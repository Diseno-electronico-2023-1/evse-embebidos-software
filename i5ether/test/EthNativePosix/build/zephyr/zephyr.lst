
zephyr.elf:     file format elf32-littleriscv


Disassembly of section rom_start:

40000000 <__start>:
#else
	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to _isr_wrapper.
	 */
	la t0, _isr_wrapper
40000000:	00000297          	auipc	t0,0x0
40000004:	01428293          	addi	t0,t0,20 # 40000014 <_isr_wrapper>
#endif

	csrw mtvec, t0
40000008:	30529073          	csrw	mtvec,t0

	/* Jump to __reset */
	tail __reset
4000000c:	0040006f          	j	40000010 <__reset>

Disassembly of section reset:

40000010 <__reset>:
	/*
	 * jump to __initialize
	 * use call opcode in case __initialize is far away.
	 * This will be dependent on linker.ld configuration.
	 */
	call __initialize
40000010:	6580c0ef          	jal	ra,4000c668 <__initialize>

Disassembly of section exceptions:

40000014 <_isr_wrapper>:

#ifdef CONFIG_RISCV_SOC_HAS_ISR_STACKING
	SOC_ISR_SW_STACKING
#else
	/* Save caller-saved registers on current thread stack. */
	addi sp, sp, -__z_arch_esf_t_SIZEOF
40000014:	fb010113          	addi	sp,sp,-80
	DO_CALLER_SAVED(sr)		;
40000018:	00512223          	sw	t0,4(sp)
4000001c:	00612423          	sw	t1,8(sp)
40000020:	00712623          	sw	t2,12(sp)
40000024:	01c12823          	sw	t3,16(sp)
40000028:	01d12a23          	sw	t4,20(sp)
4000002c:	01e12c23          	sw	t5,24(sp)
40000030:	01f12e23          	sw	t6,28(sp)
40000034:	02a12023          	sw	a0,32(sp)
40000038:	02b12223          	sw	a1,36(sp)
4000003c:	02c12423          	sw	a2,40(sp)
40000040:	02d12623          	sw	a3,44(sp)
40000044:	02e12823          	sw	a4,48(sp)
40000048:	02f12a23          	sw	a5,52(sp)
4000004c:	03012c23          	sw	a6,56(sp)
40000050:	03112e23          	sw	a7,60(sp)
40000054:	00112023          	sw	ra,0(sp)
#endif /* CONFIG_RISCV_SOC_HAS_ISR_STACKING */

	/* Save s0 in the esf and load it with &_current_cpu. */
	sr s0, __z_arch_esf_t_s0_OFFSET(sp)
40000058:	04812423          	sw	s0,72(sp)
	get_current_cpu s0
4000005c:	0003b417          	auipc	s0,0x3b
40000060:	16840413          	addi	s0,s0,360 # 4003b1c4 <_kernel>

	/* Save MEPC register */
	csrr t0, mepc
40000064:	341022f3          	csrr	t0,mepc
	sr t0, __z_arch_esf_t_mepc_OFFSET(sp)
40000068:	04512023          	sw	t0,64(sp)

	/* Save MSTATUS register */
	csrr t2, mstatus
4000006c:	300023f3          	csrr	t2,mstatus
	sr t2, __z_arch_esf_t_mstatus_OFFSET(sp)
40000070:	04712223          	sw	t2,68(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
40000074:	154000ef          	jal	ra,400001c8 <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	bnez a0, is_interrupt
40000078:	04051a63          	bnez	a0,400000cc <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
4000007c:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
40000080:	800003b7          	lui	t2,0x80000
40000084:	fff38393          	addi	t2,t2,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and t0, t0, t2
40000088:	0072f2b3          	and	t0,t0,t2

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call from
	 * kernel thread.
	 */
	li t1, SOC_MCAUSE_ECALL_EXP
4000008c:	00b00313          	li	t1,11
	beq t0, t1, is_kernel_syscall
40000090:	00628a63          	beq	t0,t1,400000a4 <is_kernel_syscall>
	 * Stack pointer is pointing to a z_arch_esf_t structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to
	 * no_reschedule to restore stack.
	 */
	mv a0, sp
40000094:	00010513          	mv	a0,sp
	la ra, no_reschedule
40000098:	00000097          	auipc	ra,0x0
4000009c:	0c408093          	addi	ra,ra,196 # 4000015c <no_reschedule>
	tail _Fault
400000a0:	3f80c06f          	j	4000c498 <_Fault>

400000a4 <is_kernel_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	lr t0, __z_arch_esf_t_mepc_OFFSET(sp)
400000a4:	04012283          	lw	t0,64(sp)
	addi t0, t0, 4
400000a8:	00428293          	addi	t0,t0,4
	sr t0, __z_arch_esf_t_mepc_OFFSET(sp)
400000ac:	04512023          	sw	t0,64(sp)
	li t1, MSTATUS_MPRV
	csrs mstatus, t1
#endif

	/* Determine what to do. Operation code is in t0. */
	lr t0, __z_arch_esf_t_t0_OFFSET(sp)
400000b0:	00412283          	lw	t0,4(sp)

	.if RV_ECALL_RUNTIME_EXCEPT != 0; .err; .endif
	beqz t0, do_fault
400000b4:	00028663          	beqz	t0,400000c0 <do_fault>
	j reschedule
skip_schedule:
#endif

	/* default fault code is K_ERR_KERNEL_OOPS */
	li a0, 3
400000b8:	00300513          	li	a0,3
	j 1f
400000bc:	0080006f          	j	400000c4 <do_fault+0x4>

400000c0 <do_fault>:

do_fault:
	/* Handle RV_ECALL_RUNTIME_EXCEPT. Retrieve reason in a0, esf in A1. */
	lr a0, __z_arch_esf_t_a0_OFFSET(sp)
400000c0:	02012503          	lw	a0,32(sp)
1:	mv a1, sp
400000c4:	00010593          	mv	a1,sp
	tail z_riscv_fatal_error
400000c8:	03c0c06f          	j	4000c104 <z_riscv_fatal_error>

400000cc <is_interrupt>:
	csrs mstatus, t1
2:
#endif

	/* Increment _current_cpu->nested */
	lw t1, ___cpu_t_nested_OFFSET(s0)
400000cc:	00042303          	lw	t1,0(s0)
	addi t2, t1, 1
400000d0:	00130393          	addi	t2,t1,1
	sw t2, ___cpu_t_nested_OFFSET(s0)
400000d4:	00742023          	sw	t2,0(s0)
	bnez t1, on_irq_stack
400000d8:	00031a63          	bnez	t1,400000ec <on_irq_stack>

	/* Switch to interrupt stack */
	mv t0, sp
400000dc:	00010293          	mv	t0,sp
	lr sp, ___cpu_t_irq_stack_OFFSET(s0)
400000e0:	00442103          	lw	sp,4(s0)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
400000e4:	ff010113          	addi	sp,sp,-16
	sr t0, 0(sp)
400000e8:	00512023          	sw	t0,0(sp)

400000ec <on_irq_stack>:
#ifdef CONFIG_TRACING_ISR
	call sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
400000ec:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
400000f0:	800002b7          	lui	t0,0x80000
400000f4:	fff28293          	addi	t0,t0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and a0, a0, t0
400000f8:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
400000fc:	0bc000ef          	jal	ra,400001b8 <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 2-word wide, we should shift index accordingly)
	 */
	la t0, _sw_isr_table
40000100:	00032297          	auipc	t0,0x32
40000104:	27428293          	addi	t0,t0,628 # 40032374 <_sw_isr_table>
	slli a0, a0, (RV_REGSHIFT + 1)
40000108:	00351513          	slli	a0,a0,0x3
	add t0, t0, a0
4000010c:	00a282b3          	add	t0,t0,a0

	/* Load argument in a0 register */
	lr a0, 0(t0)
40000110:	0002a503          	lw	a0,0(t0)

	/* Load ISR function address in register t1 */
	lr t1, RV_REGSIZE(t0)
40000114:	0042a303          	lw	t1,4(t0)

	/* Call ISR function */
	jalr ra, t1, 0
40000118:	000300e7          	jalr	t1

4000011c <irq_done>:
	call sys_trace_isr_exit
#endif

irq_done:
	/* Decrement _current_cpu->nested */
	lw t2, ___cpu_t_nested_OFFSET(s0)
4000011c:	00042383          	lw	t2,0(s0)
	addi t2, t2, -1
40000120:	fff38393          	addi	t2,t2,-1
	sw t2, ___cpu_t_nested_OFFSET(s0)
40000124:	00742023          	sw	t2,0(s0)
	bnez t2, no_reschedule
40000128:	02039a63          	bnez	t2,4000015c <no_reschedule>

	/* nested count is back to 0: Return to thread stack */
	lr sp, 0(sp)
4000012c:	00012103          	lw	sp,0(sp)

40000130 <check_reschedule>:
#endif

check_reschedule:

	/* Get pointer to current thread on this CPU */
	lr a1, ___cpu_t_current_OFFSET(s0)
40000130:	00842583          	lw	a1,8(s0)
	/*
	 * Get next thread to schedule with z_get_next_switch_handle().
	 * We pass it a NULL as we didn't save the whole thread context yet.
	 * If no scheduling is necessary then NULL will be returned.
	 */
	addi sp, sp, -16
40000134:	ff010113          	addi	sp,sp,-16
	sr a1, 0(sp)
40000138:	00b12023          	sw	a1,0(sp)
	mv a0, zero
4000013c:	00000513          	li	a0,0
	call z_get_next_switch_handle
40000140:	379300ef          	jal	ra,40030cb8 <z_get_next_switch_handle>
	lr a1, 0(sp)
40000144:	00012583          	lw	a1,0(sp)
	addi sp, sp, 16
40000148:	01010113          	addi	sp,sp,16
	beqz a0, no_reschedule
4000014c:	00050863          	beqz	a0,4000015c <no_reschedule>

40000150 <reschedule>:
	/*
	 * Perform context switch:
	 * a0 = new thread
	 * a1 = old thread
	 */
	call z_riscv_switch
40000150:	5740c0ef          	jal	ra,4000c6c4 <z_riscv_switch>

40000154 <z_riscv_thread_start>:

z_riscv_thread_start:
might_have_rescheduled:
	/* reload s0 with &_current_cpu as it might have changed or be unset */
	get_current_cpu s0
40000154:	0003b417          	auipc	s0,0x3b
40000158:	07040413          	addi	s0,s0,112 # 4003b1c4 <_kernel>

4000015c <no_reschedule>:
	sb t1, _thread_offset_to_exception_depth(t0)
fp_trap_exit:
#endif

	/* Restore MEPC and MSTATUS registers */
	lr t0, __z_arch_esf_t_mepc_OFFSET(sp)
4000015c:	04012283          	lw	t0,64(sp)
	lr t2, __z_arch_esf_t_mstatus_OFFSET(sp)
40000160:	04412383          	lw	t2,68(sp)
	csrw mepc, t0
40000164:	34129073          	csrw	mepc,t0
	csrw mstatus, t2
40000168:	30039073          	csrw	mstatus,t2
	sr t0, __z_arch_esf_t_sp_OFFSET(sp)
2:
#endif

	/* Restore s0 (it is no longer ours) */
	lr s0, __z_arch_esf_t_s0_OFFSET(sp)
4000016c:	04812403          	lw	s0,72(sp)

#ifdef CONFIG_RISCV_SOC_HAS_ISR_STACKING
	SOC_ISR_SW_UNSTACKING
#else
	/* Restore caller-saved registers from thread stack */
	DO_CALLER_SAVED(lr)
40000170:	00412283          	lw	t0,4(sp)
40000174:	00812303          	lw	t1,8(sp)
40000178:	00c12383          	lw	t2,12(sp)
4000017c:	01012e03          	lw	t3,16(sp)
40000180:	01412e83          	lw	t4,20(sp)
40000184:	01812f03          	lw	t5,24(sp)
40000188:	01c12f83          	lw	t6,28(sp)
4000018c:	02012503          	lw	a0,32(sp)
40000190:	02412583          	lw	a1,36(sp)
40000194:	02812603          	lw	a2,40(sp)
40000198:	02c12683          	lw	a3,44(sp)
4000019c:	03012703          	lw	a4,48(sp)
400001a0:	03412783          	lw	a5,52(sp)
400001a4:	03812803          	lw	a6,56(sp)
400001a8:	03c12883          	lw	a7,60(sp)
400001ac:	00012083          	lw	ra,0(sp)
#ifdef CONFIG_USERSPACE
	/* retrieve saved stack pointer */
	lr sp, __z_arch_esf_t_sp_OFFSET(sp)
#else
	/* remove esf from the stack */
	addi sp, sp, __z_arch_esf_t_SIZEOF
400001b0:	05010113          	addi	sp,sp,80
#endif

#endif /* CONFIG_RISCV_SOC_HAS_ISR_STACKING */

	mret
400001b4:	30200073          	mret

400001b8 <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
400001b8:	00100313          	li	t1,1
	sll t0, t1, a0
400001bc:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
400001c0:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	ret
400001c4:	00008067          	ret

400001c8 <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
400001c8:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
400001cc:	80000337          	lui	t1,0x80000
	and t0, t0, t1
400001d0:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
400001d4:	00000513          	li	a0,0
	beqz t0, not_interrupt
400001d8:	00028463          	beqz	t0,400001e0 <not_interrupt>
	addi a0, a0, 1
400001dc:	00150513          	addi	a0,a0,1

400001e0 <not_interrupt>:

not_interrupt:
	/* return */
	ret
400001e0:	00008067          	ret

Disassembly of section text:

400001e4 <__ashldi3>:
400001e4:	02060063          	beqz	a2,40000204 <__ashldi3+0x20>
400001e8:	02000793          	li	a5,32
400001ec:	40c787b3          	sub	a5,a5,a2
400001f0:	00f04c63          	bgtz	a5,40000208 <__ashldi3+0x24>
400001f4:	fe060613          	addi	a2,a2,-32
400001f8:	00c515b3          	sll	a1,a0,a2
400001fc:	00000713          	li	a4,0
40000200:	00070513          	mv	a0,a4
40000204:	00008067          	ret
40000208:	00c51733          	sll	a4,a0,a2
4000020c:	00c595b3          	sll	a1,a1,a2
40000210:	00f55533          	srl	a0,a0,a5
40000214:	00a5e5b3          	or	a1,a1,a0
40000218:	fe9ff06f          	j	40000200 <__ashldi3+0x1c>

4000021c <__clzsi2>:
4000021c:	000107b7          	lui	a5,0x10
40000220:	02f57a63          	bgeu	a0,a5,40000254 <__clzsi2+0x38>
40000224:	10053793          	sltiu	a5,a0,256
40000228:	0017c793          	xori	a5,a5,1
4000022c:	00379793          	slli	a5,a5,0x3
40000230:	40032737          	lui	a4,0x40032
40000234:	02000693          	li	a3,32
40000238:	40f686b3          	sub	a3,a3,a5
4000023c:	00f55533          	srl	a0,a0,a5
40000240:	6f070793          	addi	a5,a4,1776 # 400326f0 <__clz_tab>
40000244:	00a787b3          	add	a5,a5,a0
40000248:	0007c503          	lbu	a0,0(a5) # 10000 <__kernel_ram_size+0x44f8>
4000024c:	40a68533          	sub	a0,a3,a0
40000250:	00008067          	ret
40000254:	01000737          	lui	a4,0x1000
40000258:	01000793          	li	a5,16
4000025c:	fce56ae3          	bltu	a0,a4,40000230 <__clzsi2+0x14>
40000260:	01800793          	li	a5,24
40000264:	fcdff06f          	j	40000230 <__clzsi2+0x14>

40000268 <__ctzsi2>:
40000268:	40a007b3          	neg	a5,a0
4000026c:	00a7f533          	and	a0,a5,a0
40000270:	000107b7          	lui	a5,0x10
40000274:	02f57863          	bgeu	a0,a5,400002a4 <__ctzsi2+0x3c>
40000278:	10053793          	sltiu	a5,a0,256
4000027c:	0017c793          	xori	a5,a5,1
40000280:	00379793          	slli	a5,a5,0x3
40000284:	40032737          	lui	a4,0x40032
40000288:	00f55533          	srl	a0,a0,a5
4000028c:	6f070713          	addi	a4,a4,1776 # 400326f0 <__clz_tab>
40000290:	00a70733          	add	a4,a4,a0
40000294:	00074503          	lbu	a0,0(a4)
40000298:	fff78793          	addi	a5,a5,-1 # ffff <__kernel_ram_size+0x44f7>
4000029c:	00f50533          	add	a0,a0,a5
400002a0:	00008067          	ret
400002a4:	01000737          	lui	a4,0x1000
400002a8:	01000793          	li	a5,16
400002ac:	fce56ce3          	bltu	a0,a4,40000284 <__ctzsi2+0x1c>
400002b0:	01800793          	li	a5,24
400002b4:	fd1ff06f          	j	40000284 <__ctzsi2+0x1c>

400002b8 <__udivdi3>:
400002b8:	00050893          	mv	a7,a0
400002bc:	00058313          	mv	t1,a1
400002c0:	00060713          	mv	a4,a2
400002c4:	00050813          	mv	a6,a0
400002c8:	00058793          	mv	a5,a1
400002cc:	28069263          	bnez	a3,40000550 <__udivdi3+0x298>
400002d0:	400325b7          	lui	a1,0x40032
400002d4:	6f058593          	addi	a1,a1,1776 # 400326f0 <__clz_tab>
400002d8:	0ec37663          	bgeu	t1,a2,400003c4 <__udivdi3+0x10c>
400002dc:	000106b7          	lui	a3,0x10
400002e0:	0cd67863          	bgeu	a2,a3,400003b0 <__udivdi3+0xf8>
400002e4:	10063693          	sltiu	a3,a2,256
400002e8:	0016c693          	xori	a3,a3,1
400002ec:	00369693          	slli	a3,a3,0x3
400002f0:	00d65533          	srl	a0,a2,a3
400002f4:	00a585b3          	add	a1,a1,a0
400002f8:	0005c583          	lbu	a1,0(a1)
400002fc:	02000513          	li	a0,32
40000300:	00d586b3          	add	a3,a1,a3
40000304:	40d505b3          	sub	a1,a0,a3
40000308:	00d50c63          	beq	a0,a3,40000320 <__udivdi3+0x68>
4000030c:	00b317b3          	sll	a5,t1,a1
40000310:	00d8d6b3          	srl	a3,a7,a3
40000314:	00b61733          	sll	a4,a2,a1
40000318:	00f6e7b3          	or	a5,a3,a5
4000031c:	00b89833          	sll	a6,a7,a1
40000320:	01075593          	srli	a1,a4,0x10
40000324:	02b7d333          	divu	t1,a5,a1
40000328:	01071613          	slli	a2,a4,0x10
4000032c:	01065613          	srli	a2,a2,0x10
40000330:	02b7f7b3          	remu	a5,a5,a1
40000334:	00030513          	mv	a0,t1
40000338:	026608b3          	mul	a7,a2,t1
4000033c:	01079693          	slli	a3,a5,0x10
40000340:	01085793          	srli	a5,a6,0x10
40000344:	00d7e7b3          	or	a5,a5,a3
40000348:	0117fe63          	bgeu	a5,a7,40000364 <__udivdi3+0xac>
4000034c:	00f707b3          	add	a5,a4,a5
40000350:	fff30513          	addi	a0,t1,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
40000354:	00e7e863          	bltu	a5,a4,40000364 <__udivdi3+0xac>
40000358:	0117f663          	bgeu	a5,a7,40000364 <__udivdi3+0xac>
4000035c:	ffe30513          	addi	a0,t1,-2
40000360:	00e787b3          	add	a5,a5,a4
40000364:	411787b3          	sub	a5,a5,a7
40000368:	02b7d8b3          	divu	a7,a5,a1
4000036c:	01081813          	slli	a6,a6,0x10
40000370:	01085813          	srli	a6,a6,0x10
40000374:	02b7f7b3          	remu	a5,a5,a1
40000378:	031606b3          	mul	a3,a2,a7
4000037c:	01079793          	slli	a5,a5,0x10
40000380:	00f86833          	or	a6,a6,a5
40000384:	00088793          	mv	a5,a7
40000388:	00d87c63          	bgeu	a6,a3,400003a0 <__udivdi3+0xe8>
4000038c:	01070833          	add	a6,a4,a6
40000390:	fff88793          	addi	a5,a7,-1
40000394:	00e86663          	bltu	a6,a4,400003a0 <__udivdi3+0xe8>
40000398:	00d87463          	bgeu	a6,a3,400003a0 <__udivdi3+0xe8>
4000039c:	ffe88793          	addi	a5,a7,-2
400003a0:	01051513          	slli	a0,a0,0x10
400003a4:	00f56533          	or	a0,a0,a5
400003a8:	00000593          	li	a1,0
400003ac:	00008067          	ret
400003b0:	01000537          	lui	a0,0x1000
400003b4:	01000693          	li	a3,16
400003b8:	f2a66ce3          	bltu	a2,a0,400002f0 <__udivdi3+0x38>
400003bc:	01800693          	li	a3,24
400003c0:	f31ff06f          	j	400002f0 <__udivdi3+0x38>
400003c4:	00000693          	li	a3,0
400003c8:	00060c63          	beqz	a2,400003e0 <__udivdi3+0x128>
400003cc:	000107b7          	lui	a5,0x10
400003d0:	0cf67063          	bgeu	a2,a5,40000490 <__udivdi3+0x1d8>
400003d4:	10063693          	sltiu	a3,a2,256
400003d8:	0016c693          	xori	a3,a3,1
400003dc:	00369693          	slli	a3,a3,0x3
400003e0:	00d657b3          	srl	a5,a2,a3
400003e4:	00f585b3          	add	a1,a1,a5
400003e8:	0005c783          	lbu	a5,0(a1)
400003ec:	00d787b3          	add	a5,a5,a3
400003f0:	02000693          	li	a3,32
400003f4:	40f685b3          	sub	a1,a3,a5
400003f8:	0af69663          	bne	a3,a5,400004a4 <__udivdi3+0x1ec>
400003fc:	40c307b3          	sub	a5,t1,a2
40000400:	00100593          	li	a1,1
40000404:	01075893          	srli	a7,a4,0x10
40000408:	0317de33          	divu	t3,a5,a7
4000040c:	01071613          	slli	a2,a4,0x10
40000410:	01065613          	srli	a2,a2,0x10
40000414:	01085693          	srli	a3,a6,0x10
40000418:	0317f7b3          	remu	a5,a5,a7
4000041c:	000e0513          	mv	a0,t3
40000420:	03c60333          	mul	t1,a2,t3
40000424:	01079793          	slli	a5,a5,0x10
40000428:	00f6e7b3          	or	a5,a3,a5
4000042c:	0067fe63          	bgeu	a5,t1,40000448 <__udivdi3+0x190>
40000430:	00f707b3          	add	a5,a4,a5
40000434:	fffe0513          	addi	a0,t3,-1
40000438:	00e7e863          	bltu	a5,a4,40000448 <__udivdi3+0x190>
4000043c:	0067f663          	bgeu	a5,t1,40000448 <__udivdi3+0x190>
40000440:	ffee0513          	addi	a0,t3,-2
40000444:	00e787b3          	add	a5,a5,a4
40000448:	406787b3          	sub	a5,a5,t1
4000044c:	0317d333          	divu	t1,a5,a7
40000450:	01081813          	slli	a6,a6,0x10
40000454:	01085813          	srli	a6,a6,0x10
40000458:	0317f7b3          	remu	a5,a5,a7
4000045c:	026606b3          	mul	a3,a2,t1
40000460:	01079793          	slli	a5,a5,0x10
40000464:	00f86833          	or	a6,a6,a5
40000468:	00030793          	mv	a5,t1
4000046c:	00d87c63          	bgeu	a6,a3,40000484 <__udivdi3+0x1cc>
40000470:	01070833          	add	a6,a4,a6
40000474:	fff30793          	addi	a5,t1,-1
40000478:	00e86663          	bltu	a6,a4,40000484 <__udivdi3+0x1cc>
4000047c:	00d87463          	bgeu	a6,a3,40000484 <__udivdi3+0x1cc>
40000480:	ffe30793          	addi	a5,t1,-2
40000484:	01051513          	slli	a0,a0,0x10
40000488:	00f56533          	or	a0,a0,a5
4000048c:	00008067          	ret
40000490:	010007b7          	lui	a5,0x1000
40000494:	01000693          	li	a3,16
40000498:	f4f664e3          	bltu	a2,a5,400003e0 <__udivdi3+0x128>
4000049c:	01800693          	li	a3,24
400004a0:	f41ff06f          	j	400003e0 <__udivdi3+0x128>
400004a4:	00b61733          	sll	a4,a2,a1
400004a8:	00f356b3          	srl	a3,t1,a5
400004ac:	01075513          	srli	a0,a4,0x10
400004b0:	00b31333          	sll	t1,t1,a1
400004b4:	00f8d7b3          	srl	a5,a7,a5
400004b8:	0067e7b3          	or	a5,a5,t1
400004bc:	02a6d333          	divu	t1,a3,a0
400004c0:	01071613          	slli	a2,a4,0x10
400004c4:	01065613          	srli	a2,a2,0x10
400004c8:	00b89833          	sll	a6,a7,a1
400004cc:	02a6f6b3          	remu	a3,a3,a0
400004d0:	026608b3          	mul	a7,a2,t1
400004d4:	01069593          	slli	a1,a3,0x10
400004d8:	0107d693          	srli	a3,a5,0x10
400004dc:	00b6e6b3          	or	a3,a3,a1
400004e0:	00030593          	mv	a1,t1
400004e4:	0116fe63          	bgeu	a3,a7,40000500 <__udivdi3+0x248>
400004e8:	00d706b3          	add	a3,a4,a3
400004ec:	fff30593          	addi	a1,t1,-1
400004f0:	00e6e863          	bltu	a3,a4,40000500 <__udivdi3+0x248>
400004f4:	0116f663          	bgeu	a3,a7,40000500 <__udivdi3+0x248>
400004f8:	ffe30593          	addi	a1,t1,-2
400004fc:	00e686b3          	add	a3,a3,a4
40000500:	411686b3          	sub	a3,a3,a7
40000504:	02a6d8b3          	divu	a7,a3,a0
40000508:	01079793          	slli	a5,a5,0x10
4000050c:	0107d793          	srli	a5,a5,0x10
40000510:	02a6f6b3          	remu	a3,a3,a0
40000514:	03160633          	mul	a2,a2,a7
40000518:	01069693          	slli	a3,a3,0x10
4000051c:	00d7e7b3          	or	a5,a5,a3
40000520:	00088693          	mv	a3,a7
40000524:	00c7fe63          	bgeu	a5,a2,40000540 <__udivdi3+0x288>
40000528:	00f707b3          	add	a5,a4,a5
4000052c:	fff88693          	addi	a3,a7,-1
40000530:	00e7e863          	bltu	a5,a4,40000540 <__udivdi3+0x288>
40000534:	00c7f663          	bgeu	a5,a2,40000540 <__udivdi3+0x288>
40000538:	ffe88693          	addi	a3,a7,-2
4000053c:	00e787b3          	add	a5,a5,a4
40000540:	01059593          	slli	a1,a1,0x10
40000544:	40c787b3          	sub	a5,a5,a2
40000548:	00d5e5b3          	or	a1,a1,a3
4000054c:	eb9ff06f          	j	40000404 <__udivdi3+0x14c>
40000550:	18d5e663          	bltu	a1,a3,400006dc <__udivdi3+0x424>
40000554:	000107b7          	lui	a5,0x10
40000558:	04f6f463          	bgeu	a3,a5,400005a0 <__udivdi3+0x2e8>
4000055c:	1006b713          	sltiu	a4,a3,256
40000560:	00174713          	xori	a4,a4,1
40000564:	00371713          	slli	a4,a4,0x3
40000568:	400327b7          	lui	a5,0x40032
4000056c:	00e6d5b3          	srl	a1,a3,a4
40000570:	6f078793          	addi	a5,a5,1776 # 400326f0 <__clz_tab>
40000574:	00b787b3          	add	a5,a5,a1
40000578:	0007c783          	lbu	a5,0(a5)
4000057c:	00e787b3          	add	a5,a5,a4
40000580:	02000713          	li	a4,32
40000584:	40f705b3          	sub	a1,a4,a5
40000588:	02f71663          	bne	a4,a5,400005b4 <__udivdi3+0x2fc>
4000058c:	00100513          	li	a0,1
40000590:	e066eee3          	bltu	a3,t1,400003ac <__udivdi3+0xf4>
40000594:	00c8b533          	sltu	a0,a7,a2
40000598:	00154513          	xori	a0,a0,1
4000059c:	00008067          	ret
400005a0:	010007b7          	lui	a5,0x1000
400005a4:	01000713          	li	a4,16
400005a8:	fcf6e0e3          	bltu	a3,a5,40000568 <__udivdi3+0x2b0>
400005ac:	01800713          	li	a4,24
400005b0:	fb9ff06f          	j	40000568 <__udivdi3+0x2b0>
400005b4:	00f65733          	srl	a4,a2,a5
400005b8:	00b696b3          	sll	a3,a3,a1
400005bc:	00d766b3          	or	a3,a4,a3
400005c0:	00f35733          	srl	a4,t1,a5
400005c4:	00b31333          	sll	t1,t1,a1
400005c8:	00f8d7b3          	srl	a5,a7,a5
400005cc:	0067e7b3          	or	a5,a5,t1
400005d0:	0106d313          	srli	t1,a3,0x10
400005d4:	02675eb3          	divu	t4,a4,t1
400005d8:	01069813          	slli	a6,a3,0x10
400005dc:	01085813          	srli	a6,a6,0x10
400005e0:	00b61633          	sll	a2,a2,a1
400005e4:	02677733          	remu	a4,a4,t1
400005e8:	03d80e33          	mul	t3,a6,t4
400005ec:	01071513          	slli	a0,a4,0x10
400005f0:	0107d713          	srli	a4,a5,0x10
400005f4:	00a76733          	or	a4,a4,a0
400005f8:	000e8513          	mv	a0,t4
400005fc:	01c77e63          	bgeu	a4,t3,40000618 <__udivdi3+0x360>
40000600:	00e68733          	add	a4,a3,a4
40000604:	fffe8513          	addi	a0,t4,-1
40000608:	00d76863          	bltu	a4,a3,40000618 <__udivdi3+0x360>
4000060c:	01c77663          	bgeu	a4,t3,40000618 <__udivdi3+0x360>
40000610:	ffee8513          	addi	a0,t4,-2
40000614:	00d70733          	add	a4,a4,a3
40000618:	41c70733          	sub	a4,a4,t3
4000061c:	02675e33          	divu	t3,a4,t1
40000620:	01079793          	slli	a5,a5,0x10
40000624:	0107d793          	srli	a5,a5,0x10
40000628:	02677733          	remu	a4,a4,t1
4000062c:	03c80833          	mul	a6,a6,t3
40000630:	01071713          	slli	a4,a4,0x10
40000634:	00e7e7b3          	or	a5,a5,a4
40000638:	000e0713          	mv	a4,t3
4000063c:	0107fe63          	bgeu	a5,a6,40000658 <__udivdi3+0x3a0>
40000640:	00f687b3          	add	a5,a3,a5
40000644:	fffe0713          	addi	a4,t3,-1
40000648:	00d7e863          	bltu	a5,a3,40000658 <__udivdi3+0x3a0>
4000064c:	0107f663          	bgeu	a5,a6,40000658 <__udivdi3+0x3a0>
40000650:	ffee0713          	addi	a4,t3,-2
40000654:	00d787b3          	add	a5,a5,a3
40000658:	01051513          	slli	a0,a0,0x10
4000065c:	00010e37          	lui	t3,0x10
40000660:	00e56533          	or	a0,a0,a4
40000664:	fffe0693          	addi	a3,t3,-1 # ffff <__kernel_ram_size+0x44f7>
40000668:	00d57733          	and	a4,a0,a3
4000066c:	410787b3          	sub	a5,a5,a6
40000670:	00d676b3          	and	a3,a2,a3
40000674:	01055813          	srli	a6,a0,0x10
40000678:	01065613          	srli	a2,a2,0x10
4000067c:	02d70333          	mul	t1,a4,a3
40000680:	02d806b3          	mul	a3,a6,a3
40000684:	02c70733          	mul	a4,a4,a2
40000688:	02c80833          	mul	a6,a6,a2
4000068c:	00d70633          	add	a2,a4,a3
40000690:	01035713          	srli	a4,t1,0x10
40000694:	00c70733          	add	a4,a4,a2
40000698:	00d77463          	bgeu	a4,a3,400006a0 <__udivdi3+0x3e8>
4000069c:	01c80833          	add	a6,a6,t3
400006a0:	01075693          	srli	a3,a4,0x10
400006a4:	010686b3          	add	a3,a3,a6
400006a8:	02d7e663          	bltu	a5,a3,400006d4 <__udivdi3+0x41c>
400006ac:	ced79ee3          	bne	a5,a3,400003a8 <__udivdi3+0xf0>
400006b0:	000107b7          	lui	a5,0x10
400006b4:	fff78793          	addi	a5,a5,-1 # ffff <__kernel_ram_size+0x44f7>
400006b8:	00f77733          	and	a4,a4,a5
400006bc:	01071713          	slli	a4,a4,0x10
400006c0:	00f37333          	and	t1,t1,a5
400006c4:	00b898b3          	sll	a7,a7,a1
400006c8:	00670733          	add	a4,a4,t1
400006cc:	00000593          	li	a1,0
400006d0:	cce8fee3          	bgeu	a7,a4,400003ac <__udivdi3+0xf4>
400006d4:	fff50513          	addi	a0,a0,-1 # ffffff <__rom_region_size+0xfc7043>
400006d8:	cd1ff06f          	j	400003a8 <__udivdi3+0xf0>
400006dc:	00000593          	li	a1,0
400006e0:	00000513          	li	a0,0
400006e4:	00008067          	ret

400006e8 <__umoddi3>:
400006e8:	00060813          	mv	a6,a2
400006ec:	00050793          	mv	a5,a0
400006f0:	00058713          	mv	a4,a1
400006f4:	20069663          	bnez	a3,40000900 <__umoddi3+0x218>
400006f8:	400328b7          	lui	a7,0x40032
400006fc:	6f088893          	addi	a7,a7,1776 # 400326f0 <__clz_tab>
40000700:	0cc5fc63          	bgeu	a1,a2,400007d8 <__umoddi3+0xf0>
40000704:	000106b7          	lui	a3,0x10
40000708:	0ad67e63          	bgeu	a2,a3,400007c4 <__umoddi3+0xdc>
4000070c:	10063693          	sltiu	a3,a2,256
40000710:	0016c693          	xori	a3,a3,1
40000714:	00369693          	slli	a3,a3,0x3
40000718:	00d65333          	srl	t1,a2,a3
4000071c:	006888b3          	add	a7,a7,t1
40000720:	0008c883          	lbu	a7,0(a7)
40000724:	02000313          	li	t1,32
40000728:	00d886b3          	add	a3,a7,a3
4000072c:	40d308b3          	sub	a7,t1,a3
40000730:	00d30c63          	beq	t1,a3,40000748 <__umoddi3+0x60>
40000734:	01159733          	sll	a4,a1,a7
40000738:	00d556b3          	srl	a3,a0,a3
4000073c:	01161833          	sll	a6,a2,a7
40000740:	00e6e733          	or	a4,a3,a4
40000744:	011517b3          	sll	a5,a0,a7
40000748:	01085613          	srli	a2,a6,0x10
4000074c:	02c756b3          	divu	a3,a4,a2
40000750:	01081513          	slli	a0,a6,0x10
40000754:	01055513          	srli	a0,a0,0x10
40000758:	02c77733          	remu	a4,a4,a2
4000075c:	02a686b3          	mul	a3,a3,a0
40000760:	01071593          	slli	a1,a4,0x10
40000764:	0107d713          	srli	a4,a5,0x10
40000768:	00b76733          	or	a4,a4,a1
4000076c:	00d77a63          	bgeu	a4,a3,40000780 <__umoddi3+0x98>
40000770:	00e80733          	add	a4,a6,a4
40000774:	01076663          	bltu	a4,a6,40000780 <__umoddi3+0x98>
40000778:	00d77463          	bgeu	a4,a3,40000780 <__umoddi3+0x98>
4000077c:	01070733          	add	a4,a4,a6
40000780:	40d70733          	sub	a4,a4,a3
40000784:	02c756b3          	divu	a3,a4,a2
40000788:	02c77733          	remu	a4,a4,a2
4000078c:	02a686b3          	mul	a3,a3,a0
40000790:	01079793          	slli	a5,a5,0x10
40000794:	01071713          	slli	a4,a4,0x10
40000798:	0107d793          	srli	a5,a5,0x10
4000079c:	00e7e7b3          	or	a5,a5,a4
400007a0:	00d7fa63          	bgeu	a5,a3,400007b4 <__umoddi3+0xcc>
400007a4:	00f807b3          	add	a5,a6,a5
400007a8:	0107e663          	bltu	a5,a6,400007b4 <__umoddi3+0xcc>
400007ac:	00d7f463          	bgeu	a5,a3,400007b4 <__umoddi3+0xcc>
400007b0:	010787b3          	add	a5,a5,a6
400007b4:	40d787b3          	sub	a5,a5,a3
400007b8:	0117d533          	srl	a0,a5,a7
400007bc:	00000593          	li	a1,0
400007c0:	00008067          	ret
400007c4:	01000337          	lui	t1,0x1000
400007c8:	01000693          	li	a3,16
400007cc:	f46666e3          	bltu	a2,t1,40000718 <__umoddi3+0x30>
400007d0:	01800693          	li	a3,24
400007d4:	f45ff06f          	j	40000718 <__umoddi3+0x30>
400007d8:	00000693          	li	a3,0
400007dc:	00060c63          	beqz	a2,400007f4 <__umoddi3+0x10c>
400007e0:	00010737          	lui	a4,0x10
400007e4:	06e67e63          	bgeu	a2,a4,40000860 <__umoddi3+0x178>
400007e8:	10063693          	sltiu	a3,a2,256
400007ec:	0016c693          	xori	a3,a3,1
400007f0:	00369693          	slli	a3,a3,0x3
400007f4:	00d65733          	srl	a4,a2,a3
400007f8:	00e888b3          	add	a7,a7,a4
400007fc:	0008c703          	lbu	a4,0(a7)
40000800:	00d70733          	add	a4,a4,a3
40000804:	02000693          	li	a3,32
40000808:	40e688b3          	sub	a7,a3,a4
4000080c:	06e69463          	bne	a3,a4,40000874 <__umoddi3+0x18c>
40000810:	40c58733          	sub	a4,a1,a2
40000814:	01085593          	srli	a1,a6,0x10
40000818:	02b75633          	divu	a2,a4,a1
4000081c:	01081513          	slli	a0,a6,0x10
40000820:	01055513          	srli	a0,a0,0x10
40000824:	0107d693          	srli	a3,a5,0x10
40000828:	02b77733          	remu	a4,a4,a1
4000082c:	02a60633          	mul	a2,a2,a0
40000830:	01071713          	slli	a4,a4,0x10
40000834:	00e6e733          	or	a4,a3,a4
40000838:	00c77a63          	bgeu	a4,a2,4000084c <__umoddi3+0x164>
4000083c:	00e80733          	add	a4,a6,a4
40000840:	01076663          	bltu	a4,a6,4000084c <__umoddi3+0x164>
40000844:	00c77463          	bgeu	a4,a2,4000084c <__umoddi3+0x164>
40000848:	01070733          	add	a4,a4,a6
4000084c:	40c70733          	sub	a4,a4,a2
40000850:	02b756b3          	divu	a3,a4,a1
40000854:	02b77733          	remu	a4,a4,a1
40000858:	02a686b3          	mul	a3,a3,a0
4000085c:	f35ff06f          	j	40000790 <__umoddi3+0xa8>
40000860:	01000737          	lui	a4,0x1000
40000864:	01000693          	li	a3,16
40000868:	f8e666e3          	bltu	a2,a4,400007f4 <__umoddi3+0x10c>
4000086c:	01800693          	li	a3,24
40000870:	f85ff06f          	j	400007f4 <__umoddi3+0x10c>
40000874:	01161833          	sll	a6,a2,a7
40000878:	00e5d6b3          	srl	a3,a1,a4
4000087c:	011517b3          	sll	a5,a0,a7
40000880:	011595b3          	sll	a1,a1,a7
40000884:	00e55733          	srl	a4,a0,a4
40000888:	01085513          	srli	a0,a6,0x10
4000088c:	00b76733          	or	a4,a4,a1
40000890:	02a6d5b3          	divu	a1,a3,a0
40000894:	01081313          	slli	t1,a6,0x10
40000898:	01035313          	srli	t1,t1,0x10
4000089c:	02a6f6b3          	remu	a3,a3,a0
400008a0:	026585b3          	mul	a1,a1,t1
400008a4:	01069613          	slli	a2,a3,0x10
400008a8:	01075693          	srli	a3,a4,0x10
400008ac:	00c6e6b3          	or	a3,a3,a2
400008b0:	00b6fa63          	bgeu	a3,a1,400008c4 <__umoddi3+0x1dc>
400008b4:	00d806b3          	add	a3,a6,a3
400008b8:	0106e663          	bltu	a3,a6,400008c4 <__umoddi3+0x1dc>
400008bc:	00b6f463          	bgeu	a3,a1,400008c4 <__umoddi3+0x1dc>
400008c0:	010686b3          	add	a3,a3,a6
400008c4:	40b686b3          	sub	a3,a3,a1
400008c8:	02a6d633          	divu	a2,a3,a0
400008cc:	01071713          	slli	a4,a4,0x10
400008d0:	01075713          	srli	a4,a4,0x10
400008d4:	02a6f6b3          	remu	a3,a3,a0
400008d8:	02660633          	mul	a2,a2,t1
400008dc:	01069693          	slli	a3,a3,0x10
400008e0:	00d76733          	or	a4,a4,a3
400008e4:	00c77a63          	bgeu	a4,a2,400008f8 <__umoddi3+0x210>
400008e8:	00e80733          	add	a4,a6,a4
400008ec:	01076663          	bltu	a4,a6,400008f8 <__umoddi3+0x210>
400008f0:	00c77463          	bgeu	a4,a2,400008f8 <__umoddi3+0x210>
400008f4:	01070733          	add	a4,a4,a6
400008f8:	40c70733          	sub	a4,a4,a2
400008fc:	f19ff06f          	j	40000814 <__umoddi3+0x12c>
40000900:	1cd5e463          	bltu	a1,a3,40000ac8 <__umoddi3+0x3e0>
40000904:	00010837          	lui	a6,0x10
40000908:	0506fe63          	bgeu	a3,a6,40000964 <__umoddi3+0x27c>
4000090c:	1006b813          	sltiu	a6,a3,256
40000910:	00184813          	xori	a6,a6,1
40000914:	00381813          	slli	a6,a6,0x3
40000918:	400328b7          	lui	a7,0x40032
4000091c:	0106d333          	srl	t1,a3,a6
40000920:	6f088893          	addi	a7,a7,1776 # 400326f0 <__clz_tab>
40000924:	006888b3          	add	a7,a7,t1
40000928:	0008c883          	lbu	a7,0(a7)
4000092c:	02000313          	li	t1,32
40000930:	010888b3          	add	a7,a7,a6
40000934:	41130833          	sub	a6,t1,a7
40000938:	05131063          	bne	t1,a7,40000978 <__umoddi3+0x290>
4000093c:	00b6e463          	bltu	a3,a1,40000944 <__umoddi3+0x25c>
40000940:	00c56c63          	bltu	a0,a2,40000958 <__umoddi3+0x270>
40000944:	40c50633          	sub	a2,a0,a2
40000948:	40d586b3          	sub	a3,a1,a3
4000094c:	00c53733          	sltu	a4,a0,a2
40000950:	00060793          	mv	a5,a2
40000954:	40e68733          	sub	a4,a3,a4
40000958:	00078513          	mv	a0,a5
4000095c:	00070593          	mv	a1,a4
40000960:	00008067          	ret
40000964:	010008b7          	lui	a7,0x1000
40000968:	01000813          	li	a6,16
4000096c:	fb16e6e3          	bltu	a3,a7,40000918 <__umoddi3+0x230>
40000970:	01800813          	li	a6,24
40000974:	fa5ff06f          	j	40000918 <__umoddi3+0x230>
40000978:	011657b3          	srl	a5,a2,a7
4000097c:	010696b3          	sll	a3,a3,a6
40000980:	00d7e6b3          	or	a3,a5,a3
40000984:	0115d733          	srl	a4,a1,a7
40000988:	0106de13          	srli	t3,a3,0x10
4000098c:	03c75f33          	divu	t5,a4,t3
40000990:	01069313          	slli	t1,a3,0x10
40000994:	01035313          	srli	t1,t1,0x10
40000998:	010597b3          	sll	a5,a1,a6
4000099c:	011555b3          	srl	a1,a0,a7
400009a0:	00f5e5b3          	or	a1,a1,a5
400009a4:	0105d793          	srli	a5,a1,0x10
400009a8:	01061633          	sll	a2,a2,a6
400009ac:	01051533          	sll	a0,a0,a6
400009b0:	03c77733          	remu	a4,a4,t3
400009b4:	03e30eb3          	mul	t4,t1,t5
400009b8:	01071713          	slli	a4,a4,0x10
400009bc:	00e7e7b3          	or	a5,a5,a4
400009c0:	000f0713          	mv	a4,t5
400009c4:	01d7fe63          	bgeu	a5,t4,400009e0 <__umoddi3+0x2f8>
400009c8:	00f687b3          	add	a5,a3,a5
400009cc:	ffff0713          	addi	a4,t5,-1
400009d0:	00d7e863          	bltu	a5,a3,400009e0 <__umoddi3+0x2f8>
400009d4:	01d7f663          	bgeu	a5,t4,400009e0 <__umoddi3+0x2f8>
400009d8:	ffef0713          	addi	a4,t5,-2
400009dc:	00d787b3          	add	a5,a5,a3
400009e0:	41d787b3          	sub	a5,a5,t4
400009e4:	03c7deb3          	divu	t4,a5,t3
400009e8:	01059593          	slli	a1,a1,0x10
400009ec:	0105d593          	srli	a1,a1,0x10
400009f0:	03c7f7b3          	remu	a5,a5,t3
400009f4:	000e8e13          	mv	t3,t4
400009f8:	03d30333          	mul	t1,t1,t4
400009fc:	01079793          	slli	a5,a5,0x10
40000a00:	00f5e5b3          	or	a1,a1,a5
40000a04:	0065fe63          	bgeu	a1,t1,40000a20 <__umoddi3+0x338>
40000a08:	00b685b3          	add	a1,a3,a1
40000a0c:	fffe8e13          	addi	t3,t4,-1
40000a10:	00d5e863          	bltu	a1,a3,40000a20 <__umoddi3+0x338>
40000a14:	0065f663          	bgeu	a1,t1,40000a20 <__umoddi3+0x338>
40000a18:	ffee8e13          	addi	t3,t4,-2
40000a1c:	00d585b3          	add	a1,a1,a3
40000a20:	01071793          	slli	a5,a4,0x10
40000a24:	00010f37          	lui	t5,0x10
40000a28:	01c7e7b3          	or	a5,a5,t3
40000a2c:	406585b3          	sub	a1,a1,t1
40000a30:	ffff0313          	addi	t1,t5,-1 # ffff <__kernel_ram_size+0x44f7>
40000a34:	0067f733          	and	a4,a5,t1
40000a38:	01065e13          	srli	t3,a2,0x10
40000a3c:	0107d793          	srli	a5,a5,0x10
40000a40:	00667333          	and	t1,a2,t1
40000a44:	02670eb3          	mul	t4,a4,t1
40000a48:	02678333          	mul	t1,a5,t1
40000a4c:	03c70733          	mul	a4,a4,t3
40000a50:	03c787b3          	mul	a5,a5,t3
40000a54:	00670e33          	add	t3,a4,t1
40000a58:	010ed713          	srli	a4,t4,0x10
40000a5c:	01c70733          	add	a4,a4,t3
40000a60:	00677463          	bgeu	a4,t1,40000a68 <__umoddi3+0x380>
40000a64:	01e787b3          	add	a5,a5,t5
40000a68:	01075313          	srli	t1,a4,0x10
40000a6c:	00f307b3          	add	a5,t1,a5
40000a70:	00010337          	lui	t1,0x10
40000a74:	fff30313          	addi	t1,t1,-1 # ffff <__kernel_ram_size+0x44f7>
40000a78:	00677733          	and	a4,a4,t1
40000a7c:	01071713          	slli	a4,a4,0x10
40000a80:	006efeb3          	and	t4,t4,t1
40000a84:	01d70733          	add	a4,a4,t4
40000a88:	00f5e663          	bltu	a1,a5,40000a94 <__umoddi3+0x3ac>
40000a8c:	00f59e63          	bne	a1,a5,40000aa8 <__umoddi3+0x3c0>
40000a90:	00e57c63          	bgeu	a0,a4,40000aa8 <__umoddi3+0x3c0>
40000a94:	40c70633          	sub	a2,a4,a2
40000a98:	00c73333          	sltu	t1,a4,a2
40000a9c:	00d306b3          	add	a3,t1,a3
40000aa0:	00060713          	mv	a4,a2
40000aa4:	40d787b3          	sub	a5,a5,a3
40000aa8:	40e50733          	sub	a4,a0,a4
40000aac:	00e53533          	sltu	a0,a0,a4
40000ab0:	40f585b3          	sub	a1,a1,a5
40000ab4:	40a585b3          	sub	a1,a1,a0
40000ab8:	011598b3          	sll	a7,a1,a7
40000abc:	01075733          	srl	a4,a4,a6
40000ac0:	00e8e533          	or	a0,a7,a4
40000ac4:	0105d5b3          	srl	a1,a1,a6
40000ac8:	00008067          	ret

40000acc <_OffsetAbsSyms>:
GEN_OFFSET_SYM(_cpu_arch_t, user_exc_sp);
GEN_OFFSET_SYM(_cpu_arch_t, user_exc_tmp0);
GEN_OFFSET_SYM(_cpu_arch_t, user_exc_tmp1);
#endif

GEN_ABS_SYM_END
40000acc:	00008067          	ret

40000ad0 <main>:
/* This application itself does nothing as there is net-shell that can be used
 * to monitor things.
 */
int main(void)
{
	LOG_INF("Start application");
40000ad0:	40044537          	lui	a0,0x40044
40000ad4:	78452783          	lw	a5,1924(a0) # 40044784 <log_dynamic_net_native_posix_sample>
40000ad8:	00200713          	li	a4,2
40000adc:	0077f793          	andi	a5,a5,7
40000ae0:	04f77263          	bgeu	a4,a5,40000b24 <main+0x54>
{
40000ae4:	fd010113          	addi	sp,sp,-48
40000ae8:	02112623          	sw	ra,44(sp)
	LOG_INF("Start application");
40000aec:	400327b7          	lui	a5,0x40032
40000af0:	7f078793          	addi	a5,a5,2032 # 400327f0 <__clz_tab+0x100>
40000af4:	00f12e23          	sw	a5,28(sp)
40000af8:	00e12c23          	sw	a4,24(sp)
40000afc:	000015b7          	lui	a1,0x1
		(void) arch_syscall_invoke4(parm0.x, parm1.x, parm2.x, parm3.x, K_SYSCALL_Z_LOG_MSG_STATIC_CREATE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg_static_create(source, desc, package, data);
40000b00:	00000693          	li	a3,0
40000b04:	01810613          	addi	a2,sp,24
40000b08:	78450513          	addi	a0,a0,1924
40000b0c:	0c058593          	addi	a1,a1,192 # 10c0 <CONFIG_HEAP_MEM_POOL_SIZE+0xc0>
40000b10:	484040ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
	return 0;
}
40000b14:	02c12083          	lw	ra,44(sp)
40000b18:	00000513          	li	a0,0
40000b1c:	03010113          	addi	sp,sp,48
40000b20:	00008067          	ret
40000b24:	00000513          	li	a0,0
40000b28:	00008067          	ret

40000b2c <getopt>:
/*
 * getopt --
 *	Parse argc/argv argument vector.
 */
int getopt(int nargc, char *const nargv[], const char *ostr)
{
40000b2c:	fe010113          	addi	sp,sp,-32
40000b30:	00812c23          	sw	s0,24(sp)
40000b34:	00912a23          	sw	s1,20(sp)
40000b38:	01212823          	sw	s2,16(sp)
40000b3c:	01312623          	sw	s3,12(sp)
40000b40:	01412423          	sw	s4,8(sp)
40000b44:	00112e23          	sw	ra,28(sp)
40000b48:	01512223          	sw	s5,4(sp)
40000b4c:	02010413          	addi	s0,sp,32
40000b50:	00050a13          	mv	s4,a0
40000b54:	00058993          	mv	s3,a1
40000b58:	00060913          	mv	s2,a2
	struct getopt_state *state;
	char *oli; /* option letter list index */

	/* get getopt state of the current thread */
	state = getopt_state_get();
40000b5c:	288000ef          	jal	ra,40000de4 <getopt_state_get>

	if (state->optreset || *state->place == 0) { /* update scanning pointer */
40000b60:	00c52783          	lw	a5,12(a0)
	state = getopt_state_get();
40000b64:	00050493          	mv	s1,a0
	if (state->optreset || *state->place == 0) { /* update scanning pointer */
40000b68:	00079863          	bnez	a5,40000b78 <getopt+0x4c>
40000b6c:	01452783          	lw	a5,20(a0)
40000b70:	0007c703          	lbu	a4,0(a5)
40000b74:	16071463          	bnez	a4,40000cdc <getopt+0x1b0>
		state->optreset = 0;
		state->place = nargv[state->optind];
40000b78:	0044a783          	lw	a5,4(s1)
		state->optreset = 0;
40000b7c:	0004a623          	sw	zero,12(s1)
		state->place = nargv[state->optind];
40000b80:	00279713          	slli	a4,a5,0x2
40000b84:	00e98733          	add	a4,s3,a4
40000b88:	00072703          	lw	a4,0(a4) # 1000000 <__rom_region_size+0xfc7044>
		if (state->optind >= nargc || *state->place++ != '-') {
40000b8c:	0547c263          	blt	a5,s4,40000bd0 <getopt+0xa4>
		}
		state->optopt = *state->place++;
		if (state->optopt == '-' && *state->place == 0) {
			/* "--" => end of options */
			++state->optind;
			state->place = EMSG;
40000b90:	400337b7          	lui	a5,0x40033
40000b94:	1e878793          	addi	a5,a5,488 # 400331e8 <severity_lvls+0xf0>
40000b98:	00f4aa23          	sw	a5,20(s1)
			z_getopt_global_state_update(state);
40000b9c:	00048513          	mv	a0,s1
40000ba0:	204000ef          	jal	ra,40000da4 <z_getopt_global_state_update>
			return -1;
40000ba4:	fff00513          	li	a0,-1
		state->place = EMSG;
		++state->optind;
	}
	z_getopt_global_state_update(state);
	return state->optopt;	/* return option letter */
}
40000ba8:	fe040113          	addi	sp,s0,-32
40000bac:	01c12083          	lw	ra,28(sp)
40000bb0:	01812403          	lw	s0,24(sp)
40000bb4:	01412483          	lw	s1,20(sp)
40000bb8:	01012903          	lw	s2,16(sp)
40000bbc:	00c12983          	lw	s3,12(sp)
40000bc0:	00812a03          	lw	s4,8(sp)
40000bc4:	00412a83          	lw	s5,4(sp)
40000bc8:	02010113          	addi	sp,sp,32
40000bcc:	00008067          	ret
		if (state->optind >= nargc || *state->place++ != '-') {
40000bd0:	00170693          	addi	a3,a4,1
40000bd4:	00d4aa23          	sw	a3,20(s1)
40000bd8:	00074a83          	lbu	s5,0(a4)
40000bdc:	02d00693          	li	a3,45
40000be0:	fada98e3          	bne	s5,a3,40000b90 <getopt+0x64>
		state->optopt = *state->place++;
40000be4:	00270693          	addi	a3,a4,2
40000be8:	00d4aa23          	sw	a3,20(s1)
40000bec:	00174683          	lbu	a3,1(a4)
40000bf0:	00d4a423          	sw	a3,8(s1)
		if (state->optopt == '-' && *state->place == 0) {
40000bf4:	01569c63          	bne	a3,s5,40000c0c <getopt+0xe0>
40000bf8:	00274703          	lbu	a4,2(a4)
40000bfc:	02071a63          	bnez	a4,40000c30 <getopt+0x104>
			++state->optind;
40000c00:	00178793          	addi	a5,a5,1
40000c04:	00f4a223          	sw	a5,4(s1)
40000c08:	f89ff06f          	j	40000b90 <getopt+0x64>
		if (state->optopt == 0) {
40000c0c:	02069263          	bnez	a3,40000c30 <getopt+0x104>
			state->place = EMSG;
40000c10:	400337b7          	lui	a5,0x40033
40000c14:	1e878793          	addi	a5,a5,488 # 400331e8 <severity_lvls+0xf0>
40000c18:	00f4aa23          	sw	a5,20(s1)
			if (strchr(ostr, '-') == NULL) {
40000c1c:	02d00593          	li	a1,45
40000c20:	00090513          	mv	a0,s2
40000c24:	7690b0ef          	jal	ra,4000cb8c <strchr>
40000c28:	f6050ae3          	beqz	a0,40000b9c <getopt+0x70>
			state->optopt = '-';
40000c2c:	0154a423          	sw	s5,8(s1)
	oli = strchr(ostr, state->optopt);
40000c30:	0084a583          	lw	a1,8(s1)
40000c34:	00090513          	mv	a0,s2
40000c38:	7550b0ef          	jal	ra,4000cb8c <strchr>
	if (state->optopt == ':' || oli == NULL) {
40000c3c:	0084a583          	lw	a1,8(s1)
40000c40:	03a00713          	li	a4,58
40000c44:	0144a783          	lw	a5,20(s1)
40000c48:	00e58663          	beq	a1,a4,40000c54 <getopt+0x128>
		if (*state->place == 0) {
40000c4c:	00078693          	mv	a3,a5
	if (state->optopt == ':' || oli == NULL) {
40000c50:	0a051063          	bnez	a0,40000cf0 <getopt+0x1c4>
		if (*state->place == 0) {
40000c54:	0007c783          	lbu	a5,0(a5)
40000c58:	00079863          	bnez	a5,40000c68 <getopt+0x13c>
			++state->optind;
40000c5c:	0044a783          	lw	a5,4(s1)
40000c60:	00178793          	addi	a5,a5,1
40000c64:	00f4a223          	sw	a5,4(s1)
		if (state->opterr && *ostr != ':') {
40000c68:	0004a783          	lw	a5,0(s1)
40000c6c:	06078063          	beqz	a5,40000ccc <getopt+0x1a0>
40000c70:	00094703          	lbu	a4,0(s2)
40000c74:	03a00793          	li	a5,58
40000c78:	04f70a63          	beq	a4,a5,40000ccc <getopt+0x1a0>
			LOG_ERR("illegal option -- %c", state->optopt);
40000c7c:	40044537          	lui	a0,0x40044
40000c80:	73452783          	lw	a5,1844(a0) # 40044734 <log_dynamic_getopt>
40000c84:	0077f793          	andi	a5,a5,7
40000c88:	04078263          	beqz	a5,40000ccc <getopt+0x1a0>
40000c8c:	00010913          	mv	s2,sp
40000c90:	fe010113          	addi	sp,sp,-32
40000c94:	00010613          	mv	a2,sp
40000c98:	400337b7          	lui	a5,0x40033
40000c9c:	81c78793          	addi	a5,a5,-2020 # 4003281c <__clz_tab+0x12c>
				LOG_ERR("option requires an argument -- %c",
40000ca0:	00f62a23          	sw	a5,20(a2)
40000ca4:	00300793          	li	a5,3
40000ca8:	00b62c23          	sw	a1,24(a2)
40000cac:	00f62823          	sw	a5,16(a2)
40000cb0:	000025b7          	lui	a1,0x2
40000cb4:	00000693          	li	a3,0
40000cb8:	01060613          	addi	a2,a2,16
40000cbc:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
40000cc0:	73450513          	addi	a0,a0,1844
40000cc4:	2d0040ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
40000cc8:	00090113          	mv	sp,s2
			z_getopt_global_state_update(state);
40000ccc:	00048513          	mv	a0,s1
40000cd0:	0d4000ef          	jal	ra,40000da4 <z_getopt_global_state_update>
		return BADCH;
40000cd4:	03f00513          	li	a0,63
40000cd8:	ed1ff06f          	j	40000ba8 <getopt+0x7c>
		state->optopt = *state->place++;
40000cdc:	00178713          	addi	a4,a5,1
40000ce0:	00e52a23          	sw	a4,20(a0)
40000ce4:	0007c783          	lbu	a5,0(a5)
40000ce8:	00f52423          	sw	a5,8(a0)
40000cec:	f45ff06f          	j	40000c30 <getopt+0x104>
	if (oli[1] != ':') {
40000cf0:	00154603          	lbu	a2,1(a0)
40000cf4:	02e60663          	beq	a2,a4,40000d20 <getopt+0x1f4>
		state->optarg = NULL;
40000cf8:	0004a823          	sw	zero,16(s1)
		if (*state->place == 0) {
40000cfc:	0007c783          	lbu	a5,0(a5)
40000d00:	00079863          	bnez	a5,40000d10 <getopt+0x1e4>
		++state->optind;
40000d04:	0044a783          	lw	a5,4(s1)
40000d08:	00178793          	addi	a5,a5,1
40000d0c:	00f4a223          	sw	a5,4(s1)
	z_getopt_global_state_update(state);
40000d10:	00048513          	mv	a0,s1
40000d14:	090000ef          	jal	ra,40000da4 <z_getopt_global_state_update>
	return state->optopt;	/* return option letter */
40000d18:	0084a503          	lw	a0,8(s1)
40000d1c:	e8dff06f          	j	40000ba8 <getopt+0x7c>
		if (*state->place) {
40000d20:	0006c503          	lbu	a0,0(a3) # 10000 <__kernel_ram_size+0x44f8>
40000d24:	40033737          	lui	a4,0x40033
			++state->optind;
40000d28:	0044a783          	lw	a5,4(s1)
40000d2c:	1e870713          	addi	a4,a4,488 # 400331e8 <severity_lvls+0xf0>
		if (*state->place) {
40000d30:	00051e63          	bnez	a0,40000d4c <getopt+0x220>
		} else if (nargc > ++state->optind) {
40000d34:	00178793          	addi	a5,a5,1
40000d38:	00f4a223          	sw	a5,4(s1)
40000d3c:	0147de63          	bge	a5,s4,40000d58 <getopt+0x22c>
			state->optarg = nargv[state->optind];
40000d40:	00279793          	slli	a5,a5,0x2
40000d44:	00f989b3          	add	s3,s3,a5
40000d48:	0009a683          	lw	a3,0(s3)
			state->optarg = state->place;
40000d4c:	00d4a823          	sw	a3,16(s1)
		state->place = EMSG;
40000d50:	00e4aa23          	sw	a4,20(s1)
40000d54:	fb1ff06f          	j	40000d04 <getopt+0x1d8>
			state->place = EMSG;
40000d58:	00e4aa23          	sw	a4,20(s1)
			if (*ostr == ':') {
40000d5c:	00094783          	lbu	a5,0(s2)
40000d60:	00c79a63          	bne	a5,a2,40000d74 <getopt+0x248>
				z_getopt_global_state_update(state);
40000d64:	00048513          	mv	a0,s1
40000d68:	03c000ef          	jal	ra,40000da4 <z_getopt_global_state_update>
				return BADARG;
40000d6c:	03a00513          	li	a0,58
40000d70:	e39ff06f          	j	40000ba8 <getopt+0x7c>
			if (state->opterr) {
40000d74:	0004a783          	lw	a5,0(s1)
40000d78:	f4078ae3          	beqz	a5,40000ccc <getopt+0x1a0>
				LOG_ERR("option requires an argument -- %c",
40000d7c:	40044537          	lui	a0,0x40044
40000d80:	73452783          	lw	a5,1844(a0) # 40044734 <log_dynamic_getopt>
40000d84:	0077f793          	andi	a5,a5,7
40000d88:	f40782e3          	beqz	a5,40000ccc <getopt+0x1a0>
40000d8c:	00010913          	mv	s2,sp
40000d90:	fe010113          	addi	sp,sp,-32
40000d94:	00010613          	mv	a2,sp
40000d98:	400337b7          	lui	a5,0x40033
40000d9c:	83478793          	addi	a5,a5,-1996 # 40032834 <__clz_tab+0x144>
40000da0:	f01ff06f          	j	40000ca0 <getopt+0x174>

40000da4 <z_getopt_global_state_update>:
/* This function is not thread safe. All threads using getopt are calling
 * this function.
 */
void z_getopt_global_state_update(struct getopt_state *state)
{
	opterr = state->opterr;
40000da4:	00052703          	lw	a4,0(a0)
40000da8:	400447b7          	lui	a5,0x40044
40000dac:	6ae7a423          	sw	a4,1704(a5) # 400446a8 <opterr>
	optind = state->optind;
40000db0:	00452703          	lw	a4,4(a0)
40000db4:	400447b7          	lui	a5,0x40044
40000db8:	6ae7a223          	sw	a4,1700(a5) # 400446a4 <optind>
	optopt = state->optopt;
40000dbc:	00852703          	lw	a4,8(a0)
40000dc0:	400397b7          	lui	a5,0x40039
40000dc4:	fce7ac23          	sw	a4,-40(a5) # 40038fd8 <optopt>
	optreset = state->optreset;
40000dc8:	00c52703          	lw	a4,12(a0)
40000dcc:	400397b7          	lui	a5,0x40039
40000dd0:	fce7aa23          	sw	a4,-44(a5) # 40038fd4 <optreset>
	optarg = state->optarg;
40000dd4:	01052703          	lw	a4,16(a0)
40000dd8:	400397b7          	lui	a5,0x40039
40000ddc:	fce7a823          	sw	a4,-48(a5) # 40038fd0 <optarg>
}
40000de0:	00008067          	ret

40000de4 <getopt_state_get>:
			return &sh->ctx->getopt;
		}
	}
#endif
	/* If not a shell thread return a common pointer */
	return &m_getopt_common_state;
40000de4:	40044537          	lui	a0,0x40044
}
40000de8:	fe850513          	addi	a0,a0,-24 # 40043fe8 <m_getopt_common_state>
40000dec:	00008067          	ret

40000df0 <cbvprintf_package>:
	return cb(str, strl, ctx);
}

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
40000df0:	f7010113          	addi	sp,sp,-144
	const char *s;
	bool parsing = false;
	/* Flag indicates that rw strings are stored as array with positions,
	 * instead of appending them to the package.
	 */
	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
40000df4:	00467793          	andi	a5,a2,4
40000df8:	00f12423          	sw	a5,8(sp)
{
40000dfc:	08112623          	sw	ra,140(sp)
40000e00:	08812423          	sw	s0,136(sp)
40000e04:	08912223          	sw	s1,132(sp)
40000e08:	09212023          	sw	s2,128(sp)
40000e0c:	07312e23          	sw	s3,124(sp)
40000e10:	07412c23          	sw	s4,120(sp)
40000e14:	07512a23          	sw	s5,116(sp)
40000e18:	07612823          	sw	s6,112(sp)
40000e1c:	07712623          	sw	s7,108(sp)
40000e20:	07812423          	sw	s8,104(sp)
40000e24:	07912223          	sw	s9,100(sp)
40000e28:	07a12023          	sw	s10,96(sp)
40000e2c:	05b12e23          	sw	s11,92(sp)
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
	bool is_str_arg = false;
	union cbprintf_package_hdr *pkg_hdr = packaged;

	/* Buffer must be aligned at least to size of a pointer. */
	if ((uintptr_t)packaged % sizeof(void *)) {
40000e30:	00357793          	andi	a5,a0,3
40000e34:	56079a63          	bnez	a5,400013a8 <cbvprintf_package+0x5b8>
40000e38:	00365d13          	srli	s10,a2,0x3
40000e3c:	007d7d13          	andi	s10,s10,7
40000e40:	00050493          	mv	s1,a0
40000e44:	00058993          	mv	s3,a1
40000e48:	00068a93          	mv	s5,a3
40000e4c:	001d0d13          	addi	s10,s10,1
	 * which is guaranteed to be at least 4 bytes, we just reserve
	 * multiple of pointer size for the above to preserve alignment.
	 *
	 * Refer to union cbprintf_package_hdr for more details.
	 */
	buf += sizeof(*pkg_hdr);
40000e50:	00450413          	addi	s0,a0,4
	 * When buf0 is NULL we don't store anything.
	 * Instead we count the needed space to store the data.
	 * In this case, incoming len argument indicates the anticipated
	 * buffer "misalignment" offset.
	 */
	if (buf0 == NULL) {
40000e54:	04050663          	beqz	a0,40000ea0 <cbvprintf_package+0xb0>

	/*
	 * Otherwise we must ensure we can store at least
	 * the pointer to the format string itself.
	 */
	if (buf0 != NULL && BUF_OFFSET + sizeof(char *) > len) {
40000e58:	00700793          	li	a5,7
40000e5c:	04b7ea63          	bltu	a5,a1,40000eb0 <cbvprintf_package+0xc0>
		return -ENOSPC;
40000e60:	fe400513          	li	a0,-28
	return BUF_OFFSET;

#undef BUF_OFFSET
#undef STR_POS_RO_FLAG
#undef STR_POS_MASK
}
40000e64:	08c12083          	lw	ra,140(sp)
40000e68:	08812403          	lw	s0,136(sp)
40000e6c:	08412483          	lw	s1,132(sp)
40000e70:	08012903          	lw	s2,128(sp)
40000e74:	07c12983          	lw	s3,124(sp)
40000e78:	07812a03          	lw	s4,120(sp)
40000e7c:	07412a83          	lw	s5,116(sp)
40000e80:	07012b03          	lw	s6,112(sp)
40000e84:	06c12b83          	lw	s7,108(sp)
40000e88:	06812c03          	lw	s8,104(sp)
40000e8c:	06412c83          	lw	s9,100(sp)
40000e90:	06012d03          	lw	s10,96(sp)
40000e94:	05c12d83          	lw	s11,92(sp)
40000e98:	09010113          	addi	sp,sp,144
40000e9c:	00008067          	ret
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
40000ea0:	0075f993          	andi	s3,a1,7
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
40000ea4:	00800793          	li	a5,8
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
40000ea8:	00498413          	addi	s0,s3,4
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
40000eac:	413789b3          	sub	s3,a5,s3
	s = fmt--;
40000eb0:	00267c93          	andi	s9,a2,2
			switch (*fmt) {
40000eb4:	40033637          	lui	a2,0x40033
40000eb8:	86060793          	addi	a5,a2,-1952 # 40032860 <__clz_tab+0x170>
40000ebc:	00010337          	lui	t1,0x10
40000ec0:	00f12623          	sw	a5,12(sp)
40000ec4:	fda30793          	addi	a5,t1,-38 # ffda <__kernel_ram_size+0x44d2>
	s = fmt--;
40000ec8:	fffa8593          	addi	a1,s5,-1
	unsigned int s_ro_cnt = 0; /* number of ro strings */
40000ecc:	00000c13          	li	s8,0
	unsigned int s_rw_cnt = 0; /* number of rw strings */
40000ed0:	00000d93          	li	s11,0
	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
40000ed4:	00000b93          	li	s7,0
	bool parsing = false;
40000ed8:	00000a13          	li	s4,0
	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
40000edc:	fff00693          	li	a3,-1
	align = VA_STACK_ALIGN(char *);
40000ee0:	00400b13          	li	s6,4
	size = sizeof(char *);
40000ee4:	00400913          	li	s2,4
			switch (*fmt) {
40000ee8:	00f12823          	sw	a5,16(sp)
			if (buf0 != NULL) {
40000eec:	00048463          	beqz	s1,40000ef4 <cbvprintf_package+0x104>
				*(const char **)buf = s;
40000ef0:	01542023          	sw	s5,0(s0)
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
40000ef4:	2ba04e63          	bgtz	s10,400011b0 <cbvprintf_package+0x3c0>
#else
	#define RO_START 0
	#define RO_END 0
#endif

	return (((const char *)addr >= (const char *)RO_START) &&
40000ef8:	400327b7          	lui	a5,0x40032
40000efc:	27c78793          	addi	a5,a5,636 # 4003227c <__rodata_region_start>
40000f00:	00fae863          	bltu	s5,a5,40000f10 <cbvprintf_package+0x120>
40000f04:	400397b7          	lui	a5,0x40039
40000f08:	fbc78793          	addi	a5,a5,-68 # 40038fbc <__rodata_region_end>
40000f0c:	2afae263          	bltu	s5,a5,400011b0 <cbvprintf_package+0x3c0>
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
40000f10:	40940533          	sub	a0,s0,s1
40000f14:	00255793          	srli	a5,a0,0x2
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
40000f18:	300c9a63          	bnez	s9,4000122c <cbvprintf_package+0x43c>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
40000f1c:	00f00513          	li	a0,15
40000f20:	23756a63          	bltu	a0,s7,40001154 <cbvprintf_package+0x364>
				if (buf0 != NULL) {
40000f24:	30048e63          	beqz	s1,40001240 <cbvprintf_package+0x450>
					str_ptr_pos[s_idx] = s_ptr_idx;
40000f28:	030b8613          	addi	a2,s7,48
40000f2c:	02010513          	addi	a0,sp,32
40000f30:	00a60533          	add	a0,a2,a0
40000f34:	fef50023          	sb	a5,-32(a0)
					str_ptr_arg[s_idx] = arg_idx;
40000f38:	fed50823          	sb	a3,-16(a0)
						s_rw_cnt++;
40000f3c:	001d8d93          	addi	s11,s11,1
40000f40:	2bc0006f          	j	400011fc <cbvprintf_package+0x40c>
			switch (*fmt) {
40000f44:	00800b13          	li	s6,8
40000f48:	00800913          	li	s2,8
			if (*++fmt == '\0') {
40000f4c:	0015c783          	lbu	a5,1(a1)
40000f50:	00158593          	addi	a1,a1,1
40000f54:	32078063          	beqz	a5,40001274 <cbvprintf_package+0x484>
			if (!parsing) {
40000f58:	000a1e63          	bnez	s4,40000f74 <cbvprintf_package+0x184>
				if (*fmt == '%') {
40000f5c:	fee798e3          	bne	a5,a4,40000f4c <cbvprintf_package+0x15c>
					arg_idx++;
40000f60:	00168693          	addi	a3,a3,1
					parsing = true;
40000f64:	00100a13          	li	s4,1
				align = VA_STACK_ALIGN(size_t);
40000f68:	00400b13          	li	s6,4
40000f6c:	00400913          	li	s2,4
40000f70:	fddff06f          	j	40000f4c <cbvprintf_package+0x15c>
			switch (*fmt) {
40000f74:	07a00513          	li	a0,122
40000f78:	08f56463          	bltu	a0,a5,40001000 <cbvprintf_package+0x210>
40000f7c:	02f8e663          	bltu	a7,a5,40000fa8 <cbvprintf_package+0x1b8>
40000f80:	08f66063          	bltu	a2,a5,40001000 <cbvprintf_package+0x210>
40000f84:	02900513          	li	a0,41
40000f88:	04f56063          	bltu	a0,a5,40000fc8 <cbvprintf_package+0x1d8>
40000f8c:	06e78863          	beq	a5,a4,40000ffc <cbvprintf_package+0x20c>
40000f90:	06f76863          	bltu	a4,a5,40001000 <cbvprintf_package+0x210>
40000f94:	02000513          	li	a0,32
40000f98:	faa78ae3          	beq	a5,a0,40000f4c <cbvprintf_package+0x15c>
40000f9c:	fdd78793          	addi	a5,a5,-35
40000fa0:	0017ba13          	seqz	s4,a5
40000fa4:	fa9ff06f          	j	40000f4c <cbvprintf_package+0x15c>
40000fa8:	fb478793          	addi	a5,a5,-76
40000fac:	0ff7f793          	zext.b	a5,a5
40000fb0:	04f2e863          	bltu	t0,a5,40001000 <cbvprintf_package+0x210>
40000fb4:	00c12503          	lw	a0,12(sp)
40000fb8:	00279793          	slli	a5,a5,0x2
40000fbc:	00a787b3          	add	a5,a5,a0
40000fc0:	0007a783          	lw	a5,0(a5)
40000fc4:	00078067          	jr	a5
40000fc8:	00100513          	li	a0,1
40000fcc:	fd678793          	addi	a5,a5,-42
40000fd0:	00f517b3          	sll	a5,a0,a5
40000fd4:	01012503          	lw	a0,16(sp)
40000fd8:	00a7f533          	and	a0,a5,a0
40000fdc:	f60518e3          	bnez	a0,40000f4c <cbvprintf_package+0x15c>
40000fe0:	38800537          	lui	a0,0x38800
40000fe4:	00a7f533          	and	a0,a5,a0
40000fe8:	08051063          	bnez	a0,40001068 <cbvprintf_package+0x278>
40000fec:	0017fa13          	andi	s4,a5,1
40000ff0:	f40a0ee3          	beqz	s4,40000f4c <cbvprintf_package+0x15c>
40000ff4:	00000793          	li	a5,0
40000ff8:	0300006f          	j	40001028 <cbvprintf_package+0x238>
				arg_idx--;
40000ffc:	fff68693          	addi	a3,a3,-1
				parsing = false;
40001000:	00000a13          	li	s4,0
40001004:	f49ff06f          	j	40000f4c <cbvprintf_package+0x15c>
				if (fmt[-1] == 'l') {
40001008:	fff5c783          	lbu	a5,-1(a1)
4000100c:	13f79863          	bne	a5,t6,4000113c <cbvprintf_package+0x34c>
					if (fmt[-2] == 'l') {
40001010:	ffe5c783          	lbu	a5,-2(a1)
40001014:	13f79a63          	bne	a5,t6,40001148 <cbvprintf_package+0x358>
40001018:	00000793          	li	a5,0
				parsing = false;
4000101c:	00000a13          	li	s4,0
						align = VA_STACK_ALIGN(long long);
40001020:	00800b13          	li	s6,8
						size = sizeof(long long);
40001024:	00800913          	li	s2,8
		buf = (void *) ROUND_UP(buf, align);
40001028:	fff40413          	addi	s0,s0,-1
4000102c:	01640433          	add	s0,s0,s6
40001030:	41600533          	neg	a0,s6
40001034:	00a47433          	and	s0,s0,a0
		if (buf0 != NULL && BUF_OFFSET + size > len) {
40001038:	14048463          	beqz	s1,40001180 <cbvprintf_package+0x390>
4000103c:	40990533          	sub	a0,s2,s1
40001040:	00850533          	add	a0,a0,s0
40001044:	e0a9eee3          	bltu	s3,a0,40000e60 <cbvprintf_package+0x70>
		if (is_str_arg) {
40001048:	14079c63          	bnez	a5,400011a0 <cbvprintf_package+0x3b0>
		} else if (size == sizeof(int)) {
4000104c:	11d91263          	bne	s2,t4,40001150 <cbvprintf_package+0x360>
			int v = va_arg(ap, int);
40001050:	00082503          	lw	a0,0(a6) # 10000 <__kernel_ram_size+0x44f8>
40001054:	00480793          	addi	a5,a6,4
				*(int *)buf = v;
40001058:	00a42023          	sw	a0,0(s0)
			buf += sizeof(int);
4000105c:	00440413          	addi	s0,s0,4
40001060:	00078813          	mv	a6,a5
40001064:	f09ff06f          	j	40000f6c <cbvprintf_package+0x17c>
				if (fmt[-1] == 'L') {
40001068:	fff5ca03          	lbu	s4,-1(a1)
4000106c:	09ea1263          	bne	s4,t5,400010f0 <cbvprintf_package+0x300>
					v.ld = va_arg(ap, long double);
40001070:	00082503          	lw	a0,0(a6)
40001074:	00480793          	addi	a5,a6,4
					size = sizeof(long double);
40001078:	01000913          	li	s2,16
					v.ld = va_arg(ap, long double);
4000107c:	00052803          	lw	a6,0(a0) # 38800000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x328a1f00>
40001080:	03012023          	sw	a6,32(sp)
40001084:	00452803          	lw	a6,4(a0)
40001088:	03012223          	sw	a6,36(sp)
4000108c:	00852803          	lw	a6,8(a0)
40001090:	00c52503          	lw	a0,12(a0)
40001094:	03012423          	sw	a6,40(sp)
40001098:	02a12623          	sw	a0,44(sp)
				buf = (void *) ROUND_UP(buf, align);
4000109c:	fff40413          	addi	s0,s0,-1
400010a0:	01240433          	add	s0,s0,s2
400010a4:	41200533          	neg	a0,s2
400010a8:	00a47433          	and	s0,s0,a0
				if (buf0 != NULL) {
400010ac:	02048a63          	beqz	s1,400010e0 <cbvprintf_package+0x2f0>
					if (BUF_OFFSET + size > len) {
400010b0:	40990533          	sub	a0,s2,s1
400010b4:	00850533          	add	a0,a0,s0
400010b8:	daa9e4e3          	bltu	s3,a0,40000e60 <cbvprintf_package+0x70>
					} else if (fmt[-1] == 'L') {
400010bc:	05ea1c63          	bne	s4,t5,40001114 <cbvprintf_package+0x324>
						*(long double *)buf = v.ld;
400010c0:	02012503          	lw	a0,32(sp)
400010c4:	00a42023          	sw	a0,0(s0)
400010c8:	02412503          	lw	a0,36(sp)
400010cc:	00a42223          	sw	a0,4(s0)
400010d0:	02812503          	lw	a0,40(sp)
400010d4:	00a42423          	sw	a0,8(s0)
400010d8:	02c12503          	lw	a0,44(sp)
400010dc:	00a42623          	sw	a0,12(s0)
				buf += size;
400010e0:	01240433          	add	s0,s0,s2
				continue;
400010e4:	00078813          	mv	a6,a5
400010e8:	00090b13          	mv	s6,s2
400010ec:	f15ff06f          	j	40001000 <cbvprintf_package+0x210>
					v.d = va_arg(ap, double);
400010f0:	00780813          	addi	a6,a6,7
400010f4:	ff887813          	andi	a6,a6,-8
400010f8:	00082303          	lw	t1,0(a6)
400010fc:	00482383          	lw	t2,4(a6)
40001100:	00880793          	addi	a5,a6,8
40001104:	02612023          	sw	t1,32(sp)
40001108:	02712223          	sw	t2,36(sp)
					size = sizeof(double);
4000110c:	00800913          	li	s2,8
40001110:	f8dff06f          	j	4000109c <cbvprintf_package+0x2ac>
						*(double *)buf = v.d;
40001114:	02012303          	lw	t1,32(sp)
40001118:	02412383          	lw	t2,36(sp)
4000111c:	00642023          	sw	t1,0(s0)
40001120:	00742223          	sw	t2,4(s0)
40001124:	fbdff06f          	j	400010e0 <cbvprintf_package+0x2f0>
			switch (*fmt) {
40001128:	000a0793          	mv	a5,s4
				parsing = false;
4000112c:	00000a13          	li	s4,0
				align = VA_STACK_ALIGN(void *);
40001130:	00400b13          	li	s6,4
				size = sizeof(void *);
40001134:	00400913          	li	s2,4
40001138:	ef1ff06f          	j	40001028 <cbvprintf_package+0x238>
4000113c:	00000793          	li	a5,0
				parsing = false;
40001140:	00000a13          	li	s4,0
40001144:	ee5ff06f          	j	40001028 <cbvprintf_package+0x238>
40001148:	00000793          	li	a5,0
4000114c:	fe1ff06f          	j	4000112c <cbvprintf_package+0x33c>
		} else if (size == sizeof(long long)) {
40001150:	01c90663          	beq	s2,t3,4000115c <cbvprintf_package+0x36c>
					return -EINVAL;
40001154:	fea00513          	li	a0,-22
40001158:	d0dff06f          	j	40000e64 <cbvprintf_package+0x74>
			long long v = va_arg(ap, long long);
4000115c:	00780793          	addi	a5,a6,7
40001160:	ff87f793          	andi	a5,a5,-8
40001164:	0007a303          	lw	t1,0(a5)
40001168:	0047a383          	lw	t2,4(a5)
4000116c:	00878813          	addi	a6,a5,8
40001170:	00642023          	sw	t1,0(s0)
40001174:	00742223          	sw	t2,4(s0)
			buf += sizeof(long long);
40001178:	00840413          	addi	s0,s0,8
4000117c:	dcdff06f          	j	40000f48 <cbvprintf_package+0x158>
		if (is_str_arg) {
40001180:	02079063          	bnez	a5,400011a0 <cbvprintf_package+0x3b0>
			int v = va_arg(ap, int);
40001184:	00480793          	addi	a5,a6,4
		} else if (size == sizeof(int)) {
40001188:	edd90ae3          	beq	s2,t4,4000105c <cbvprintf_package+0x26c>
		} else if (size == sizeof(long long)) {
4000118c:	fdc914e3          	bne	s2,t3,40001154 <cbvprintf_package+0x364>
			long long v = va_arg(ap, long long);
40001190:	00780813          	addi	a6,a6,7
40001194:	ff887813          	andi	a6,a6,-8
40001198:	00880813          	addi	a6,a6,8
			if (buf0 != NULL) {
4000119c:	fddff06f          	j	40001178 <cbvprintf_package+0x388>
			s = va_arg(ap, char *);
400011a0:	00082a83          	lw	s5,0(a6)
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
400011a4:	fffd0d13          	addi	s10,s10,-1
			s = va_arg(ap, char *);
400011a8:	00480713          	addi	a4,a6,4
400011ac:	d41ff06f          	j	40000eec <cbvprintf_package+0xfc>
			if (is_ro && !do_ro) {
400011b0:	040c8863          	beqz	s9,40001200 <cbvprintf_package+0x410>
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
400011b4:	40940533          	sub	a0,s0,s1
400011b8:	00255793          	srli	a5,a0,0x2
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
400011bc:	00100813          	li	a6,1
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
400011c0:	1ff00e13          	li	t3,511
400011c4:	f8ae68e3          	bltu	t3,a0,40001154 <cbvprintf_package+0x364>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
400011c8:	00f00513          	li	a0,15
400011cc:	f97564e3          	bltu	a0,s7,40001154 <cbvprintf_package+0x364>
				if (buf0 != NULL) {
400011d0:	06048263          	beqz	s1,40001234 <cbvprintf_package+0x444>
					str_ptr_pos[s_idx] = s_ptr_idx;
400011d4:	030b8613          	addi	a2,s7,48
400011d8:	02010513          	addi	a0,sp,32
400011dc:	00a60533          	add	a0,a2,a0
400011e0:	0ff7f793          	zext.b	a5,a5
400011e4:	fef50023          	sb	a5,-32(a0)
					str_ptr_arg[s_idx] = arg_idx;
400011e8:	fed50823          	sb	a3,-16(a0)
					if (is_ro) {
400011ec:	d40808e3          	beqz	a6,40000f3c <cbvprintf_package+0x14c>
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
400011f0:	f807e793          	ori	a5,a5,-128
400011f4:	fef50023          	sb	a5,-32(a0)
						s_ro_cnt++;
400011f8:	001c0c13          	addi	s8,s8,1
				s_idx++;
400011fc:	001b8b93          	addi	s7,s7,1
			buf += sizeof(char *);
40001200:	00070813          	mv	a6,a4
40001204:	00440413          	addi	s0,s0,4
			switch (*fmt) {
40001208:	04b00893          	li	a7,75
4000120c:	00800e13          	li	t3,8
40001210:	00400e93          	li	t4,4
				if (fmt[-1] == 'L') {
40001214:	04c00f13          	li	t5,76
			switch (*fmt) {
40001218:	02e00293          	li	t0,46
				if (fmt[-1] == 'l') {
4000121c:	06c00f93          	li	t6,108
			switch (*fmt) {
40001220:	04700613          	li	a2,71
40001224:	02500713          	li	a4,37
40001228:	d25ff06f          	j	40000f4c <cbvprintf_package+0x15c>
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
4000122c:	00000813          	li	a6,0
40001230:	f91ff06f          	j	400011c0 <cbvprintf_package+0x3d0>
				} else if (is_ro) {
40001234:	00080663          	beqz	a6,40001240 <cbvprintf_package+0x450>
					len += 1;
40001238:	00198993          	addi	s3,s3,1
4000123c:	fc1ff06f          	j	400011fc <cbvprintf_package+0x40c>
				} else if (rws_pos_en) {
40001240:	00812783          	lw	a5,8(sp)
					len += 2;
40001244:	00298993          	addi	s3,s3,2
				} else if (rws_pos_en) {
40001248:	fa079ae3          	bnez	a5,400011fc <cbvprintf_package+0x40c>
					len += strlen(s) + 1 + 1;
4000124c:	000a8513          	mv	a0,s5
40001250:	00e12e23          	sw	a4,28(sp)
40001254:	00b12c23          	sw	a1,24(sp)
40001258:	00d12a23          	sw	a3,20(sp)
4000125c:	1790b0ef          	jal	ra,4000cbd4 <strlen>
40001260:	01c12703          	lw	a4,28(sp)
40001264:	01812583          	lw	a1,24(sp)
40001268:	01412683          	lw	a3,20(sp)
4000126c:	00a989b3          	add	s3,s3,a0
40001270:	f8dff06f          	j	400011fc <cbvprintf_package+0x40c>
	if (BUF_OFFSET / sizeof(int) > 255) {
40001274:	409407b3          	sub	a5,s0,s1
40001278:	3ff00713          	li	a4,1023
4000127c:	ecf76ce3          	bltu	a4,a5,40001154 <cbvprintf_package+0x364>
	if (buf0 == NULL) {
40001280:	00049863          	bnez	s1,40001290 <cbvprintf_package+0x4a0>
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
40001284:	ff898513          	addi	a0,s3,-8
40001288:	00f50533          	add	a0,a0,a5
4000128c:	bd9ff06f          	j	40000e64 <cbvprintf_package+0x74>
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
40001290:	0027d793          	srli	a5,a5,0x2
	*(char **)buf0 = NULL;
40001294:	0004a023          	sw	zero,0(s1)
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
40001298:	00f48023          	sb	a5,0(s1)
	if (rws_pos_en) {
4000129c:	00812783          	lw	a5,8(sp)
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
400012a0:	0ffdfd93          	zext.b	s11,s11
	if (rws_pos_en) {
400012a4:	02078663          	beqz	a5,400012d0 <cbvprintf_package+0x4e0>
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
400012a8:	01b481a3          	sb	s11,3(s1)
	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
400012ac:	01848123          	sb	s8,2(s1)
	if (s_ro_cnt) {
400012b0:	060c1063          	bnez	s8,40001310 <cbvprintf_package+0x520>
		if (BUF_OFFSET + 1 + size > len) {
400012b4:	00100b13          	li	s6,1
400012b8:	03010913          	addi	s2,sp,48
			*buf++ = str_ptr_arg[i];
400012bc:	00000c93          	li	s9,0
		if (BUF_OFFSET + 1 + size > len) {
400012c0:	409b0b33          	sub	s6,s6,s1
	for (i = 0; i < s_idx; i++) {
400012c4:	059b9e63          	bne	s7,s9,40001320 <cbvprintf_package+0x530>
	return BUF_OFFSET;
400012c8:	40940533          	sub	a0,s0,s1
400012cc:	b99ff06f          	j	40000e64 <cbvprintf_package+0x74>
		pkg_hdr->desc.str_cnt = s_rw_cnt;
400012d0:	01b480a3          	sb	s11,1(s1)
		pkg_hdr->desc.rw_str_cnt = 0;
400012d4:	fd9ff06f          	j	400012ac <cbvprintf_package+0x4bc>
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
400012d8:	03010713          	addi	a4,sp,48
400012dc:	00f70733          	add	a4,a4,a5
400012e0:	00074703          	lbu	a4,0(a4)
400012e4:	01871613          	slli	a2,a4,0x18
400012e8:	41865613          	srai	a2,a2,0x18
400012ec:	00065c63          	bgez	a2,40001304 <cbvprintf_package+0x514>
			if (BUF_OFFSET + 1 > len) {
400012f0:	00d40633          	add	a2,s0,a3
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
400012f4:	07f77713          	andi	a4,a4,127
			if (BUF_OFFSET + 1 > len) {
400012f8:	b6c9e4e3          	bltu	s3,a2,40000e60 <cbvprintf_package+0x70>
			*buf++ = pos;
400012fc:	00e40023          	sb	a4,0(s0)
40001300:	00140413          	addi	s0,s0,1
		for (i = 0; i < s_idx; i++) {
40001304:	00178793          	addi	a5,a5,1
40001308:	fcfb98e3          	bne	s7,a5,400012d8 <cbvprintf_package+0x4e8>
4000130c:	fa9ff06f          	j	400012b4 <cbvprintf_package+0x4c4>
			if (BUF_OFFSET + 1 > len) {
40001310:	00100693          	li	a3,1
		for (i = 0; i < s_idx; i++) {
40001314:	00000793          	li	a5,0
			if (BUF_OFFSET + 1 > len) {
40001318:	409686b3          	sub	a3,a3,s1
4000131c:	fedff06f          	j	40001308 <cbvprintf_package+0x518>
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
40001320:	000c0663          	beqz	s8,4000132c <cbvprintf_package+0x53c>
40001324:	00090783          	lb	a5,0(s2)
40001328:	0407c863          	bltz	a5,40001378 <cbvprintf_package+0x588>
		if (rws_pos_en) {
4000132c:	00812783          	lw	a5,8(sp)
40001330:	04078a63          	beqz	a5,40001384 <cbvprintf_package+0x594>
			*buf++ = str_ptr_arg[i];
40001334:	04010793          	addi	a5,sp,64
40001338:	019787b3          	add	a5,a5,s9
4000133c:	0007c783          	lbu	a5,0(a5)
			size = 0;
40001340:	00000a13          	li	s4,0
			*buf++ = str_ptr_arg[i];
40001344:	00140413          	addi	s0,s0,1
40001348:	fef40fa3          	sb	a5,-1(s0)
		if (BUF_OFFSET + 1 + size > len) {
4000134c:	014b07b3          	add	a5,s6,s4
40001350:	00f407b3          	add	a5,s0,a5
40001354:	b0f9e6e3          	bltu	s3,a5,40000e60 <cbvprintf_package+0x70>
		*buf++ = str_ptr_pos[i];
40001358:	00094783          	lbu	a5,0(s2)
4000135c:	00140d13          	addi	s10,s0,1
		memcpy(buf, s, size);
40001360:	000a0613          	mv	a2,s4
		*buf++ = str_ptr_pos[i];
40001364:	00f40023          	sb	a5,0(s0)
		memcpy(buf, s, size);
40001368:	000a8593          	mv	a1,s5
4000136c:	000d0513          	mv	a0,s10
40001370:	1890b0ef          	jal	ra,4000ccf8 <memcpy>
		buf += size;
40001374:	014d0433          	add	s0,s10,s4
	for (i = 0; i < s_idx; i++) {
40001378:	001c8c93          	addi	s9,s9,1
4000137c:	00190913          	addi	s2,s2,1
40001380:	f45ff06f          	j	400012c4 <cbvprintf_package+0x4d4>
			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
40001384:	00094783          	lbu	a5,0(s2)
40001388:	00279793          	slli	a5,a5,0x2
4000138c:	00f487b3          	add	a5,s1,a5
40001390:	0007aa83          	lw	s5,0(a5)
			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
40001394:	0007a023          	sw	zero,0(a5)
			size = strlen(s) + 1;
40001398:	000a8513          	mv	a0,s5
4000139c:	0390b0ef          	jal	ra,4000cbd4 <strlen>
400013a0:	00150a13          	addi	s4,a0,1
400013a4:	fa9ff06f          	j	4000134c <cbvprintf_package+0x55c>
		return -EFAULT;
400013a8:	ff200513          	li	a0,-14
400013ac:	ab9ff06f          	j	40000e64 <cbvprintf_package+0x74>

400013b0 <cbpprintf_external>:
	uint8_t *buf = packaged;
	struct cbprintf_package_hdr_ext *hdr = packaged;
	char *s, **ps;
	unsigned int i, args_size, s_nbr, ros_nbr, rws_nbr, s_idx;

	if (buf == NULL) {
400013b0:	0e068863          	beqz	a3,400014a0 <cbpprintf_external+0xf0>
{
400013b4:	fe010113          	addi	sp,sp,-32
400013b8:	00812c23          	sw	s0,24(sp)
400013bc:	00912a23          	sw	s1,20(sp)
400013c0:	01212823          	sw	s2,16(sp)
400013c4:	01312623          	sw	s3,12(sp)
400013c8:	01412423          	sw	s4,8(sp)
400013cc:	00112e23          	sw	ra,28(sp)
400013d0:	01512223          	sw	s5,4(sp)
400013d4:	01612023          	sw	s6,0(sp)

	/* Retrieve the size of the arg list and number of strings. */
	args_size = hdr->hdr.desc.len * sizeof(int);
	s_nbr     = hdr->hdr.desc.str_cnt;
	ros_nbr   = hdr->hdr.desc.ro_str_cnt;
	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
400013d8:	0036c783          	lbu	a5,3(a3)
	args_size = hdr->hdr.desc.len * sizeof(int);
400013dc:	0006c703          	lbu	a4,0(a3)
	s_nbr     = hdr->hdr.desc.str_cnt;
400013e0:	0016cb03          	lbu	s6,1(a3)

	/* Locate the string table */
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
400013e4:	00179793          	slli	a5,a5,0x1
	args_size = hdr->hdr.desc.len * sizeof(int);
400013e8:	00271713          	slli	a4,a4,0x2
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
400013ec:	00e787b3          	add	a5,a5,a4
	ros_nbr   = hdr->hdr.desc.ro_str_cnt;
400013f0:	0026c703          	lbu	a4,2(a3)
400013f4:	00050493          	mv	s1,a0
400013f8:	00058993          	mv	s3,a1
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
400013fc:	00e787b3          	add	a5,a5,a4
40001400:	00060913          	mv	s2,a2
40001404:	00068413          	mv	s0,a3
40001408:	00f687b3          	add	a5,a3,a5

	/*
	 * Patch in string pointers.
	 */
	for (i = 0; i < s_nbr; i++) {
4000140c:	00000a13          	li	s4,0
40001410:	076a6263          	bltu	s4,s6,40001474 <cbpprintf_external+0xc4>

	/* Skip past the header */
	buf += sizeof(*hdr);

	/* Turn this into a va_list and  print it */
	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
40001414:	00544703          	lbu	a4,5(s0)
40001418:	00444783          	lbu	a5,4(s0)
4000141c:	00744603          	lbu	a2,7(s0)
40001420:	00871713          	slli	a4,a4,0x8
40001424:	00f76733          	or	a4,a4,a5
40001428:	00644783          	lbu	a5,6(s0)
4000142c:	01861613          	slli	a2,a2,0x18
	return formatter(out, ctx, fmt, u.ap);
40001430:	00840693          	addi	a3,s0,8
	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
40001434:	01079793          	slli	a5,a5,0x10
}
40001438:	01812403          	lw	s0,24(sp)
	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
4000143c:	00e7e7b3          	or	a5,a5,a4
}
40001440:	01c12083          	lw	ra,28(sp)
40001444:	00812a03          	lw	s4,8(sp)
40001448:	00412a83          	lw	s5,4(sp)
4000144c:	00012b03          	lw	s6,0(sp)
	return formatter(out, ctx, fmt, u.ap);
40001450:	00f66633          	or	a2,a2,a5
40001454:	00090593          	mv	a1,s2
40001458:	00048513          	mv	a0,s1
}
4000145c:	01012903          	lw	s2,16(sp)
40001460:	01412483          	lw	s1,20(sp)
	return formatter(out, ctx, fmt, u.ap);
40001464:	00098793          	mv	a5,s3
}
40001468:	00c12983          	lw	s3,12(sp)
4000146c:	02010113          	addi	sp,sp,32
	return formatter(out, ctx, fmt, u.ap);
40001470:	00078067          	jr	a5
		s_idx = *(uint8_t *)s++;
40001474:	00178a93          	addi	s5,a5,1
40001478:	0007c783          	lbu	a5,0(a5)
		s += strlen(s) + 1;
4000147c:	000a8513          	mv	a0,s5
	for (i = 0; i < s_nbr; i++) {
40001480:	001a0a13          	addi	s4,s4,1
		*ps = s;
40001484:	00279793          	slli	a5,a5,0x2
40001488:	00f407b3          	add	a5,s0,a5
4000148c:	0157a023          	sw	s5,0(a5)
		s += strlen(s) + 1;
40001490:	7440b0ef          	jal	ra,4000cbd4 <strlen>
40001494:	00150793          	addi	a5,a0,1
40001498:	00fa87b3          	add	a5,s5,a5
	for (i = 0; i < s_nbr; i++) {
4000149c:	f75ff06f          	j	40001410 <cbpprintf_external+0x60>
}
400014a0:	fea00513          	li	a0,-22
400014a4:	00008067          	ret

400014a8 <is_ptr>:

/* Function checks if nth argument is a pointer (%p). Returns true is yes. Returns
 * false if not or if string does not have nth argument.
 */
bool is_ptr(const char *fmt, int n)
{
400014a8:	00050713          	mv	a4,a0
	char c;
	bool mod = false;
	int cnt = 0;
400014ac:	00000693          	li	a3,0
	bool mod = false;
400014b0:	00000513          	li	a0,0
				if (c == 'p') {
					return true;
				} else if (is_fmt_spec(c)) {
					return false;
				}
			} else if (is_fmt_spec(c)) {
400014b4:	03a00893          	li	a7,58
				if (c == 'p') {
400014b8:	07000313          	li	t1,112
				cnt++;
				mod = false;
			}
		}
		if (c == '%') {
400014bc:	02500e13          	li	t3,37
	while ((c = *fmt++) != '\0') {
400014c0:	00074783          	lbu	a5,0(a4)
400014c4:	00170813          	addi	a6,a4,1
400014c8:	00078e63          	beqz	a5,400014e4 <is_ptr+0x3c>
		if (mod) {
400014cc:	04050063          	beqz	a0,4000150c <is_ptr+0x64>
			if (cnt == n) {
400014d0:	00b69e63          	bne	a3,a1,400014ec <is_ptr+0x44>
				if (c == 'p') {
400014d4:	04678463          	beq	a5,t1,4000151c <is_ptr+0x74>
	return (c >= 64) && (c <= 122);
400014d8:	fc078713          	addi	a4,a5,-64
				} else if (is_fmt_spec(c)) {
400014dc:	0ff77713          	zext.b	a4,a4
400014e0:	02e8e663          	bltu	a7,a4,4000150c <is_ptr+0x64>
					return false;
400014e4:	00000513          	li	a0,0
400014e8:	00008067          	ret
	return (c >= 64) && (c <= 122);
400014ec:	fc078613          	addi	a2,a5,-64
			} else if (is_fmt_spec(c)) {
400014f0:	0ff67613          	zext.b	a2,a2
400014f4:	00c8ec63          	bltu	a7,a2,4000150c <is_ptr+0x64>
	while ((c = *fmt++) != '\0') {
400014f8:	00174783          	lbu	a5,1(a4)
				cnt++;
400014fc:	00168693          	addi	a3,a3,1
	while ((c = *fmt++) != '\0') {
40001500:	00270813          	addi	a6,a4,2
40001504:	00000513          	li	a0,0
40001508:	00078a63          	beqz	a5,4000151c <is_ptr+0x74>
		if (c == '%') {
4000150c:	01c79463          	bne	a5,t3,40001514 <is_ptr+0x6c>
			mod = !mod;
40001510:	00154513          	xori	a0,a0,1
	while ((c = *fmt++) != '\0') {
40001514:	00080713          	mv	a4,a6
40001518:	fa9ff06f          	j	400014c0 <is_ptr+0x18>
		}
	}

	return false;
}
4000151c:	00008067          	ret

40001520 <cbprintf_package_convert>:
			     cbprintf_convert_cb cb,
			     void *ctx,
			     uint32_t flags,
			     uint16_t *strl,
			     size_t strl_len)
{
40001520:	f6010113          	addi	sp,sp,-160
40001524:	08812c23          	sw	s0,152(sp)
40001528:	09212823          	sw	s2,144(sp)
4000152c:	09412423          	sw	s4,136(sp)
40001530:	07a12823          	sw	s10,112(sp)
40001534:	07b12623          	sw	s11,108(sp)
40001538:	08112e23          	sw	ra,156(sp)
4000153c:	08912a23          	sw	s1,148(sp)
40001540:	09312623          	sw	s3,140(sp)
40001544:	09512223          	sw	s5,132(sp)
40001548:	09612023          	sw	s6,128(sp)
4000154c:	07712e23          	sw	s7,124(sp)
40001550:	07812c23          	sw	s8,120(sp)
40001554:	07912a23          	sw	s9,116(sp)
40001558:	0a010413          	addi	s0,sp,160
	__ASSERT_NO_MSG(in_packaged != NULL);

	uint8_t *buf = in_packaged;
	uint32_t *buf32 = in_packaged;
	unsigned int args_size, ros_nbr, rws_nbr;
	bool fmt_present = flags & CBPRINTF_PACKAGE_CONVERT_PTR_CHECK ? true : false;
4000155c:	00375d93          	srli	s11,a4,0x3
{
40001560:	f8f42223          	sw	a5,-124(s0)
40001564:	001df793          	andi	a5,s11,1
40001568:	f8d42423          	sw	a3,-120(s0)
4000156c:	f9042623          	sw	a6,-116(s0)
40001570:	f8f42023          	sw	a5,-128(s0)
40001574:	00050d13          	mv	s10,a0
40001578:	00058913          	mv	s2,a1
4000157c:	00060a13          	mv	s4,a2
	bool rw_cpy;
	bool ro_cpy;
	struct cbprintf_package_desc *in_desc = in_packaged;

	in_len = in_len != 0 ? in_len : get_package_len(in_packaged);
40001580:	02059263          	bnez	a1,400015a4 <cbprintf_package_convert+0x84>
	s_nbr     = buf[1];
40001584:	00154a83          	lbu	s5,1(a0)
	args_size = buf[0] * sizeof(int);
40001588:	00054503          	lbu	a0,0(a0)
	ros_nbr   = buf[2];
4000158c:	002d4783          	lbu	a5,2(s10)
	args_size = buf[0] * sizeof(int);
40001590:	00251513          	slli	a0,a0,0x2
	buf += ros_nbr;
40001594:	00f50533          	add	a0,a0,a5
40001598:	00ad0533          	add	a0,s10,a0
	for (unsigned int i = 0; i < s_nbr; i++) {
4000159c:	09596063          	bltu	s2,s5,4000161c <cbprintf_package_convert+0xfc>
	return (size_t)(uintptr_t)(buf - start);
400015a0:	41a50933          	sub	s2,a0,s10

	/* Get number of RO string indexes in the package and check if copying
	 * includes appending those strings.
	 */
	ros_nbr = in_desc->ro_str_cnt;
400015a4:	002d4b83          	lbu	s7,2(s10)
		(flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) == CBPRINTF_PACKAGE_CONVERT_RO_STR;

	/* Get number of RW string indexes in the package and check if copying
	 * includes appending those strings.
	 */
	rws_nbr = in_desc->rw_str_cnt;
400015a8:	003d4b03          	lbu	s6,3(s10)
	ros_nbr = in_desc->ro_str_cnt;
400015ac:	000b8993          	mv	s3,s7
	ro_cpy = ros_nbr &&
400015b0:	000b8663          	beqz	s7,400015bc <cbprintf_package_convert+0x9c>
		(flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) == CBPRINTF_PACKAGE_CONVERT_RO_STR;
400015b4:	00177793          	andi	a5,a4,1
	ro_cpy = ros_nbr &&
400015b8:	08079463          	bnez	a5,40001640 <cbprintf_package_convert+0x120>
	rw_cpy = rws_nbr > 0 &&
400015bc:	1c0b1a63          	bnez	s6,40001790 <cbprintf_package_convert+0x270>
	/* If flags are not set or appending request without rw string indexes
	 * present is chosen, just do a simple copy (or length calculation).
	 * Assuming that it is the most common case.
	 */
	if (!rw_cpy && !ro_cpy) {
		if (cb) {
400015c0:	000a0a63          	beqz	s4,400015d4 <cbprintf_package_convert+0xb4>
			cb(in_packaged, in_len, ctx);
400015c4:	f8842603          	lw	a2,-120(s0)
400015c8:	00090593          	mv	a1,s2
400015cc:	000d0513          	mv	a0,s10
400015d0:	000a00e7          	jalr	s4
		}

		return in_len;
400015d4:	00090c93          	mv	s9,s2

	/* Empty call (can be interpreted as flushing) */
	(void)cb(NULL, 0, ctx);

	return out_len;
}
400015d8:	f6040113          	addi	sp,s0,-160
400015dc:	09c12083          	lw	ra,156(sp)
400015e0:	000c8513          	mv	a0,s9
400015e4:	09812403          	lw	s0,152(sp)
400015e8:	09412483          	lw	s1,148(sp)
400015ec:	09012903          	lw	s2,144(sp)
400015f0:	08c12983          	lw	s3,140(sp)
400015f4:	08812a03          	lw	s4,136(sp)
400015f8:	08412a83          	lw	s5,132(sp)
400015fc:	08012b03          	lw	s6,128(sp)
40001600:	07c12b83          	lw	s7,124(sp)
40001604:	07812c03          	lw	s8,120(sp)
40001608:	07412c83          	lw	s9,116(sp)
4000160c:	07012d03          	lw	s10,112(sp)
40001610:	06c12d83          	lw	s11,108(sp)
40001614:	0a010113          	addi	sp,sp,160
40001618:	00008067          	ret
		buf++;
4000161c:	00150993          	addi	s3,a0,1
		buf += strlen((const char *)buf) + 1;
40001620:	00098513          	mv	a0,s3
40001624:	f6e42e23          	sw	a4,-132(s0)
40001628:	5ac0b0ef          	jal	ra,4000cbd4 <strlen>
4000162c:	00150513          	addi	a0,a0,1
	for (unsigned int i = 0; i < s_nbr; i++) {
40001630:	f7c42703          	lw	a4,-132(s0)
		buf += strlen((const char *)buf) + 1;
40001634:	00a98533          	add	a0,s3,a0
	for (unsigned int i = 0; i < s_nbr; i++) {
40001638:	00190913          	addi	s2,s2,1
4000163c:	f61ff06f          	j	4000159c <cbprintf_package_convert+0x7c>
	rw_cpy = rws_nbr > 0 &&
40001640:	000d4a83          	lbu	s5,0(s10)
40001644:	004d2c03          	lw	s8,4(s10)
	args_size = in_desc->len * sizeof(int);
40001648:	002a9a93          	slli	s5,s5,0x2
	uint8_t *str_pos = &buf[args_size];
4000164c:	015d0db3          	add	s11,s10,s5
	if (cb == NULL) {
40001650:	320a1863          	bnez	s4,40001980 <cbprintf_package_convert+0x460>
		out_len = (int)in_len;
40001654:	00090c93          	mv	s9,s2
	size_t strl_cnt = 0;
40001658:	00000493          	li	s1,0
			for (unsigned int i = 0; i < ros_nbr; i++) {
4000165c:	00000913          	li	s2,0
				const char *str = *(const char **)&buf32[*str_pos];
40001660:	012d86b3          	add	a3,s11,s2
40001664:	0006c683          	lbu	a3,0(a3)
40001668:	f8e42423          	sw	a4,-120(s0)
4000166c:	00269693          	slli	a3,a3,0x2
40001670:	00dd06b3          	add	a3,s10,a3
		return 1 + strlen(str);
40001674:	0006a503          	lw	a0,0(a3)
40001678:	55c0b0ef          	jal	ra,4000cbd4 <strlen>
				if (strl && strl_cnt < strl_len) {
4000167c:	f8442783          	lw	a5,-124(s0)
40001680:	f8842703          	lw	a4,-120(s0)
		return 1 + strlen(str);
40001684:	00150513          	addi	a0,a0,1
				if (strl && strl_cnt < strl_len) {
40001688:	02078063          	beqz	a5,400016a8 <cbprintf_package_convert+0x188>
4000168c:	f8c42783          	lw	a5,-116(s0)
40001690:	00f4fc63          	bgeu	s1,a5,400016a8 <cbprintf_package_convert+0x188>
					strl[strl_cnt++] = (uint16_t)len;
40001694:	f8442783          	lw	a5,-124(s0)
40001698:	00149693          	slli	a3,s1,0x1
4000169c:	00148493          	addi	s1,s1,1
400016a0:	00d786b3          	add	a3,a5,a3
400016a4:	00a69023          	sh	a0,0(a3)
			for (unsigned int i = 0; i < ros_nbr; i++) {
400016a8:	00190913          	addi	s2,s2,1
				out_len += len;
400016ac:	00ac8cb3          	add	s9,s9,a0
			for (unsigned int i = 0; i < ros_nbr; i++) {
400016b0:	fb7968e3          	bltu	s2,s7,40001660 <cbprintf_package_convert+0x140>
400016b4:	017d8db3          	add	s11,s11,s7
		bool drop_ro_str_pos = !(flags &
400016b8:	00577993          	andi	s3,a4,5
400016bc:	0019b993          	seqz	s3,s3
400016c0:	001b1b13          	slli	s6,s6,0x1
400016c4:	40032a37          	lui	s4,0x40032
			} else if (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) {
400016c8:	00277793          	andi	a5,a4,2
400016cc:	40039ab7          	lui	s5,0x40039
400016d0:	00198993          	addi	s3,s3,1
400016d4:	016d8b33          	add	s6,s11,s6
400016d8:	27ca0a13          	addi	s4,s4,636 # 4003227c <__rodata_region_start>
400016dc:	f8f42423          	sw	a5,-120(s0)
400016e0:	fbca8a93          	addi	s5,s5,-68 # 40038fbc <__rodata_region_end>
				if (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) {
400016e4:	00177913          	andi	s2,a4,1
		for (unsigned int i = 0; i < rws_nbr; i++) {
400016e8:	ef6d88e3          	beq	s11,s6,400015d8 <cbprintf_package_convert+0xb8>
			uint8_t arg_idx = *str_pos++;
400016ec:	000dc583          	lbu	a1,0(s11)
			if (fmt_present && is_ptr(fmt, arg_idx)) {
400016f0:	f8042783          	lw	a5,-128(s0)
			uint8_t arg_pos = *str_pos++;
400016f4:	002d8d93          	addi	s11,s11,2
			const char *str = *(const char **)&buf32[arg_pos];
400016f8:	fffdc703          	lbu	a4,-1(s11)
400016fc:	00271713          	slli	a4,a4,0x2
40001700:	00ed0733          	add	a4,s10,a4
40001704:	00072b83          	lw	s7,0(a4)
40001708:	014be463          	bltu	s7,s4,40001710 <cbprintf_package_convert+0x1f0>
4000170c:	0d5be063          	bltu	s7,s5,400017cc <cbprintf_package_convert+0x2ac>
			if (fmt_present && is_ptr(fmt, arg_idx)) {
40001710:	0e078063          	beqz	a5,400017f0 <cbprintf_package_convert+0x2d0>
40001714:	000c0513          	mv	a0,s8
40001718:	f6b42e23          	sw	a1,-132(s0)
4000171c:	d8dff0ef          	jal	ra,400014a8 <is_ptr>
40001720:	f7c42583          	lw	a1,-132(s0)
40001724:	0c050663          	beqz	a0,400017f0 <cbprintf_package_convert+0x2d0>
				LOG_WRN("(unsigned) char * used for %%p argument. "
40001728:	40044537          	lui	a0,0x40044
4000172c:	72c52703          	lw	a4,1836(a0) # 4004472c <log_dynamic_cbprintf_package>
40001730:	00677713          	andi	a4,a4,6
40001734:	04070a63          	beqz	a4,40001788 <cbprintf_package_convert+0x268>
40001738:	00010b93          	mv	s7,sp
4000173c:	fd010113          	addi	sp,sp,-48
40001740:	00010613          	mv	a2,sp
40001744:	40033737          	lui	a4,0x40033
40001748:	91c70713          	addi	a4,a4,-1764 # 4003291c <__clz_tab+0x22c>
4000174c:	00e62a23          	sw	a4,20(a2)
40001750:	20000713          	li	a4,512
40001754:	02e61023          	sh	a4,32(a2)
40001758:	01000737          	lui	a4,0x1000
4000175c:	00470713          	addi	a4,a4,4 # 1000004 <__rom_region_size+0xfc7048>
40001760:	00b62e23          	sw	a1,28(a2)
40001764:	01862c23          	sw	s8,24(a2)
40001768:	00e62823          	sw	a4,16(a2)
4000176c:	000025b7          	lui	a1,0x2
40001770:	00000693          	li	a3,0
40001774:	01060613          	addi	a2,a2,16
40001778:	48058593          	addi	a1,a1,1152 # 2480 <CONFIG_SRAM_SIZE+0x480>
4000177c:	72c50513          	addi	a0,a0,1836
40001780:	015030ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
40001784:	000b8113          	mv	sp,s7
				out_len -= 2;
40001788:	ffec8c93          	addi	s9,s9,-2
				continue;
4000178c:	f5dff06f          	j	400016e8 <cbprintf_package_convert+0x1c8>
		 (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) == CBPRINTF_PACKAGE_CONVERT_RW_STR;
40001790:	00277793          	andi	a5,a4,2
	rw_cpy = rws_nbr > 0 &&
40001794:	e20786e3          	beqz	a5,400015c0 <cbprintf_package_convert+0xa0>
	args_size = in_desc->len * sizeof(int);
40001798:	000d4a83          	lbu	s5,0(s10)
	const char *fmt = *(const char **)(buf + sizeof(void *));
4000179c:	004d2c03          	lw	s8,4(s10)
	args_size = in_desc->len * sizeof(int);
400017a0:	002a9a93          	slli	s5,s5,0x2
	uint8_t *str_pos = &buf[args_size];
400017a4:	015d0db3          	add	s11,s10,s5
	if (cb == NULL) {
400017a8:	080a1463          	bnez	s4,40001830 <cbprintf_package_convert+0x310>
		out_len = (int)in_len;
400017ac:	00090c93          	mv	s9,s2
			if (ros_nbr && flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {
400017b0:	000b9663          	bnez	s7,400017bc <cbprintf_package_convert+0x29c>
	size_t strl_cnt = 0;
400017b4:	00000493          	li	s1,0
400017b8:	f01ff06f          	j	400016b8 <cbprintf_package_convert+0x198>
			if (ros_nbr && flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {
400017bc:	00477493          	andi	s1,a4,4
400017c0:	ee048ce3          	beqz	s1,400016b8 <cbprintf_package_convert+0x198>
				str_pos += ros_nbr;
400017c4:	017d8db3          	add	s11,s11,s7
400017c8:	fedff06f          	j	400017b4 <cbprintf_package_convert+0x294>
			if (fmt_present && is_ptr(fmt, arg_idx)) {
400017cc:	00078c63          	beqz	a5,400017e4 <cbprintf_package_convert+0x2c4>
400017d0:	000c0513          	mv	a0,s8
400017d4:	f6b42e23          	sw	a1,-132(s0)
400017d8:	cd1ff0ef          	jal	ra,400014a8 <is_ptr>
400017dc:	f7c42583          	lw	a1,-132(s0)
400017e0:	f40514e3          	bnez	a0,40001728 <cbprintf_package_convert+0x208>
				if (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) {
400017e4:	00091a63          	bnez	s2,400017f8 <cbprintf_package_convert+0x2d8>
					out_len -= drop_ro_str_pos ? 2 : 1;
400017e8:	413c8cb3          	sub	s9,s9,s3
400017ec:	efdff06f          	j	400016e8 <cbprintf_package_convert+0x1c8>
			} else if (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) {
400017f0:	f8842783          	lw	a5,-120(s0)
400017f4:	ee078ae3          	beqz	a5,400016e8 <cbprintf_package_convert+0x1c8>
		return 1 + strlen(str);
400017f8:	000b8513          	mv	a0,s7
400017fc:	3d80b0ef          	jal	ra,4000cbd4 <strlen>
				if (strl && strl_cnt < strl_len) {
40001800:	f8442783          	lw	a5,-124(s0)
40001804:	02078263          	beqz	a5,40001828 <cbprintf_package_convert+0x308>
40001808:	f8c42783          	lw	a5,-116(s0)
4000180c:	00f4fe63          	bgeu	s1,a5,40001828 <cbprintf_package_convert+0x308>
					strl[strl_cnt++] = (uint16_t)len;
40001810:	f8442783          	lw	a5,-124(s0)
40001814:	00149713          	slli	a4,s1,0x1
		return 1 + strlen(str);
40001818:	00150693          	addi	a3,a0,1
					strl[strl_cnt++] = (uint16_t)len;
4000181c:	00e78733          	add	a4,a5,a4
40001820:	00d71023          	sh	a3,0(a4)
40001824:	00148493          	addi	s1,s1,1
				out_len += (len - 1);
40001828:	00ac8cb3          	add	s9,s9,a0
		for (unsigned int i = 0; i < rws_nbr; i++) {
4000182c:	ebdff06f          	j	400016e8 <cbprintf_package_convert+0x1c8>
	} else if (ros_nbr && flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {
40001830:	140b8e63          	beqz	s7,4000198c <cbprintf_package_convert+0x46c>
40001834:	00477793          	andi	a5,a4,4
40001838:	14078a63          	beqz	a5,4000198c <cbprintf_package_convert+0x46c>
		keep_cnt = ros_nbr;
4000183c:	000b8493          	mv	s1,s7
		scpy_cnt = 0;
40001840:	00000993          	li	s3,0
		dst = keep_str_pos;
40001844:	fb040513          	addi	a0,s0,-80
		memcpy(dst, str_pos, ros_nbr);
40001848:	000b8613          	mv	a2,s7
4000184c:	000d8593          	mv	a1,s11
40001850:	f8e42623          	sw	a4,-116(s0)
40001854:	4a40b0ef          	jal	ra,4000ccf8 <memcpy>
40001858:	f8c42703          	lw	a4,-116(s0)
	str_pos += ros_nbr;
4000185c:	017d87b3          	add	a5,s11,s7
40001860:	001b1b13          	slli	s6,s6,0x1
40001864:	f8f42623          	sw	a5,-116(s0)
	for (unsigned int i = 0; i < rws_nbr; i++) {
40001868:	01678db3          	add	s11,a5,s6
4000186c:	400327b7          	lui	a5,0x40032
40001870:	27c78793          	addi	a5,a5,636 # 4003227c <__rodata_region_start>
40001874:	f6f42e23          	sw	a5,-132(s0)
			if (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) {
40001878:	00277793          	andi	a5,a4,2
4000187c:	f6f42c23          	sw	a5,-136(s0)
40001880:	400397b7          	lui	a5,0x40039
40001884:	fbc78793          	addi	a5,a5,-68 # 40038fbc <__rodata_region_end>
40001888:	f6f42a23          	sw	a5,-140(s0)
			if (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) {
4000188c:	00177793          	andi	a5,a4,1
40001890:	f6f42823          	sw	a5,-144(s0)
			} else if (flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {
40001894:	00477793          	andi	a5,a4,4
40001898:	f6f42623          	sw	a5,-148(s0)
	for (unsigned int i = 0; i < rws_nbr; i++) {
4000189c:	f8c42783          	lw	a5,-116(s0)
400018a0:	0efd9c63          	bne	s11,a5,40001998 <cbprintf_package_convert+0x478>
	out_desc.str_cnt = in_desc->str_cnt + scpy_cnt;
400018a4:	001d4c03          	lbu	s8,1(s10)
	out_desc.rw_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) ? 0 : (keep_cnt / 2);
400018a8:	00277613          	andi	a2,a4,2
	out_desc.len = in_desc->len;
400018ac:	000d4d83          	lbu	s11,0(s10)
	out_desc.str_cnt = in_desc->str_cnt + scpy_cnt;
400018b0:	018987b3          	add	a5,s3,s8
400018b4:	0ff7f793          	zext.b	a5,a5
	out_desc.rw_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) ? 0 : (keep_cnt / 2);
400018b8:	00000593          	li	a1,0
400018bc:	00061463          	bnez	a2,400018c4 <cbprintf_package_convert+0x3a4>
400018c0:	0014d593          	srli	a1,s1,0x1
	out_desc.ro_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) ? 0 :
400018c4:	00177613          	andi	a2,a4,1
400018c8:	00000513          	li	a0,0
400018cc:	00061863          	bnez	a2,400018dc <cbprintf_package_convert+0x3bc>
			((flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) ? keep_cnt : 0);
400018d0:	00477713          	andi	a4,a4,4
	out_desc.ro_str_cnt = (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) ? 0 :
400018d4:	00070463          	beqz	a4,400018dc <cbprintf_package_convert+0x3bc>
400018d8:	00048513          	mv	a0,s1
	struct cbprintf_package_desc in_desc_backup = *in_desc;
400018dc:	002d4803          	lbu	a6,2(s10)
400018e0:	003d4703          	lbu	a4,3(s10)
	rv = cb(in_packaged, args_size, ctx);
400018e4:	f8842603          	lw	a2,-120(s0)
	*in_desc = out_desc;
400018e8:	00ad0123          	sb	a0,2(s10)
400018ec:	00bd01a3          	sb	a1,3(s10)
	struct cbprintf_package_desc in_desc_backup = *in_desc;
400018f0:	f7042e23          	sw	a6,-132(s0)
400018f4:	f8e42023          	sw	a4,-128(s0)
	*in_desc = out_desc;
400018f8:	00fd00a3          	sb	a5,1(s10)
	rv = cb(in_packaged, args_size, ctx);
400018fc:	000a8593          	mv	a1,s5
40001900:	000d0513          	mv	a0,s10
40001904:	000a00e7          	jalr	s4
40001908:	00050c93          	mv	s9,a0
	if (rv < 0) {
4000190c:	cc0546e3          	bltz	a0,400015d8 <cbprintf_package_convert+0xb8>
	*in_desc = in_desc_backup;
40001910:	f7c42803          	lw	a6,-132(s0)
40001914:	f8042703          	lw	a4,-128(s0)
	rv = cb(keep_str_pos, keep_cnt, ctx);
40001918:	f8842603          	lw	a2,-120(s0)
	*in_desc = in_desc_backup;
4000191c:	018d00a3          	sb	s8,1(s10)
40001920:	01bd0023          	sb	s11,0(s10)
40001924:	010d0123          	sb	a6,2(s10)
40001928:	00ed01a3          	sb	a4,3(s10)
	rv = cb(keep_str_pos, keep_cnt, ctx);
4000192c:	00048593          	mv	a1,s1
40001930:	fb040513          	addi	a0,s0,-80
40001934:	000a00e7          	jalr	s4
40001938:	00050c13          	mv	s8,a0
	if (rv < 0) {
4000193c:	1c054263          	bltz	a0,40001b00 <cbprintf_package_convert+0x5e0>
	size_t strs_len = in_len - (args_size + ros_nbr + 2 * rws_nbr);
40001940:	417905b3          	sub	a1,s2,s7
	rv = cb(str_pos, strs_len, ctx);
40001944:	f8842603          	lw	a2,-120(s0)
40001948:	f8c42503          	lw	a0,-116(s0)
	size_t strs_len = in_len - (args_size + ros_nbr + 2 * rws_nbr);
4000194c:	415585b3          	sub	a1,a1,s5
	rv = cb(str_pos, strs_len, ctx);
40001950:	416585b3          	sub	a1,a1,s6
40001954:	000a00e7          	jalr	s4
	if (rv < 0) {
40001958:	1a054863          	bltz	a0,40001b08 <cbprintf_package_convert+0x5e8>
	out_len += rv;
4000195c:	018c8c33          	add	s8,s9,s8
	out_len += rv;
40001960:	00ac0cb3          	add	s9,s8,a0
	for (unsigned int i = 0; i < scpy_cnt; i++) {
40001964:	00000b13          	li	s6,0
40001968:	113b6a63          	bltu	s6,s3,40001a7c <cbprintf_package_convert+0x55c>
	(void)cb(NULL, 0, ctx);
4000196c:	f8842603          	lw	a2,-120(s0)
40001970:	00000593          	li	a1,0
40001974:	00000513          	li	a0,0
40001978:	000a00e7          	jalr	s4
	return out_len;
4000197c:	c5dff06f          	j	400015d8 <cbprintf_package_convert+0xb8>
	if (cb == NULL) {
40001980:	00000493          	li	s1,0
40001984:	fa040513          	addi	a0,s0,-96
40001988:	ec1ff06f          	j	40001848 <cbprintf_package_convert+0x328>
		scpy_cnt = 0;
4000198c:	00000993          	li	s3,0
		keep_cnt = 0;
40001990:	00000493          	li	s1,0
40001994:	ec9ff06f          	j	4000185c <cbprintf_package_convert+0x33c>
		uint8_t arg_idx = *str_pos++;
40001998:	f8c42783          	lw	a5,-116(s0)
4000199c:	f7c42683          	lw	a3,-132(s0)
400019a0:	0007c583          	lbu	a1,0(a5)
		uint8_t arg_pos = *str_pos++;
400019a4:	00278793          	addi	a5,a5,2
400019a8:	f8f42623          	sw	a5,-116(s0)
400019ac:	fff7cc83          	lbu	s9,-1(a5)
		const char *str = *(const char **)&buf32[arg_pos];
400019b0:	002c9793          	slli	a5,s9,0x2
400019b4:	00fd07b3          	add	a5,s10,a5
400019b8:	0007a783          	lw	a5,0(a5)
400019bc:	00d7e663          	bltu	a5,a3,400019c8 <cbprintf_package_convert+0x4a8>
400019c0:	f7442683          	lw	a3,-140(s0)
400019c4:	04d7ee63          	bltu	a5,a3,40001a20 <cbprintf_package_convert+0x500>
		if (fmt_present && is_ptr(fmt, arg_idx)) {
400019c8:	f8042783          	lw	a5,-128(s0)
400019cc:	02078063          	beqz	a5,400019ec <cbprintf_package_convert+0x4cc>
400019d0:	000c0513          	mv	a0,s8
400019d4:	f6e42223          	sw	a4,-156(s0)
400019d8:	f6b42423          	sw	a1,-152(s0)
400019dc:	acdff0ef          	jal	ra,400014a8 <is_ptr>
400019e0:	f6842583          	lw	a1,-152(s0)
400019e4:	f6442703          	lw	a4,-156(s0)
400019e8:	ea051ae3          	bnez	a0,4000189c <cbprintf_package_convert+0x37c>
			if (flags & CBPRINTF_PACKAGE_CONVERT_RW_STR) {
400019ec:	f7842783          	lw	a5,-136(s0)
400019f0:	04079a63          	bnez	a5,40001a44 <cbprintf_package_convert+0x524>
				keep_str_pos[keep_cnt++] = arg_idx;
400019f4:	00148793          	addi	a5,s1,1
400019f8:	fc048693          	addi	a3,s1,-64
400019fc:	0ff7f793          	zext.b	a5,a5
40001a00:	00868533          	add	a0,a3,s0
				keep_str_pos[keep_cnt++] = arg_pos;
40001a04:	fc078793          	addi	a5,a5,-64
				keep_str_pos[keep_cnt++] = arg_idx;
40001a08:	feb50823          	sb	a1,-16(a0)
				keep_str_pos[keep_cnt++] = arg_pos;
40001a0c:	00248693          	addi	a3,s1,2
40001a10:	008787b3          	add	a5,a5,s0
40001a14:	0ff6f493          	zext.b	s1,a3
40001a18:	ff978823          	sb	s9,-16(a5)
	for (unsigned int i = 0; i < rws_nbr; i++) {
40001a1c:	e81ff06f          	j	4000189c <cbprintf_package_convert+0x37c>
		if (fmt_present && is_ptr(fmt, arg_idx)) {
40001a20:	f8042783          	lw	a5,-128(s0)
40001a24:	00078c63          	beqz	a5,40001a3c <cbprintf_package_convert+0x51c>
40001a28:	000c0513          	mv	a0,s8
40001a2c:	f6e42423          	sw	a4,-152(s0)
40001a30:	a79ff0ef          	jal	ra,400014a8 <is_ptr>
40001a34:	f6842703          	lw	a4,-152(s0)
40001a38:	e60512e3          	bnez	a0,4000189c <cbprintf_package_convert+0x37c>
			if (flags & CBPRINTF_PACKAGE_CONVERT_RO_STR) {
40001a3c:	f7042783          	lw	a5,-144(s0)
40001a40:	00078e63          	beqz	a5,40001a5c <cbprintf_package_convert+0x53c>
				cpy_str_pos[scpy_cnt++] = arg_pos;
40001a44:	fc098693          	addi	a3,s3,-64
40001a48:	00198793          	addi	a5,s3,1
40001a4c:	008689b3          	add	s3,a3,s0
40001a50:	ff998023          	sb	s9,-32(s3)
40001a54:	0ff7f993          	zext.b	s3,a5
40001a58:	e45ff06f          	j	4000189c <cbprintf_package_convert+0x37c>
			} else if (flags & CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR) {
40001a5c:	f6c42783          	lw	a5,-148(s0)
40001a60:	e2078ee3          	beqz	a5,4000189c <cbprintf_package_convert+0x37c>
				keep_str_pos[keep_cnt++] = arg_pos;
40001a64:	fc048693          	addi	a3,s1,-64
40001a68:	00148793          	addi	a5,s1,1
40001a6c:	008686b3          	add	a3,a3,s0
40001a70:	ff968823          	sb	s9,-16(a3)
40001a74:	0ff7f493          	zext.b	s1,a5
40001a78:	e25ff06f          	j	4000189c <cbprintf_package_convert+0x37c>
		uint8_t loc = cpy_str_pos[i];
40001a7c:	fa040793          	addi	a5,s0,-96
40001a80:	01678733          	add	a4,a5,s6
40001a84:	00074703          	lbu	a4,0(a4)
		uint16_t str_len = strl ? strl[i] : 0;
40001a88:	f8442783          	lw	a5,-124(s0)
40001a8c:	00000913          	li	s2,0
		uint8_t loc = cpy_str_pos[i];
40001a90:	f8e40fa3          	sb	a4,-97(s0)
		const char *str = *(const char **)&buf32[loc];
40001a94:	00271713          	slli	a4,a4,0x2
40001a98:	00ed0733          	add	a4,s10,a4
40001a9c:	00072a83          	lw	s5,0(a4)
		uint16_t str_len = strl ? strl[i] : 0;
40001aa0:	00078863          	beqz	a5,40001ab0 <cbprintf_package_convert+0x590>
40001aa4:	001b1713          	slli	a4,s6,0x1
40001aa8:	00e78733          	add	a4,a5,a4
40001aac:	00075903          	lhu	s2,0(a4)
		rv = cb(&loc, 1, ctx);
40001ab0:	f8842603          	lw	a2,-120(s0)
40001ab4:	00100593          	li	a1,1
40001ab8:	f9f40513          	addi	a0,s0,-97
40001abc:	000a00e7          	jalr	s4
		if (rv < 0) {
40001ac0:	04054463          	bltz	a0,40001b08 <cbprintf_package_convert+0x5e8>
		out_len += rv;
40001ac4:	00ac8cb3          	add	s9,s9,a0
	strl = strl > 0 ? strl : strlen(str) + 1;
40001ac8:	00091c63          	bnez	s2,40001ae0 <cbprintf_package_convert+0x5c0>
40001acc:	000a8513          	mv	a0,s5
40001ad0:	1040b0ef          	jal	ra,4000cbd4 <strlen>
40001ad4:	00150913          	addi	s2,a0,1
40001ad8:	01091913          	slli	s2,s2,0x10
40001adc:	01095913          	srli	s2,s2,0x10
	return cb(str, strl, ctx);
40001ae0:	f8842603          	lw	a2,-120(s0)
40001ae4:	00090593          	mv	a1,s2
40001ae8:	000a8513          	mv	a0,s5
40001aec:	000a00e7          	jalr	s4
		if (rv < 0) {
40001af0:	00054c63          	bltz	a0,40001b08 <cbprintf_package_convert+0x5e8>
		out_len += rv;
40001af4:	00ac8cb3          	add	s9,s9,a0
	for (unsigned int i = 0; i < scpy_cnt; i++) {
40001af8:	001b0b13          	addi	s6,s6,1
40001afc:	e6dff06f          	j	40001968 <cbprintf_package_convert+0x448>
40001b00:	00050c93          	mv	s9,a0
40001b04:	ad5ff06f          	j	400015d8 <cbprintf_package_convert+0xb8>
40001b08:	00050c93          	mv	s9,a0
40001b0c:	acdff06f          	j	400015d8 <cbprintf_package_convert+0xb8>

40001b10 <char2hex>:
#include <errno.h>
#include <zephyr/sys/util.h>

int char2hex(char c, uint8_t *x)
{
	if (c >= '0' && c <= '9') {
40001b10:	fd050713          	addi	a4,a0,-48
40001b14:	0ff77713          	zext.b	a4,a4
40001b18:	00900693          	li	a3,9
{
40001b1c:	00050793          	mv	a5,a0
	if (c >= '0' && c <= '9') {
40001b20:	00e6e863          	bltu	a3,a4,40001b30 <char2hex+0x20>
		*x = c - '0';
40001b24:	00e58023          	sb	a4,0(a1)
		*x = c - 'A' + 10;
	} else {
		return -EINVAL;
	}

	return 0;
40001b28:	00000513          	li	a0,0
40001b2c:	00008067          	ret
	} else if (c >= 'a' && c <= 'f') {
40001b30:	f9f50713          	addi	a4,a0,-97
40001b34:	0ff77713          	zext.b	a4,a4
40001b38:	00500693          	li	a3,5
40001b3c:	00e6e863          	bltu	a3,a4,40001b4c <char2hex+0x3c>
		*x = c - 'a' + 10;
40001b40:	fa950793          	addi	a5,a0,-87
		*x = c - 'A' + 10;
40001b44:	0ff7f713          	zext.b	a4,a5
40001b48:	fddff06f          	j	40001b24 <char2hex+0x14>
	} else if (c >= 'A' && c <= 'F') {
40001b4c:	fbf50713          	addi	a4,a0,-65
40001b50:	0ff77713          	zext.b	a4,a4
		return -EINVAL;
40001b54:	fea00513          	li	a0,-22
	} else if (c >= 'A' && c <= 'F') {
40001b58:	00e6e663          	bltu	a3,a4,40001b64 <char2hex+0x54>
		*x = c - 'A' + 10;
40001b5c:	fc978793          	addi	a5,a5,-55
40001b60:	fe5ff06f          	j	40001b44 <char2hex+0x34>
}
40001b64:	00008067          	ret

40001b68 <hex2bin>:
	hex[2 * buflen] = '\0';
	return 2 * buflen;
}

size_t hex2bin(const char *hex, size_t hexlen, uint8_t *buf, size_t buflen)
{
40001b68:	fd010113          	addi	sp,sp,-48
40001b6c:	01312e23          	sw	s3,28(sp)
	uint8_t dec;

	if (buflen < hexlen / 2 + hexlen % 2) {
40001b70:	0015d993          	srli	s3,a1,0x1
40001b74:	0015f593          	andi	a1,a1,1
{
40001b78:	01412c23          	sw	s4,24(sp)
40001b7c:	02112623          	sw	ra,44(sp)
40001b80:	02812423          	sw	s0,40(sp)
40001b84:	02912223          	sw	s1,36(sp)
40001b88:	03212023          	sw	s2,32(sp)
	if (buflen < hexlen / 2 + hexlen % 2) {
40001b8c:	00b98a33          	add	s4,s3,a1
40001b90:	0346f663          	bgeu	a3,s4,40001bbc <hex2bin+0x54>
		return 0;
40001b94:	00000a13          	li	s4,0
		}
		buf[i] += dec;
	}

	return hexlen / 2 + hexlen % 2;
}
40001b98:	02c12083          	lw	ra,44(sp)
40001b9c:	02812403          	lw	s0,40(sp)
40001ba0:	02412483          	lw	s1,36(sp)
40001ba4:	02012903          	lw	s2,32(sp)
40001ba8:	01c12983          	lw	s3,28(sp)
40001bac:	000a0513          	mv	a0,s4
40001bb0:	01812a03          	lw	s4,24(sp)
40001bb4:	03010113          	addi	sp,sp,48
40001bb8:	00008067          	ret
40001bbc:	00050493          	mv	s1,a0
40001bc0:	00060413          	mv	s0,a2
	if (hexlen % 2) {
40001bc4:	02058263          	beqz	a1,40001be8 <hex2bin+0x80>
		if (char2hex(hex[0], &dec) < 0) {
40001bc8:	00054503          	lbu	a0,0(a0)
40001bcc:	00f10593          	addi	a1,sp,15
40001bd0:	f41ff0ef          	jal	ra,40001b10 <char2hex>
40001bd4:	fc0540e3          	bltz	a0,40001b94 <hex2bin+0x2c>
		buf[0] = dec;
40001bd8:	00f14783          	lbu	a5,15(sp)
		hex++;
40001bdc:	00148493          	addi	s1,s1,1
		buf++;
40001be0:	00140413          	addi	s0,s0,1
		buf[0] = dec;
40001be4:	fef40fa3          	sb	a5,-1(s0)
	for (size_t i = 0; i < hexlen / 2; i++) {
40001be8:	013409b3          	add	s3,s0,s3
40001bec:	fb3406e3          	beq	s0,s3,40001b98 <hex2bin+0x30>
		if (char2hex(hex[2 * i], &dec) < 0) {
40001bf0:	0004c503          	lbu	a0,0(s1)
40001bf4:	00f10593          	addi	a1,sp,15
40001bf8:	f19ff0ef          	jal	ra,40001b10 <char2hex>
40001bfc:	f8054ce3          	bltz	a0,40001b94 <hex2bin+0x2c>
		buf[i] = dec << 4;
40001c00:	00f14903          	lbu	s2,15(sp)
		if (char2hex(hex[2 * i + 1], &dec) < 0) {
40001c04:	00f10593          	addi	a1,sp,15
40001c08:	00248493          	addi	s1,s1,2
		buf[i] = dec << 4;
40001c0c:	00491913          	slli	s2,s2,0x4
40001c10:	0ff97913          	zext.b	s2,s2
40001c14:	01240023          	sb	s2,0(s0)
		if (char2hex(hex[2 * i + 1], &dec) < 0) {
40001c18:	fff4c503          	lbu	a0,-1(s1)
40001c1c:	ef5ff0ef          	jal	ra,40001b10 <char2hex>
40001c20:	f6054ae3          	bltz	a0,40001b94 <hex2bin+0x2c>
		buf[i] += dec;
40001c24:	00f14783          	lbu	a5,15(sp)
40001c28:	00140413          	addi	s0,s0,1
40001c2c:	00f90933          	add	s2,s2,a5
40001c30:	ff240fa3          	sb	s2,-1(s0)
	for (size_t i = 0; i < hexlen / 2; i++) {
40001c34:	fb9ff06f          	j	40001bec <hex2bin+0x84>

40001c38 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
40001c38:	00000513          	li	a0,0
40001c3c:	00008067          	ret

40001c40 <str_out>:
	int count;
};

static int str_out(int c, struct str_context *ctx)
{
	if (ctx->str == NULL || ctx->count >= ctx->max) {
40001c40:	0085a703          	lw	a4,8(a1)
40001c44:	0005a783          	lw	a5,0(a1)
		ctx->count++;
		return c;
	}

	if (ctx->count == ctx->max - 1) {
		ctx->str[ctx->count++] = '\0';
40001c48:	00170613          	addi	a2,a4,1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
40001c4c:	00078663          	beqz	a5,40001c58 <str_out+0x18>
40001c50:	0045a683          	lw	a3,4(a1)
40001c54:	00d74663          	blt	a4,a3,40001c60 <str_out+0x20>
		ctx->count++;
40001c58:	00c5a423          	sw	a2,8(a1)
		return c;
40001c5c:	00008067          	ret
	if (ctx->count == ctx->max - 1) {
40001c60:	fff68693          	addi	a3,a3,-1
		ctx->str[ctx->count++] = '\0';
40001c64:	00c5a423          	sw	a2,8(a1)
40001c68:	00e787b3          	add	a5,a5,a4
	if (ctx->count == ctx->max - 1) {
40001c6c:	00e69663          	bne	a3,a4,40001c78 <str_out+0x38>
		ctx->str[ctx->count++] = '\0';
40001c70:	00078023          	sb	zero,0(a5)
40001c74:	00008067          	ret
	} else {
		ctx->str[ctx->count++] = c;
40001c78:	00a78023          	sb	a0,0(a5)
	}

	return c;
}
40001c7c:	00008067          	ret

40001c80 <__printk_hook_install>:
	_char_out = fn;
40001c80:	400447b7          	lui	a5,0x40044
40001c84:	6aa7a623          	sw	a0,1708(a5) # 400446ac <_char_out>
}
40001c88:	00008067          	ret

40001c8c <printk>:
{
40001c8c:	fc010113          	addi	sp,sp,-64
40001c90:	02b12223          	sw	a1,36(sp)
	va_start(ap, fmt);
40001c94:	02410593          	addi	a1,sp,36
{
40001c98:	00112e23          	sw	ra,28(sp)
40001c9c:	02c12423          	sw	a2,40(sp)
40001ca0:	02d12623          	sw	a3,44(sp)
40001ca4:	02e12823          	sw	a4,48(sp)
40001ca8:	02f12a23          	sw	a5,52(sp)
40001cac:	03012c23          	sw	a6,56(sp)
40001cb0:	03112e23          	sw	a7,60(sp)
	va_start(ap, fmt);
40001cb4:	00b12623          	sw	a1,12(sp)
		z_log_vprintk(fmt, ap);
40001cb8:	7bc020ef          	jal	ra,40004474 <z_log_vprintk>
}
40001cbc:	01c12083          	lw	ra,28(sp)
40001cc0:	04010113          	addi	sp,sp,64
40001cc4:	00008067          	ret

40001cc8 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
40001cc8:	fe010113          	addi	sp,sp,-32
40001ccc:	00812c23          	sw	s0,24(sp)
	struct str_context ctx = { str, size, 0 };
40001cd0:	00a12223          	sw	a0,4(sp)
{
40001cd4:	00050413          	mv	s0,a0
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
40001cd8:	40002537          	lui	a0,0x40002
	struct str_context ctx = { str, size, 0 };
40001cdc:	00b12423          	sw	a1,8(sp)
40001ce0:	00000713          	li	a4,0
40001ce4:	00410593          	addi	a1,sp,4
40001ce8:	c4050513          	addi	a0,a0,-960 # 40001c40 <str_out>
{
40001cec:	00112e23          	sw	ra,28(sp)
	struct str_context ctx = { str, size, 0 };
40001cf0:	00012623          	sw	zero,12(sp)
40001cf4:	5a9000ef          	jal	ra,40002a9c <z_cbvprintf_impl>

	cbvprintf(str_out, &ctx, fmt, ap);

	if (ctx.count < ctx.max) {
40001cf8:	00c12503          	lw	a0,12(sp)
40001cfc:	00812783          	lw	a5,8(sp)
40001d00:	00f55663          	bge	a0,a5,40001d0c <vsnprintk+0x44>
		str[ctx.count] = '\0';
40001d04:	00a40433          	add	s0,s0,a0
40001d08:	00040023          	sb	zero,0(s0)
	}

	return ctx.count;
}
40001d0c:	01c12083          	lw	ra,28(sp)
40001d10:	01812403          	lw	s0,24(sp)
40001d14:	02010113          	addi	sp,sp,32
40001d18:	00008067          	ret

40001d1c <snprintk>:
{
40001d1c:	fc010113          	addi	sp,sp,-64
40001d20:	02d12623          	sw	a3,44(sp)
	va_start(ap, fmt);
40001d24:	02c10693          	addi	a3,sp,44
{
40001d28:	00112e23          	sw	ra,28(sp)
40001d2c:	02e12823          	sw	a4,48(sp)
40001d30:	02f12a23          	sw	a5,52(sp)
40001d34:	03012c23          	sw	a6,56(sp)
40001d38:	03112e23          	sw	a7,60(sp)
	va_start(ap, fmt);
40001d3c:	00d12623          	sw	a3,12(sp)
	ret = vsnprintk(str, size, fmt, ap);
40001d40:	f89ff0ef          	jal	ra,40001cc8 <vsnprintk>
}
40001d44:	01c12083          	lw	ra,28(sp)
40001d48:	04010113          	addi	sp,sp,64
40001d4c:	00008067          	ret

40001d50 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
40001d50:	ff010113          	addi	sp,sp,-16
40001d54:	00050793          	mv	a5,a0
40001d58:	00058513          	mv	a0,a1
40001d5c:	00060593          	mv	a1,a2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
40001d60:	00068613          	mv	a2,a3
{
40001d64:	00112623          	sw	ra,12(sp)
	entry(p1, p2, p3);
40001d68:	000780e7          	jalr	a5
	if (z_syscall_trap()) {
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
40001d6c:	1d82f0ef          	jal	ra,40030f44 <z_impl_z_current_get>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
40001d70:	3082f0ef          	jal	ra,40031078 <z_impl_k_thread_abort>

40001d74 <chunk_field>:
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
40001d74:	00852703          	lw	a4,8(a0)
	void *cmem = &buf[c];
40001d78:	00359593          	slli	a1,a1,0x3
	if (big_heap(h)) {
40001d7c:	000087b7          	lui	a5,0x8
	void *cmem = &buf[c];
40001d80:	00b505b3          	add	a1,a0,a1
	if (big_heap(h)) {
40001d84:	00f76a63          	bltu	a4,a5,40001d98 <chunk_field+0x24>
		return ((uint32_t *)cmem)[f];
40001d88:	00261613          	slli	a2,a2,0x2
40001d8c:	00c585b3          	add	a1,a1,a2
40001d90:	0005a503          	lw	a0,0(a1)
40001d94:	00008067          	ret
	} else {
		return ((uint16_t *)cmem)[f];
40001d98:	00161613          	slli	a2,a2,0x1
40001d9c:	00c585b3          	add	a1,a1,a2
40001da0:	0005d503          	lhu	a0,0(a1)
	}
}
40001da4:	00008067          	ret

40001da8 <chunk_set>:
	CHECK(c <= h->end_chunk);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
40001da8:	00852703          	lw	a4,8(a0)
	void *cmem = &buf[c];
40001dac:	00359593          	slli	a1,a1,0x3
	if (big_heap(h)) {
40001db0:	000087b7          	lui	a5,0x8
	void *cmem = &buf[c];
40001db4:	00b505b3          	add	a1,a0,a1
	if (big_heap(h)) {
40001db8:	00f76a63          	bltu	a4,a5,40001dcc <chunk_set+0x24>
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
40001dbc:	00261613          	slli	a2,a2,0x2
40001dc0:	00c585b3          	add	a1,a1,a2
40001dc4:	00d5a023          	sw	a3,0(a1)
40001dc8:	00008067          	ret
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
40001dcc:	00161613          	slli	a2,a2,0x1
40001dd0:	00c585b3          	add	a1,a1,a2
40001dd4:	00d59023          	sh	a3,0(a1)
	}
}
40001dd8:	00008067          	ret

40001ddc <chunk_size>:
{
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
40001ddc:	ff010113          	addi	sp,sp,-16
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
40001de0:	00100613          	li	a2,1
{
40001de4:	00112623          	sw	ra,12(sp)
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
40001de8:	f8dff0ef          	jal	ra,40001d74 <chunk_field>
}
40001dec:	00c12083          	lw	ra,12(sp)
40001df0:	00155513          	srli	a0,a0,0x1
40001df4:	01010113          	addi	sp,sp,16
40001df8:	00008067          	ret

40001dfc <set_chunk_used>:
static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
40001dfc:	00852703          	lw	a4,8(a0)
	void *cmem = &buf[c];
40001e00:	00359593          	slli	a1,a1,0x3
	if (big_heap(h)) {
40001e04:	000087b7          	lui	a5,0x8
	void *cmem = &buf[c];
40001e08:	00b505b3          	add	a1,a0,a1
	if (big_heap(h)) {
40001e0c:	02f76063          	bltu	a4,a5,40001e2c <set_chunk_used+0x30>
		if (used) {
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
40001e10:	0045a783          	lw	a5,4(a1)
		if (used) {
40001e14:	00060863          	beqz	a2,40001e24 <set_chunk_used+0x28>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
40001e18:	0017e793          	ori	a5,a5,1
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
40001e1c:	00f5a223          	sw	a5,4(a1)
40001e20:	00008067          	ret
40001e24:	ffe7f793          	andi	a5,a5,-2
40001e28:	ff5ff06f          	j	40001e1c <set_chunk_used+0x20>
		}
	} else {
		if (used) {
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
40001e2c:	0025d783          	lhu	a5,2(a1)
		if (used) {
40001e30:	00060863          	beqz	a2,40001e40 <set_chunk_used+0x44>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
40001e34:	0017e793          	ori	a5,a5,1
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
40001e38:	00f59123          	sh	a5,2(a1)
		}
	}
}
40001e3c:	00008067          	ret
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
40001e40:	ffe7f793          	andi	a5,a5,-2
40001e44:	ff5ff06f          	j	40001e38 <set_chunk_used+0x3c>

40001e48 <set_chunk_size>:
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, chunksz_t size)
{
	chunk_set(h, c, SIZE_AND_USED, size << 1);
40001e48:	00161693          	slli	a3,a2,0x1
40001e4c:	00100613          	li	a2,1
40001e50:	f59ff06f          	j	40001da8 <chunk_set>

40001e54 <mem_to_chunkid>:
	return big_heap(h) && chunk_size(h, c) == 1U;
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
40001e54:	00852703          	lw	a4,8(a0)
40001e58:	000087b7          	lui	a5,0x8
40001e5c:	00f76c63          	bltu	a4,a5,40001e74 <mem_to_chunkid+0x20>
40001e60:	00800793          	li	a5,8
 * boundary.
 */
static chunkid_t mem_to_chunkid(struct z_heap *h, void *p)
{
	uint8_t *mem = p, *base = (uint8_t *)chunk_buf(h);
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
40001e64:	40f585b3          	sub	a1,a1,a5
40001e68:	40a58533          	sub	a0,a1,a0
}
40001e6c:	00355513          	srli	a0,a0,0x3
40001e70:	00008067          	ret
40001e74:	00400793          	li	a5,4
40001e78:	fedff06f          	j	40001e64 <mem_to_chunkid+0x10>

40001e7c <bucket_idx.isra.0>:
static inline size_t chunksz_to_bytes(struct z_heap *h, chunksz_t chunksz_in)
{
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
40001e7c:	ff010113          	addi	sp,sp,-16
40001e80:	00112623          	sw	ra,12(sp)
	return big_heap(h) ? 8 : 4;
40001e84:	000087b7          	lui	a5,0x8
40001e88:	02f56863          	bltu	a0,a5,40001eb8 <bucket_idx.isra.0+0x3c>
40001e8c:	00800793          	li	a5,8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
40001e90:	00878793          	addi	a5,a5,8 # 8008 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4008>
40001e94:	0037d793          	srli	a5,a5,0x3
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
40001e98:	00158593          	addi	a1,a1,1
	return 31 - __builtin_clz(usable_sz);
40001e9c:	40f58533          	sub	a0,a1,a5
40001ea0:	b7cfe0ef          	jal	ra,4000021c <__clzsi2>
}
40001ea4:	00c12083          	lw	ra,12(sp)
40001ea8:	01f00793          	li	a5,31
40001eac:	40a78533          	sub	a0,a5,a0
40001eb0:	01010113          	addi	sp,sp,16
40001eb4:	00008067          	ret
	return big_heap(h) ? 8 : 4;
40001eb8:	00400793          	li	a5,4
40001ebc:	fd5ff06f          	j	40001e90 <bucket_idx.isra.0+0x14>

40001ec0 <free_list_remove_bidx>:
{
40001ec0:	fe010113          	addi	sp,sp,-32
40001ec4:	01412423          	sw	s4,8(sp)
40001ec8:	00060a13          	mv	s4,a2
	return chunk_field(h, c, FREE_NEXT);
40001ecc:	00300613          	li	a2,3
40001ed0:	00812c23          	sw	s0,24(sp)
40001ed4:	00912a23          	sw	s1,20(sp)
40001ed8:	01312623          	sw	s3,12(sp)
40001edc:	00112e23          	sw	ra,28(sp)
40001ee0:	01212823          	sw	s2,16(sp)
40001ee4:	00050413          	mv	s0,a0
40001ee8:	00058993          	mv	s3,a1
40001eec:	e89ff0ef          	jal	ra,40001d74 <chunk_field>
40001ef0:	004a0493          	addi	s1,s4,4
	if (next_free_chunk(h, c) == c) {
40001ef4:	04a99463          	bne	s3,a0,40001f3c <free_list_remove_bidx+0x7c>
		h->avail_buckets &= ~BIT(bidx);
40001ef8:	00c42783          	lw	a5,12(s0)
40001efc:	00100613          	li	a2,1
40001f00:	01461633          	sll	a2,a2,s4
40001f04:	fff64613          	not	a2,a2
		b->next = 0;
40001f08:	00249493          	slli	s1,s1,0x2
		h->avail_buckets &= ~BIT(bidx);
40001f0c:	00c7f7b3          	and	a5,a5,a2
40001f10:	00f42623          	sw	a5,12(s0)
		b->next = 0;
40001f14:	00940433          	add	s0,s0,s1
40001f18:	00042023          	sw	zero,0(s0)
}
40001f1c:	01c12083          	lw	ra,28(sp)
40001f20:	01812403          	lw	s0,24(sp)
40001f24:	01412483          	lw	s1,20(sp)
40001f28:	01012903          	lw	s2,16(sp)
40001f2c:	00c12983          	lw	s3,12(sp)
40001f30:	00812a03          	lw	s4,8(sp)
40001f34:	02010113          	addi	sp,sp,32
40001f38:	00008067          	ret
40001f3c:	00050913          	mv	s2,a0
	return chunk_field(h, c, FREE_PREV);
40001f40:	00098593          	mv	a1,s3
40001f44:	00200613          	li	a2,2
40001f48:	00040513          	mv	a0,s0
		b->next = second;
40001f4c:	00249493          	slli	s1,s1,0x2
40001f50:	e25ff0ef          	jal	ra,40001d74 <chunk_field>
40001f54:	009404b3          	add	s1,s0,s1
40001f58:	00050993          	mv	s3,a0
40001f5c:	0124a023          	sw	s2,0(s1)
	chunk_set(h, c, FREE_NEXT, next);
40001f60:	00090693          	mv	a3,s2
40001f64:	00050593          	mv	a1,a0
40001f68:	00300613          	li	a2,3
40001f6c:	00040513          	mv	a0,s0
40001f70:	e39ff0ef          	jal	ra,40001da8 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
40001f74:	00040513          	mv	a0,s0
}
40001f78:	01812403          	lw	s0,24(sp)
40001f7c:	01c12083          	lw	ra,28(sp)
40001f80:	01412483          	lw	s1,20(sp)
40001f84:	00812a03          	lw	s4,8(sp)
40001f88:	00098693          	mv	a3,s3
40001f8c:	00090593          	mv	a1,s2
40001f90:	00c12983          	lw	s3,12(sp)
40001f94:	01012903          	lw	s2,16(sp)
40001f98:	00200613          	li	a2,2
40001f9c:	02010113          	addi	sp,sp,32
40001fa0:	e09ff06f          	j	40001da8 <chunk_set>

40001fa4 <free_list_remove>:
{
40001fa4:	ff010113          	addi	sp,sp,-16
40001fa8:	00812423          	sw	s0,8(sp)
40001fac:	00912223          	sw	s1,4(sp)
40001fb0:	00112623          	sw	ra,12(sp)
40001fb4:	01212023          	sw	s2,0(sp)
	return big_heap_chunks(h->end_chunk);
40001fb8:	00852903          	lw	s2,8(a0)
40001fbc:	00058493          	mv	s1,a1
40001fc0:	00050413          	mv	s0,a0
	return big_heap(h) && chunk_size(h, c) == 1U;
40001fc4:	e19ff0ef          	jal	ra,40001ddc <chunk_size>
40001fc8:	000087b7          	lui	a5,0x8
40001fcc:	00050593          	mv	a1,a0
40001fd0:	00f96663          	bltu	s2,a5,40001fdc <free_list_remove+0x38>
40001fd4:	00100793          	li	a5,1
40001fd8:	02f50863          	beq	a0,a5,40002008 <free_list_remove+0x64>
		int bidx = bucket_idx(h, chunk_size(h, c));
40001fdc:	00090513          	mv	a0,s2
40001fe0:	e9dff0ef          	jal	ra,40001e7c <bucket_idx.isra.0>
40001fe4:	00050613          	mv	a2,a0
		free_list_remove_bidx(h, c, bidx);
40001fe8:	00040513          	mv	a0,s0
}
40001fec:	00812403          	lw	s0,8(sp)
40001ff0:	00c12083          	lw	ra,12(sp)
40001ff4:	00012903          	lw	s2,0(sp)
		free_list_remove_bidx(h, c, bidx);
40001ff8:	00048593          	mv	a1,s1
}
40001ffc:	00412483          	lw	s1,4(sp)
40002000:	01010113          	addi	sp,sp,16
		free_list_remove_bidx(h, c, bidx);
40002004:	ebdff06f          	j	40001ec0 <free_list_remove_bidx>
}
40002008:	00c12083          	lw	ra,12(sp)
4000200c:	00812403          	lw	s0,8(sp)
40002010:	00412483          	lw	s1,4(sp)
40002014:	00012903          	lw	s2,0(sp)
40002018:	01010113          	addi	sp,sp,16
4000201c:	00008067          	ret

40002020 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
40002020:	fe010113          	addi	sp,sp,-32
40002024:	00912a23          	sw	s1,20(sp)
40002028:	01212823          	sw	s2,16(sp)
4000202c:	01312623          	sw	s3,12(sp)
40002030:	01512223          	sw	s5,4(sp)
40002034:	01612023          	sw	s6,0(sp)
40002038:	00112e23          	sw	ra,28(sp)
4000203c:	00812c23          	sw	s0,24(sp)
40002040:	01412423          	sw	s4,8(sp)
40002044:	00050493          	mv	s1,a0
	int bi = bucket_idx(h, sz);
40002048:	00852503          	lw	a0,8(a0)
{
4000204c:	00058a93          	mv	s5,a1
	int bi = bucket_idx(h, sz);
40002050:	e2dff0ef          	jal	ra,40001e7c <bucket_idx.isra.0>
40002054:	00251993          	slli	s3,a0,0x2
40002058:	013489b3          	add	s3,s1,s3
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
4000205c:	0109ab03          	lw	s6,16(s3)
	int bi = bucket_idx(h, sz);
40002060:	00050913          	mv	s2,a0
	if (b->next) {
40002064:	060b0c63          	beqz	s6,400020dc <alloc_chunk+0xbc>
40002068:	00300a13          	li	s4,3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
4000206c:	0109a403          	lw	s0,16(s3)
			if (chunk_size(h, c) >= sz) {
40002070:	00048513          	mv	a0,s1
40002074:	00040593          	mv	a1,s0
40002078:	d65ff0ef          	jal	ra,40001ddc <chunk_size>
4000207c:	05556063          	bltu	a0,s5,400020bc <alloc_chunk+0x9c>
				free_list_remove_bidx(h, c, bi);
40002080:	00090613          	mv	a2,s2

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
40002084:	00040593          	mv	a1,s0
40002088:	00048513          	mv	a0,s1
4000208c:	e35ff0ef          	jal	ra,40001ec0 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
40002090:	01c12083          	lw	ra,28(sp)
40002094:	00040513          	mv	a0,s0
40002098:	01812403          	lw	s0,24(sp)
4000209c:	01412483          	lw	s1,20(sp)
400020a0:	01012903          	lw	s2,16(sp)
400020a4:	00c12983          	lw	s3,12(sp)
400020a8:	00812a03          	lw	s4,8(sp)
400020ac:	00412a83          	lw	s5,4(sp)
400020b0:	00012b03          	lw	s6,0(sp)
400020b4:	02010113          	addi	sp,sp,32
400020b8:	00008067          	ret
	return chunk_field(h, c, FREE_NEXT);
400020bc:	00300613          	li	a2,3
400020c0:	00040593          	mv	a1,s0
400020c4:	00048513          	mv	a0,s1
400020c8:	cadff0ef          	jal	ra,40001d74 <chunk_field>
			b->next = next_free_chunk(h, c);
400020cc:	00a9a823          	sw	a0,16(s3)
		} while (--i && b->next != first);
400020d0:	fffa0a13          	addi	s4,s4,-1
400020d4:	000a0463          	beqz	s4,400020dc <alloc_chunk+0xbc>
400020d8:	f8ab1ae3          	bne	s6,a0,4000206c <alloc_chunk+0x4c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
400020dc:	00c4a783          	lw	a5,12(s1)
400020e0:	00190913          	addi	s2,s2,1
400020e4:	fff00413          	li	s0,-1
400020e8:	01241433          	sll	s0,s0,s2
400020ec:	00f47433          	and	s0,s0,a5
	if (bmask != 0U) {
400020f0:	fa0400e3          	beqz	s0,40002090 <alloc_chunk+0x70>
		int minbucket = __builtin_ctz(bmask);
400020f4:	00040513          	mv	a0,s0
400020f8:	970fe0ef          	jal	ra,40000268 <__ctzsi2>
		chunkid_t c = h->buckets[minbucket].next;
400020fc:	00450793          	addi	a5,a0,4
40002100:	00279793          	slli	a5,a5,0x2
40002104:	00f487b3          	add	a5,s1,a5
40002108:	0007a403          	lw	s0,0(a5) # 8000 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4000>
		int minbucket = __builtin_ctz(bmask);
4000210c:	00050613          	mv	a2,a0
		chunkid_t c = h->buckets[minbucket].next;
40002110:	f75ff06f          	j	40002084 <alloc_chunk+0x64>

40002114 <split_chunks>:
{
40002114:	fd010113          	addi	sp,sp,-48
40002118:	02112623          	sw	ra,44(sp)
4000211c:	02812423          	sw	s0,40(sp)
40002120:	02912223          	sw	s1,36(sp)
40002124:	03212023          	sw	s2,32(sp)
40002128:	01312e23          	sw	s3,28(sp)
4000212c:	00060413          	mv	s0,a2
40002130:	00050493          	mv	s1,a0
40002134:	00058913          	mv	s2,a1
	chunksz_t sz0 = chunk_size(h, lc);
40002138:	ca5ff0ef          	jal	ra,40001ddc <chunk_size>
	chunksz_t lsz = rc - lc;
4000213c:	412406b3          	sub	a3,s0,s2
	chunksz_t rsz = sz0 - lsz;
40002140:	408909b3          	sub	s3,s2,s0
40002144:	00a989b3          	add	s3,s3,a0
	set_chunk_size(h, lc, lsz);
40002148:	00068613          	mv	a2,a3
4000214c:	00090593          	mv	a1,s2
40002150:	00048513          	mv	a0,s1
40002154:	00d12623          	sw	a3,12(sp)
40002158:	cf1ff0ef          	jal	ra,40001e48 <set_chunk_size>
	set_chunk_size(h, rc, rsz);
4000215c:	00098613          	mv	a2,s3
40002160:	00040593          	mv	a1,s0
40002164:	00048513          	mv	a0,s1
40002168:	ce1ff0ef          	jal	ra,40001e48 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
4000216c:	00c12683          	lw	a3,12(sp)
40002170:	00000613          	li	a2,0
40002174:	00040593          	mv	a1,s0
40002178:	00048513          	mv	a0,s1
4000217c:	c2dff0ef          	jal	ra,40001da8 <chunk_set>
	return c + chunk_size(h, c);
40002180:	00040593          	mv	a1,s0
40002184:	00048513          	mv	a0,s1
40002188:	c55ff0ef          	jal	ra,40001ddc <chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
4000218c:	00a405b3          	add	a1,s0,a0
}
40002190:	02812403          	lw	s0,40(sp)
40002194:	02c12083          	lw	ra,44(sp)
40002198:	02012903          	lw	s2,32(sp)
4000219c:	00098693          	mv	a3,s3
400021a0:	00048513          	mv	a0,s1
400021a4:	01c12983          	lw	s3,28(sp)
400021a8:	02412483          	lw	s1,36(sp)
400021ac:	00000613          	li	a2,0
400021b0:	03010113          	addi	sp,sp,48
400021b4:	bf5ff06f          	j	40001da8 <chunk_set>

400021b8 <merge_chunks>:
{
400021b8:	fe010113          	addi	sp,sp,-32
400021bc:	00112e23          	sw	ra,28(sp)
400021c0:	00812c23          	sw	s0,24(sp)
400021c4:	00912a23          	sw	s1,20(sp)
400021c8:	01212823          	sw	s2,16(sp)
400021cc:	01312623          	sw	s3,12(sp)
400021d0:	00060913          	mv	s2,a2
400021d4:	00050413          	mv	s0,a0
400021d8:	00058993          	mv	s3,a1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
400021dc:	c01ff0ef          	jal	ra,40001ddc <chunk_size>
400021e0:	00090593          	mv	a1,s2
400021e4:	00050493          	mv	s1,a0
400021e8:	00040513          	mv	a0,s0
400021ec:	bf1ff0ef          	jal	ra,40001ddc <chunk_size>
400021f0:	00a484b3          	add	s1,s1,a0
	set_chunk_size(h, lc, newsz);
400021f4:	00048613          	mv	a2,s1
400021f8:	00098593          	mv	a1,s3
400021fc:	00040513          	mv	a0,s0
40002200:	c49ff0ef          	jal	ra,40001e48 <set_chunk_size>
	return c + chunk_size(h, c);
40002204:	00090593          	mv	a1,s2
40002208:	00040513          	mv	a0,s0
4000220c:	bd1ff0ef          	jal	ra,40001ddc <chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
40002210:	00a905b3          	add	a1,s2,a0
40002214:	00040513          	mv	a0,s0
}
40002218:	01812403          	lw	s0,24(sp)
4000221c:	01c12083          	lw	ra,28(sp)
40002220:	01012903          	lw	s2,16(sp)
40002224:	00c12983          	lw	s3,12(sp)
40002228:	00048693          	mv	a3,s1
4000222c:	01412483          	lw	s1,20(sp)
40002230:	00000613          	li	a2,0
40002234:	02010113          	addi	sp,sp,32
40002238:	b71ff06f          	j	40001da8 <chunk_set>

4000223c <free_list_add>:
{
4000223c:	fe010113          	addi	sp,sp,-32
40002240:	00812c23          	sw	s0,24(sp)
40002244:	00912a23          	sw	s1,20(sp)
40002248:	00112e23          	sw	ra,28(sp)
4000224c:	01212823          	sw	s2,16(sp)
40002250:	01312623          	sw	s3,12(sp)
	return big_heap_chunks(h->end_chunk);
40002254:	00852903          	lw	s2,8(a0)
40002258:	00058493          	mv	s1,a1
4000225c:	00050413          	mv	s0,a0
	return big_heap(h) && chunk_size(h, c) == 1U;
40002260:	b7dff0ef          	jal	ra,40001ddc <chunk_size>
40002264:	000087b7          	lui	a5,0x8
40002268:	00050593          	mv	a1,a0
4000226c:	00f96663          	bltu	s2,a5,40002278 <free_list_add+0x3c>
40002270:	00100793          	li	a5,1
40002274:	0cf50a63          	beq	a0,a5,40002348 <free_list_add+0x10c>
		int bidx = bucket_idx(h, chunk_size(h, c));
40002278:	00090513          	mv	a0,s2
4000227c:	c01ff0ef          	jal	ra,40001e7c <bucket_idx.isra.0>
	if (b->next == 0U) {
40002280:	00251793          	slli	a5,a0,0x2
40002284:	00f407b3          	add	a5,s0,a5
40002288:	0107a903          	lw	s2,16(a5) # 8010 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4010>
4000228c:	04091e63          	bnez	s2,400022e8 <free_list_add+0xac>
		h->avail_buckets |= BIT(bidx);
40002290:	00c42703          	lw	a4,12(s0)
40002294:	00100693          	li	a3,1
40002298:	00a696b3          	sll	a3,a3,a0
4000229c:	00d76733          	or	a4,a4,a3
400022a0:	00e42623          	sw	a4,12(s0)
	chunk_set(h, c, FREE_PREV, prev);
400022a4:	00048693          	mv	a3,s1
400022a8:	00200613          	li	a2,2
400022ac:	00048593          	mv	a1,s1
		b->next = c;
400022b0:	0097a823          	sw	s1,16(a5)
400022b4:	00040513          	mv	a0,s0
400022b8:	af1ff0ef          	jal	ra,40001da8 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
400022bc:	00048693          	mv	a3,s1
400022c0:	00300613          	li	a2,3
400022c4:	00048593          	mv	a1,s1
	chunk_set(h, c, FREE_PREV, prev);
400022c8:	00040513          	mv	a0,s0
}
400022cc:	01812403          	lw	s0,24(sp)
400022d0:	01c12083          	lw	ra,28(sp)
400022d4:	01412483          	lw	s1,20(sp)
400022d8:	01012903          	lw	s2,16(sp)
400022dc:	00c12983          	lw	s3,12(sp)
400022e0:	02010113          	addi	sp,sp,32
400022e4:	ac5ff06f          	j	40001da8 <chunk_set>
	return chunk_field(h, c, FREE_PREV);
400022e8:	00200613          	li	a2,2
400022ec:	00090593          	mv	a1,s2
400022f0:	00040513          	mv	a0,s0
400022f4:	a81ff0ef          	jal	ra,40001d74 <chunk_field>
	chunk_set(h, c, FREE_PREV, prev);
400022f8:	00050693          	mv	a3,a0
	return chunk_field(h, c, FREE_PREV);
400022fc:	00050993          	mv	s3,a0
	chunk_set(h, c, FREE_PREV, prev);
40002300:	00200613          	li	a2,2
40002304:	00048593          	mv	a1,s1
40002308:	00040513          	mv	a0,s0
4000230c:	a9dff0ef          	jal	ra,40001da8 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
40002310:	00090693          	mv	a3,s2
40002314:	00300613          	li	a2,3
40002318:	00048593          	mv	a1,s1
4000231c:	00040513          	mv	a0,s0
40002320:	a89ff0ef          	jal	ra,40001da8 <chunk_set>
40002324:	00048693          	mv	a3,s1
40002328:	00300613          	li	a2,3
4000232c:	00098593          	mv	a1,s3
40002330:	00040513          	mv	a0,s0
40002334:	a75ff0ef          	jal	ra,40001da8 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
40002338:	00048693          	mv	a3,s1
4000233c:	00200613          	li	a2,2
40002340:	00090593          	mv	a1,s2
40002344:	f85ff06f          	j	400022c8 <free_list_add+0x8c>
40002348:	01c12083          	lw	ra,28(sp)
4000234c:	01812403          	lw	s0,24(sp)
40002350:	01412483          	lw	s1,20(sp)
40002354:	01012903          	lw	s2,16(sp)
40002358:	00c12983          	lw	s3,12(sp)
4000235c:	02010113          	addi	sp,sp,32
40002360:	00008067          	ret

40002364 <free_chunk>:
{
40002364:	fe010113          	addi	sp,sp,-32
40002368:	00112e23          	sw	ra,28(sp)
4000236c:	00812c23          	sw	s0,24(sp)
40002370:	00912a23          	sw	s1,20(sp)
40002374:	00058413          	mv	s0,a1
40002378:	00050493          	mv	s1,a0
	return c + chunk_size(h, c);
4000237c:	a61ff0ef          	jal	ra,40001ddc <chunk_size>
40002380:	00a405b3          	add	a1,s0,a0
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
40002384:	00100613          	li	a2,1
40002388:	00048513          	mv	a0,s1
4000238c:	00b12623          	sw	a1,12(sp)
40002390:	9e5ff0ef          	jal	ra,40001d74 <chunk_field>
	if (!chunk_used(h, right_chunk(h, c))) {
40002394:	00157513          	andi	a0,a0,1
40002398:	00c12583          	lw	a1,12(sp)
4000239c:	02051463          	bnez	a0,400023c4 <free_chunk+0x60>
		free_list_remove(h, right_chunk(h, c));
400023a0:	00048513          	mv	a0,s1
400023a4:	c01ff0ef          	jal	ra,40001fa4 <free_list_remove>
	return c + chunk_size(h, c);
400023a8:	00040593          	mv	a1,s0
400023ac:	00048513          	mv	a0,s1
400023b0:	a2dff0ef          	jal	ra,40001ddc <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
400023b4:	00a40633          	add	a2,s0,a0
400023b8:	00040593          	mv	a1,s0
400023bc:	00048513          	mv	a0,s1
400023c0:	df9ff0ef          	jal	ra,400021b8 <merge_chunks>
	return c - chunk_field(h, c, LEFT_SIZE);
400023c4:	00000613          	li	a2,0
400023c8:	00040593          	mv	a1,s0
400023cc:	00048513          	mv	a0,s1
400023d0:	9a5ff0ef          	jal	ra,40001d74 <chunk_field>
400023d4:	40a405b3          	sub	a1,s0,a0
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
400023d8:	00100613          	li	a2,1
400023dc:	00048513          	mv	a0,s1
400023e0:	00b12623          	sw	a1,12(sp)
400023e4:	991ff0ef          	jal	ra,40001d74 <chunk_field>
	if (!chunk_used(h, left_chunk(h, c))) {
400023e8:	00157513          	andi	a0,a0,1
400023ec:	00c12583          	lw	a1,12(sp)
400023f0:	04051063          	bnez	a0,40002430 <free_chunk+0xcc>
		free_list_remove(h, left_chunk(h, c));
400023f4:	00048513          	mv	a0,s1
400023f8:	badff0ef          	jal	ra,40001fa4 <free_list_remove>
	return c - chunk_field(h, c, LEFT_SIZE);
400023fc:	00040593          	mv	a1,s0
40002400:	00000613          	li	a2,0
40002404:	00048513          	mv	a0,s1
40002408:	96dff0ef          	jal	ra,40001d74 <chunk_field>
		merge_chunks(h, left_chunk(h, c), c);
4000240c:	40a405b3          	sub	a1,s0,a0
40002410:	00040613          	mv	a2,s0
40002414:	00048513          	mv	a0,s1
40002418:	da1ff0ef          	jal	ra,400021b8 <merge_chunks>
4000241c:	00040593          	mv	a1,s0
40002420:	00000613          	li	a2,0
40002424:	00048513          	mv	a0,s1
40002428:	94dff0ef          	jal	ra,40001d74 <chunk_field>
4000242c:	40a40433          	sub	s0,s0,a0
	free_list_add(h, c);
40002430:	00040593          	mv	a1,s0
}
40002434:	01812403          	lw	s0,24(sp)
40002438:	01c12083          	lw	ra,28(sp)
	free_list_add(h, c);
4000243c:	00048513          	mv	a0,s1
}
40002440:	01412483          	lw	s1,20(sp)
40002444:	02010113          	addi	sp,sp,32
	free_list_add(h, c);
40002448:	df5ff06f          	j	4000223c <free_list_add>

4000244c <sys_heap_free>:
	if (mem == NULL) {
4000244c:	04058463          	beqz	a1,40002494 <sys_heap_free+0x48>
{
40002450:	fe010113          	addi	sp,sp,-32
40002454:	00112e23          	sw	ra,28(sp)
40002458:	00812c23          	sw	s0,24(sp)
4000245c:	00052403          	lw	s0,0(a0)
	chunkid_t c = mem_to_chunkid(h, mem);
40002460:	00040513          	mv	a0,s0
40002464:	9f1ff0ef          	jal	ra,40001e54 <mem_to_chunkid>
40002468:	00050593          	mv	a1,a0
	set_chunk_used(h, c, false);
4000246c:	00a12623          	sw	a0,12(sp)
40002470:	00000613          	li	a2,0
40002474:	00040513          	mv	a0,s0
40002478:	985ff0ef          	jal	ra,40001dfc <set_chunk_used>
	free_chunk(h, c);
4000247c:	00040513          	mv	a0,s0
}
40002480:	01812403          	lw	s0,24(sp)
	free_chunk(h, c);
40002484:	00c12583          	lw	a1,12(sp)
}
40002488:	01c12083          	lw	ra,28(sp)
4000248c:	02010113          	addi	sp,sp,32
	free_chunk(h, c);
40002490:	ed5ff06f          	j	40002364 <free_chunk>
40002494:	00008067          	ret

40002498 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
40002498:	ff010113          	addi	sp,sp,-16
4000249c:	00112623          	sw	ra,12(sp)
400024a0:	00812423          	sw	s0,8(sp)
400024a4:	00912223          	sw	s1,4(sp)
400024a8:	01212023          	sw	s2,0(sp)
	struct z_heap *h = heap->heap;
400024ac:	00052903          	lw	s2,0(a0)
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
400024b0:	02059063          	bnez	a1,400024d0 <sys_heap_alloc+0x38>
		return NULL;
400024b4:	00000513          	li	a0,0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
400024b8:	00c12083          	lw	ra,12(sp)
400024bc:	00812403          	lw	s0,8(sp)
400024c0:	00412483          	lw	s1,4(sp)
400024c4:	00012903          	lw	s2,0(sp)
400024c8:	01010113          	addi	sp,sp,16
400024cc:	00008067          	ret
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
400024d0:	00892703          	lw	a4,8(s2)
400024d4:	0035d793          	srli	a5,a1,0x3
	if (bytes == 0U || size_too_big(h, bytes)) {
400024d8:	fce7fee3          	bgeu	a5,a4,400024b4 <sys_heap_alloc+0x1c>
	return big_heap(h) ? 8 : 4;
400024dc:	000086b7          	lui	a3,0x8
400024e0:	00400793          	li	a5,4
400024e4:	00d76463          	bltu	a4,a3,400024ec <sys_heap_alloc+0x54>
400024e8:	00800793          	li	a5,8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
400024ec:	00758413          	addi	s0,a1,7
400024f0:	00f40433          	add	s0,s0,a5
400024f4:	00345413          	srli	s0,s0,0x3
	chunkid_t c = alloc_chunk(h, chunk_sz);
400024f8:	00040593          	mv	a1,s0
400024fc:	00090513          	mv	a0,s2
40002500:	b21ff0ef          	jal	ra,40002020 <alloc_chunk>
40002504:	00050493          	mv	s1,a0
	if (c == 0U) {
40002508:	fa0506e3          	beqz	a0,400024b4 <sys_heap_alloc+0x1c>
	if (chunk_size(h, c) > chunk_sz) {
4000250c:	00050593          	mv	a1,a0
40002510:	00090513          	mv	a0,s2
40002514:	8c9ff0ef          	jal	ra,40001ddc <chunk_size>
40002518:	02a47263          	bgeu	s0,a0,4000253c <sys_heap_alloc+0xa4>
		split_chunks(h, c, c + chunk_sz);
4000251c:	00848433          	add	s0,s1,s0
40002520:	00048593          	mv	a1,s1
40002524:	00090513          	mv	a0,s2
40002528:	00040613          	mv	a2,s0
4000252c:	be9ff0ef          	jal	ra,40002114 <split_chunks>
		free_list_add(h, c + chunk_sz);
40002530:	00040593          	mv	a1,s0
40002534:	00090513          	mv	a0,s2
40002538:	d05ff0ef          	jal	ra,4000223c <free_list_add>
	set_chunk_used(h, c, true);
4000253c:	00048593          	mv	a1,s1
40002540:	00100613          	li	a2,1
40002544:	00090513          	mv	a0,s2
40002548:	8b5ff0ef          	jal	ra,40001dfc <set_chunk_used>
	return big_heap(h) ? 8 : 4;
4000254c:	00892683          	lw	a3,8(s2)
40002550:	00008737          	lui	a4,0x8
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
40002554:	00349493          	slli	s1,s1,0x3
40002558:	00400793          	li	a5,4
4000255c:	00e6e463          	bltu	a3,a4,40002564 <sys_heap_alloc+0xcc>
40002560:	00800793          	li	a5,8
40002564:	00f484b3          	add	s1,s1,a5
40002568:	00990533          	add	a0,s2,s1
	return mem;
4000256c:	f4dff06f          	j	400024b8 <sys_heap_alloc+0x20>

40002570 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
40002570:	fe010113          	addi	sp,sp,-32
40002574:	00812c23          	sw	s0,24(sp)
40002578:	01212823          	sw	s2,16(sp)
4000257c:	01512223          	sw	s5,4(sp)
40002580:	00112e23          	sw	ra,28(sp)
40002584:	00912a23          	sw	s1,20(sp)
40002588:	01312623          	sw	s3,12(sp)
4000258c:	01412423          	sw	s4,8(sp)
	struct z_heap *h = heap->heap;
40002590:	00052983          	lw	s3,0(a0)
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
	if (align != rew) {
40002594:	fff58a93          	addi	s5,a1,-1
40002598:	00bafab3          	and	s5,s5,a1
	return big_heap_chunks(h->end_chunk);
4000259c:	0089a683          	lw	a3,8(s3)
{
400025a0:	00058913          	mv	s2,a1
400025a4:	00060413          	mv	s0,a2
	if (align != rew) {
400025a8:	060a8063          	beqz	s5,40002608 <sys_heap_aligned_alloc+0x98>
	return big_heap(h) ? 8 : 4;
400025ac:	000087b7          	lui	a5,0x8
400025b0:	00400613          	li	a2,4
400025b4:	00f6e463          	bltu	a3,a5,400025bc <sys_heap_aligned_alloc+0x4c>
400025b8:	00800613          	li	a2,8
	rew = align & -align;
400025bc:	41200733          	neg	a4,s2
400025c0:	01277733          	and	a4,a4,s2
400025c4:	00070793          	mv	a5,a4
400025c8:	00e67463          	bgeu	a2,a4,400025d0 <sys_heap_aligned_alloc+0x60>
400025cc:	00060793          	mv	a5,a2
400025d0:	000a8913          	mv	s2,s5
400025d4:	00070a93          	mv	s5,a4
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
400025d8:	06041663          	bnez	s0,40002644 <sys_heap_aligned_alloc+0xd4>
		return NULL;
400025dc:	00000493          	li	s1,0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
400025e0:	01c12083          	lw	ra,28(sp)
400025e4:	01812403          	lw	s0,24(sp)
400025e8:	01012903          	lw	s2,16(sp)
400025ec:	00c12983          	lw	s3,12(sp)
400025f0:	00812a03          	lw	s4,8(sp)
400025f4:	00412a83          	lw	s5,4(sp)
400025f8:	00048513          	mv	a0,s1
400025fc:	01412483          	lw	s1,20(sp)
40002600:	02010113          	addi	sp,sp,32
40002604:	00008067          	ret
40002608:	00008737          	lui	a4,0x8
4000260c:	00400793          	li	a5,4
40002610:	00e6e463          	bltu	a3,a4,40002618 <sys_heap_aligned_alloc+0xa8>
40002614:	00800793          	li	a5,8
		if (align <= chunk_header_bytes(h)) {
40002618:	fd27e0e3          	bltu	a5,s2,400025d8 <sys_heap_aligned_alloc+0x68>
			return sys_heap_alloc(heap, bytes);
4000261c:	00040593          	mv	a1,s0
}
40002620:	01812403          	lw	s0,24(sp)
40002624:	01c12083          	lw	ra,28(sp)
40002628:	01412483          	lw	s1,20(sp)
4000262c:	01012903          	lw	s2,16(sp)
40002630:	00c12983          	lw	s3,12(sp)
40002634:	00812a03          	lw	s4,8(sp)
40002638:	00412a83          	lw	s5,4(sp)
4000263c:	02010113          	addi	sp,sp,32
			return sys_heap_alloc(heap, bytes);
40002640:	e59ff06f          	j	40002498 <sys_heap_alloc>
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
40002644:	00345713          	srli	a4,s0,0x3
	if (bytes == 0 || size_too_big(h, bytes)) {
40002648:	f8d77ae3          	bgeu	a4,a3,400025dc <sys_heap_aligned_alloc+0x6c>
	chunksz_t padded_sz = bytes_to_chunksz(h, bytes + align - gap);
4000264c:	00740593          	addi	a1,s0,7
	return big_heap(h) ? 8 : 4;
40002650:	00008637          	lui	a2,0x8
40002654:	012585b3          	add	a1,a1,s2
40002658:	00400713          	li	a4,4
4000265c:	00c6e463          	bltu	a3,a2,40002664 <sys_heap_aligned_alloc+0xf4>
40002660:	00800713          	li	a4,8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
40002664:	40f585b3          	sub	a1,a1,a5
40002668:	00e585b3          	add	a1,a1,a4
	chunkid_t c0 = alloc_chunk(h, padded_sz);
4000266c:	0035d593          	srli	a1,a1,0x3
40002670:	00098513          	mv	a0,s3
40002674:	9adff0ef          	jal	ra,40002020 <alloc_chunk>
40002678:	00050a13          	mv	s4,a0
	if (c0 == 0) {
4000267c:	f60500e3          	beqz	a0,400025dc <sys_heap_aligned_alloc+0x6c>
	return big_heap(h) ? 8 : 4;
40002680:	0089a683          	lw	a3,8(s3)
40002684:	00008737          	lui	a4,0x8
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
40002688:	00351493          	slli	s1,a0,0x3
4000268c:	00400793          	li	a5,4
40002690:	00e6e463          	bltu	a3,a4,40002698 <sys_heap_aligned_alloc+0x128>
40002694:	00800793          	li	a5,8
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
40002698:	009a84b3          	add	s1,s5,s1
4000269c:	00f484b3          	add	s1,s1,a5
400026a0:	009984b3          	add	s1,s3,s1
400026a4:	fff90793          	addi	a5,s2,-1
400026a8:	00f484b3          	add	s1,s1,a5
400026ac:	41200933          	neg	s2,s2
400026b0:	0124f4b3          	and	s1,s1,s2
400026b4:	415484b3          	sub	s1,s1,s5
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
400026b8:	00848433          	add	s0,s1,s0
400026bc:	00740413          	addi	s0,s0,7
	chunkid_t c = mem_to_chunkid(h, mem);
400026c0:	00048593          	mv	a1,s1
400026c4:	00098513          	mv	a0,s3
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
400026c8:	ff847413          	andi	s0,s0,-8
	chunkid_t c = mem_to_chunkid(h, mem);
400026cc:	f88ff0ef          	jal	ra,40001e54 <mem_to_chunkid>
	chunkid_t c_end = end - chunk_buf(h);
400026d0:	41340433          	sub	s0,s0,s3
	chunkid_t c = mem_to_chunkid(h, mem);
400026d4:	00050913          	mv	s2,a0
	chunkid_t c_end = end - chunk_buf(h);
400026d8:	40345413          	srai	s0,s0,0x3
	if (c > c0) {
400026dc:	02aa7063          	bgeu	s4,a0,400026fc <sys_heap_aligned_alloc+0x18c>
		split_chunks(h, c0, c);
400026e0:	00050613          	mv	a2,a0
400026e4:	000a0593          	mv	a1,s4
400026e8:	00098513          	mv	a0,s3
400026ec:	a29ff0ef          	jal	ra,40002114 <split_chunks>
		free_list_add(h, c0);
400026f0:	000a0593          	mv	a1,s4
400026f4:	00098513          	mv	a0,s3
400026f8:	b45ff0ef          	jal	ra,4000223c <free_list_add>
	return c + chunk_size(h, c);
400026fc:	00090593          	mv	a1,s2
40002700:	00098513          	mv	a0,s3
40002704:	ed8ff0ef          	jal	ra,40001ddc <chunk_size>
40002708:	00a90533          	add	a0,s2,a0
	if (right_chunk(h, c) > c_end) {
4000270c:	02a47063          	bgeu	s0,a0,4000272c <sys_heap_aligned_alloc+0x1bc>
		split_chunks(h, c, c_end);
40002710:	00090593          	mv	a1,s2
40002714:	00098513          	mv	a0,s3
40002718:	00040613          	mv	a2,s0
4000271c:	9f9ff0ef          	jal	ra,40002114 <split_chunks>
		free_list_add(h, c_end);
40002720:	00040593          	mv	a1,s0
40002724:	00098513          	mv	a0,s3
40002728:	b15ff0ef          	jal	ra,4000223c <free_list_add>
	set_chunk_used(h, c, true);
4000272c:	00100613          	li	a2,1
40002730:	00090593          	mv	a1,s2
40002734:	00098513          	mv	a0,s3
40002738:	ec4ff0ef          	jal	ra,40001dfc <set_chunk_used>
	return mem;
4000273c:	ea5ff06f          	j	400025e0 <sys_heap_aligned_alloc+0x70>

40002740 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
40002740:	fe010113          	addi	sp,sp,-32
40002744:	00112e23          	sw	ra,28(sp)
40002748:	00812c23          	sw	s0,24(sp)
4000274c:	00912a23          	sw	s1,20(sp)
40002750:	01212823          	sw	s2,16(sp)
40002754:	01312623          	sw	s3,12(sp)
	return big_heap_bytes(size) ? 8 : 4;
40002758:	00040737          	lui	a4,0x40
4000275c:	00400793          	li	a5,4
40002760:	00e66463          	bltu	a2,a4,40002768 <sys_heap_init+0x28>
40002764:	00800793          	li	a5,8
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
40002768:	40f60633          	sub	a2,a2,a5

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
4000276c:	00c58433          	add	s0,a1,a2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
40002770:	00758493          	addi	s1,a1,7
40002774:	ff84f493          	andi	s1,s1,-8
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
40002778:	ff847413          	andi	s0,s0,-8
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
4000277c:	40940433          	sub	s0,s0,s1

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
40002780:	00952023          	sw	s1,0(a0)
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
40002784:	00345413          	srli	s0,s0,0x3
	h->end_chunk = heap_sz;
40002788:	0084a423          	sw	s0,8(s1)
	h->avail_buckets = 0;
4000278c:	0004a623          	sw	zero,12(s1)
	h->free_bytes = 0;
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
40002790:	00040593          	mv	a1,s0
40002794:	00040513          	mv	a0,s0
40002798:	ee4ff0ef          	jal	ra,40001e7c <bucket_idx.isra.0>
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
4000279c:	00251913          	slli	s2,a0,0x2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
400027a0:	01b90913          	addi	s2,s2,27
400027a4:	00395913          	srli	s2,s2,0x3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
400027a8:	01048713          	addi	a4,s1,16
400027ac:	00000793          	li	a5,0
400027b0:	0af55c63          	bge	a0,a5,40002868 <sys_heap_init+0x128>
		h->buckets[i].next = 0;
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
400027b4:	00090613          	mv	a2,s2
400027b8:	00048513          	mv	a0,s1
400027bc:	00000593          	li	a1,0
400027c0:	e88ff0ef          	jal	ra,40001e48 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
400027c4:	00000693          	li	a3,0
400027c8:	00048513          	mv	a0,s1
400027cc:	00000613          	li	a2,0
400027d0:	00000593          	li	a1,0
400027d4:	dd4ff0ef          	jal	ra,40001da8 <chunk_set>
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);
400027d8:	00048513          	mv	a0,s1
400027dc:	00100613          	li	a2,1
400027e0:	00000593          	li	a1,0
400027e4:	e18ff0ef          	jal	ra,40001dfc <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
400027e8:	412409b3          	sub	s3,s0,s2
400027ec:	00098613          	mv	a2,s3
400027f0:	00090593          	mv	a1,s2
400027f4:	00048513          	mv	a0,s1
400027f8:	e50ff0ef          	jal	ra,40001e48 <set_chunk_size>
400027fc:	00090693          	mv	a3,s2
40002800:	00090593          	mv	a1,s2
40002804:	00048513          	mv	a0,s1
40002808:	00000613          	li	a2,0
4000280c:	d9cff0ef          	jal	ra,40001da8 <chunk_set>
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
40002810:	00040593          	mv	a1,s0
40002814:	00048513          	mv	a0,s1
40002818:	00000613          	li	a2,0
4000281c:	e2cff0ef          	jal	ra,40001e48 <set_chunk_size>
40002820:	00098693          	mv	a3,s3
40002824:	00040593          	mv	a1,s0
40002828:	00048513          	mv	a0,s1
4000282c:	00000613          	li	a2,0
40002830:	d78ff0ef          	jal	ra,40001da8 <chunk_set>
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
40002834:	00040593          	mv	a1,s0
40002838:	00048513          	mv	a0,s1
4000283c:	00100613          	li	a2,1
40002840:	dbcff0ef          	jal	ra,40001dfc <set_chunk_used>

	free_list_add(h, chunk0_size);
}
40002844:	01812403          	lw	s0,24(sp)
40002848:	01c12083          	lw	ra,28(sp)
4000284c:	00c12983          	lw	s3,12(sp)
	free_list_add(h, chunk0_size);
40002850:	00090593          	mv	a1,s2
40002854:	00048513          	mv	a0,s1
}
40002858:	01012903          	lw	s2,16(sp)
4000285c:	01412483          	lw	s1,20(sp)
40002860:	02010113          	addi	sp,sp,32
	free_list_add(h, chunk0_size);
40002864:	9d9ff06f          	j	4000223c <free_list_add>
		h->buckets[i].next = 0;
40002868:	00072023          	sw	zero,0(a4) # 40000 <__rom_region_size+0x7044>
	for (int i = 0; i < nb_buckets; i++) {
4000286c:	00178793          	addi	a5,a5,1 # 8001 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4001>
40002870:	00470713          	addi	a4,a4,4
40002874:	f3dff06f          	j	400027b0 <sys_heap_init+0x70>

40002878 <crc16_reflect>:

	return crc;
}

uint16_t crc16_reflect(uint16_t poly, uint16_t seed, const uint8_t *src, size_t len)
{
40002878:	00050713          	mv	a4,a0
	uint16_t crc = seed;
	size_t i, j;

	for (i = 0; i < len; i++) {
4000287c:	00000793          	li	a5,0
	uint16_t crc = seed;
40002880:	00058513          	mv	a0,a1
	for (i = 0; i < len; i++) {
40002884:	00d79463          	bne	a5,a3,4000288c <crc16_reflect+0x14>
		}
	}


	return crc;
}
40002888:	00008067          	ret
		crc ^= (uint16_t)src[i];
4000288c:	00f605b3          	add	a1,a2,a5
40002890:	0005c583          	lbu	a1,0(a1)
40002894:	00800813          	li	a6,8
40002898:	00b54533          	xor	a0,a0,a1
			if (crc & 0x0001UL) {
4000289c:	00157593          	andi	a1,a0,1
				crc = (crc >> 1U) ^ poly;
400028a0:	00155513          	srli	a0,a0,0x1
			if (crc & 0x0001UL) {
400028a4:	00058863          	beqz	a1,400028b4 <crc16_reflect+0x3c>
				crc = (crc >> 1U) ^ poly;
400028a8:	00a745b3          	xor	a1,a4,a0
400028ac:	01059513          	slli	a0,a1,0x10
400028b0:	01055513          	srli	a0,a0,0x10
		for (j = 0; j < 8; j++) {
400028b4:	fff80813          	addi	a6,a6,-1
400028b8:	fe0812e3          	bnez	a6,4000289c <crc16_reflect+0x24>
	for (i = 0; i < len; i++) {
400028bc:	00178793          	addi	a5,a5,1
400028c0:	fc5ff06f          	j	40002884 <crc16_reflect+0xc>

400028c4 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
400028c4:	fd010113          	addi	sp,sp,-48
400028c8:	02812423          	sw	s0,40(sp)
400028cc:	02912223          	sw	s1,36(sp)
400028d0:	03212023          	sw	s2,32(sp)
400028d4:	01312e23          	sw	s3,28(sp)
400028d8:	01712623          	sw	s7,12(sp)
400028dc:	01812423          	sw	s8,8(sp)
400028e0:	01912223          	sw	s9,4(sp)
400028e4:	02112623          	sw	ra,44(sp)
400028e8:	01412c23          	sw	s4,24(sp)
400028ec:	01512a23          	sw	s5,20(sp)
400028f0:	01612823          	sw	s6,16(sp)
	bool upcase = isupper((int)conv->specifier) != 0;
400028f4:	00364783          	lbu	a5,3(a2) # 8003 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4003>
{
400028f8:	00070b93          	mv	s7,a4
	switch (specifier) {
400028fc:	06f00713          	li	a4,111
{
40002900:	00050413          	mv	s0,a0
40002904:	00058493          	mv	s1,a1
40002908:	00060c93          	mv	s9,a2
4000290c:	00068913          	mv	s2,a3
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
40002910:	fbf78993          	addi	s3,a5,-65
	switch (specifier) {
40002914:	00800c13          	li	s8,8
40002918:	00e78c63          	beq	a5,a4,40002930 <encode_uint+0x6c>
4000291c:	0cf76263          	bltu	a4,a5,400029e0 <encode_uint+0x11c>
40002920:	05800713          	li	a4,88
		return 16;
40002924:	01000c13          	li	s8,16
	switch (specifier) {
40002928:	00e78463          	beq	a5,a4,40002930 <encode_uint+0x6c>
		return 10;
4000292c:	00a00c13          	li	s8,10
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
40002930:	00000a93          	li	s5,0

		*--bp = (lsv <= 9) ? ('0' + lsv)
40002934:	00900a13          	li	s4,9
40002938:	01900b13          	li	s6,25
		unsigned int lsv = (unsigned int)(value % radix);
4000293c:	000c0613          	mv	a2,s8
40002940:	00000693          	li	a3,0
40002944:	00040513          	mv	a0,s0
40002948:	00048593          	mv	a1,s1
4000294c:	d9dfd0ef          	jal	ra,400006e8 <__umoddi3>
		*--bp = (lsv <= 9) ? ('0' + lsv)
40002950:	0ff57793          	zext.b	a5,a0
40002954:	0aaa6263          	bltu	s4,a0,400029f8 <encode_uint+0x134>
40002958:	03078793          	addi	a5,a5,48
4000295c:	0ff7f793          	zext.b	a5,a5
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
40002960:	000c0613          	mv	a2,s8
40002964:	00000693          	li	a3,0
40002968:	00040513          	mv	a0,s0
4000296c:	00048593          	mv	a1,s1
		*--bp = (lsv <= 9) ? ('0' + lsv)
40002970:	fefb8fa3          	sb	a5,-1(s7)
40002974:	fffb8b93          	addi	s7,s7,-1
		value /= radix;
40002978:	941fd0ef          	jal	ra,400002b8 <__udivdi3>
	} while ((value != 0) && (bps < bp));
4000297c:	009a9463          	bne	s5,s1,40002984 <encode_uint+0xc0>
40002980:	01846463          	bltu	s0,s8,40002988 <encode_uint+0xc4>
40002984:	07796463          	bltu	s2,s7,400029ec <encode_uint+0x128>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
40002988:	000cd783          	lhu	a5,0(s9)
4000298c:	0207f793          	andi	a5,a5,32
40002990:	00078c63          	beqz	a5,400029a8 <encode_uint+0xe4>
		if (radix == 8) {
40002994:	00800793          	li	a5,8
40002998:	06fc1a63          	bne	s8,a5,40002a0c <encode_uint+0x148>
			conv->altform_0 = true;
4000299c:	002cc783          	lbu	a5,2(s9)
400029a0:	0087e793          	ori	a5,a5,8
		} else if (radix == 16) {
			conv->altform_0c = true;
400029a4:	00fc8123          	sb	a5,2(s9)
			;
		}
	}

	return bp;
}
400029a8:	02c12083          	lw	ra,44(sp)
400029ac:	02812403          	lw	s0,40(sp)
400029b0:	02412483          	lw	s1,36(sp)
400029b4:	02012903          	lw	s2,32(sp)
400029b8:	01c12983          	lw	s3,28(sp)
400029bc:	01812a03          	lw	s4,24(sp)
400029c0:	01412a83          	lw	s5,20(sp)
400029c4:	01012b03          	lw	s6,16(sp)
400029c8:	00812c03          	lw	s8,8(sp)
400029cc:	00412c83          	lw	s9,4(sp)
400029d0:	000b8513          	mv	a0,s7
400029d4:	00c12b83          	lw	s7,12(sp)
400029d8:	03010113          	addi	sp,sp,48
400029dc:	00008067          	ret
	switch (specifier) {
400029e0:	0f77f793          	andi	a5,a5,247
400029e4:	07000713          	li	a4,112
400029e8:	f3dff06f          	j	40002924 <encode_uint+0x60>
		value /= radix;
400029ec:	00050413          	mv	s0,a0
400029f0:	00058493          	mv	s1,a1
400029f4:	f49ff06f          	j	4000293c <encode_uint+0x78>
		*--bp = (lsv <= 9) ? ('0' + lsv)
400029f8:	013b6663          	bltu	s6,s3,40002a04 <encode_uint+0x140>
400029fc:	03778793          	addi	a5,a5,55
40002a00:	f5dff06f          	j	4000295c <encode_uint+0x98>
40002a04:	05778793          	addi	a5,a5,87
40002a08:	f55ff06f          	j	4000295c <encode_uint+0x98>
		} else if (radix == 16) {
40002a0c:	01000793          	li	a5,16
40002a10:	f8fc1ce3          	bne	s8,a5,400029a8 <encode_uint+0xe4>
			conv->altform_0c = true;
40002a14:	002cc783          	lbu	a5,2(s9)
40002a18:	0107e793          	ori	a5,a5,16
40002a1c:	f89ff06f          	j	400029a4 <encode_uint+0xe0>

40002a20 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
40002a20:	fe010113          	addi	sp,sp,-32
40002a24:	00812c23          	sw	s0,24(sp)
40002a28:	00912a23          	sw	s1,20(sp)
40002a2c:	01212823          	sw	s2,16(sp)
40002a30:	01312623          	sw	s3,12(sp)
40002a34:	01412423          	sw	s4,8(sp)
40002a38:	00112e23          	sw	ra,28(sp)
40002a3c:	00050993          	mv	s3,a0
40002a40:	00058a13          	mv	s4,a1
40002a44:	00060493          	mv	s1,a2
40002a48:	00068913          	mv	s2,a3
	size_t count = 0;

	while ((sp < ep) || ((ep == NULL) && *sp)) {
40002a4c:	00060413          	mv	s0,a2
40002a50:	01246c63          	bltu	s0,s2,40002a68 <outs+0x48>
40002a54:	00090663          	beqz	s2,40002a60 <outs+0x40>
			return rc;
		}
		++count;
	}

	return (int)count;
40002a58:	40940533          	sub	a0,s0,s1
40002a5c:	0200006f          	j	40002a7c <outs+0x5c>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
40002a60:	00044783          	lbu	a5,0(s0)
40002a64:	fe078ae3          	beqz	a5,40002a58 <outs+0x38>
		int rc = out((int)*sp++, ctx);
40002a68:	00044503          	lbu	a0,0(s0)
40002a6c:	000a0593          	mv	a1,s4
40002a70:	00140413          	addi	s0,s0,1
40002a74:	000980e7          	jalr	s3
		if (rc < 0) {
40002a78:	fc055ce3          	bgez	a0,40002a50 <outs+0x30>
}
40002a7c:	01c12083          	lw	ra,28(sp)
40002a80:	01812403          	lw	s0,24(sp)
40002a84:	01412483          	lw	s1,20(sp)
40002a88:	01012903          	lw	s2,16(sp)
40002a8c:	00c12983          	lw	s3,12(sp)
40002a90:	00812a03          	lw	s4,8(sp)
40002a94:	02010113          	addi	sp,sp,32
40002a98:	00008067          	ret

40002a9c <z_cbvprintf_impl>:

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
40002a9c:	f7010113          	addi	sp,sp,-144
40002aa0:	08812423          	sw	s0,136(sp)
40002aa4:	08912223          	sw	s1,132(sp)
40002aa8:	07412c23          	sw	s4,120(sp)
40002aac:	07912223          	sw	s9,100(sp)
40002ab0:	07a12023          	sw	s10,96(sp)
40002ab4:	08112623          	sw	ra,140(sp)
40002ab8:	09212023          	sw	s2,128(sp)
40002abc:	07312e23          	sw	s3,124(sp)
40002ac0:	07512a23          	sw	s5,116(sp)
40002ac4:	07612823          	sw	s6,112(sp)
40002ac8:	07712623          	sw	s7,108(sp)
40002acc:	07812423          	sw	s8,104(sp)
40002ad0:	05b12e23          	sw	s11,92(sp)
40002ad4:	00050493          	mv	s1,a0
40002ad8:	00b12423          	sw	a1,8(sp)
40002adc:	00060413          	mv	s0,a2
40002ae0:	00068c93          	mv	s9,a3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
40002ae4:	00000d13          	li	s10,0
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
		if (*fp != '%') {
40002ae8:	02500a13          	li	s4,37
	while (*fp != 0) {
40002aec:	00044503          	lbu	a0,0(s0)
40002af0:	00051663          	bnez	a0,40002afc <z_cbvprintf_impl+0x60>
			OUTC(' ');
			--width;
		}
	}

	return count;
40002af4:	000d0513          	mv	a0,s10
40002af8:	2890006f          	j	40003580 <z_cbvprintf_impl+0xae4>
			OUTC(*fp++);
40002afc:	00140993          	addi	s3,s0,1
		if (*fp != '%') {
40002b00:	01450c63          	beq	a0,s4,40002b18 <z_cbvprintf_impl+0x7c>
			OUTC(*fp++);
40002b04:	00812583          	lw	a1,8(sp)
			OUTC('%');
40002b08:	000480e7          	jalr	s1
40002b0c:	26054ae3          	bltz	a0,40003580 <z_cbvprintf_impl+0xae4>
40002b10:	001d0d13          	addi	s10,s10,1
		if (bps == NULL) {
40002b14:	6cc0006f          	j	400031e0 <z_cbvprintf_impl+0x744>
		} state = {
40002b18:	02000613          	li	a2,32
40002b1c:	00000593          	li	a1,0
40002b20:	03010513          	addi	a0,sp,48
40002b24:	1f80a0ef          	jal	ra,4000cd1c <memset>
	if (*sp == '%') {
40002b28:	00144783          	lbu	a5,1(s0)
40002b2c:	05479c63          	bne	a5,s4,40002b84 <z_cbvprintf_impl+0xe8>
		conv->specifier = *sp++;
40002b30:	00240993          	addi	s3,s0,2
40002b34:	054101a3          	sb	s4,67(sp)
		if (conv->width_star) {
40002b38:	04015783          	lhu	a5,64(sp)
40002b3c:	1007f713          	andi	a4,a5,256
40002b40:	50070c63          	beqz	a4,40003058 <z_cbvprintf_impl+0x5bc>
			width = va_arg(ap, int);
40002b44:	000caa83          	lw	s5,0(s9)
40002b48:	004c8713          	addi	a4,s9,4
			if (width < 0) {
40002b4c:	000ad863          	bgez	s5,40002b5c <z_cbvprintf_impl+0xc0>
				conv->flag_dash = true;
40002b50:	0047e793          	ori	a5,a5,4
40002b54:	04f11023          	sh	a5,64(sp)
				width = -width;
40002b58:	41500ab3          	neg	s5,s5
		if (conv->prec_star) {
40002b5c:	04015783          	lhu	a5,64(sp)
40002b60:	4007f693          	andi	a3,a5,1024
40002b64:	50068a63          	beqz	a3,40003078 <z_cbvprintf_impl+0x5dc>
			int arg = va_arg(ap, int);
40002b68:	00072b83          	lw	s7,0(a4)
40002b6c:	00470c93          	addi	s9,a4,4
			if (arg < 0) {
40002b70:	500bdc63          	bgez	s7,40003088 <z_cbvprintf_impl+0x5ec>
				conv->prec_present = false;
40002b74:	dff7f793          	andi	a5,a5,-513
40002b78:	04f11023          	sh	a5,64(sp)
		int precision = -1;
40002b7c:	fff00b93          	li	s7,-1
40002b80:	5080006f          	j	40003088 <z_cbvprintf_impl+0x5ec>
40002b84:	00000713          	li	a4,0
40002b88:	00000513          	li	a0,0
40002b8c:	00000693          	li	a3,0
40002b90:	00000593          	li	a1,0
40002b94:	00000613          	li	a2,0
		switch (*sp) {
40002b98:	02b00813          	li	a6,43
40002b9c:	02d00893          	li	a7,45
40002ba0:	03000313          	li	t1,48
40002ba4:	02000e13          	li	t3,32
40002ba8:	02300e93          	li	t4,35
40002bac:	0009c783          	lbu	a5,0(s3)
40002bb0:	13078a63          	beq	a5,a6,40002ce4 <z_cbvprintf_impl+0x248>
40002bb4:	12f86063          	bltu	a6,a5,40002cd4 <z_cbvprintf_impl+0x238>
40002bb8:	13c78c63          	beq	a5,t3,40002cf0 <z_cbvprintf_impl+0x254>
40002bbc:	13d78e63          	beq	a5,t4,40002cf8 <z_cbvprintf_impl+0x25c>
40002bc0:	00070863          	beqz	a4,40002bd0 <z_cbvprintf_impl+0x134>
40002bc4:	04015703          	lhu	a4,64(sp)
40002bc8:	04076713          	ori	a4,a4,64
40002bcc:	04e11023          	sh	a4,64(sp)
40002bd0:	00050863          	beqz	a0,40002be0 <z_cbvprintf_impl+0x144>
40002bd4:	04015703          	lhu	a4,64(sp)
40002bd8:	02076713          	ori	a4,a4,32
40002bdc:	04e11023          	sh	a4,64(sp)
40002be0:	00068863          	beqz	a3,40002bf0 <z_cbvprintf_impl+0x154>
40002be4:	04015703          	lhu	a4,64(sp)
40002be8:	01076713          	ori	a4,a4,16
40002bec:	04e11023          	sh	a4,64(sp)
40002bf0:	00058863          	beqz	a1,40002c00 <z_cbvprintf_impl+0x164>
40002bf4:	04015703          	lhu	a4,64(sp)
40002bf8:	00876713          	ori	a4,a4,8
40002bfc:	04e11023          	sh	a4,64(sp)
40002c00:	00060863          	beqz	a2,40002c10 <z_cbvprintf_impl+0x174>
40002c04:	04015703          	lhu	a4,64(sp)
40002c08:	00476713          	ori	a4,a4,4
40002c0c:	04e11023          	sh	a4,64(sp)
	if (conv->flag_zero && conv->flag_dash) {
40002c10:	04012703          	lw	a4,64(sp)
40002c14:	04400693          	li	a3,68
40002c18:	04477713          	andi	a4,a4,68
40002c1c:	00d71863          	bne	a4,a3,40002c2c <z_cbvprintf_impl+0x190>
		conv->flag_zero = false;
40002c20:	04015703          	lhu	a4,64(sp)
40002c24:	fbf77713          	andi	a4,a4,-65
40002c28:	04e11023          	sh	a4,64(sp)
	conv->width_present = true;
40002c2c:	04015703          	lhu	a4,64(sp)
40002c30:	08076713          	ori	a4,a4,128
40002c34:	04e11023          	sh	a4,64(sp)
	if (*sp == '*') {
40002c38:	02a00713          	li	a4,42
40002c3c:	10e79663          	bne	a5,a4,40002d48 <z_cbvprintf_impl+0x2ac>
		conv->width_star = true;
40002c40:	04015703          	lhu	a4,64(sp)
		return ++sp;
40002c44:	00198793          	addi	a5,s3,1
		conv->width_star = true;
40002c48:	10076713          	ori	a4,a4,256
		conv->unsupported |= ((conv->width_value < 0)
40002c4c:	04e11023          	sh	a4,64(sp)
	conv->prec_present = (*sp == '.');
40002c50:	0007c603          	lbu	a2,0(a5)
40002c54:	04015703          	lhu	a4,64(sp)
40002c58:	fd260693          	addi	a3,a2,-46
40002c5c:	0016b693          	seqz	a3,a3
40002c60:	00969693          	slli	a3,a3,0x9
40002c64:	dff77713          	andi	a4,a4,-513
40002c68:	00d76733          	or	a4,a4,a3
40002c6c:	04e11023          	sh	a4,64(sp)
	if (!conv->prec_present) {
40002c70:	02e00713          	li	a4,46
40002c74:	0ee61c63          	bne	a2,a4,40002d6c <z_cbvprintf_impl+0x2d0>
	if (*sp == '*') {
40002c78:	0017c683          	lbu	a3,1(a5)
40002c7c:	02a00713          	li	a4,42
40002c80:	0ce68e63          	beq	a3,a4,40002d5c <z_cbvprintf_impl+0x2c0>
	++sp;
40002c84:	00178793          	addi	a5,a5,1
	size_t val = 0;
40002c88:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp) != 0) {
40002c8c:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
40002c90:	00a00813          	li	a6,10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
40002c94:	0007c683          	lbu	a3,0(a5)
40002c98:	00178513          	addi	a0,a5,1
40002c9c:	fd068593          	addi	a1,a3,-48 # 7fd0 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3fd0>
	while (isdigit((int)(unsigned char)*sp) != 0) {
40002ca0:	14b67863          	bgeu	a2,a1,40002df0 <z_cbvprintf_impl+0x354>
	conv->unsupported |= ((conv->prec_value < 0)
40002ca4:	04012683          	lw	a3,64(sp)
	conv->prec_value = prec;
40002ca8:	04e12423          	sw	a4,72(sp)
			      || (prec != (size_t)conv->prec_value));
40002cac:	01f75713          	srli	a4,a4,0x1f
	conv->unsupported |= ((conv->prec_value < 0)
40002cb0:	0016d693          	srli	a3,a3,0x1
40002cb4:	0016f693          	andi	a3,a3,1
40002cb8:	00d76733          	or	a4,a4,a3
40002cbc:	04015683          	lhu	a3,64(sp)
40002cc0:	00171713          	slli	a4,a4,0x1
40002cc4:	ffd6f693          	andi	a3,a3,-3
40002cc8:	00e6e733          	or	a4,a3,a4
40002ccc:	04e11023          	sh	a4,64(sp)
	return sp;
40002cd0:	09c0006f          	j	40002d6c <z_cbvprintf_impl+0x2d0>
		switch (*sp) {
40002cd4:	03178663          	beq	a5,a7,40002d00 <z_cbvprintf_impl+0x264>
40002cd8:	ee6794e3          	bne	a5,t1,40002bc0 <z_cbvprintf_impl+0x124>
40002cdc:	00100713          	li	a4,1
40002ce0:	0080006f          	j	40002ce8 <z_cbvprintf_impl+0x24c>
40002ce4:	00100593          	li	a1,1
			++sp;
40002ce8:	00198993          	addi	s3,s3,1
	} while (loop);
40002cec:	ec1ff06f          	j	40002bac <z_cbvprintf_impl+0x110>
		switch (*sp) {
40002cf0:	00100693          	li	a3,1
40002cf4:	ff5ff06f          	j	40002ce8 <z_cbvprintf_impl+0x24c>
40002cf8:	00100513          	li	a0,1
40002cfc:	fedff06f          	j	40002ce8 <z_cbvprintf_impl+0x24c>
40002d00:	00100613          	li	a2,1
40002d04:	fe5ff06f          	j	40002ce8 <z_cbvprintf_impl+0x24c>
		val = 10U * val + *sp++ - '0';
40002d08:	03070733          	mul	a4,a4,a6
40002d0c:	00050793          	mv	a5,a0
40002d10:	fd070713          	addi	a4,a4,-48
40002d14:	00e68733          	add	a4,a3,a4
40002d18:	0007c683          	lbu	a3,0(a5)
40002d1c:	00178513          	addi	a0,a5,1
40002d20:	fd068593          	addi	a1,a3,-48
	while (isdigit((int)(unsigned char)*sp) != 0) {
40002d24:	feb672e3          	bgeu	a2,a1,40002d08 <z_cbvprintf_impl+0x26c>
	if (sp != wp) {
40002d28:	f2f984e3          	beq	s3,a5,40002c50 <z_cbvprintf_impl+0x1b4>
		conv->unsupported |= ((conv->width_value < 0)
40002d2c:	04015683          	lhu	a3,64(sp)
		conv->width_value = width;
40002d30:	04e12223          	sw	a4,68(sp)
		conv->unsupported |= ((conv->width_value < 0)
40002d34:	01f75713          	srli	a4,a4,0x1f
40002d38:	00171713          	slli	a4,a4,0x1
40002d3c:	ffd6f693          	andi	a3,a3,-3
40002d40:	00e6e733          	or	a4,a3,a4
40002d44:	f09ff06f          	j	40002c4c <z_cbvprintf_impl+0x1b0>
40002d48:	00098793          	mv	a5,s3
	size_t val = 0;
40002d4c:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp) != 0) {
40002d50:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
40002d54:	00a00813          	li	a6,10
40002d58:	fc1ff06f          	j	40002d18 <z_cbvprintf_impl+0x27c>
		conv->prec_star = true;
40002d5c:	04015703          	lhu	a4,64(sp)
		return ++sp;
40002d60:	00278793          	addi	a5,a5,2
		conv->prec_star = true;
40002d64:	40076713          	ori	a4,a4,1024
40002d68:	04e11023          	sh	a4,64(sp)
	switch (*sp) {
40002d6c:	0007c683          	lbu	a3,0(a5)
40002d70:	06c00713          	li	a4,108
40002d74:	0ee68e63          	beq	a3,a4,40002e70 <z_cbvprintf_impl+0x3d4>
40002d78:	08d76663          	bltu	a4,a3,40002e04 <z_cbvprintf_impl+0x368>
40002d7c:	06800713          	li	a4,104
40002d80:	0ae68663          	beq	a3,a4,40002e2c <z_cbvprintf_impl+0x390>
40002d84:	06a00713          	li	a4,106
40002d88:	10e68a63          	beq	a3,a4,40002e9c <z_cbvprintf_impl+0x400>
40002d8c:	04c00713          	li	a4,76
40002d90:	12e68e63          	beq	a3,a4,40002ecc <z_cbvprintf_impl+0x430>
	conv->specifier = *sp++;
40002d94:	00178993          	addi	s3,a5,1
40002d98:	0007c783          	lbu	a5,0(a5)
	switch (conv->specifier) {
40002d9c:	07800713          	li	a4,120
	conv->specifier = *sp++;
40002da0:	04f101a3          	sb	a5,67(sp)
	switch (conv->specifier) {
40002da4:	2af76263          	bltu	a4,a5,40003048 <z_cbvprintf_impl+0x5ac>
40002da8:	06d00713          	li	a4,109
40002dac:	12f76e63          	bltu	a4,a5,40002ee8 <z_cbvprintf_impl+0x44c>
40002db0:	06900713          	li	a4,105
40002db4:	28f76a63          	bltu	a4,a5,40003048 <z_cbvprintf_impl+0x5ac>
40002db8:	05700713          	li	a4,87
40002dbc:	18f76063          	bltu	a4,a5,40002f3c <z_cbvprintf_impl+0x4a0>
40002dc0:	04100713          	li	a4,65
40002dc4:	00e78a63          	beq	a5,a4,40002dd8 <z_cbvprintf_impl+0x33c>
40002dc8:	fbb78793          	addi	a5,a5,-69
40002dcc:	0ff7f793          	zext.b	a5,a5
40002dd0:	00200713          	li	a4,2
40002dd4:	26f76a63          	bltu	a4,a5,40003048 <z_cbvprintf_impl+0x5ac>
		conv->specifier_cat = SPECIFIER_FP;
40002dd8:	04214783          	lbu	a5,66(sp)
40002ddc:	ff87f793          	andi	a5,a5,-8
40002de0:	0047e793          	ori	a5,a5,4
40002de4:	04f10123          	sb	a5,66(sp)
			unsupported = true;
40002de8:	00100793          	li	a5,1
			break;
40002dec:	1b40006f          	j	40002fa0 <z_cbvprintf_impl+0x504>
		val = 10U * val + *sp++ - '0';
40002df0:	03070733          	mul	a4,a4,a6
40002df4:	00050793          	mv	a5,a0
40002df8:	fd070713          	addi	a4,a4,-48
40002dfc:	00d70733          	add	a4,a4,a3
40002e00:	e95ff06f          	j	40002c94 <z_cbvprintf_impl+0x1f8>
	switch (*sp) {
40002e04:	07400713          	li	a4,116
40002e08:	0ae68663          	beq	a3,a4,40002eb4 <z_cbvprintf_impl+0x418>
40002e0c:	07a00713          	li	a4,122
40002e10:	f8e692e3          	bne	a3,a4,40002d94 <z_cbvprintf_impl+0x2f8>
		conv->length_mod = LENGTH_Z;
40002e14:	04015703          	lhu	a4,64(sp)
40002e18:	ffff86b7          	lui	a3,0xffff8
40002e1c:	7ff68693          	addi	a3,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
40002e20:	00d77733          	and	a4,a4,a3
40002e24:	000036b7          	lui	a3,0x3
40002e28:	0380006f          	j	40002e60 <z_cbvprintf_impl+0x3c4>
		if (*++sp == 'h') {
40002e2c:	04015703          	lhu	a4,64(sp)
40002e30:	0017c583          	lbu	a1,1(a5)
40002e34:	ffff8637          	lui	a2,0xffff8
40002e38:	7ff60613          	addi	a2,a2,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_HH;
40002e3c:	00c77733          	and	a4,a4,a2
		if (*++sp == 'h') {
40002e40:	00d59e63          	bne	a1,a3,40002e5c <z_cbvprintf_impl+0x3c0>
			conv->length_mod = LENGTH_HH;
40002e44:	000016b7          	lui	a3,0x1
40002e48:	80068693          	addi	a3,a3,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
			conv->length_mod = LENGTH_LL;
40002e4c:	00d76733          	or	a4,a4,a3
40002e50:	04e11023          	sh	a4,64(sp)
			++sp;
40002e54:	00278793          	addi	a5,a5,2
40002e58:	f3dff06f          	j	40002d94 <z_cbvprintf_impl+0x2f8>
			conv->length_mod = LENGTH_H;
40002e5c:	000016b7          	lui	a3,0x1
40002e60:	00d76733          	or	a4,a4,a3
40002e64:	04e11023          	sh	a4,64(sp)
		if (*++sp == 'h') {
40002e68:	00178793          	addi	a5,a5,1
40002e6c:	f29ff06f          	j	40002d94 <z_cbvprintf_impl+0x2f8>
		if (*++sp == 'l') {
40002e70:	04015703          	lhu	a4,64(sp)
40002e74:	0017c583          	lbu	a1,1(a5)
40002e78:	ffff8637          	lui	a2,0xffff8
40002e7c:	7ff60613          	addi	a2,a2,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_LL;
40002e80:	00c77733          	and	a4,a4,a2
		if (*++sp == 'l') {
40002e84:	00d59663          	bne	a1,a3,40002e90 <z_cbvprintf_impl+0x3f4>
			conv->length_mod = LENGTH_LL;
40002e88:	000026b7          	lui	a3,0x2
40002e8c:	fc1ff06f          	j	40002e4c <z_cbvprintf_impl+0x3b0>
			conv->length_mod = LENGTH_L;
40002e90:	000026b7          	lui	a3,0x2
		conv->length_mod = LENGTH_T;
40002e94:	80068693          	addi	a3,a3,-2048 # 1800 <CONFIG_HEAP_MEM_POOL_SIZE+0x800>
40002e98:	fc9ff06f          	j	40002e60 <z_cbvprintf_impl+0x3c4>
		conv->length_mod = LENGTH_J;
40002e9c:	04015703          	lhu	a4,64(sp)
40002ea0:	ffff86b7          	lui	a3,0xffff8
40002ea4:	7ff68693          	addi	a3,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
40002ea8:	00d77733          	and	a4,a4,a3
40002eac:	000036b7          	lui	a3,0x3
40002eb0:	fe5ff06f          	j	40002e94 <z_cbvprintf_impl+0x3f8>
		conv->length_mod = LENGTH_T;
40002eb4:	04015703          	lhu	a4,64(sp)
40002eb8:	ffff86b7          	lui	a3,0xffff8
40002ebc:	7ff68693          	addi	a3,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
40002ec0:	00d77733          	and	a4,a4,a3
40002ec4:	000046b7          	lui	a3,0x4
40002ec8:	fcdff06f          	j	40002e94 <z_cbvprintf_impl+0x3f8>
		conv->unsupported = true;
40002ecc:	04015703          	lhu	a4,64(sp)
40002ed0:	ffff86b7          	lui	a3,0xffff8
40002ed4:	7fd68693          	addi	a3,a3,2045 # ffff87fd <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff87fe>
40002ed8:	00d77733          	and	a4,a4,a3
40002edc:	000046b7          	lui	a3,0x4
40002ee0:	00268693          	addi	a3,a3,2 # 4002 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x2>
40002ee4:	f7dff06f          	j	40002e60 <z_cbvprintf_impl+0x3c4>
	switch (conv->specifier) {
40002ee8:	f9278713          	addi	a4,a5,-110
40002eec:	00100793          	li	a5,1
40002ef0:	00e797b3          	sll	a5,a5,a4
40002ef4:	4827f713          	andi	a4,a5,1154
40002ef8:	0c071863          	bnez	a4,40002fc8 <z_cbvprintf_impl+0x52c>
40002efc:	0247f713          	andi	a4,a5,36
40002f00:	12071a63          	bnez	a4,40003034 <z_cbvprintf_impl+0x598>
40002f04:	0017f793          	andi	a5,a5,1
40002f08:	14078063          	beqz	a5,40003048 <z_cbvprintf_impl+0x5ac>
		conv->specifier_cat = SPECIFIER_PTR;
40002f0c:	04214783          	lbu	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
40002f10:	00008737          	lui	a4,0x8
40002f14:	80070713          	addi	a4,a4,-2048 # 7800 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3800>
		conv->specifier_cat = SPECIFIER_PTR;
40002f18:	ff87f793          	andi	a5,a5,-8
40002f1c:	0037e793          	ori	a5,a5,3
40002f20:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
40002f24:	04015783          	lhu	a5,64(sp)
40002f28:	00e7f7b3          	and	a5,a5,a4
40002f2c:	ffffc737          	lui	a4,0xffffc
40002f30:	00e787b3          	add	a5,a5,a4
40002f34:	0017b793          	seqz	a5,a5
40002f38:	0680006f          	j	40002fa0 <z_cbvprintf_impl+0x504>
	switch (conv->specifier) {
40002f3c:	fa878693          	addi	a3,a5,-88
40002f40:	00100713          	li	a4,1
40002f44:	00d71733          	sll	a4,a4,a3
40002f48:	0000e6b7          	lui	a3,0xe
40002f4c:	20068693          	addi	a3,a3,512 # e200 <__kernel_ram_size+0x26f8>
40002f50:	00d776b3          	and	a3,a4,a3
40002f54:	e80692e3          	bnez	a3,40002dd8 <z_cbvprintf_impl+0x33c>
40002f58:	000016b7          	lui	a3,0x1
40002f5c:	80168693          	addi	a3,a3,-2047 # 801 <CONFIG_ISR_STACK_SIZE+0x1>
40002f60:	00d776b3          	and	a3,a4,a3
40002f64:	08069063          	bnez	a3,40002fe4 <z_cbvprintf_impl+0x548>
40002f68:	000217b7          	lui	a5,0x21
40002f6c:	00f77733          	and	a4,a4,a5
40002f70:	0c070c63          	beqz	a4,40003048 <z_cbvprintf_impl+0x5ac>
		conv->specifier_cat = SPECIFIER_SINT;
40002f74:	04214783          	lbu	a5,66(sp)
40002f78:	ff87f793          	andi	a5,a5,-8
40002f7c:	0017e793          	ori	a5,a5,1
		if (conv->length_mod == LENGTH_UPPER_L) {
40002f80:	04015703          	lhu	a4,64(sp)
		conv->specifier_cat = SPECIFIER_SINT;
40002f84:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
40002f88:	000087b7          	lui	a5,0x8
40002f8c:	80078793          	addi	a5,a5,-2048 # 7800 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3800>
40002f90:	00f777b3          	and	a5,a4,a5
40002f94:	000046b7          	lui	a3,0x4
40002f98:	04d78063          	beq	a5,a3,40002fd8 <z_cbvprintf_impl+0x53c>
	bool unsupported = false;
40002f9c:	00000793          	li	a5,0
	conv->unsupported |= unsupported;
40002fa0:	04012703          	lw	a4,64(sp)
40002fa4:	00175713          	srli	a4,a4,0x1
40002fa8:	00177713          	andi	a4,a4,1
40002fac:	00e7e7b3          	or	a5,a5,a4
40002fb0:	04015703          	lhu	a4,64(sp)
40002fb4:	00179793          	slli	a5,a5,0x1
40002fb8:	ffd77713          	andi	a4,a4,-3
40002fbc:	00f767b3          	or	a5,a4,a5
40002fc0:	04f11023          	sh	a5,64(sp)
	return sp;
40002fc4:	b75ff06f          	j	40002b38 <z_cbvprintf_impl+0x9c>
		conv->specifier_cat = SPECIFIER_UINT;
40002fc8:	04214783          	lbu	a5,66(sp)
40002fcc:	ff87f793          	andi	a5,a5,-8
40002fd0:	0027e793          	ori	a5,a5,2
40002fd4:	fadff06f          	j	40002f80 <z_cbvprintf_impl+0x4e4>
			conv->invalid = true;
40002fd8:	00176713          	ori	a4,a4,1
40002fdc:	04e11023          	sh	a4,64(sp)
		if (conv->specifier == 'c') {
40002fe0:	fbdff06f          	j	40002f9c <z_cbvprintf_impl+0x500>
		conv->specifier_cat = SPECIFIER_UINT;
40002fe4:	04214703          	lbu	a4,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
40002fe8:	04015683          	lhu	a3,64(sp)
40002fec:	00004637          	lui	a2,0x4
		conv->specifier_cat = SPECIFIER_UINT;
40002ff0:	ff877713          	andi	a4,a4,-8
40002ff4:	00276713          	ori	a4,a4,2
40002ff8:	04e10123          	sb	a4,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
40002ffc:	00008737          	lui	a4,0x8
40003000:	80070713          	addi	a4,a4,-2048 # 7800 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3800>
40003004:	00e6f733          	and	a4,a3,a4
40003008:	00c71663          	bne	a4,a2,40003014 <z_cbvprintf_impl+0x578>
			conv->invalid = true;
4000300c:	0016e693          	ori	a3,a3,1
40003010:	04d11023          	sh	a3,64(sp)
		if (conv->specifier == 'c') {
40003014:	06300713          	li	a4,99
40003018:	f8e792e3          	bne	a5,a4,40002f9c <z_cbvprintf_impl+0x500>
		if (conv->length_mod != LENGTH_NONE) {
4000301c:	04015783          	lhu	a5,64(sp)
40003020:	00008737          	lui	a4,0x8
40003024:	80070713          	addi	a4,a4,-2048 # 7800 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3800>
40003028:	00e7f7b3          	and	a5,a5,a4
4000302c:	00f037b3          	snez	a5,a5
40003030:	f71ff06f          	j	40002fa0 <z_cbvprintf_impl+0x504>
		conv->specifier_cat = SPECIFIER_PTR;
40003034:	04214783          	lbu	a5,66(sp)
40003038:	ff87f793          	andi	a5,a5,-8
4000303c:	0037e793          	ori	a5,a5,3
40003040:	04f10123          	sb	a5,66(sp)
40003044:	fd9ff06f          	j	4000301c <z_cbvprintf_impl+0x580>
		conv->invalid = true;
40003048:	04015783          	lhu	a5,64(sp)
4000304c:	0017e793          	ori	a5,a5,1
40003050:	04f11023          	sh	a5,64(sp)
		break;
40003054:	f49ff06f          	j	40002f9c <z_cbvprintf_impl+0x500>
		} else if (conv->width_present) {
40003058:	0807f793          	andi	a5,a5,128
4000305c:	00078863          	beqz	a5,4000306c <z_cbvprintf_impl+0x5d0>
			width = conv->width_value;
40003060:	04412a83          	lw	s5,68(sp)
40003064:	000c8713          	mv	a4,s9
40003068:	af5ff06f          	j	40002b5c <z_cbvprintf_impl+0xc0>
4000306c:	000c8713          	mv	a4,s9
		int width = -1;
40003070:	fff00a93          	li	s5,-1
40003074:	ae9ff06f          	j	40002b5c <z_cbvprintf_impl+0xc0>
		} else if (conv->prec_present) {
40003078:	2007f793          	andi	a5,a5,512
4000307c:	06078663          	beqz	a5,400030e8 <z_cbvprintf_impl+0x64c>
			precision = conv->prec_value;
40003080:	04812b83          	lw	s7,72(sp)
40003084:	00070c93          	mv	s9,a4
			= (enum specifier_cat_enum)conv->specifier_cat;
40003088:	04012603          	lw	a2,64(sp)
		conv->pad0_value = 0;
4000308c:	04012223          	sw	zero,68(sp)
		conv->pad0_pre_exp = 0;
40003090:	04012423          	sw	zero,72(sp)
			= (enum specifier_cat_enum)conv->specifier_cat;
40003094:	01065513          	srli	a0,a2,0x10
			= (enum length_mod_enum)conv->length_mod;
40003098:	00b65693          	srli	a3,a2,0xb
		enum specifier_cat_enum specifier_cat
4000309c:	00757513          	andi	a0,a0,7
		if (specifier_cat == SPECIFIER_SINT) {
400030a0:	00100593          	li	a1,1
			= (enum length_mod_enum)conv->length_mod;
400030a4:	00f6f693          	andi	a3,a3,15
		if (specifier_cat == SPECIFIER_SINT) {
400030a8:	08b51a63          	bne	a0,a1,4000313c <z_cbvprintf_impl+0x6a0>
			switch (length_mod) {
400030ac:	00500793          	li	a5,5
400030b0:	18f68463          	beq	a3,a5,40003238 <z_cbvprintf_impl+0x79c>
400030b4:	02d7ee63          	bltu	a5,a3,400030f0 <z_cbvprintf_impl+0x654>
400030b8:	00300793          	li	a5,3
400030bc:	04f68663          	beq	a3,a5,40003108 <z_cbvprintf_impl+0x66c>
400030c0:	00400793          	li	a5,4
400030c4:	16f68a63          	beq	a3,a5,40003238 <z_cbvprintf_impl+0x79c>
				value->sint = va_arg(ap, int);
400030c8:	000ca783          	lw	a5,0(s9)
400030cc:	004c8713          	addi	a4,s9,4
400030d0:	41f7d593          	srai	a1,a5,0x1f
400030d4:	02f12823          	sw	a5,48(sp)
400030d8:	02b12a23          	sw	a1,52(sp)
			if (length_mod == LENGTH_HH) {
400030dc:	04a69263          	bne	a3,a0,40003120 <z_cbvprintf_impl+0x684>
				value->sint = (signed char)value->sint;
400030e0:	03010783          	lb	a5,48(sp)
400030e4:	0140006f          	j	400030f8 <z_cbvprintf_impl+0x65c>
400030e8:	00070c93          	mv	s9,a4
400030ec:	a91ff06f          	j	40002b7c <z_cbvprintf_impl+0xe0>
400030f0:	000ca783          	lw	a5,0(s9)
400030f4:	004c8713          	addi	a4,s9,4
				value->sint = (short)value->sint;
400030f8:	02f12823          	sw	a5,48(sp)
400030fc:	41f7d793          	srai	a5,a5,0x1f
40003100:	02f12a23          	sw	a5,52(sp)
40003104:	0240006f          	j	40003128 <z_cbvprintf_impl+0x68c>
					value->sint = va_arg(ap, long);
40003108:	000ca783          	lw	a5,0(s9)
4000310c:	02f12823          	sw	a5,48(sp)
40003110:	41f7d793          	srai	a5,a5,0x1f
40003114:	02f12a23          	sw	a5,52(sp)
			value->ptr = va_arg(ap, void *);
40003118:	004c8c93          	addi	s9,s9,4
4000311c:	0a00006f          	j	400031bc <z_cbvprintf_impl+0x720>
			} else if (length_mod == LENGTH_H) {
40003120:	00200593          	li	a1,2
40003124:	00b68663          	beq	a3,a1,40003130 <z_cbvprintf_impl+0x694>
40003128:	00070c93          	mv	s9,a4
4000312c:	0900006f          	j	400031bc <z_cbvprintf_impl+0x720>
				value->sint = (short)value->sint;
40003130:	01079793          	slli	a5,a5,0x10
40003134:	4107d793          	srai	a5,a5,0x10
40003138:	fc1ff06f          	j	400030f8 <z_cbvprintf_impl+0x65c>
		} else if (specifier_cat == SPECIFIER_UINT) {
4000313c:	00200793          	li	a5,2
40003140:	0cf51063          	bne	a0,a5,40003200 <z_cbvprintf_impl+0x764>
			switch (length_mod) {
40003144:	00500793          	li	a5,5
40003148:	0ef68863          	beq	a3,a5,40003238 <z_cbvprintf_impl+0x79c>
4000314c:	02d7ee63          	bltu	a5,a3,40003188 <z_cbvprintf_impl+0x6ec>
40003150:	00300793          	li	a5,3
40003154:	04f68463          	beq	a3,a5,4000319c <z_cbvprintf_impl+0x700>
40003158:	00400793          	li	a5,4
4000315c:	0cf68e63          	beq	a3,a5,40003238 <z_cbvprintf_impl+0x79c>
				value->uint = va_arg(ap, unsigned int);
40003160:	000ca783          	lw	a5,0(s9)
40003164:	004c8713          	addi	a4,s9,4
			if (length_mod == LENGTH_HH) {
40003168:	08b68663          	beq	a3,a1,400031f4 <z_cbvprintf_impl+0x758>
				value->uint = va_arg(ap, unsigned int);
4000316c:	02f12823          	sw	a5,48(sp)
40003170:	02012a23          	sw	zero,52(sp)
			} else if (length_mod == LENGTH_H) {
40003174:	faa69ae3          	bne	a3,a0,40003128 <z_cbvprintf_impl+0x68c>
				value->uint = (unsigned short)value->uint;
40003178:	01079793          	slli	a5,a5,0x10
4000317c:	0107d793          	srli	a5,a5,0x10
40003180:	02f12823          	sw	a5,48(sp)
40003184:	fa5ff06f          	j	40003128 <z_cbvprintf_impl+0x68c>
40003188:	000ca503          	lw	a0,0(s9)
4000318c:	004c8713          	addi	a4,s9,4
					(uint_value_type)va_arg(ap, size_t);
40003190:	02a12823          	sw	a0,48(sp)
				value->uint = (unsigned char)value->uint;
40003194:	02012a23          	sw	zero,52(sp)
40003198:	f91ff06f          	j	40003128 <z_cbvprintf_impl+0x68c>
				if ((!WCHAR_IS_SIGNED)
4000319c:	04314703          	lbu	a4,67(sp)
400031a0:	06300793          	li	a5,99
400031a4:	04f71263          	bne	a4,a5,400031e8 <z_cbvprintf_impl+0x74c>
					value->uint = (wchar_t)va_arg(ap,
400031a8:	000ca783          	lw	a5,0(s9)
400031ac:	41f7d713          	srai	a4,a5,0x1f
				value->sint = va_arg(ap, int);
400031b0:	004c8c93          	addi	s9,s9,4
					value->uint = (wchar_t)va_arg(ap,
400031b4:	02f12823          	sw	a5,48(sp)
400031b8:	02e12a23          	sw	a4,52(sp)
		if (conv->invalid || conv->unsupported) {
400031bc:	00367613          	andi	a2,a2,3
400031c0:	0a060663          	beqz	a2,4000326c <z_cbvprintf_impl+0x7d0>
			OUTS(sp, fp);
400031c4:	00812583          	lw	a1,8(sp)
400031c8:	00098693          	mv	a3,s3
400031cc:	00040613          	mv	a2,s0
400031d0:	00048513          	mv	a0,s1
400031d4:	84dff0ef          	jal	ra,40002a20 <outs>
400031d8:	3a054463          	bltz	a0,40003580 <z_cbvprintf_impl+0xae4>
400031dc:	00ad0d33          	add	s10,s10,a0
			continue;
400031e0:	00098413          	mv	s0,s3
400031e4:	909ff06f          	j	40002aec <z_cbvprintf_impl+0x50>
					value->uint = va_arg(ap, unsigned long);
400031e8:	000ca783          	lw	a5,0(s9)
400031ec:	00000713          	li	a4,0
			if (length_mod == LENGTH_HH) {
400031f0:	fc1ff06f          	j	400031b0 <z_cbvprintf_impl+0x714>
				value->uint = (unsigned char)value->uint;
400031f4:	0ff7f793          	zext.b	a5,a5
400031f8:	02f12823          	sw	a5,48(sp)
400031fc:	f99ff06f          	j	40003194 <z_cbvprintf_impl+0x6f8>
		} else if (specifier_cat == SPECIFIER_FP) {
40003200:	00400793          	li	a5,4
40003204:	04f51a63          	bne	a0,a5,40003258 <z_cbvprintf_impl+0x7bc>
			if (length_mod == LENGTH_UPPER_L) {
40003208:	00800793          	li	a5,8
4000320c:	02f69663          	bne	a3,a5,40003238 <z_cbvprintf_impl+0x79c>
				value->ldbl = va_arg(ap, long double);
40003210:	000ca783          	lw	a5,0(s9)
40003214:	0007a703          	lw	a4,0(a5)
40003218:	02e12823          	sw	a4,48(sp)
4000321c:	0047a703          	lw	a4,4(a5)
40003220:	02e12a23          	sw	a4,52(sp)
40003224:	0087a703          	lw	a4,8(a5)
40003228:	00c7a783          	lw	a5,12(a5)
4000322c:	02e12c23          	sw	a4,56(sp)
40003230:	02f12e23          	sw	a5,60(sp)
40003234:	ee5ff06f          	j	40003118 <z_cbvprintf_impl+0x67c>
				value->dbl = va_arg(ap, double);
40003238:	007c8793          	addi	a5,s9,7
4000323c:	ff87f793          	andi	a5,a5,-8
40003240:	0007a703          	lw	a4,0(a5)
40003244:	00878c93          	addi	s9,a5,8
40003248:	0047a783          	lw	a5,4(a5)
4000324c:	02e12823          	sw	a4,48(sp)
40003250:	02f12a23          	sw	a5,52(sp)
40003254:	f69ff06f          	j	400031bc <z_cbvprintf_impl+0x720>
		} else if (specifier_cat == SPECIFIER_PTR) {
40003258:	00300793          	li	a5,3
4000325c:	f6f510e3          	bne	a0,a5,400031bc <z_cbvprintf_impl+0x720>
			value->ptr = va_arg(ap, void *);
40003260:	000ca783          	lw	a5,0(s9)
40003264:	02f12823          	sw	a5,48(sp)
40003268:	eb1ff06f          	j	40003118 <z_cbvprintf_impl+0x67c>
		switch (conv->specifier) {
4000326c:	04314783          	lbu	a5,67(sp)
40003270:	07800713          	li	a4,120
40003274:	f6f766e3          	bltu	a4,a5,400031e0 <z_cbvprintf_impl+0x744>
40003278:	06200713          	li	a4,98
4000327c:	00f76e63          	bltu	a4,a5,40003298 <z_cbvprintf_impl+0x7fc>
40003280:	02500713          	li	a4,37
40003284:	02e78e63          	beq	a5,a4,400032c0 <z_cbvprintf_impl+0x824>
40003288:	05800713          	li	a4,88
4000328c:	f4e79ae3          	bne	a5,a4,400031e0 <z_cbvprintf_impl+0x744>
40003290:	00000d93          	li	s11,0
40003294:	1b00006f          	j	40003444 <z_cbvprintf_impl+0x9a8>
40003298:	f9d78793          	addi	a5,a5,-99
4000329c:	0ff7f793          	zext.b	a5,a5
400032a0:	01500713          	li	a4,21
400032a4:	f2f76ee3          	bltu	a4,a5,400031e0 <z_cbvprintf_impl+0x744>
400032a8:	40033737          	lui	a4,0x40033
400032ac:	00279793          	slli	a5,a5,0x2
400032b0:	9dc70713          	addi	a4,a4,-1572 # 400329dc <__clz_tab+0x2ec>
400032b4:	00e787b3          	add	a5,a5,a4
400032b8:	0007a783          	lw	a5,0(a5)
400032bc:	00078067          	jr	a5
			OUTC('%');
400032c0:	00812583          	lw	a1,8(sp)
400032c4:	02500513          	li	a0,37
400032c8:	841ff06f          	j	40002b08 <z_cbvprintf_impl+0x6c>
			bps = (const char *)value->ptr;
400032cc:	03012403          	lw	s0,48(sp)
			if (precision >= 0) {
400032d0:	100bc663          	bltz	s7,400033dc <z_cbvprintf_impl+0x940>
				len = strnlen(bps, precision);
400032d4:	000b8593          	mv	a1,s7
400032d8:	00040513          	mv	a0,s0
400032dc:	119090ef          	jal	ra,4000cbf4 <strnlen>
			bpe = bps + len;
400032e0:	00a40b33          	add	s6,s0,a0
		char sign = 0;
400032e4:	00000d93          	li	s11,0
		if (bps == NULL) {
400032e8:	ee040ce3          	beqz	s0,400031e0 <z_cbvprintf_impl+0x744>
		if (conv->altform_0c) {
400032ec:	04214783          	lbu	a5,66(sp)
400032f0:	0107fc13          	andi	s8,a5,16
400032f4:	260c0263          	beqz	s8,40003558 <z_cbvprintf_impl+0xabc>
			nj_len += 2U;
400032f8:	00250513          	addi	a0,a0,2
		nj_len += conv->pad0_value;
400032fc:	04412b83          	lw	s7,68(sp)
		if (conv->pad_fp) {
40003300:	0407f793          	andi	a5,a5,64
		nj_len += conv->pad0_value;
40003304:	01750533          	add	a0,a0,s7
		if (conv->pad_fp) {
40003308:	00078663          	beqz	a5,40003314 <z_cbvprintf_impl+0x878>
			nj_len += conv->pad0_pre_exp;
4000330c:	04812783          	lw	a5,72(sp)
40003310:	00f50533          	add	a0,a0,a5
		if (width > 0) {
40003314:	07505063          	blez	s5,40003374 <z_cbvprintf_impl+0x8d8>
			if (!conv->flag_dash) {
40003318:	04012783          	lw	a5,64(sp)
			width -= (int)nj_len;
4000331c:	40aa8ab3          	sub	s5,s5,a0
			if (!conv->flag_dash) {
40003320:	0027d793          	srli	a5,a5,0x2
40003324:	0017f793          	andi	a5,a5,1
40003328:	04079663          	bnez	a5,40003374 <z_cbvprintf_impl+0x8d8>
				if (conv->flag_zero) {
4000332c:	04015783          	lhu	a5,64(sp)
40003330:	0407f793          	andi	a5,a5,64
40003334:	28078463          	beqz	a5,400035bc <z_cbvprintf_impl+0xb20>
					if (sign != 0) {
40003338:	280d8663          	beqz	s11,400035c4 <z_cbvprintf_impl+0xb28>
						OUTC(sign);
4000333c:	00812583          	lw	a1,8(sp)
40003340:	000d8513          	mv	a0,s11
40003344:	000480e7          	jalr	s1
40003348:	22054c63          	bltz	a0,40003580 <z_cbvprintf_impl+0xae4>
4000334c:	001d0d13          	addi	s10,s10,1
					pad = '0';
40003350:	03000713          	li	a4,48
						OUTC(sign);
40003354:	00000d93          	li	s11,0
					pad = '0';
40003358:	000a8913          	mv	s2,s5
				while (width-- > 0) {
4000335c:	00090693          	mv	a3,s2
40003360:	fff90913          	addi	s2,s2,-1
40003364:	20d04263          	bgtz	a3,40003568 <z_cbvprintf_impl+0xacc>
40003368:	01aa8d33          	add	s10,s5,s10
4000336c:	40dd0d33          	sub	s10,s10,a3
40003370:	00090a93          	mv	s5,s2
		if (sign != 0) {
40003374:	000d8c63          	beqz	s11,4000338c <z_cbvprintf_impl+0x8f0>
			OUTC(sign);
40003378:	00812583          	lw	a1,8(sp)
4000337c:	000d8513          	mv	a0,s11
40003380:	000480e7          	jalr	s1
40003384:	1e054e63          	bltz	a0,40003580 <z_cbvprintf_impl+0xae4>
40003388:	001d0d13          	addi	s10,s10,1
			if (conv->altform_0c | conv->altform_0) {
4000338c:	04012783          	lw	a5,64(sp)
40003390:	0147d713          	srli	a4,a5,0x14
40003394:	00177713          	andi	a4,a4,1
40003398:	00071863          	bnez	a4,400033a8 <z_cbvprintf_impl+0x90c>
4000339c:	0137d793          	srli	a5,a5,0x13
400033a0:	0017f793          	andi	a5,a5,1
400033a4:	00078c63          	beqz	a5,400033bc <z_cbvprintf_impl+0x920>
				OUTC('0');
400033a8:	00812583          	lw	a1,8(sp)
400033ac:	03000513          	li	a0,48
400033b0:	000480e7          	jalr	s1
400033b4:	1c054663          	bltz	a0,40003580 <z_cbvprintf_impl+0xae4>
400033b8:	001d0d13          	addi	s10,s10,1
			if (conv->altform_0c) {
400033bc:	000c0c63          	beqz	s8,400033d4 <z_cbvprintf_impl+0x938>
				OUTC(conv->specifier);
400033c0:	00812583          	lw	a1,8(sp)
400033c4:	04314503          	lbu	a0,67(sp)
400033c8:	000480e7          	jalr	s1
400033cc:	1a054a63          	bltz	a0,40003580 <z_cbvprintf_impl+0xae4>
400033d0:	001d0d13          	addi	s10,s10,1
			while (pad_len-- > 0) {
400033d4:	01ab8bb3          	add	s7,s7,s10
400033d8:	2080006f          	j	400035e0 <z_cbvprintf_impl+0xb44>
				len = strlen(bps);
400033dc:	00040513          	mv	a0,s0
400033e0:	7f4090ef          	jal	ra,4000cbd4 <strlen>
400033e4:	efdff06f          	j	400032e0 <z_cbvprintf_impl+0x844>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
400033e8:	03012783          	lw	a5,48(sp)
			bps = buf;
400033ec:	01810413          	addi	s0,sp,24
			bpe = buf + 1;
400033f0:	01910b13          	addi	s6,sp,25
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
400033f4:	00f10c23          	sb	a5,24(sp)
		char sign = 0;
400033f8:	00000d93          	li	s11,0
		size_t nj_len = (bpe - bps);
400033fc:	00100513          	li	a0,1
40003400:	eedff06f          	j	400032ec <z_cbvprintf_impl+0x850>
			if (conv->flag_plus) {
40003404:	04015783          	lhu	a5,64(sp)
				sign = '+';
40003408:	02b00d93          	li	s11,43
			if (conv->flag_plus) {
4000340c:	0087f713          	andi	a4,a5,8
40003410:	00071663          	bnez	a4,4000341c <z_cbvprintf_impl+0x980>
			} else if (conv->flag_space) {
40003414:	00179793          	slli	a5,a5,0x1
40003418:	0207fd93          	andi	s11,a5,32
			sint = value->sint;
4000341c:	03412783          	lw	a5,52(sp)
40003420:	03012703          	lw	a4,48(sp)
			if (sint < 0) {
40003424:	0207d063          	bgez	a5,40003444 <z_cbvprintf_impl+0x9a8>
				value->uint = (uint_value_type)-sint;
40003428:	40e006b3          	neg	a3,a4
4000342c:	40f007b3          	neg	a5,a5
40003430:	00e03733          	snez	a4,a4
40003434:	40e787b3          	sub	a5,a5,a4
40003438:	02d12823          	sw	a3,48(sp)
4000343c:	02f12a23          	sw	a5,52(sp)
				sign = '-';
40003440:	02d00d93          	li	s11,45
			bps = encode_uint(value->uint, conv, buf, bpe);
40003444:	03012503          	lw	a0,48(sp)
40003448:	03412583          	lw	a1,52(sp)
4000344c:	02e10713          	addi	a4,sp,46
40003450:	01810693          	addi	a3,sp,24
40003454:	04010613          	addi	a2,sp,64
40003458:	c6cff0ef          	jal	ra,400028c4 <encode_uint>
4000345c:	00050413          	mv	s0,a0
			if (precision >= 0) {
40003460:	020bc263          	bltz	s7,40003484 <z_cbvprintf_impl+0x9e8>
				conv->flag_zero = false;
40003464:	04015703          	lhu	a4,64(sp)
				size_t len = bpe - bps;
40003468:	02e10793          	addi	a5,sp,46
4000346c:	408787b3          	sub	a5,a5,s0
				conv->flag_zero = false;
40003470:	fbf77713          	andi	a4,a4,-65
40003474:	04e11023          	sh	a4,64(sp)
				if (len < (size_t)precision) {
40003478:	0177f663          	bgeu	a5,s7,40003484 <z_cbvprintf_impl+0x9e8>
					conv->pad0_value = precision - (int)len;
4000347c:	40fb87b3          	sub	a5,s7,a5
40003480:	04f12223          	sw	a5,68(sp)
		if (bps == NULL) {
40003484:	d4040ee3          	beqz	s0,400031e0 <z_cbvprintf_impl+0x744>
		size_t nj_len = (bpe - bps);
40003488:	02e10793          	addi	a5,sp,46
4000348c:	40878533          	sub	a0,a5,s0
		if (sign != 0) {
40003490:	00078b13          	mv	s6,a5
40003494:	e40d8ce3          	beqz	s11,400032ec <z_cbvprintf_impl+0x850>
			nj_len += 1U;
40003498:	00150513          	addi	a0,a0,1
4000349c:	e51ff06f          	j	400032ec <z_cbvprintf_impl+0x850>
			if (value->ptr != NULL) {
400034a0:	03012503          	lw	a0,48(sp)
400034a4:	08050c63          	beqz	a0,4000353c <z_cbvprintf_impl+0xaa0>
				bps = encode_uint((uintptr_t)value->ptr, conv,
400034a8:	02e10b13          	addi	s6,sp,46
400034ac:	000b0713          	mv	a4,s6
400034b0:	01810693          	addi	a3,sp,24
400034b4:	04010613          	addi	a2,sp,64
400034b8:	00000593          	li	a1,0
400034bc:	c08ff0ef          	jal	ra,400028c4 <encode_uint>
				conv->altform_0c = true;
400034c0:	04215783          	lhu	a5,66(sp)
400034c4:	00008737          	lui	a4,0x8
400034c8:	81070713          	addi	a4,a4,-2032 # 7810 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3810>
400034cc:	0ef7f793          	andi	a5,a5,239
400034d0:	00e7e7b3          	or	a5,a5,a4
400034d4:	04f11123          	sh	a5,66(sp)
				bps = encode_uint((uintptr_t)value->ptr, conv,
400034d8:	00050413          	mv	s0,a0
		char sign = 0;
400034dc:	00000d93          	li	s11,0
			if (precision >= 0) {
400034e0:	f80bd2e3          	bgez	s7,40003464 <z_cbvprintf_impl+0x9c8>
		size_t nj_len = (bpe - bps);
400034e4:	40ab0533          	sub	a0,s6,a0
		if (bps == NULL) {
400034e8:	e00412e3          	bnez	s0,400032ec <z_cbvprintf_impl+0x850>
400034ec:	cf5ff06f          	j	400031e0 <z_cbvprintf_impl+0x744>
	switch ((enum length_mod_enum)conv->length_mod) {
400034f0:	00700713          	li	a4,7
				store_count(conv, value->ptr, count);
400034f4:	03012783          	lw	a5,48(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
400034f8:	ced764e3          	bltu	a4,a3,400031e0 <z_cbvprintf_impl+0x744>
400034fc:	40033737          	lui	a4,0x40033
40003500:	a3470713          	addi	a4,a4,-1484 # 40032a34 <__clz_tab+0x344>
40003504:	00269693          	slli	a3,a3,0x2
40003508:	00e686b3          	add	a3,a3,a4
4000350c:	0006a703          	lw	a4,0(a3) # 4000 <CONFIG_COVERAGE_GCOV_HEAP_SIZE>
40003510:	00070067          	jr	a4
		*(signed char *)dp = (signed char)count;
40003514:	01a78023          	sb	s10,0(a5)
		if (bps == NULL) {
40003518:	cc9ff06f          	j	400031e0 <z_cbvprintf_impl+0x744>
		*(short *)dp = (short)count;
4000351c:	01a79023          	sh	s10,0(a5)
		if (bps == NULL) {
40003520:	cc1ff06f          	j	400031e0 <z_cbvprintf_impl+0x744>
		*(intmax_t *)dp = (intmax_t)count;
40003524:	41fd5713          	srai	a4,s10,0x1f
40003528:	01a7a023          	sw	s10,0(a5)
4000352c:	00e7a223          	sw	a4,4(a5)
		if (bps == NULL) {
40003530:	cb1ff06f          	j	400031e0 <z_cbvprintf_impl+0x744>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
40003534:	01a7a023          	sw	s10,0(a5)
		if (bps == NULL) {
40003538:	ca9ff06f          	j	400031e0 <z_cbvprintf_impl+0x744>
4000353c:	40033437          	lui	s0,0x40033
			bpe = bps + 5;
40003540:	40033b37          	lui	s6,0x40033
40003544:	9d440413          	addi	s0,s0,-1580 # 400329d4 <__clz_tab+0x2e4>
40003548:	9d9b0b13          	addi	s6,s6,-1575 # 400329d9 <__clz_tab+0x2e9>
		char sign = 0;
4000354c:	00000d93          	li	s11,0
		size_t nj_len = (bpe - bps);
40003550:	00500513          	li	a0,5
40003554:	d99ff06f          	j	400032ec <z_cbvprintf_impl+0x850>
		} else if (conv->altform_0) {
40003558:	0087f713          	andi	a4,a5,8
4000355c:	da0700e3          	beqz	a4,400032fc <z_cbvprintf_impl+0x860>
			nj_len += 1U;
40003560:	00150513          	addi	a0,a0,1
40003564:	d99ff06f          	j	400032fc <z_cbvprintf_impl+0x860>
					OUTC(pad);
40003568:	00812583          	lw	a1,8(sp)
4000356c:	00070513          	mv	a0,a4
40003570:	00e12623          	sw	a4,12(sp)
40003574:	000480e7          	jalr	s1
40003578:	00c12703          	lw	a4,12(sp)
4000357c:	de0550e3          	bgez	a0,4000335c <z_cbvprintf_impl+0x8c0>
#undef OUTS
#undef OUTC
}
40003580:	08c12083          	lw	ra,140(sp)
40003584:	08812403          	lw	s0,136(sp)
40003588:	08412483          	lw	s1,132(sp)
4000358c:	08012903          	lw	s2,128(sp)
40003590:	07c12983          	lw	s3,124(sp)
40003594:	07812a03          	lw	s4,120(sp)
40003598:	07412a83          	lw	s5,116(sp)
4000359c:	07012b03          	lw	s6,112(sp)
400035a0:	06c12b83          	lw	s7,108(sp)
400035a4:	06812c03          	lw	s8,104(sp)
400035a8:	06412c83          	lw	s9,100(sp)
400035ac:	06012d03          	lw	s10,96(sp)
400035b0:	05c12d83          	lw	s11,92(sp)
400035b4:	09010113          	addi	sp,sp,144
400035b8:	00008067          	ret
				char pad = ' ';
400035bc:	02000713          	li	a4,32
400035c0:	d99ff06f          	j	40003358 <z_cbvprintf_impl+0x8bc>
					pad = '0';
400035c4:	03000713          	li	a4,48
400035c8:	d91ff06f          	j	40003358 <z_cbvprintf_impl+0x8bc>
				OUTC('0');
400035cc:	00812583          	lw	a1,8(sp)
400035d0:	03000513          	li	a0,48
400035d4:	000480e7          	jalr	s1
400035d8:	fa0544e3          	bltz	a0,40003580 <z_cbvprintf_impl+0xae4>
400035dc:	001d0d13          	addi	s10,s10,1
			while (pad_len-- > 0) {
400035e0:	41ab87b3          	sub	a5,s7,s10
400035e4:	fef044e3          	bgtz	a5,400035cc <z_cbvprintf_impl+0xb30>
			OUTS(bps, bpe);
400035e8:	00812583          	lw	a1,8(sp)
400035ec:	000b0693          	mv	a3,s6
400035f0:	00040613          	mv	a2,s0
400035f4:	00048513          	mv	a0,s1
400035f8:	c28ff0ef          	jal	ra,40002a20 <outs>
400035fc:	f80542e3          	bltz	a0,40003580 <z_cbvprintf_impl+0xae4>
40003600:	01a50d33          	add	s10,a0,s10
		while (width > 0) {
40003604:	01aa8ab3          	add	s5,s5,s10
40003608:	41aa87b3          	sub	a5,s5,s10
4000360c:	bcf05ae3          	blez	a5,400031e0 <z_cbvprintf_impl+0x744>
			OUTC(' ');
40003610:	00812583          	lw	a1,8(sp)
40003614:	02000513          	li	a0,32
40003618:	000480e7          	jalr	s1
4000361c:	f60542e3          	bltz	a0,40003580 <z_cbvprintf_impl+0xae4>
40003620:	001d0d13          	addi	s10,s10,1
			--width;
40003624:	fe5ff06f          	j	40003608 <z_cbvprintf_impl+0xb6c>

40003628 <ring_buf_put_claim>:

#include <zephyr/sys/ring_buffer.h>
#include <string.h>

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
40003628:	00050713          	mv	a4,a0
	uint32_t free_space, wrap_size;
	int32_t base;

	base = buf->put_base;
4000362c:	00c52883          	lw	a7,12(a0)
	wrap_size = buf->put_head - base;
40003630:	00452803          	lw	a6,4(a0)
	if (unlikely(wrap_size >= buf->size)) {
40003634:	01c72783          	lw	a5,28(a4)
	wrap_size = buf->put_head - base;
40003638:	41180533          	sub	a0,a6,a7
	if (unlikely(wrap_size >= buf->size)) {
4000363c:	00f56663          	bltu	a0,a5,40003648 <ring_buf_put_claim+0x20>
		/* put_base is not yet adjusted */
		wrap_size -= buf->size;
40003640:	40f50533          	sub	a0,a0,a5
		base += buf->size;
40003644:	00f888b3          	add	a7,a7,a5
 *
 * @return Ring buffer free space (in bytes).
 */
static inline uint32_t ring_buf_space_get(struct ring_buf *buf)
{
	return buf->size - (buf->put_head - buf->get_tail);
40003648:	01472683          	lw	a3,20(a4)
4000364c:	40d806b3          	sub	a3,a6,a3
40003650:	40d786b3          	sub	a3,a5,a3
	}
	wrap_size = buf->size - wrap_size;

	free_space = ring_buf_space_get(buf);
	size = MIN(size, free_space);
40003654:	00d67463          	bgeu	a2,a3,4000365c <ring_buf_put_claim+0x34>
40003658:	00060693          	mv	a3,a2
	wrap_size = buf->size - wrap_size;
4000365c:	40a78533          	sub	a0,a5,a0
	size = MIN(size, wrap_size);
40003660:	00a6f463          	bgeu	a3,a0,40003668 <ring_buf_put_claim+0x40>
40003664:	00068513          	mv	a0,a3

	*data = &buf->buffer[buf->put_head - base];
40003668:	00072783          	lw	a5,0(a4)
4000366c:	41180833          	sub	a6,a6,a7
40003670:	010787b3          	add	a5,a5,a6
40003674:	00f5a023          	sw	a5,0(a1)
	buf->put_head += size;
40003678:	00472783          	lw	a5,4(a4)
4000367c:	00a787b3          	add	a5,a5,a0
40003680:	00f72223          	sw	a5,4(a4)

	return size;
}
40003684:	00008067          	ret

40003688 <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
	uint32_t finish_space, wrap_size;

	finish_space = buf->put_head - buf->put_tail;
40003688:	00852783          	lw	a5,8(a0)
4000368c:	00452703          	lw	a4,4(a0)
40003690:	40f70733          	sub	a4,a4,a5
	if (unlikely(size > finish_space)) {
40003694:	02b76a63          	bltu	a4,a1,400036c8 <ring_buf_put_finish+0x40>
		return -EINVAL;
	}

	buf->put_tail += size;
40003698:	00b785b3          	add	a1,a5,a1
	buf->put_head = buf->put_tail;

	wrap_size = buf->put_tail - buf->put_base;
4000369c:	00c52783          	lw	a5,12(a0)
	if (unlikely(wrap_size >= buf->size)) {
400036a0:	01c52703          	lw	a4,28(a0)
	buf->put_tail += size;
400036a4:	00b52423          	sw	a1,8(a0)
	buf->put_head = buf->put_tail;
400036a8:	00b52223          	sw	a1,4(a0)
	wrap_size = buf->put_tail - buf->put_base;
400036ac:	40f585b3          	sub	a1,a1,a5
	if (unlikely(wrap_size >= buf->size)) {
400036b0:	00e5f663          	bgeu	a1,a4,400036bc <ring_buf_put_finish+0x34>
		/* we wrapped: adjust put_base */
		buf->put_base += buf->size;
	}

	return 0;
400036b4:	00000513          	li	a0,0
400036b8:	00008067          	ret
		buf->put_base += buf->size;
400036bc:	00e787b3          	add	a5,a5,a4
400036c0:	00f52623          	sw	a5,12(a0)
400036c4:	ff1ff06f          	j	400036b4 <ring_buf_put_finish+0x2c>
		return -EINVAL;
400036c8:	fea00513          	li	a0,-22
}
400036cc:	00008067          	ret

400036d0 <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
400036d0:	fd010113          	addi	sp,sp,-48
400036d4:	02912223          	sw	s1,36(sp)
400036d8:	03212023          	sw	s2,32(sp)
400036dc:	01312e23          	sw	s3,28(sp)
400036e0:	01412c23          	sw	s4,24(sp)
400036e4:	02112623          	sw	ra,44(sp)
400036e8:	02812423          	sw	s0,40(sp)
400036ec:	00050a13          	mv	s4,a0
400036f0:	00058913          	mv	s2,a1
400036f4:	00060493          	mv	s1,a2
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
400036f8:	00000993          	li	s3,0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
400036fc:	00048613          	mv	a2,s1
40003700:	00c10593          	addi	a1,sp,12
40003704:	000a0513          	mv	a0,s4
40003708:	f21ff0ef          	jal	ra,40003628 <ring_buf_put_claim>
4000370c:	00050413          	mv	s0,a0
		memcpy(dst, data, partial_size);
40003710:	00050613          	mv	a2,a0
40003714:	00c12503          	lw	a0,12(sp)
40003718:	00090593          	mv	a1,s2
		total_size += partial_size;
		size -= partial_size;
4000371c:	408484b3          	sub	s1,s1,s0
		memcpy(dst, data, partial_size);
40003720:	5d8090ef          	jal	ra,4000ccf8 <memcpy>
		total_size += partial_size;
40003724:	008989b3          	add	s3,s3,s0
		data += partial_size;
40003728:	00890933          	add	s2,s2,s0
	} while (size && partial_size);
4000372c:	00048463          	beqz	s1,40003734 <ring_buf_put+0x64>
40003730:	fc0416e3          	bnez	s0,400036fc <ring_buf_put+0x2c>

	err = ring_buf_put_finish(buf, total_size);
40003734:	00098593          	mv	a1,s3
40003738:	000a0513          	mv	a0,s4
4000373c:	f4dff0ef          	jal	ra,40003688 <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);
	ARG_UNUSED(err);

	return total_size;
}
40003740:	02c12083          	lw	ra,44(sp)
40003744:	02812403          	lw	s0,40(sp)
40003748:	02412483          	lw	s1,36(sp)
4000374c:	02012903          	lw	s2,32(sp)
40003750:	01812a03          	lw	s4,24(sp)
40003754:	00098513          	mv	a0,s3
40003758:	01c12983          	lw	s3,28(sp)
4000375c:	03010113          	addi	sp,sp,48
40003760:	00008067          	ret

40003764 <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
40003764:	00050713          	mv	a4,a0
	uint32_t available_size, wrap_size;
	int32_t base;

	base = buf->get_base;
40003768:	01852883          	lw	a7,24(a0)
	wrap_size = buf->get_head - base;
4000376c:	01052803          	lw	a6,16(a0)
	if (unlikely(wrap_size >= buf->size)) {
40003770:	01c72783          	lw	a5,28(a4)
	wrap_size = buf->get_head - base;
40003774:	41180533          	sub	a0,a6,a7
	if (unlikely(wrap_size >= buf->size)) {
40003778:	00f56663          	bltu	a0,a5,40003784 <ring_buf_get_claim+0x20>
		/* get_base is not yet adjusted */
		wrap_size -= buf->size;
4000377c:	40f50533          	sub	a0,a0,a5
		base += buf->size;
40003780:	00f888b3          	add	a7,a7,a5
 *
 * @return Ring buffer space used (in bytes).
 */
static inline uint32_t ring_buf_size_get(struct ring_buf *buf)
{
	return buf->put_tail - buf->get_head;
40003784:	00872683          	lw	a3,8(a4)
40003788:	410686b3          	sub	a3,a3,a6
	}
	wrap_size = buf->size - wrap_size;

	available_size = ring_buf_size_get(buf);
	size = MIN(size, available_size);
4000378c:	00d67463          	bgeu	a2,a3,40003794 <ring_buf_get_claim+0x30>
40003790:	00060693          	mv	a3,a2
	wrap_size = buf->size - wrap_size;
40003794:	40a78533          	sub	a0,a5,a0
	size = MIN(size, wrap_size);
40003798:	00a6f463          	bgeu	a3,a0,400037a0 <ring_buf_get_claim+0x3c>
4000379c:	00068513          	mv	a0,a3

	*data = &buf->buffer[buf->get_head - base];
400037a0:	00072783          	lw	a5,0(a4)
400037a4:	41180833          	sub	a6,a6,a7
400037a8:	010787b3          	add	a5,a5,a6
400037ac:	00f5a023          	sw	a5,0(a1)
	buf->get_head += size;
400037b0:	01072783          	lw	a5,16(a4)
400037b4:	00a787b3          	add	a5,a5,a0
400037b8:	00f72823          	sw	a5,16(a4)

	return size;
}
400037bc:	00008067          	ret

400037c0 <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
	uint32_t finish_space, wrap_size;

	finish_space = buf->get_head - buf->get_tail;
400037c0:	01452783          	lw	a5,20(a0)
400037c4:	01052703          	lw	a4,16(a0)
400037c8:	40f70733          	sub	a4,a4,a5
	if (unlikely(size > finish_space)) {
400037cc:	02b76a63          	bltu	a4,a1,40003800 <ring_buf_get_finish+0x40>
		return -EINVAL;
	}

	buf->get_tail += size;
400037d0:	00b785b3          	add	a1,a5,a1
	buf->get_head = buf->get_tail;

	wrap_size = buf->get_tail - buf->get_base;
400037d4:	01852783          	lw	a5,24(a0)
	if (unlikely(wrap_size >= buf->size)) {
400037d8:	01c52703          	lw	a4,28(a0)
	buf->get_tail += size;
400037dc:	00b52a23          	sw	a1,20(a0)
	buf->get_head = buf->get_tail;
400037e0:	00b52823          	sw	a1,16(a0)
	wrap_size = buf->get_tail - buf->get_base;
400037e4:	40f585b3          	sub	a1,a1,a5
	if (unlikely(wrap_size >= buf->size)) {
400037e8:	00e5f663          	bgeu	a1,a4,400037f4 <ring_buf_get_finish+0x34>
		/* we wrapped: adjust get_base */
		buf->get_base += buf->size;
	}

	return 0;
400037ec:	00000513          	li	a0,0
400037f0:	00008067          	ret
		buf->get_base += buf->size;
400037f4:	00e787b3          	add	a5,a5,a4
400037f8:	00f52c23          	sw	a5,24(a0)
400037fc:	ff1ff06f          	j	400037ec <ring_buf_get_finish+0x2c>
		return -EINVAL;
40003800:	fea00513          	li	a0,-22
}
40003804:	00008067          	ret

40003808 <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
40003808:	fd010113          	addi	sp,sp,-48
4000380c:	02912223          	sw	s1,36(sp)
40003810:	03212023          	sw	s2,32(sp)
40003814:	01312e23          	sw	s3,28(sp)
40003818:	01412c23          	sw	s4,24(sp)
4000381c:	02112623          	sw	ra,44(sp)
40003820:	02812423          	sw	s0,40(sp)
40003824:	00050a13          	mv	s4,a0
40003828:	00058493          	mv	s1,a1
4000382c:	00060913          	mv	s2,a2
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
40003830:	00000993          	li	s3,0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
40003834:	00090613          	mv	a2,s2
40003838:	00c10593          	addi	a1,sp,12
4000383c:	000a0513          	mv	a0,s4
40003840:	f25ff0ef          	jal	ra,40003764 <ring_buf_get_claim>
40003844:	00050413          	mv	s0,a0
		if (data) {
40003848:	00048c63          	beqz	s1,40003860 <ring_buf_get+0x58>
			memcpy(data, src, partial_size);
4000384c:	00c12583          	lw	a1,12(sp)
40003850:	00050613          	mv	a2,a0
40003854:	00048513          	mv	a0,s1
40003858:	4a0090ef          	jal	ra,4000ccf8 <memcpy>
			data += partial_size;
4000385c:	008484b3          	add	s1,s1,s0
		}
		total_size += partial_size;
		size -= partial_size;
40003860:	40890933          	sub	s2,s2,s0
		total_size += partial_size;
40003864:	008989b3          	add	s3,s3,s0
	} while (size && partial_size);
40003868:	00090463          	beqz	s2,40003870 <ring_buf_get+0x68>
4000386c:	fc0414e3          	bnez	s0,40003834 <ring_buf_get+0x2c>

	err = ring_buf_get_finish(buf, total_size);
40003870:	00098593          	mv	a1,s3
40003874:	000a0513          	mv	a0,s4
40003878:	f49ff0ef          	jal	ra,400037c0 <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);
	ARG_UNUSED(err);

	return total_size;
}
4000387c:	02c12083          	lw	ra,44(sp)
40003880:	02812403          	lw	s0,40(sp)
40003884:	02412483          	lw	s1,36(sp)
40003888:	02012903          	lw	s2,32(sp)
4000388c:	01812a03          	lw	s4,24(sp)
40003890:	00098513          	mv	a0,s3
40003894:	01c12983          	lw	s3,28(sp)
40003898:	03010113          	addi	sp,sp,48
4000389c:	00008067          	ret

400038a0 <free_space>:
 * be more space available after wrapping.
 * @retval false When result is total free space.
 */
static inline bool free_space(struct mpsc_pbuf_buffer *buffer, uint32_t *res)
{
	if (buffer->flags & MPSC_PBUF_FULL) {
400038a0:	01052783          	lw	a5,16(a0)
400038a4:	0087f793          	andi	a5,a5,8
400038a8:	02079863          	bnez	a5,400038d8 <free_space+0x38>
		*res = 0;
		return false;
	}

	if (buffer->rd_idx > buffer->tmp_wr_idx) {
400038ac:	00c52703          	lw	a4,12(a0)
400038b0:	00052783          	lw	a5,0(a0)
400038b4:	00e7f863          	bgeu	a5,a4,400038c4 <free_space+0x24>
		*res =  buffer->rd_idx - buffer->tmp_wr_idx;
400038b8:	40f707b3          	sub	a5,a4,a5
		return false;
400038bc:	00000513          	li	a0,0
400038c0:	0100006f          	j	400038d0 <free_space+0x30>
		return false;
	}
	*res = buffer->size - buffer->tmp_wr_idx;
400038c4:	02052703          	lw	a4,32(a0)

	return true;
400038c8:	00100513          	li	a0,1
	*res = buffer->size - buffer->tmp_wr_idx;
400038cc:	40f707b3          	sub	a5,a4,a5
		*res =  buffer->rd_idx - buffer->tmp_wr_idx;
400038d0:	00f5a023          	sw	a5,0(a1)
}
400038d4:	00008067          	ret
400038d8:	00000793          	li	a5,0
400038dc:	fe1ff06f          	j	400038bc <free_space+0x1c>

400038e0 <get_usage>:

	return false;
}

static inline uint32_t get_usage(struct mpsc_pbuf_buffer *buffer)
{
400038e0:	fe010113          	addi	sp,sp,-32
	uint32_t f;

	if (free_space(buffer, &f)) {
400038e4:	00c10593          	addi	a1,sp,12
{
400038e8:	00812c23          	sw	s0,24(sp)
400038ec:	00112e23          	sw	ra,28(sp)
400038f0:	00050413          	mv	s0,a0
	if (free_space(buffer, &f)) {
400038f4:	fadff0ef          	jal	ra,400038a0 <free_space>
400038f8:	00050c63          	beqz	a0,40003910 <get_usage+0x30>
		f += (buffer->rd_idx - 1);
400038fc:	00c12783          	lw	a5,12(sp)
40003900:	00c42703          	lw	a4,12(s0)
40003904:	fff78793          	addi	a5,a5,-1
40003908:	00e787b3          	add	a5,a5,a4
4000390c:	00f12623          	sw	a5,12(sp)
	}

	return buffer->size - 1 - f;
40003910:	02042503          	lw	a0,32(s0)
40003914:	00c12783          	lw	a5,12(sp)
}
40003918:	01c12083          	lw	ra,28(sp)
4000391c:	01812403          	lw	s0,24(sp)
	return buffer->size - 1 - f;
40003920:	40f50533          	sub	a0,a0,a5
}
40003924:	fff50513          	addi	a0,a0,-1
40003928:	02010113          	addi	sp,sp,32
4000392c:	00008067          	ret

40003930 <idx_inc>:
	return !item->hdr.valid && !item->hdr.busy;
}

static inline uint32_t idx_inc(struct mpsc_pbuf_buffer *buffer,
				uint32_t idx, int32_t val)
{
40003930:	00050713          	mv	a4,a0
	uint32_t i = idx + val;

	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
		return i & (buffer->size - 1);
40003934:	02072783          	lw	a5,32(a4)
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
40003938:	01072703          	lw	a4,16(a4)
	uint32_t i = idx + val;
4000393c:	00b60533          	add	a0,a2,a1
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
40003940:	00177713          	andi	a4,a4,1
40003944:	00070863          	beqz	a4,40003954 <idx_inc+0x24>
		return i & (buffer->size - 1);
40003948:	fff78793          	addi	a5,a5,-1
4000394c:	00f57533          	and	a0,a0,a5
40003950:	00008067          	ret
	}

	return (i >= buffer->size) ? i - buffer->size : i;
40003954:	00f56463          	bltu	a0,a5,4000395c <idx_inc+0x2c>
40003958:	40f50533          	sub	a0,a0,a5
}
4000395c:	00008067          	ret

40003960 <rd_idx_inc>:
		buffer->flags |= MPSC_PBUF_FULL;
	}
}

static void rd_idx_inc(struct mpsc_pbuf_buffer *buffer, int32_t wlen)
{
40003960:	ff010113          	addi	sp,sp,-16
40003964:	00812423          	sw	s0,8(sp)
40003968:	00112623          	sw	ra,12(sp)
4000396c:	00058613          	mv	a2,a1
	buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, wlen);
40003970:	00c52583          	lw	a1,12(a0)
{
40003974:	00050413          	mv	s0,a0
	buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, wlen);
40003978:	fb9ff0ef          	jal	ra,40003930 <idx_inc>
	buffer->flags &= ~MPSC_PBUF_FULL;
4000397c:	01042783          	lw	a5,16(s0)
	buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, wlen);
40003980:	00a42623          	sw	a0,12(s0)
	buffer->flags &= ~MPSC_PBUF_FULL;
40003984:	ff77f793          	andi	a5,a5,-9
40003988:	00f42823          	sw	a5,16(s0)
}
4000398c:	00c12083          	lw	ra,12(sp)
40003990:	00812403          	lw	s0,8(sp)
40003994:	01010113          	addi	sp,sp,16
40003998:	00008067          	ret

4000399c <add_skip_item>:

static void add_skip_item(struct mpsc_pbuf_buffer *buffer, uint32_t wlen)
{
4000399c:	fe010113          	addi	sp,sp,-32
400039a0:	00812c23          	sw	s0,24(sp)
400039a4:	00112e23          	sw	ra,28(sp)
	union mpsc_pbuf_generic skip = {
		.skip = { .valid = 0, .busy = 1, .len = wlen }
	};

	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
400039a8:	00052683          	lw	a3,0(a0)
400039ac:	01c52783          	lw	a5,28(a0)
	union mpsc_pbuf_generic skip = {
400039b0:	00259713          	slli	a4,a1,0x2
	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
400039b4:	00269693          	slli	a3,a3,0x2
400039b8:	00d787b3          	add	a5,a5,a3
	union mpsc_pbuf_generic skip = {
400039bc:	00276713          	ori	a4,a4,2
	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
400039c0:	00e7a023          	sw	a4,0(a5)
{
400039c4:	00058613          	mv	a2,a1
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
400039c8:	00b12623          	sw	a1,12(sp)
400039cc:	00052583          	lw	a1,0(a0)
{
400039d0:	00050413          	mv	s0,a0
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
400039d4:	f5dff0ef          	jal	ra,40003930 <idx_inc>
	if (buffer->tmp_wr_idx == buffer->rd_idx) {
400039d8:	00c42783          	lw	a5,12(s0)
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
400039dc:	00a42023          	sw	a0,0(s0)
	if (buffer->tmp_wr_idx == buffer->rd_idx) {
400039e0:	00c12603          	lw	a2,12(sp)
400039e4:	00f51863          	bne	a0,a5,400039f4 <add_skip_item+0x58>
		buffer->flags |= MPSC_PBUF_FULL;
400039e8:	01042783          	lw	a5,16(s0)
400039ec:	0087e793          	ori	a5,a5,8
400039f0:	00f42823          	sw	a5,16(s0)
	tmp_wr_idx_inc(buffer, wlen);
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
400039f4:	00442583          	lw	a1,4(s0)
400039f8:	00040513          	mv	a0,s0
400039fc:	f35ff0ef          	jal	ra,40003930 <idx_inc>
40003a00:	00a42223          	sw	a0,4(s0)
}
40003a04:	01c12083          	lw	ra,28(sp)
40003a08:	01812403          	lw	s0,24(sp)
40003a0c:	02010113          	addi	sp,sp,32
40003a10:	00008067          	ret

40003a14 <drop_item_locked>:

static bool drop_item_locked(struct mpsc_pbuf_buffer *buffer,
			     uint32_t free_wlen,
			     union mpsc_pbuf_generic **item_to_drop,
			     uint32_t *tmp_wr_idx_shift)
{
40003a14:	fe010113          	addi	sp,sp,-32
40003a18:	00812c23          	sw	s0,24(sp)
40003a1c:	01312623          	sw	s3,12(sp)
40003a20:	01412423          	sw	s4,8(sp)
40003a24:	01512223          	sw	s5,4(sp)
40003a28:	00112e23          	sw	ra,28(sp)
40003a2c:	00912a23          	sw	s1,20(sp)
40003a30:	01212823          	sw	s2,16(sp)
	union mpsc_pbuf_generic *item;
	uint32_t skip_wlen;

	item = (union mpsc_pbuf_generic *)&buffer->buf[buffer->rd_idx];
40003a34:	00c52783          	lw	a5,12(a0)
40003a38:	01c52903          	lw	s2,28(a0)
{
40003a3c:	00058993          	mv	s3,a1
	item = (union mpsc_pbuf_generic *)&buffer->buf[buffer->rd_idx];
40003a40:	00279793          	slli	a5,a5,0x2
40003a44:	00f90933          	add	s2,s2,a5
	if (item->hdr.busy && !item->hdr.valid) {
40003a48:	00092583          	lw	a1,0(s2)
40003a4c:	00200793          	li	a5,2
{
40003a50:	00050413          	mv	s0,a0
	if (item->hdr.busy && !item->hdr.valid) {
40003a54:	0035f713          	andi	a4,a1,3
{
40003a58:	00060a13          	mv	s4,a2
40003a5c:	00068a93          	mv	s5,a3
	if (item->hdr.busy && !item->hdr.valid) {
40003a60:	04f70063          	beq	a4,a5,40003aa0 <drop_item_locked+0x8c>
	skip_wlen = get_skip(item);
	*item_to_drop = NULL;
40003a64:	00062023          	sw	zero,0(a2) # 4000 <CONFIG_COVERAGE_GCOV_HEAP_SIZE>
	*tmp_wr_idx_shift = 0;
40003a68:	0006a023          	sw	zero,0(a3)
		buffer->tmp_rd_idx = buffer->rd_idx;
		return true;
	}

	/* Other options for dropping available only in overwrite mode. */
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE)) {
40003a6c:	01042783          	lw	a5,16(s0)
40003a70:	0027f793          	andi	a5,a5,2
40003a74:	04079863          	bnez	a5,40003ac4 <drop_item_locked+0xb0>
		return false;
40003a78:	00000513          	li	a0,0
		MPSC_PBUF_DBG(buffer, "no space: dropping packet %p (len: %d)",
			       item, rd_wlen);
	}

	return true;
}
40003a7c:	01c12083          	lw	ra,28(sp)
40003a80:	01812403          	lw	s0,24(sp)
40003a84:	01412483          	lw	s1,20(sp)
40003a88:	01012903          	lw	s2,16(sp)
40003a8c:	00c12983          	lw	s3,12(sp)
40003a90:	00812a03          	lw	s4,8(sp)
40003a94:	00412a83          	lw	s5,4(sp)
40003a98:	02010113          	addi	sp,sp,32
40003a9c:	00008067          	ret
	*item_to_drop = NULL;
40003aa0:	00062023          	sw	zero,0(a2)
		return item->skip.len;
40003aa4:	0025d593          	srli	a1,a1,0x2
	*tmp_wr_idx_shift = 0;
40003aa8:	0006a023          	sw	zero,0(a3)
	if (skip_wlen) {
40003aac:	fc0580e3          	beqz	a1,40003a6c <drop_item_locked+0x58>
		rd_idx_inc(buffer, skip_wlen);
40003ab0:	eb1ff0ef          	jal	ra,40003960 <rd_idx_inc>
		buffer->tmp_rd_idx = buffer->rd_idx;
40003ab4:	00c42783          	lw	a5,12(s0)
40003ab8:	00f42423          	sw	a5,8(s0)
		return true;
40003abc:	00100513          	li	a0,1
40003ac0:	fbdff06f          	j	40003a7c <drop_item_locked+0x68>
	uint32_t rd_wlen = buffer->get_wlen(item);
40003ac4:	01842783          	lw	a5,24(s0)
40003ac8:	00090513          	mv	a0,s2
40003acc:	000780e7          	jalr	a5
	return item->hdr.valid;
40003ad0:	00092783          	lw	a5,0(s2)
	uint32_t rd_wlen = buffer->get_wlen(item);
40003ad4:	00050493          	mv	s1,a0
	if (!is_valid(item)) {
40003ad8:	0017f713          	andi	a4,a5,1
40003adc:	f8070ee3          	beqz	a4,40003a78 <drop_item_locked+0x64>
	} else if (item->hdr.busy) {
40003ae0:	0027f793          	andi	a5,a5,2
40003ae4:	06078063          	beqz	a5,40003b44 <drop_item_locked+0x130>
		if (free_wlen) {
40003ae8:	00098863          	beqz	s3,40003af8 <drop_item_locked+0xe4>
			add_skip_item(buffer, free_wlen);
40003aec:	00098593          	mv	a1,s3
40003af0:	00040513          	mv	a0,s0
40003af4:	ea9ff0ef          	jal	ra,4000399c <add_skip_item>
		buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, rd_wlen);
40003af8:	00442583          	lw	a1,4(s0)
40003afc:	00048613          	mv	a2,s1
40003b00:	00040513          	mv	a0,s0
40003b04:	e2dff0ef          	jal	ra,40003930 <idx_inc>
		if (buffer->rd_idx == buffer->tmp_rd_idx) {
40003b08:	00842783          	lw	a5,8(s0)
40003b0c:	00c42583          	lw	a1,12(s0)
		buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, rd_wlen);
40003b10:	00a42223          	sw	a0,4(s0)
		if (buffer->rd_idx == buffer->tmp_rd_idx) {
40003b14:	00f59a63          	bne	a1,a5,40003b28 <drop_item_locked+0x114>
			buffer->tmp_rd_idx = idx_inc(buffer, buffer->tmp_rd_idx, rd_wlen);
40003b18:	00048613          	mv	a2,s1
40003b1c:	00040513          	mv	a0,s0
40003b20:	e11ff0ef          	jal	ra,40003930 <idx_inc>
40003b24:	00a42423          	sw	a0,8(s0)
		buffer->tmp_wr_idx = buffer->tmp_rd_idx;
40003b28:	00842783          	lw	a5,8(s0)
40003b2c:	00f42023          	sw	a5,0(s0)
		buffer->rd_idx = buffer->tmp_rd_idx;
40003b30:	00f42623          	sw	a5,12(s0)
		buffer->flags |= MPSC_PBUF_FULL;
40003b34:	01042783          	lw	a5,16(s0)
40003b38:	0087e793          	ori	a5,a5,8
40003b3c:	00f42823          	sw	a5,16(s0)
40003b40:	f7dff06f          	j	40003abc <drop_item_locked+0xa8>
		rd_idx_inc(buffer, rd_wlen);
40003b44:	00050593          	mv	a1,a0
40003b48:	00040513          	mv	a0,s0
40003b4c:	e15ff0ef          	jal	ra,40003960 <rd_idx_inc>
		buffer->tmp_rd_idx = buffer->rd_idx;
40003b50:	00c42783          	lw	a5,12(s0)
40003b54:	00f42423          	sw	a5,8(s0)
		if (free_wlen) {
40003b58:	00098c63          	beqz	s3,40003b70 <drop_item_locked+0x15c>
			buffer->buf[buffer->tmp_wr_idx] = invalid.raw;
40003b5c:	00042703          	lw	a4,0(s0)
40003b60:	01c42783          	lw	a5,28(s0)
40003b64:	00271713          	slli	a4,a4,0x2
40003b68:	00e787b3          	add	a5,a5,a4
40003b6c:	0007a023          	sw	zero,0(a5)
		*tmp_wr_idx_shift = rd_wlen + free_wlen;
40003b70:	01348633          	add	a2,s1,s3
40003b74:	00caa023          	sw	a2,0(s5)
		buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, *tmp_wr_idx_shift);
40003b78:	00042583          	lw	a1,0(s0)
40003b7c:	00040513          	mv	a0,s0
40003b80:	db1ff0ef          	jal	ra,40003930 <idx_inc>
		buffer->flags |= MPSC_PBUF_FULL;
40003b84:	01042783          	lw	a5,16(s0)
		buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, *tmp_wr_idx_shift);
40003b88:	00a42023          	sw	a0,0(s0)
		buffer->flags |= MPSC_PBUF_FULL;
40003b8c:	0087e793          	ori	a5,a5,8
40003b90:	00f42823          	sw	a5,16(s0)
		item->hdr.valid = 0;
40003b94:	00092783          	lw	a5,0(s2)
40003b98:	ffe7f793          	andi	a5,a5,-2
40003b9c:	00f92023          	sw	a5,0(s2)
		*item_to_drop = item;
40003ba0:	012a2023          	sw	s2,0(s4)
		MPSC_PBUF_DBG(buffer, "no space: dropping packet %p (len: %d)",
40003ba4:	f19ff06f          	j	40003abc <drop_item_locked+0xa8>

40003ba8 <post_drop_action>:

static void post_drop_action(struct mpsc_pbuf_buffer *buffer,
			     uint32_t prev_tmp_wr_idx,
			     uint32_t tmp_wr_idx_shift)
{
40003ba8:	ff010113          	addi	sp,sp,-16
40003bac:	00812423          	sw	s0,8(sp)
40003bb0:	00912223          	sw	s1,4(sp)
40003bb4:	01212023          	sw	s2,0(sp)
40003bb8:	00050413          	mv	s0,a0
40003bbc:	00112623          	sw	ra,12(sp)
40003bc0:	00058493          	mv	s1,a1
40003bc4:	00060913          	mv	s2,a2
	uint32_t cmp_tmp_wr_idx = idx_inc(buffer, prev_tmp_wr_idx, tmp_wr_idx_shift);
40003bc8:	d69ff0ef          	jal	ra,40003930 <idx_inc>

	if (cmp_tmp_wr_idx == buffer->tmp_wr_idx) {
40003bcc:	00042783          	lw	a5,0(s0)
40003bd0:	02a79663          	bne	a5,a0,40003bfc <post_drop_action+0x54>
		/* Operation not interrupted by another alloc. */
		buffer->tmp_wr_idx = prev_tmp_wr_idx;
		buffer->flags &= ~MPSC_PBUF_FULL;
40003bd4:	01042783          	lw	a5,16(s0)
		buffer->tmp_wr_idx = prev_tmp_wr_idx;
40003bd8:	00942023          	sw	s1,0(s0)
		buffer->flags &= ~MPSC_PBUF_FULL;
40003bdc:	ff77f793          	andi	a5,a5,-9
40003be0:	00f42823          	sw	a5,16(s0)
	buffer->buf[prev_tmp_wr_idx] = skip.raw;
	buffer->wr_idx = idx_inc(buffer,
				 buffer->wr_idx,
				 tmp_wr_idx_shift);
	/* full flag? */
}
40003be4:	00c12083          	lw	ra,12(sp)
40003be8:	00812403          	lw	s0,8(sp)
40003bec:	00412483          	lw	s1,4(sp)
40003bf0:	00012903          	lw	s2,0(sp)
40003bf4:	01010113          	addi	sp,sp,16
40003bf8:	00008067          	ret
	buffer->buf[prev_tmp_wr_idx] = skip.raw;
40003bfc:	01c42783          	lw	a5,28(s0)
	union mpsc_pbuf_generic skip = {
40003c00:	00291713          	slli	a4,s2,0x2
	buffer->buf[prev_tmp_wr_idx] = skip.raw;
40003c04:	00249493          	slli	s1,s1,0x2
	union mpsc_pbuf_generic skip = {
40003c08:	00276713          	ori	a4,a4,2
	buffer->buf[prev_tmp_wr_idx] = skip.raw;
40003c0c:	009787b3          	add	a5,a5,s1
40003c10:	00e7a023          	sw	a4,0(a5)
	buffer->wr_idx = idx_inc(buffer,
40003c14:	00442583          	lw	a1,4(s0)
40003c18:	00090613          	mv	a2,s2
40003c1c:	00040513          	mv	a0,s0
40003c20:	d11ff0ef          	jal	ra,40003930 <idx_inc>
40003c24:	00a42223          	sw	a0,4(s0)
40003c28:	fbdff06f          	j	40003be4 <post_drop_action+0x3c>

40003c2c <max_utilization_update>:
	if (!(buffer->flags & MPSC_PBUF_MAX_UTILIZATION)) {
40003c2c:	01052783          	lw	a5,16(a0)
40003c30:	0047f793          	andi	a5,a5,4
40003c34:	04078263          	beqz	a5,40003c78 <max_utilization_update+0x4c>
{
40003c38:	ff010113          	addi	sp,sp,-16
40003c3c:	00812423          	sw	s0,8(sp)
40003c40:	00112623          	sw	ra,12(sp)
40003c44:	00912223          	sw	s1,4(sp)
	buffer->max_usage = MAX(buffer->max_usage, get_usage(buffer));
40003c48:	02452483          	lw	s1,36(a0)
40003c4c:	00050413          	mv	s0,a0
40003c50:	c91ff0ef          	jal	ra,400038e0 <get_usage>
40003c54:	00048793          	mv	a5,s1
40003c58:	00a4f463          	bgeu	s1,a0,40003c60 <max_utilization_update+0x34>
40003c5c:	00050793          	mv	a5,a0
40003c60:	02f42223          	sw	a5,36(s0)
}
40003c64:	00c12083          	lw	ra,12(sp)
40003c68:	00812403          	lw	s0,8(sp)
40003c6c:	00412483          	lw	s1,4(sp)
40003c70:	01010113          	addi	sp,sp,16
40003c74:	00008067          	ret
40003c78:	00008067          	ret

40003c7c <mpsc_pbuf_init>:
{
40003c7c:	ff010113          	addi	sp,sp,-16
40003c80:	00912223          	sw	s1,4(sp)
	memset(buffer, 0, offsetof(struct mpsc_pbuf_buffer, buf));
40003c84:	01c00613          	li	a2,28
{
40003c88:	00058493          	mv	s1,a1
	memset(buffer, 0, offsetof(struct mpsc_pbuf_buffer, buf));
40003c8c:	00000593          	li	a1,0
{
40003c90:	00812423          	sw	s0,8(sp)
40003c94:	00112623          	sw	ra,12(sp)
40003c98:	00050413          	mv	s0,a0
	memset(buffer, 0, offsetof(struct mpsc_pbuf_buffer, buf));
40003c9c:	080090ef          	jal	ra,4000cd1c <memset>
	buffer->get_wlen = cfg->get_wlen;
40003ca0:	00c4a783          	lw	a5,12(s1)
40003ca4:	00f42c23          	sw	a5,24(s0)
	buffer->notify_drop = cfg->notify_drop;
40003ca8:	0084a783          	lw	a5,8(s1)
40003cac:	00f42a23          	sw	a5,20(s0)
	buffer->buf = cfg->buf;
40003cb0:	0004a783          	lw	a5,0(s1)
40003cb4:	00f42e23          	sw	a5,28(s0)
	buffer->size = cfg->size;
40003cb8:	0044a783          	lw	a5,4(s1)
	buffer->max_usage = 0;
40003cbc:	02042223          	sw	zero,36(s0)
	buffer->size = cfg->size;
40003cc0:	02f42023          	sw	a5,32(s0)
	buffer->flags = cfg->flags;
40003cc4:	0104a703          	lw	a4,16(s1)
 * @param x value to check
 * @return true if @p x is a power of two, false otherwise
 */
static inline bool is_power_of_two(unsigned int x)
{
	return IS_POWER_OF_TWO(x);
40003cc8:	00078a63          	beqz	a5,40003cdc <mpsc_pbuf_init+0x60>
40003ccc:	fff78693          	addi	a3,a5,-1
40003cd0:	00f6f7b3          	and	a5,a3,a5
40003cd4:	00079463          	bnez	a5,40003cdc <mpsc_pbuf_init+0x60>
		buffer->flags |= MPSC_PBUF_SIZE_POW2;
40003cd8:	00176713          	ori	a4,a4,1
	buffer->flags = cfg->flags;
40003cdc:	00e42823          	sw	a4,16(s0)
		union { uintptr_t x; unsigned int val; } parm2 = { .val = limit };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_K_SEM_INIT);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_init(sem, initial_count, limit);
40003ce0:	02840513          	addi	a0,s0,40
}
40003ce4:	00812403          	lw	s0,8(sp)
40003ce8:	00c12083          	lw	ra,12(sp)
40003cec:	00412483          	lw	s1,4(sp)
40003cf0:	00100613          	li	a2,1
40003cf4:	00000593          	li	a1,0
40003cf8:	01010113          	addi	sp,sp,16
40003cfc:	4052b06f          	j	4002f900 <z_impl_k_sem_init>

40003d00 <mpsc_pbuf_alloc>:
	} while (cont);
}

union mpsc_pbuf_generic *mpsc_pbuf_alloc(struct mpsc_pbuf_buffer *buffer,
					 size_t wlen, k_timeout_t timeout)
{
40003d00:	fb010113          	addi	sp,sp,-80
40003d04:	05212023          	sw	s2,64(sp)
40003d08:	04112623          	sw	ra,76(sp)
40003d0c:	04812423          	sw	s0,72(sp)
40003d10:	04912223          	sw	s1,68(sp)
40003d14:	03312e23          	sw	s3,60(sp)
40003d18:	03412c23          	sw	s4,56(sp)
40003d1c:	03512a23          	sw	s5,52(sp)
40003d20:	03612823          	sw	s6,48(sp)
40003d24:	03712623          	sw	s7,44(sp)
40003d28:	03812423          	sw	s8,40(sp)
40003d2c:	03912223          	sw	s9,36(sp)
	uint32_t tmp_wr_idx_shift = 0;
	uint32_t tmp_wr_idx_val = 0;

	MPSC_PBUF_DBG(buffer, "alloc %d words", (int)wlen);

	if (wlen > (buffer->size)) {
40003d30:	02052783          	lw	a5,32(a0)
	union mpsc_pbuf_generic *dropped_item = NULL;
40003d34:	00012a23          	sw	zero,20(sp)
	uint32_t tmp_wr_idx_shift = 0;
40003d38:	00012e23          	sw	zero,28(sp)
		MPSC_PBUF_DBG(buffer, "Failed to alloc");
		return NULL;
40003d3c:	00000913          	li	s2,0
	if (wlen > (buffer->size)) {
40003d40:	0ab7ee63          	bltu	a5,a1,40003dfc <mpsc_pbuf_alloc+0xfc>
40003d44:	00050413          	mv	s0,a0
40003d48:	00058993          	mv	s3,a1
40003d4c:	00060a13          	mv	s4,a2
40003d50:	00068a93          	mv	s5,a3
	uint32_t tmp_wr_idx_val = 0;
40003d54:	00000b13          	li	s6,0
	union mpsc_pbuf_generic *item = NULL;
40003d58:	00000913          	li	s2,0
			tmp_wr_idx_inc(buffer, wlen);
			cont = false;
		} else if (wrap) {
			add_skip_item(buffer, free_wlen);
			cont = true;
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) && !k_is_in_isr()) {
40003d5c:	00d66bb3          	or	s7,a2,a3
#ifdef CONFIG_RISCV_SOC_HAS_CUSTOM_IRQ_LOCK_OPS
	return z_soc_irq_lock();
#else
	unsigned int key;

	__asm__ volatile ("csrrc %0, mstatus, %1"
40003d60:	30047cf3          	csrrci	s9,mstatus,8
		if (tmp_wr_idx_shift) {
40003d64:	01c12603          	lw	a2,28(sp)

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
40003d68:	000c8c13          	mv	s8,s9
40003d6c:	00060a63          	beqz	a2,40003d80 <mpsc_pbuf_alloc+0x80>
			post_drop_action(buffer, tmp_wr_idx_val, tmp_wr_idx_shift);
40003d70:	000b0593          	mv	a1,s6
40003d74:	00040513          	mv	a0,s0
40003d78:	e31ff0ef          	jal	ra,40003ba8 <post_drop_action>
			tmp_wr_idx_shift = 0;
40003d7c:	00012e23          	sw	zero,28(sp)
		wrap = free_space(buffer, &free_wlen);
40003d80:	01810593          	addi	a1,sp,24
40003d84:	00040513          	mv	a0,s0
40003d88:	b19ff0ef          	jal	ra,400038a0 <free_space>
		if (free_wlen >= wlen) {
40003d8c:	01812583          	lw	a1,24(sp)
		wrap = free_space(buffer, &free_wlen);
40003d90:	00050493          	mv	s1,a0
		if (free_wlen >= wlen) {
40003d94:	0b35e863          	bltu	a1,s3,40003e44 <mpsc_pbuf_alloc+0x144>
			    (union mpsc_pbuf_generic *)&buffer->buf[buffer->tmp_wr_idx];
40003d98:	00042783          	lw	a5,0(s0)
			item =
40003d9c:	01c42903          	lw	s2,28(s0)
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
40003da0:	00098613          	mv	a2,s3
			    (union mpsc_pbuf_generic *)&buffer->buf[buffer->tmp_wr_idx];
40003da4:	00279793          	slli	a5,a5,0x2
			item =
40003da8:	00f90933          	add	s2,s2,a5
			item->hdr.valid = 0;
40003dac:	00094783          	lbu	a5,0(s2)
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
40003db0:	00040513          	mv	a0,s0
			item->hdr.valid = 0;
40003db4:	ffc7f793          	andi	a5,a5,-4
40003db8:	00f90023          	sb	a5,0(s2)
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
40003dbc:	00042583          	lw	a1,0(s0)
40003dc0:	b71ff0ef          	jal	ra,40003930 <idx_inc>
	if (buffer->tmp_wr_idx == buffer->rd_idx) {
40003dc4:	00c42783          	lw	a5,12(s0)
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
40003dc8:	00a42023          	sw	a0,0(s0)
	if (buffer->tmp_wr_idx == buffer->rd_idx) {
40003dcc:	06f50463          	beq	a0,a5,40003e34 <mpsc_pbuf_alloc+0x134>
			cont = false;
40003dd0:	00000493          	li	s1,0
#ifdef CONFIG_RISCV_SOC_HAS_CUSTOM_IRQ_LOCK_OPS
	z_soc_irq_unlock(key);
#else
	__asm__ volatile ("csrs mstatus, %0"
			  :
			  : "r" (key & MSTATUS_IEN)
40003dd4:	008c7c13          	andi	s8,s8,8
	__asm__ volatile ("csrs mstatus, %0"
40003dd8:	300c2073          	csrs	mstatus,s8
			cont = drop_item_locked(buffer, free_wlen,
						&dropped_item, &tmp_wr_idx_shift);
		}
		k_spin_unlock(&buffer->lock, key);

		if (dropped_item) {
40003ddc:	01412583          	lw	a1,20(sp)
40003de0:	00058c63          	beqz	a1,40003df8 <mpsc_pbuf_alloc+0xf8>
			/* Notify about item being dropped. */
			if (buffer->notify_drop) {
40003de4:	01442783          	lw	a5,20(s0)
40003de8:	00078663          	beqz	a5,40003df4 <mpsc_pbuf_alloc+0xf4>
				buffer->notify_drop(buffer, dropped_item);
40003dec:	00040513          	mv	a0,s0
40003df0:	000780e7          	jalr	a5
			}
			dropped_item = NULL;
40003df4:	00012a23          	sw	zero,20(sp)
		}
	} while (cont);
40003df8:	f60494e3          	bnez	s1,40003d60 <mpsc_pbuf_alloc+0x60>
		/* During test fill with 0's to simplify message comparison */
		memset(item, 0, sizeof(int) * wlen);
	}

	return item;
}
40003dfc:	04c12083          	lw	ra,76(sp)
40003e00:	04812403          	lw	s0,72(sp)
40003e04:	04412483          	lw	s1,68(sp)
40003e08:	03c12983          	lw	s3,60(sp)
40003e0c:	03812a03          	lw	s4,56(sp)
40003e10:	03412a83          	lw	s5,52(sp)
40003e14:	03012b03          	lw	s6,48(sp)
40003e18:	02c12b83          	lw	s7,44(sp)
40003e1c:	02812c03          	lw	s8,40(sp)
40003e20:	02412c83          	lw	s9,36(sp)
40003e24:	00090513          	mv	a0,s2
40003e28:	04012903          	lw	s2,64(sp)
40003e2c:	05010113          	addi	sp,sp,80
40003e30:	00008067          	ret
		buffer->flags |= MPSC_PBUF_FULL;
40003e34:	01042783          	lw	a5,16(s0)
40003e38:	0087e793          	ori	a5,a5,8
40003e3c:	00f42823          	sw	a5,16(s0)
40003e40:	f91ff06f          	j	40003dd0 <mpsc_pbuf_alloc+0xd0>
		} else if (wrap) {
40003e44:	00050863          	beqz	a0,40003e54 <mpsc_pbuf_alloc+0x154>
			add_skip_item(buffer, free_wlen);
40003e48:	00040513          	mv	a0,s0
40003e4c:	b51ff0ef          	jal	ra,4000399c <add_skip_item>
			cont = true;
40003e50:	f85ff06f          	j	40003dd4 <mpsc_pbuf_alloc+0xd4>
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) && !k_is_in_isr()) {
40003e54:	020b8c63          	beqz	s7,40003e8c <mpsc_pbuf_alloc+0x18c>
40003e58:	00b12623          	sw	a1,12(sp)
40003e5c:	6352a0ef          	jal	ra,4002ec90 <k_is_in_isr>
40003e60:	00c12583          	lw	a1,12(sp)
40003e64:	02051463          	bnez	a0,40003e8c <mpsc_pbuf_alloc+0x18c>
40003e68:	008cfc93          	andi	s9,s9,8
40003e6c:	300ca073          	csrs	mstatus,s9
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm1 = { .val = timeout };
		return (int) arch_syscall_invoke3(parm0.x, parm1.split.lo, parm1.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
40003e70:	000a0593          	mv	a1,s4
40003e74:	000a8613          	mv	a2,s5
40003e78:	02840513          	addi	a0,s0,40
40003e7c:	32d2b0ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003e80:	30047c73          	csrrci	s8,mstatus,8
			cont = (err == 0) ? true : false;
40003e84:	00153493          	seqz	s1,a0
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) && !k_is_in_isr()) {
40003e88:	f4dff06f          	j	40003dd4 <mpsc_pbuf_alloc+0xd4>
			cont = drop_item_locked(buffer, free_wlen,
40003e8c:	01c10693          	addi	a3,sp,28
40003e90:	01410613          	addi	a2,sp,20
40003e94:	00040513          	mv	a0,s0
			tmp_wr_idx_val = buffer->tmp_wr_idx;
40003e98:	00042b03          	lw	s6,0(s0)
			cont = drop_item_locked(buffer, free_wlen,
40003e9c:	b79ff0ef          	jal	ra,40003a14 <drop_item_locked>
40003ea0:	00050493          	mv	s1,a0
40003ea4:	f31ff06f          	j	40003dd4 <mpsc_pbuf_alloc+0xd4>

40003ea8 <mpsc_pbuf_commit>:

void mpsc_pbuf_commit(struct mpsc_pbuf_buffer *buffer,
		       union mpsc_pbuf_generic *item)
{
40003ea8:	ff010113          	addi	sp,sp,-16
40003eac:	00812423          	sw	s0,8(sp)
40003eb0:	00912223          	sw	s1,4(sp)
40003eb4:	00112623          	sw	ra,12(sp)
40003eb8:	01212023          	sw	s2,0(sp)
	uint32_t wlen = buffer->get_wlen(item);
40003ebc:	01852783          	lw	a5,24(a0)
{
40003ec0:	00050413          	mv	s0,a0
	uint32_t wlen = buffer->get_wlen(item);
40003ec4:	00058513          	mv	a0,a1
{
40003ec8:	00058493          	mv	s1,a1
	uint32_t wlen = buffer->get_wlen(item);
40003ecc:	000780e7          	jalr	a5
40003ed0:	00050613          	mv	a2,a0
40003ed4:	30047973          	csrrci	s2,mstatus,8

	k_spinlock_key_t key = k_spin_lock(&buffer->lock);

	item->hdr.valid = 1;
40003ed8:	0004a783          	lw	a5,0(s1)
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
40003edc:	00040513          	mv	a0,s0
	__asm__ volatile ("csrs mstatus, %0"
40003ee0:	00897913          	andi	s2,s2,8
	item->hdr.valid = 1;
40003ee4:	0017e793          	ori	a5,a5,1
40003ee8:	00f4a023          	sw	a5,0(s1)
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
40003eec:	00442583          	lw	a1,4(s0)
40003ef0:	a41ff0ef          	jal	ra,40003930 <idx_inc>
40003ef4:	00a42223          	sw	a0,4(s0)
	max_utilization_update(buffer);
40003ef8:	00040513          	mv	a0,s0
40003efc:	d31ff0ef          	jal	ra,40003c2c <max_utilization_update>
40003f00:	30092073          	csrs	mstatus,s2
	k_spin_unlock(&buffer->lock, key);
	MPSC_PBUF_DBG(buffer, "committed %p", item);
}
40003f04:	00c12083          	lw	ra,12(sp)
40003f08:	00812403          	lw	s0,8(sp)
40003f0c:	00412483          	lw	s1,4(sp)
40003f10:	00012903          	lw	s2,0(sp)
40003f14:	01010113          	addi	sp,sp,16
40003f18:	00008067          	ret

40003f1c <mpsc_pbuf_claim>:
		}
	} while (cont);
}

const union mpsc_pbuf_generic *mpsc_pbuf_claim(struct mpsc_pbuf_buffer *buffer)
{
40003f1c:	fd010113          	addi	sp,sp,-48
40003f20:	02812423          	sw	s0,40(sp)
40003f24:	01412c23          	sw	s4,24(sp)
40003f28:	02112623          	sw	ra,44(sp)
40003f2c:	02912223          	sw	s1,36(sp)
40003f30:	03212023          	sw	s2,32(sp)
40003f34:	01312e23          	sw	s3,28(sp)
40003f38:	00050413          	mv	s0,a0
	if (item->hdr.busy && !item->hdr.valid) {
40003f3c:	00200a13          	li	s4,2
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003f40:	30047973          	csrrci	s2,mstatus,8
	if (buffer->flags & MPSC_PBUF_FULL || buffer->tmp_rd_idx > buffer->wr_idx) {
40003f44:	01042703          	lw	a4,16(s0)
40003f48:	00842783          	lw	a5,8(s0)
40003f4c:	00877713          	andi	a4,a4,8
40003f50:	00071863          	bnez	a4,40003f60 <mpsc_pbuf_claim+0x44>
40003f54:	00442683          	lw	a3,4(s0)
	*res = (buffer->wr_idx - buffer->tmp_rd_idx);
40003f58:	40f68733          	sub	a4,a3,a5
	if (buffer->flags & MPSC_PBUF_FULL || buffer->tmp_rd_idx > buffer->wr_idx) {
40003f5c:	00f6f663          	bgeu	a3,a5,40003f68 <mpsc_pbuf_claim+0x4c>
		*res = buffer->size - buffer->tmp_rd_idx;
40003f60:	02042703          	lw	a4,32(s0)
40003f64:	40f70733          	sub	a4,a4,a5

		cont = false;
		key = k_spin_lock(&buffer->lock);
		(void)available(buffer, &a);
		item = (union mpsc_pbuf_generic *)
			&buffer->buf[buffer->tmp_rd_idx];
40003f68:	01c42483          	lw	s1,28(s0)

		if (!a || is_invalid(item)) {
40003f6c:	00897913          	andi	s2,s2,8
40003f70:	00071863          	bnez	a4,40003f80 <mpsc_pbuf_claim+0x64>
	__asm__ volatile ("csrs mstatus, %0"
40003f74:	30092073          	csrs	mstatus,s2
			MPSC_PBUF_DBG(buffer, "invalid claim %d: %p", a, item);
			item = NULL;
40003f78:	00000493          	li	s1,0
			MPSC_PBUF_DBG(buffer, ">>claimed %d: %p", a, item);
		}
		k_spin_unlock(&buffer->lock, key);
	} while (cont);

	return item;
40003f7c:	0980006f          	j	40004014 <mpsc_pbuf_claim+0xf8>
			&buffer->buf[buffer->tmp_rd_idx];
40003f80:	00279793          	slli	a5,a5,0x2
		item = (union mpsc_pbuf_generic *)
40003f84:	00f484b3          	add	s1,s1,a5
	return !item->hdr.valid && !item->hdr.busy;
40003f88:	0004a783          	lw	a5,0(s1)
40003f8c:	0037f713          	andi	a4,a5,3
		if (!a || is_invalid(item)) {
40003f90:	fe0702e3          	beqz	a4,40003f74 <mpsc_pbuf_claim+0x58>
	if (item->hdr.busy && !item->hdr.valid) {
40003f94:	01471663          	bne	a4,s4,40003fa0 <mpsc_pbuf_claim+0x84>
		return item->skip.len;
40003f98:	0027d993          	srli	s3,a5,0x2
			if (skip || !is_valid(item)) {
40003f9c:	00099e63          	bnez	s3,40003fb8 <mpsc_pbuf_claim+0x9c>
40003fa0:	0017f713          	andi	a4,a5,1
40003fa4:	02071e63          	bnez	a4,40003fe0 <mpsc_pbuf_claim+0xc4>
					skip ? skip : buffer->get_wlen(item);
40003fa8:	01842783          	lw	a5,24(s0)
40003fac:	00048513          	mv	a0,s1
40003fb0:	000780e7          	jalr	a5
40003fb4:	00050993          	mv	s3,a0
				      idx_inc(buffer, buffer->tmp_rd_idx, inc);
40003fb8:	00842583          	lw	a1,8(s0)
40003fbc:	00098613          	mv	a2,s3
40003fc0:	00040513          	mv	a0,s0
40003fc4:	96dff0ef          	jal	ra,40003930 <idx_inc>
				buffer->tmp_rd_idx =
40003fc8:	00a42423          	sw	a0,8(s0)
				rd_idx_inc(buffer, inc);
40003fcc:	00098593          	mv	a1,s3
40003fd0:	00040513          	mv	a0,s0
40003fd4:	98dff0ef          	jal	ra,40003960 <rd_idx_inc>
40003fd8:	30092073          	csrs	mstatus,s2
	} while (cont);
40003fdc:	f65ff06f          	j	40003f40 <mpsc_pbuf_claim+0x24>
				item->hdr.busy = 1;
40003fe0:	0027e793          	ori	a5,a5,2
40003fe4:	00f4a023          	sw	a5,0(s1)
					idx_inc(buffer, buffer->tmp_rd_idx,
40003fe8:	00842583          	lw	a1,8(s0)
						buffer->get_wlen(item));
40003fec:	01842783          	lw	a5,24(s0)
40003ff0:	00048513          	mv	a0,s1
					idx_inc(buffer, buffer->tmp_rd_idx,
40003ff4:	00b12623          	sw	a1,12(sp)
						buffer->get_wlen(item));
40003ff8:	000780e7          	jalr	a5
					idx_inc(buffer, buffer->tmp_rd_idx,
40003ffc:	00c12583          	lw	a1,12(sp)
						buffer->get_wlen(item));
40004000:	00050613          	mv	a2,a0
					idx_inc(buffer, buffer->tmp_rd_idx,
40004004:	00040513          	mv	a0,s0
40004008:	929ff0ef          	jal	ra,40003930 <idx_inc>
				buffer->tmp_rd_idx =
4000400c:	00a42423          	sw	a0,8(s0)
40004010:	30092073          	csrs	mstatus,s2
}
40004014:	02c12083          	lw	ra,44(sp)
40004018:	02812403          	lw	s0,40(sp)
4000401c:	02012903          	lw	s2,32(sp)
40004020:	01c12983          	lw	s3,28(sp)
40004024:	01812a03          	lw	s4,24(sp)
40004028:	00048513          	mv	a0,s1
4000402c:	02412483          	lw	s1,36(sp)
40004030:	03010113          	addi	sp,sp,48
40004034:	00008067          	ret

40004038 <mpsc_pbuf_free>:

void mpsc_pbuf_free(struct mpsc_pbuf_buffer *buffer,
		     const union mpsc_pbuf_generic *item)
{
40004038:	fe010113          	addi	sp,sp,-32
4000403c:	00812c23          	sw	s0,24(sp)
40004040:	00912a23          	sw	s1,20(sp)
40004044:	01212823          	sw	s2,16(sp)
40004048:	00112e23          	sw	ra,28(sp)
4000404c:	01312623          	sw	s3,12(sp)
	uint32_t wlen = buffer->get_wlen(item);
40004050:	01852783          	lw	a5,24(a0)
{
40004054:	00050413          	mv	s0,a0
	uint32_t wlen = buffer->get_wlen(item);
40004058:	00058513          	mv	a0,a1
{
4000405c:	00058493          	mv	s1,a1
	uint32_t wlen = buffer->get_wlen(item);
40004060:	000780e7          	jalr	a5
40004064:	00050913          	mv	s2,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40004068:	300479f3          	csrrci	s3,mstatus,8
	k_spinlock_key_t key = k_spin_lock(&buffer->lock);
	union mpsc_pbuf_generic *witem = (union mpsc_pbuf_generic *)item;

	witem->hdr.valid = 0;
4000406c:	0004a783          	lw	a5,0(s1)
40004070:	ffe7f713          	andi	a4,a5,-2
40004074:	00e4a023          	sw	a4,0(s1)
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE) ||
40004078:	01042703          	lw	a4,16(s0)
4000407c:	00277713          	andi	a4,a4,2
40004080:	00070c63          	beqz	a4,40004098 <mpsc_pbuf_free+0x60>
		 ((uint32_t *)item == &buffer->buf[buffer->rd_idx])) {
40004084:	00c42683          	lw	a3,12(s0)
40004088:	01c42703          	lw	a4,28(s0)
4000408c:	00269693          	slli	a3,a3,0x2
40004090:	00d70733          	add	a4,a4,a3
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE) ||
40004094:	06e49063          	bne	s1,a4,400040f4 <mpsc_pbuf_free+0xbc>
		witem->hdr.busy = 0;
40004098:	0004a783          	lw	a5,0(s1)
4000409c:	ffd7f793          	andi	a5,a5,-3
400040a0:	00f4a023          	sw	a5,0(s1)
		if (buffer->rd_idx == buffer->tmp_rd_idx) {
400040a4:	00842783          	lw	a5,8(s0)
400040a8:	00c42583          	lw	a1,12(s0)
400040ac:	00f59a63          	bne	a1,a5,400040c0 <mpsc_pbuf_free+0x88>
			 * at claimed item. In that case tmp_rd_idx points at
			 * the same location. In that case increment also tmp_rd_idx
			 * which will mark freed buffer as the only free space in
			 * the buffer.
			 */
			buffer->tmp_rd_idx = idx_inc(buffer, buffer->tmp_rd_idx, wlen);
400040b0:	00090613          	mv	a2,s2
400040b4:	00040513          	mv	a0,s0
400040b8:	879ff0ef          	jal	ra,40003930 <idx_inc>
400040bc:	00a42423          	sw	a0,8(s0)
		}
		rd_idx_inc(buffer, wlen);
400040c0:	00090593          	mv	a1,s2
400040c4:	00040513          	mv	a0,s0
400040c8:	899ff0ef          	jal	ra,40003960 <rd_idx_inc>
	__asm__ volatile ("csrs mstatus, %0"
400040cc:	0089f993          	andi	s3,s3,8
400040d0:	3009a073          	csrs	mstatus,s3
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
400040d4:	02840513          	addi	a0,s0,40
	}
	MPSC_PBUF_DBG(buffer, "<<freed: %p", item);

	k_spin_unlock(&buffer->lock, key);
	k_sem_give(&buffer->sem);
}
400040d8:	01812403          	lw	s0,24(sp)
400040dc:	01c12083          	lw	ra,28(sp)
400040e0:	01412483          	lw	s1,20(sp)
400040e4:	01012903          	lw	s2,16(sp)
400040e8:	00c12983          	lw	s3,12(sp)
400040ec:	02010113          	addi	sp,sp,32
400040f0:	0492b06f          	j	4002f938 <z_impl_k_sem_give>
		witem->skip.len = wlen;
400040f4:	00251913          	slli	s2,a0,0x2
400040f8:	0027f793          	andi	a5,a5,2
400040fc:	0127e7b3          	or	a5,a5,s2
40004100:	00f4a023          	sw	a5,0(s1)
40004104:	fc9ff06f          	j	400040cc <mpsc_pbuf_free+0x94>

40004108 <mpsc_pbuf_is_pending>:
	if (buffer->flags & MPSC_PBUF_FULL || buffer->tmp_rd_idx > buffer->wr_idx) {
40004108:	01052783          	lw	a5,16(a0)
4000410c:	00852703          	lw	a4,8(a0)
40004110:	0087f793          	andi	a5,a5,8
40004114:	00079863          	bnez	a5,40004124 <mpsc_pbuf_is_pending+0x1c>
40004118:	00452683          	lw	a3,4(a0)
	*res = (buffer->wr_idx - buffer->tmp_rd_idx);
4000411c:	40e687b3          	sub	a5,a3,a4
	if (buffer->flags & MPSC_PBUF_FULL || buffer->tmp_rd_idx > buffer->wr_idx) {
40004120:	00e6f663          	bgeu	a3,a4,4000412c <mpsc_pbuf_is_pending+0x24>
		*res = buffer->size - buffer->tmp_rd_idx;
40004124:	02052783          	lw	a5,32(a0)
40004128:	40e787b3          	sub	a5,a5,a4
	uint32_t a;

	(void)available(buffer, &a);

	return a ? true : false;
}
4000412c:	00f03533          	snez	a0,a5
40004130:	00008067          	ret

40004134 <mpsc_pbuf_get_utilization>:

void mpsc_pbuf_get_utilization(struct mpsc_pbuf_buffer *buffer,
			       uint32_t *size, uint32_t *now)
{
40004134:	ff010113          	addi	sp,sp,-16
40004138:	00812423          	sw	s0,8(sp)
4000413c:	00112623          	sw	ra,12(sp)
	/* One byte is left for full/empty distinction. */
	*size = (buffer->size - 1) * sizeof(int);
40004140:	02052783          	lw	a5,32(a0)
{
40004144:	00060413          	mv	s0,a2
	*size = (buffer->size - 1) * sizeof(int);
40004148:	fff78793          	addi	a5,a5,-1
4000414c:	00279793          	slli	a5,a5,0x2
40004150:	00f5a023          	sw	a5,0(a1)
	*now = get_usage(buffer) * sizeof(int);
40004154:	f8cff0ef          	jal	ra,400038e0 <get_usage>
40004158:	00251513          	slli	a0,a0,0x2
4000415c:	00a42023          	sw	a0,0(s0)
}
40004160:	00c12083          	lw	ra,12(sp)
40004164:	00812403          	lw	s0,8(sp)
40004168:	01010113          	addi	sp,sp,16
4000416c:	00008067          	ret

40004170 <mpsc_pbuf_get_max_utilization>:

int mpsc_pbuf_get_max_utilization(struct mpsc_pbuf_buffer *buffer, uint32_t *max)
{

	if (!(buffer->flags & MPSC_PBUF_MAX_UTILIZATION)) {
40004170:	01052783          	lw	a5,16(a0)
40004174:	0047f793          	andi	a5,a5,4
40004178:	00078c63          	beqz	a5,40004190 <mpsc_pbuf_get_max_utilization+0x20>
		return -ENOTSUP;
	}

	*max = buffer->max_usage * sizeof(int);
4000417c:	02452783          	lw	a5,36(a0)
	return 0;
40004180:	00000513          	li	a0,0
	*max = buffer->max_usage * sizeof(int);
40004184:	00279793          	slli	a5,a5,0x2
40004188:	00f5a023          	sw	a5,0(a1)
	return 0;
4000418c:	00008067          	ret
		return -ENOTSUP;
40004190:	f7a00513          	li	a0,-134
}
40004194:	00008067          	ret

40004198 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_STRIP_PATHS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
40004198:	00008067          	ret

4000419c <log_msg_generic_get_wlen>:
	va_end(ap);
}

static inline bool z_log_item_is_msg(const union log_msg_generic *msg)
{
	return msg->generic.type == Z_LOG_MSG_LOG;
4000419c:	00054783          	lbu	a5,0(a0)
 */
static inline uint32_t log_msg_generic_get_wlen(const union mpsc_pbuf_generic *item)
{
	const union log_msg_generic *generic_msg = (const union log_msg_generic *)item;

	if (z_log_item_is_msg(generic_msg)) {
400041a0:	0047f793          	andi	a5,a5,4
400041a4:	02079463          	bnez	a5,400041cc <log_msg_generic_get_wlen+0x30>
	return Z_LOG_MSG_ALIGNED_WLEN(desc.package_len, desc.data_len);
400041a8:	00052783          	lw	a5,0(a0)
400041ac:	0097d513          	srli	a0,a5,0x9
400041b0:	7ff57513          	andi	a0,a0,2047
400041b4:	0147d793          	srli	a5,a5,0x14
400041b8:	00f50533          	add	a0,a0,a5
400041bc:	01750513          	addi	a0,a0,23
400041c0:	ff857513          	andi	a0,a0,-8
400041c4:	00255513          	srli	a0,a0,0x2
		const struct log_msg *msg = (const struct log_msg *)generic_msg;

		return log_msg_get_total_wlen(msg->hdr.desc);
400041c8:	00008067          	ret
	}

	return 0;
400041cc:	00000513          	li	a0,0
}
400041d0:	00008067          	ret

400041d4 <dummy_timestamp>:
static void msg_process(union log_msg_generic *msg);

static log_timestamp_t dummy_timestamp(void)
{
	return 0;
}
400041d4:	00000513          	li	a0,0
400041d8:	00008067          	ret

400041dc <activate_foreach_backend>:
		z_log_runtime_filters_init();
	}
}

static uint32_t activate_foreach_backend(uint32_t mask)
{
400041dc:	fe010113          	addi	sp,sp,-32
400041e0:	01212823          	sw	s2,16(sp)
	while (mask_cpy) {
		uint32_t i = __builtin_ctz(mask_cpy);
		const struct log_backend *backend = log_backend_get(i);

		mask_cpy &= ~BIT(i);
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
400041e4:	40032937          	lui	s2,0x40032
{
400041e8:	00912a23          	sw	s1,20(sp)
400041ec:	01512223          	sw	s5,4(sp)
400041f0:	01612023          	sw	s6,0(sp)
400041f4:	00112e23          	sw	ra,28(sp)
400041f8:	00812c23          	sw	s0,24(sp)
400041fc:	01312623          	sw	s3,12(sp)
40004200:	01412423          	sw	s4,8(sp)
40004204:	00050493          	mv	s1,a0
	while (mask_cpy) {
40004208:	00050a93          	mv	s5,a0
		mask_cpy &= ~BIT(i);
4000420c:	00100b13          	li	s6,1
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
40004210:	50c90913          	addi	s2,s2,1292 # 4003250c <shell_uart_backend>
	while (mask_cpy) {
40004214:	02049863          	bnez	s1,40004244 <activate_foreach_backend+0x68>
					   CONFIG_LOG_MAX_LEVEL);
		}
	}

	return mask;
}
40004218:	01c12083          	lw	ra,28(sp)
4000421c:	01812403          	lw	s0,24(sp)
40004220:	01412483          	lw	s1,20(sp)
40004224:	01012903          	lw	s2,16(sp)
40004228:	00c12983          	lw	s3,12(sp)
4000422c:	00812a03          	lw	s4,8(sp)
40004230:	00012b03          	lw	s6,0(sp)
40004234:	000a8513          	mv	a0,s5
40004238:	00412a83          	lw	s5,4(sp)
4000423c:	02010113          	addi	sp,sp,32
40004240:	00008067          	ret
		uint32_t i = __builtin_ctz(mask_cpy);
40004244:	00048513          	mv	a0,s1
40004248:	820fc0ef          	jal	ra,40000268 <__ctzsi2>
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
4000424c:	00451413          	slli	s0,a0,0x4
40004250:	008909b3          	add	s3,s2,s0
40004254:	00c9c783          	lbu	a5,12(s3)
		mask_cpy &= ~BIT(i);
40004258:	00ab1a33          	sll	s4,s6,a0
4000425c:	fffa4a13          	not	s4,s4
40004260:	0144f4b3          	and	s1,s1,s4
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
40004264:	fa0788e3          	beqz	a5,40004214 <activate_foreach_backend+0x38>
 * @retval -EBUSY if backend is not yet ready.
 */
static inline int log_backend_is_ready(const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	if (backend->api->is_ready != NULL) {
40004268:	0009a783          	lw	a5,0(s3)
4000426c:	0107a783          	lw	a5,16(a5)
40004270:	02079263          	bnez	a5,40004294 <activate_foreach_backend+0xb8>
					   backend->cb->ctx,
40004274:	00890433          	add	s0,s2,s0
			log_backend_enable(backend,
40004278:	00442783          	lw	a5,4(s0)
4000427c:	00400613          	li	a2,4
40004280:	00098513          	mv	a0,s3
40004284:	0007a583          	lw	a1,0(a5)
			mask &= ~BIT(i);
40004288:	014afab3          	and	s5,s5,s4
			log_backend_enable(backend,
4000428c:	31d000ef          	jal	ra,40004da8 <log_backend_enable>
40004290:	f85ff06f          	j	40004214 <activate_foreach_backend+0x38>
		return backend->api->is_ready(backend);
40004294:	00098513          	mv	a0,s3
40004298:	000780e7          	jalr	a5
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
4000429c:	f6051ce3          	bnez	a0,40004214 <activate_foreach_backend+0x38>
400042a0:	fd5ff06f          	j	40004274 <activate_foreach_backend+0x98>

400042a4 <atomic_inc>:
		union { uintptr_t x; atomic_val_t val; } parm1 = { .val = value };
		return (atomic_val_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_ATOMIC_ADD);
	}
#endif
	compiler_barrier();
	return z_impl_atomic_add(target, value);
400042a4:	00100593          	li	a1,1
400042a8:	7a02d06f          	j	40031a48 <z_impl_atomic_add>

400042ac <enable_logger>:
struct k_thread logging_thread;

static int enable_logger(void)
{
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
400042ac:	400045b7          	lui	a1,0x40004
400042b0:	40039537          	lui	a0,0x40039
{
400042b4:	fe010113          	addi	sp,sp,-32
		k_timer_init(&log_process_thread_timer,
400042b8:	00000613          	li	a2,0
400042bc:	35458593          	addi	a1,a1,852 # 40004354 <log_process_thread_timer_expiry_fn>
400042c0:	5d850513          	addi	a0,a0,1496 # 400395d8 <log_process_thread_timer>
{
400042c4:	00112e23          	sw	ra,28(sp)
400042c8:	00812c23          	sw	s0,24(sp)
		k_timer_init(&log_process_thread_timer,
400042cc:	5fc2d0ef          	jal	ra,400318c8 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
400042d0:	00000793          	li	a5,0
400042d4:	00000813          	li	a6,0
400042d8:	40039437          	lui	s0,0x40039
400042dc:	400056b7          	lui	a3,0x40005
400042e0:	4003b5b7          	lui	a1,0x4003b
400042e4:	01012623          	sw	a6,12(sp)
400042e8:	00f12423          	sw	a5,8(sp)
400042ec:	00012023          	sw	zero,0(sp)
400042f0:	00e00893          	li	a7,14
400042f4:	00000813          	li	a6,0
400042f8:	00000713          	li	a4,0
400042fc:	89468693          	addi	a3,a3,-1900 # 40004894 <log_process_thread_func>
40004300:	30000613          	li	a2,768
40004304:	1f058593          	addi	a1,a1,496 # 4003b1f0 <logging_stack>
40004308:	11040513          	addi	a0,s0,272 # 40039110 <logging_thread>
4000430c:	4a52a0ef          	jal	ra,4002efb0 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
40004310:	400335b7          	lui	a1,0x40033
40004314:	11040513          	addi	a0,s0,272
40004318:	a5458593          	addi	a1,a1,-1452 # 40032a54 <__clz_tab+0x364>
4000431c:	1c92a0ef          	jal	ra,4002ece4 <z_impl_k_thread_name_set>
	} else {
		(void)z_log_init(false, false);
	}

	return 0;
}
40004320:	01c12083          	lw	ra,28(sp)
40004324:	01812403          	lw	s0,24(sp)
40004328:	00000513          	li	a0,0
4000432c:	02010113          	addi	sp,sp,32
40004330:	00008067          	ret

40004334 <default_lf_get_timestamp>:
{
40004334:	ff010113          	addi	sp,sp,-16
40004338:	00112623          	sw	ra,12(sp)
	return z_impl_k_uptime_ticks();
4000433c:	3182d0ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
}
40004340:	00c12083          	lw	ra,12(sp)
40004344:	00a00793          	li	a5,10
40004348:	02a78533          	mul	a0,a5,a0
4000434c:	01010113          	addi	sp,sp,16
40004350:	00008067          	ret

40004354 <log_process_thread_timer_expiry_fn>:
	z_impl_k_sem_give(sem);
40004354:	40045537          	lui	a0,0x40045
40004358:	8e050513          	addi	a0,a0,-1824 # 400448e0 <log_process_thread_sem>
4000435c:	5dc2b06f          	j	4002f938 <z_impl_k_sem_give>

40004360 <z_log_init>:
{
40004360:	fe010113          	addi	sp,sp,-32
40004364:	01512223          	sw	s5,4(sp)
40004368:	00050a93          	mv	s5,a0
	if (atomic_inc(&initialized) != 0) {
4000436c:	40039537          	lui	a0,0x40039
40004370:	fec50513          	addi	a0,a0,-20 # 40038fec <initialized>
{
40004374:	01412423          	sw	s4,8(sp)
40004378:	00112e23          	sw	ra,28(sp)
4000437c:	00812c23          	sw	s0,24(sp)
40004380:	00912a23          	sw	s1,20(sp)
40004384:	01212823          	sw	s2,16(sp)
40004388:	01312623          	sw	s3,12(sp)
4000438c:	01612023          	sw	s6,0(sp)
40004390:	00058a13          	mv	s4,a1
	if (atomic_inc(&initialized) != 0) {
40004394:	f11ff0ef          	jal	ra,400042a4 <atomic_inc>
40004398:	0a050e63          	beqz	a0,40004454 <z_log_init+0xf4>
	uint32_t mask = 0;
4000439c:	00000493          	li	s1,0
}
400043a0:	01c12083          	lw	ra,28(sp)
400043a4:	01812403          	lw	s0,24(sp)
400043a8:	01012903          	lw	s2,16(sp)
400043ac:	00c12983          	lw	s3,12(sp)
400043b0:	00812a03          	lw	s4,8(sp)
400043b4:	00412a83          	lw	s5,4(sp)
400043b8:	00012b03          	lw	s6,0(sp)
400043bc:	00048513          	mv	a0,s1
400043c0:	01412483          	lw	s1,20(sp)
400043c4:	02010113          	addi	sp,sp,32
400043c8:	00008067          	ret
		if (backend->autostart) {
400043cc:	00c44783          	lbu	a5,12(s0)
400043d0:	02078e63          	beqz	a5,4000440c <z_log_init+0xac>
	if (backend->api->init) {
400043d4:	00042783          	lw	a5,0(s0)
400043d8:	00c7a783          	lw	a5,12(a5)
400043dc:	00078663          	beqz	a5,400043e8 <z_log_init+0x88>
		backend->api->init(backend);
400043e0:	00040513          	mv	a0,s0
400043e4:	000780e7          	jalr	a5
	if (backend->api->is_ready != NULL) {
400043e8:	00042783          	lw	a5,0(s0)
400043ec:	0107a783          	lw	a5,16(a5)
400043f0:	04079663          	bnez	a5,4000443c <z_log_init+0xdc>
				log_backend_enable(backend,
400043f4:	00442783          	lw	a5,4(s0)
400043f8:	00400613          	li	a2,4
400043fc:	00040513          	mv	a0,s0
40004400:	0007a583          	lw	a1,0(a5)
40004404:	1a5000ef          	jal	ra,40004da8 <log_backend_enable>
			i++;
40004408:	00198993          	addi	s3,s3,1
	STRUCT_SECTION_FOREACH(log_backend, backend) {
4000440c:	01040413          	addi	s0,s0,16
40004410:	fb246ee3          	bltu	s0,s2,400043cc <z_log_init+0x6c>
	if (blocking) {
40004414:	f80a86e3          	beqz	s5,400043a0 <z_log_init+0x40>
		while (mask) {
40004418:	f80482e3          	beqz	s1,4000439c <z_log_init+0x3c>
			mask = activate_foreach_backend(mask);
4000441c:	00048513          	mv	a0,s1
40004420:	dbdff0ef          	jal	ra,400041dc <activate_foreach_backend>
40004424:	00050493          	mv	s1,a0
			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
40004428:	fe0a08e3          	beqz	s4,40004418 <z_log_init+0xb8>
	return z_impl_k_sleep(timeout);
4000442c:	00000593          	li	a1,0
40004430:	00100513          	li	a0,1
40004434:	2d12c0ef          	jal	ra,40030f04 <z_impl_k_sleep>
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline int32_t k_msleep(int32_t ms)
{
	return k_sleep(Z_TIMEOUT_MS(ms));
40004438:	fe1ff06f          	j	40004418 <z_log_init+0xb8>
		return backend->api->is_ready(backend);
4000443c:	00040513          	mv	a0,s0
40004440:	000780e7          	jalr	a5
			if (log_backend_is_ready(backend) == 0) {
40004444:	fa0508e3          	beqz	a0,400043f4 <z_log_init+0x94>
				mask |= BIT(i);
40004448:	013b17b3          	sll	a5,s6,s3
4000444c:	00f4e4b3          	or	s1,s1,a5
40004450:	fb9ff06f          	j	40004408 <z_log_init+0xa8>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40004454:	40032437          	lui	s0,0x40032
40004458:	40032937          	lui	s2,0x40032
4000445c:	00050993          	mv	s3,a0
40004460:	50c40413          	addi	s0,s0,1292 # 4003250c <shell_uart_backend>
	uint32_t mask = 0;
40004464:	00000493          	li	s1,0
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40004468:	51c90913          	addi	s2,s2,1308 # 4003251c <shell_uart>
				mask |= BIT(i);
4000446c:	00100b13          	li	s6,1
40004470:	fa1ff06f          	j	40004410 <z_log_init+0xb0>

40004474 <z_log_vprintk>:
{
40004474:	00050813          	mv	a6,a0
40004478:	00058893          	mv	a7,a1
		va_end(parm7.val);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg_runtime_vcreate(domain_id, source, level, data, dlen, package_flags, fmt, ap);
4000447c:	00000793          	li	a5,0
40004480:	00000713          	li	a4,0
40004484:	00000693          	li	a3,0
40004488:	00000613          	li	a2,0
4000448c:	00000593          	li	a1,0
40004490:	00000513          	li	a0,0
40004494:	4f10006f          	j	40005184 <z_impl_z_log_msg_runtime_vcreate>

40004498 <log_set_timestamp_func>:
{
40004498:	00050793          	mv	a5,a0
	if (timestamp_getter == NULL) {
4000449c:	02050663          	beqz	a0,400044c8 <log_set_timestamp_func+0x30>
{
400044a0:	ff010113          	addi	sp,sp,-16
400044a4:	00058513          	mv	a0,a1
	timestamp_func = timestamp_getter;
400044a8:	40044737          	lui	a4,0x40044
{
400044ac:	00112623          	sw	ra,12(sp)
	timestamp_func = timestamp_getter;
400044b0:	6af72823          	sw	a5,1712(a4) # 400446b0 <timestamp_func>
		log_output_timestamp_freq_set(freq);
400044b4:	4d4010ef          	jal	ra,40005988 <log_output_timestamp_freq_set>
}
400044b8:	00c12083          	lw	ra,12(sp)
	return 0;
400044bc:	00000513          	li	a0,0
}
400044c0:	01010113          	addi	sp,sp,16
400044c4:	00008067          	ret
		return -EINVAL;
400044c8:	fea00513          	li	a0,-22
}
400044cc:	00008067          	ret

400044d0 <z_log_notify_backend_enabled>:
{
400044d0:	ff010113          	addi	sp,sp,-16
400044d4:	00812423          	sw	s0,8(sp)
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
400044d8:	40039437          	lui	s0,0x40039
400044dc:	10444783          	lbu	a5,260(s0) # 40039104 <backend_attached>
{
400044e0:	00112623          	sw	ra,12(sp)
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
400044e4:	00079863          	bnez	a5,400044f4 <z_log_notify_backend_enabled+0x24>
	z_impl_k_sem_give(sem);
400044e8:	40045537          	lui	a0,0x40045
400044ec:	8e050513          	addi	a0,a0,-1824 # 400448e0 <log_process_thread_sem>
400044f0:	4482b0ef          	jal	ra,4002f938 <z_impl_k_sem_give>
	backend_attached = true;
400044f4:	00100793          	li	a5,1
}
400044f8:	00c12083          	lw	ra,12(sp)
	backend_attached = true;
400044fc:	10f40223          	sb	a5,260(s0)
}
40004500:	00812403          	lw	s0,8(sp)
40004504:	01010113          	addi	sp,sp,16
40004508:	00008067          	ret

4000450c <z_log_dropped>:
{
4000450c:	ff010113          	addi	sp,sp,-16
40004510:	00812423          	sw	s0,8(sp)
40004514:	00050413          	mv	s0,a0
	atomic_inc(&dropped_cnt);
40004518:	40039537          	lui	a0,0x40039
4000451c:	fe450513          	addi	a0,a0,-28 # 40038fe4 <dropped_cnt>
{
40004520:	00112623          	sw	ra,12(sp)
	atomic_inc(&dropped_cnt);
40004524:	d81ff0ef          	jal	ra,400042a4 <atomic_inc>
	if (buffered) {
40004528:	02040063          	beqz	s0,40004548 <z_log_dropped+0x3c>
}
4000452c:	00812403          	lw	s0,8(sp)
40004530:	00c12083          	lw	ra,12(sp)
		union { uintptr_t x; atomic_val_t val; } parm1 = { .val = value };
		return (atomic_val_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_ATOMIC_SUB);
	}
#endif
	compiler_barrier();
	return z_impl_atomic_sub(target, value);
40004534:	40039537          	lui	a0,0x40039
40004538:	00100593          	li	a1,1
4000453c:	fe850513          	addi	a0,a0,-24 # 40038fe8 <buffered_cnt>
40004540:	01010113          	addi	sp,sp,16
40004544:	5242d06f          	j	40031a68 <z_impl_atomic_sub>
40004548:	00c12083          	lw	ra,12(sp)
4000454c:	00812403          	lw	s0,8(sp)
40004550:	01010113          	addi	sp,sp,16
40004554:	00008067          	ret

40004558 <z_log_notify_drop>:
				     const union mpsc_pbuf_generic *item)
{
	ARG_UNUSED(buffer);
	ARG_UNUSED(item);

	z_log_dropped(true);
40004558:	00100513          	li	a0,1
4000455c:	fb1ff06f          	j	4000450c <z_log_dropped>

40004560 <z_log_dropped_read_and_clear>:
		union { uintptr_t x; atomic_val_t val; } parm1 = { .val = value };
		return (atomic_val_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_ATOMIC_SET);
	}
#endif
	compiler_barrier();
	return z_impl_atomic_set(target, value);
40004560:	40039537          	lui	a0,0x40039
40004564:	00000593          	li	a1,0
40004568:	fe450513          	addi	a0,a0,-28 # 40038fe4 <dropped_cnt>
4000456c:	5242d06f          	j	40031a90 <z_impl_atomic_set>

40004570 <dropped_notify>:
{
40004570:	ff010113          	addi	sp,sp,-16
40004574:	00812423          	sw	s0,8(sp)
40004578:	00912223          	sw	s1,4(sp)
4000457c:	01212023          	sw	s2,0(sp)
40004580:	00112623          	sw	ra,12(sp)
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40004584:	40032437          	lui	s0,0x40032
	uint32_t dropped = z_log_dropped_read_and_clear();
40004588:	fd9ff0ef          	jal	ra,40004560 <z_log_dropped_read_and_clear>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
4000458c:	400324b7          	lui	s1,0x40032
	uint32_t dropped = z_log_dropped_read_and_clear();
40004590:	00050913          	mv	s2,a0
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40004594:	50c40413          	addi	s0,s0,1292 # 4003250c <shell_uart_backend>
40004598:	51c48493          	addi	s1,s1,1308 # 4003251c <shell_uart>
4000459c:	00946e63          	bltu	s0,s1,400045b8 <dropped_notify+0x48>
}
400045a0:	00c12083          	lw	ra,12(sp)
400045a4:	00812403          	lw	s0,8(sp)
400045a8:	00412483          	lw	s1,4(sp)
400045ac:	00012903          	lw	s2,0(sp)
400045b0:	01010113          	addi	sp,sp,16
400045b4:	00008067          	ret
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
400045b8:	00442783          	lw	a5,4(s0)
		if (log_backend_is_active(backend)) {
400045bc:	0057c783          	lbu	a5,5(a5)
400045c0:	00078e63          	beqz	a5,400045dc <dropped_notify+0x6c>
	if (backend->api->dropped != NULL) {
400045c4:	00042783          	lw	a5,0(s0)
400045c8:	0047a783          	lw	a5,4(a5)
400045cc:	00078863          	beqz	a5,400045dc <dropped_notify+0x6c>
		backend->api->dropped(backend, cnt);
400045d0:	00090593          	mv	a1,s2
400045d4:	00040513          	mv	a0,s0
400045d8:	000780e7          	jalr	a5
	STRUCT_SECTION_FOREACH(log_backend, backend) {
400045dc:	01040413          	addi	s0,s0,16
400045e0:	fbdff06f          	j	4000459c <dropped_notify+0x2c>

400045e4 <z_log_msg_init>:
{
400045e4:	ff010113          	addi	sp,sp,-16
400045e8:	00812423          	sw	s0,8(sp)
	mpsc_pbuf_init(&log_buffer, &mpsc_config);
400045ec:	400335b7          	lui	a1,0x40033
400045f0:	40044437          	lui	s0,0x40044
400045f4:	6e840513          	addi	a0,s0,1768 # 400446e8 <log_buffer>
400045f8:	a5c58593          	addi	a1,a1,-1444 # 40032a5c <mpsc_config>
{
400045fc:	00112623          	sw	ra,12(sp)
	mpsc_pbuf_init(&log_buffer, &mpsc_config);
40004600:	e7cff0ef          	jal	ra,40003c7c <mpsc_pbuf_init>
	curr_log_buffer = &log_buffer;
40004604:	6e840413          	addi	s0,s0,1768
40004608:	400397b7          	lui	a5,0x40039
}
4000460c:	00c12083          	lw	ra,12(sp)
	curr_log_buffer = &log_buffer;
40004610:	fc87ae23          	sw	s0,-36(a5) # 40038fdc <curr_log_buffer>
}
40004614:	00812403          	lw	s0,8(sp)
40004618:	01010113          	addi	sp,sp,16
4000461c:	00008067          	ret

40004620 <log_core_init>:
	panic_mode = false;
40004620:	400397b7          	lui	a5,0x40039
40004624:	100782a3          	sb	zero,261(a5) # 40039105 <panic_mode>
		log_set_timestamp_func(default_lf_get_timestamp, 1000U);
40004628:	40004537          	lui	a0,0x40004
	dropped_cnt = 0;
4000462c:	400397b7          	lui	a5,0x40039
{
40004630:	ff010113          	addi	sp,sp,-16
	dropped_cnt = 0;
40004634:	fe07a223          	sw	zero,-28(a5) # 40038fe4 <dropped_cnt>
		log_set_timestamp_func(default_lf_get_timestamp, 1000U);
40004638:	3e800593          	li	a1,1000
	buffered_cnt = 0;
4000463c:	400397b7          	lui	a5,0x40039
		log_set_timestamp_func(default_lf_get_timestamp, 1000U);
40004640:	33450513          	addi	a0,a0,820 # 40004334 <default_lf_get_timestamp>
{
40004644:	00112623          	sw	ra,12(sp)
	buffered_cnt = 0;
40004648:	fe07a423          	sw	zero,-24(a5) # 40038fe8 <buffered_cnt>
		log_set_timestamp_func(default_lf_get_timestamp, 1000U);
4000464c:	e4dff0ef          	jal	ra,40004498 <log_set_timestamp_func>
		z_log_msg_init();
40004650:	f95ff0ef          	jal	ra,400045e4 <z_log_msg_init>
}
40004654:	00c12083          	lw	ra,12(sp)
40004658:	01010113          	addi	sp,sp,16
		z_log_runtime_filters_init();
4000465c:	4ac0006f          	j	40004b08 <z_log_runtime_filters_init>

40004660 <z_log_msg_alloc>:
{
40004660:	00050593          	mv	a1,a0
	return (struct log_msg *)mpsc_pbuf_alloc(buffer, wlen,
40004664:	40044537          	lui	a0,0x40044
40004668:	00000613          	li	a2,0
4000466c:	00000693          	li	a3,0
40004670:	6e850513          	addi	a0,a0,1768 # 400446e8 <log_buffer>
40004674:	e8cff06f          	j	40003d00 <mpsc_pbuf_alloc>

40004678 <z_log_msg_local_claim>:
	return (union log_msg_generic *)mpsc_pbuf_claim(&log_buffer);
40004678:	40044537          	lui	a0,0x40044
4000467c:	6e850513          	addi	a0,a0,1768 # 400446e8 <log_buffer>
40004680:	89dff06f          	j	40003f1c <mpsc_pbuf_claim>

40004684 <z_log_msg_free>:
	mpsc_pbuf_free(buffer, &msg->buf);
40004684:	400397b7          	lui	a5,0x40039
{
40004688:	00050593          	mv	a1,a0
	mpsc_pbuf_free(buffer, &msg->buf);
4000468c:	fdc7a503          	lw	a0,-36(a5) # 40038fdc <curr_log_buffer>
40004690:	9a9ff06f          	j	40004038 <mpsc_pbuf_free>

40004694 <z_log_msg_pending>:
	return mpsc_pbuf_is_pending(buffer);
40004694:	40044537          	lui	a0,0x40044
40004698:	6e850513          	addi	a0,a0,1768 # 400446e8 <log_buffer>
4000469c:	a6dff06f          	j	40004108 <mpsc_pbuf_is_pending>

400046a0 <z_impl_log_process>:
	if (!backend_attached) {
400046a0:	400397b7          	lui	a5,0x40039
400046a4:	1047c783          	lbu	a5,260(a5) # 40039104 <backend_attached>
400046a8:	14078c63          	beqz	a5,40004800 <z_impl_log_process+0x160>
{
400046ac:	fe010113          	addi	sp,sp,-32
400046b0:	00912a23          	sw	s1,20(sp)
400046b4:	00112e23          	sw	ra,28(sp)
400046b8:	00812c23          	sw	s0,24(sp)
400046bc:	01212823          	sw	s2,16(sp)
400046c0:	01312623          	sw	s3,12(sp)
	return z_log_msg_local_claim();
400046c4:	fb5ff0ef          	jal	ra,40004678 <z_log_msg_local_claim>
400046c8:	00050493          	mv	s1,a0
	if (msg) {
400046cc:	02050863          	beqz	a0,400046fc <z_impl_log_process+0x5c>
	return z_impl_atomic_sub(target, value);
400046d0:	40039537          	lui	a0,0x40039
400046d4:	00100593          	li	a1,1
400046d8:	fe850513          	addi	a0,a0,-24 # 40038fe8 <buffered_cnt>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
400046dc:	40032437          	lui	s0,0x40032
400046e0:	400329b7          	lui	s3,0x40032
400046e4:	3842d0ef          	jal	ra,40031a68 <z_impl_atomic_sub>
400046e8:	50c40413          	addi	s0,s0,1292 # 4003250c <shell_uart_backend>
400046ec:	51c98993          	addi	s3,s3,1308 # 4003251c <shell_uart>
400046f0:	09346863          	bltu	s0,s3,40004780 <z_impl_log_process+0xe0>
		z_log_msg_free(msg);
400046f4:	00048513          	mv	a0,s1
400046f8:	f8dff0ef          	jal	ra,40004684 <z_log_msg_free>
	return dropped_cnt > 0;
400046fc:	400397b7          	lui	a5,0x40039
		if ((dropped_pend || unordered_pend) &&
40004700:	fe47a783          	lw	a5,-28(a5) # 40038fe4 <dropped_cnt>
40004704:	40039437          	lui	s0,0x40039
40004708:	04f05063          	blez	a5,40004748 <z_impl_log_process+0xa8>
	return z_impl_k_uptime_ticks();
4000470c:	7492c0ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
40004710:	00a00793          	li	a5,10
40004714:	02a78733          	mul	a4,a5,a0
		   (k_uptime_get() - last_failure_report) > CONFIG_LOG_FAILURE_REPORT_PERIOD) {
40004718:	fc442683          	lw	a3,-60(s0) # 40038fc4 <last_failure_report+0x4>
4000471c:	02b785b3          	mul	a1,a5,a1
40004720:	02a7b7b3          	mulhu	a5,a5,a0
40004724:	00f585b3          	add	a1,a1,a5
40004728:	fc042783          	lw	a5,-64(s0)
4000472c:	40d585b3          	sub	a1,a1,a3
40004730:	40f707b3          	sub	a5,a4,a5
40004734:	00f73733          	sltu	a4,a4,a5
		if ((dropped_pend || unordered_pend) &&
40004738:	00e59663          	bne	a1,a4,40004744 <z_impl_log_process+0xa4>
4000473c:	3e800713          	li	a4,1000
40004740:	00f77463          	bgeu	a4,a5,40004748 <z_impl_log_process+0xa8>
				dropped_notify();
40004744:	e2dff0ef          	jal	ra,40004570 <dropped_notify>
		last_failure_report += CONFIG_LOG_FAILURE_REPORT_PERIOD;
40004748:	fc042783          	lw	a5,-64(s0)
4000474c:	fc442683          	lw	a3,-60(s0)
}
40004750:	01c12083          	lw	ra,28(sp)
		last_failure_report += CONFIG_LOG_FAILURE_REPORT_PERIOD;
40004754:	3e878713          	addi	a4,a5,1000
40004758:	00f737b3          	sltu	a5,a4,a5
4000475c:	00d787b3          	add	a5,a5,a3
40004760:	fce42023          	sw	a4,-64(s0)
40004764:	fcf42223          	sw	a5,-60(s0)
}
40004768:	01812403          	lw	s0,24(sp)
4000476c:	01412483          	lw	s1,20(sp)
40004770:	01012903          	lw	s2,16(sp)
40004774:	00c12983          	lw	s3,12(sp)
40004778:	02010113          	addi	sp,sp,32
	return z_log_msg_pending();
4000477c:	f19ff06f          	j	40004694 <z_log_msg_pending>
	return backend->cb->active;
40004780:	00442783          	lw	a5,4(s0)
		if (log_backend_is_active(backend) &&
40004784:	0057c783          	lbu	a5,5(a5)
40004788:	02078263          	beqz	a5,400047ac <z_impl_log_process+0x10c>
	return msg->generic.type == Z_LOG_MSG_LOG;
4000478c:	0004c783          	lbu	a5,0(s1)
	if (!z_log_item_is_msg(msg)) {
40004790:	0047f793          	andi	a5,a5,4
40004794:	02078063          	beqz	a5,400047b4 <z_impl_log_process+0x114>
	backend->api->process(backend, msg);
40004798:	00042783          	lw	a5,0(s0)
4000479c:	00048593          	mv	a1,s1
400047a0:	00040513          	mv	a0,s0
400047a4:	0007a783          	lw	a5,0(a5)
400047a8:	000780e7          	jalr	a5
	STRUCT_SECTION_FOREACH(log_backend, backend) {
400047ac:	01040413          	addi	s0,s0,16
400047b0:	f41ff06f          	j	400046f0 <z_impl_log_process+0x50>
 *
 * @return Log level.
 */
static inline uint8_t log_msg_get_level(struct log_msg *msg)
{
	return msg->hdr.desc.level;
400047b4:	0004a583          	lw	a1,0(s1)
 *
 * @return Pointer to the source data.
 */
static inline const void *log_msg_get_source(struct log_msg *msg)
{
	return msg->hdr.source;
400047b8:	0044a603          	lw	a2,4(s1)
	return msg->hdr.desc.level;
400047bc:	0065d913          	srli	s2,a1,0x6
400047c0:	00797913          	andi	s2,s2,7
	return msg->hdr.desc.domain;
400047c4:	0035d593          	srli	a1,a1,0x3
400047c8:	0075f593          	andi	a1,a1,7
	if (level == LOG_LEVEL_NONE) {
400047cc:	fc0906e3          	beqz	s2,40004798 <z_impl_log_process+0xf8>
	if (source) {
400047d0:	fc0604e3          	beqz	a2,40004798 <z_impl_log_process+0xf8>
 *
 * @return Source ID.
 */
static inline uint32_t log_dynamic_source_id(struct log_source_dynamic_data *data)
{
	return ((uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_dynamic))/
400047d4:	400447b7          	lui	a5,0x40044
400047d8:	72c78793          	addi	a5,a5,1836 # 4004472c <log_dynamic_cbprintf_package>
400047dc:	40f60633          	sub	a2,a2,a5
400047e0:	00265613          	srli	a2,a2,0x2
		backend_level = log_filter_get(backend, domain_id, source_id, true);
400047e4:	01061613          	slli	a2,a2,0x10
400047e8:	00100693          	li	a3,1
400047ec:	41065613          	srai	a2,a2,0x10
400047f0:	00040513          	mv	a0,s0
400047f4:	65c000ef          	jal	ra,40004e50 <log_filter_get>
		if (log_backend_is_active(backend) &&
400047f8:	fb256ae3          	bltu	a0,s2,400047ac <z_impl_log_process+0x10c>
400047fc:	f9dff06f          	j	40004798 <z_impl_log_process+0xf8>
}
40004800:	00000513          	li	a0,0
40004804:	00008067          	ret

40004808 <z_impl_log_panic>:
{
40004808:	ff010113          	addi	sp,sp,-16
4000480c:	01212023          	sw	s2,0(sp)
	if (panic_mode) {
40004810:	40039937          	lui	s2,0x40039
40004814:	10594783          	lbu	a5,261(s2) # 40039105 <panic_mode>
{
40004818:	00112623          	sw	ra,12(sp)
4000481c:	00812423          	sw	s0,8(sp)
40004820:	00912223          	sw	s1,4(sp)
	if (panic_mode) {
40004824:	02079a63          	bnez	a5,40004858 <z_impl_log_panic+0x50>
	(void)z_log_init(true, false);
40004828:	00000593          	li	a1,0
4000482c:	00100513          	li	a0,1
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40004830:	40032437          	lui	s0,0x40032
40004834:	400324b7          	lui	s1,0x40032
	(void)z_log_init(true, false);
40004838:	b29ff0ef          	jal	ra,40004360 <z_log_init>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
4000483c:	50c40413          	addi	s0,s0,1292 # 4003250c <shell_uart_backend>
40004840:	51c48493          	addi	s1,s1,1308 # 4003251c <shell_uart>
40004844:	02946663          	bltu	s0,s1,40004870 <z_impl_log_panic+0x68>
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke0(K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process();
40004848:	e59ff0ef          	jal	ra,400046a0 <z_impl_log_process>
		while (log_process() == true) {
4000484c:	fe051ee3          	bnez	a0,40004848 <z_impl_log_panic+0x40>
	panic_mode = true;
40004850:	00100793          	li	a5,1
40004854:	10f902a3          	sb	a5,261(s2)
}
40004858:	00c12083          	lw	ra,12(sp)
4000485c:	00812403          	lw	s0,8(sp)
40004860:	00412483          	lw	s1,4(sp)
40004864:	00012903          	lw	s2,0(sp)
40004868:	01010113          	addi	sp,sp,16
4000486c:	00008067          	ret
	return backend->cb->active;
40004870:	00442783          	lw	a5,4(s0)
		if (log_backend_is_active(backend)) {
40004874:	0057c783          	lbu	a5,5(a5)
40004878:	00078a63          	beqz	a5,4000488c <z_impl_log_panic+0x84>
	backend->api->panic(backend);
4000487c:	00042783          	lw	a5,0(s0)
40004880:	00040513          	mv	a0,s0
40004884:	0087a783          	lw	a5,8(a5)
40004888:	000780e7          	jalr	a5
	STRUCT_SECTION_FOREACH(log_backend, backend) {
4000488c:	01040413          	addi	s0,s0,16
40004890:	fb5ff06f          	j	40004844 <z_impl_log_panic+0x3c>

40004894 <log_process_thread_func>:
{
40004894:	fd010113          	addi	sp,sp,-48
	uint32_t activate_mask = z_log_init(false, false);
40004898:	00000593          	li	a1,0
4000489c:	00000513          	li	a0,0
{
400048a0:	02812423          	sw	s0,40(sp)
400048a4:	02112623          	sw	ra,44(sp)
400048a8:	02912223          	sw	s1,36(sp)
400048ac:	03212023          	sw	s2,32(sp)
400048b0:	01312e23          	sw	s3,28(sp)
400048b4:	01412c23          	sw	s4,24(sp)
400048b8:	01512a23          	sw	s5,20(sp)
400048bc:	01612823          	sw	s6,16(sp)
400048c0:	01712623          	sw	s7,12(sp)
400048c4:	01812423          	sw	s8,8(sp)
	uint32_t activate_mask = z_log_init(false, false);
400048c8:	a99ff0ef          	jal	ra,40004360 <z_log_init>
400048cc:	00050413          	mv	s0,a0
	k_timeout_t timeout = (activate_mask != 0) ? K_MSEC(50) : K_FOREVER;
400048d0:	08050a63          	beqz	a0,40004964 <log_process_thread_func+0xd0>
400048d4:	00500a13          	li	s4,5
400048d8:	00000a93          	li	s5,0
	return z_impl_z_current_get();
400048dc:	6682c0ef          	jal	ra,40030f44 <z_impl_z_current_get>
	proc_tid = process_tid;
400048e0:	400397b7          	lui	a5,0x40039
400048e4:	fea7a023          	sw	a0,-32(a5) # 40038fe0 <proc_tid>
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
400048e8:	02050063          	beqz	a0,40004908 <log_process_thread_func+0x74>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
400048ec:	400397b7          	lui	a5,0x40039
	    process_tid &&
400048f0:	fe87a703          	lw	a4,-24(a5) # 40038fe8 <buffered_cnt>
400048f4:	00900793          	li	a5,9
400048f8:	00e7d863          	bge	a5,a4,40004908 <log_process_thread_func+0x74>
	z_impl_k_sem_give(sem);
400048fc:	40045537          	lui	a0,0x40045
40004900:	8e050513          	addi	a0,a0,-1824 # 400448e0 <log_process_thread_sem>
40004904:	0342b0ef          	jal	ra,4002f938 <z_impl_k_sem_give>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40004908:	400329b7          	lui	s3,0x40032
	k_timeout_t timeout = (activate_mask != 0) ? K_MSEC(50) : K_FOREVER;
4000490c:	00000b13          	li	s6,0
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40004910:	40032bb7          	lui	s7,0x40032
40004914:	51c98993          	addi	s3,s3,1308 # 4003251c <shell_uart>
	return z_impl_k_sem_take(sem, timeout);
40004918:	40045c37          	lui	s8,0x40045
		if (activate_mask) {
4000491c:	00040e63          	beqz	s0,40004938 <log_process_thread_func+0xa4>
			activate_mask = activate_foreach_backend(activate_mask);
40004920:	00040513          	mv	a0,s0
40004924:	8b9ff0ef          	jal	ra,400041dc <activate_foreach_backend>
40004928:	00050413          	mv	s0,a0
			if (!activate_mask) {
4000492c:	00051663          	bnez	a0,40004938 <log_process_thread_func+0xa4>
				timeout = K_FOREVER;
40004930:	fff00a13          	li	s4,-1
40004934:	fff00a93          	li	s5,-1
40004938:	d69ff0ef          	jal	ra,400046a0 <z_impl_log_process>
4000493c:	00050913          	mv	s2,a0
		if (log_process() == false) {
40004940:	00051e63          	bnez	a0,4000495c <log_process_thread_func+0xc8>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40004944:	50cb8493          	addi	s1,s7,1292 # 4003250c <shell_uart_backend>
			if (processed_any) {
40004948:	040b1463          	bnez	s6,40004990 <log_process_thread_func+0xfc>
4000494c:	000a0593          	mv	a1,s4
40004950:	000a8613          	mv	a2,s5
40004954:	8e0c0513          	addi	a0,s8,-1824 # 400448e0 <log_process_thread_sem>
40004958:	0502b0ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
	k_timeout_t timeout = (activate_mask != 0) ? K_MSEC(50) : K_FOREVER;
4000495c:	00090b13          	mv	s6,s2
40004960:	fbdff06f          	j	4000491c <log_process_thread_func+0x88>
40004964:	fff00a13          	li	s4,-1
40004968:	fff00a93          	li	s5,-1
4000496c:	f71ff06f          	j	400048dc <log_process_thread_func+0x48>
				      enum log_backend_evt event,
				      union log_backend_evt_arg *arg)
{
	__ASSERT_NO_MSG(backend != NULL);

	if (backend->api->notify) {
40004970:	0004a783          	lw	a5,0(s1)
40004974:	0187a783          	lw	a5,24(a5)
40004978:	00078a63          	beqz	a5,4000498c <log_process_thread_func+0xf8>
		backend->api->notify(backend, event, arg);
4000497c:	00000613          	li	a2,0
40004980:	00000593          	li	a1,0
40004984:	00048513          	mv	a0,s1
40004988:	000780e7          	jalr	a5
	STRUCT_SECTION_FOREACH(log_backend, backend) {
4000498c:	01048493          	addi	s1,s1,16
40004990:	ff34e0e3          	bltu	s1,s3,40004970 <log_process_thread_func+0xdc>
40004994:	fb9ff06f          	j	4000494c <log_process_thread_func+0xb8>

40004998 <z_log_msg_post_finalize>:
	atomic_val_t cnt = atomic_inc(&buffered_cnt);
40004998:	40039537          	lui	a0,0x40039
{
4000499c:	ff010113          	addi	sp,sp,-16
	atomic_val_t cnt = atomic_inc(&buffered_cnt);
400049a0:	fe850513          	addi	a0,a0,-24 # 40038fe8 <buffered_cnt>
{
400049a4:	00112623          	sw	ra,12(sp)
400049a8:	00812423          	sw	s0,8(sp)
	atomic_val_t cnt = atomic_inc(&buffered_cnt);
400049ac:	8f9ff0ef          	jal	ra,400042a4 <atomic_inc>
	if (panic_mode) {
400049b0:	400397b7          	lui	a5,0x40039
400049b4:	1057c783          	lbu	a5,261(a5) # 40039105 <panic_mode>
400049b8:	02078263          	beqz	a5,400049dc <z_log_msg_post_finalize+0x44>
	__asm__ volatile ("csrrc %0, mstatus, %1"
400049bc:	30047473          	csrrci	s0,mstatus,8
400049c0:	ce1ff0ef          	jal	ra,400046a0 <z_impl_log_process>
	__asm__ volatile ("csrs mstatus, %0"
400049c4:	00847413          	andi	s0,s0,8
400049c8:	30042073          	csrs	mstatus,s0
}
400049cc:	00c12083          	lw	ra,12(sp)
400049d0:	00812403          	lw	s0,8(sp)
400049d4:	01010113          	addi	sp,sp,16
400049d8:	00008067          	ret
	} else if (proc_tid != NULL) {
400049dc:	400397b7          	lui	a5,0x40039
400049e0:	fe07a783          	lw	a5,-32(a5) # 40038fe0 <proc_tid>
400049e4:	fe0784e3          	beqz	a5,400049cc <z_log_msg_post_finalize+0x34>
		if (cnt == 0) {
400049e8:	02051663          	bnez	a0,40004a14 <z_log_msg_post_finalize+0x7c>
}
400049ec:	00812403          	lw	s0,8(sp)
400049f0:	00c12083          	lw	ra,12(sp)
	z_impl_k_timer_start(timer, duration, period);
400049f4:	40039537          	lui	a0,0x40039
400049f8:	00000693          	li	a3,0
400049fc:	00000713          	li	a4,0
40004a00:	06400593          	li	a1,100
40004a04:	00000613          	li	a2,0
40004a08:	5d850513          	addi	a0,a0,1496 # 400395d8 <log_process_thread_timer>
40004a0c:	01010113          	addi	sp,sp,16
40004a10:	6e12c06f          	j	400318f0 <z_impl_k_timer_start>
		} else if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
40004a14:	00a00793          	li	a5,10
40004a18:	faf51ae3          	bne	a0,a5,400049cc <z_log_msg_post_finalize+0x34>
	z_impl_k_timer_stop(timer);
40004a1c:	40039537          	lui	a0,0x40039
40004a20:	5d850513          	addi	a0,a0,1496 # 400395d8 <log_process_thread_timer>
40004a24:	7a12c0ef          	jal	ra,400319c4 <z_impl_k_timer_stop>
}
40004a28:	00812403          	lw	s0,8(sp)
40004a2c:	00c12083          	lw	ra,12(sp)
	z_impl_k_sem_give(sem);
40004a30:	40045537          	lui	a0,0x40045
40004a34:	8e050513          	addi	a0,a0,-1824 # 400448e0 <log_process_thread_sem>
40004a38:	01010113          	addi	sp,sp,16
40004a3c:	6fd2a06f          	j	4002f938 <z_impl_k_sem_give>

40004a40 <z_log_msg_commit>:
	msg->hdr.timestamp = timestamp_func();
40004a40:	400447b7          	lui	a5,0x40044
40004a44:	6b07a783          	lw	a5,1712(a5) # 400446b0 <timestamp_func>
{
40004a48:	fe010113          	addi	sp,sp,-32
40004a4c:	00112e23          	sw	ra,28(sp)
40004a50:	00a12623          	sw	a0,12(sp)
	msg->hdr.timestamp = timestamp_func();
40004a54:	000780e7          	jalr	a5
40004a58:	00c12583          	lw	a1,12(sp)
40004a5c:	00a5a423          	sw	a0,8(a1)
	mpsc_pbuf_commit(buffer, &m->buf);
40004a60:	40044537          	lui	a0,0x40044
40004a64:	6e850513          	addi	a0,a0,1768 # 400446e8 <log_buffer>
40004a68:	c40ff0ef          	jal	ra,40003ea8 <mpsc_pbuf_commit>
}
40004a6c:	01c12083          	lw	ra,28(sp)
40004a70:	02010113          	addi	sp,sp,32
	z_log_msg_post_finalize();
40004a74:	f25ff06f          	j	40004998 <z_log_msg_post_finalize>

40004a78 <z_log_get_tag>:
}
40004a78:	00000513          	li	a0,0
40004a7c:	00008067          	ret

40004a80 <log_mem_get_usage>:
{
40004a80:	00058613          	mv	a2,a1
	mpsc_pbuf_get_utilization(&log_buffer, buf_size, usage);
40004a84:	00050593          	mv	a1,a0
40004a88:	40044537          	lui	a0,0x40044
{
40004a8c:	ff010113          	addi	sp,sp,-16
	mpsc_pbuf_get_utilization(&log_buffer, buf_size, usage);
40004a90:	6e850513          	addi	a0,a0,1768 # 400446e8 <log_buffer>
{
40004a94:	00112623          	sw	ra,12(sp)
	mpsc_pbuf_get_utilization(&log_buffer, buf_size, usage);
40004a98:	e9cff0ef          	jal	ra,40004134 <mpsc_pbuf_get_utilization>
}
40004a9c:	00c12083          	lw	ra,12(sp)
40004aa0:	00000513          	li	a0,0
40004aa4:	01010113          	addi	sp,sp,16
40004aa8:	00008067          	ret

40004aac <log_mem_get_max_usage>:
{
40004aac:	00050593          	mv	a1,a0
	return mpsc_pbuf_get_max_utilization(&log_buffer, max);
40004ab0:	40044537          	lui	a0,0x40044
40004ab4:	6e850513          	addi	a0,a0,1768 # 400446e8 <log_buffer>
40004ab8:	eb8ff06f          	j	40004170 <mpsc_pbuf_get_max_utilization>

40004abc <log_src_cnt_get>:
	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
40004abc:	40032537          	lui	a0,0x40032
40004ac0:	400327b7          	lui	a5,0x40032
40004ac4:	3f478793          	addi	a5,a5,1012 # 400323f4 <log_const_cbprintf_package>
40004ac8:	50c50513          	addi	a0,a0,1292 # 4003250c <shell_uart_backend>
40004acc:	40f50533          	sub	a0,a0,a5
	if (z_log_is_local_domain(domain_id)) {
		return z_log_sources_count();
	}

	return link_source_count(domain_id);
}
40004ad0:	00355513          	srli	a0,a0,0x3
40004ad4:	00008067          	ret

40004ad8 <log_source_name_get>:
40004ad8:	40032737          	lui	a4,0x40032
40004adc:	400327b7          	lui	a5,0x40032
40004ae0:	3f470713          	addi	a4,a4,1012 # 400323f4 <log_const_cbprintf_package>
40004ae4:	50c78793          	addi	a5,a5,1292 # 4003250c <shell_uart_backend>
40004ae8:	40e787b3          	sub	a5,a5,a4
40004aec:	0037d793          	srli	a5,a5,0x3
{
	if (z_log_is_local_domain(domain_id)) {
		if (source_id < log_src_cnt_get(domain_id)) {
			return TYPE_SECTION_START(log_const)[source_id].name;
		} else {
			return NULL;
40004af0:	00000513          	li	a0,0
		if (source_id < log_src_cnt_get(domain_id)) {
40004af4:	00f5f863          	bgeu	a1,a5,40004b04 <log_source_name_get+0x2c>
			return TYPE_SECTION_START(log_const)[source_id].name;
40004af8:	00359593          	slli	a1,a1,0x3
40004afc:	00b70733          	add	a4,a4,a1
40004b00:	00072503          	lw	a0,0(a4)
		}
	}

	return link_source_name_get(domain_id, source_id);
}
40004b04:	00008067          	ret

40004b08 <z_log_runtime_filters_init>:
	 *
	 * Each log source's aggregated runtime level is set to match its
	 * compile-time level. When backends are attached later on in
	 * log_init(), they'll be initialized to the same value.
	 */
	for (int i = 0; i < z_log_sources_count(); i++) {
40004b08:	40032737          	lui	a4,0x40032
40004b0c:	400327b7          	lui	a5,0x40032
40004b10:	3f470713          	addi	a4,a4,1012 # 400323f4 <log_const_cbprintf_package>
40004b14:	50c78793          	addi	a5,a5,1292 # 4003250c <shell_uart_backend>
40004b18:	400446b7          	lui	a3,0x40044
40004b1c:	40e787b3          	sub	a5,a5,a4
40004b20:	72c68693          	addi	a3,a3,1836 # 4004472c <log_dynamic_cbprintf_package>
40004b24:	0037d793          	srli	a5,a5,0x3
40004b28:	00000593          	li	a1,0
40004b2c:	00870713          	addi	a4,a4,8
40004b30:	00f59463          	bne	a1,a5,40004b38 <z_log_runtime_filters_init+0x30>
		level = MAX(level, CONFIG_LOG_OVERRIDE_LEVEL);
		LOG_FILTER_SLOT_SET(filters,
				    LOG_FILTER_AGGR_SLOT_IDX,
				    level);
	}
}
40004b34:	00008067          	ret
		LOG_FILTER_SLOT_SET(filters,
40004b38:	0006a603          	lw	a2,0(a3)
40004b3c:	ffc74503          	lbu	a0,-4(a4)
	for (int i = 0; i < z_log_sources_count(); i++) {
40004b40:	00158593          	addi	a1,a1,1
		LOG_FILTER_SLOT_SET(filters,
40004b44:	ff867613          	andi	a2,a2,-8
40004b48:	00757513          	andi	a0,a0,7
40004b4c:	00a66633          	or	a2,a2,a0
40004b50:	00c6a023          	sw	a2,0(a3)
	for (int i = 0; i < z_log_sources_count(); i++) {
40004b54:	00468693          	addi	a3,a3,4
40004b58:	fd5ff06f          	j	40004b2c <z_log_runtime_filters_init+0x24>

40004b5c <log_source_id_get>:

int log_source_id_get(const char *name)
{
40004b5c:	fe010113          	addi	sp,sp,-32
40004b60:	00812c23          	sw	s0,24(sp)
40004b64:	00912a23          	sw	s1,20(sp)
40004b68:	40032437          	lui	s0,0x40032
40004b6c:	400324b7          	lui	s1,0x40032
40004b70:	3f448493          	addi	s1,s1,1012 # 400323f4 <log_const_cbprintf_package>
40004b74:	50c40413          	addi	s0,s0,1292 # 4003250c <shell_uart_backend>
40004b78:	40940433          	sub	s0,s0,s1
40004b7c:	01212823          	sw	s2,16(sp)
40004b80:	01312623          	sw	s3,12(sp)
40004b84:	00112e23          	sw	ra,28(sp)
40004b88:	00050993          	mv	s3,a0
40004b8c:	00345413          	srli	s0,s0,0x3
	for (int i = 0; i < log_src_cnt_get(Z_LOG_LOCAL_DOMAIN_ID); i++) {
40004b90:	00000913          	li	s2,0
40004b94:	00891663          	bne	s2,s0,40004ba0 <log_source_id_get+0x44>

		if ((sname != NULL) && (strcmp(sname, name) == 0)) {
			return i;
		}
	}
	return -1;
40004b98:	fff00913          	li	s2,-1
40004b9c:	0240006f          	j	40004bc0 <log_source_id_get+0x64>
			return TYPE_SECTION_START(log_const)[source_id].name;
40004ba0:	0004a503          	lw	a0,0(s1)
		if ((sname != NULL) && (strcmp(sname, name) == 0)) {
40004ba4:	00051863          	bnez	a0,40004bb4 <log_source_id_get+0x58>
	for (int i = 0; i < log_src_cnt_get(Z_LOG_LOCAL_DOMAIN_ID); i++) {
40004ba8:	00190913          	addi	s2,s2,1
40004bac:	00848493          	addi	s1,s1,8
40004bb0:	fe5ff06f          	j	40004b94 <log_source_id_get+0x38>
		if ((sname != NULL) && (strcmp(sname, name) == 0)) {
40004bb4:	00098593          	mv	a1,s3
40004bb8:	060080ef          	jal	ra,4000cc18 <strcmp>
40004bbc:	fe0516e3          	bnez	a0,40004ba8 <log_source_id_get+0x4c>
}
40004bc0:	01c12083          	lw	ra,28(sp)
40004bc4:	01812403          	lw	s0,24(sp)
40004bc8:	01412483          	lw	s1,20(sp)
40004bcc:	00c12983          	lw	s3,12(sp)
40004bd0:	00090513          	mv	a0,s2
40004bd4:	01012903          	lw	s2,16(sp)
40004bd8:	02010113          	addi	sp,sp,32
40004bdc:	00008067          	ret

40004be0 <z_impl_log_filter_set>:
}

uint32_t z_impl_log_filter_set(struct log_backend const *const backend,
			       uint32_t domain_id, int16_t source_id,
			       uint32_t level)
{
40004be0:	fe010113          	addi	sp,sp,-32
40004be4:	00812c23          	sw	s0,24(sp)
40004be8:	01312623          	sw	s3,12(sp)
40004bec:	00112e23          	sw	ra,28(sp)
40004bf0:	00912a23          	sw	s1,20(sp)
40004bf4:	01212823          	sw	s2,16(sp)
40004bf8:	01412423          	sw	s4,8(sp)
40004bfc:	01512223          	sw	s5,4(sp)
40004c00:	00060413          	mv	s0,a2
40004c04:	00068993          	mv	s3,a3
	}

	__ASSERT_NO_MSG(source_id < log_src_cnt_get(domain_id));


	if (backend == NULL) {
40004c08:	06051663          	bnez	a0,40004c74 <z_impl_log_filter_set+0x94>
		uint32_t max = 0U;

		STRUCT_SECTION_FOREACH(log_backend, iter_backend) {
40004c0c:	40032937          	lui	s2,0x40032
40004c10:	40032a37          	lui	s4,0x40032
40004c14:	00058a93          	mv	s5,a1
40004c18:	50c90913          	addi	s2,s2,1292 # 4003250c <shell_uart_backend>
		uint32_t max = 0U;
40004c1c:	00000493          	li	s1,0
		STRUCT_SECTION_FOREACH(log_backend, iter_backend) {
40004c20:	51ca0a13          	addi	s4,s4,1308 # 4003251c <shell_uart>
40004c24:	0240006f          	j	40004c48 <z_impl_log_filter_set+0x68>
		union { uintptr_t x; uint32_t val; } parm3 = { .val = level };
		return (uint32_t) arch_syscall_invoke4(parm0.x, parm1.x, parm2.x, parm3.x, K_SYSCALL_LOG_FILTER_SET);
	}
#endif
	compiler_barrier();
	return z_impl_log_filter_set(backend, domain_id, source_id, level);
40004c28:	00098693          	mv	a3,s3
40004c2c:	00040613          	mv	a2,s0
40004c30:	000a8593          	mv	a1,s5
40004c34:	00090513          	mv	a0,s2
40004c38:	fa9ff0ef          	jal	ra,40004be0 <z_impl_log_filter_set>
			uint32_t current = log_filter_set(iter_backend,
						 domain_id, source_id, level);

			max = MAX(current, max);
40004c3c:	00a4f463          	bgeu	s1,a0,40004c44 <z_impl_log_filter_set+0x64>
40004c40:	00050493          	mv	s1,a0
		STRUCT_SECTION_FOREACH(log_backend, iter_backend) {
40004c44:	01090913          	addi	s2,s2,16
40004c48:	ff4960e3          	bltu	s2,s4,40004c28 <z_impl_log_filter_set+0x48>
	level = MIN(level, MAX(log_filter_get(backend, domain_id, source_id, false),
			       CONFIG_LOG_OVERRIDE_LEVEL));
	set_runtime_filter(log_backend_id_get(backend), domain_id, source_id, level);

	return level;
}
40004c4c:	01c12083          	lw	ra,28(sp)
40004c50:	01812403          	lw	s0,24(sp)
40004c54:	01012903          	lw	s2,16(sp)
40004c58:	00c12983          	lw	s3,12(sp)
40004c5c:	00812a03          	lw	s4,8(sp)
40004c60:	00412a83          	lw	s5,4(sp)
40004c64:	00048513          	mv	a0,s1
40004c68:	01412483          	lw	s1,20(sp)
40004c6c:	02010113          	addi	sp,sp,32
40004c70:	00008067          	ret
40004c74:	40032737          	lui	a4,0x40032
40004c78:	400327b7          	lui	a5,0x40032
40004c7c:	3f470713          	addi	a4,a4,1012 # 400323f4 <log_const_cbprintf_package>
40004c80:	50c78793          	addi	a5,a5,1292 # 4003250c <shell_uart_backend>
40004c84:	40e787b3          	sub	a5,a5,a4
40004c88:	0037d793          	srli	a5,a5,0x3
	level = MIN(level, MAX(log_filter_get(backend, domain_id, source_id, false),
40004c8c:	00000493          	li	s1,0
		if (source_id < log_src_cnt_get(domain_id)) {
40004c90:	00f67c63          	bgeu	a2,a5,40004ca8 <z_impl_log_filter_set+0xc8>
			return TYPE_SECTION_START(log_const)[source_id].level;
40004c94:	00361793          	slli	a5,a2,0x3
40004c98:	00f70733          	add	a4,a4,a5

		return LOG_FILTER_SLOT_GET(get_dynamic_filter(domain_id, source_id),
					   log_backend_id_get(backend));
	}

	return log_compiled_level_get(domain_id, source_id);
40004c9c:	00474483          	lbu	s1,4(a4)
40004ca0:	0096f463          	bgeu	a3,s1,40004ca8 <z_impl_log_filter_set+0xc8>
40004ca4:	00068493          	mv	s1,a3
	return backend->cb->id;
40004ca8:	00452783          	lw	a5,4(a0)
	prev_max = LOG_FILTER_SLOT_GET(filters, LOG_FILTER_AGGR_SLOT_IDX);
40004cac:	40044737          	lui	a4,0x40044
40004cb0:	72c70613          	addi	a2,a4,1836 # 4004472c <log_dynamic_cbprintf_package>
	LOG_FILTER_SLOT_SET(filters, backend_id, level);
40004cb4:	0047c683          	lbu	a3,4(a5)
40004cb8:	00300793          	li	a5,3
	prev_max = LOG_FILTER_SLOT_GET(filters, LOG_FILTER_AGGR_SLOT_IDX);
40004cbc:	00241413          	slli	s0,s0,0x2
	LOG_FILTER_SLOT_SET(filters, backend_id, level);
40004cc0:	02f686b3          	mul	a3,a3,a5
	prev_max = LOG_FILTER_SLOT_GET(filters, LOG_FILTER_AGGR_SLOT_IDX);
40004cc4:	00860633          	add	a2,a2,s0
	LOG_FILTER_SLOT_SET(filters, backend_id, level);
40004cc8:	00062603          	lw	a2,0(a2)
40004ccc:	00700793          	li	a5,7
	uint32_t max_filter = LOG_LEVEL_NONE;
40004cd0:	00000593          	li	a1,0
40004cd4:	72c70713          	addi	a4,a4,1836
	for (i = first_slot; i < LOG_FILTERS_NUM_OF_SLOTS; i++) {
40004cd8:	01e00513          	li	a0,30
	LOG_FILTER_SLOT_SET(filters, backend_id, level);
40004cdc:	00d797b3          	sll	a5,a5,a3
40004ce0:	fff7c793          	not	a5,a5
40004ce4:	00c7f7b3          	and	a5,a5,a2
40004ce8:	0074f613          	andi	a2,s1,7
40004cec:	00d616b3          	sll	a3,a2,a3
40004cf0:	00d7e7b3          	or	a5,a5,a3
40004cf4:	00300693          	li	a3,3
		uint32_t tmp_filter = LOG_FILTER_SLOT_GET(&filters, i);
40004cf8:	00d7d633          	srl	a2,a5,a3
40004cfc:	00767613          	andi	a2,a2,7
40004d00:	00c5f463          	bgeu	a1,a2,40004d08 <z_impl_log_filter_set+0x128>
40004d04:	00060593          	mv	a1,a2
	for (i = first_slot; i < LOG_FILTERS_NUM_OF_SLOTS; i++) {
40004d08:	00368693          	addi	a3,a3,3
40004d0c:	fea696e3          	bne	a3,a0,40004cf8 <z_impl_log_filter_set+0x118>
	LOG_FILTER_SLOT_SET(filters, LOG_FILTER_AGGR_SLOT_IDX, new_max);
40004d10:	ff87f793          	andi	a5,a5,-8
40004d14:	00870733          	add	a4,a4,s0
40004d18:	00b7e7b3          	or	a5,a5,a1
40004d1c:	00f72023          	sw	a5,0(a4)
}
40004d20:	f2dff06f          	j	40004c4c <z_impl_log_filter_set+0x6c>

40004d24 <backend_filter_set>:
{
40004d24:	fe010113          	addi	sp,sp,-32
40004d28:	00812c23          	sw	s0,24(sp)
40004d2c:	400327b7          	lui	a5,0x40032
40004d30:	40032437          	lui	s0,0x40032
40004d34:	50c40413          	addi	s0,s0,1292 # 4003250c <shell_uart_backend>
40004d38:	3f478793          	addi	a5,a5,1012 # 400323f4 <log_const_cbprintf_package>
40004d3c:	40f40433          	sub	s0,s0,a5
40004d40:	00912a23          	sw	s1,20(sp)
40004d44:	01212823          	sw	s2,16(sp)
40004d48:	01312623          	sw	s3,12(sp)
40004d4c:	00112e23          	sw	ra,28(sp)
40004d50:	00050913          	mv	s2,a0
40004d54:	00058993          	mv	s3,a1
40004d58:	00345413          	srli	s0,s0,0x3
	for (uint16_t s = 0; s < log_src_cnt_get(0); s++) {
40004d5c:	00000493          	li	s1,0
40004d60:	0284e063          	bltu	s1,s0,40004d80 <backend_filter_set+0x5c>
}
40004d64:	01c12083          	lw	ra,28(sp)
40004d68:	01812403          	lw	s0,24(sp)
40004d6c:	01412483          	lw	s1,20(sp)
40004d70:	01012903          	lw	s2,16(sp)
40004d74:	00c12983          	lw	s3,12(sp)
40004d78:	02010113          	addi	sp,sp,32
40004d7c:	00008067          	ret
40004d80:	01049613          	slli	a2,s1,0x10
	for (uint16_t s = 0; s < log_src_cnt_get(0); s++) {
40004d84:	00148493          	addi	s1,s1,1
40004d88:	00098693          	mv	a3,s3
40004d8c:	41065613          	srai	a2,a2,0x10
40004d90:	00000593          	li	a1,0
40004d94:	00090513          	mv	a0,s2
40004d98:	01049493          	slli	s1,s1,0x10
40004d9c:	e45ff0ef          	jal	ra,40004be0 <z_impl_log_filter_set>
40004da0:	0104d493          	srli	s1,s1,0x10
40004da4:	fbdff06f          	j	40004d60 <backend_filter_set+0x3c>

40004da8 <log_backend_enable>:
	id += backend - log_backend_get(0);
40004da8:	400327b7          	lui	a5,0x40032
40004dac:	50c78793          	addi	a5,a5,1292 # 4003250c <shell_uart_backend>
	backend->cb->id = id;
40004db0:	00452703          	lw	a4,4(a0)
40004db4:	40f507b3          	sub	a5,a0,a5
{
40004db8:	ff010113          	addi	sp,sp,-16
	id += backend - log_backend_get(0);
40004dbc:	4047d793          	srai	a5,a5,0x4
{
40004dc0:	00812423          	sw	s0,8(sp)
40004dc4:	00912223          	sw	s1,4(sp)
40004dc8:	00112623          	sw	ra,12(sp)
	id += backend - log_backend_get(0);
40004dcc:	00178793          	addi	a5,a5,1
	log_backend_id_set(backend, id);
40004dd0:	00f70223          	sb	a5,4(a4)
	backend->cb->level = level;
40004dd4:	00452783          	lw	a5,4(a0)
{
40004dd8:	00058493          	mv	s1,a1
40004ddc:	00060593          	mv	a1,a2
	backend->cb->level = level;
40004de0:	00c78323          	sb	a2,6(a5)
{
40004de4:	00050413          	mv	s0,a0
	backend_filter_set(backend, level);
40004de8:	f3dff0ef          	jal	ra,40004d24 <backend_filter_set>
	backend->cb->ctx = ctx;
40004dec:	00442783          	lw	a5,4(s0)
	backend->cb->active = true;
40004df0:	00100713          	li	a4,1
	backend->cb->ctx = ctx;
40004df4:	0097a023          	sw	s1,0(a5)
	backend->cb->active = true;
40004df8:	00442783          	lw	a5,4(s0)
40004dfc:	00e782a3          	sb	a4,5(a5)
}
40004e00:	00812403          	lw	s0,8(sp)
40004e04:	00c12083          	lw	ra,12(sp)
40004e08:	00412483          	lw	s1,4(sp)
40004e0c:	01010113          	addi	sp,sp,16
	z_log_notify_backend_enabled();
40004e10:	ec0ff06f          	j	400044d0 <z_log_notify_backend_enabled>

40004e14 <log_backend_disable>:
	return backend->cb->active;
40004e14:	00452783          	lw	a5,4(a0)
{
40004e18:	ff010113          	addi	sp,sp,-16
40004e1c:	00812423          	sw	s0,8(sp)
40004e20:	00112623          	sw	ra,12(sp)
	if (log_backend_is_active(backend)) {
40004e24:	0057c783          	lbu	a5,5(a5)
{
40004e28:	00050413          	mv	s0,a0
	if (log_backend_is_active(backend)) {
40004e2c:	00078663          	beqz	a5,40004e38 <log_backend_disable+0x24>
		backend_filter_set(backend, LOG_LEVEL_NONE);
40004e30:	00000593          	li	a1,0
40004e34:	ef1ff0ef          	jal	ra,40004d24 <backend_filter_set>
	backend->cb->active = false;
40004e38:	00442783          	lw	a5,4(s0)
40004e3c:	000782a3          	sb	zero,5(a5)
}
40004e40:	00c12083          	lw	ra,12(sp)
40004e44:	00812403          	lw	s0,8(sp)
40004e48:	01010113          	addi	sp,sp,16
40004e4c:	00008067          	ret

40004e50 <log_filter_get>:
{
40004e50:	00050713          	mv	a4,a0
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) && runtime) {
40004e54:	02068e63          	beqz	a3,40004e90 <log_filter_get+0x40>
			return LOG_LEVEL_DBG;
40004e58:	00400513          	li	a0,4
		if (source_id < 0) {
40004e5c:	06064063          	bltz	a2,40004ebc <log_filter_get+0x6c>
	return backend->cb->id;
40004e60:	00472703          	lw	a4,4(a4)
		return LOG_FILTER_SLOT_GET(get_dynamic_filter(domain_id, source_id),
40004e64:	00300693          	li	a3,3
40004e68:	400447b7          	lui	a5,0x40044
40004e6c:	00474703          	lbu	a4,4(a4)
40004e70:	00261613          	slli	a2,a2,0x2
40004e74:	72c78793          	addi	a5,a5,1836 # 4004472c <log_dynamic_cbprintf_package>
40004e78:	02d70733          	mul	a4,a4,a3
40004e7c:	00c787b3          	add	a5,a5,a2
40004e80:	0007a503          	lw	a0,0(a5)
40004e84:	00e55533          	srl	a0,a0,a4
40004e88:	00757513          	andi	a0,a0,7
40004e8c:	00008067          	ret
40004e90:	40032737          	lui	a4,0x40032
40004e94:	400327b7          	lui	a5,0x40032
40004e98:	3f470713          	addi	a4,a4,1012 # 400323f4 <log_const_cbprintf_package>
40004e9c:	50c78793          	addi	a5,a5,1292 # 4003250c <shell_uart_backend>
40004ea0:	40e787b3          	sub	a5,a5,a4
40004ea4:	0037d793          	srli	a5,a5,0x3
			return LOG_LEVEL_NONE;
40004ea8:	00000513          	li	a0,0
		if (source_id < log_src_cnt_get(domain_id)) {
40004eac:	00f67863          	bgeu	a2,a5,40004ebc <log_filter_get+0x6c>
			return TYPE_SECTION_START(log_const)[source_id].level;
40004eb0:	00361613          	slli	a2,a2,0x3
40004eb4:	00c70733          	add	a4,a4,a2
40004eb8:	00474503          	lbu	a0,4(a4)
}
40004ebc:	00008067          	ret

40004ec0 <z_cbprintf_cpy>:
	if ((desc->size - desc->off) < len) {
40004ec0:	00862703          	lw	a4,8(a2)
40004ec4:	00462783          	lw	a5,4(a2)
40004ec8:	40e787b3          	sub	a5,a5,a4
40004ecc:	04b7ea63          	bltu	a5,a1,40004f20 <z_cbprintf_cpy+0x60>
{
40004ed0:	ff010113          	addi	sp,sp,-16
40004ed4:	00812423          	sw	s0,8(sp)
40004ed8:	00912223          	sw	s1,4(sp)
40004edc:	00112623          	sw	ra,12(sp)
	memcpy(&((uint8_t *)desc->buf)[desc->off], buf, len);
40004ee0:	00062783          	lw	a5,0(a2)
40004ee4:	00058413          	mv	s0,a1
40004ee8:	00060493          	mv	s1,a2
40004eec:	00058613          	mv	a2,a1
40004ef0:	00050593          	mv	a1,a0
40004ef4:	00e78533          	add	a0,a5,a4
40004ef8:	601070ef          	jal	ra,4000ccf8 <memcpy>
	desc->off += len;
40004efc:	0084a783          	lw	a5,8(s1)
	return len;
40004f00:	00040513          	mv	a0,s0
	desc->off += len;
40004f04:	008787b3          	add	a5,a5,s0
40004f08:	00f4a423          	sw	a5,8(s1)
}
40004f0c:	00c12083          	lw	ra,12(sp)
40004f10:	00812403          	lw	s0,8(sp)
40004f14:	00412483          	lw	s1,4(sp)
40004f18:	01010113          	addi	sp,sp,16
40004f1c:	00008067          	ret
		return -ENOSPC;
40004f20:	fe400513          	li	a0,-28
}
40004f24:	00008067          	ret

40004f28 <z_log_msg_finalize>:
	 (IS_ENABLED(CONFIG_LOG_FRONTEND_ONLY) || log_backend_count_get() == 0))

void z_log_msg_finalize(struct log_msg *msg, const void *source,
			 const struct log_msg_desc desc, const void *data)
{
	if (!msg) {
40004f28:	00051463          	bnez	a0,40004f30 <z_log_msg_finalize+0x8>
		z_log_dropped(false);
40004f2c:	de0ff06f          	j	4000450c <z_log_dropped>
{
40004f30:	ff010113          	addi	sp,sp,-16
40004f34:	00812423          	sw	s0,8(sp)
40004f38:	00912223          	sw	s1,4(sp)
40004f3c:	01212023          	sw	s2,0(sp)
40004f40:	00112623          	sw	ra,12(sp)
40004f44:	00058913          	mv	s2,a1
40004f48:	00050413          	mv	s0,a0
40004f4c:	00060493          	mv	s1,a2
40004f50:	00068593          	mv	a1,a3

		return;
	}

	if (data) {
40004f54:	00068e63          	beqz	a3,40004f70 <z_log_msg_finalize+0x48>
		uint8_t *d = msg->data + desc.package_len;
40004f58:	00965793          	srli	a5,a2,0x9
40004f5c:	01050513          	addi	a0,a0,16
40004f60:	7ff7f793          	andi	a5,a5,2047

		memcpy(d, data, desc.data_len);
40004f64:	01465613          	srli	a2,a2,0x14
40004f68:	00f50533          	add	a0,a0,a5
40004f6c:	58d070ef          	jal	ra,4000ccf8 <memcpy>
	}

	msg->hdr.desc = desc;
40004f70:	00942023          	sw	s1,0(s0)
	msg->hdr.source = source;
40004f74:	01242223          	sw	s2,4(s0)
	z_log_msg_commit(msg);
40004f78:	00040513          	mv	a0,s0
}
40004f7c:	00812403          	lw	s0,8(sp)
40004f80:	00c12083          	lw	ra,12(sp)
40004f84:	00412483          	lw	s1,4(sp)
40004f88:	00012903          	lw	s2,0(sp)
40004f8c:	01010113          	addi	sp,sp,16
	z_log_msg_commit(msg);
40004f90:	ab1ff06f          	j	40004a40 <z_log_msg_commit>

40004f94 <z_impl_z_log_msg_static_create>:

void z_impl_z_log_msg_static_create(const void *source,
			      const struct log_msg_desc desc,
			      uint8_t *package, const void *data)
{
40004f94:	fb010113          	addi	sp,sp,-80
40004f98:	04812423          	sw	s0,72(sp)
40004f9c:	04912223          	sw	s1,68(sp)
40004fa0:	05212023          	sw	s2,64(sp)
40004fa4:	03312e23          	sw	s3,60(sp)
40004fa8:	03412c23          	sw	s4,56(sp)
40004fac:	03512a23          	sw	s5,52(sp)
40004fb0:	04112623          	sw	ra,76(sp)
40004fb4:	03612823          	sw	s6,48(sp)
40004fb8:	03712623          	sw	s7,44(sp)
40004fbc:	03812423          	sw	s8,40(sp)
40004fc0:	05010413          	addi	s0,sp,80
40004fc4:	0095d993          	srli	s3,a1,0x9
40004fc8:	7ff9f993          	andi	s3,s3,2047
40004fcc:	00050a13          	mv	s4,a0
40004fd0:	00058913          	mv	s2,a1
40004fd4:	00068a93          	mv	s5,a3

	if (!BACKENDS_IN_USE()) {
		return;
	}

	struct log_msg_desc out_desc = desc;
40004fd8:	0145d493          	srli	s1,a1,0x14
	int inlen = desc.package_len;
	struct log_msg *msg;

	if (inlen > 0) {
40004fdc:	18098863          	beqz	s3,4000516c <z_impl_z_log_msg_static_create+0x1d8>
40004fe0:	00060b13          	mv	s6,a2
	return cbprintf_package_convert(in_packaged, in_len,
40004fe4:	fc440693          	addi	a3,s0,-60
	struct z_cbprintf_buf_desc buf_desc = {
40004fe8:	fc042223          	sw	zero,-60(s0)
40004fec:	fc042423          	sw	zero,-56(s0)
40004ff0:	fc042623          	sw	zero,-52(s0)
	return cbprintf_package_convert(in_packaged, in_len,
40004ff4:	00400813          	li	a6,4
40004ff8:	fbc40793          	addi	a5,s0,-68
40004ffc:	00a00713          	li	a4,10
40005000:	00000613          	li	a2,0
40005004:	00098593          	mv	a1,s3
40005008:	000b0513          	mv	a0,s6
4000500c:	d14fc0ef          	jal	ra,40001520 <cbprintf_package_convert>

		len = cbprintf_package_copy(package, inlen,
					    NULL, 0, flags,
					    strl, ARRAY_SIZE(strl));

		if (len > Z_LOG_MSG_MAX_PACKAGE) {
40005010:	7ff00693          	li	a3,2047
		len = cbprintf_package_copy(package, inlen,
40005014:	00098b93          	mv	s7,s3
40005018:	00050c13          	mv	s8,a0
		if (len > Z_LOG_MSG_MAX_PACKAGE) {
4000501c:	0ca6f063          	bgeu	a3,a0,400050dc <z_impl_z_log_msg_static_create+0x148>
			struct cbprintf_package_hdr_ext *pkg =
				(struct cbprintf_package_hdr_ext *)package;

			LOG_WRN("Message (\"%s\") dropped because it exceeds size limitation (%u)",
40005020:	40044537          	lui	a0,0x40044
40005024:	73c52783          	lw	a5,1852(a0) # 4004473c <log_dynamic_log>
40005028:	0067f793          	andi	a5,a5,6
4000502c:	06078e63          	beqz	a5,400050a8 <z_impl_z_log_msg_static_create+0x114>
40005030:	005b4783          	lbu	a5,5(s6)
40005034:	004b4703          	lbu	a4,4(s6)
40005038:	00010493          	mv	s1,sp
4000503c:	00879793          	slli	a5,a5,0x8
40005040:	00e7e7b3          	or	a5,a5,a4
40005044:	006b4703          	lbu	a4,6(s6)
40005048:	fd010113          	addi	sp,sp,-48
4000504c:	00010613          	mv	a2,sp
40005050:	01071713          	slli	a4,a4,0x10
40005054:	00f76733          	or	a4,a4,a5
40005058:	007b4783          	lbu	a5,7(s6)
4000505c:	01879793          	slli	a5,a5,0x18
40005060:	00e7e7b3          	or	a5,a5,a4
40005064:	00f62c23          	sw	a5,24(a2)
40005068:	20000793          	li	a5,512
4000506c:	02f61023          	sh	a5,32(a2)
40005070:	40033737          	lui	a4,0x40033
40005074:	010007b7          	lui	a5,0x1000
40005078:	a8070713          	addi	a4,a4,-1408 # 40032a80 <mpsc_config+0x24>
4000507c:	00478793          	addi	a5,a5,4 # 1000004 <__rom_region_size+0xfc7048>
40005080:	00e62a23          	sw	a4,20(a2)
40005084:	00d62e23          	sw	a3,28(a2)
40005088:	00f62823          	sw	a5,16(a2)
4000508c:	000025b7          	lui	a1,0x2
	z_impl_z_log_msg_static_create(source, desc, package, data);
40005090:	00000693          	li	a3,0
40005094:	01060613          	addi	a2,a2,16
40005098:	48058593          	addi	a1,a1,1152 # 2480 <CONFIG_SRAM_SIZE+0x480>
4000509c:	73c50513          	addi	a0,a0,1852
400050a0:	ef5ff0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
400050a4:	00048113          	mv	sp,s1
	} else {
		msg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));
	}

	z_log_msg_finalize(msg, source, out_desc, data);
}
400050a8:	fb040113          	addi	sp,s0,-80
400050ac:	04c12083          	lw	ra,76(sp)
400050b0:	04812403          	lw	s0,72(sp)
400050b4:	04412483          	lw	s1,68(sp)
400050b8:	04012903          	lw	s2,64(sp)
400050bc:	03c12983          	lw	s3,60(sp)
400050c0:	03812a03          	lw	s4,56(sp)
400050c4:	03412a83          	lw	s5,52(sp)
400050c8:	03012b03          	lw	s6,48(sp)
400050cc:	02c12b83          	lw	s7,44(sp)
400050d0:	02812c03          	lw	s8,40(sp)
400050d4:	05010113          	addi	sp,sp,80
400050d8:	00008067          	ret
	return Z_LOG_MSG_ALIGNED_WLEN(desc.package_len, desc.data_len);
400050dc:	01748493          	addi	s1,s1,23
400050e0:	00a484b3          	add	s1,s1,a0
		msg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));
400050e4:	fff007b7          	lui	a5,0xfff00
		out_desc.package_len = len;
400050e8:	7ff57993          	andi	s3,a0,2047
400050ec:	ff84f493          	andi	s1,s1,-8
		msg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));
400050f0:	1ff78793          	addi	a5,a5,511 # fff001ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfff00200>
400050f4:	00999713          	slli	a4,s3,0x9
400050f8:	00f977b3          	and	a5,s2,a5
400050fc:	0024d513          	srli	a0,s1,0x2
40005100:	00e7e933          	or	s2,a5,a4
40005104:	d5cff0ef          	jal	ra,40004660 <z_log_msg_alloc>
40005108:	00050493          	mv	s1,a0
		if (msg) {
4000510c:	02050c63          	beqz	a0,40005144 <z_impl_z_log_msg_static_create+0x1b0>
						    msg->data, out_desc.package_len,
40005110:	01050793          	addi	a5,a0,16
40005114:	40005637          	lui	a2,0x40005
	struct z_cbprintf_buf_desc buf_desc = {
40005118:	fcf42223          	sw	a5,-60(s0)
4000511c:	fd842423          	sw	s8,-56(s0)
40005120:	fc042623          	sw	zero,-52(s0)
	return cbprintf_package_convert(in_packaged, in_len,
40005124:	00400813          	li	a6,4
40005128:	fbc40793          	addi	a5,s0,-68
4000512c:	00a00713          	li	a4,10
40005130:	fc440693          	addi	a3,s0,-60
40005134:	ec060613          	addi	a2,a2,-320 # 40004ec0 <z_cbprintf_cpy>
40005138:	000b8593          	mv	a1,s7
4000513c:	000b0513          	mv	a0,s6
40005140:	be0fc0ef          	jal	ra,40001520 <cbprintf_package_convert>
	z_log_msg_finalize(msg, source, out_desc, data);
40005144:	fff007b7          	lui	a5,0xfff00
40005148:	1ff78793          	addi	a5,a5,511 # fff001ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfff00200>
4000514c:	00999993          	slli	s3,s3,0x9
40005150:	00f97633          	and	a2,s2,a5
40005154:	000a8693          	mv	a3,s5
40005158:	01366633          	or	a2,a2,s3
4000515c:	000a0593          	mv	a1,s4
40005160:	00048513          	mv	a0,s1
40005164:	dc5ff0ef          	jal	ra,40004f28 <z_log_msg_finalize>
40005168:	f41ff06f          	j	400050a8 <z_impl_z_log_msg_static_create+0x114>
4000516c:	01748493          	addi	s1,s1,23
40005170:	ff84f493          	andi	s1,s1,-8
		msg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));
40005174:	0024d513          	srli	a0,s1,0x2
40005178:	ce8ff0ef          	jal	ra,40004660 <z_log_msg_alloc>
4000517c:	00050493          	mv	s1,a0
40005180:	fc5ff06f          	j	40005144 <z_impl_z_log_msg_static_create+0x1b0>

40005184 <z_impl_z_log_msg_runtime_vcreate>:
#endif

void z_impl_z_log_msg_runtime_vcreate(uint8_t domain_id, const void *source,
				uint8_t level, const void *data, size_t dlen,
				uint32_t package_flags, const char *fmt, va_list ap)
{
40005184:	fc010113          	addi	sp,sp,-64
40005188:	02812c23          	sw	s0,56(sp)
4000518c:	02912a23          	sw	s1,52(sp)
40005190:	03212823          	sw	s2,48(sp)
40005194:	03312623          	sw	s3,44(sp)
40005198:	03412423          	sw	s4,40(sp)
4000519c:	03512223          	sw	s5,36(sp)
400051a0:	03612023          	sw	s6,32(sp)
400051a4:	01712e23          	sw	s7,28(sp)
400051a8:	02112e23          	sw	ra,60(sp)
400051ac:	00058a13          	mv	s4,a1
400051b0:	00050b93          	mv	s7,a0
400051b4:	00060413          	mv	s0,a2
400051b8:	00068a93          	mv	s5,a3
400051bc:	00070493          	mv	s1,a4
400051c0:	00078993          	mv	s3,a5
400051c4:	00080913          	mv	s2,a6
400051c8:	00088b13          	mv	s6,a7
400051cc:	00000593          	li	a1,0
	int plen;

	if (fmt) {
400051d0:	02080063          	beqz	a6,400051f0 <z_impl_z_log_msg_runtime_vcreate+0x6c>
		va_list ap2;

		va_copy(ap2, ap);
		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
400051d4:	01000593          	li	a1,16
400051d8:	00088713          	mv	a4,a7
400051dc:	00080693          	mv	a3,a6
400051e0:	00078613          	mv	a2,a5
400051e4:	00000513          	li	a0,0
400051e8:	c09fb0ef          	jal	ra,40000df0 <cbvprintf_package>
400051ec:	00050593          	mv	a1,a0
	}

	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
	struct log_msg *msg;
	uint8_t *pkg;
	struct log_msg_desc desc =
400051f0:	00747413          	andi	s0,s0,7
400051f4:	007bfb93          	andi	s7,s7,7
400051f8:	00100737          	lui	a4,0x100
400051fc:	00959793          	slli	a5,a1,0x9
40005200:	e0070713          	addi	a4,a4,-512 # ffe00 <__rom_region_size+0xc6e44>
40005204:	00641413          	slli	s0,s0,0x6
40005208:	003b9b93          	slli	s7,s7,0x3
4000520c:	00e7f7b3          	and	a5,a5,a4
40005210:	01746433          	or	s0,s0,s7
40005214:	00f46433          	or	s0,s0,a5
40005218:	01449793          	slli	a5,s1,0x14
	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
4000521c:	01748493          	addi	s1,s1,23
40005220:	00b484b3          	add	s1,s1,a1
40005224:	ff84f493          	andi	s1,s1,-8
		Z_LOG_MSG_DESC_INITIALIZER(domain_id, level, plen, dlen);

	if (IS_ENABLED(CONFIG_LOG_MODE_DEFERRED) && BACKENDS_IN_USE()) {
		msg = z_log_msg_alloc(msg_wlen);
40005228:	0024d513          	srli	a0,s1,0x2
	struct log_msg_desc desc =
4000522c:	00f46433          	or	s0,s0,a5
	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
40005230:	00b12623          	sw	a1,12(sp)
		msg = z_log_msg_alloc(msg_wlen);
40005234:	c2cff0ef          	jal	ra,40004660 <z_log_msg_alloc>
40005238:	00050493          	mv	s1,a0
		if (IS_ENABLED(CONFIG_LOG_FRONTEND) && msg == NULL) {
			pkg = alloca(plen);
		} else {
			pkg = msg ? msg->data : NULL;
4000523c:	02050063          	beqz	a0,4000525c <z_impl_z_log_msg_runtime_vcreate+0xd8>
	} else {
		msg = alloca(msg_wlen * sizeof(int));
		pkg = msg->data;
	}

	if (pkg && fmt) {
40005240:	00090e63          	beqz	s2,4000525c <z_impl_z_log_msg_runtime_vcreate+0xd8>
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
40005244:	00c12583          	lw	a1,12(sp)
40005248:	000b0713          	mv	a4,s6
4000524c:	00090693          	mv	a3,s2
40005250:	00098613          	mv	a2,s3
40005254:	01050513          	addi	a0,a0,16
40005258:	b99fb0ef          	jal	ra,40000df0 <cbvprintf_package>
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_msg(source, desc, pkg, data);
	}

	if (BACKENDS_IN_USE()) {
		z_log_msg_finalize(msg, source, desc, data);
4000525c:	00040613          	mv	a2,s0
	}
}
40005260:	03812403          	lw	s0,56(sp)
40005264:	03c12083          	lw	ra,60(sp)
40005268:	03012903          	lw	s2,48(sp)
4000526c:	02c12983          	lw	s3,44(sp)
40005270:	02012b03          	lw	s6,32(sp)
40005274:	01c12b83          	lw	s7,28(sp)
		z_log_msg_finalize(msg, source, desc, data);
40005278:	000a8693          	mv	a3,s5
4000527c:	000a0593          	mv	a1,s4
}
40005280:	02412a83          	lw	s5,36(sp)
40005284:	02812a03          	lw	s4,40(sp)
		z_log_msg_finalize(msg, source, desc, data);
40005288:	00048513          	mv	a0,s1
}
4000528c:	03412483          	lw	s1,52(sp)
40005290:	04010113          	addi	sp,sp,64
		z_log_msg_finalize(msg, source, desc, data);
40005294:	c95ff06f          	j	40004f28 <z_log_msg_finalize>

40005298 <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, uint8_t *buf, size_t len,
			 void *ctx)
{
40005298:	fe010113          	addi	sp,sp,-32
4000529c:	00812c23          	sw	s0,24(sp)
400052a0:	00912a23          	sw	s1,20(sp)
400052a4:	01212823          	sw	s2,16(sp)
400052a8:	01312623          	sw	s3,12(sp)
400052ac:	00112e23          	sw	ra,28(sp)
400052b0:	00050913          	mv	s2,a0
400052b4:	00058493          	mv	s1,a1
400052b8:	00060413          	mv	s0,a2
400052bc:	00068993          	mv	s3,a3
	int processed;

	do {
		processed = outf(buf, len, ctx);
400052c0:	00040593          	mv	a1,s0
400052c4:	00048513          	mv	a0,s1
400052c8:	00098613          	mv	a2,s3
400052cc:	000900e7          	jalr	s2
		len -= processed;
400052d0:	40a40433          	sub	s0,s0,a0
		buf += processed;
400052d4:	00a484b3          	add	s1,s1,a0
	} while (len != 0);
400052d8:	fe0414e3          	bnez	s0,400052c0 <buffer_write+0x28>
}
400052dc:	01c12083          	lw	ra,28(sp)
400052e0:	01812403          	lw	s0,24(sp)
400052e4:	01412483          	lw	s1,20(sp)
400052e8:	01012903          	lw	s2,16(sp)
400052ec:	00c12983          	lw	s3,12(sp)
400052f0:	02010113          	addi	sp,sp,32
400052f4:	00008067          	ret

400052f8 <cbvprintf>:
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
400052f8:	00000713          	li	a4,0
400052fc:	fa0fd06f          	j	40002a9c <z_cbvprintf_impl>

40005300 <print_formatted>:
{
40005300:	fc010113          	addi	sp,sp,-64
40005304:	02c12423          	sw	a2,40(sp)
	length = cbvprintf(out_func, (void *)output, fmt, args);
40005308:	00058613          	mv	a2,a1
4000530c:	00050593          	mv	a1,a0
40005310:	40005537          	lui	a0,0x40005
{
40005314:	02d12623          	sw	a3,44(sp)
	length = cbvprintf(out_func, (void *)output, fmt, args);
40005318:	3b450513          	addi	a0,a0,948 # 400053b4 <out_func>
	va_start(args, fmt);
4000531c:	02810693          	addi	a3,sp,40
{
40005320:	00112e23          	sw	ra,28(sp)
40005324:	02e12823          	sw	a4,48(sp)
40005328:	02f12a23          	sw	a5,52(sp)
4000532c:	03012c23          	sw	a6,56(sp)
40005330:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
40005334:	00d12623          	sw	a3,12(sp)
	length = cbvprintf(out_func, (void *)output, fmt, args);
40005338:	fc1ff0ef          	jal	ra,400052f8 <cbvprintf>
}
4000533c:	01c12083          	lw	ra,28(sp)
40005340:	04010113          	addi	sp,sp,64
40005344:	00008067          	ret

40005348 <newline_print>:
	if (IS_ENABLED(CONFIG_LOG_BACKEND_NET) &&
	    flags & LOG_OUTPUT_FLAG_FORMAT_SYSLOG) {
		return;
	}

	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
40005348:	0105f793          	andi	a5,a1,16
4000534c:	02079263          	bnez	a5,40005370 <newline_print+0x28>
		return;
	}

	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
40005350:	0205f593          	andi	a1,a1,32
40005354:	00058863          	beqz	a1,40005364 <newline_print+0x1c>
		print_formatted(ctx, "\n");
40005358:	400335b7          	lui	a1,0x40033
4000535c:	bf458593          	addi	a1,a1,-1036 # 40032bf4 <severity+0x88>
	} else {
		print_formatted(ctx, "\r\n");
40005360:	fa1ff06f          	j	40005300 <print_formatted>
40005364:	400335b7          	lui	a1,0x40033
40005368:	ac058593          	addi	a1,a1,-1344 # 40032ac0 <mpsc_config+0x64>
4000536c:	ff5ff06f          	j	40005360 <newline_print+0x18>
	}
}
40005370:	00008067          	ret

40005374 <log_output_flush>:
{
40005374:	ff010113          	addi	sp,sp,-16
40005378:	00812423          	sw	s0,8(sp)
4000537c:	00112623          	sw	ra,12(sp)
		     output->control_block->offset,
40005380:	00452783          	lw	a5,4(a0)
{
40005384:	00050413          	mv	s0,a0
	buffer_write(output->func, output->buf,
40005388:	00852583          	lw	a1,8(a0)
4000538c:	0047a683          	lw	a3,4(a5)
40005390:	0007a603          	lw	a2,0(a5)
40005394:	00052503          	lw	a0,0(a0)
40005398:	f01ff0ef          	jal	ra,40005298 <buffer_write>
	output->control_block->offset = 0;
4000539c:	00442783          	lw	a5,4(s0)
400053a0:	0007a023          	sw	zero,0(a5)
}
400053a4:	00c12083          	lw	ra,12(sp)
400053a8:	00812403          	lw	s0,8(sp)
400053ac:	01010113          	addi	sp,sp,16
400053b0:	00008067          	ret

400053b4 <out_func>:
{
400053b4:	ff010113          	addi	sp,sp,-16
400053b8:	00812423          	sw	s0,8(sp)
400053bc:	00912223          	sw	s1,4(sp)
400053c0:	00112623          	sw	ra,12(sp)
	if (out_ctx->control_block->offset == out_ctx->size) {
400053c4:	0045a783          	lw	a5,4(a1)
{
400053c8:	00050493          	mv	s1,a0
400053cc:	00058413          	mv	s0,a1
	if (out_ctx->control_block->offset == out_ctx->size) {
400053d0:	0007a703          	lw	a4,0(a5)
400053d4:	00c5a783          	lw	a5,12(a1)
400053d8:	00f71663          	bne	a4,a5,400053e4 <out_func+0x30>
		log_output_flush(out_ctx);
400053dc:	00058513          	mv	a0,a1
400053e0:	f95ff0ef          	jal	ra,40005374 <log_output_flush>
	idx = atomic_inc(&out_ctx->control_block->offset);
400053e4:	00442503          	lw	a0,4(s0)
	return z_impl_atomic_add(target, value);
400053e8:	00100593          	li	a1,1
400053ec:	65c2c0ef          	jal	ra,40031a48 <z_impl_atomic_add>
	out_ctx->buf[idx] = (uint8_t)c;
400053f0:	00842783          	lw	a5,8(s0)
400053f4:	00a787b3          	add	a5,a5,a0
400053f8:	00978023          	sb	s1,0(a5)
}
400053fc:	00c12083          	lw	ra,12(sp)
40005400:	00812403          	lw	s0,8(sp)
40005404:	00412483          	lw	s1,4(sp)
40005408:	00000513          	li	a0,0
4000540c:	01010113          	addi	sp,sp,16
40005410:	00008067          	ret

40005414 <cr_out_func>:
{
40005414:	ff010113          	addi	sp,sp,-16
40005418:	00812423          	sw	s0,8(sp)
4000541c:	00912223          	sw	s1,4(sp)
40005420:	00112623          	sw	ra,12(sp)
	if (c == '\n') {
40005424:	00a00793          	li	a5,10
{
40005428:	00050413          	mv	s0,a0
4000542c:	00058493          	mv	s1,a1
	if (c == '\n') {
40005430:	00f51663          	bne	a0,a5,4000543c <cr_out_func+0x28>
		out_func((int)'\r', ctx);
40005434:	00d00513          	li	a0,13
40005438:	f7dff0ef          	jal	ra,400053b4 <out_func>
	out_func(c, ctx);
4000543c:	00048593          	mv	a1,s1
40005440:	00040513          	mv	a0,s0
40005444:	f71ff0ef          	jal	ra,400053b4 <out_func>
}
40005448:	00c12083          	lw	ra,12(sp)
4000544c:	00812403          	lw	s0,8(sp)
40005450:	00412483          	lw	s1,4(sp)
40005454:	00000513          	li	a0,0
40005458:	01010113          	addi	sp,sp,16
4000545c:	00008067          	ret

40005460 <log_output_process>:
			uint8_t level,
			const uint8_t *package,
			const uint8_t *data,
			size_t data_len,
			uint32_t flags)
{
40005460:	fb010113          	addi	sp,sp,-80
40005464:	05212023          	sw	s2,64(sp)
40005468:	03312e23          	sw	s3,60(sp)
4000546c:	03412c23          	sw	s4,56(sp)
40005470:	03512a23          	sw	s5,52(sp)
40005474:	03612823          	sw	s6,48(sp)
40005478:	03812423          	sw	s8,40(sp)
4000547c:	04112623          	sw	ra,76(sp)
40005480:	04812423          	sw	s0,72(sp)
40005484:	04912223          	sw	s1,68(sp)
40005488:	03712623          	sw	s7,44(sp)
4000548c:	03912223          	sw	s9,36(sp)
40005490:	03a12023          	sw	s10,32(sp)
40005494:	01b12e23          	sw	s11,28(sp)
40005498:	00a12623          	sw	a0,12(sp)
4000549c:	05012983          	lw	s3,80(sp)
400054a0:	00068c13          	mv	s8,a3
400054a4:	00070a93          	mv	s5,a4
400054a8:	00078b13          	mv	s6,a5
400054ac:	00080a13          	mv	s4,a6
400054b0:	00088913          	mv	s2,a7
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
	uint32_t prefix_offset;
	cbprintf_cb cb;

	if (!raw_string) {
400054b4:	18070663          	beqz	a4,40005640 <log_output_process+0x1e0>
400054b8:	00060c93          	mv	s9,a2
		prefix_offset = prefix_print(output, flags, 0, timestamp, domain, source, level);
400054bc:	00058493          	mv	s1,a1
	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
400054c0:	db8ff0ef          	jal	ra,40004a78 <z_log_get_tag>
	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
400054c4:	0029fd93          	andi	s11,s3,2
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
400054c8:	0019fd13          	andi	s10,s3,1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
400054cc:	0089f413          	andi	s0,s3,8
	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
400054d0:	00050613          	mv	a2,a0
	uint32_t length = 0U;
400054d4:	00000b93          	li	s7,0
	if (tag) {
400054d8:	00050c63          	beqz	a0,400054f0 <log_output_process+0x90>
		length += print_formatted(output, "%s ", tag);
400054dc:	00c12503          	lw	a0,12(sp)
400054e0:	400335b7          	lui	a1,0x40033
400054e4:	acc58593          	addi	a1,a1,-1332 # 40032acc <mpsc_config+0x70>
400054e8:	e19ff0ef          	jal	ra,40005300 <print_formatted>
400054ec:	00050b93          	mv	s7,a0
	if (stamp) {
400054f0:	020d8263          	beqz	s11,40005514 <log_output_process+0xb4>
		IS_ENABLED(CONFIG_LOG_OUTPUT_FORMAT_LINUX_TIMESTAMP) |
400054f4:	0449f793          	andi	a5,s3,68
	if (!format) {
400054f8:	0c079e63          	bnez	a5,400055d4 <log_output_process+0x174>
		length = print_formatted(output, "[%08lu] ", timestamp);
400054fc:	00c12503          	lw	a0,12(sp)
40005500:	400335b7          	lui	a1,0x40033
40005504:	00048613          	mv	a2,s1
40005508:	ad058593          	addi	a1,a1,-1328 # 40032ad0 <mpsc_config+0x74>
4000550c:	df5ff0ef          	jal	ra,40005300 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
40005510:	00ab8bb3          	add	s7,s7,a0
	if (color) {
40005514:	020d0a63          	beqz	s10,40005548 <log_output_process+0xe8>
		const char *log_color = start && (colors[level] != NULL) ?
40005518:	400337b7          	lui	a5,0x40033
4000551c:	002a9713          	slli	a4,s5,0x2
40005520:	b5878793          	addi	a5,a5,-1192 # 40032b58 <colors>
40005524:	00e787b3          	add	a5,a5,a4
40005528:	0007a603          	lw	a2,0(a5)
4000552c:	00061663          	bnez	a2,40005538 <log_output_process+0xd8>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
40005530:	40033637          	lui	a2,0x40033
40005534:	ac460613          	addi	a2,a2,-1340 # 40032ac4 <mpsc_config+0x68>
		print_formatted(output, "%s", log_color);
40005538:	00c12503          	lw	a0,12(sp)
4000553c:	400335b7          	lui	a1,0x40033
40005540:	af858593          	addi	a1,a1,-1288 # 40032af8 <mpsc_config+0x9c>
40005544:	dbdff0ef          	jal	ra,40005300 <print_formatted>
	int total = 0;
40005548:	00000493          	li	s1,0
	if (level_on) {
4000554c:	02040663          	beqz	s0,40005578 <log_output_process+0x118>
		total += print_formatted(output, "<%s> ", severity[level]);
40005550:	400337b7          	lui	a5,0x40033
40005554:	002a9713          	slli	a4,s5,0x2
40005558:	b6c78793          	addi	a5,a5,-1172 # 40032b6c <severity>
4000555c:	00e787b3          	add	a5,a5,a4
40005560:	0007a603          	lw	a2,0(a5)
40005564:	00c12503          	lw	a0,12(sp)
40005568:	400335b7          	lui	a1,0x40033
4000556c:	afc58593          	addi	a1,a1,-1284 # 40032afc <mpsc_config+0xa0>
40005570:	d91ff0ef          	jal	ra,40005300 <print_formatted>
40005574:	00050493          	mv	s1,a0
	if (domain) {
40005578:	000c8e63          	beqz	s9,40005594 <log_output_process+0x134>
		total += print_formatted(output, "%s/", domain);
4000557c:	00c12503          	lw	a0,12(sp)
40005580:	400335b7          	lui	a1,0x40033
40005584:	000c8613          	mv	a2,s9
40005588:	b0458593          	addi	a1,a1,-1276 # 40032b04 <mpsc_config+0xa8>
4000558c:	d75ff0ef          	jal	ra,40005300 <print_formatted>
40005590:	00a484b3          	add	s1,s1,a0
	if (source) {
40005594:	000c0e63          	beqz	s8,400055b0 <log_output_process+0x150>
		total += print_formatted(output,
40005598:	00c12503          	lw	a0,12(sp)
4000559c:	400335b7          	lui	a1,0x40033
400055a0:	000c0613          	mv	a2,s8
400055a4:	b0858593          	addi	a1,a1,-1272 # 40032b08 <mpsc_config+0xac>
400055a8:	d59ff0ef          	jal	ra,40005300 <print_formatted>
400055ac:	00a484b3          	add	s1,s1,a0
	length += ids_print(output, level_on, func_on, domain, source, level);
400055b0:	017484b3          	add	s1,s1,s7
		 * appending <CR> to the new line character).
		 */
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
	}

	if (package) {
400055b4:	0a0b1a63          	bnez	s6,40005668 <log_output_process+0x208>

		(void)err;
		__ASSERT_NO_MSG(err >= 0);
	}

	if (data_len) {
400055b8:	0c091863          	bnez	s2,40005688 <log_output_process+0x228>
	if (color) {
400055bc:	0019f793          	andi	a5,s3,1
400055c0:	22079c63          	bnez	a5,400057f8 <log_output_process+0x398>
	newline_print(output, flags);
400055c4:	00c12503          	lw	a0,12(sp)
400055c8:	00098593          	mv	a1,s3
400055cc:	d7dff0ef          	jal	ra,40005348 <newline_print>
}
400055d0:	1e80006f          	j	400057b8 <log_output_process+0x358>
	} else if (freq != 0U) {
400055d4:	400397b7          	lui	a5,0x40039
400055d8:	ff47a783          	lw	a5,-12(a5) # 40038ff4 <freq>
		length = 0;
400055dc:	00000513          	li	a0,0
	} else if (freq != 0U) {
400055e0:	f20788e3          	beqz	a5,40005510 <log_output_process+0xb0>
		timestamp /= timestamp_div;
400055e4:	40039737          	lui	a4,0x40039
400055e8:	ff072703          	lw	a4,-16(a4) # 40038ff0 <timestamp_div>
400055ec:	00001637          	lui	a2,0x1
400055f0:	e1060613          	addi	a2,a2,-496 # e10 <CONFIG_ISR_STACK_SIZE+0x610>
400055f4:	02e4d4b3          	divu	s1,s1,a4
		ms = (remainder * 1000U) / freq;
400055f8:	3e800713          	li	a4,1000
				length = print_formatted(output,
400055fc:	03c00693          	li	a3,60
		total_seconds = timestamp / freq;
40005600:	02f4d5b3          	divu	a1,s1,a5
		remainder = timestamp % freq;
40005604:	02f4f4b3          	remu	s1,s1,a5
		ms = (remainder * 1000U) / freq;
40005608:	02e484b3          	mul	s1,s1,a4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
4000560c:	02f4f833          	remu	a6,s1,a5
40005610:	02c5f533          	remu	a0,a1,a2
40005614:	02e80833          	mul	a6,a6,a4
				length = print_formatted(output,
40005618:	02c5d633          	divu	a2,a1,a2
4000561c:	400335b7          	lui	a1,0x40033
40005620:	adc58593          	addi	a1,a1,-1316 # 40032adc <mpsc_config+0x80>
40005624:	02d57733          	remu	a4,a0,a3
40005628:	02f85833          	divu	a6,a6,a5
4000562c:	02d556b3          	divu	a3,a0,a3
40005630:	00c12503          	lw	a0,12(sp)
40005634:	02f4d7b3          	divu	a5,s1,a5
40005638:	cc9ff0ef          	jal	ra,40005300 <print_formatted>
4000563c:	ed5ff06f          	j	40005510 <log_output_process+0xb0>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
40005640:	00100793          	li	a5,1
40005644:	00f69a63          	bne	a3,a5,40005658 <log_output_process+0x1f8>
	if (package) {
40005648:	120b1463          	bnez	s6,40005770 <log_output_process+0x310>
	if (data_len) {
4000564c:	16090663          	beqz	s2,400057b8 <log_output_process+0x358>
		prefix_offset = 0;
40005650:	00000493          	li	s1,0
40005654:	0340006f          	j	40005688 <log_output_process+0x228>
	if (package) {
40005658:	fe0b0ae3          	beqz	s6,4000564c <log_output_process+0x1ec>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
4000565c:	40005537          	lui	a0,0x40005
40005660:	41450513          	addi	a0,a0,1044 # 40005414 <cr_out_func>
40005664:	1140006f          	j	40005778 <log_output_process+0x318>
		cb = out_func;
40005668:	40005537          	lui	a0,0x40005
4000566c:	3b450513          	addi	a0,a0,948 # 400053b4 <out_func>
		return cbpprintf_external(out, cbvprintf_tagged_args,
					  ctx, packaged);
	}
#endif

	return cbpprintf_external(out, cbvprintf, ctx, packaged);
40005670:	00c12603          	lw	a2,12(sp)
40005674:	400055b7          	lui	a1,0x40005
40005678:	000b0693          	mv	a3,s6
4000567c:	2f858593          	addi	a1,a1,760 # 400052f8 <cbvprintf>
40005680:	d31fb0ef          	jal	ra,400013b0 <cbpprintf_external>
	if (data_len) {
40005684:	12090863          	beqz	s2,400057b4 <log_output_process+0x354>
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
40005688:	01000c13          	li	s8,16
		print_formatted(output, " ");
4000568c:	40036bb7          	lui	s7,0x40036
			print_formatted(output, "%02x ", data[i]);
40005690:	40033cb7          	lui	s9,0x40033
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
40005694:	00090b13          	mv	s6,s2
40005698:	012c7463          	bgeu	s8,s2,400056a0 <log_output_process+0x240>
4000569c:	01000b13          	li	s6,16
	newline_print(output, flags);
400056a0:	00c12503          	lw	a0,12(sp)
400056a4:	00098593          	mv	a1,s3
	for (int i = 0; i < prefix_offset; i++) {
400056a8:	00000d13          	li	s10,0
	newline_print(output, flags);
400056ac:	c9dff0ef          	jal	ra,40005348 <newline_print>
	for (int i = 0; i < prefix_offset; i++) {
400056b0:	0c9d4863          	blt	s10,s1,40005780 <log_output_process+0x320>
			print_formatted(output, "%02x ", data[i]);
400056b4:	000a4603          	lbu	a2,0(s4)
400056b8:	00c12503          	lw	a0,12(sp)
400056bc:	b10c8593          	addi	a1,s9,-1264 # 40032b10 <mpsc_config+0xb4>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
400056c0:	00100d13          	li	s10,1
			print_formatted(output, "%02x ", data[i]);
400056c4:	c3dff0ef          	jal	ra,40005300 <print_formatted>
		if (i > 0 && !(i % 8)) {
400056c8:	007d7793          	andi	a5,s10,7
400056cc:	00079863          	bnez	a5,400056dc <log_output_process+0x27c>
			print_formatted(output, " ");
400056d0:	00c12503          	lw	a0,12(sp)
400056d4:	724b8593          	addi	a1,s7,1828 # 40036724 <CSWTCH.15846+0x10c4>
400056d8:	c29ff0ef          	jal	ra,40005300 <print_formatted>
		if (i < length) {
400056dc:	0b6d7c63          	bgeu	s10,s6,40005794 <log_output_process+0x334>
			print_formatted(output, "%02x ", data[i]);
400056e0:	01aa07b3          	add	a5,s4,s10
400056e4:	0007c603          	lbu	a2,0(a5)
400056e8:	00c12503          	lw	a0,12(sp)
400056ec:	b10c8593          	addi	a1,s9,-1264
400056f0:	c11ff0ef          	jal	ra,40005300 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
400056f4:	001d0d13          	addi	s10,s10,1
400056f8:	fd8d18e3          	bne	s10,s8,400056c8 <log_output_process+0x268>
	print_formatted(output, "|");
400056fc:	00c12503          	lw	a0,12(sp)
40005700:	400337b7          	lui	a5,0x40033
40005704:	b1c78593          	addi	a1,a5,-1252 # 40032b1c <mpsc_config+0xc0>
40005708:	bf9ff0ef          	jal	ra,40005300 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
4000570c:	00000413          	li	s0,0
		if (i < length) {
40005710:	00000713          	li	a4,0
			print_formatted(output, "%c",
40005714:	05e00d13          	li	s10,94
40005718:	40034db7          	lui	s11,0x40034
			unsigned char c = (unsigned char)data[i];
4000571c:	00ea0733          	add	a4,s4,a4
40005720:	00074603          	lbu	a2,0(a4)
	return (int)((((unsigned)c) >= ' ') &&
40005724:	fe060713          	addi	a4,a2,-32
			print_formatted(output, "%c",
40005728:	00ed7463          	bgeu	s10,a4,40005730 <log_output_process+0x2d0>
4000572c:	02e00613          	li	a2,46
40005730:	00c12503          	lw	a0,12(sp)
40005734:	e34d8593          	addi	a1,s11,-460 # 40033e34 <_shell_help+0x18>
40005738:	bc9ff0ef          	jal	ra,40005300 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
4000573c:	00140413          	addi	s0,s0,1
40005740:	07840463          	beq	s0,s8,400057a8 <log_output_process+0x348>
		if (i > 0 && !(i % 8)) {
40005744:	00747713          	andi	a4,s0,7
40005748:	00071863          	bnez	a4,40005758 <log_output_process+0x2f8>
			print_formatted(output, " ");
4000574c:	00c12503          	lw	a0,12(sp)
40005750:	724b8593          	addi	a1,s7,1828
40005754:	badff0ef          	jal	ra,40005300 <print_formatted>
		if (i < length) {
40005758:	00040713          	mv	a4,s0
4000575c:	fd6460e3          	bltu	s0,s6,4000571c <log_output_process+0x2bc>
			print_formatted(output, " ");
40005760:	00c12503          	lw	a0,12(sp)
40005764:	724b8593          	addi	a1,s7,1828
40005768:	b99ff0ef          	jal	ra,40005300 <print_formatted>
4000576c:	fd1ff06f          	j	4000573c <log_output_process+0x2dc>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
40005770:	40005537          	lui	a0,0x40005
40005774:	3b450513          	addi	a0,a0,948 # 400053b4 <out_func>
		prefix_offset = 0;
40005778:	00000493          	li	s1,0
4000577c:	ef5ff06f          	j	40005670 <log_output_process+0x210>
		print_formatted(output, " ");
40005780:	00c12503          	lw	a0,12(sp)
40005784:	724b8593          	addi	a1,s7,1828
	for (int i = 0; i < prefix_offset; i++) {
40005788:	001d0d13          	addi	s10,s10,1
		print_formatted(output, " ");
4000578c:	b75ff0ef          	jal	ra,40005300 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
40005790:	f21ff06f          	j	400056b0 <log_output_process+0x250>
			print_formatted(output, "   ");
40005794:	00c12503          	lw	a0,12(sp)
40005798:	400337b7          	lui	a5,0x40033
4000579c:	b1878593          	addi	a1,a5,-1256 # 40032b18 <mpsc_config+0xbc>
400057a0:	b61ff0ef          	jal	ra,40005300 <print_formatted>
400057a4:	f51ff06f          	j	400056f4 <log_output_process+0x294>
		len -= length;
400057a8:	41690933          	sub	s2,s2,s6
		data += length;
400057ac:	016a0a33          	add	s4,s4,s6
	} while (len);
400057b0:	ee0912e3          	bnez	s2,40005694 <log_output_process+0x234>
		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
	}

	if (!raw_string) {
400057b4:	e00a94e3          	bnez	s5,400055bc <log_output_process+0x15c>
		postfix_print(output, flags, level);
	}

	log_output_flush(output);
}
400057b8:	04812403          	lw	s0,72(sp)
	log_output_flush(output);
400057bc:	00c12503          	lw	a0,12(sp)
}
400057c0:	04c12083          	lw	ra,76(sp)
400057c4:	04412483          	lw	s1,68(sp)
400057c8:	04012903          	lw	s2,64(sp)
400057cc:	03c12983          	lw	s3,60(sp)
400057d0:	03812a03          	lw	s4,56(sp)
400057d4:	03412a83          	lw	s5,52(sp)
400057d8:	03012b03          	lw	s6,48(sp)
400057dc:	02c12b83          	lw	s7,44(sp)
400057e0:	02812c03          	lw	s8,40(sp)
400057e4:	02412c83          	lw	s9,36(sp)
400057e8:	02012d03          	lw	s10,32(sp)
400057ec:	01c12d83          	lw	s11,28(sp)
400057f0:	05010113          	addi	sp,sp,80
	log_output_flush(output);
400057f4:	b81ff06f          	j	40005374 <log_output_flush>
		print_formatted(output, "%s", log_color);
400057f8:	00c12503          	lw	a0,12(sp)
400057fc:	40033637          	lui	a2,0x40033
40005800:	400335b7          	lui	a1,0x40033
40005804:	ac460613          	addi	a2,a2,-1340 # 40032ac4 <mpsc_config+0x68>
40005808:	af858593          	addi	a1,a1,-1288 # 40032af8 <mpsc_config+0x9c>
4000580c:	af5ff0ef          	jal	ra,40005300 <print_formatted>
}
40005810:	db5ff06f          	j	400055c4 <log_output_process+0x164>

40005814 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg, uint32_t flags)
{
40005814:	fc010113          	addi	sp,sp,-64
40005818:	02812c23          	sw	s0,56(sp)
4000581c:	02912a23          	sw	s1,52(sp)
40005820:	03312623          	sw	s3,44(sp)
40005824:	02112e23          	sw	ra,60(sp)
40005828:	03212823          	sw	s2,48(sp)
4000582c:	00050493          	mv	s1,a0
	return msg->hdr.desc.level;
40005830:	0005a503          	lw	a0,0(a1)
	return msg->hdr.source;
40005834:	0045a683          	lw	a3,4(a1)
 *
 * @return Timestamp.
 */
static inline log_timestamp_t log_msg_get_timestamp(struct log_msg *msg)
{
	return msg->hdr.timestamp;
40005838:	0085a903          	lw	s2,8(a1)
	return msg->hdr.desc.level;
4000583c:	00655713          	srli	a4,a0,0x6
40005840:	00058413          	mv	s0,a1
40005844:	00060993          	mv	s3,a2
40005848:	00777713          	andi	a4,a4,7
		/* Remote domain is converting source pointer to ID */
		source_id = (int16_t)(uintptr_t)log_msg_get_source(msg);
	} else {
		void *source = (void *)log_msg_get_source(msg);

		if (source != NULL) {
4000584c:	02068e63          	beqz	a3,40005888 <log_output_msg_process+0x74>
	return ((uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_dynamic))/
40005850:	400447b7          	lui	a5,0x40044
40005854:	72c78793          	addi	a5,a5,1836 # 4004472c <log_dynamic_cbprintf_package>
40005858:	40f686b3          	sub	a3,a3,a5
4000585c:	0026d693          	srli	a3,a3,0x2
			source_id = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ?
40005860:	01069593          	slli	a1,a3,0x10
40005864:	4105d593          	srai	a1,a1,0x10
		} else {
			source_id = -1;
		}
	}

	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
40005868:	00000693          	li	a3,0
4000586c:	0005ce63          	bltz	a1,40005888 <log_output_msg_process+0x74>
	return msg->hdr.desc.domain;
40005870:	00355513          	srli	a0,a0,0x3
40005874:	00757513          	andi	a0,a0,7
40005878:	00e12e23          	sw	a4,28(sp)
4000587c:	a5cff0ef          	jal	ra,40004ad8 <log_source_name_get>
40005880:	01c12703          	lw	a4,28(sp)
40005884:	00050693          	mv	a3,a0
 *
 * @return pointer to the package.
 */
static inline uint8_t *log_msg_get_package(struct log_msg *msg, size_t *len)
{
	*len = msg->hdr.desc.package_len;
40005888:	00042883          	lw	a7,0(s0)

	return msg->data;
4000588c:	01040793          	addi	a5,s0,16
	*len = msg->hdr.desc.package_len;
40005890:	0098d593          	srli	a1,a7,0x9
40005894:	7ff5f593          	andi	a1,a1,2047
	*len = msg->hdr.desc.data_len;
40005898:	0148d893          	srli	a7,a7,0x14
	return msg->data + msg->hdr.desc.package_len;
4000589c:	00b78833          	add	a6,a5,a1
	size_t plen, dlen;
	uint8_t *package = log_msg_get_package(msg, &plen);
	uint8_t *data = log_msg_get_data(msg, &dlen);

	log_output_process(output, timestamp, NULL, sname, level,
400058a0:	00059463          	bnez	a1,400058a8 <log_output_msg_process+0x94>
400058a4:	00000793          	li	a5,0
400058a8:	01312023          	sw	s3,0(sp)
400058ac:	00090593          	mv	a1,s2
400058b0:	00048513          	mv	a0,s1
400058b4:	00000613          	li	a2,0
400058b8:	ba9ff0ef          	jal	ra,40005460 <log_output_process>
			   plen > 0 ? package : NULL, data, dlen, flags);
}
400058bc:	03c12083          	lw	ra,60(sp)
400058c0:	03812403          	lw	s0,56(sp)
400058c4:	03412483          	lw	s1,52(sp)
400058c8:	03012903          	lw	s2,48(sp)
400058cc:	02c12983          	lw	s3,44(sp)
400058d0:	04010113          	addi	sp,sp,64
400058d4:	00008067          	ret

400058d8 <log_output_dropped_process>:

void log_output_dropped_process(const struct log_output *output, uint32_t cnt)
{
400058d8:	fe010113          	addi	sp,sp,-32
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
400058dc:	000027b7          	lui	a5,0x2
{
400058e0:	00812c23          	sw	s0,24(sp)
400058e4:	00112e23          	sw	ra,28(sp)
400058e8:	00912a23          	sw	s1,20(sp)
400058ec:	01212823          	sw	s2,16(sp)
	cnt = MIN(cnt, 9999);
400058f0:	70f78793          	addi	a5,a5,1807 # 270f <CONFIG_SRAM_SIZE+0x70f>
	log_output_func_t outf = output->func;
400058f4:	00052483          	lw	s1,0(a0)
{
400058f8:	00050413          	mv	s0,a0
	cnt = MIN(cnt, 9999);
400058fc:	00078693          	mv	a3,a5
40005900:	00b7e463          	bltu	a5,a1,40005908 <log_output_dropped_process+0x30>
40005904:	00058693          	mv	a3,a1
	len = snprintk(buf, sizeof(buf), "%d", cnt);
40005908:	40034637          	lui	a2,0x40034
4000590c:	c4060613          	addi	a2,a2,-960 # 40033c40 <shell_transport_uart_shell_uart+0x214>
40005910:	00500593          	li	a1,5
40005914:	00810513          	addi	a0,sp,8
40005918:	c04fc0ef          	jal	ra,40001d1c <snprintk>

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
4000591c:	00442783          	lw	a5,4(s0)
40005920:	400325b7          	lui	a1,0x40032
	len = snprintk(buf, sizeof(buf), "%d", cnt);
40005924:	00050913          	mv	s2,a0
	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
40005928:	0047a683          	lw	a3,4(a5)
4000592c:	00048513          	mv	a0,s1
40005930:	00400613          	li	a2,4
40005934:	5a058593          	addi	a1,a1,1440 # 400325a0 <prefix.1>
40005938:	961ff0ef          	jal	ra,40005298 <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
4000593c:	00442783          	lw	a5,4(s0)
40005940:	00090613          	mv	a2,s2
40005944:	00810593          	addi	a1,sp,8
40005948:	0047a683          	lw	a3,4(a5)
4000594c:	00048513          	mv	a0,s1
40005950:	949ff0ef          	jal	ra,40005298 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
40005954:	00442783          	lw	a5,4(s0)
40005958:	400335b7          	lui	a1,0x40033
4000595c:	00048513          	mv	a0,s1
40005960:	0047a683          	lw	a3,4(a5)
40005964:	01700613          	li	a2,23
40005968:	b2058593          	addi	a1,a1,-1248 # 40032b20 <postfix.0>
4000596c:	92dff0ef          	jal	ra,40005298 <buffer_write>
		     output->control_block->ctx);
}
40005970:	01c12083          	lw	ra,28(sp)
40005974:	01812403          	lw	s0,24(sp)
40005978:	01412483          	lw	s1,20(sp)
4000597c:	01012903          	lw	s2,16(sp)
40005980:	02010113          	addi	sp,sp,32
40005984:	00008067          	ret

40005988 <log_output_timestamp_freq_set>:
{
	timestamp_div = 1U;
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
40005988:	000f4737          	lui	a4,0xf4
4000598c:	00000693          	li	a3,0
40005990:	00100793          	li	a5,1
40005994:	24070713          	addi	a4,a4,576 # f4240 <__rom_region_size+0xbb284>
40005998:	02a76063          	bltu	a4,a0,400059b8 <log_output_timestamp_freq_set+0x30>
4000599c:	40039737          	lui	a4,0x40039
400059a0:	00069463          	bnez	a3,400059a8 <log_output_timestamp_freq_set+0x20>
	timestamp_div = 1U;
400059a4:	00100793          	li	a5,1
400059a8:	fef72823          	sw	a5,-16(a4) # 40038ff0 <timestamp_div>
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
400059ac:	400397b7          	lui	a5,0x40039
400059b0:	fea7aa23          	sw	a0,-12(a5) # 40038ff4 <freq>
}
400059b4:	00008067          	ret
		frequency /= 2U;
400059b8:	00155513          	srli	a0,a0,0x1
		timestamp_div *= 2U;
400059bc:	00179793          	slli	a5,a5,0x1
400059c0:	00100693          	li	a3,1
400059c4:	fd5ff06f          	j	40005998 <log_output_timestamp_freq_set+0x10>

400059c8 <severity_lvl_get>:

static void severity_lvl_get(size_t idx, struct shell_static_entry *entry)
{
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &dsub_module_name;
400059c8:	400327b7          	lui	a5,0x40032
400059cc:	59078793          	addi	a5,a5,1424 # 40032590 <dsub_module_name>
400059d0:	00f5a423          	sw	a5,8(a1)
	entry->handler = NULL;
400059d4:	0005a623          	sw	zero,12(a1)
	entry->help  = NULL;
400059d8:	0005a223          	sw	zero,4(a1)
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
					severity_lvls_sorted[idx] : NULL;
400059dc:	00400713          	li	a4,4
400059e0:	00000793          	li	a5,0
400059e4:	00a76c63          	bltu	a4,a0,400059fc <severity_lvl_get+0x34>
400059e8:	400337b7          	lui	a5,0x40033
400059ec:	00251513          	slli	a0,a0,0x2
400059f0:	0e478793          	addi	a5,a5,228 # 400330e4 <severity_lvls_sorted>
400059f4:	00a787b3          	add	a5,a5,a0
400059f8:	0007a783          	lw	a5,0(a5)
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
400059fc:	00f5a023          	sw	a5,0(a1)
}
40005a00:	00008067          	ret

40005a04 <log_halt>:
	backend->cb->active = false;
40005a04:	0045a783          	lw	a5,4(a1)
		    size_t argc,
		    char **argv)
{
	log_backend_deactivate(backend);
	return 0;
}
40005a08:	00000513          	li	a0,0
40005a0c:	000782a3          	sb	zero,5(a5)
40005a10:	00008067          	ret

40005a14 <log_go>:
static int log_go(const struct shell *sh,
		  const struct log_backend *backend,
		  size_t argc,
		  char **argv)
{
	log_backend_activate(backend, backend->cb->ctx);
40005a14:	0045a783          	lw	a5,4(a1)
	backend->cb->active = true;
40005a18:	00100713          	li	a4,1
	return 0;
}
40005a1c:	00000513          	li	a0,0
40005a20:	00e782a3          	sb	a4,5(a5)
40005a24:	00008067          	ret

40005a28 <backend_name_get>:
{
	uint32_t section_count = 0;

	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &sub_log_backend;
40005a28:	400327b7          	lui	a5,0x40032
40005a2c:	5ac78793          	addi	a5,a5,1452 # 400325ac <sub_log_backend>
40005a30:	00f5a423          	sw	a5,8(a1)
	entry->syntax  = NULL;

	STRUCT_SECTION_COUNT(log_backend, &section_count);
40005a34:	40032737          	lui	a4,0x40032
40005a38:	400327b7          	lui	a5,0x40032
40005a3c:	50c70713          	addi	a4,a4,1292 # 4003250c <shell_uart_backend>
40005a40:	51c78793          	addi	a5,a5,1308 # 4003251c <shell_uart>
40005a44:	40e787b3          	sub	a5,a5,a4
	entry->handler = NULL;
40005a48:	0005a623          	sw	zero,12(a1)
	entry->help  = NULL;
40005a4c:	0005a223          	sw	zero,4(a1)
	entry->syntax  = NULL;
40005a50:	0005a023          	sw	zero,0(a1)
	STRUCT_SECTION_COUNT(log_backend, &section_count);
40005a54:	0047d793          	srli	a5,a5,0x4

	if (idx < section_count) {
40005a58:	00f57a63          	bgeu	a0,a5,40005a6c <backend_name_get+0x44>
		struct log_backend *backend = NULL;

		STRUCT_SECTION_GET(log_backend, idx, &backend);
		__ASSERT_NO_MSG(backend != NULL);
		entry->syntax = backend->name;
40005a5c:	00451513          	slli	a0,a0,0x4
40005a60:	00a70733          	add	a4,a4,a0
40005a64:	00872783          	lw	a5,8(a4)
40005a68:	00f5a023          	sw	a5,0(a1)
	}
}
40005a6c:	00008067          	ret

40005a70 <module_name_get>:
{
40005a70:	ff010113          	addi	sp,sp,-16
	entry->subcmd = &dsub_module_name;
40005a74:	400327b7          	lui	a5,0x40032
{
40005a78:	00812423          	sw	s0,8(sp)
40005a7c:	00112623          	sw	ra,12(sp)
	entry->subcmd = &dsub_module_name;
40005a80:	59078793          	addi	a5,a5,1424 # 40032590 <dsub_module_name>
{
40005a84:	00058413          	mv	s0,a1
	entry->handler = NULL;
40005a88:	0005a623          	sw	zero,12(a1)
	entry->help  = NULL;
40005a8c:	0005a223          	sw	zero,4(a1)
	entry->subcmd = &dsub_module_name;
40005a90:	00f5a423          	sw	a5,8(a1)
	entry->syntax = log_source_name_get(Z_LOG_LOCAL_DOMAIN_ID, idx);
40005a94:	00050593          	mv	a1,a0
40005a98:	00000513          	li	a0,0
40005a9c:	83cff0ef          	jal	ra,40004ad8 <log_source_name_get>
40005aa0:	00a42023          	sw	a0,0(s0)
}
40005aa4:	00c12083          	lw	ra,12(sp)
40005aa8:	00812403          	lw	s0,8(sp)
40005aac:	01010113          	addi	sp,sp,16
40005ab0:	00008067          	ret

40005ab4 <cmd_log_backends_list>:
{
40005ab4:	fe010113          	addi	sp,sp,-32
40005ab8:	00812c23          	sw	s0,24(sp)
40005abc:	00912a23          	sw	s1,20(sp)
40005ac0:	01312623          	sw	s3,12(sp)
40005ac4:	01412423          	sw	s4,8(sp)
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40005ac8:	40032437          	lui	s0,0x40032
40005acc:	400324b7          	lui	s1,0x40032
		shell_fprintf(sh, SHELL_NORMAL,
40005ad0:	400339b7          	lui	s3,0x40033
40005ad4:	40033a37          	lui	s4,0x40033
{
40005ad8:	01212823          	sw	s2,16(sp)
40005adc:	01512223          	sw	s5,4(sp)
40005ae0:	00112e23          	sw	ra,28(sp)
40005ae4:	00050913          	mv	s2,a0
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40005ae8:	50c40413          	addi	s0,s0,1292 # 4003250c <shell_uart_backend>
40005aec:	51c48493          	addi	s1,s1,1308 # 4003251c <shell_uart>
		shell_fprintf(sh, SHELL_NORMAL,
40005af0:	b8898993          	addi	s3,s3,-1144 # 40032b88 <severity+0x1c>
40005af4:	b80a0a13          	addi	s4,s4,-1152 # 40032b80 <severity+0x14>
40005af8:	40033ab7          	lui	s5,0x40033
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40005afc:	02946663          	bltu	s0,s1,40005b28 <cmd_log_backends_list+0x74>
}
40005b00:	01c12083          	lw	ra,28(sp)
40005b04:	01812403          	lw	s0,24(sp)
40005b08:	01412483          	lw	s1,20(sp)
40005b0c:	01012903          	lw	s2,16(sp)
40005b10:	00c12983          	lw	s3,12(sp)
40005b14:	00812a03          	lw	s4,8(sp)
40005b18:	00412a83          	lw	s5,4(sp)
40005b1c:	00000513          	li	a0,0
40005b20:	02010113          	addi	sp,sp,32
40005b24:	00008067          	ret
			      backend->cb->active ? "enabled" : "disabled",
40005b28:	00442783          	lw	a5,4(s0)
		shell_fprintf(sh, SHELL_NORMAL,
40005b2c:	00842683          	lw	a3,8(s0)
40005b30:	00098713          	mv	a4,s3
40005b34:	0057c603          	lbu	a2,5(a5)
40005b38:	00060463          	beqz	a2,40005b40 <cmd_log_backends_list+0x8c>
40005b3c:	000a0713          	mv	a4,s4
40005b40:	0047c783          	lbu	a5,4(a5)
40005b44:	b94a8613          	addi	a2,s5,-1132 # 40032b94 <severity+0x28>
40005b48:	00800593          	li	a1,8
40005b4c:	00090513          	mv	a0,s2
40005b50:	39c030ef          	jal	ra,40008eec <shell_fprintf>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40005b54:	01040413          	addi	s0,s0,16
40005b58:	fa5ff06f          	j	40005afc <cmd_log_backends_list+0x48>

40005b5c <log_status>:
{
40005b5c:	fd010113          	addi	sp,sp,-48
40005b60:	01312e23          	sw	s3,28(sp)
40005b64:	00050993          	mv	s3,a0
	uint32_t modules_cnt = log_src_cnt_get(Z_LOG_LOCAL_DOMAIN_ID);
40005b68:	00000513          	li	a0,0
{
40005b6c:	01412c23          	sw	s4,24(sp)
40005b70:	01612823          	sw	s6,16(sp)
40005b74:	00058a13          	mv	s4,a1
40005b78:	02112623          	sw	ra,44(sp)
40005b7c:	02812423          	sw	s0,40(sp)
40005b80:	02912223          	sw	s1,36(sp)
40005b84:	03212023          	sw	s2,32(sp)
40005b88:	01512a23          	sw	s5,20(sp)
40005b8c:	01712623          	sw	s7,12(sp)
	uint32_t modules_cnt = log_src_cnt_get(Z_LOG_LOCAL_DOMAIN_ID);
40005b90:	f2dfe0ef          	jal	ra,40004abc <log_src_cnt_get>
	return backend->cb->active;
40005b94:	004a2783          	lw	a5,4(s4)
40005b98:	00050b13          	mv	s6,a0
	if (!log_backend_is_active(backend)) {
40005b9c:	0057c783          	lbu	a5,5(a5)
40005ba0:	00079c63          	bnez	a5,40005bb8 <log_status+0x5c>
		shell_warn(sh, "Logs are halted!");
40005ba4:	40033637          	lui	a2,0x40033
40005ba8:	bb860613          	addi	a2,a2,-1096 # 40032bb8 <severity+0x4c>
40005bac:	00300593          	li	a1,3
40005bb0:	00098513          	mv	a0,s3
40005bb4:	338030ef          	jal	ra,40008eec <shell_fprintf>
	shell_fprintf(sh, SHELL_NORMAL, "%-40s | current | built-in \r\n",
40005bb8:	400336b7          	lui	a3,0x40033
40005bbc:	40033637          	lui	a2,0x40033
40005bc0:	bcc68693          	addi	a3,a3,-1076 # 40032bcc <severity+0x60>
40005bc4:	bd860613          	addi	a2,a2,-1064 # 40032bd8 <severity+0x6c>
40005bc8:	00800593          	li	a1,8
40005bcc:	00098513          	mv	a0,s3
40005bd0:	31c030ef          	jal	ra,40008eec <shell_fprintf>
	shell_fprintf(sh, SHELL_NORMAL,
40005bd4:	40033637          	lui	a2,0x40033
40005bd8:	bf860613          	addi	a2,a2,-1032 # 40032bf8 <severity+0x8c>
40005bdc:	00800593          	li	a1,8
40005be0:	00098513          	mv	a0,s3
			      severity_lvls[compiled_lvl]);
40005be4:	40033ab7          	lui	s5,0x40033
	shell_fprintf(sh, SHELL_NORMAL,
40005be8:	304030ef          	jal	ra,40008eec <shell_fprintf>
	for (int16_t i = 0U; i < modules_cnt; i++) {
40005bec:	00000413          	li	s0,0
			      severity_lvls[compiled_lvl]);
40005bf0:	0f8a8a93          	addi	s5,s5,248 # 400330f8 <severity_lvls>
		shell_fprintf(sh, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
40005bf4:	40033bb7          	lui	s7,0x40033
	for (int16_t i = 0U; i < modules_cnt; i++) {
40005bf8:	03646a63          	bltu	s0,s6,40005c2c <log_status+0xd0>
}
40005bfc:	02c12083          	lw	ra,44(sp)
40005c00:	02812403          	lw	s0,40(sp)
40005c04:	02412483          	lw	s1,36(sp)
40005c08:	02012903          	lw	s2,32(sp)
40005c0c:	01c12983          	lw	s3,28(sp)
40005c10:	01812a03          	lw	s4,24(sp)
40005c14:	01412a83          	lw	s5,20(sp)
40005c18:	01012b03          	lw	s6,16(sp)
40005c1c:	00c12b83          	lw	s7,12(sp)
40005c20:	00000513          	li	a0,0
40005c24:	03010113          	addi	sp,sp,48
40005c28:	00008067          	ret
		dynamic_lvl = log_filter_get(backend, Z_LOG_LOCAL_DOMAIN_ID,
40005c2c:	00040613          	mv	a2,s0
40005c30:	00100693          	li	a3,1
40005c34:	00000593          	li	a1,0
40005c38:	000a0513          	mv	a0,s4
40005c3c:	a14ff0ef          	jal	ra,40004e50 <log_filter_get>
		compiled_lvl = log_filter_get(backend, Z_LOG_LOCAL_DOMAIN_ID,
40005c40:	00040613          	mv	a2,s0
40005c44:	00000693          	li	a3,0
		dynamic_lvl = log_filter_get(backend, Z_LOG_LOCAL_DOMAIN_ID,
40005c48:	00050493          	mv	s1,a0
		compiled_lvl = log_filter_get(backend, Z_LOG_LOCAL_DOMAIN_ID,
40005c4c:	00000593          	li	a1,0
40005c50:	000a0513          	mv	a0,s4
40005c54:	9fcff0ef          	jal	ra,40004e50 <log_filter_get>
40005c58:	00050913          	mv	s2,a0
		shell_fprintf(sh, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
40005c5c:	00040593          	mv	a1,s0
40005c60:	00000513          	li	a0,0
			      severity_lvls[compiled_lvl]);
40005c64:	00291913          	slli	s2,s2,0x2
			      severity_lvls[dynamic_lvl],
40005c68:	00249493          	slli	s1,s1,0x2
		shell_fprintf(sh, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
40005c6c:	e6dfe0ef          	jal	ra,40004ad8 <log_source_name_get>
			      severity_lvls[compiled_lvl]);
40005c70:	012a8933          	add	s2,s5,s2
			      severity_lvls[dynamic_lvl],
40005c74:	009a84b3          	add	s1,s5,s1
		shell_fprintf(sh, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
40005c78:	00092783          	lw	a5,0(s2)
40005c7c:	0004a703          	lw	a4,0(s1)
40005c80:	00140413          	addi	s0,s0,1
40005c84:	00050693          	mv	a3,a0
40005c88:	c38b8613          	addi	a2,s7,-968 # 40032c38 <severity+0xcc>
40005c8c:	00800593          	li	a1,8
40005c90:	00098513          	mv	a0,s3
	for (int16_t i = 0U; i < modules_cnt; i++) {
40005c94:	01041413          	slli	s0,s0,0x10
		shell_fprintf(sh, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
40005c98:	254030ef          	jal	ra,40008eec <shell_fprintf>
	for (int16_t i = 0U; i < modules_cnt; i++) {
40005c9c:	41045413          	srai	s0,s0,0x10
40005ca0:	f59ff06f          	j	40005bf8 <log_status+0x9c>

40005ca4 <shell_backend_cmd_execute>:
{
40005ca4:	fd010113          	addi	sp,sp,-48
40005ca8:	02812423          	sw	s0,40(sp)
40005cac:	03212023          	sw	s2,32(sp)
40005cb0:	01312e23          	sw	s3,28(sp)
40005cb4:	01512a23          	sw	s5,20(sp)
40005cb8:	01612823          	sw	s6,16(sp)
40005cbc:	01712623          	sw	s7,12(sp)
40005cc0:	01812423          	sw	s8,8(sp)
40005cc4:	02112623          	sw	ra,44(sp)
40005cc8:	02912223          	sw	s1,36(sp)
40005ccc:	01412c23          	sw	s4,24(sp)
	char const *name = argv[-1];
40005cd0:	ffc62a03          	lw	s4,-4(a2)
{
40005cd4:	00050913          	mv	s2,a0
40005cd8:	00058b93          	mv	s7,a1
	size_t slen = strlen(name);
40005cdc:	000a0513          	mv	a0,s4
{
40005ce0:	00060993          	mv	s3,a2
40005ce4:	00068c13          	mv	s8,a3
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40005ce8:	40032437          	lui	s0,0x40032
	size_t slen = strlen(name);
40005cec:	6e9060ef          	jal	ra,4000cbd4 <strlen>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40005cf0:	40032ab7          	lui	s5,0x40032
	size_t slen = strlen(name);
40005cf4:	00050b13          	mv	s6,a0
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40005cf8:	50c40413          	addi	s0,s0,1292 # 4003250c <shell_uart_backend>
40005cfc:	51ca8a93          	addi	s5,s5,1308 # 4003251c <shell_uart>
40005d00:	03546263          	bltu	s0,s5,40005d24 <shell_backend_cmd_execute+0x80>
		shell_error(sh, "Invalid backend: %s", name);
40005d04:	40033637          	lui	a2,0x40033
40005d08:	000a0693          	mv	a3,s4
40005d0c:	c4c60613          	addi	a2,a2,-948 # 40032c4c <severity+0xe0>
40005d10:	00100593          	li	a1,1
40005d14:	00090513          	mv	a0,s2
40005d18:	1d4030ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40005d1c:	ff800493          	li	s1,-8
40005d20:	0300006f          	j	40005d50 <shell_backend_cmd_execute+0xac>
		if (strncmp(name, backend->name, slen) == 0) {
40005d24:	00842583          	lw	a1,8(s0)
40005d28:	000b0613          	mv	a2,s6
40005d2c:	000a0513          	mv	a0,s4
40005d30:	70d060ef          	jal	ra,4000cc3c <strncmp>
40005d34:	00050493          	mv	s1,a0
40005d38:	04051663          	bnez	a0,40005d84 <shell_backend_cmd_execute+0xe0>
		func(sh, backend, argc, argv);
40005d3c:	00098693          	mv	a3,s3
40005d40:	000b8613          	mv	a2,s7
40005d44:	00040593          	mv	a1,s0
40005d48:	00090513          	mv	a0,s2
40005d4c:	000c00e7          	jalr	s8
}
40005d50:	02c12083          	lw	ra,44(sp)
40005d54:	02812403          	lw	s0,40(sp)
40005d58:	02012903          	lw	s2,32(sp)
40005d5c:	01c12983          	lw	s3,28(sp)
40005d60:	01812a03          	lw	s4,24(sp)
40005d64:	01412a83          	lw	s5,20(sp)
40005d68:	01012b03          	lw	s6,16(sp)
40005d6c:	00c12b83          	lw	s7,12(sp)
40005d70:	00812c03          	lw	s8,8(sp)
40005d74:	00048513          	mv	a0,s1
40005d78:	02412483          	lw	s1,36(sp)
40005d7c:	03010113          	addi	sp,sp,48
40005d80:	00008067          	ret
	STRUCT_SECTION_FOREACH(log_backend, backend) {
40005d84:	01040413          	addi	s0,s0,16
40005d88:	f79ff06f          	j	40005d00 <shell_backend_cmd_execute+0x5c>

40005d8c <cmd_log_backend_status>:
	shell_backend_cmd_execute(sh, argc, argv, log_status);
40005d8c:	400066b7          	lui	a3,0x40006
{
40005d90:	ff010113          	addi	sp,sp,-16
	shell_backend_cmd_execute(sh, argc, argv, log_status);
40005d94:	b5c68693          	addi	a3,a3,-1188 # 40005b5c <log_status>
{
40005d98:	00112623          	sw	ra,12(sp)
	shell_backend_cmd_execute(sh, argc, argv, log_status);
40005d9c:	f09ff0ef          	jal	ra,40005ca4 <shell_backend_cmd_execute>
}
40005da0:	00c12083          	lw	ra,12(sp)
40005da4:	00000513          	li	a0,0
40005da8:	01010113          	addi	sp,sp,16
40005dac:	00008067          	ret

40005db0 <cmd_log_backend_halt>:
	return shell_backend_cmd_execute(sh, argc, argv, log_halt);
40005db0:	400066b7          	lui	a3,0x40006
40005db4:	a0468693          	addi	a3,a3,-1532 # 40005a04 <log_halt>
40005db8:	eedff06f          	j	40005ca4 <shell_backend_cmd_execute>

40005dbc <cmd_log_backend_go>:
	return shell_backend_cmd_execute(sh, argc, argv, log_go);
40005dbc:	400066b7          	lui	a3,0x40006
40005dc0:	a1468693          	addi	a3,a3,-1516 # 40005a14 <log_go>
40005dc4:	ee1ff06f          	j	40005ca4 <shell_backend_cmd_execute>

40005dc8 <cmd_log_backend_enable>:
	return shell_backend_cmd_execute(sh, argc, argv, log_enable);
40005dc8:	400066b7          	lui	a3,0x40006
40005dcc:	0ec68693          	addi	a3,a3,236 # 400060ec <log_enable>
40005dd0:	ed5ff06f          	j	40005ca4 <shell_backend_cmd_execute>

40005dd4 <cmd_log_backend_disable>:
	return shell_backend_cmd_execute(sh, argc, argv, log_disable);
40005dd4:	400066b7          	lui	a3,0x40006
40005dd8:	22868693          	addi	a3,a3,552 # 40006228 <log_disable>
40005ddc:	ec9ff06f          	j	40005ca4 <shell_backend_cmd_execute>

40005de0 <cmd_log_mem>:
{
40005de0:	fe010113          	addi	sp,sp,-32
40005de4:	00812c23          	sw	s0,24(sp)
	err = log_mem_get_usage(&size, &used);
40005de8:	00810593          	addi	a1,sp,8
{
40005dec:	00050413          	mv	s0,a0
	err = log_mem_get_usage(&size, &used);
40005df0:	00410513          	addi	a0,sp,4
{
40005df4:	00112e23          	sw	ra,28(sp)
	err = log_mem_get_usage(&size, &used);
40005df8:	c89fe0ef          	jal	ra,40004a80 <log_mem_get_usage>
	if (err < 0) {
40005dfc:	02055663          	bgez	a0,40005e28 <cmd_log_mem+0x48>
		shell_error(sh, "Failed to get usage (mode does not support it?)");
40005e00:	40033637          	lui	a2,0x40033
40005e04:	00040513          	mv	a0,s0
40005e08:	c6460613          	addi	a2,a2,-924 # 40032c64 <severity+0xf8>
40005e0c:	00100593          	li	a1,1
40005e10:	0dc030ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40005e14:	ff800513          	li	a0,-8
}
40005e18:	01c12083          	lw	ra,28(sp)
40005e1c:	01812403          	lw	s0,24(sp)
40005e20:	02010113          	addi	sp,sp,32
40005e24:	00008067          	ret
	shell_print(sh, "Log message buffer utilization report:");
40005e28:	40033637          	lui	a2,0x40033
40005e2c:	c9860613          	addi	a2,a2,-872 # 40032c98 <severity+0x12c>
40005e30:	00800593          	li	a1,8
40005e34:	00040513          	mv	a0,s0
40005e38:	0b4030ef          	jal	ra,40008eec <shell_fprintf>
	shell_print(sh, "\tCapacity: %u bytes", size);
40005e3c:	00412683          	lw	a3,4(sp)
40005e40:	40033637          	lui	a2,0x40033
40005e44:	cc060613          	addi	a2,a2,-832 # 40032cc0 <severity+0x154>
40005e48:	00800593          	li	a1,8
40005e4c:	00040513          	mv	a0,s0
40005e50:	09c030ef          	jal	ra,40008eec <shell_fprintf>
	shell_print(sh, "\tCurrently in use: %u bytes", used);
40005e54:	00812683          	lw	a3,8(sp)
40005e58:	40033637          	lui	a2,0x40033
40005e5c:	00040513          	mv	a0,s0
40005e60:	cd860613          	addi	a2,a2,-808 # 40032cd8 <severity+0x16c>
40005e64:	00800593          	li	a1,8
40005e68:	084030ef          	jal	ra,40008eec <shell_fprintf>
	err = log_mem_get_max_usage(&max);
40005e6c:	00c10513          	addi	a0,sp,12
40005e70:	c3dfe0ef          	jal	ra,40004aac <log_mem_get_max_usage>
	if (err < 0) {
40005e74:	02055063          	bgez	a0,40005e94 <cmd_log_mem+0xb4>
		shell_print(sh, "Enable CONFIG_LOG_MEM_UTILIZATION to get maximum usage");
40005e78:	40033637          	lui	a2,0x40033
40005e7c:	cf860613          	addi	a2,a2,-776 # 40032cf8 <severity+0x18c>
40005e80:	00800593          	li	a1,8
40005e84:	00040513          	mv	a0,s0
40005e88:	064030ef          	jal	ra,40008eec <shell_fprintf>
		return 0;
40005e8c:	00000513          	li	a0,0
40005e90:	f89ff06f          	j	40005e18 <cmd_log_mem+0x38>
	shell_print(sh, "\tMaximum usage: %u bytes", max);
40005e94:	00c12683          	lw	a3,12(sp)
40005e98:	40033637          	lui	a2,0x40033
40005e9c:	d3060613          	addi	a2,a2,-720 # 40032d30 <severity+0x1c4>
40005ea0:	00800593          	li	a1,8
40005ea4:	00040513          	mv	a0,s0
40005ea8:	044030ef          	jal	ra,40008eec <shell_fprintf>
	return 0;
40005eac:	fe1ff06f          	j	40005e8c <cmd_log_mem+0xac>

40005eb0 <shell_state_precheck>:
	if (sh->log_backend->control_block->state
40005eb0:	01c52783          	lw	a5,28(a0)
40005eb4:	0087a783          	lw	a5,8(a5)
40005eb8:	0047a783          	lw	a5,4(a5)
40005ebc:	02079663          	bnez	a5,40005ee8 <shell_state_precheck+0x38>
		shell_error(sh, "Shell log backend not initialized.");
40005ec0:	40033637          	lui	a2,0x40033
{
40005ec4:	ff010113          	addi	sp,sp,-16
		shell_error(sh, "Shell log backend not initialized.");
40005ec8:	d4c60613          	addi	a2,a2,-692 # 40032d4c <severity+0x1e0>
40005ecc:	00100593          	li	a1,1
{
40005ed0:	00112623          	sw	ra,12(sp)
		shell_error(sh, "Shell log backend not initialized.");
40005ed4:	018030ef          	jal	ra,40008eec <shell_fprintf>
}
40005ed8:	00c12083          	lw	ra,12(sp)
		shell_error(sh, "Shell log backend not initialized.");
40005edc:	00000513          	li	a0,0
}
40005ee0:	01010113          	addi	sp,sp,16
40005ee4:	00008067          	ret
	return true;
40005ee8:	00100513          	li	a0,1
}
40005eec:	00008067          	ret

40005ef0 <cmd_log_self_status>:
{
40005ef0:	fe010113          	addi	sp,sp,-32
40005ef4:	00812c23          	sw	s0,24(sp)
40005ef8:	00912a23          	sw	s1,20(sp)
40005efc:	00112e23          	sw	ra,28(sp)
40005f00:	00050413          	mv	s0,a0
40005f04:	00058493          	mv	s1,a1
40005f08:	00c12623          	sw	a2,12(sp)
	if (!shell_state_precheck(sh)) {
40005f0c:	fa5ff0ef          	jal	ra,40005eb0 <shell_state_precheck>
40005f10:	00050e63          	beqz	a0,40005f2c <cmd_log_self_status+0x3c>
	log_status(sh, sh->log_backend->backend, argc, argv);
40005f14:	01c42783          	lw	a5,28(s0)
40005f18:	00c12683          	lw	a3,12(sp)
40005f1c:	00048613          	mv	a2,s1
40005f20:	0007a583          	lw	a1,0(a5)
40005f24:	00040513          	mv	a0,s0
40005f28:	c35ff0ef          	jal	ra,40005b5c <log_status>
}
40005f2c:	01c12083          	lw	ra,28(sp)
40005f30:	01812403          	lw	s0,24(sp)
40005f34:	01412483          	lw	s1,20(sp)
40005f38:	00000513          	li	a0,0
40005f3c:	02010113          	addi	sp,sp,32
40005f40:	00008067          	ret

40005f44 <filters_set>:
{
40005f44:	fb010113          	addi	sp,sp,-80
40005f48:	04812423          	sw	s0,72(sp)
40005f4c:	05212023          	sw	s2,64(sp)
40005f50:	03312e23          	sw	s3,60(sp)
40005f54:	03512a23          	sw	s5,52(sp)
40005f58:	03612823          	sw	s6,48(sp)
40005f5c:	04112623          	sw	ra,76(sp)
40005f60:	04912223          	sw	s1,68(sp)
40005f64:	03412c23          	sw	s4,56(sp)
40005f68:	03712623          	sw	s7,44(sp)
40005f6c:	03812423          	sw	s8,40(sp)
40005f70:	03912223          	sw	s9,36(sp)
40005f74:	03a12023          	sw	s10,32(sp)
40005f78:	01b12e23          	sw	s11,28(sp)
40005f7c:	00a12623          	sw	a0,12(sp)
40005f80:	00058a93          	mv	s5,a1
40005f84:	00060913          	mv	s2,a2
40005f88:	00068413          	mv	s0,a3
40005f8c:	00070b13          	mv	s6,a4
40005f90:	00060993          	mv	s3,a2
	int cnt = all ? log_src_cnt_get(Z_LOG_LOCAL_DOMAIN_ID) : argc;
40005f94:	00061863          	bnez	a2,40005fa4 <filters_set+0x60>
40005f98:	00000513          	li	a0,0
40005f9c:	b21fe0ef          	jal	ra,40004abc <log_src_cnt_get>
40005fa0:	00050993          	mv	s3,a0
	if (!backend->cb->active) {
40005fa4:	004aa783          	lw	a5,4(s5)
40005fa8:	0057c783          	lbu	a5,5(a5)
40005fac:	00079c63          	bnez	a5,40005fc4 <filters_set+0x80>
		shell_warn(sh, "Backend not active.");
40005fb0:	00c12503          	lw	a0,12(sp)
40005fb4:	40033637          	lui	a2,0x40033
40005fb8:	d7060613          	addi	a2,a2,-656 # 40032d70 <severity+0x204>
40005fbc:	00300593          	li	a1,3
40005fc0:	72d020ef          	jal	ra,40008eec <shell_fprintf>
				shell_warn(sh, "%s: level set to %s.",
40005fc4:	40033bb7          	lui	s7,0x40033
40005fc8:	00000493          	li	s1,0
40005fcc:	0f8b8b93          	addi	s7,s7,248 # 400330f8 <severity_lvls>
40005fd0:	40033cb7          	lui	s9,0x40033
	for (i = 0; i < cnt; i++) {
40005fd4:	0734d463          	bge	s1,s3,4000603c <filters_set+0xf8>
		id = all ? i : module_id_get(argv[i]);
40005fd8:	00048c13          	mv	s8,s1
40005fdc:	0a090663          	beqz	s2,40006088 <filters_set+0x144>
			shell_error(sh, "%s: unknown source name.", argv[i]);
40005fe0:	40033c37          	lui	s8,0x40033
	uint32_t modules_cnt = log_src_cnt_get(Z_LOG_LOCAL_DOMAIN_ID);
40005fe4:	00000513          	li	a0,0
		id = all ? i : module_id_get(argv[i]);
40005fe8:	00042d83          	lw	s11,0(s0)
	uint32_t modules_cnt = log_src_cnt_get(Z_LOG_LOCAL_DOMAIN_ID);
40005fec:	ad1fe0ef          	jal	ra,40004abc <log_src_cnt_get>
40005ff0:	00050a13          	mv	s4,a0
	for (i = 0U; i < modules_cnt; i++) {
40005ff4:	00000d13          	li	s10,0
40005ff8:	03aa0263          	beq	s4,s10,4000601c <filters_set+0xd8>
		tmp_name = log_source_name_get(Z_LOG_LOCAL_DOMAIN_ID, i);
40005ffc:	000d0593          	mv	a1,s10
40006000:	00000513          	li	a0,0
40006004:	ad5fe0ef          	jal	ra,40004ad8 <log_source_name_get>
		if (strncmp(tmp_name, name, 64) == 0) {
40006008:	04000613          	li	a2,64
4000600c:	000d8593          	mv	a1,s11
40006010:	42d060ef          	jal	ra,4000cc3c <strncmp>
40006014:	06051263          	bnez	a0,40006078 <filters_set+0x134>
		if (id >= 0) {
40006018:	060d5463          	bgez	s10,40006080 <filters_set+0x13c>
			shell_error(sh, "%s: unknown source name.", argv[i]);
4000601c:	00042683          	lw	a3,0(s0)
40006020:	00c12503          	lw	a0,12(sp)
40006024:	da0c0613          	addi	a2,s8,-608 # 40032da0 <severity+0x234>
40006028:	00100593          	li	a1,1
	for (i = 0; i < cnt; i++) {
4000602c:	00148493          	addi	s1,s1,1
			shell_error(sh, "%s: unknown source name.", argv[i]);
40006030:	6bd020ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; i < cnt; i++) {
40006034:	00440413          	addi	s0,s0,4
40006038:	fb34c6e3          	blt	s1,s3,40005fe4 <filters_set+0xa0>
}
4000603c:	04c12083          	lw	ra,76(sp)
40006040:	04812403          	lw	s0,72(sp)
40006044:	04412483          	lw	s1,68(sp)
40006048:	04012903          	lw	s2,64(sp)
4000604c:	03c12983          	lw	s3,60(sp)
40006050:	03812a03          	lw	s4,56(sp)
40006054:	03412a83          	lw	s5,52(sp)
40006058:	03012b03          	lw	s6,48(sp)
4000605c:	02c12b83          	lw	s7,44(sp)
40006060:	02812c03          	lw	s8,40(sp)
40006064:	02412c83          	lw	s9,36(sp)
40006068:	02012d03          	lw	s10,32(sp)
4000606c:	01c12d83          	lw	s11,28(sp)
40006070:	05010113          	addi	sp,sp,80
40006074:	00008067          	ret
	for (i = 0U; i < modules_cnt; i++) {
40006078:	001d0d13          	addi	s10,s10,1
4000607c:	f7dff06f          	j	40005ff8 <filters_set+0xb4>
40006080:	00048c13          	mv	s8,s1
			return i;
40006084:	000d0493          	mv	s1,s10
40006088:	01049613          	slli	a2,s1,0x10
4000608c:	000b0693          	mv	a3,s6
40006090:	41065613          	srai	a2,a2,0x10
40006094:	00000593          	li	a1,0
40006098:	000a8513          	mv	a0,s5
4000609c:	b45fe0ef          	jal	ra,40004be0 <z_impl_log_filter_set>
400060a0:	00050493          	mv	s1,a0
			if (set_lvl != level) {
400060a4:	02ab0a63          	beq	s6,a0,400060d8 <filters_set+0x194>
					log_source_name_get(Z_LOG_LOCAL_DOMAIN_ID, i) :
400060a8:	02091e63          	bnez	s2,400060e4 <filters_set+0x1a0>
400060ac:	000c0593          	mv	a1,s8
400060b0:	00000513          	li	a0,0
400060b4:	a25fe0ef          	jal	ra,40004ad8 <log_source_name_get>
400060b8:	00050693          	mv	a3,a0
				shell_warn(sh, "%s: level set to %s.",
400060bc:	00249493          	slli	s1,s1,0x2
400060c0:	009b84b3          	add	s1,s7,s1
400060c4:	0004a703          	lw	a4,0(s1)
400060c8:	00c12503          	lw	a0,12(sp)
400060cc:	d88c8613          	addi	a2,s9,-632 # 40032d88 <severity+0x21c>
400060d0:	00300593          	li	a1,3
400060d4:	619020ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; i < cnt; i++) {
400060d8:	001c0493          	addi	s1,s8,1
400060dc:	00440413          	addi	s0,s0,4
400060e0:	ef5ff06f          	j	40005fd4 <filters_set+0x90>
					log_source_name_get(Z_LOG_LOCAL_DOMAIN_ID, i) :
400060e4:	00042683          	lw	a3,0(s0)
400060e8:	fd5ff06f          	j	400060bc <filters_set+0x178>

400060ec <log_enable>:
{
400060ec:	fc010113          	addi	sp,sp,-64
400060f0:	02912a23          	sw	s1,52(sp)
400060f4:	03212823          	sw	s2,48(sp)
400060f8:	03312623          	sw	s3,44(sp)
400060fc:	03412423          	sw	s4,40(sp)
40006100:	03512223          	sw	s5,36(sp)
40006104:	03612023          	sw	s6,32(sp)
40006108:	02112e23          	sw	ra,60(sp)
4000610c:	02812c23          	sw	s0,56(sp)
40006110:	01712e23          	sw	s7,28(sp)
	severity_level = severity_level_get(argv[1]);
40006114:	0046ab83          	lw	s7,4(a3)
40006118:	40033937          	lui	s2,0x40033
{
4000611c:	00050993          	mv	s3,a0
40006120:	00058a13          	mv	s4,a1
40006124:	00060a93          	mv	s5,a2
40006128:	00068493          	mv	s1,a3
4000612c:	0f890913          	addi	s2,s2,248 # 400330f8 <severity_lvls>
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
40006130:	00000713          	li	a4,0
40006134:	00500b13          	li	s6,5
		if (strncmp(str, severity_lvls[i], 4) == 0) {
40006138:	00092583          	lw	a1,0(s2)
4000613c:	00400613          	li	a2,4
40006140:	000b8513          	mv	a0,s7
40006144:	00e12623          	sw	a4,12(sp)
40006148:	2f5060ef          	jal	ra,4000cc3c <strncmp>
4000614c:	00c12703          	lw	a4,12(sp)
40006150:	00050413          	mv	s0,a0
40006154:	02050863          	beqz	a0,40006184 <log_enable+0x98>
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
40006158:	00170713          	addi	a4,a4,1
4000615c:	00490913          	addi	s2,s2,4
40006160:	fd671ce3          	bne	a4,s6,40006138 <log_enable+0x4c>
		shell_error(sh, "Invalid severity: %s", argv[1]);
40006164:	0044a683          	lw	a3,4(s1)
40006168:	40033637          	lui	a2,0x40033
4000616c:	dbc60613          	addi	a2,a2,-580 # 40032dbc <severity+0x250>
40006170:	00100593          	li	a1,1
40006174:	00098513          	mv	a0,s3
40006178:	575020ef          	jal	ra,40008eec <shell_fprintf>
4000617c:	ff800413          	li	s0,-8
40006180:	0180006f          	j	40006198 <log_enable+0xac>
	filters_set(sh, backend, argc - 2, &argv[2], severity_level);
40006184:	00848693          	addi	a3,s1,8
40006188:	ffea8613          	addi	a2,s5,-2
4000618c:	000a0593          	mv	a1,s4
40006190:	00098513          	mv	a0,s3
40006194:	db1ff0ef          	jal	ra,40005f44 <filters_set>
}
40006198:	03c12083          	lw	ra,60(sp)
4000619c:	00040513          	mv	a0,s0
400061a0:	03812403          	lw	s0,56(sp)
400061a4:	03412483          	lw	s1,52(sp)
400061a8:	03012903          	lw	s2,48(sp)
400061ac:	02c12983          	lw	s3,44(sp)
400061b0:	02812a03          	lw	s4,40(sp)
400061b4:	02412a83          	lw	s5,36(sp)
400061b8:	02012b03          	lw	s6,32(sp)
400061bc:	01c12b83          	lw	s7,28(sp)
400061c0:	04010113          	addi	sp,sp,64
400061c4:	00008067          	ret

400061c8 <cmd_log_self_enable>:
{
400061c8:	fe010113          	addi	sp,sp,-32
400061cc:	00812c23          	sw	s0,24(sp)
400061d0:	00912a23          	sw	s1,20(sp)
400061d4:	00112e23          	sw	ra,28(sp)
400061d8:	00050413          	mv	s0,a0
400061dc:	00058493          	mv	s1,a1
400061e0:	00c12623          	sw	a2,12(sp)
	if (!shell_state_precheck(sh)) {
400061e4:	ccdff0ef          	jal	ra,40005eb0 <shell_state_precheck>
400061e8:	02050663          	beqz	a0,40006214 <cmd_log_self_enable+0x4c>
	return log_enable(sh, sh->log_backend->backend, argc, argv);
400061ec:	01c42783          	lw	a5,28(s0)
400061f0:	00040513          	mv	a0,s0
}
400061f4:	01812403          	lw	s0,24(sp)
	return log_enable(sh, sh->log_backend->backend, argc, argv);
400061f8:	00c12683          	lw	a3,12(sp)
}
400061fc:	01c12083          	lw	ra,28(sp)
	return log_enable(sh, sh->log_backend->backend, argc, argv);
40006200:	0007a583          	lw	a1,0(a5)
40006204:	00048613          	mv	a2,s1
}
40006208:	01412483          	lw	s1,20(sp)
4000620c:	02010113          	addi	sp,sp,32
	return log_enable(sh, sh->log_backend->backend, argc, argv);
40006210:	eddff06f          	j	400060ec <log_enable>
}
40006214:	01c12083          	lw	ra,28(sp)
40006218:	01812403          	lw	s0,24(sp)
4000621c:	01412483          	lw	s1,20(sp)
40006220:	02010113          	addi	sp,sp,32
40006224:	00008067          	ret

40006228 <log_disable>:
{
40006228:	ff010113          	addi	sp,sp,-16
	filters_set(sh, backend, argc - 1, &argv[1], LOG_LEVEL_NONE);
4000622c:	00000713          	li	a4,0
40006230:	00468693          	addi	a3,a3,4
40006234:	fff60613          	addi	a2,a2,-1
{
40006238:	00112623          	sw	ra,12(sp)
	filters_set(sh, backend, argc - 1, &argv[1], LOG_LEVEL_NONE);
4000623c:	d09ff0ef          	jal	ra,40005f44 <filters_set>
}
40006240:	00c12083          	lw	ra,12(sp)
40006244:	00000513          	li	a0,0
40006248:	01010113          	addi	sp,sp,16
4000624c:	00008067          	ret

40006250 <cmd_log_self_disable>:
{
40006250:	fe010113          	addi	sp,sp,-32
40006254:	00812c23          	sw	s0,24(sp)
40006258:	00912a23          	sw	s1,20(sp)
4000625c:	00112e23          	sw	ra,28(sp)
40006260:	00050413          	mv	s0,a0
40006264:	00058493          	mv	s1,a1
40006268:	00c12623          	sw	a2,12(sp)
	if (!shell_state_precheck(sh)) {
4000626c:	c45ff0ef          	jal	ra,40005eb0 <shell_state_precheck>
40006270:	02050663          	beqz	a0,4000629c <cmd_log_self_disable+0x4c>
	return log_disable(sh, sh->log_backend->backend, argc, argv);
40006274:	01c42783          	lw	a5,28(s0)
40006278:	00040513          	mv	a0,s0
}
4000627c:	01812403          	lw	s0,24(sp)
	return log_disable(sh, sh->log_backend->backend, argc, argv);
40006280:	00c12683          	lw	a3,12(sp)
}
40006284:	01c12083          	lw	ra,28(sp)
	return log_disable(sh, sh->log_backend->backend, argc, argv);
40006288:	0007a583          	lw	a1,0(a5)
4000628c:	00048613          	mv	a2,s1
}
40006290:	01412483          	lw	s1,20(sp)
40006294:	02010113          	addi	sp,sp,32
	return log_disable(sh, sh->log_backend->backend, argc, argv);
40006298:	f91ff06f          	j	40006228 <log_disable>
}
4000629c:	01c12083          	lw	ra,28(sp)
400062a0:	01812403          	lw	s0,24(sp)
400062a4:	01412483          	lw	s1,20(sp)
400062a8:	02010113          	addi	sp,sp,32
400062ac:	00008067          	ret

400062b0 <cmd_log_self_go>:
{
400062b0:	ff010113          	addi	sp,sp,-16
400062b4:	00812423          	sw	s0,8(sp)
400062b8:	00112623          	sw	ra,12(sp)
400062bc:	00050413          	mv	s0,a0
	if (!shell_state_precheck(sh)) {
400062c0:	bf1ff0ef          	jal	ra,40005eb0 <shell_state_precheck>
400062c4:	00050c63          	beqz	a0,400062dc <cmd_log_self_go+0x2c>
	return log_go(sh, sh->log_backend->backend, argc, argv);
400062c8:	01c42783          	lw	a5,28(s0)
	backend->cb->active = true;
400062cc:	00100713          	li	a4,1
	log_backend_activate(backend, backend->cb->ctx);
400062d0:	0007a783          	lw	a5,0(a5)
400062d4:	0047a783          	lw	a5,4(a5)
400062d8:	00e782a3          	sb	a4,5(a5)
}
400062dc:	00c12083          	lw	ra,12(sp)
400062e0:	00812403          	lw	s0,8(sp)
400062e4:	00000513          	li	a0,0
400062e8:	01010113          	addi	sp,sp,16
400062ec:	00008067          	ret

400062f0 <cmd_log_self_halt>:
{
400062f0:	ff010113          	addi	sp,sp,-16
400062f4:	00812423          	sw	s0,8(sp)
400062f8:	00112623          	sw	ra,12(sp)
400062fc:	00050413          	mv	s0,a0
	if (!shell_state_precheck(sh)) {
40006300:	bb1ff0ef          	jal	ra,40005eb0 <shell_state_precheck>
40006304:	00050a63          	beqz	a0,40006318 <cmd_log_self_halt+0x28>
	return log_halt(sh, sh->log_backend->backend, argc, argv);
40006308:	01c42783          	lw	a5,28(s0)
	backend->cb->active = false;
4000630c:	0007a783          	lw	a5,0(a5)
40006310:	0047a783          	lw	a5,4(a5)
40006314:	000782a3          	sb	zero,5(a5)
}
40006318:	00c12083          	lw	ra,12(sp)
4000631c:	00812403          	lw	s0,8(sp)
40006320:	00000513          	li	a0,0
40006324:	01010113          	addi	sp,sp,16
40006328:	00008067          	ret

4000632c <cmd_kernel_version>:
#define THREAD_MAX_NAM_LEN 10
#endif

static int cmd_kernel_version(const struct shell *sh,
			      size_t argc, char **argv)
{
4000632c:	ff010113          	addi	sp,sp,-16
40006330:	00112623          	sw	ra,12(sp)
40006334:	00812423          	sw	s0,8(sp)
40006338:	00050413          	mv	s0,a0
	uint32_t version = sys_kernel_version_get();
4000633c:	64d280ef          	jal	ra,4002f188 <sys_kernel_version_get>

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(sh, "Zephyr version %d.%d.%d",
40006340:	00855793          	srli	a5,a0,0x8
40006344:	01055713          	srli	a4,a0,0x10
40006348:	40033637          	lui	a2,0x40033
4000634c:	01855693          	srli	a3,a0,0x18
40006350:	0ff7f793          	zext.b	a5,a5
40006354:	00040513          	mv	a0,s0
40006358:	0ff77713          	zext.b	a4,a4
4000635c:	10c60613          	addi	a2,a2,268 # 4003310c <severity_lvls+0x14>
40006360:	00800593          	li	a1,8
40006364:	389020ef          	jal	ra,40008eec <shell_fprintf>
		      SYS_KERNEL_VER_MAJOR(version),
		      SYS_KERNEL_VER_MINOR(version),
		      SYS_KERNEL_VER_PATCHLEVEL(version));
	return 0;
}
40006368:	00c12083          	lw	ra,12(sp)
4000636c:	00812403          	lw	s0,8(sp)
40006370:	00000513          	li	a0,0
40006374:	01010113          	addi	sp,sp,16
40006378:	00008067          	ret

4000637c <cmd_kernel_uptime>:

static int cmd_kernel_uptime(const struct shell *sh,
			     size_t argc, char **argv)
{
4000637c:	ff010113          	addi	sp,sp,-16
40006380:	00812423          	sw	s0,8(sp)
40006384:	00112623          	sw	ra,12(sp)
40006388:	00050413          	mv	s0,a0
	return z_impl_k_uptime_ticks();
4000638c:	2c82b0ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(sh, "Uptime: %u ms", k_uptime_get_32());
40006390:	00a00693          	li	a3,10
40006394:	02a686b3          	mul	a3,a3,a0
40006398:	40033637          	lui	a2,0x40033
4000639c:	00040513          	mv	a0,s0
400063a0:	12860613          	addi	a2,a2,296 # 40033128 <severity_lvls+0x30>
400063a4:	00800593          	li	a1,8
400063a8:	345020ef          	jal	ra,40008eec <shell_fprintf>
	return 0;
}
400063ac:	00c12083          	lw	ra,12(sp)
400063b0:	00812403          	lw	s0,8(sp)
400063b4:	00000513          	li	a0,0
400063b8:	01010113          	addi	sp,sp,16
400063bc:	00008067          	ret

400063c0 <cmd_kernel_threads>:

}

static int cmd_kernel_threads(const struct shell *sh,
			      size_t argc, char **argv)
{
400063c0:	ff010113          	addi	sp,sp,-16
400063c4:	00112623          	sw	ra,12(sp)
400063c8:	00812423          	sw	s0,8(sp)
400063cc:	00050413          	mv	s0,a0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(sh, "Scheduler: %u since last call", sys_clock_elapsed());
400063d0:	3bd260ef          	jal	ra,4002cf8c <sys_clock_elapsed>
400063d4:	40033637          	lui	a2,0x40033
400063d8:	00050693          	mv	a3,a0
400063dc:	13860613          	addi	a2,a2,312 # 40033138 <severity_lvls+0x40>
400063e0:	00040513          	mv	a0,s0
400063e4:	00800593          	li	a1,8
400063e8:	305020ef          	jal	ra,40008eec <shell_fprintf>
	shell_print(sh, "Threads:");
400063ec:	40033637          	lui	a2,0x40033
400063f0:	00040513          	mv	a0,s0
400063f4:	15860613          	addi	a2,a2,344 # 40033158 <severity_lvls+0x60>
400063f8:	00800593          	li	a1,8
400063fc:	2f1020ef          	jal	ra,40008eec <shell_fprintf>
	k_thread_foreach(shell_tdata_dump, (void *)sh);
40006400:	40006537          	lui	a0,0x40006
40006404:	00040593          	mv	a1,s0
40006408:	42450513          	addi	a0,a0,1060 # 40006424 <shell_tdata_dump>
4000640c:	01d280ef          	jal	ra,4002ec28 <k_thread_foreach>
	return 0;
}
40006410:	00c12083          	lw	ra,12(sp)
40006414:	00812403          	lw	s0,8(sp)
40006418:	00000513          	li	a0,0
4000641c:	01010113          	addi	sp,sp,16
40006420:	00008067          	ret

40006424 <shell_tdata_dump>:
{
40006424:	fb010113          	addi	sp,sp,-80
40006428:	04812423          	sw	s0,72(sp)
4000642c:	04912223          	sw	s1,68(sp)
40006430:	04112623          	sw	ra,76(sp)
40006434:	05212023          	sw	s2,64(sp)
	size_t size = thread->stack_info.size;
40006438:	0b452903          	lw	s2,180(a0)
{
4000643c:	00050413          	mv	s0,a0
40006440:	00058493          	mv	s1,a1
	tname = k_thread_name_get(thread);
40006444:	0e1280ef          	jal	ra,4002ed24 <k_thread_name_get>
40006448:	00a12623          	sw	a0,12(sp)
	return z_impl_z_current_get();
4000644c:	2f92a0ef          	jal	ra,40030f44 <z_impl_z_current_get>
	shell_print(sh, "%s%p %-10s",
40006450:	00c12783          	lw	a5,12(sp)
40006454:	0ca40063          	beq	s0,a0,40006514 <shell_tdata_dump+0xf0>
40006458:	400366b7          	lui	a3,0x40036
4000645c:	72468693          	addi	a3,a3,1828 # 40036724 <CSWTCH.15846+0x10c4>
40006460:	00079663          	bnez	a5,4000646c <shell_tdata_dump+0x48>
40006464:	400337b7          	lui	a5,0x40033
40006468:	16878793          	addi	a5,a5,360 # 40033168 <severity_lvls+0x70>
4000646c:	40033637          	lui	a2,0x40033
40006470:	00040713          	mv	a4,s0
40006474:	00048513          	mv	a0,s1
40006478:	16c60613          	addi	a2,a2,364 # 4003316c <severity_lvls+0x74>
4000647c:	00800593          	li	a1,8
40006480:	26d020ef          	jal	ra,40008eec <shell_fprintf>
	shell_print(sh, "\toptions: 0x%x, priority: %d timeout: %" PRId64,
40006484:	02842803          	lw	a6,40(s0)
40006488:	02c42883          	lw	a7,44(s0)
4000648c:	00e40703          	lb	a4,14(s0)
40006490:	00c44683          	lbu	a3,12(s0)
40006494:	40033637          	lui	a2,0x40033
40006498:	00048513          	mv	a0,s1
4000649c:	17860613          	addi	a2,a2,376 # 40033178 <severity_lvls+0x80>
400064a0:	00800593          	li	a1,8
400064a4:	249020ef          	jal	ra,40008eec <shell_fprintf>
	shell_print(sh, "\tstate: %s, entry: %p",
400064a8:	02010593          	addi	a1,sp,32
400064ac:	02000613          	li	a2,32
400064b0:	00040513          	mv	a0,s0
400064b4:	079280ef          	jal	ra,4002ed2c <k_thread_state_str>
400064b8:	07842703          	lw	a4,120(s0)
400064bc:	40033637          	lui	a2,0x40033
400064c0:	00050693          	mv	a3,a0
400064c4:	1a460613          	addi	a2,a2,420 # 400331a4 <severity_lvls+0xac>
400064c8:	00800593          	li	a1,8
400064cc:	00048513          	mv	a0,s1
400064d0:	21d020ef          	jal	ra,40008eec <shell_fprintf>
	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
400064d4:	01c10593          	addi	a1,sp,28
400064d8:	00040513          	mv	a0,s0
400064dc:	49d280ef          	jal	ra,4002f178 <z_impl_k_thread_stack_space_get>
400064e0:	00050693          	mv	a3,a0
	if (ret) {
400064e4:	02050e63          	beqz	a0,40006520 <shell_tdata_dump+0xfc>
		shell_print(sh,
400064e8:	40033637          	lui	a2,0x40033
400064ec:	1bc60613          	addi	a2,a2,444 # 400331bc <severity_lvls+0xc4>
400064f0:	00800593          	li	a1,8
400064f4:	00048513          	mv	a0,s1
400064f8:	1f5020ef          	jal	ra,40008eec <shell_fprintf>
}
400064fc:	04c12083          	lw	ra,76(sp)
40006500:	04812403          	lw	s0,72(sp)
40006504:	04412483          	lw	s1,68(sp)
40006508:	04012903          	lw	s2,64(sp)
4000650c:	05010113          	addi	sp,sp,80
40006510:	00008067          	ret
	shell_print(sh, "%s%p %-10s",
40006514:	400336b7          	lui	a3,0x40033
40006518:	16468693          	addi	a3,a3,356 # 40033164 <severity_lvls+0x6c>
4000651c:	f45ff06f          	j	40006460 <shell_tdata_dump+0x3c>
		pcnt = ((size - unused) * 100U) / size;
40006520:	01c12703          	lw	a4,28(sp)
40006524:	06400893          	li	a7,100
		shell_print(sh,
40006528:	40033637          	lui	a2,0x40033
		pcnt = ((size - unused) * 100U) / size;
4000652c:	40e907b3          	sub	a5,s2,a4
40006530:	031788b3          	mul	a7,a5,a7
		shell_print(sh,
40006534:	00090813          	mv	a6,s2
40006538:	00090693          	mv	a3,s2
4000653c:	1ec60613          	addi	a2,a2,492 # 400331ec <severity_lvls+0xf4>
40006540:	00800593          	li	a1,8
40006544:	00048513          	mv	a0,s1
40006548:	0328d8b3          	divu	a7,a7,s2
4000654c:	1a1020ef          	jal	ra,40008eec <shell_fprintf>
}
40006550:	fadff06f          	j	400064fc <shell_tdata_dump+0xd8>

40006554 <cmd_kernel_stacks>:
K_KERNEL_STACK_ARRAY_DECLARE(z_interrupt_stacks, CONFIG_MP_MAX_NUM_CPUS,
			     CONFIG_ISR_STACK_SIZE);

static int cmd_kernel_stacks(const struct shell *sh,
			     size_t argc, char **argv)
{
40006554:	fb010113          	addi	sp,sp,-80
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
	char pad[THREAD_MAX_NAM_LEN] = { 0 };
40006558:	01c00613          	li	a2,28
{
4000655c:	04912223          	sw	s1,68(sp)
	char pad[THREAD_MAX_NAM_LEN] = { 0 };
40006560:	00000593          	li	a1,0
{
40006564:	00050493          	mv	s1,a0
	char pad[THREAD_MAX_NAM_LEN] = { 0 };
40006568:	02410513          	addi	a0,sp,36
{
4000656c:	04112623          	sw	ra,76(sp)
40006570:	04812423          	sw	s0,72(sp)
40006574:	05212023          	sw	s2,64(sp)
	char pad[THREAD_MAX_NAM_LEN] = { 0 };
40006578:	02012023          	sw	zero,32(sp)

	memset(pad, ' ', MAX((THREAD_MAX_NAM_LEN - strlen("IRQ 00")), 1));
4000657c:	40033937          	lui	s2,0x40033
	char pad[THREAD_MAX_NAM_LEN] = { 0 };
40006580:	79c060ef          	jal	ra,4000cd1c <memset>
	memset(pad, ' ', MAX((THREAD_MAX_NAM_LEN - strlen("IRQ 00")), 1));
40006584:	22490513          	addi	a0,s2,548 # 40033224 <severity_lvls+0x12c>
40006588:	64c060ef          	jal	ra,4000cbd4 <strlen>
4000658c:	02000413          	li	s0,32
40006590:	40a40533          	sub	a0,s0,a0
40006594:	00100793          	li	a5,1
40006598:	00100613          	li	a2,1
4000659c:	00a7f863          	bgeu	a5,a0,400065ac <cmd_kernel_stacks+0x58>
400065a0:	22490513          	addi	a0,s2,548
400065a4:	630060ef          	jal	ra,4000cbd4 <strlen>
400065a8:	40a40633          	sub	a2,s0,a0
400065ac:	02000593          	li	a1,32
400065b0:	02010513          	addi	a0,sp,32
400065b4:	768060ef          	jal	ra,4000cd1c <memset>

	k_thread_foreach(shell_stack_dump, (void *)sh);
400065b8:	40007537          	lui	a0,0x40007
400065bc:	00048593          	mv	a1,s1
400065c0:	81450513          	addi	a0,a0,-2028 # 40006814 <shell_stack_dump>
400065c4:	664280ef          	jal	ra,4002ec28 <k_thread_foreach>

	for (int i = 0; i < num_cpus; i++) {
		size_t unused;
		const uint8_t *buf = Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]);
		size_t size = K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[i]);
		int err = z_stack_space_get(buf, size, &unused);
400065c8:	00001437          	lui	s0,0x1
400065cc:	4003d937          	lui	s2,0x4003d
400065d0:	01c10613          	addi	a2,sp,28
400065d4:	80040593          	addi	a1,s0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
400065d8:	9d090513          	addi	a0,s2,-1584 # 4003c9d0 <z_interrupt_stacks>
400065dc:	371280ef          	jal	ra,4002f14c <z_stack_space_get>

		(void)err;
		__ASSERT_NO_MSG(err == 0);

		shell_print(sh,
400065e0:	01c12883          	lw	a7,28(sp)
400065e4:	80040813          	addi	a6,s0,-2048
400065e8:	06400793          	li	a5,100
400065ec:	41180733          	sub	a4,a6,a7
400065f0:	02f707b3          	mul	a5,a4,a5
400065f4:	40033637          	lui	a2,0x40033
400065f8:	00e12023          	sw	a4,0(sp)
400065fc:	00048513          	mv	a0,s1
40006600:	01012223          	sw	a6,4(sp)
40006604:	9d090693          	addi	a3,s2,-1584
40006608:	00000713          	li	a4,0
4000660c:	22c60613          	addi	a2,a2,556 # 4003322c <severity_lvls+0x134>
40006610:	00800593          	li	a1,8
40006614:	00b7d793          	srli	a5,a5,0xb
40006618:	00f12423          	sw	a5,8(sp)
4000661c:	02010793          	addi	a5,sp,32
40006620:	0cd020ef          	jal	ra,40008eec <shell_fprintf>
			    &z_interrupt_stacks[i], i, pad, size, unused, size - unused, size,
			    ((size - unused) * 100U) / size);
	}

	return 0;
}
40006624:	04c12083          	lw	ra,76(sp)
40006628:	04812403          	lw	s0,72(sp)
4000662c:	04412483          	lw	s1,68(sp)
40006630:	04012903          	lw	s2,64(sp)
40006634:	00000513          	li	a0,0
40006638:	05010113          	addi	sp,sp,80
4000663c:	00008067          	ret

40006640 <cmd_kernel_cycles>:
{
40006640:	ff010113          	addi	sp,sp,-16
40006644:	00112623          	sw	ra,12(sp)
40006648:	00812423          	sw	s0,8(sp)
4000664c:	00050413          	mv	s0,a0

extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
40006650:	119260ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
	shell_print(sh, "cycles: %u hw cycles", k_cycle_get_32());
40006654:	40033637          	lui	a2,0x40033
40006658:	00050693          	mv	a3,a0
4000665c:	27860613          	addi	a2,a2,632 # 40033278 <severity_lvls+0x180>
40006660:	00040513          	mv	a0,s0
40006664:	00800593          	li	a1,8
40006668:	085020ef          	jal	ra,40008eec <shell_fprintf>
}
4000666c:	00c12083          	lw	ra,12(sp)
40006670:	00812403          	lw	s0,8(sp)
40006674:	00000513          	li	a0,0
40006678:	01010113          	addi	sp,sp,16
4000667c:	00008067          	ret

40006680 <cmd_kernel_log_level_set>:
}

#if defined(CONFIG_LOG_RUNTIME_FILTERING)
static int cmd_kernel_log_level_set(const struct shell *sh,
				    size_t argc, char **argv)
{
40006680:	fd010113          	addi	sp,sp,-48
40006684:	02912223          	sw	s1,36(sp)
40006688:	03212023          	sw	s2,32(sp)
4000668c:	01312e23          	sw	s3,28(sp)
40006690:	02112623          	sw	ra,44(sp)
40006694:	02812423          	sw	s0,40(sp)
40006698:	01412c23          	sw	s4,24(sp)
4000669c:	00060993          	mv	s3,a2
400066a0:	00050493          	mv	s1,a0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
	int err = 0;

	uint8_t severity = shell_strtoul(argv[2], 10, &err);
400066a4:	0089a503          	lw	a0,8(s3)
400066a8:	00c10613          	addi	a2,sp,12
400066ac:	00a00593          	li	a1,10
	int err = 0;
400066b0:	00012623          	sw	zero,12(sp)
	uint8_t severity = shell_strtoul(argv[2], 10, &err);
400066b4:	570030ef          	jal	ra,40009c24 <shell_strtoul>

	if (err) {
400066b8:	00c12903          	lw	s2,12(sp)
400066bc:	04090263          	beqz	s2,40006700 <cmd_kernel_log_level_set+0x80>
		shell_error(sh, "Unable to parse log severity (err %d)", err);
400066c0:	40033637          	lui	a2,0x40033
400066c4:	00090693          	mv	a3,s2
400066c8:	29060613          	addi	a2,a2,656 # 40033290 <severity_lvls+0x198>
400066cc:	00100593          	li	a1,1
400066d0:	00048513          	mv	a0,s1
400066d4:	019020ef          	jal	ra,40008eec <shell_fprintf>

		return err;
400066d8:	00c12903          	lw	s2,12(sp)
	}

	log_filter_set(NULL, 0, (int16_t)source_id, severity);

	return 0;
}
400066dc:	02c12083          	lw	ra,44(sp)
400066e0:	02812403          	lw	s0,40(sp)
400066e4:	02412483          	lw	s1,36(sp)
400066e8:	01c12983          	lw	s3,28(sp)
400066ec:	01812a03          	lw	s4,24(sp)
400066f0:	00090513          	mv	a0,s2
400066f4:	02012903          	lw	s2,32(sp)
400066f8:	03010113          	addi	sp,sp,48
400066fc:	00008067          	ret
40006700:	0ff57713          	zext.b	a4,a0
	if (severity > LOG_LEVEL_DBG) {
40006704:	00400793          	li	a5,4
40006708:	0ff57413          	zext.b	s0,a0
4000670c:	02e7f663          	bgeu	a5,a4,40006738 <cmd_kernel_log_level_set+0xb8>
		shell_error(sh, "Invalid log level: %d", severity);
40006710:	40033637          	lui	a2,0x40033
40006714:	00040693          	mv	a3,s0
40006718:	2b860613          	addi	a2,a2,696 # 400332b8 <severity_lvls+0x1c0>
4000671c:	00100593          	li	a1,1
40006720:	00048513          	mv	a0,s1
40006724:	7c8020ef          	jal	ra,40008eec <shell_fprintf>
		shell_help(sh);
40006728:	00048513          	mv	a0,s1
4000672c:	2a5020ef          	jal	ra,400091d0 <shell_help>
		return SHELL_CMD_HELP_PRINTED;
40006730:	00100913          	li	s2,1
40006734:	fa9ff06f          	j	400066dc <cmd_kernel_log_level_set+0x5c>
	int source_id = log_source_id_get(argv[1]);
40006738:	0049a503          	lw	a0,4(s3)
4000673c:	c20fe0ef          	jal	ra,40004b5c <log_source_id_get>
40006740:	00050a13          	mv	s4,a0
	if (source_id < 0) {
40006744:	00055e63          	bgez	a0,40006760 <cmd_kernel_log_level_set+0xe0>
		shell_error(sh, "Unable to find log source: %s", argv[1]);
40006748:	0049a683          	lw	a3,4(s3)
4000674c:	40033637          	lui	a2,0x40033
40006750:	2d060613          	addi	a2,a2,720 # 400332d0 <severity_lvls+0x1d8>
40006754:	00100593          	li	a1,1
40006758:	00048513          	mv	a0,s1
4000675c:	790020ef          	jal	ra,40008eec <shell_fprintf>
40006760:	010a1613          	slli	a2,s4,0x10
40006764:	00040693          	mv	a3,s0
40006768:	41065613          	srai	a2,a2,0x10
4000676c:	00000593          	li	a1,0
40006770:	00000513          	li	a0,0
40006774:	c6cfe0ef          	jal	ra,40004be0 <z_impl_log_filter_set>
40006778:	f65ff06f          	j	400066dc <cmd_kernel_log_level_set+0x5c>

4000677c <cmd_kernel_sleep>:
{
4000677c:	fe010113          	addi	sp,sp,-32
40006780:	00812c23          	sw	s0,24(sp)
40006784:	00912a23          	sw	s1,20(sp)
40006788:	00060793          	mv	a5,a2
4000678c:	00112e23          	sw	ra,28(sp)
40006790:	00050493          	mv	s1,a0
	ms = shell_strtoul(argv[1], 10, &err);
40006794:	0047a503          	lw	a0,4(a5)
40006798:	00c10613          	addi	a2,sp,12
4000679c:	00a00593          	li	a1,10
	int err = 0;
400067a0:	00012623          	sw	zero,12(sp)
	ms = shell_strtoul(argv[1], 10, &err);
400067a4:	480030ef          	jal	ra,40009c24 <shell_strtoul>
	if (!err) {
400067a8:	00c12403          	lw	s0,12(sp)
400067ac:	04041463          	bnez	s0,400067f4 <cmd_kernel_sleep+0x78>
400067b0:	00050793          	mv	a5,a0
400067b4:	00055463          	bgez	a0,400067bc <cmd_kernel_sleep+0x40>
400067b8:	00000793          	li	a5,0
		t += off;
400067bc:	00978513          	addi	a0,a5,9
400067c0:	41f7d593          	srai	a1,a5,0x1f
400067c4:	00f537b3          	sltu	a5,a0,a5
			return t / ((uint64_t)from_hz / to_hz);
400067c8:	00a00613          	li	a2,10
400067cc:	00000693          	li	a3,0
400067d0:	00b785b3          	add	a1,a5,a1
400067d4:	ae5f90ef          	jal	ra,400002b8 <__udivdi3>
	return z_impl_k_sleep(timeout);
400067d8:	72c2a0ef          	jal	ra,40030f04 <z_impl_k_sleep>
}
400067dc:	01c12083          	lw	ra,28(sp)
400067e0:	00040513          	mv	a0,s0
400067e4:	01812403          	lw	s0,24(sp)
400067e8:	01412483          	lw	s1,20(sp)
400067ec:	02010113          	addi	sp,sp,32
400067f0:	00008067          	ret
		shell_error(sh, "Unable to parse input (err %d)", err);
400067f4:	40033637          	lui	a2,0x40033
400067f8:	00040693          	mv	a3,s0
400067fc:	2f060613          	addi	a2,a2,752 # 400332f0 <severity_lvls+0x1f8>
40006800:	00100593          	li	a1,1
40006804:	00048513          	mv	a0,s1
40006808:	6e4020ef          	jal	ra,40008eec <shell_fprintf>
		return err;
4000680c:	00c12403          	lw	s0,12(sp)
40006810:	fcdff06f          	j	400067dc <cmd_kernel_sleep+0x60>

40006814 <shell_stack_dump>:
{
40006814:	fd010113          	addi	sp,sp,-48
40006818:	02812423          	sw	s0,40(sp)
4000681c:	02912223          	sw	s1,36(sp)
40006820:	02112623          	sw	ra,44(sp)
40006824:	03212023          	sw	s2,32(sp)
	size_t size = thread->stack_info.size;
40006828:	0b452903          	lw	s2,180(a0)
{
4000682c:	00050413          	mv	s0,a0
40006830:	00058493          	mv	s1,a1
	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
40006834:	01c10593          	addi	a1,sp,28
40006838:	141280ef          	jal	ra,4002f178 <z_impl_k_thread_stack_space_get>
	if (ret) {
4000683c:	02050a63          	beqz	a0,40006870 <shell_stack_dump+0x5c>
		shell_print(sh,
40006840:	40033637          	lui	a2,0x40033
40006844:	00050693          	mv	a3,a0
40006848:	1bc60613          	addi	a2,a2,444 # 400331bc <severity_lvls+0xc4>
4000684c:	00800593          	li	a1,8
40006850:	00048513          	mv	a0,s1
40006854:	698020ef          	jal	ra,40008eec <shell_fprintf>
}
40006858:	02c12083          	lw	ra,44(sp)
4000685c:	02812403          	lw	s0,40(sp)
40006860:	02412483          	lw	s1,36(sp)
40006864:	02012903          	lw	s2,32(sp)
40006868:	03010113          	addi	sp,sp,48
4000686c:	00008067          	ret
	tname = k_thread_name_get((struct k_thread *)thread);
40006870:	00040513          	mv	a0,s0
40006874:	4b0280ef          	jal	ra,4002ed24 <k_thread_name_get>
	pcnt = ((size - unused) * 100U) / size;
40006878:	01c12803          	lw	a6,28(sp)
4000687c:	06400693          	li	a3,100
	tname = k_thread_name_get((struct k_thread *)thread);
40006880:	00050713          	mv	a4,a0
	pcnt = ((size - unused) * 100U) / size;
40006884:	410908b3          	sub	a7,s2,a6
40006888:	02d886b3          	mul	a3,a7,a3
4000688c:	0326d6b3          	divu	a3,a3,s2
	shell_print(
40006890:	00051663          	bnez	a0,4000689c <shell_stack_dump+0x88>
40006894:	40033737          	lui	a4,0x40033
40006898:	16870713          	addi	a4,a4,360 # 40033168 <severity_lvls+0x70>
4000689c:	40033637          	lui	a2,0x40033
400068a0:	00d12223          	sw	a3,4(sp)
400068a4:	01212023          	sw	s2,0(sp)
400068a8:	00090793          	mv	a5,s2
400068ac:	00040693          	mv	a3,s0
400068b0:	31060613          	addi	a2,a2,784 # 40033310 <severity_lvls+0x218>
400068b4:	00800593          	li	a1,8
400068b8:	00048513          	mv	a0,s1
400068bc:	630020ef          	jal	ra,40008eec <shell_fprintf>
400068c0:	f99ff06f          	j	40006858 <shell_stack_dump+0x44>

400068c4 <get_device_name>:
};

static const char *get_device_name(const struct device *dev,
				   char *buf,
				   size_t len)
{
400068c4:	ff010113          	addi	sp,sp,-16
400068c8:	00812423          	sw	s0,8(sp)
400068cc:	00112623          	sw	ra,12(sp)
400068d0:	00050693          	mv	a3,a0
	const char *name = dev->name;
400068d4:	00052503          	lw	a0,0(a0)
{
400068d8:	00058413          	mv	s0,a1
400068dc:	00060593          	mv	a1,a2

	if ((name == NULL) || (name[0] == 0)) {
400068e0:	00050663          	beqz	a0,400068ec <get_device_name+0x28>
400068e4:	00054783          	lbu	a5,0(a0)
400068e8:	00079c63          	bnez	a5,40006900 <get_device_name+0x3c>
		snprintf(buf, len, "[%p]", dev);
400068ec:	40033637          	lui	a2,0x40033
400068f0:	4e060613          	addi	a2,a2,1248 # 400334e0 <shell_sub_kernel+0xa0>
400068f4:	00040513          	mv	a0,s0
400068f8:	4b8060ef          	jal	ra,4000cdb0 <snprintf>
		name = buf;
400068fc:	00040513          	mv	a0,s0
	}

	return name;
}
40006900:	00c12083          	lw	ra,12(sp)
40006904:	00812403          	lw	s0,8(sp)
40006908:	01010113          	addi	sp,sp,16
4000690c:	00008067          	ret

40006910 <cmd_device_list_visitor>:
	size_t buf_size;
};

static int cmd_device_list_visitor(const struct device *dev,
				   void *context)
{
40006910:	ff010113          	addi	sp,sp,-16
40006914:	00112623          	sw	ra,12(sp)
40006918:	00812423          	sw	s0,8(sp)
	const struct cmd_device_list_visitor_context *ctx = context;

	shell_fprintf(ctx->sh, SHELL_NORMAL, "  requires: %s\n",
4000691c:	0005a403          	lw	s0,0(a1)
40006920:	0085a603          	lw	a2,8(a1)
40006924:	0045a583          	lw	a1,4(a1)
40006928:	f9dff0ef          	jal	ra,400068c4 <get_device_name>
4000692c:	40033637          	lui	a2,0x40033
40006930:	00050693          	mv	a3,a0
40006934:	4e860613          	addi	a2,a2,1256 # 400334e8 <shell_sub_kernel+0xa8>
40006938:	00040513          	mv	a0,s0
4000693c:	00800593          	li	a1,8
40006940:	5ac020ef          	jal	ra,40008eec <shell_fprintf>
		      get_device_name(dev, ctx->buf, ctx->buf_size));

	return 0;
}
40006944:	00c12083          	lw	ra,12(sp)
40006948:	00812403          	lw	s0,8(sp)
4000694c:	00000513          	li	a0,0
40006950:	01010113          	addi	sp,sp,16
40006954:	00008067          	ret

40006958 <cmd_device_list>:

static int cmd_device_list(const struct shell *sh,
			   size_t argc, char **argv)
{
40006958:	fa010113          	addi	sp,sp,-96
4000695c:	04912a23          	sw	s1,84(sp)
40006960:	00050493          	mv	s1,a0
	const struct device *devlist;
	size_t devcnt = z_device_get_all_static(&devlist);
40006964:	00c10513          	addi	a0,sp,12
{
40006968:	04112e23          	sw	ra,92(sp)
4000696c:	04812c23          	sw	s0,88(sp)
40006970:	05212823          	sw	s2,80(sp)
40006974:	05312623          	sw	s3,76(sp)
40006978:	05412423          	sw	s4,72(sp)
4000697c:	05512223          	sw	s5,68(sp)
40006980:	05612023          	sw	s6,64(sp)
40006984:	03712e23          	sw	s7,60(sp)
40006988:	03812c23          	sw	s8,56(sp)
	size_t devcnt = z_device_get_all_static(&devlist);
4000698c:	161270ef          	jal	ra,4002e2ec <z_device_get_all_static>
	const struct device *devlist_end = devlist + devcnt;
40006990:	01800793          	li	a5,24
40006994:	02f50533          	mul	a0,a0,a5
40006998:	00c12903          	lw	s2,12(sp)
	const struct device *dev;

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_fprintf(sh, SHELL_NORMAL, "devices:\n");
4000699c:	40033637          	lui	a2,0x40033
400069a0:	50c60613          	addi	a2,a2,1292 # 4003350c <shell_sub_kernel+0xcc>
400069a4:	00800593          	li	a1,8
		const char *name = get_device_name(dev, buf, sizeof(buf));
		const char *state = "READY";

		shell_fprintf(sh, SHELL_NORMAL, "- %s", name);
		if (!device_is_ready(dev)) {
			state = "DISABLED";
400069a8:	400339b7          	lui	s3,0x40033
		const char *state = "READY";
400069ac:	40033a37          	lui	s4,0x40033
		const char *name = get_device_name(dev, buf, sizeof(buf));
400069b0:	01c10a93          	addi	s5,sp,28
		shell_fprintf(sh, SHELL_NORMAL, "- %s", name);
400069b4:	40033b37          	lui	s6,0x40033
			state = "DISABLED";
400069b8:	50098993          	addi	s3,s3,1280 # 40033500 <shell_sub_kernel+0xc0>
	const struct device *devlist_end = devlist + devcnt;
400069bc:	00a90933          	add	s2,s2,a0
	shell_fprintf(sh, SHELL_NORMAL, "devices:\n");
400069c0:	00048513          	mv	a0,s1
400069c4:	528020ef          	jal	ra,40008eec <shell_fprintf>
	for (dev = devlist; dev < devlist_end; dev++) {
400069c8:	00c12403          	lw	s0,12(sp)
		const char *state = "READY";
400069cc:	4f8a0a13          	addi	s4,s4,1272 # 400334f8 <shell_sub_kernel+0xb8>
				state = pm_device_state_str(st);
			}
#endif /* CONFIG_PM_DEVICE */
		}

		shell_fprintf(sh, SHELL_NORMAL, " (%s)\n", state);
400069d0:	40033bb7          	lui	s7,0x40033
				.sh = sh,
				.buf = buf,
				.buf_size = sizeof(buf),
			};

			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
400069d4:	40007c37          	lui	s8,0x40007
	for (dev = devlist; dev < devlist_end; dev++) {
400069d8:	03246c63          	bltu	s0,s2,40006a10 <cmd_device_list+0xb8>
		}
	}

	return 0;
}
400069dc:	05c12083          	lw	ra,92(sp)
400069e0:	05812403          	lw	s0,88(sp)
400069e4:	05412483          	lw	s1,84(sp)
400069e8:	05012903          	lw	s2,80(sp)
400069ec:	04c12983          	lw	s3,76(sp)
400069f0:	04812a03          	lw	s4,72(sp)
400069f4:	04412a83          	lw	s5,68(sp)
400069f8:	04012b03          	lw	s6,64(sp)
400069fc:	03c12b83          	lw	s7,60(sp)
40006a00:	03812c03          	lw	s8,56(sp)
40006a04:	00000513          	li	a0,0
40006a08:	06010113          	addi	sp,sp,96
40006a0c:	00008067          	ret
		const char *name = get_device_name(dev, buf, sizeof(buf));
40006a10:	000a8593          	mv	a1,s5
40006a14:	01400613          	li	a2,20
40006a18:	00040513          	mv	a0,s0
40006a1c:	ea9ff0ef          	jal	ra,400068c4 <get_device_name>
40006a20:	00050693          	mv	a3,a0
		shell_fprintf(sh, SHELL_NORMAL, "- %s", name);
40006a24:	518b0613          	addi	a2,s6,1304 # 40033518 <shell_sub_kernel+0xd8>
40006a28:	00800593          	li	a1,8
40006a2c:	00048513          	mv	a0,s1
40006a30:	4bc020ef          	jal	ra,40008eec <shell_fprintf>
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
40006a34:	00040513          	mv	a0,s0
40006a38:	0e1270ef          	jal	ra,4002e318 <z_device_is_ready>
			state = "DISABLED";
40006a3c:	00098693          	mv	a3,s3
		if (!device_is_ready(dev)) {
40006a40:	00050463          	beqz	a0,40006a48 <cmd_device_list+0xf0>
		const char *state = "READY";
40006a44:	000a0693          	mv	a3,s4
		shell_fprintf(sh, SHELL_NORMAL, " (%s)\n", state);
40006a48:	520b8613          	addi	a2,s7,1312 # 40033520 <shell_sub_kernel+0xe0>
40006a4c:	00800593          	li	a1,8
40006a50:	00048513          	mv	a0,s1
40006a54:	498020ef          	jal	ra,40008eec <shell_fprintf>
			struct cmd_device_list_visitor_context ctx = {
40006a58:	01400793          	li	a5,20
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
40006a5c:	00040513          	mv	a0,s0
40006a60:	01010613          	addi	a2,sp,16
40006a64:	910c0593          	addi	a1,s8,-1776 # 40006910 <cmd_device_list_visitor>
			struct cmd_device_list_visitor_context ctx = {
40006a68:	00912823          	sw	s1,16(sp)
40006a6c:	01512a23          	sw	s5,20(sp)
40006a70:	00f12c23          	sw	a5,24(sp)
	for (dev = devlist; dev < devlist_end; dev++) {
40006a74:	01840413          	addi	s0,s0,24
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
40006a78:	0cd270ef          	jal	ra,4002e344 <device_required_foreach>
	for (dev = devlist; dev < devlist_end; dev++) {
40006a7c:	f5dff06f          	j	400069d8 <cmd_device_list+0x80>

40006a80 <device_get_config_level>:
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
40006a80:	00259713          	slli	a4,a1,0x2
40006a84:	400337b7          	lui	a5,0x40033
40006a88:	00158593          	addi	a1,a1,1
40006a8c:	63478793          	addi	a5,a5,1588 # 40033634 <levels>
40006a90:	00259593          	slli	a1,a1,0x2
{
40006a94:	fc010113          	addi	sp,sp,-64
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
40006a98:	00e78733          	add	a4,a5,a4
40006a9c:	00b787b3          	add	a5,a5,a1
{
40006aa0:	02812c23          	sw	s0,56(sp)
40006aa4:	03412423          	sw	s4,40(sp)
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
40006aa8:	00072403          	lw	s0,0(a4)
40006aac:	0007aa03          	lw	s4,0(a5)
{
40006ab0:	03212823          	sw	s2,48(sp)
40006ab4:	03312623          	sw	s3,44(sp)
40006ab8:	03512223          	sw	s5,36(sp)
40006abc:	02112e23          	sw	ra,60(sp)
40006ac0:	02912a23          	sw	s1,52(sp)
40006ac4:	00050913          	mv	s2,a0
	bool devices = false;
40006ac8:	00000993          	li	s3,0
			shell_fprintf(sh, SHELL_NORMAL, "- %s\n",
40006acc:	40033ab7          	lui	s5,0x40033
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
40006ad0:	03446663          	bltu	s0,s4,40006afc <device_get_config_level+0x7c>
}
40006ad4:	03c12083          	lw	ra,60(sp)
40006ad8:	03812403          	lw	s0,56(sp)
40006adc:	03412483          	lw	s1,52(sp)
40006ae0:	03012903          	lw	s2,48(sp)
40006ae4:	02812a03          	lw	s4,40(sp)
40006ae8:	02412a83          	lw	s5,36(sp)
40006aec:	00098513          	mv	a0,s3
40006af0:	02c12983          	lw	s3,44(sp)
40006af4:	04010113          	addi	sp,sp,64
40006af8:	00008067          	ret
40006afc:	00040513          	mv	a0,s0
40006b00:	019270ef          	jal	ra,4002e318 <z_device_is_ready>
40006b04:	00050493          	mv	s1,a0
		if (device_is_ready(dev)) {
40006b08:	02050663          	beqz	a0,40006b34 <device_get_config_level+0xb4>
			shell_fprintf(sh, SHELL_NORMAL, "- %s\n",
40006b0c:	01400613          	li	a2,20
40006b10:	00c10593          	addi	a1,sp,12
40006b14:	00040513          	mv	a0,s0
40006b18:	dadff0ef          	jal	ra,400068c4 <get_device_name>
40006b1c:	00050693          	mv	a3,a0
40006b20:	528a8613          	addi	a2,s5,1320 # 40033528 <shell_sub_kernel+0xe8>
40006b24:	00800593          	li	a1,8
40006b28:	00090513          	mv	a0,s2
40006b2c:	3c0020ef          	jal	ra,40008eec <shell_fprintf>
			devices = true;
40006b30:	00048993          	mv	s3,s1
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
40006b34:	01840413          	addi	s0,s0,24
40006b38:	f99ff06f          	j	40006ad0 <device_get_config_level+0x50>

40006b3c <cmd_device_levels>:
	shell_fprintf(sh, SHELL_NORMAL, "EARLY:\n");
40006b3c:	40033637          	lui	a2,0x40033
{
40006b40:	ff010113          	addi	sp,sp,-16
	shell_fprintf(sh, SHELL_NORMAL, "EARLY:\n");
40006b44:	00800593          	li	a1,8
40006b48:	53060613          	addi	a2,a2,1328 # 40033530 <shell_sub_kernel+0xf0>
{
40006b4c:	00812423          	sw	s0,8(sp)
40006b50:	00112623          	sw	ra,12(sp)
40006b54:	00050413          	mv	s0,a0
	shell_fprintf(sh, SHELL_NORMAL, "EARLY:\n");
40006b58:	394020ef          	jal	ra,40008eec <shell_fprintf>
	ret = device_get_config_level(sh, INIT_LEVEL_EARLY);
40006b5c:	00000593          	li	a1,0
40006b60:	00040513          	mv	a0,s0
40006b64:	f1dff0ef          	jal	ra,40006a80 <device_get_config_level>
	if (ret == false) {
40006b68:	00051c63          	bnez	a0,40006b80 <cmd_device_levels+0x44>
		shell_fprintf(sh, SHELL_NORMAL, "- None\n");
40006b6c:	40033637          	lui	a2,0x40033
40006b70:	53860613          	addi	a2,a2,1336 # 40033538 <shell_sub_kernel+0xf8>
40006b74:	00800593          	li	a1,8
40006b78:	00040513          	mv	a0,s0
40006b7c:	370020ef          	jal	ra,40008eec <shell_fprintf>
	shell_fprintf(sh, SHELL_NORMAL, "PRE KERNEL 1:\n");
40006b80:	40033637          	lui	a2,0x40033
40006b84:	00800593          	li	a1,8
40006b88:	00040513          	mv	a0,s0
40006b8c:	54060613          	addi	a2,a2,1344 # 40033540 <shell_sub_kernel+0x100>
40006b90:	35c020ef          	jal	ra,40008eec <shell_fprintf>
	ret = device_get_config_level(sh, INIT_LEVEL_PRE_KERNEL_1);
40006b94:	00100593          	li	a1,1
40006b98:	00040513          	mv	a0,s0
40006b9c:	ee5ff0ef          	jal	ra,40006a80 <device_get_config_level>
	if (ret == false) {
40006ba0:	00051c63          	bnez	a0,40006bb8 <cmd_device_levels+0x7c>
		shell_fprintf(sh, SHELL_NORMAL, "- None\n");
40006ba4:	40033637          	lui	a2,0x40033
40006ba8:	53860613          	addi	a2,a2,1336 # 40033538 <shell_sub_kernel+0xf8>
40006bac:	00800593          	li	a1,8
40006bb0:	00040513          	mv	a0,s0
40006bb4:	338020ef          	jal	ra,40008eec <shell_fprintf>
	shell_fprintf(sh, SHELL_NORMAL, "PRE KERNEL 2:\n");
40006bb8:	40033637          	lui	a2,0x40033
40006bbc:	00800593          	li	a1,8
40006bc0:	00040513          	mv	a0,s0
40006bc4:	55060613          	addi	a2,a2,1360 # 40033550 <shell_sub_kernel+0x110>
40006bc8:	324020ef          	jal	ra,40008eec <shell_fprintf>
	ret = device_get_config_level(sh, INIT_LEVEL_PRE_KERNEL_2);
40006bcc:	00200593          	li	a1,2
40006bd0:	00040513          	mv	a0,s0
40006bd4:	eadff0ef          	jal	ra,40006a80 <device_get_config_level>
	if (ret == false) {
40006bd8:	00051c63          	bnez	a0,40006bf0 <cmd_device_levels+0xb4>
		shell_fprintf(sh, SHELL_NORMAL, "- None\n");
40006bdc:	40033637          	lui	a2,0x40033
40006be0:	53860613          	addi	a2,a2,1336 # 40033538 <shell_sub_kernel+0xf8>
40006be4:	00800593          	li	a1,8
40006be8:	00040513          	mv	a0,s0
40006bec:	300020ef          	jal	ra,40008eec <shell_fprintf>
	shell_fprintf(sh, SHELL_NORMAL, "POST_KERNEL:\n");
40006bf0:	40033637          	lui	a2,0x40033
40006bf4:	00800593          	li	a1,8
40006bf8:	00040513          	mv	a0,s0
40006bfc:	56060613          	addi	a2,a2,1376 # 40033560 <shell_sub_kernel+0x120>
40006c00:	2ec020ef          	jal	ra,40008eec <shell_fprintf>
	ret = device_get_config_level(sh, INIT_LEVEL_POST_KERNEL);
40006c04:	00300593          	li	a1,3
40006c08:	00040513          	mv	a0,s0
40006c0c:	e75ff0ef          	jal	ra,40006a80 <device_get_config_level>
	if (ret == false) {
40006c10:	00051c63          	bnez	a0,40006c28 <cmd_device_levels+0xec>
		shell_fprintf(sh, SHELL_NORMAL, "- None\n");
40006c14:	40033637          	lui	a2,0x40033
40006c18:	53860613          	addi	a2,a2,1336 # 40033538 <shell_sub_kernel+0xf8>
40006c1c:	00800593          	li	a1,8
40006c20:	00040513          	mv	a0,s0
40006c24:	2c8020ef          	jal	ra,40008eec <shell_fprintf>
	shell_fprintf(sh, SHELL_NORMAL, "APPLICATION:\n");
40006c28:	40033637          	lui	a2,0x40033
40006c2c:	00800593          	li	a1,8
40006c30:	00040513          	mv	a0,s0
40006c34:	57060613          	addi	a2,a2,1392 # 40033570 <shell_sub_kernel+0x130>
40006c38:	2b4020ef          	jal	ra,40008eec <shell_fprintf>
	ret = device_get_config_level(sh, INIT_LEVEL_APPLICATION);
40006c3c:	00400593          	li	a1,4
40006c40:	00040513          	mv	a0,s0
40006c44:	e3dff0ef          	jal	ra,40006a80 <device_get_config_level>
	if (ret == false) {
40006c48:	00051c63          	bnez	a0,40006c60 <cmd_device_levels+0x124>
		shell_fprintf(sh, SHELL_NORMAL, "- None\n");
40006c4c:	40033637          	lui	a2,0x40033
40006c50:	53860613          	addi	a2,a2,1336 # 40033538 <shell_sub_kernel+0xf8>
40006c54:	00800593          	li	a1,8
40006c58:	00040513          	mv	a0,s0
40006c5c:	290020ef          	jal	ra,40008eec <shell_fprintf>
}
40006c60:	00c12083          	lw	ra,12(sp)
40006c64:	00812403          	lw	s0,8(sp)
40006c68:	00000513          	li	a0,0
40006c6c:	01010113          	addi	sp,sp,16
40006c70:	00008067          	ret

40006c74 <cmd_devmem>:
	return err;
}

/* The syntax of the command is similar to busybox's devmem */
static int cmd_devmem(const struct shell *sh, size_t argc, char **argv)
{
40006c74:	fe010113          	addi	sp,sp,-32
40006c78:	01312623          	sw	s3,12(sp)
40006c7c:	00112e23          	sw	ra,28(sp)
40006c80:	00812c23          	sw	s0,24(sp)
40006c84:	00912a23          	sw	s1,20(sp)
40006c88:	01212823          	sw	s2,16(sp)
40006c8c:	01412423          	sw	s4,8(sp)
40006c90:	01512223          	sw	s5,4(sp)
	mem_addr_t phys_addr, addr;
	uint32_t value = 0;
	uint8_t width;

	if (argc < 2 || argc > 4) {
40006c94:	ffe58793          	addi	a5,a1,-2
40006c98:	00200993          	li	s3,2
40006c9c:	0ef9ec63          	bltu	s3,a5,40006d94 <cmd_devmem+0x120>
40006ca0:	00060413          	mv	s0,a2
		return -EINVAL;
	}

	phys_addr = strtoul(argv[1], NULL, 16);
40006ca4:	00050913          	mv	s2,a0
40006ca8:	00442503          	lw	a0,4(s0)
40006cac:	00058a13          	mv	s4,a1
40006cb0:	01000613          	li	a2,16
40006cb4:	00000593          	li	a1,0
40006cb8:	461050ef          	jal	ra,4000c918 <strtoul>
40006cbc:	00050493          	mv	s1,a0
	shell_print(sh, "Mapped 0x%lx to 0x%lx\n", phys_addr, addr);
#else
	addr = phys_addr;
#endif /* defined(CONFIG_MMU) || defined(CONFIG_PCIE) */

	if (argc < 3) {
40006cc0:	40033ab7          	lui	s5,0x40033
40006cc4:	033a1063          	bne	s4,s3,40006ce4 <cmd_devmem+0x70>
		width = 32;
	} else {
		width = strtoul(argv[2], NULL, 10);
	}

	shell_fprintf(sh, SHELL_NORMAL, "Using data width %d\n", width);
40006cc8:	02000693          	li	a3,32
40006ccc:	64ca8613          	addi	a2,s5,1612 # 4003364c <levels+0x18>
40006cd0:	00800593          	li	a1,8
40006cd4:	00090513          	mv	a0,s2
40006cd8:	214020ef          	jal	ra,40008eec <shell_fprintf>
	*(volatile uint16_t *)addr = data;
}

static ALWAYS_INLINE uint32_t sys_read32(mem_addr_t addr)
{
	return *(volatile uint32_t *)addr;
40006cdc:	0004a683          	lw	a3,0(s1)
	if (err == 0) {
40006ce0:	0540006f          	j	40006d34 <cmd_devmem+0xc0>
		width = strtoul(argv[2], NULL, 10);
40006ce4:	00842503          	lw	a0,8(s0)
40006ce8:	00a00613          	li	a2,10
40006cec:	00000593          	li	a1,0
40006cf0:	429050ef          	jal	ra,4000c918 <strtoul>
40006cf4:	0ff57993          	zext.b	s3,a0
	shell_fprintf(sh, SHELL_NORMAL, "Using data width %d\n", width);
40006cf8:	00098693          	mv	a3,s3
40006cfc:	64ca8613          	addi	a2,s5,1612
40006d00:	00800593          	li	a1,8
40006d04:	00090513          	mv	a0,s2
40006d08:	1e4020ef          	jal	ra,40008eec <shell_fprintf>

	if (argc <= 3) {
40006d0c:	00400793          	li	a5,4
40006d10:	08fa0663          	beq	s4,a5,40006d9c <cmd_devmem+0x128>
	switch (width) {
40006d14:	01000793          	li	a5,16
40006d18:	04f98c63          	beq	s3,a5,40006d70 <cmd_devmem+0xfc>
40006d1c:	02000793          	li	a5,32
40006d20:	faf98ee3          	beq	s3,a5,40006cdc <cmd_devmem+0x68>
40006d24:	00800793          	li	a5,8
40006d28:	04f99c63          	bne	s3,a5,40006d80 <cmd_devmem+0x10c>
	return *(volatile uint8_t *)addr;
40006d2c:	0004c683          	lbu	a3,0(s1)
40006d30:	0ff6f693          	zext.b	a3,a3
		shell_fprintf(sh, SHELL_NORMAL, "Read value 0x%x\n", value);
40006d34:	40033637          	lui	a2,0x40033
40006d38:	67c60613          	addi	a2,a2,1660 # 4003367c <levels+0x48>
40006d3c:	00800593          	li	a1,8
40006d40:	00090513          	mv	a0,s2
40006d44:	1a8020ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
40006d48:	00000513          	li	a0,0
	value = strtoul(argv[3], NULL, 16);

	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);

	return memory_write(sh, addr, width, value);
}
40006d4c:	01c12083          	lw	ra,28(sp)
40006d50:	01812403          	lw	s0,24(sp)
40006d54:	01412483          	lw	s1,20(sp)
40006d58:	01012903          	lw	s2,16(sp)
40006d5c:	00c12983          	lw	s3,12(sp)
40006d60:	00812a03          	lw	s4,8(sp)
40006d64:	00412a83          	lw	s5,4(sp)
40006d68:	02010113          	addi	sp,sp,32
40006d6c:	00008067          	ret
	return *(volatile uint16_t *)addr;
40006d70:	0004d683          	lhu	a3,0(s1)
40006d74:	01069693          	slli	a3,a3,0x10
40006d78:	0106d693          	srli	a3,a3,0x10
	if (err == 0) {
40006d7c:	fb9ff06f          	j	40006d34 <cmd_devmem+0xc0>
		shell_fprintf(sh, SHELL_NORMAL, "Incorrect data width\n");
40006d80:	40033637          	lui	a2,0x40033
40006d84:	66460613          	addi	a2,a2,1636 # 40033664 <levels+0x30>
40006d88:	00800593          	li	a1,8
40006d8c:	00090513          	mv	a0,s2
40006d90:	15c020ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
40006d94:	fea00513          	li	a0,-22
40006d98:	fb5ff06f          	j	40006d4c <cmd_devmem+0xd8>
	value = strtoul(argv[3], NULL, 16);
40006d9c:	00c42503          	lw	a0,12(s0)
40006da0:	01000613          	li	a2,16
40006da4:	00000593          	li	a1,0
40006da8:	371050ef          	jal	ra,4000c918 <strtoul>
	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);
40006dac:	40033637          	lui	a2,0x40033
40006db0:	00050693          	mv	a3,a0
	value = strtoul(argv[3], NULL, 16);
40006db4:	00050413          	mv	s0,a0
	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);
40006db8:	69060613          	addi	a2,a2,1680 # 40033690 <levels+0x5c>
40006dbc:	00800593          	li	a1,8
40006dc0:	00090513          	mv	a0,s2
40006dc4:	128020ef          	jal	ra,40008eec <shell_fprintf>
	switch (width) {
40006dc8:	01000793          	li	a5,16
40006dcc:	02f98063          	beq	s3,a5,40006dec <cmd_devmem+0x178>
40006dd0:	02000793          	li	a5,32
40006dd4:	02f98463          	beq	s3,a5,40006dfc <cmd_devmem+0x188>
40006dd8:	00800793          	li	a5,8
40006ddc:	faf992e3          	bne	s3,a5,40006d80 <cmd_devmem+0x10c>
		sys_write8(value, addr);
40006de0:	0ff47413          	zext.b	s0,s0
	*(volatile uint8_t *)addr = data;
40006de4:	00848023          	sb	s0,0(s1)
}
40006de8:	f61ff06f          	j	40006d48 <cmd_devmem+0xd4>
		sys_write16(value, addr);
40006dec:	01041413          	slli	s0,s0,0x10
40006df0:	01045413          	srli	s0,s0,0x10
	*(volatile uint16_t *)addr = data;
40006df4:	00849023          	sh	s0,0(s1)
}
40006df8:	f51ff06f          	j	40006d48 <cmd_devmem+0xd4>
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	*(volatile uint32_t *)addr = data;
40006dfc:	0084a023          	sw	s0,0(s1)
}
40006e00:	f49ff06f          	j	40006d48 <cmd_devmem+0xd4>

40006e04 <set_bypass.isra.0>:
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
40006e04:	ff010113          	addi	sp,sp,-16
40006e08:	00812423          	sw	s0,8(sp)
40006e0c:	00912223          	sw	s1,4(sp)
40006e10:	01212023          	sw	s2,0(sp)
40006e14:	00112623          	sw	ra,12(sp)
	if (bypass && in_use) {
40006e18:	40039937          	lui	s2,0x40039
40006e1c:	10694783          	lbu	a5,262(s2) # 40039106 <in_use.0>
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
40006e20:	00050413          	mv	s0,a0
40006e24:	00058493          	mv	s1,a1
	if (bypass && in_use) {
40006e28:	04058a63          	beqz	a1,40006e7c <set_bypass.isra.0+0x78>
40006e2c:	02078463          	beqz	a5,40006e54 <set_bypass.isra.0+0x50>
}
40006e30:	00812403          	lw	s0,8(sp)
40006e34:	00c12083          	lw	ra,12(sp)
40006e38:	00412483          	lw	s1,4(sp)
40006e3c:	00012903          	lw	s2,0(sp)
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
40006e40:	40033637          	lui	a2,0x40033
40006e44:	6a460613          	addi	a2,a2,1700 # 400336a4 <levels+0x70>
40006e48:	00100593          	li	a1,1
}
40006e4c:	01010113          	addi	sp,sp,16
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
40006e50:	09c0206f          	j	40008eec <shell_fprintf>
	in_use = !in_use;
40006e54:	00100793          	li	a5,1
40006e58:	10f90323          	sb	a5,262(s2)
		shell_print(sh, "Loading...\npress ctrl-x ctrl-q to escape");
40006e5c:	40033637          	lui	a2,0x40033
40006e60:	6e060613          	addi	a2,a2,1760 # 400336e0 <levels+0xac>
40006e64:	00800593          	li	a1,8
40006e68:	00040513          	mv	a0,s0
40006e6c:	080020ef          	jal	ra,40008eec <shell_fprintf>
		in_use = true;
40006e70:	00100793          	li	a5,1
40006e74:	10f90323          	sb	a5,262(s2)
40006e78:	0100006f          	j	40006e88 <set_bypass.isra.0+0x84>
	in_use = !in_use;
40006e7c:	0017c793          	xori	a5,a5,1
40006e80:	10f90323          	sb	a5,262(s2)
	if (in_use) {
40006e84:	fc079ce3          	bnez	a5,40006e5c <set_bypass.isra.0+0x58>
	shell_set_bypass(sh, bypass);
40006e88:	00040513          	mv	a0,s0
}
40006e8c:	00812403          	lw	s0,8(sp)
40006e90:	00c12083          	lw	ra,12(sp)
40006e94:	00012903          	lw	s2,0(sp)
	shell_set_bypass(sh, bypass);
40006e98:	00048593          	mv	a1,s1
}
40006e9c:	00412483          	lw	s1,4(sp)
40006ea0:	01010113          	addi	sp,sp,16
	shell_set_bypass(sh, bypass);
40006ea4:	3880206f          	j	4000922c <shell_set_bypass>

40006ea8 <bypass_cb>:
	if (tail == CHAR_CAN && recv[0] == CHAR_DC1) {
40006ea8:	40039737          	lui	a4,0x40039
40006eac:	10774683          	lbu	a3,263(a4) # 40039107 <tail.1>
{
40006eb0:	fe010113          	addi	sp,sp,-32
40006eb4:	00112e23          	sw	ra,28(sp)
40006eb8:	00812c23          	sw	s0,24(sp)
	if (tail == CHAR_CAN && recv[0] == CHAR_DC1) {
40006ebc:	01800793          	li	a5,24
40006ec0:	00f69863          	bne	a3,a5,40006ed0 <bypass_cb+0x28>
40006ec4:	0005c683          	lbu	a3,0(a1)
40006ec8:	01100793          	li	a5,17
40006ecc:	0cf68663          	beq	a3,a5,40006f98 <bypass_cb+0xf0>
40006ed0:	00158793          	addi	a5,a1,1
40006ed4:	00c58633          	add	a2,a1,a2
			if (recv[i] == CHAR_CAN && recv[i + 1] == CHAR_DC1) {
40006ed8:	01800693          	li	a3,24
40006edc:	01100813          	li	a6,17
		for (int i = 0; i < (len - 1); i++) {
40006ee0:	0ac79063          	bne	a5,a2,40006f80 <bypass_cb+0xd8>
	tail = recv[len - 1];
40006ee4:	fff7c783          	lbu	a5,-1(a5)
	if (is_ascii(*recv)) {
40006ee8:	0005c683          	lbu	a3,0(a1)
40006eec:	40039437          	lui	s0,0x40039
	tail = recv[len - 1];
40006ef0:	10f703a3          	sb	a5,263(a4)
	return (data >= 0x30 && data <= 0x39) || (data >= 0x61 && data <= 0x66) ||
40006ef4:	fd068793          	addi	a5,a3,-48
40006ef8:	0ff7f793          	zext.b	a5,a5
40006efc:	00900713          	li	a4,9
40006f00:	00f77c63          	bgeu	a4,a5,40006f18 <bypass_cb+0x70>
40006f04:	fdf6f793          	andi	a5,a3,-33
40006f08:	fbf78793          	addi	a5,a5,-65
40006f0c:	0ff7f793          	zext.b	a5,a5
40006f10:	00500713          	li	a4,5
40006f14:	02f76063          	bltu	a4,a5,40006f34 <bypass_cb+0x8c>
		chunk[chunk_element] = *recv;
40006f18:	ffc42703          	lw	a4,-4(s0) # 40038ffc <chunk_element>
40006f1c:	400397b7          	lui	a5,0x40039
40006f20:	ff878793          	addi	a5,a5,-8 # 40038ff8 <chunk>
40006f24:	00f707b3          	add	a5,a4,a5
		chunk_element++;
40006f28:	00170713          	addi	a4,a4,1
		chunk[chunk_element] = *recv;
40006f2c:	00d78023          	sb	a3,0(a5)
		chunk_element++;
40006f30:	fee42e23          	sw	a4,-4(s0)
	if (chunk_element == 2) {
40006f34:	ffc42703          	lw	a4,-4(s0)
40006f38:	00200793          	li	a5,2
40006f3c:	10f71063          	bne	a4,a5,4000703c <bypass_cb+0x194>
		byte = (uint8_t)strtoul(chunk, NULL, 16);
40006f40:	40039537          	lui	a0,0x40039
40006f44:	01000613          	li	a2,16
40006f48:	00000593          	li	a1,0
40006f4c:	ff850513          	addi	a0,a0,-8 # 40038ff8 <chunk>
40006f50:	1c9050ef          	jal	ra,4000c918 <strtoul>
		*bytes = byte;
40006f54:	40039737          	lui	a4,0x40039
40006f58:	00872783          	lw	a5,8(a4) # 40039008 <bytes>
		chunk_element = 0;
40006f5c:	fe042e23          	sw	zero,-4(s0)
		byte = (uint8_t)strtoul(chunk, NULL, 16);
40006f60:	00a78023          	sb	a0,0(a5)
		bytes++;
40006f64:	00178793          	addi	a5,a5,1
40006f68:	00f72423          	sw	a5,8(a4)
		sum++;
40006f6c:	40039737          	lui	a4,0x40039
40006f70:	00072783          	lw	a5,0(a4) # 40039000 <sum>
40006f74:	00178793          	addi	a5,a5,1
40006f78:	00f72023          	sw	a5,0(a4)
		chunk_element = 0;
40006f7c:	0c00006f          	j	4000703c <bypass_cb+0x194>
			if (recv[i] == CHAR_CAN && recv[i + 1] == CHAR_DC1) {
40006f80:	fff7c883          	lbu	a7,-1(a5)
40006f84:	00d89663          	bne	a7,a3,40006f90 <bypass_cb+0xe8>
40006f88:	0007c883          	lbu	a7,0(a5)
40006f8c:	01088663          	beq	a7,a6,40006f98 <bypass_cb+0xf0>
		for (int i = 0; i < (len - 1); i++) {
40006f90:	00178793          	addi	a5,a5,1
40006f94:	f4dff06f          	j	40006ee0 <bypass_cb+0x38>
		shell_print(sh, "Number of bytes read: %d", sum);
40006f98:	40039437          	lui	s0,0x40039
40006f9c:	00042683          	lw	a3,0(s0) # 40039000 <sum>
40006fa0:	40033637          	lui	a2,0x40033
40006fa4:	70c60613          	addi	a2,a2,1804 # 4003370c <levels+0xd8>
40006fa8:	00800593          	li	a1,8
40006fac:	00a12623          	sw	a0,12(sp)
40006fb0:	73d010ef          	jal	ra,40008eec <shell_fprintf>
		set_bypass(sh, NULL);
40006fb4:	00c12503          	lw	a0,12(sp)
40006fb8:	00000593          	li	a1,0
40006fbc:	e49ff0ef          	jal	ra,40006e04 <set_bypass.isra.0>
		if (!littleendian) {
40006fc0:	400397b7          	lui	a5,0x40039
40006fc4:	1087c703          	lbu	a4,264(a5) # 40039108 <littleendian>
40006fc8:	06071a63          	bnez	a4,4000703c <bypass_cb+0x194>
40006fcc:	40039637          	lui	a2,0x40039
40006fd0:	00462583          	lw	a1,4(a2) # 40039004 <data>
40006fd4:	00042783          	lw	a5,0(s0)
				*data = __bswap_32(*data);
40006fd8:	00010537          	lui	a0,0x10
			while (sum > 4) {
40006fdc:	00400893          	li	a7,4
				*data = __bswap_32(*data);
40006fe0:	f0050513          	addi	a0,a0,-256 # ff00 <__kernel_ram_size+0x43f8>
40006fe4:	00ff0337          	lui	t1,0xff0
			while (sum > 4) {
40006fe8:	06f8c263          	blt	a7,a5,4000704c <bypass_cb+0x1a4>
40006fec:	00070663          	beqz	a4,40006ff8 <bypass_cb+0x150>
40006ff0:	00b62223          	sw	a1,4(a2)
40006ff4:	00f42023          	sw	a5,0(s0)
			if (sum % 4 == 0) {
40006ff8:	0037f713          	andi	a4,a5,3
40006ffc:	08071663          	bnez	a4,40007088 <bypass_cb+0x1e0>
				*data = __bswap_32(*data);
40007000:	00462583          	lw	a1,4(a2)
40007004:	00010637          	lui	a2,0x10
40007008:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
4000700c:	0005a783          	lw	a5,0(a1)
40007010:	01879693          	slli	a3,a5,0x18
40007014:	0187d713          	srli	a4,a5,0x18
40007018:	00d76733          	or	a4,a4,a3
4000701c:	0087d693          	srli	a3,a5,0x8
40007020:	00c6f6b3          	and	a3,a3,a2
40007024:	00d76733          	or	a4,a4,a3
40007028:	00879793          	slli	a5,a5,0x8
4000702c:	00ff06b7          	lui	a3,0xff0
40007030:	00d7f7b3          	and	a5,a5,a3
40007034:	00f767b3          	or	a5,a4,a5
40007038:	00f5a023          	sw	a5,0(a1)
}
4000703c:	01c12083          	lw	ra,28(sp)
40007040:	01812403          	lw	s0,24(sp)
40007044:	02010113          	addi	sp,sp,32
40007048:	00008067          	ret
				*data = __bswap_32(*data);
4000704c:	0005a703          	lw	a4,0(a1)
40007050:	ffc78793          	addi	a5,a5,-4
				data++;
40007054:	00458593          	addi	a1,a1,4
				*data = __bswap_32(*data);
40007058:	01871813          	slli	a6,a4,0x18
4000705c:	01875693          	srli	a3,a4,0x18
40007060:	0106e6b3          	or	a3,a3,a6
40007064:	00875813          	srli	a6,a4,0x8
40007068:	00a87833          	and	a6,a6,a0
4000706c:	00871713          	slli	a4,a4,0x8
40007070:	0106e6b3          	or	a3,a3,a6
40007074:	00677733          	and	a4,a4,t1
40007078:	00e6e733          	or	a4,a3,a4
4000707c:	fee5ae23          	sw	a4,-4(a1)
				data++;
40007080:	00100713          	li	a4,1
40007084:	f65ff06f          	j	40006fe8 <bypass_cb+0x140>
			} else if (sum % 4 == 2) {
40007088:	00400713          	li	a4,4
4000708c:	02e7e7b3          	rem	a5,a5,a4
40007090:	00200713          	li	a4,2
40007094:	02e79463          	bne	a5,a4,400070bc <bypass_cb+0x214>
				*data = __bswap_16(*data);
40007098:	00462683          	lw	a3,4(a2)
4000709c:	0006d703          	lhu	a4,0(a3) # ff0000 <__rom_region_size+0xfb7044>
400070a0:	00871793          	slli	a5,a4,0x8
400070a4:	00875713          	srli	a4,a4,0x8
400070a8:	00e7e7b3          	or	a5,a5,a4
400070ac:	01079793          	slli	a5,a5,0x10
400070b0:	0107d793          	srli	a5,a5,0x10
400070b4:	00f6a023          	sw	a5,0(a3)
400070b8:	f85ff06f          	j	4000703c <bypass_cb+0x194>
			} else if (sum % 4 == 3) {
400070bc:	00300713          	li	a4,3
400070c0:	f6e79ee3          	bne	a5,a4,4000703c <bypass_cb+0x194>
				*data = __bswap_24(*data);
400070c4:	00462603          	lw	a2,4(a2)
400070c8:	00ff05b7          	lui	a1,0xff0
400070cc:	00062703          	lw	a4,0(a2)
400070d0:	01075793          	srli	a5,a4,0x10
400070d4:	01071693          	slli	a3,a4,0x10
400070d8:	00b6f6b3          	and	a3,a3,a1
400070dc:	0ff7f793          	zext.b	a5,a5
400070e0:	00d7e7b3          	or	a5,a5,a3
400070e4:	000106b7          	lui	a3,0x10
400070e8:	f0068693          	addi	a3,a3,-256 # ff00 <__kernel_ram_size+0x43f8>
400070ec:	00d77733          	and	a4,a4,a3
400070f0:	00e7e7b3          	or	a5,a5,a4
400070f4:	00f62023          	sw	a5,0(a2)
400070f8:	f45ff06f          	j	4000703c <bypass_cb+0x194>

400070fc <cmd_load>:
{
400070fc:	fd010113          	addi	sp,sp,-48
	chunk_element = 0;
40007100:	400397b7          	lui	a5,0x40039
{
40007104:	01512a23          	sw	s5,20(sp)
	chunk_element = 0;
40007108:	fe07ae23          	sw	zero,-4(a5) # 40038ffc <chunk_element>
	littleendian = false;
4000710c:	40039ab7          	lui	s5,0x40039
	sum = 0;
40007110:	400397b7          	lui	a5,0x40039
{
40007114:	02812423          	sw	s0,40(sp)
40007118:	03212023          	sw	s2,32(sp)
4000711c:	01312e23          	sw	s3,28(sp)
40007120:	01412c23          	sw	s4,24(sp)
40007124:	01612823          	sw	s6,16(sp)
40007128:	01712623          	sw	s7,12(sp)
4000712c:	01812423          	sw	s8,8(sp)
40007130:	01912223          	sw	s9,4(sp)
40007134:	02112623          	sw	ra,44(sp)
40007138:	02912223          	sw	s1,36(sp)
4000713c:	00050993          	mv	s3,a0
40007140:	00058913          	mv	s2,a1
40007144:	00060413          	mv	s0,a2
	littleendian = false;
40007148:	100a8423          	sb	zero,264(s5) # 40039108 <littleendian>
	sum = 0;
4000714c:	0007a023          	sw	zero,0(a5) # 40039000 <sum>
	while (argc >= 2) {
40007150:	00100a13          	li	s4,1
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
40007154:	40033b37          	lui	s6,0x40033
		if (!strncmp(arg, "-e", 2)) {
40007158:	40033bb7          	lui	s7,0x40033
		} else if (arg[0] == '-' && arg[1]) {
4000715c:	02d00c13          	li	s8,45
			shell_print(sh, "Unknown option \"%s\"", arg);
40007160:	40033cb7          	lui	s9,0x40033
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
40007164:	00442483          	lw	s1,4(s0)
	while (argc >= 2) {
40007168:	072a7263          	bgeu	s4,s2,400071cc <cmd_load+0xd0>
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
4000716c:	00200613          	li	a2,2
40007170:	728b0593          	addi	a1,s6,1832 # 40033728 <levels+0xf4>
40007174:	00048513          	mv	a0,s1
40007178:	2c5050ef          	jal	ra,4000cc3c <strncmp>
4000717c:	00000793          	li	a5,0
40007180:	00051863          	bnez	a0,40007190 <cmd_load+0x94>
40007184:	00442783          	lw	a5,4(s0)
40007188:	0027c783          	lbu	a5,2(a5)
4000718c:	00f037b3          	snez	a5,a5
40007190:	00f484b3          	add	s1,s1,a5
		if (!strncmp(arg, "-e", 2)) {
40007194:	00200613          	li	a2,2
40007198:	72cb8593          	addi	a1,s7,1836 # 4003372c <levels+0xf8>
4000719c:	00048513          	mv	a0,s1
400071a0:	29d050ef          	jal	ra,4000cc3c <strncmp>
400071a4:	00051a63          	bnez	a0,400071b8 <cmd_load+0xbc>
			littleendian = true;
400071a8:	114a8423          	sb	s4,264(s5)
		argv++;
400071ac:	00440413          	addi	s0,s0,4
		argc--;
400071b0:	fff90913          	addi	s2,s2,-1
400071b4:	fb1ff06f          	j	40007164 <cmd_load+0x68>
		} else if (!strcmp(arg, "--")) {
400071b8:	728b0593          	addi	a1,s6,1832
400071bc:	00048513          	mv	a0,s1
400071c0:	259050ef          	jal	ra,4000cc18 <strcmp>
400071c4:	08051063          	bnez	a0,40007244 <cmd_load+0x148>
			argv++;
400071c8:	00440413          	addi	s0,s0,4
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
400071cc:	00442503          	lw	a0,4(s0)
400071d0:	00000613          	li	a2,0
400071d4:	00000593          	li	a1,0
400071d8:	5ac050ef          	jal	ra,4000c784 <strtol>
400071dc:	400397b7          	lui	a5,0x40039
400071e0:	00a7a423          	sw	a0,8(a5) # 40039008 <bytes>
	data = (uint32_t *)strtol(argv[1], NULL, 0);
400071e4:	00442503          	lw	a0,4(s0)
400071e8:	00000613          	li	a2,0
400071ec:	00000593          	li	a1,0
400071f0:	594050ef          	jal	ra,4000c784 <strtol>
400071f4:	400397b7          	lui	a5,0x40039
	set_bypass(sh, bypass_cb);
400071f8:	400075b7          	lui	a1,0x40007
	data = (uint32_t *)strtol(argv[1], NULL, 0);
400071fc:	00a7a223          	sw	a0,4(a5) # 40039004 <data>
	set_bypass(sh, bypass_cb);
40007200:	ea858593          	addi	a1,a1,-344 # 40006ea8 <bypass_cb>
40007204:	00098513          	mv	a0,s3
40007208:	bfdff0ef          	jal	ra,40006e04 <set_bypass.isra.0>
}
4000720c:	02c12083          	lw	ra,44(sp)
40007210:	02812403          	lw	s0,40(sp)
40007214:	02412483          	lw	s1,36(sp)
40007218:	02012903          	lw	s2,32(sp)
4000721c:	01c12983          	lw	s3,28(sp)
40007220:	01812a03          	lw	s4,24(sp)
40007224:	01412a83          	lw	s5,20(sp)
40007228:	01012b03          	lw	s6,16(sp)
4000722c:	00c12b83          	lw	s7,12(sp)
40007230:	00812c03          	lw	s8,8(sp)
40007234:	00412c83          	lw	s9,4(sp)
40007238:	00000513          	li	a0,0
4000723c:	03010113          	addi	sp,sp,48
40007240:	00008067          	ret
		} else if (arg[0] == '-' && arg[1]) {
40007244:	0004c783          	lbu	a5,0(s1)
40007248:	f98792e3          	bne	a5,s8,400071cc <cmd_load+0xd0>
4000724c:	0014c783          	lbu	a5,1(s1)
40007250:	f6078ee3          	beqz	a5,400071cc <cmd_load+0xd0>
			shell_print(sh, "Unknown option \"%s\"", arg);
40007254:	00048693          	mv	a3,s1
40007258:	730c8613          	addi	a2,s9,1840 # 40033730 <levels+0xfc>
4000725c:	00800593          	li	a1,8
40007260:	00098513          	mv	a0,s3
40007264:	489010ef          	jal	ra,40008eec <shell_fprintf>
40007268:	f45ff06f          	j	400071ac <cmd_load+0xb0>

4000726c <cmd_dump>:
{
4000726c:	fb010113          	addi	sp,sp,-80
	optind = 1;
40007270:	400447b7          	lui	a5,0x40044
40007274:	00100713          	li	a4,1
{
40007278:	04812423          	sw	s0,72(sp)
4000727c:	04912223          	sw	s1,68(sp)
40007280:	05212023          	sw	s2,64(sp)
40007284:	03312e23          	sw	s3,60(sp)
40007288:	03412c23          	sw	s4,56(sp)
4000728c:	03512a23          	sw	s5,52(sp)
40007290:	03612823          	sw	s6,48(sp)
40007294:	03712623          	sw	s7,44(sp)
40007298:	03812423          	sw	s8,40(sp)
4000729c:	03912223          	sw	s9,36(sp)
400072a0:	03a12023          	sw	s10,32(sp)
400072a4:	04112623          	sw	ra,76(sp)
400072a8:	01b12e23          	sw	s11,28(sp)
400072ac:	00050993          	mv	s3,a0
400072b0:	00058a93          	mv	s5,a1
400072b4:	00060b13          	mv	s6,a2
	optind = 1;
400072b8:	6ae7a223          	sw	a4,1700(a5) # 400446a4 <optind>
	mem_addr_t addr = -1;
400072bc:	fff00493          	li	s1,-1
	size_t width = 32;
400072c0:	02000913          	li	s2,32
	size_t size = -1;
400072c4:	fff00413          	li	s0,-1
	while ((rv = getopt(argc, argv, "a:s:w:")) != -1) {
400072c8:	40033bb7          	lui	s7,0x40033
400072cc:	fff00a13          	li	s4,-1
		switch (rv) {
400072d0:	07300c13          	li	s8,115
400072d4:	07700c93          	li	s9,119
400072d8:	06100d13          	li	s10,97
	while ((rv = getopt(argc, argv, "a:s:w:")) != -1) {
400072dc:	784b8613          	addi	a2,s7,1924 # 40033784 <levels+0x150>
400072e0:	000b0593          	mv	a1,s6
400072e4:	000a8513          	mv	a0,s5
400072e8:	845f90ef          	jal	ra,40000b2c <getopt>
400072ec:	03451063          	bne	a0,s4,4000730c <cmd_dump+0xa0>
	if (addr == -1) {
400072f0:	13449263          	bne	s1,s4,40007414 <cmd_dump+0x1a8>
		shell_error(sh, "'-a <address>' is mandatory");
400072f4:	40033637          	lui	a2,0x40033
400072f8:	78c60613          	addi	a2,a2,1932 # 4003378c <levels+0x158>
		shell_error(sh, "'-s <size>' is mandatory");
400072fc:	00100593          	li	a1,1
				shell_fprintf(sh, SHELL_NORMAL, "Incorrect data width\n");
40007300:	00098513          	mv	a0,s3
40007304:	3e9010ef          	jal	ra,40008eec <shell_fprintf>
40007308:	0540006f          	j	4000735c <cmd_dump+0xf0>
		switch (rv) {
4000730c:	09850863          	beq	a0,s8,4000739c <cmd_dump+0x130>
40007310:	0d950463          	beq	a0,s9,400073d8 <cmd_dump+0x16c>
40007314:	05a51463          	bne	a0,s10,4000735c <cmd_dump+0xf0>
			addr = (mem_addr_t)strtoul(optarg, NULL, 16);
40007318:	40039db7          	lui	s11,0x40039
4000731c:	fd0da503          	lw	a0,-48(s11) # 40038fd0 <optarg>
40007320:	01000613          	li	a2,16
40007324:	00000593          	li	a1,0
40007328:	5f0050ef          	jal	ra,4000c918 <strtoul>
4000732c:	00050493          	mv	s1,a0
			if (addr == 0 && errno == EINVAL) {
40007330:	fa0516e3          	bnez	a0,400072dc <cmd_dump+0x70>
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
40007334:	060270ef          	jal	ra,4002e394 <z_impl_z_errno>
40007338:	00052703          	lw	a4,0(a0)
4000733c:	01600793          	li	a5,22
40007340:	f8f71ee3          	bne	a4,a5,400072dc <cmd_dump+0x70>
				shell_error(sh, "invalid addr '%s'", optarg);
40007344:	fd0da683          	lw	a3,-48(s11)
40007348:	40033637          	lui	a2,0x40033
4000734c:	74860613          	addi	a2,a2,1864 # 40033748 <levels+0x114>
				shell_error(sh, "invalid size '%s'", optarg);
40007350:	00100593          	li	a1,1
40007354:	00098513          	mv	a0,s3
40007358:	395010ef          	jal	ra,40008eec <shell_fprintf>
				return -EINVAL;
4000735c:	fea00513          	li	a0,-22
}
40007360:	04c12083          	lw	ra,76(sp)
40007364:	04812403          	lw	s0,72(sp)
40007368:	04412483          	lw	s1,68(sp)
4000736c:	04012903          	lw	s2,64(sp)
40007370:	03c12983          	lw	s3,60(sp)
40007374:	03812a03          	lw	s4,56(sp)
40007378:	03412a83          	lw	s5,52(sp)
4000737c:	03012b03          	lw	s6,48(sp)
40007380:	02c12b83          	lw	s7,44(sp)
40007384:	02812c03          	lw	s8,40(sp)
40007388:	02412c83          	lw	s9,36(sp)
4000738c:	02012d03          	lw	s10,32(sp)
40007390:	01c12d83          	lw	s11,28(sp)
40007394:	05010113          	addi	sp,sp,80
40007398:	00008067          	ret
			size = (size_t)strtoul(optarg, NULL, 0);
4000739c:	40039db7          	lui	s11,0x40039
400073a0:	fd0da503          	lw	a0,-48(s11) # 40038fd0 <optarg>
400073a4:	00000613          	li	a2,0
400073a8:	00000593          	li	a1,0
400073ac:	56c050ef          	jal	ra,4000c918 <strtoul>
400073b0:	00050413          	mv	s0,a0
			if (size == 0 && errno == EINVAL) {
400073b4:	f20514e3          	bnez	a0,400072dc <cmd_dump+0x70>
400073b8:	7dd260ef          	jal	ra,4002e394 <z_impl_z_errno>
400073bc:	00052703          	lw	a4,0(a0)
400073c0:	01600793          	li	a5,22
400073c4:	f0f71ce3          	bne	a4,a5,400072dc <cmd_dump+0x70>
				shell_error(sh, "invalid size '%s'", optarg);
400073c8:	40033637          	lui	a2,0x40033
400073cc:	fd0da683          	lw	a3,-48(s11)
400073d0:	75c60613          	addi	a2,a2,1884 # 4003375c <levels+0x128>
400073d4:	f7dff06f          	j	40007350 <cmd_dump+0xe4>
			width = (size_t)strtoul(optarg, NULL, 0);
400073d8:	40039db7          	lui	s11,0x40039
400073dc:	fd0da503          	lw	a0,-48(s11) # 40038fd0 <optarg>
400073e0:	00000613          	li	a2,0
400073e4:	00000593          	li	a1,0
400073e8:	530050ef          	jal	ra,4000c918 <strtoul>
400073ec:	00050913          	mv	s2,a0
			if (width == 0 && errno == EINVAL) {
400073f0:	ee0516e3          	bnez	a0,400072dc <cmd_dump+0x70>
400073f4:	7a1260ef          	jal	ra,4002e394 <z_impl_z_errno>
400073f8:	00052703          	lw	a4,0(a0)
400073fc:	01600793          	li	a5,22
40007400:	ecf71ee3          	bne	a4,a5,400072dc <cmd_dump+0x70>
				shell_error(sh, "invalid width '%s'", optarg);
40007404:	40033637          	lui	a2,0x40033
40007408:	fd0da683          	lw	a3,-48(s11)
4000740c:	77060613          	addi	a2,a2,1904 # 40033770 <levels+0x13c>
40007410:	f41ff06f          	j	40007350 <cmd_dump+0xe4>
	if (size == -1) {
40007414:	01441863          	bne	s0,s4,40007424 <cmd_dump+0x1b8>
		shell_error(sh, "'-s <size>' is mandatory");
40007418:	40033637          	lui	a2,0x40033
4000741c:	7ac60613          	addi	a2,a2,1964 # 400337ac <levels+0x178>
40007420:	eddff06f          	j	400072fc <cmd_dump+0x90>
	return memory_dump(sh, addr, size, width);
40007424:	0ff97913          	zext.b	s2,s2
	const size_t vsize = width / BITS_PER_BYTE;
40007428:	00395a13          	srli	s4,s2,0x3
		     size >= vsize && data_offset + vsize <= SHELL_HEXDUMP_BYTES_IN_LINE;
4000742c:	01000b13          	li	s6,16
			switch (width) {
40007430:	02000b93          	li	s7,32
40007434:	00800c13          	li	s8,8
	for (; size > 0;
40007438:	0a040e63          	beqz	s0,400074f4 <cmd_dump+0x288>
4000743c:	00010793          	mv	a5,sp
40007440:	00048713          	mv	a4,s1
40007444:	00078613          	mv	a2,a5
		     size >= vsize && data_offset + vsize <= SHELL_HEXDUMP_BYTES_IN_LINE;
40007448:	409a05b3          	sub	a1,s4,s1
4000744c:	0200006f          	j	4000746c <cmd_dump+0x200>
			switch (width) {
40007450:	05690a63          	beq	s2,s6,400074a4 <cmd_dump+0x238>
40007454:	07790663          	beq	s2,s7,400074c0 <cmd_dump+0x254>
40007458:	09891663          	bne	s2,s8,400074e4 <cmd_dump+0x278>
	return *(volatile uint8_t *)addr;
4000745c:	00074683          	lbu	a3,0(a4)
				data[data_offset] = value;
40007460:	00d78023          	sb	a3,0(a5)
				break;
40007464:	01470733          	add	a4,a4,s4
40007468:	014787b3          	add	a5,a5,s4
		     size >= vsize && data_offset + vsize <= SHELL_HEXDUMP_BYTES_IN_LINE;
4000746c:	01446663          	bltu	s0,s4,40007478 <cmd_dump+0x20c>
40007470:	00e586b3          	add	a3,a1,a4
40007474:	fcdb7ee3          	bgeu	s6,a3,40007450 <cmd_dump+0x1e4>
		shell_hexdump_line(sh, addr, data, MIN(size, SHELL_HEXDUMP_BYTES_IN_LINE));
40007478:	01000793          	li	a5,16
4000747c:	00040a93          	mv	s5,s0
40007480:	0087f463          	bgeu	a5,s0,40007488 <cmd_dump+0x21c>
40007484:	01000a93          	li	s5,16
40007488:	00048593          	mv	a1,s1
4000748c:	000a8693          	mv	a3,s5
40007490:	00098513          	mv	a0,s3
40007494:	311010ef          	jal	ra,40008fa4 <shell_hexdump_line>
	     addr += SHELL_HEXDUMP_BYTES_IN_LINE, size -= MIN(size, SHELL_HEXDUMP_BYTES_IN_LINE)) {
40007498:	01048493          	addi	s1,s1,16
4000749c:	41540433          	sub	s0,s0,s5
400074a0:	f99ff06f          	j	40007438 <cmd_dump+0x1cc>
	return *(volatile uint16_t *)addr;
400074a4:	00075683          	lhu	a3,0(a4)
400074a8:	01069693          	slli	a3,a3,0x10
400074ac:	0106d693          	srli	a3,a3,0x10
				data[data_offset] = (uint8_t)value;
400074b0:	00d78023          	sb	a3,0(a5)
				value >>= 8;
400074b4:	0086d693          	srli	a3,a3,0x8
				data[data_offset + 1] = (uint8_t)value;
400074b8:	00d780a3          	sb	a3,1(a5)
				break;
400074bc:	fa9ff06f          	j	40007464 <cmd_dump+0x1f8>
	return *(volatile uint32_t *)addr;
400074c0:	00072683          	lw	a3,0(a4)
				value >>= 8;
400074c4:	0086d513          	srli	a0,a3,0x8
				data[data_offset] = (uint8_t)value;
400074c8:	00d78023          	sb	a3,0(a5)
				data[data_offset + 1] = (uint8_t)value;
400074cc:	00a780a3          	sb	a0,1(a5)
				value >>= 8;
400074d0:	0106d513          	srli	a0,a3,0x10
				value >>= 8;
400074d4:	0186d693          	srli	a3,a3,0x18
				data[data_offset + 2] = (uint8_t)value;
400074d8:	00a78123          	sb	a0,2(a5)
				data[data_offset + 3] = (uint8_t)value;
400074dc:	00d781a3          	sb	a3,3(a5)
				break;
400074e0:	f85ff06f          	j	40007464 <cmd_dump+0x1f8>
				shell_fprintf(sh, SHELL_NORMAL, "Incorrect data width\n");
400074e4:	40033637          	lui	a2,0x40033
400074e8:	66460613          	addi	a2,a2,1636 # 40033664 <levels+0x30>
400074ec:	00800593          	li	a1,8
400074f0:	e11ff06f          	j	40007300 <cmd_dump+0x94>
	return 0;
400074f4:	00000513          	li	a0,0
	return memory_dump(sh, addr, size, width);
400074f8:	e69ff06f          	j	40007360 <cmd_dump+0xf4>

400074fc <log_msg_generic_get_wlen>:
	return msg->generic.type == Z_LOG_MSG_LOG;
400074fc:	00054783          	lbu	a5,0(a0)
	if (z_log_item_is_msg(generic_msg)) {
40007500:	0047f793          	andi	a5,a5,4
40007504:	02079463          	bnez	a5,4000752c <log_msg_generic_get_wlen+0x30>
	return Z_LOG_MSG_ALIGNED_WLEN(desc.package_len, desc.data_len);
40007508:	00052783          	lw	a5,0(a0)
4000750c:	0097d513          	srli	a0,a5,0x9
40007510:	7ff57513          	andi	a0,a0,2047
40007514:	0147d793          	srli	a5,a5,0x14
40007518:	00f50533          	add	a0,a0,a5
4000751c:	01750513          	addi	a0,a0,23
40007520:	ff857513          	andi	a0,a0,-8
40007524:	00255513          	srli	a0,a0,0x2
		return log_msg_get_total_wlen(msg->hdr.desc);
40007528:	00008067          	ret
	return 0;
4000752c:	00000513          	li	a0,0
}
40007530:	00008067          	ret

40007534 <enable>:

static int enable(const struct shell_transport *transport, bool blocking_tx)
{
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
40007534:	00452783          	lw	a5,4(a0)
		uart_irq_tx_disable(sh_uart->ctrl_blk->dev);
#endif
	}

	return 0;
}
40007538:	00000513          	li	a0,0
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
4000753c:	0007a783          	lw	a5,0(a5)
40007540:	00b78823          	sb	a1,16(a5)
}
40007544:	00008067          	ret

40007548 <write>:
	}
}

static int write(const struct shell_transport *transport,
		 const void *data, size_t length, size_t *cnt)
{
40007548:	fe010113          	addi	sp,sp,-32
4000754c:	00812c23          	sw	s0,24(sp)
40007550:	00912a23          	sw	s1,20(sp)
40007554:	01212823          	sw	s2,16(sp)
40007558:	01412423          	sw	s4,8(sp)
4000755c:	00112e23          	sw	ra,28(sp)
40007560:	01312623          	sw	s3,12(sp)
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
40007564:	00452983          	lw	s3,4(a0)
{
40007568:	00060493          	mv	s1,a2
4000756c:	00068913          	mv	s2,a3
40007570:	00058413          	mv	s0,a1
40007574:	00c58a33          	add	s4,a1,a2

	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
		!sh_uart->ctrl_blk->blocking_tx) {
		irq_write(sh_uart, data, length, cnt);
	} else {
		for (size_t i = 0; i < length; i++) {
40007578:	05441063          	bne	s0,s4,400075b8 <write+0x70>
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
		}

		*cnt = length;
4000757c:	00992023          	sw	s1,0(s2)

		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
40007580:	0009a783          	lw	a5,0(s3)
40007584:	00100513          	li	a0,1
40007588:	0047a703          	lw	a4,4(a5)
4000758c:	0087a583          	lw	a1,8(a5)
40007590:	000700e7          	jalr	a4
					   sh_uart->ctrl_blk->context);
	}

	return 0;
}
40007594:	01c12083          	lw	ra,28(sp)
40007598:	01812403          	lw	s0,24(sp)
4000759c:	01412483          	lw	s1,20(sp)
400075a0:	01012903          	lw	s2,16(sp)
400075a4:	00c12983          	lw	s3,12(sp)
400075a8:	00812a03          	lw	s4,8(sp)
400075ac:	00000513          	li	a0,0
400075b0:	02010113          	addi	sp,sp,32
400075b4:	00008067          	ret
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
400075b8:	0009a783          	lw	a5,0(s3)
400075bc:	00044583          	lbu	a1,0(s0)
400075c0:	0007a503          	lw	a0,0(a5)
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
400075c4:	00852783          	lw	a5,8(a0)
400075c8:	00140413          	addi	s0,s0,1
400075cc:	0047a783          	lw	a5,4(a5)
400075d0:	000780e7          	jalr	a5
		for (size_t i = 0; i < length; i++) {
400075d4:	fa5ff06f          	j	40007578 <write+0x30>

400075d8 <read>:

static int read(const struct shell_transport *transport,
		void *data, size_t length, size_t *cnt)
{
400075d8:	ff010113          	addi	sp,sp,-16
400075dc:	00812423          	sw	s0,8(sp)
400075e0:	00112623          	sw	ra,12(sp)
	struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
400075e4:	00452783          	lw	a5,4(a0)
{
400075e8:	00068413          	mv	s0,a3
	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
400075ec:	0107a503          	lw	a0,16(a5)
400075f0:	a18fc0ef          	jal	ra,40003808 <ring_buf_get>
400075f4:	00a42023          	sw	a0,0(s0)

	return 0;
}
400075f8:	00c12083          	lw	ra,12(sp)
400075fc:	00812403          	lw	s0,8(sp)
40007600:	00000513          	li	a0,0
40007604:	01010113          	addi	sp,sp,16
40007608:	00008067          	ret

4000760c <uninit>:
{
4000760c:	ff010113          	addi	sp,sp,-16
40007610:	00112623          	sw	ra,12(sp)
		k_timer_stop(sh_uart->timer);
40007614:	00452783          	lw	a5,4(a0)
40007618:	0047a503          	lw	a0,4(a5)
	z_impl_k_timer_stop(timer);
4000761c:	3a82a0ef          	jal	ra,400319c4 <z_impl_k_timer_stop>
}
40007620:	00c12083          	lw	ra,12(sp)
40007624:	00000513          	li	a0,0
40007628:	01010113          	addi	sp,sp,16
4000762c:	00008067          	ret

40007630 <enable_shell_uart>:
	.update = update,
#endif /* CONFIG_MCUMGR_TRANSPORT_SHELL */
};

static int enable_shell_uart(void)
{
40007630:	ff010113          	addi	sp,sp,-16
40007634:	00112623          	sw	ra,12(sp)
40007638:	00812423          	sw	s0,8(sp)
4000763c:	40032437          	lui	s0,0x40032
40007640:	31440513          	addi	a0,s0,788 # 40032314 <__device_dts_ord_20>
40007644:	4d5260ef          	jal	ra,4002e318 <z_device_is_ready>
40007648:	fed00793          	li	a5,-19
		(CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > LOG_LEVEL_DBG) ?
		CONFIG_LOG_MAX_LEVEL : CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL;
	static const struct shell_backend_config_flags cfg_flags =
					SHELL_DEFAULT_BACKEND_CONFIG_FLAGS;

	if (!device_is_ready(dev)) {
4000764c:	02050463          	beqz	a0,40007674 <enable_shell_uart+0x44>

	if (IS_ENABLED(CONFIG_MCUMGR_TRANSPORT_SHELL)) {
		smp_shell_init();
	}

	shell_init(&shell_uart, dev, cfg_flags, log_backend, level);
40007650:	400327b7          	lui	a5,0x40032
40007654:	5bc7a603          	lw	a2,1468(a5) # 400325bc <cfg_flags.0>
40007658:	40032537          	lui	a0,0x40032
4000765c:	00400713          	li	a4,4
40007660:	00100693          	li	a3,1
40007664:	31440593          	addi	a1,s0,788
40007668:	51c50513          	addi	a0,a0,1308 # 4003251c <shell_uart>
4000766c:	3f0010ef          	jal	ra,40008a5c <shell_init>

	return 0;
40007670:	00000793          	li	a5,0
}
40007674:	00c12083          	lw	ra,12(sp)
40007678:	00812403          	lw	s0,8(sp)
4000767c:	00078513          	mv	a0,a5
40007680:	01010113          	addi	sp,sp,16
40007684:	00008067          	ret

40007688 <timer_handler>:
{
40007688:	fc010113          	addi	sp,sp,-64
4000768c:	02112e23          	sw	ra,60(sp)
40007690:	02812c23          	sw	s0,56(sp)
40007694:	02912a23          	sw	s1,52(sp)
40007698:	03212823          	sw	s2,48(sp)
4000769c:	03312623          	sw	s3,44(sp)
400076a0:	03412423          	sw	s4,40(sp)
 */
__syscall void *k_timer_user_data_get(const struct k_timer *timer);

static inline void *z_impl_k_timer_user_data_get(const struct k_timer *timer)
{
	return timer->user_data;
400076a4:	03452403          	lw	s0,52(a0)
			LOG_WRN("RX ring buffer full.");
400076a8:	400344b7          	lui	s1,0x40034
400076ac:	00001937          	lui	s2,0x1
400076b0:	400449b7          	lui	s3,0x40044
400076b4:	96c48493          	addi	s1,s1,-1684 # 4003396c <shell_sub_devmem+0x3c>
400076b8:	00200a13          	li	s4,2
400076bc:	08090913          	addi	s2,s2,128 # 1080 <CONFIG_HEAP_MEM_POOL_SIZE+0x80>
	while (uart_poll_in(sh_uart->ctrl_blk->dev, &c) == 0) {
400076c0:	00042783          	lw	a5,0(s0)
400076c4:	0007a503          	lw	a0,0(a5)
	if (api->poll_in == NULL) {
400076c8:	00852783          	lw	a5,8(a0)
400076cc:	0007a783          	lw	a5,0(a5)
400076d0:	00078863          	beqz	a5,400076e0 <timer_handler+0x58>
	return api->poll_in(dev, p_char);
400076d4:	00710593          	addi	a1,sp,7
400076d8:	000780e7          	jalr	a5
400076dc:	02050263          	beqz	a0,40007700 <timer_handler+0x78>
}
400076e0:	03c12083          	lw	ra,60(sp)
400076e4:	03812403          	lw	s0,56(sp)
400076e8:	03412483          	lw	s1,52(sp)
400076ec:	03012903          	lw	s2,48(sp)
400076f0:	02c12983          	lw	s3,44(sp)
400076f4:	02812a03          	lw	s4,40(sp)
400076f8:	04010113          	addi	sp,sp,64
400076fc:	00008067          	ret
		if (ring_buf_put(sh_uart->rx_ringbuf, &c, 1) == 0U) {
40007700:	01042503          	lw	a0,16(s0)
40007704:	00100613          	li	a2,1
40007708:	00710593          	addi	a1,sp,7
4000770c:	fc5fb0ef          	jal	ra,400036d0 <ring_buf_put>
40007710:	02051663          	bnez	a0,4000773c <timer_handler+0xb4>
			LOG_WRN("RX ring buffer full.");
40007714:	7b49a783          	lw	a5,1972(s3) # 400447b4 <log_dynamic_shell_uart>
40007718:	0067f793          	andi	a5,a5,6
4000771c:	02078063          	beqz	a5,4000773c <timer_handler+0xb4>
40007720:	00912e23          	sw	s1,28(sp)
40007724:	01412c23          	sw	s4,24(sp)
40007728:	00000693          	li	a3,0
4000772c:	01810613          	addi	a2,sp,24
40007730:	00090593          	mv	a1,s2
40007734:	7b498513          	addi	a0,s3,1972
40007738:	85dfd0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
4000773c:	00042783          	lw	a5,0(s0)
40007740:	00000513          	li	a0,0
40007744:	0047a703          	lw	a4,4(a5)
40007748:	0087a583          	lw	a1,8(a5)
4000774c:	000700e7          	jalr	a4
40007750:	f71ff06f          	j	400076c0 <timer_handler+0x38>

40007754 <init>:
{
40007754:	ff010113          	addi	sp,sp,-16
40007758:	00112623          	sw	ra,12(sp)
4000775c:	00812423          	sw	s0,8(sp)
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
40007760:	00452403          	lw	s0,4(a0)
	sh_uart->ctrl_blk->dev = (const struct device *)config;
40007764:	00042783          	lw	a5,0(s0)
40007768:	00b7a023          	sw	a1,0(a5)
	sh_uart->ctrl_blk->handler = evt_handler;
4000776c:	00042783          	lw	a5,0(s0)
		k_timer_init(sh_uart->timer, timer_handler, NULL);
40007770:	400075b7          	lui	a1,0x40007
40007774:	68858593          	addi	a1,a1,1672 # 40007688 <timer_handler>
	sh_uart->ctrl_blk->handler = evt_handler;
40007778:	00c7a223          	sw	a2,4(a5)
	sh_uart->ctrl_blk->context = context;
4000777c:	00042783          	lw	a5,0(s0)
		k_timer_init(sh_uart->timer, timer_handler, NULL);
40007780:	00000613          	li	a2,0
	sh_uart->ctrl_blk->context = context;
40007784:	00d7a423          	sw	a3,8(a5)
		k_timer_init(sh_uart->timer, timer_handler, NULL);
40007788:	00442503          	lw	a0,4(s0)
4000778c:	13c2a0ef          	jal	ra,400318c8 <k_timer_init>
		k_timer_user_data_set(sh_uart->timer, (void *)sh_uart);
40007790:	00442783          	lw	a5,4(s0)
	timer->user_data = user_data;
40007794:	0287aa23          	sw	s0,52(a5)
		k_timer_start(sh_uart->timer, RX_POLL_PERIOD, RX_POLL_PERIOD);
40007798:	00442503          	lw	a0,4(s0)
	z_impl_k_timer_start(timer, duration, period);
4000779c:	00100693          	li	a3,1
400077a0:	00000713          	li	a4,0
400077a4:	00100593          	li	a1,1
400077a8:	00000613          	li	a2,0
400077ac:	1442a0ef          	jal	ra,400318f0 <z_impl_k_timer_start>
}
400077b0:	00c12083          	lw	ra,12(sp)
400077b4:	00812403          	lw	s0,8(sp)
400077b8:	00000513          	li	a0,0
400077bc:	01010113          	addi	sp,sp,16
400077c0:	00008067          	ret

400077c4 <cmd_buffer_clear>:
	sh->ctx->receive_state = state;
}

static void cmd_buffer_clear(const struct shell *sh)
{
	sh->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
400077c4:	00852783          	lw	a5,8(a0)
400077c8:	04078723          	sb	zero,78(a5)
	sh->ctx->cmd_buff_pos = 0;
400077cc:	00852783          	lw	a5,8(a0)
400077d0:	04079523          	sh	zero,74(a5)
	sh->ctx->cmd_buff_len = 0;
400077d4:	00852783          	lw	a5,8(a0)
400077d8:	04079423          	sh	zero,72(a5)
}
400077dc:	00008067          	ret

400077e0 <atomic_or>:
		union { uintptr_t x; atomic_val_t val; } parm1 = { .val = value };
		return (atomic_val_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_ATOMIC_OR);
	}
#endif
	compiler_barrier();
	return z_impl_atomic_or(target, value);
400077e0:	2cc2a06f          	j	40031aac <z_impl_atomic_or>

400077e4 <atomic_and>:
		union { uintptr_t x; atomic_val_t val; } parm1 = { .val = value };
		return (atomic_val_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_ATOMIC_AND);
	}
#endif
	compiler_barrier();
	return z_impl_atomic_and(target, value);
400077e4:	2e82a06f          	j	40031acc <z_impl_atomic_and>

400077e8 <shell_signal_handle>:
typedef void (*shell_signal_handler_t)(const struct shell *sh);

static void shell_signal_handle(const struct shell *sh,
				enum shell_signal sig_idx,
				shell_signal_handler_t handler)
{
400077e8:	fd010113          	addi	sp,sp,-48
400077ec:	02812423          	sw	s0,40(sp)
400077f0:	02912223          	sw	s1,36(sp)
400077f4:	02112623          	sw	ra,44(sp)
400077f8:	00050413          	mv	s0,a0
	struct k_poll_signal *sig = &sh->ctx->signals[sig_idx];
400077fc:	00852503          	lw	a0,8(a0)
40007800:	00459593          	slli	a1,a1,0x4
40007804:	27458593          	addi	a1,a1,628
{
40007808:	00060493          	mv	s1,a2
	struct k_poll_signal *sig = &sh->ctx->signals[sig_idx];
4000780c:	00b50533          	add	a0,a0,a1
		(void) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_K_POLL_SIGNAL_CHECK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_check(sig, signaled, result);
40007810:	01c10613          	addi	a2,sp,28
40007814:	01810593          	addi	a1,sp,24
40007818:	00a12623          	sw	a0,12(sp)
4000781c:	0952a0ef          	jal	ra,400320b0 <z_impl_k_poll_signal_check>
	int set;
	int res;

	k_poll_signal_check(sig, &set, &res);

	if (set) {
40007820:	01812783          	lw	a5,24(sp)
40007824:	00c12503          	lw	a0,12(sp)
40007828:	00078863          	beqz	a5,40007838 <shell_signal_handle+0x50>
	z_impl_k_poll_signal_reset(sig);
4000782c:	07d2a0ef          	jal	ra,400320a8 <z_impl_k_poll_signal_reset>
		k_poll_signal_reset(sig);
		handler(sh);
40007830:	00040513          	mv	a0,s0
40007834:	000480e7          	jalr	s1
	}
}
40007838:	02c12083          	lw	ra,44(sp)
4000783c:	02812403          	lw	s0,40(sp)
40007840:	02412483          	lw	s1,36(sp)
40007844:	03010113          	addi	sp,sp,48
40007848:	00008067          	ret

4000784c <z_shell_strlen>:
void z_shell_multiline_data_calc(struct shell_multiline_cons *cons,
				 uint16_t buff_pos, uint16_t buff_len);

static inline uint16_t z_shell_strlen(const char *str)
{
	return str == NULL ? 0U : (uint16_t)strlen(str);
4000784c:	02050263          	beqz	a0,40007870 <z_shell_strlen+0x24>
{
40007850:	ff010113          	addi	sp,sp,-16
40007854:	00112623          	sw	ra,12(sp)
	return str == NULL ? 0U : (uint16_t)strlen(str);
40007858:	37c050ef          	jal	ra,4000cbd4 <strlen>
}
4000785c:	00c12083          	lw	ra,12(sp)
	return str == NULL ? 0U : (uint16_t)strlen(str);
40007860:	01051513          	slli	a0,a0,0x10
40007864:	01055513          	srli	a0,a0,0x10
}
40007868:	01010113          	addi	sp,sp,16
4000786c:	00008067          	ret
	return str == NULL ? 0U : (uint16_t)strlen(str);
40007870:	00000513          	li	a0,0
}
40007874:	00008067          	ret

40007878 <z_shell_raw_fprintf>:
extern "C" {
#endif

static inline void z_shell_raw_fprintf(const struct shell_fprintf *const ctx,
				       const char *fmt, ...)
{
40007878:	fc010113          	addi	sp,sp,-64
4000787c:	02c12423          	sw	a2,40(sp)
	va_list args;

	va_start(args, fmt);
40007880:	02810613          	addi	a2,sp,40
{
40007884:	00112e23          	sw	ra,28(sp)
40007888:	02d12623          	sw	a3,44(sp)
4000788c:	02e12823          	sw	a4,48(sp)
40007890:	02f12a23          	sw	a5,52(sp)
40007894:	03012c23          	sw	a6,56(sp)
40007898:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
4000789c:	00c12623          	sw	a2,12(sp)
	z_shell_fprintf_fmt(ctx, fmt, args);
400078a0:	1e1010ef          	jal	ra,40009280 <z_shell_fprintf_fmt>
	va_end(args);
}
400078a4:	01c12083          	lw	ra,28(sp)
400078a8:	04010113          	addi	sp,sp,64
400078ac:	00008067          	ret

400078b0 <shell_internal_help_print>:
{
400078b0:	ff010113          	addi	sp,sp,-16
400078b4:	00812423          	sw	s0,8(sp)
400078b8:	00112623          	sw	ra,12(sp)
	z_shell_help_cmd_print(sh, &sh->ctx->active_cmd);
400078bc:	00852583          	lw	a1,8(a0)
{
400078c0:	00050413          	mv	s0,a0
	z_shell_help_cmd_print(sh, &sh->ctx->active_cmd);
400078c4:	00c58593          	addi	a1,a1,12
400078c8:	265030ef          	jal	ra,4000b32c <z_shell_help_cmd_print>
	z_shell_help_subcmd_print(sh, &sh->ctx->active_cmd,
400078cc:	00842583          	lw	a1,8(s0)
400078d0:	00040513          	mv	a0,s0
}
400078d4:	00812403          	lw	s0,8(sp)
400078d8:	00c12083          	lw	ra,12(sp)
	z_shell_help_subcmd_print(sh, &sh->ctx->active_cmd,
400078dc:	40034637          	lui	a2,0x40034
400078e0:	a4060613          	addi	a2,a2,-1472 # 40033a40 <shell_transport_uart_shell_uart+0x14>
400078e4:	00c58593          	addi	a1,a1,12
}
400078e8:	01010113          	addi	sp,sp,16
	z_shell_help_subcmd_print(sh, &sh->ctx->active_cmd,
400078ec:	0b90306f          	j	4000b1a4 <z_shell_help_subcmd_print>

400078f0 <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
400078f0:	34d2706f          	j	4002f43c <z_impl_k_mutex_lock>

400078f4 <transport_evt_handler>:
			&sh->ctx->signals[SHELL_SIGNAL_RXRDY] :
400078f4:	0085a703          	lw	a4,8(a1)
400078f8:	2a470793          	addi	a5,a4,676
400078fc:	00051463          	bnez	a0,40007904 <transport_evt_handler+0x10>
40007900:	27470793          	addi	a5,a4,628
		union { uintptr_t x; int val; } parm1 = { .val = result };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
40007904:	00000593          	li	a1,0
40007908:	00078513          	mv	a0,a5
4000790c:	7b82a06f          	j	400320c4 <z_impl_k_poll_signal_raise>

40007910 <kill_handler>:

static void kill_handler(const struct shell *sh)
{
40007910:	fe010113          	addi	sp,sp,-32
40007914:	00812c23          	sw	s0,24(sp)
40007918:	00112e23          	sw	ra,28(sp)
	return ret;
}

static inline bool z_flag_processing_get(const struct shell *sh)
{
	return sh->ctx->ctx.flags.processing == 1;
4000791c:	00852783          	lw	a5,8(a0)
40007920:	00050413          	mv	s0,a0
		return -EBUSY;
40007924:	ff000593          	li	a1,-16
40007928:	2707a783          	lw	a5,624(a5)
4000792c:	0017f793          	andi	a5,a5,1
	if (z_flag_processing_get(sh)) {
40007930:	02079e63          	bnez	a5,4000796c <kill_handler+0x5c>
		z_shell_log_backend_disable(sh->log_backend);
40007934:	01c52503          	lw	a0,28(a0)
40007938:	4d0030ef          	jal	ra,4000ae08 <z_shell_log_backend_disable>
	err = sh->iface->api->uninit(sh->iface);
4000793c:	00442503          	lw	a0,4(s0)
40007940:	00052783          	lw	a5,0(a0)
40007944:	0047a783          	lw	a5,4(a5)
40007948:	000780e7          	jalr	a5
4000794c:	00050593          	mv	a1,a0
	if (err != 0) {
40007950:	00051e63          	bnez	a0,4000796c <kill_handler+0x5c>
40007954:	00a12623          	sw	a0,12(sp)
	z_shell_history_purge(sh->history);
40007958:	00c42503          	lw	a0,12(s0)
4000795c:	300040ef          	jal	ra,4000bc5c <z_shell_history_purge>
	sh->ctx->state = state;
40007960:	00842783          	lw	a5,8(s0)
40007964:	00c12583          	lw	a1,12(sp)
40007968:	0007a223          	sw	zero,4(a5)
	int err = instance_uninit(sh);

	if (sh->ctx->uninit_cb) {
4000796c:	00842783          	lw	a5,8(s0)
40007970:	0407a783          	lw	a5,64(a5)
40007974:	00078663          	beqz	a5,40007980 <kill_handler+0x70>
		sh->ctx->uninit_cb(sh, err);
40007978:	00040513          	mv	a0,s0
4000797c:	000780e7          	jalr	a5
	}

	sh->ctx->tid = NULL;
40007980:	00842783          	lw	a5,8(s0)
40007984:	3007ac23          	sw	zero,792(a5)
	return z_impl_z_current_get();
40007988:	5bc290ef          	jal	ra,40030f44 <z_impl_z_current_get>
	k_thread_abort(k_current_get());
}
4000798c:	01812403          	lw	s0,24(sp)
40007990:	01c12083          	lw	ra,28(sp)
40007994:	02010113          	addi	sp,sp,32
	z_impl_k_thread_abort(thread);
40007998:	6e02906f          	j	40031078 <z_impl_k_thread_abort>

4000799c <z_cursor_next_line_move.isra.0>:
/* Function forcing new line - cannot be replaced with function
 * cursor_down_move.
 */
static inline void z_cursor_next_line_move(const struct shell *sh)
{
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
4000799c:	400335b7          	lui	a1,0x40033
400079a0:	bf458593          	addi	a1,a1,-1036 # 40032bf4 <severity+0x88>
400079a4:	ed5ff06f          	j	40007878 <z_shell_raw_fprintf>

400079a8 <z_flag_cmd_ctx_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, cmd_ctx, val, ret);
400079a8:	27050513          	addi	a0,a0,624
400079ac:	00058863          	beqz	a1,400079bc <z_flag_cmd_ctx_set.isra.0+0x14>
400079b0:	000015b7          	lui	a1,0x1
400079b4:	80058593          	addi	a1,a1,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
400079b8:	e29ff06f          	j	400077e0 <atomic_or>
400079bc:	fffff5b7          	lui	a1,0xfffff
400079c0:	7ff58593          	addi	a1,a1,2047 # fffff7ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfffff800>
400079c4:	e21ff06f          	j	400077e4 <atomic_and>

400079c8 <z_flag_history_exit_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, history_exit, val, ret);
400079c8:	27050513          	addi	a0,a0,624
400079cc:	00058663          	beqz	a1,400079d8 <z_flag_history_exit_set.isra.0+0x10>
400079d0:	00400593          	li	a1,4
400079d4:	e0dff06f          	j	400077e0 <atomic_or>
400079d8:	ffb00593          	li	a1,-5
400079dc:	e09ff06f          	j	400077e4 <atomic_and>

400079e0 <history_handle>:
{
400079e0:	fe010113          	addi	sp,sp,-32
400079e4:	00812c23          	sw	s0,24(sp)
400079e8:	00912a23          	sw	s1,20(sp)
400079ec:	00112e23          	sw	ra,28(sp)
400079f0:	00050413          	mv	s0,a0
	return sh->ctx->ctx.flags.history_exit == 1;
400079f4:	00852503          	lw	a0,8(a0)
400079f8:	00058493          	mv	s1,a1
400079fc:	27052783          	lw	a5,624(a0)
40007a00:	0027d793          	srli	a5,a5,0x2
40007a04:	0017f793          	andi	a5,a5,1
	if (z_flag_history_exit_get(sh)) {
40007a08:	00078a63          	beqz	a5,40007a1c <history_handle+0x3c>
		z_flag_history_exit_set(sh, false);
40007a0c:	00000593          	li	a1,0
40007a10:	fb9ff0ef          	jal	ra,400079c8 <z_flag_history_exit_set.isra.0>
		z_shell_history_mode_exit(sh->history);
40007a14:	00c42503          	lw	a0,12(s0)
40007a18:	194040ef          	jal	ra,4000bbac <z_shell_history_mode_exit>
 *
 * @return True if in browsing mode.
 */
static inline bool z_shell_history_active(struct shell_history *history)
{
	return (history->current) ? true : false;
40007a1c:	00c42783          	lw	a5,12(s0)
	if (!z_shell_history_active(sh->history)) {
40007a20:	00c7a783          	lw	a5,12(a5)
40007a24:	02079463          	bnez	a5,40007a4c <history_handle+0x6c>
		if (up) {
40007a28:	0a048863          	beqz	s1,40007ad8 <history_handle+0xf8>
			uint16_t cmd_len = z_shell_strlen(sh->ctx->cmd_buff);
40007a2c:	00842503          	lw	a0,8(s0)
40007a30:	04e50513          	addi	a0,a0,78
40007a34:	e19ff0ef          	jal	ra,4000784c <z_shell_strlen>
			if (cmd_len) {
40007a38:	00842783          	lw	a5,8(s0)
40007a3c:	0a050863          	beqz	a0,40007aec <history_handle+0x10c>
				strcpy(sh->ctx->temp_buff,
40007a40:	04e78593          	addi	a1,a5,78
40007a44:	14e78513          	addi	a0,a5,334
40007a48:	0e4050ef          	jal	ra,4000cb2c <strcpy>
					   sh->ctx->cmd_buff, &len);
40007a4c:	00842603          	lw	a2,8(s0)
	history_mode = z_shell_history_get(sh->history, up,
40007a50:	00c42503          	lw	a0,12(s0)
40007a54:	00e10693          	addi	a3,sp,14
40007a58:	04e60613          	addi	a2,a2,78
40007a5c:	00048593          	mv	a1,s1
40007a60:	154040ef          	jal	ra,4000bbb4 <z_shell_history_get>
	if (!history_mode) {
40007a64:	02051263          	bnez	a0,40007a88 <history_handle+0xa8>
		strcpy(sh->ctx->cmd_buff, sh->ctx->temp_buff);
40007a68:	00842503          	lw	a0,8(s0)
40007a6c:	14e50593          	addi	a1,a0,334
40007a70:	04e50513          	addi	a0,a0,78
40007a74:	0b8050ef          	jal	ra,4000cb2c <strcpy>
		len = z_shell_strlen(sh->ctx->cmd_buff);
40007a78:	00842503          	lw	a0,8(s0)
40007a7c:	04e50513          	addi	a0,a0,78
40007a80:	dcdff0ef          	jal	ra,4000784c <z_shell_strlen>
40007a84:	00a11723          	sh	a0,14(sp)
	z_shell_op_cursor_home_move(sh);
40007a88:	00040513          	mv	a0,s0
40007a8c:	69c020ef          	jal	ra,4000a128 <z_shell_op_cursor_home_move>
	return sh->ctx->cfg.flags.use_vt100 == 1;
40007a90:	00842783          	lw	a5,8(s0)
40007a94:	26c7a783          	lw	a5,620(a5)
40007a98:	0057d793          	srli	a5,a5,0x5
40007a9c:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
40007aa0:	00078a63          	beqz	a5,40007ab4 <history_handle+0xd4>
40007aa4:	01442503          	lw	a0,20(s0)
40007aa8:	400325b7          	lui	a1,0x40032
40007aac:	6a058593          	addi	a1,a1,1696 # 400326a0 <eth_config+0x4>
40007ab0:	dc9ff0ef          	jal	ra,40007878 <z_shell_raw_fprintf>
	z_shell_print_cmd(sh);
40007ab4:	00040513          	mv	a0,s0
40007ab8:	75c020ef          	jal	ra,4000a214 <z_shell_print_cmd>
	sh->ctx->cmd_buff_pos = len;
40007abc:	00842703          	lw	a4,8(s0)
40007ac0:	00e15783          	lhu	a5,14(sp)
	z_shell_op_cond_next_line(sh);
40007ac4:	00040513          	mv	a0,s0
	sh->ctx->cmd_buff_pos = len;
40007ac8:	04f71523          	sh	a5,74(a4)
	sh->ctx->cmd_buff_len = len;
40007acc:	00842703          	lw	a4,8(s0)
40007ad0:	04f71423          	sh	a5,72(a4)
	z_shell_op_cond_next_line(sh);
40007ad4:	3b8020ef          	jal	ra,40009e8c <z_shell_op_cond_next_line>
}
40007ad8:	01c12083          	lw	ra,28(sp)
40007adc:	01812403          	lw	s0,24(sp)
40007ae0:	01412483          	lw	s1,20(sp)
40007ae4:	02010113          	addi	sp,sp,32
40007ae8:	00008067          	ret
				sh->ctx->temp_buff[0] = '\0';
40007aec:	14078723          	sb	zero,334(a5)
40007af0:	f5dff06f          	j	40007a4c <history_handle+0x6c>

40007af4 <z_flag_insert_mode_set.isra.0>:
static inline bool z_flag_insert_mode_set(const struct shell *sh, bool val)
40007af4:	ff010113          	addi	sp,sp,-16
40007af8:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
40007afc:	26c50513          	addi	a0,a0,620
40007b00:	00058e63          	beqz	a1,40007b1c <z_flag_insert_mode_set.isra.0+0x28>
40007b04:	00100593          	li	a1,1
40007b08:	cd9ff0ef          	jal	ra,400077e0 <atomic_or>
}
40007b0c:	00c12083          	lw	ra,12(sp)
40007b10:	00157513          	andi	a0,a0,1
40007b14:	01010113          	addi	sp,sp,16
40007b18:	00008067          	ret
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
40007b1c:	ffe00593          	li	a1,-2
40007b20:	cc5ff0ef          	jal	ra,400077e4 <atomic_and>
40007b24:	fe9ff06f          	j	40007b0c <z_flag_insert_mode_set.isra.0+0x18>

40007b28 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
40007b28:	2712706f          	j	4002f598 <z_impl_k_mutex_unlock>

40007b2c <execute>:
{
40007b2c:	f2010113          	addi	sp,sp,-224
40007b30:	0c812c23          	sw	s0,216(sp)
	const char *argv[CONFIG_SHELL_ARGC_MAX + 1] = {0}; /* +1 reserved for NULL */
40007b34:	05400613          	li	a2,84
{
40007b38:	00050413          	mv	s0,a0
	const char *argv[CONFIG_SHELL_ARGC_MAX + 1] = {0}; /* +1 reserved for NULL */
40007b3c:	00000593          	li	a1,0
40007b40:	04c10513          	addi	a0,sp,76
{
40007b44:	0c112e23          	sw	ra,220(sp)
40007b48:	0b712e23          	sw	s7,188(sp)
40007b4c:	0c912a23          	sw	s1,212(sp)
40007b50:	0d212823          	sw	s2,208(sp)
40007b54:	0d312623          	sw	s3,204(sp)
40007b58:	0d412423          	sw	s4,200(sp)
40007b5c:	0d512223          	sw	s5,196(sp)
40007b60:	0d612023          	sw	s6,192(sp)
40007b64:	0b812c23          	sw	s8,184(sp)
40007b68:	0b912a23          	sw	s9,180(sp)
40007b6c:	0ba12823          	sw	s10,176(sp)
40007b70:	0bb12623          	sw	s11,172(sp)
	const char *argv[CONFIG_SHELL_ARGC_MAX + 1] = {0}; /* +1 reserved for NULL */
40007b74:	1a8050ef          	jal	ra,4000cd1c <memset>
	z_shell_op_cursor_end_move(sh);
40007b78:	00040513          	mv	a0,s0
	char *cmd_buf = sh->ctx->cmd_buff;
40007b7c:	00842b83          	lw	s7,8(s0)
	size_t cmd_lvl = 0;
40007b80:	00012e23          	sw	zero,28(sp)
	size_t argc = 0, args_left = SIZE_MAX;
40007b84:	02012023          	sw	zero,32(sp)
	z_shell_op_cursor_end_move(sh);
40007b88:	5b8020ef          	jal	ra,4000a140 <z_shell_op_cursor_end_move>
	if (!z_shell_cursor_in_empty_line(sh)) {
40007b8c:	00040513          	mv	a0,s0
	char *cmd_buf = sh->ctx->cmd_buff;
40007b90:	04eb8b93          	addi	s7,s7,78
	if (!z_shell_cursor_in_empty_line(sh)) {
40007b94:	28c020ef          	jal	ra,40009e20 <z_shell_cursor_in_empty_line>
40007b98:	00051663          	bnez	a0,40007ba4 <execute+0x78>
		z_cursor_next_line_move(sh);
40007b9c:	01442503          	lw	a0,20(s0)
40007ba0:	dfdff0ef          	jal	ra,4000799c <z_cursor_next_line_move.isra.0>
	memset(&sh->ctx->active_cmd, 0, sizeof(sh->ctx->active_cmd));
40007ba4:	00842503          	lw	a0,8(s0)
40007ba8:	01400613          	li	a2,20
40007bac:	00000593          	li	a1,0
40007bb0:	00c50513          	addi	a0,a0,12
40007bb4:	168050ef          	jal	ra,4000cd1c <memset>
		z_shell_cmd_trim(sh);
40007bb8:	00040513          	mv	a0,s0
40007bbc:	785010ef          	jal	ra,40009b40 <z_shell_cmd_trim>
		history_put(sh, sh->ctx->cmd_buff,
40007bc0:	00842583          	lw	a1,8(s0)
	z_shell_history_put(sh->history, line, length);
40007bc4:	00c42503          	lw	a0,12(s0)
		help_entry.help = NULL;
40007bc8:	00000a13          	li	s4,0
	z_shell_history_put(sh->history, line, length);
40007bcc:	0485d603          	lhu	a2,72(a1)
40007bd0:	04e58593          	addi	a1,a1,78
	size_t argc = 0, args_left = SIZE_MAX;
40007bd4:	fff00913          	li	s2,-1
	z_shell_history_put(sh->history, line, length);
40007bd8:	0c4040ef          	jal	ra,4000bc9c <z_shell_history_put>
		z_shell_wildcard_prepare(sh);
40007bdc:	00040513          	mv	a0,s0
40007be0:	2b0040ef          	jal	ra,4000be90 <z_shell_wildcard_prepare>
	size_t cmd_with_handler_lvl = 0;
40007be4:	00000a93          	li	s5,0
		z_shell_wildcard_prepare(sh);
40007be8:	00000c93          	li	s9,0
40007bec:	04c10993          	addi	s3,sp,76
40007bf0:	00000c13          	li	s8,0
40007bf4:	00000493          	li	s1,0
40007bf8:	00000b13          	li	s6,0
		&& args_left > 0) {
40007bfc:	00100d13          	li	s10,1
			if (status != SHELL_WILDCARD_NOT_FOUND) {
40007c00:	00300d93          	li	s11,3
		&& args_left > 0) {
40007c04:	02012703          	lw	a4,32(sp)
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
40007c08:	01c12783          	lw	a5,28(sp)
		&& args_left > 0) {
40007c0c:	19a70263          	beq	a4,s10,40007d90 <execute+0x264>
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
40007c10:	01300713          	li	a4,19
40007c14:	18f76463          	bltu	a4,a5,40007d9c <execute+0x270>
		&& args_left > 0) {
40007c18:	08091463          	bnez	s2,40007ca0 <execute+0x174>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {
40007c1c:	020c0263          	beqz	s8,40007c40 <execute+0x114>
		z_shell_wildcard_finalize(sh);
40007c20:	00040513          	mv	a0,s0
40007c24:	48c040ef          	jal	ra,4000c0b0 <z_shell_wildcard_finalize>
					sh->ctx->cmd_buff,
40007c28:	00842603          	lw	a2,8(s0)
		(void)z_shell_make_argv(&cmd_lvl,
40007c2c:	01400693          	li	a3,20
40007c30:	04c10593          	addi	a1,sp,76
40007c34:	04e60613          	addi	a2,a2,78
40007c38:	01c10513          	addi	a0,sp,28
40007c3c:	7f8010ef          	jal	ra,40009434 <z_shell_make_argv>
	if (parent != NULL) {
40007c40:	020b0a63          	beqz	s6,40007c74 <execute+0x148>
		if (parent->args.optional == SHELL_OPT_ARG_RAW && argv[cmd_lvl] != NULL) {
40007c44:	011b4703          	lbu	a4,17(s6)
40007c48:	0fe00793          	li	a5,254
40007c4c:	02f71463          	bne	a4,a5,40007c74 <execute+0x148>
40007c50:	01c12783          	lw	a5,28(sp)
40007c54:	01010693          	addi	a3,sp,16
40007c58:	00279713          	slli	a4,a5,0x2
40007c5c:	09070713          	addi	a4,a4,144
40007c60:	00d70733          	add	a4,a4,a3
40007c64:	fac72703          	lw	a4,-84(a4)
40007c68:	00070663          	beqz	a4,40007c74 <execute+0x148>
			cmd_lvl++;
40007c6c:	00178793          	addi	a5,a5,1
40007c70:	00f12e23          	sw	a5,28(sp)
	if (sh->ctx->active_cmd.handler == NULL) {
40007c74:	00842503          	lw	a0,8(s0)
	return exec_cmd(sh, cmd_lvl - cmd_with_handler_lvl,
40007c78:	01c12483          	lw	s1,28(sp)
	if (sh->ctx->active_cmd.handler == NULL) {
40007c7c:	01852783          	lw	a5,24(a0)
40007c80:	26079463          	bnez	a5,40007ee8 <execute+0x3bc>
			if (help_entry->help == NULL) {
40007c84:	040a0e63          	beqz	s4,40007ce0 <execute+0x1b4>
			if (help_entry->help != sh->ctx->active_cmd.help) {
40007c88:	01052783          	lw	a5,16(a0)
40007c8c:	0afa1a63          	bne	s4,a5,40007d40 <execute+0x214>
			shell_internal_help_print(sh);
40007c90:	00040513          	mv	a0,s0
40007c94:	c1dff0ef          	jal	ra,400078b0 <shell_internal_help_print>
			return SHELL_CMD_HELP_PRINTED;
40007c98:	00100493          	li	s1,1
40007c9c:	0480006f          	j	40007ce4 <execute+0x1b8>
		quote = z_shell_make_argv(&argc, argvp, cmd_buf, 2);
40007ca0:	00200693          	li	a3,2
40007ca4:	000b8613          	mv	a2,s7
40007ca8:	00098593          	mv	a1,s3
40007cac:	02010513          	addi	a0,sp,32
40007cb0:	784010ef          	jal	ra,40009434 <z_shell_make_argv>
		if (argc == 0) {
40007cb4:	02012783          	lw	a5,32(sp)
		cmd_buf = (char *)argvp[1];
40007cb8:	0049ab83          	lw	s7,4(s3)
		quote = z_shell_make_argv(&argc, argvp, cmd_buf, 2);
40007cbc:	00050693          	mv	a3,a0
		if (argc == 0) {
40007cc0:	02078063          	beqz	a5,40007ce0 <execute+0x1b4>
		} else if ((argc == 1) && (quote != 0)) {
40007cc4:	07a79063          	bne	a5,s10,40007d24 <execute+0x1f8>
40007cc8:	04050e63          	beqz	a0,40007d24 <execute+0x1f8>
			z_shell_fprintf(sh, SHELL_ERROR,
40007ccc:	40034637          	lui	a2,0x40034
40007cd0:	a5060613          	addi	a2,a2,-1456 # 40033a50 <shell_transport_uart_shell_uart+0x24>
40007cd4:	00100593          	li	a1,1
40007cd8:	00040513          	mv	a0,s0
40007cdc:	7e4020ef          	jal	ra,4000a4c0 <z_shell_fprintf>
			return -ENOEXEC;
40007ce0:	ff800493          	li	s1,-8
}
40007ce4:	0dc12083          	lw	ra,220(sp)
40007ce8:	0d812403          	lw	s0,216(sp)
40007cec:	0d012903          	lw	s2,208(sp)
40007cf0:	0cc12983          	lw	s3,204(sp)
40007cf4:	0c812a03          	lw	s4,200(sp)
40007cf8:	0c412a83          	lw	s5,196(sp)
40007cfc:	0c012b03          	lw	s6,192(sp)
40007d00:	0bc12b83          	lw	s7,188(sp)
40007d04:	0b812c03          	lw	s8,184(sp)
40007d08:	0b412c83          	lw	s9,180(sp)
40007d0c:	0b012d03          	lw	s10,176(sp)
40007d10:	0ac12d83          	lw	s11,172(sp)
40007d14:	00048513          	mv	a0,s1
40007d18:	0d412483          	lw	s1,212(sp)
40007d1c:	0e010113          	addi	sp,sp,224
40007d20:	00008067          	ret
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
40007d24:	01c12783          	lw	a5,28(sp)
40007d28:	0a078663          	beqz	a5,40007dd4 <execute+0x2a8>
		    z_shell_help_request(argvp[0])) {
40007d2c:	0009a503          	lw	a0,0(s3)
40007d30:	690030ef          	jal	ra,4000b3c0 <z_shell_help_request>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
40007d34:	02050e63          	beqz	a0,40007d70 <execute+0x244>
			if (help_entry.help) {
40007d38:	020a0063          	beqz	s4,40007d58 <execute+0x22c>
				sh->ctx->active_cmd = help_entry;
40007d3c:	00842503          	lw	a0,8(s0)
				sh->ctx->active_cmd = *help_entry;
40007d40:	01400613          	li	a2,20
40007d44:	03810593          	addi	a1,sp,56
40007d48:	00c50513          	addi	a0,a0,12
40007d4c:	03412e23          	sw	s4,60(sp)
40007d50:	7a9040ef          	jal	ra,4000ccf8 <memcpy>
40007d54:	f3dff06f          	j	40007c90 <execute+0x164>
			z_shell_fprintf(sh, SHELL_ERROR,
40007d58:	40034637          	lui	a2,0x40034
40007d5c:	a6460613          	addi	a2,a2,-1436 # 40033a64 <shell_transport_uart_shell_uart+0x38>
		z_shell_fprintf(sh, SHELL_ERROR,
40007d60:	00100593          	li	a1,1
40007d64:	00040513          	mv	a0,s0
40007d68:	758020ef          	jal	ra,4000a4c0 <z_shell_fprintf>
		return false;
40007d6c:	f75ff06f          	j	40007ce0 <execute+0x1b4>
		if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && (cmd_lvl > 0)) {
40007d70:	01c12783          	lw	a5,28(sp)
40007d74:	06078063          	beqz	a5,40007dd4 <execute+0x2a8>
			status = z_shell_wildcard_process(sh, entry,
40007d78:	0009a603          	lw	a2,0(s3)
40007d7c:	00048593          	mv	a1,s1
40007d80:	00040513          	mv	a0,s0
40007d84:	178040ef          	jal	ra,4000befc <z_shell_wildcard_process>
			if (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {
40007d88:	00200793          	li	a5,2
40007d8c:	02f51863          	bne	a0,a5,40007dbc <execute+0x290>
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
40007d90:	01c12703          	lw	a4,28(sp)
40007d94:	01300793          	li	a5,19
40007d98:	e8e7f2e3          	bgeu	a5,a4,40007c1c <execute+0xf0>
40007d9c:	02012703          	lw	a4,32(sp)
40007da0:	00200793          	li	a5,2
40007da4:	e6f71ce3          	bne	a4,a5,40007c1c <execute+0xf0>
		z_shell_fprintf(sh, SHELL_ERROR, "%s\n",
40007da8:	400346b7          	lui	a3,0x40034
40007dac:	40036637          	lui	a2,0x40036
40007db0:	ad068693          	addi	a3,a3,-1328 # 40033ad0 <shell_transport_uart_shell_uart+0xa4>
40007db4:	a1060613          	addi	a2,a2,-1520 # 40035a10 <CSWTCH.15846+0x3b0>
40007db8:	f1dff06f          	j	40007cd4 <execute+0x1a8>
			if (status != SHELL_WILDCARD_NOT_FOUND) {
40007dbc:	01b50c63          	beq	a0,s11,40007dd4 <execute+0x2a8>
				++cmd_lvl;
40007dc0:	01c12783          	lw	a5,28(sp)
				wildcard_found = true;
40007dc4:	00100c13          	li	s8,1
				++cmd_lvl;
40007dc8:	00178793          	addi	a5,a5,1
40007dcc:	00f12e23          	sw	a5,28(sp)
				continue;
40007dd0:	e35ff06f          	j	40007c04 <execute+0xd8>
		if (has_last_handler == false) {
40007dd4:	000c9c63          	bnez	s9,40007dec <execute+0x2c0>
			entry = z_shell_find_cmd(parent, argvp[0], &dloc);
40007dd8:	0009a583          	lw	a1,0(s3)
40007ddc:	02410613          	addi	a2,sp,36
40007de0:	000b0513          	mv	a0,s6
40007de4:	305010ef          	jal	ra,400098e8 <z_shell_find_cmd>
40007de8:	00050493          	mv	s1,a0
		argvp++;
40007dec:	00498993          	addi	s3,s3,4
		args_left--;
40007df0:	fff90913          	addi	s2,s2,-1
		if (entry) {
40007df4:	0a048663          	beqz	s1,40007ea0 <execute+0x374>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && found && entry->handler) {
40007df8:	00c4a783          	lw	a5,12(s1)
40007dfc:	020c0263          	beqz	s8,40007e20 <execute+0x2f4>
40007e00:	04078c63          	beqz	a5,40007e58 <execute+0x32c>
		z_shell_op_cursor_end_move(sh);
40007e04:	00040513          	mv	a0,s0
40007e08:	338020ef          	jal	ra,4000a140 <z_shell_op_cursor_end_move>
		z_shell_op_cond_next_line(sh);
40007e0c:	00040513          	mv	a0,s0
40007e10:	07c020ef          	jal	ra,40009e8c <z_shell_op_cond_next_line>
		z_shell_fprintf(sh, SHELL_ERROR,
40007e14:	40034637          	lui	a2,0x40034
40007e18:	a8460613          	addi	a2,a2,-1404 # 40033a84 <shell_transport_uart_shell_uart+0x58>
40007e1c:	f45ff06f          	j	40007d60 <execute+0x234>
	if (entry->handler) {
40007e20:	02078c63          	beqz	a5,40007e58 <execute+0x32c>
			active_cmd_prepare(entry, &sh->ctx->active_cmd,
40007e24:	00842503          	lw	a0,8(s0)
		*active_cmd = *entry;
40007e28:	01400613          	li	a2,20
40007e2c:	00048593          	mv	a1,s1
40007e30:	00c50513          	addi	a0,a0,12
		*handler_lvl = *lvl;
40007e34:	01c12a83          	lw	s5,28(sp)
		*active_cmd = *entry;
40007e38:	6c1040ef          	jal	ra,4000ccf8 <memcpy>
		if ((entry->subcmd == NULL)
40007e3c:	0084a783          	lw	a5,8(s1)
40007e40:	00079c63          	bnez	a5,40007e58 <execute+0x32c>
		    && entry->args.optional == SHELL_OPT_ARG_RAW) {
40007e44:	0114c703          	lbu	a4,17(s1)
40007e48:	0fe00793          	li	a5,254
40007e4c:	00f71663          	bne	a4,a5,40007e58 <execute+0x32c>
			*args_left = entry->args.mandatory - 1;
40007e50:	0104c903          	lbu	s2,16(s1)
40007e54:	fff90913          	addi	s2,s2,-1
	if (entry->help) {
40007e58:	0044a783          	lw	a5,4(s1)
40007e5c:	00048b13          	mv	s6,s1
40007e60:	00f12623          	sw	a5,12(sp)
40007e64:	00078e63          	beqz	a5,40007e80 <execute+0x354>
		*help_entry = *entry;
40007e68:	01400613          	li	a2,20
40007e6c:	00048593          	mv	a1,s1
40007e70:	03810513          	addi	a0,sp,56
40007e74:	685040ef          	jal	ra,4000ccf8 <memcpy>
40007e78:	00c12783          	lw	a5,12(sp)
40007e7c:	00078a13          	mv	s4,a5
		if (args_left || (argc == 2)) {
40007e80:	02012703          	lw	a4,32(sp)
40007e84:	00091663          	bnez	s2,40007e90 <execute+0x364>
40007e88:	00200793          	li	a5,2
40007e8c:	d6f71ce3          	bne	a4,a5,40007c04 <execute+0xd8>
			cmd_lvl++;
40007e90:	01c12783          	lw	a5,28(sp)
40007e94:	00178793          	addi	a5,a5,1
40007e98:	00f12e23          	sw	a5,28(sp)
40007e9c:	d69ff06f          	j	40007c04 <execute+0xd8>
			if (cmd_lvl == 0 &&
40007ea0:	01c12783          	lw	a5,28(sp)
40007ea4:	00078663          	beqz	a5,40007eb0 <execute+0x384>
			has_last_handler = true;
40007ea8:	00100c93          	li	s9,1
40007eac:	fd5ff06f          	j	40007e80 <execute+0x354>
	z_shell_fprintf_buffer_flush(sh->fprintf_ctx);
}

static inline bool z_shell_in_select_mode(const struct shell *sh)
{
	return sh->ctx->selected_cmd == NULL ? false : true;
40007eb0:	00842783          	lw	a5,8(s0)
40007eb4:	0207a783          	lw	a5,32(a5)
			if (cmd_lvl == 0 &&
40007eb8:	00078663          	beqz	a5,40007ec4 <execute+0x398>
				(!z_shell_in_select_mode(sh) ||
40007ebc:	00c7a783          	lw	a5,12(a5)
40007ec0:	fe0794e3          	bnez	a5,40007ea8 <execute+0x37c>
				z_shell_fprintf(sh, SHELL_ERROR,
40007ec4:	04c12683          	lw	a3,76(sp)
40007ec8:	40034737          	lui	a4,0x40034
40007ecc:	40034637          	lui	a2,0x40034
40007ed0:	ab470713          	addi	a4,a4,-1356 # 40033ab4 <shell_transport_uart_shell_uart+0x88>
40007ed4:	ac860613          	addi	a2,a2,-1336 # 40033ac8 <shell_transport_uart_shell_uart+0x9c>
40007ed8:	00100593          	li	a1,1
40007edc:	00040513          	mv	a0,s0
40007ee0:	5e0020ef          	jal	ra,4000a4c0 <z_shell_fprintf>
40007ee4:	fc5ff06f          	j	40007ea8 <execute+0x37c>
	if (sh->ctx->active_cmd.args.mandatory) {
40007ee8:	01c54703          	lbu	a4,28(a0)
	return exec_cmd(sh, cmd_lvl - cmd_with_handler_lvl,
40007eec:	415484b3          	sub	s1,s1,s5
	if (sh->ctx->active_cmd.args.mandatory) {
40007ef0:	04070663          	beqz	a4,40007f3c <execute+0x410>
		uint8_t opt8 = sh->ctx->active_cmd.args.optional;
40007ef4:	01d54783          	lbu	a5,29(a0)
				UINT16_MAX : opt8;
40007ef8:	0ff00693          	li	a3,255
40007efc:	00d79663          	bne	a5,a3,40007f08 <execute+0x3dc>
40007f00:	000107b7          	lui	a5,0x10
40007f04:	fff78793          	addi	a5,a5,-1 # ffff <__kernel_ram_size+0x44f7>
		const bool in_range = IN_RANGE(argc, mand, mand + opt);
40007f08:	00e4e663          	bltu	s1,a4,40007f14 <execute+0x3e8>
40007f0c:	00f70733          	add	a4,a4,a5
40007f10:	02977663          	bgeu	a4,s1,40007f3c <execute+0x410>
		z_shell_fprintf(sh, SHELL_ERROR,
40007f14:	00c52683          	lw	a3,12(a0)
40007f18:	40034637          	lui	a2,0x40034
40007f1c:	af460613          	addi	a2,a2,-1292 # 40033af4 <shell_transport_uart_shell_uart+0xc8>
40007f20:	00100593          	li	a1,1
40007f24:	00040513          	mv	a0,s0
40007f28:	598020ef          	jal	ra,4000a4c0 <z_shell_fprintf>
			shell_internal_help_print(sh);
40007f2c:	00040513          	mv	a0,s0
40007f30:	981ff0ef          	jal	ra,400078b0 <shell_internal_help_print>
		return -EINVAL;
40007f34:	fea00493          	li	s1,-22
40007f38:	dadff06f          	j	40007ce4 <execute+0x1b8>
		z_flag_cmd_ctx_set(sh, true);
40007f3c:	00100593          	li	a1,1
40007f40:	a69ff0ef          	jal	ra,400079a8 <z_flag_cmd_ctx_set.isra.0>
		k_mutex_unlock(&sh->ctx->wr_mtx);
40007f44:	00842503          	lw	a0,8(s0)
40007f48:	30450513          	addi	a0,a0,772
40007f4c:	bddff0ef          	jal	ra,40007b28 <k_mutex_unlock.isra.0>
		ret_val = sh->ctx->active_cmd.handler(sh, argc,
40007f50:	00842783          	lw	a5,8(s0)
40007f54:	04c10713          	addi	a4,sp,76
	return exec_cmd(sh, cmd_lvl - cmd_with_handler_lvl,
40007f58:	002a9613          	slli	a2,s5,0x2
		ret_val = sh->ctx->active_cmd.handler(sh, argc,
40007f5c:	0187a783          	lw	a5,24(a5)
40007f60:	00c70633          	add	a2,a4,a2
40007f64:	00048593          	mv	a1,s1
40007f68:	00040513          	mv	a0,s0
40007f6c:	000780e7          	jalr	a5
40007f70:	00050493          	mv	s1,a0
		k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
40007f74:	00842503          	lw	a0,8(s0)
40007f78:	fff00593          	li	a1,-1
40007f7c:	fff00613          	li	a2,-1
40007f80:	30450513          	addi	a0,a0,772
40007f84:	96dff0ef          	jal	ra,400078f0 <k_mutex_lock.constprop.0.isra.0>
		z_flag_cmd_ctx_set(sh, false);
40007f88:	00842503          	lw	a0,8(s0)
40007f8c:	00000593          	li	a1,0
40007f90:	a19ff0ef          	jal	ra,400079a8 <z_flag_cmd_ctx_set.isra.0>
40007f94:	d51ff06f          	j	40007ce4 <execute+0x1b8>

40007f98 <shell_log_process>:
{
40007f98:	fe010113          	addi	sp,sp,-32
40007f9c:	00812c23          	sw	s0,24(sp)
40007fa0:	00112e23          	sw	ra,28(sp)
40007fa4:	00912a23          	sw	s1,20(sp)
40007fa8:	01212823          	sw	s2,16(sp)
40007fac:	00050413          	mv	s0,a0
	int signaled = 0;
40007fb0:	00012423          	sw	zero,8(sp)
			z_shell_cmd_line_erase(sh);
40007fb4:	00040513          	mv	a0,s0
40007fb8:	1f8020ef          	jal	ra,4000a1b0 <z_shell_cmd_line_erase>
			processed = z_shell_log_backend_process(
40007fbc:	01c42503          	lw	a0,28(s0)
40007fc0:	72d020ef          	jal	ra,4000aeec <z_shell_log_backend_process>
40007fc4:	00050493          	mv	s1,a0
		z_shell_print_prompt_and_cmd(sh);
40007fc8:	00040513          	mv	a0,s0
		struct k_poll_signal *signal =
40007fcc:	00842903          	lw	s2,8(s0)
		z_shell_print_prompt_and_cmd(sh);
40007fd0:	215020ef          	jal	ra,4000a9e4 <z_shell_print_prompt_and_cmd>
		if (sh->ctx->cmd_buff_len) {
40007fd4:	00842783          	lw	a5,8(s0)
		struct k_poll_signal *signal =
40007fd8:	27490913          	addi	s2,s2,628
		if (sh->ctx->cmd_buff_len) {
40007fdc:	0487d783          	lhu	a5,72(a5)
40007fe0:	00078863          	beqz	a5,40007ff0 <shell_log_process+0x58>
	return z_impl_k_sleep(timeout);
40007fe4:	00200513          	li	a0,2
40007fe8:	00000593          	li	a1,0
40007fec:	719280ef          	jal	ra,40030f04 <z_impl_k_sleep>
	z_impl_k_poll_signal_check(sig, signaled, result);
40007ff0:	00c10613          	addi	a2,sp,12
40007ff4:	00810593          	addi	a1,sp,8
40007ff8:	00090513          	mv	a0,s2
40007ffc:	0b42a0ef          	jal	ra,400320b0 <z_impl_k_poll_signal_check>
	} while (processed && !signaled);
40008000:	00048663          	beqz	s1,4000800c <shell_log_process+0x74>
40008004:	00812783          	lw	a5,8(sp)
40008008:	fa0786e3          	beqz	a5,40007fb4 <shell_log_process+0x1c>
}
4000800c:	01c12083          	lw	ra,28(sp)
40008010:	01812403          	lw	s0,24(sp)
40008014:	01412483          	lw	s1,20(sp)
40008018:	01012903          	lw	s2,16(sp)
4000801c:	02010113          	addi	sp,sp,32
40008020:	00008067          	ret

40008024 <state_set.constprop.0>:
	sh->ctx->state = state;
40008024:	00852783          	lw	a5,8(a0)
40008028:	00200713          	li	a4,2
4000802c:	00e7a223          	sw	a4,4(a5)
	if (state == SHELL_STATE_ACTIVE && !sh->ctx->bypass) {
40008030:	00852783          	lw	a5,8(a0)
40008034:	0447a783          	lw	a5,68(a5)
40008038:	06079863          	bnez	a5,400080a8 <state_set.constprop.0+0x84>
static inline void state_set(const struct shell *sh, enum shell_state state)
4000803c:	ff010113          	addi	sp,sp,-16
40008040:	00812423          	sw	s0,8(sp)
40008044:	00112623          	sw	ra,12(sp)
40008048:	00050413          	mv	s0,a0
		cmd_buffer_clear(sh);
4000804c:	f78ff0ef          	jal	ra,400077c4 <cmd_buffer_clear>
	return sh->ctx->ctx.flags.print_noinit == 1;
40008050:	00842783          	lw	a5,8(s0)
40008054:	2707a783          	lw	a5,624(a5)
40008058:	00c7d793          	srli	a5,a5,0xc
4000805c:	0017f793          	andi	a5,a5,1
		if (z_flag_print_noinit_get(sh)) {
40008060:	02078a63          	beqz	a5,40008094 <state_set.constprop.0+0x70>
			z_shell_fprintf(sh, SHELL_WARNING, "%s",
40008064:	400346b7          	lui	a3,0x40034
40008068:	40033637          	lui	a2,0x40033
4000806c:	00300593          	li	a1,3
40008070:	00040513          	mv	a0,s0
40008074:	b1068693          	addi	a3,a3,-1264 # 40033b10 <shell_transport_uart_shell_uart+0xe4>
40008078:	af860613          	addi	a2,a2,-1288 # 40032af8 <mpsc_config+0x9c>
4000807c:	444020ef          	jal	ra,4000a4c0 <z_shell_fprintf>
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, print_noinit, val, ret);
40008080:	00842503          	lw	a0,8(s0)
40008084:	fffff5b7          	lui	a1,0xfffff
40008088:	fff58593          	addi	a1,a1,-1 # ffffefff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfffff000>
4000808c:	27050513          	addi	a0,a0,624
40008090:	f54ff0ef          	jal	ra,400077e4 <atomic_and>
		z_shell_print_prompt_and_cmd(sh);
40008094:	00040513          	mv	a0,s0
}
40008098:	00812403          	lw	s0,8(sp)
4000809c:	00c12083          	lw	ra,12(sp)
400080a0:	01010113          	addi	sp,sp,16
		z_shell_print_prompt_and_cmd(sh);
400080a4:	1410206f          	j	4000a9e4 <z_shell_print_prompt_and_cmd>
400080a8:	00008067          	ret

400080ac <shell_process>:

	return 0;
}

void shell_process(const struct shell *sh)
{
400080ac:	f0010113          	addi	sp,sp,-256
400080b0:	0e812c23          	sw	s0,248(sp)
400080b4:	0e112e23          	sw	ra,252(sp)
400080b8:	0e912a23          	sw	s1,244(sp)
400080bc:	0f212823          	sw	s2,240(sp)
400080c0:	0f312623          	sw	s3,236(sp)
400080c4:	0f412423          	sw	s4,232(sp)
400080c8:	0f512223          	sw	s5,228(sp)
400080cc:	0f612023          	sw	s6,224(sp)
400080d0:	0d712e23          	sw	s7,220(sp)
400080d4:	0d812c23          	sw	s8,216(sp)
400080d8:	0d912a23          	sw	s9,212(sp)
400080dc:	0da12823          	sw	s10,208(sp)
400080e0:	0db12623          	sw	s11,204(sp)
400080e4:	00050413          	mv	s0,a0
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, processing, val, ret);
400080e8:	00852503          	lw	a0,8(a0)
400080ec:	00100593          	li	a1,1
400080f0:	27050513          	addi	a0,a0,624
400080f4:	eecff0ef          	jal	ra,400077e0 <atomic_or>
	__ASSERT_NO_MSG(sh->ctx);

	/* atomically set the processing flag */
	z_flag_processing_set(sh, true);

	switch (sh->ctx->state) {
400080f8:	00842783          	lw	a5,8(s0)
400080fc:	0047a703          	lw	a4,4(a5)
40008100:	00200793          	li	a5,2
40008104:	06f71c63          	bne	a4,a5,4000817c <shell_process+0xd0>
	size_t count = 0;
40008108:	02012223          	sw	zero,36(sp)
		switch (sh->ctx->receive_state) {
4000810c:	00200b13          	li	s6,2
		shell_bypass_cb_t bypass = sh->ctx->bypass;
40008110:	00842783          	lw	a5,8(s0)
			(void)sh->iface->api->read(sh->iface, buf,
40008114:	00442503          	lw	a0,4(s0)
40008118:	02410693          	addi	a3,sp,36
		shell_bypass_cb_t bypass = sh->ctx->bypass;
4000811c:	0447a483          	lw	s1,68(a5)
			(void)sh->iface->api->read(sh->iface, buf,
40008120:	00052783          	lw	a5,0(a0)
40008124:	0107a783          	lw	a5,16(a5)
		if (bypass) {
40008128:	08048e63          	beqz	s1,400081c4 <shell_process+0x118>
			(void)sh->iface->api->read(sh->iface, buf,
4000812c:	01000613          	li	a2,16
40008130:	06c10593          	addi	a1,sp,108
40008134:	000780e7          	jalr	a5
			if (count) {
40008138:	02412783          	lw	a5,36(sp)
4000813c:	04078063          	beqz	a5,4000817c <shell_process+0xd0>
				z_flag_cmd_ctx_set(sh, true);
40008140:	00842503          	lw	a0,8(s0)
40008144:	00100593          	li	a1,1
40008148:	861ff0ef          	jal	ra,400079a8 <z_flag_cmd_ctx_set.isra.0>
				bypass(sh, buf, count);
4000814c:	02412603          	lw	a2,36(sp)
40008150:	06c10593          	addi	a1,sp,108
40008154:	00040513          	mv	a0,s0
40008158:	000480e7          	jalr	s1
				z_flag_cmd_ctx_set(sh, false);
4000815c:	00842503          	lw	a0,8(s0)
40008160:	00000593          	li	a1,0
40008164:	845ff0ef          	jal	ra,400079a8 <z_flag_cmd_ctx_set.isra.0>
				if (!(volatile shell_bypass_cb_t *)sh->ctx->bypass) {
40008168:	00842783          	lw	a5,8(s0)
4000816c:	0447a783          	lw	a5,68(a5)
40008170:	fa0790e3          	bnez	a5,40008110 <shell_process+0x64>
					state_set(sh, SHELL_STATE_ACTIVE);
40008174:	00040513          	mv	a0,s0
40008178:	eadff0ef          	jal	ra,40008024 <state_set.constprop.0>
4000817c:	00842503          	lw	a0,8(s0)
		break;
	}

	/* atomically clear the processing flag */
	z_flag_processing_set(sh, false);
}
40008180:	0f812403          	lw	s0,248(sp)
40008184:	0fc12083          	lw	ra,252(sp)
40008188:	0f412483          	lw	s1,244(sp)
4000818c:	0f012903          	lw	s2,240(sp)
40008190:	0ec12983          	lw	s3,236(sp)
40008194:	0e812a03          	lw	s4,232(sp)
40008198:	0e412a83          	lw	s5,228(sp)
4000819c:	0e012b03          	lw	s6,224(sp)
400081a0:	0dc12b83          	lw	s7,220(sp)
400081a4:	0d812c03          	lw	s8,216(sp)
400081a8:	0d412c83          	lw	s9,212(sp)
400081ac:	0d012d03          	lw	s10,208(sp)
400081b0:	0cc12d83          	lw	s11,204(sp)
400081b4:	ffe00593          	li	a1,-2
400081b8:	27050513          	addi	a0,a0,624
400081bc:	10010113          	addi	sp,sp,256
400081c0:	e24ff06f          	j	400077e4 <atomic_and>
		(void)sh->iface->api->read(sh->iface, &data,
400081c4:	00100613          	li	a2,1
400081c8:	02310593          	addi	a1,sp,35
400081cc:	000780e7          	jalr	a5
		if (count == 0) {
400081d0:	02412783          	lw	a5,36(sp)
400081d4:	fa0784e3          	beqz	a5,4000817c <shell_process+0xd0>
		if (ascii_filter(data) != 0) {
400081d8:	02314783          	lbu	a5,35(sp)
		switch (sh->ctx->receive_state) {
400081dc:	00842703          	lw	a4,8(s0)
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
400081e0:	01879693          	slli	a3,a5,0x18
400081e4:	4186d693          	srai	a3,a3,0x18
400081e8:	f206c4e3          	bltz	a3,40008110 <shell_process+0x64>
		switch (sh->ctx->receive_state) {
400081ec:	00872a83          	lw	s5,8(a4)
400081f0:	7d6a8463          	beq	s5,s6,400089b8 <shell_process+0x90c>
400081f4:	075b6e63          	bltu	s6,s5,40008270 <shell_process+0x1c4>
400081f8:	760a9a63          	bnez	s5,4000896c <shell_process+0x8c0>
	if ((data != '\r') && (data != '\n')) {
400081fc:	00d00693          	li	a3,13
40008200:	12d78063          	beq	a5,a3,40008320 <shell_process+0x274>
40008204:	00a00693          	li	a3,10
40008208:	0ad78063          	beq	a5,a3,400082a8 <shell_process+0x1fc>
	sh->ctx->ctx.flags.last_nl = val;
4000820c:	27075683          	lhu	a3,624(a4)
40008210:	8076f693          	andi	a3,a3,-2041
40008214:	26d71823          	sh	a3,624(a4)
			switch (data) {
40008218:	00900713          	li	a4,9
4000821c:	00842503          	lw	a0,8(s0)
40008220:	12e78e63          	beq	a5,a4,4000835c <shell_process+0x2b0>
40008224:	04f76a63          	bltu	a4,a5,40008278 <shell_process+0x1cc>
40008228:	ee0784e3          	beqz	a5,40008110 <shell_process+0x64>
4000822c:	00800713          	li	a4,8
40008230:	5ce78663          	beq	a5,a4,400087fc <shell_process+0x750>
40008234:	00050713          	mv	a4,a0
	return sh->ctx->cfg.flags.echo == 1;
40008238:	26c72683          	lw	a3,620(a4)
4000823c:	0016d693          	srli	a3,a3,0x1
40008240:	0016f693          	andi	a3,a3,1
				} else if (z_flag_echo_get(sh)) {
40008244:	ec0686e3          	beqz	a3,40008110 <shell_process+0x64>
	switch (data) {
40008248:	fff78793          	addi	a5,a5,-1
4000824c:	0ff7f793          	zext.b	a5,a5
40008250:	01600693          	li	a3,22
40008254:	eaf6eee3          	bltu	a3,a5,40008110 <shell_process+0x64>
40008258:	400346b7          	lui	a3,0x40034
4000825c:	00279793          	slli	a5,a5,0x2
40008260:	b6068693          	addi	a3,a3,-1184 # 40033b60 <shell_transport_uart_shell_uart+0x134>
40008264:	00d787b3          	add	a5,a5,a3
40008268:	0007a783          	lw	a5,0(a5)
4000826c:	00078067          	jr	a5
	sh->ctx->receive_state = state;
40008270:	00072423          	sw	zero,8(a4)
40008274:	e9dff06f          	j	40008110 <shell_process+0x64>
40008278:	01b00713          	li	a4,27
4000827c:	0ce78a63          	beq	a5,a4,40008350 <shell_process+0x2a4>
40008280:	07f00713          	li	a4,127
40008284:	58e78e63          	beq	a5,a4,40008820 <shell_process+0x774>
40008288:	fe078693          	addi	a3,a5,-32
				if (isprint((int) data) != 0) {
4000828c:	05e00613          	li	a2,94
40008290:	00050713          	mv	a4,a0
40008294:	fad662e3          	bltu	a2,a3,40008238 <shell_process+0x18c>
					z_flag_history_exit_set(sh, true);
40008298:	00100593          	li	a1,1
4000829c:	f2cff0ef          	jal	ra,400079c8 <z_flag_history_exit_set.isra.0>
					z_shell_op_char_insert(sh, data);
400082a0:	02314583          	lbu	a1,35(sp)
400082a4:	2f00006f          	j	40008594 <shell_process+0x4e8>
	return sh->ctx->ctx.flags.last_nl;
400082a8:	27072683          	lw	a3,624(a4)
400082ac:	0036d693          	srli	a3,a3,0x3
400082b0:	0ff6f693          	zext.b	a3,a3
	if ((z_flag_last_nl_get(sh) == 0U) ||
400082b4:	02068463          	beqz	a3,400082dc <shell_process+0x230>
400082b8:	27072683          	lw	a3,624(a4)
400082bc:	0036d693          	srli	a3,a3,0x3
400082c0:	0ff6f693          	zext.b	a3,a3
400082c4:	f6f69ae3          	bne	a3,a5,40008238 <shell_process+0x18c>
	sh->ctx->ctx.flags.last_nl = val;
400082c8:	00379693          	slli	a3,a5,0x3
400082cc:	27075783          	lhu	a5,624(a4)
400082d0:	8077f793          	andi	a5,a5,-2041
400082d4:	00d7e7b3          	or	a5,a5,a3
400082d8:	0100006f          	j	400082e8 <shell_process+0x23c>
400082dc:	27075783          	lhu	a5,624(a4)
400082e0:	8077f793          	andi	a5,a5,-2041
400082e4:	0507e793          	ori	a5,a5,80
400082e8:	26f71823          	sh	a5,624(a4)
				if (!sh->ctx->cmd_buff_len) {
400082ec:	00842483          	lw	s1,8(s0)
400082f0:	0484d783          	lhu	a5,72(s1)
400082f4:	04079663          	bnez	a5,40008340 <shell_process+0x294>
	z_flag_history_exit_set(sh, false);
400082f8:	00000593          	li	a1,0
400082fc:	00048513          	mv	a0,s1
40008300:	ec8ff0ef          	jal	ra,400079c8 <z_flag_history_exit_set.isra.0>
	z_shell_history_mode_exit(sh->history);
40008304:	00c42503          	lw	a0,12(s0)
40008308:	0a5030ef          	jal	ra,4000bbac <z_shell_history_mode_exit>
					z_cursor_next_line_move(sh);
4000830c:	01442503          	lw	a0,20(s0)
40008310:	e8cff0ef          	jal	ra,4000799c <z_cursor_next_line_move.isra.0>
		state_set(sh, SHELL_STATE_ACTIVE);
40008314:	00040513          	mv	a0,s0
40008318:	d0dff0ef          	jal	ra,40008024 <state_set.constprop.0>
		break;
4000831c:	df5ff06f          	j	40008110 <shell_process+0x64>
	return sh->ctx->ctx.flags.last_nl;
40008320:	27072683          	lw	a3,624(a4)
40008324:	0036d693          	srli	a3,a3,0x3
40008328:	0ff6f693          	zext.b	a3,a3
	if ((z_flag_last_nl_get(sh) == 0U) ||
4000832c:	f80696e3          	bnez	a3,400082b8 <shell_process+0x20c>
	sh->ctx->ctx.flags.last_nl = val;
40008330:	27075783          	lhu	a5,624(a4)
40008334:	8077f793          	andi	a5,a5,-2041
40008338:	0687e793          	ori	a5,a5,104
4000833c:	fadff06f          	j	400082e8 <shell_process+0x23c>
					sh->ctx->ret_val = execute(sh);
40008340:	00040513          	mv	a0,s0
40008344:	fe8ff0ef          	jal	ra,40007b2c <execute>
40008348:	30a4ae23          	sw	a0,796(s1)
				state_set(sh, SHELL_STATE_ACTIVE);
4000834c:	fc9ff06f          	j	40008314 <shell_process+0x268>
	sh->ctx->receive_state = state;
40008350:	00100793          	li	a5,1
40008354:	00f52423          	sw	a5,8(a0)
}
40008358:	db9ff06f          	j	40008110 <shell_process+0x64>
	return sh->ctx->cfg.flags.echo == 1;
4000835c:	26c52783          	lw	a5,620(a0)
40008360:	0017d793          	srli	a5,a5,0x1
40008364:	0017f793          	andi	a5,a5,1
				if (z_flag_echo_get(sh) &&
40008368:	da0784e3          	beqz	a5,40008110 <shell_process+0x64>
					z_flag_history_exit_set(sh, true);
4000836c:	00100593          	li	a1,1
40008370:	e58ff0ef          	jal	ra,400079c8 <z_flag_history_exit_set.isra.0>
			sh->ctx->cmd_buff_len;
40008374:	00842503          	lw	a0,8(s0)
	if (compl_space == 0U) {
40008378:	0ff00793          	li	a5,255
4000837c:	04855703          	lhu	a4,72(a0)
40008380:	d8f708e3          	beq	a4,a5,40008110 <shell_process+0x64>
	memcpy(sh->ctx->temp_buff, sh->ctx->cmd_buff,
40008384:	04a55603          	lhu	a2,74(a0)
40008388:	04e50593          	addi	a1,a0,78
4000838c:	14e50513          	addi	a0,a0,334
40008390:	169040ef          	jal	ra,4000ccf8 <memcpy>
	sh->ctx->temp_buff[sh->ctx->cmd_buff_pos] = '\0';
40008394:	00842783          	lw	a5,8(s0)
	(void)z_shell_make_argv(argc, *argv, sh->ctx->temp_buff,
40008398:	06c10593          	addi	a1,sp,108
4000839c:	01400693          	li	a3,20
	sh->ctx->temp_buff[sh->ctx->cmd_buff_pos] = '\0';
400083a0:	04a7d703          	lhu	a4,74(a5)
	(void)z_shell_make_argv(argc, *argv, sh->ctx->temp_buff,
400083a4:	02c10513          	addi	a0,sp,44
	sh->ctx->temp_buff[sh->ctx->cmd_buff_pos] = '\0';
400083a8:	00e787b3          	add	a5,a5,a4
400083ac:	14078723          	sb	zero,334(a5)
	(void)z_shell_make_argv(argc, *argv, sh->ctx->temp_buff,
400083b0:	00842603          	lw	a2,8(s0)
400083b4:	14e60613          	addi	a2,a2,334
400083b8:	07c010ef          	jal	ra,40009434 <z_shell_make_argv>
	if (*argc > CONFIG_SHELL_ARGC_MAX) {
400083bc:	02c12583          	lw	a1,44(sp)
400083c0:	01400793          	li	a5,20
400083c4:	d4b7e6e3          	bltu	a5,a1,40008110 <shell_process+0x64>
	(*argv)[*argc] = NULL;
400083c8:	00259793          	slli	a5,a1,0x2
400083cc:	02010713          	addi	a4,sp,32
400083d0:	0a078793          	addi	a5,a5,160
400083d4:	00e787b3          	add	a5,a5,a4
400083d8:	fa07a623          	sw	zero,-84(a5)
	int space = isspace((int)sh->ctx->cmd_buff[
400083dc:	00842783          	lw	a5,8(s0)
						sh->ctx->cmd_buff_pos - 1]);
400083e0:	04a7d703          	lhu	a4,74(a5)
	int space = isspace((int)sh->ctx->cmd_buff[
400083e4:	00e787b3          	add	a5,a5,a4
400083e8:	04d7c783          	lbu	a5,77(a5)
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
400083ec:	02000713          	li	a4,32
400083f0:	00e78863          	beq	a5,a4,40008400 <shell_process+0x354>
400083f4:	ff778793          	addi	a5,a5,-9
400083f8:	00400713          	li	a4,4
400083fc:	0ef76a63          	bltu	a4,a5,400084f0 <shell_process+0x444>
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
40008400:	0e059e63          	bnez	a1,400084fc <shell_process+0x450>
		*complete_arg_idx = Z_SHELL_CMD_ROOT_LVL;
40008404:	02012423          	sw	zero,40(sp)
		*cmd = selected_cmd_get(sh);
40008408:	00000493          	li	s1,0
	find_completion_candidates(sh, cmd, argv[arg_idx], &first, &cnt,
4000840c:	02812783          	lw	a5,40(sp)
40008410:	02010713          	addi	a4,sp,32
	*cnt = 0;
40008414:	00000913          	li	s2,0
	find_completion_candidates(sh, cmd, argv[arg_idx], &first, &cnt,
40008418:	00279793          	slli	a5,a5,0x2
4000841c:	0a078793          	addi	a5,a5,160
40008420:	00e787b3          	add	a5,a5,a4
40008424:	fac7ac83          	lw	s9,-84(a5)
	size_t first = 0;
40008428:	00000a13          	li	s4,0
	*longest = 0U;
4000842c:	00000993          	li	s3,0
	incompl_cmd_len = z_shell_strlen(incompl_cmd);
40008430:	000c8513          	mv	a0,s9
40008434:	c18ff0ef          	jal	ra,4000784c <z_shell_strlen>
40008438:	00050c13          	mv	s8,a0
	while ((candidate = z_shell_cmd_get(cmd, idx, &dloc)) != NULL) {
4000843c:	05810613          	addi	a2,sp,88
40008440:	000a8593          	mv	a1,s5
40008444:	00048513          	mv	a0,s1
40008448:	3d4010ef          	jal	ra,4000981c <z_shell_cmd_get>
4000844c:	00050b93          	mv	s7,a0
40008450:	0c051863          	bnez	a0,40008520 <shell_process+0x474>
	if (cnt == 1) {
40008454:	00100793          	li	a5,1
40008458:	14f91463          	bne	s2,a5,400085a0 <shell_process+0x4f4>
		autocomplete(sh, cmd, argv[arg_idx], first);
4000845c:	02812783          	lw	a5,40(sp)
40008460:	02010713          	addi	a4,sp,32
40008464:	00279793          	slli	a5,a5,0x2
40008468:	0a078793          	addi	a5,a5,160
4000846c:	00e787b3          	add	a5,a5,a4
	uint16_t arg_len = z_shell_strlen(arg);
40008470:	fac7a503          	lw	a0,-84(a5)
40008474:	bd8ff0ef          	jal	ra,4000784c <z_shell_strlen>
	match = z_shell_cmd_get(cmd, subcmd_idx, &sh->ctx->active_cmd);
40008478:	00842603          	lw	a2,8(s0)
	uint16_t arg_len = z_shell_strlen(arg);
4000847c:	00050913          	mv	s2,a0
	match = z_shell_cmd_get(cmd, subcmd_idx, &sh->ctx->active_cmd);
40008480:	000a0593          	mv	a1,s4
40008484:	00048513          	mv	a0,s1
40008488:	00c60613          	addi	a2,a2,12
4000848c:	390010ef          	jal	ra,4000981c <z_shell_cmd_get>
40008490:	00050493          	mv	s1,a0
	cmd_len = z_shell_strlen(match->syntax);
40008494:	00052503          	lw	a0,0(a0)
40008498:	bb4ff0ef          	jal	ra,4000784c <z_shell_strlen>
	if (cmd_len != arg_len) {
4000849c:	02a90063          	beq	s2,a0,400084bc <shell_process+0x410>
		z_shell_op_completion_insert(sh,
400084a0:	0004a583          	lw	a1,0(s1)
400084a4:	41250633          	sub	a2,a0,s2
400084a8:	01061613          	slli	a2,a2,0x10
400084ac:	01065613          	srli	a2,a2,0x10
400084b0:	012585b3          	add	a1,a1,s2
400084b4:	00040513          	mv	a0,s0
400084b8:	454020ef          	jal	ra,4000a90c <z_shell_op_completion_insert>
	if (isspace((int) sh->ctx->cmd_buff[
400084bc:	00842503          	lw	a0,8(s0)
400084c0:	02000713          	li	a4,32
					sh->ctx->cmd_buff_pos]) == 0) {
400084c4:	04a55783          	lhu	a5,74(a0)
	if (isspace((int) sh->ctx->cmd_buff[
400084c8:	00f507b3          	add	a5,a0,a5
400084cc:	04e7c783          	lbu	a5,78(a5)
400084d0:	00e78863          	beq	a5,a4,400084e0 <shell_process+0x434>
400084d4:	ff778793          	addi	a5,a5,-9
400084d8:	00400713          	li	a4,4
400084dc:	08f76263          	bltu	a4,a5,40008560 <shell_process+0x4b4>
		z_shell_op_cursor_move(sh, 1);
400084e0:	00100593          	li	a1,1
400084e4:	00040513          	mv	a0,s0
400084e8:	281010ef          	jal	ra,40009f68 <z_shell_op_cursor_move>
400084ec:	c25ff06f          	j	40008110 <shell_process+0x64>
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
400084f0:	00100793          	li	a5,1
400084f4:	f0b7f8e3          	bgeu	a5,a1,40008404 <shell_process+0x358>
	search_argc = space ? *argc : *argc - 1;
400084f8:	fff58593          	addi	a1,a1,-1
	*cmd = z_shell_get_last_command(selected_cmd_get(sh), search_argc,
400084fc:	00000793          	li	a5,0
40008500:	03010713          	addi	a4,sp,48
40008504:	02810693          	addi	a3,sp,40
40008508:	06c10613          	addi	a2,sp,108
4000850c:	00000513          	li	a0,0
40008510:	46c010ef          	jal	ra,4000997c <z_shell_get_last_command>
40008514:	00050493          	mv	s1,a0
	if ((*cmd == NULL) && (search_argc != 0)) {
40008518:	ee051ae3          	bnez	a0,4000840c <shell_process+0x360>
4000851c:	bf5ff06f          	j	40008110 <shell_process+0x64>
	return (strncmp(candidate, str, len) == 0) ? true : false;
40008520:	000ba503          	lw	a0,0(s7)
40008524:	000c0613          	mv	a2,s8
40008528:	000c8593          	mv	a1,s9
4000852c:	710040ef          	jal	ra,4000cc3c <strncmp>
		if (is_candidate) {
40008530:	02051463          	bnez	a0,40008558 <shell_process+0x4ac>
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
40008534:	000ba503          	lw	a0,0(s7)
40008538:	69c040ef          	jal	ra,4000cbd4 <strlen>
4000853c:	00a9f463          	bgeu	s3,a0,40008544 <shell_process+0x498>
40008540:	00050993          	mv	s3,a0
40008544:	01099993          	slli	s3,s3,0x10
40008548:	0109d993          	srli	s3,s3,0x10
			if (*cnt == 0) {
4000854c:	00091463          	bnez	s2,40008554 <shell_process+0x4a8>
				*first_idx = idx;
40008550:	000a8a13          	mv	s4,s5
			(*cnt)++;
40008554:	00190913          	addi	s2,s2,1
		idx++;
40008558:	001a8a93          	addi	s5,s5,1
4000855c:	ee1ff06f          	j	4000843c <shell_process+0x390>
	return sh->ctx->cfg.flags.insert_mode == 1;
40008560:	26c52783          	lw	a5,620(a0)
40008564:	0017f793          	andi	a5,a5,1
		if (z_flag_insert_mode_get(sh)) {
40008568:	02078463          	beqz	a5,40008590 <shell_process+0x4e4>
			z_flag_insert_mode_set(sh, false);
4000856c:	00000593          	li	a1,0
40008570:	d84ff0ef          	jal	ra,40007af4 <z_flag_insert_mode_set.isra.0>
			z_shell_op_char_insert(sh, ' ');
40008574:	02000593          	li	a1,32
40008578:	00040513          	mv	a0,s0
4000857c:	2dc020ef          	jal	ra,4000a858 <z_shell_op_char_insert>
			z_flag_insert_mode_set(sh, true);
40008580:	00842503          	lw	a0,8(s0)
40008584:	00100593          	li	a1,1
				z_flag_insert_mode_set(sh, !status);
40008588:	d6cff0ef          	jal	ra,40007af4 <z_flag_insert_mode_set.isra.0>
				break;
4000858c:	b85ff06f          	j	40008110 <shell_process+0x64>
			z_shell_op_char_insert(sh, ' ');
40008590:	02000593          	li	a1,32
					z_shell_op_char_insert(sh, data);
40008594:	00040513          	mv	a0,s0
40008598:	2c0020ef          	jal	ra,4000a858 <z_shell_op_char_insert>
4000859c:	b75ff06f          	j	40008110 <shell_process+0x64>
	} else if (cnt > 1) {
400085a0:	b727f8e3          	bgeu	a5,s2,40008110 <shell_process+0x64>
		tab_options_print(sh, cmd, argv[arg_idx], first, cnt,
400085a4:	02812783          	lw	a5,40(sp)
400085a8:	02010713          	addi	a4,sp,32
		sh->ctx->vt100_ctx.printed_cmd = 0;
400085ac:	00090b93          	mv	s7,s2
		tab_options_print(sh, cmd, argv[arg_idx], first, cnt,
400085b0:	00279793          	slli	a5,a5,0x2
400085b4:	0a078793          	addi	a5,a5,160
400085b8:	00e787b3          	add	a5,a5,a4
400085bc:	fac7a783          	lw	a5,-84(a5)
		sh->ctx->vt100_ctx.printed_cmd = 0;
400085c0:	000a0c13          	mv	s8,s4
	longest_option += z_shell_strlen(tab);
400085c4:	40034cb7          	lui	s9,0x40034
	size_t str_len = z_shell_strlen(str);
400085c8:	00078513          	mv	a0,a5
		tab_options_print(sh, cmd, argv[arg_idx], first, cnt,
400085cc:	00f12423          	sw	a5,8(sp)
	size_t str_len = z_shell_strlen(str);
400085d0:	a7cff0ef          	jal	ra,4000784c <z_shell_strlen>
		sh->ctx->vt100_ctx.printed_cmd = 0;
400085d4:	00842783          	lw	a5,8(s0)
	size_t str_len = z_shell_strlen(str);
400085d8:	00a12623          	sw	a0,12(sp)
		z_shell_fprintf(sh, SHELL_OPTION, "%s", option);
400085dc:	40033d37          	lui	s10,0x40033
		sh->ctx->vt100_ctx.printed_cmd = 0;
400085e0:	02079e23          	sh	zero,60(a5)
		z_shell_fprintf(sh, SHELL_OPTION, "\n%s%s", tab, option);
400085e4:	40034db7          	lui	s11,0x40034
		match = z_shell_cmd_get(cmd, idx, &sh->ctx->active_cmd);
400085e8:	00842603          	lw	a2,8(s0)
400085ec:	000c0593          	mv	a1,s8
400085f0:	00048513          	mv	a0,s1
400085f4:	00c60613          	addi	a2,a2,12
400085f8:	224010ef          	jal	ra,4000981c <z_shell_cmd_get>
		if (str && match->syntax &&
400085fc:	00812783          	lw	a5,8(sp)
		match = z_shell_cmd_get(cmd, idx, &sh->ctx->active_cmd);
40008600:	00050a93          	mv	s5,a0
		idx++;
40008604:	001c0c13          	addi	s8,s8,1
		if (str && match->syntax &&
40008608:	0e079c63          	bnez	a5,40008700 <shell_process+0x654>
		tab_item_print(sh, match->syntax, longest);
4000860c:	000aa703          	lw	a4,0(s5)
	if (option == NULL) {
40008610:	10071663          	bnez	a4,4000871c <shell_process+0x670>
		sh->ctx->vt100_ctx.printed_cmd = 0;
40008614:	00842783          	lw	a5,8(s0)
40008618:	02079e23          	sh	zero,60(a5)
		cnt--;
4000861c:	fffb8b93          	addi	s7,s7,-1
	while (cnt) {
40008620:	fc0b94e3          	bnez	s7,400085e8 <shell_process+0x53c>
	z_cursor_next_line_move(sh);
40008624:	01442503          	lw	a0,20(s0)
	size_t idx = first + 1;
40008628:	001a0b93          	addi	s7,s4,1
	while (cnt > 1) {
4000862c:	00100d13          	li	s10,1
	z_cursor_next_line_move(sh);
40008630:	b6cff0ef          	jal	ra,4000799c <z_cursor_next_line_move.isra.0>
	z_shell_print_prompt_and_cmd(sh);
40008634:	00040513          	mv	a0,s0
40008638:	3ac020ef          	jal	ra,4000a9e4 <z_shell_print_prompt_and_cmd>
		partial_autocomplete(sh, cmd, argv[arg_idx], first, cnt);
4000863c:	02812783          	lw	a5,40(sp)
40008640:	02010713          	addi	a4,sp,32
40008644:	00279793          	slli	a5,a5,0x2
40008648:	0a078793          	addi	a5,a5,160
4000864c:	00e787b3          	add	a5,a5,a4
	uint16_t arg_len = z_shell_strlen(arg);
40008650:	fac7a503          	lw	a0,-84(a5)
40008654:	9f8ff0ef          	jal	ra,4000784c <z_shell_strlen>
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
40008658:	000a0593          	mv	a1,s4
4000865c:	04410613          	addi	a2,sp,68
	uint16_t arg_len = z_shell_strlen(arg);
40008660:	00050a93          	mv	s5,a0
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
40008664:	00048513          	mv	a0,s1
40008668:	1b4010ef          	jal	ra,4000981c <z_shell_cmd_get>
4000866c:	00050993          	mv	s3,a0
	strncpy(sh->ctx->temp_buff, match->syntax,
40008670:	00842503          	lw	a0,8(s0)
40008674:	0009a583          	lw	a1,0(s3)
40008678:	0ff00613          	li	a2,255
4000867c:	14e50513          	addi	a0,a0,334
40008680:	4d0040ef          	jal	ra,4000cb50 <strncpy>
	*str = match->syntax;
40008684:	0009aa03          	lw	s4,0(s3)
	uint16_t common = UINT16_MAX;
40008688:	000109b7          	lui	s3,0x10
4000868c:	fff98993          	addi	s3,s3,-1 # ffff <__kernel_ram_size+0x44f7>
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
40008690:	00098c93          	mv	s9,s3
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
40008694:	05810613          	addi	a2,sp,88
40008698:	000b8593          	mv	a1,s7
4000869c:	00048513          	mv	a0,s1
400086a0:	001b8c13          	addi	s8,s7,1
400086a4:	178010ef          	jal	ra,4000981c <z_shell_cmd_get>
		if (match2 == NULL) {
400086a8:	12050a63          	beqz	a0,400087dc <shell_process+0x730>
		curr_common = str_common(sh->ctx->temp_buff, match2->syntax,
400086ac:	00842683          	lw	a3,8(s0)
400086b0:	00052603          	lw	a2,0(a0)
	size_t common = 0;
400086b4:	00000793          	li	a5,0
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
400086b8:	00f68733          	add	a4,a3,a5
400086bc:	14e74583          	lbu	a1,334(a4)
400086c0:	00f60733          	add	a4,a2,a5
400086c4:	00074703          	lbu	a4,0(a4)
400086c8:	00b71863          	bne	a4,a1,400086d8 <shell_process+0x62c>
400086cc:	00070663          	beqz	a4,400086d8 <shell_process+0x62c>
		common++;
400086d0:	00178793          	addi	a5,a5,1
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
400086d4:	ff9792e3          	bne	a5,s9,400086b8 <shell_process+0x60c>
		if ((arg_len == 0U) || (curr_common >= arg_len)) {
400086d8:	000a8463          	beqz	s5,400086e0 <shell_process+0x634>
400086dc:	0157ce63          	blt	a5,s5,400086f8 <shell_process+0x64c>
			--cnt;
400086e0:	fff90913          	addi	s2,s2,-1
			common = (curr_common < common) ? curr_common : common;
400086e4:	0137d463          	bge	a5,s3,400086ec <shell_process+0x640>
400086e8:	00078993          	mv	s3,a5
400086ec:	01099993          	slli	s3,s3,0x10
400086f0:	0109d993          	srli	s3,s3,0x10
	while (cnt > 1) {
400086f4:	0fa90463          	beq	s2,s10,400087dc <shell_process+0x730>
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
400086f8:	000c0b93          	mv	s7,s8
400086fc:	f99ff06f          	j	40008694 <shell_process+0x5e8>
		if (str && match->syntax &&
40008700:	00052503          	lw	a0,0(a0)
40008704:	f00504e3          	beqz	a0,4000860c <shell_process+0x560>
	return (strncmp(candidate, str, len) == 0) ? true : false;
40008708:	00c12603          	lw	a2,12(sp)
4000870c:	00812583          	lw	a1,8(sp)
40008710:	52c040ef          	jal	ra,4000cc3c <strncmp>
		if (str && match->syntax &&
40008714:	ee050ce3          	beqz	a0,4000860c <shell_process+0x560>
40008718:	ed1ff06f          	j	400085e8 <shell_process+0x53c>
	longest_option += z_shell_strlen(tab);
4000871c:	b54c8513          	addi	a0,s9,-1196 # 40033b54 <shell_transport_uart_shell_uart+0x128>
40008720:	00e12823          	sw	a4,16(sp)
40008724:	928ff0ef          	jal	ra,4000784c <z_shell_strlen>
	columns = (sh->ctx->vt100_ctx.cons.terminal_wid
40008728:	00842783          	lw	a5,8(s0)
	longest_option += z_shell_strlen(tab);
4000872c:	013506b3          	add	a3,a0,s3
40008730:	01069693          	slli	a3,a3,0x10
	columns = (sh->ctx->vt100_ctx.cons.terminal_wid
40008734:	02e7d783          	lhu	a5,46(a5)
	longest_option += z_shell_strlen(tab);
40008738:	0106d693          	srli	a3,a3,0x10
			- z_shell_strlen(tab)) / longest_option;
4000873c:	b54c8513          	addi	a0,s9,-1196
	longest_option += z_shell_strlen(tab);
40008740:	00d12e23          	sw	a3,28(sp)
	columns = (sh->ctx->vt100_ctx.cons.terminal_wid
40008744:	00f12c23          	sw	a5,24(sp)
			- z_shell_strlen(tab)) / longest_option;
40008748:	904ff0ef          	jal	ra,4000784c <z_shell_strlen>
	diff = longest_option - z_shell_strlen(option);
4000874c:	01012703          	lw	a4,16(sp)
			- z_shell_strlen(tab)) / longest_option;
40008750:	00a12a23          	sw	a0,20(sp)
	diff = longest_option - z_shell_strlen(option);
40008754:	00070513          	mv	a0,a4
40008758:	8f4ff0ef          	jal	ra,4000784c <z_shell_strlen>
			- z_shell_strlen(tab)) / longest_option;
4000875c:	01412583          	lw	a1,20(sp)
40008760:	01812783          	lw	a5,24(sp)
	diff = longest_option - z_shell_strlen(option);
40008764:	01c12683          	lw	a3,28(sp)
	if (sh->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
40008768:	01012703          	lw	a4,16(sp)
			- z_shell_strlen(tab)) / longest_option;
4000876c:	40b787b3          	sub	a5,a5,a1
40008770:	02d7c7b3          	div	a5,a5,a3
	diff = longest_option - z_shell_strlen(option);
40008774:	40a68ab3          	sub	s5,a3,a0
	if (sh->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
40008778:	00842503          	lw	a0,8(s0)
	diff = longest_option - z_shell_strlen(option);
4000877c:	010a9a93          	slli	s5,s5,0x10
40008780:	010ada93          	srli	s5,s5,0x10
	if (sh->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
40008784:	03c55603          	lhu	a2,60(a0)
40008788:	00160813          	addi	a6,a2,1
4000878c:	03051e23          	sh	a6,60(a0)
40008790:	01079793          	slli	a5,a5,0x10
40008794:	0107d793          	srli	a5,a5,0x10
40008798:	02f67633          	remu	a2,a2,a5
4000879c:	02061463          	bnez	a2,400087c4 <shell_process+0x718>
		z_shell_fprintf(sh, SHELL_OPTION, "\n%s%s", tab, option);
400087a0:	b54c8693          	addi	a3,s9,-1196
400087a4:	b58d8613          	addi	a2,s11,-1192 # 40033b58 <shell_transport_uart_shell_uart+0x12c>
400087a8:	00600593          	li	a1,6
400087ac:	00040513          	mv	a0,s0
400087b0:	511010ef          	jal	ra,4000a4c0 <z_shell_fprintf>
	z_shell_op_cursor_horiz_move(sh, diff);
400087b4:	000a8593          	mv	a1,s5
400087b8:	00040513          	mv	a0,s0
400087bc:	620010ef          	jal	ra,40009ddc <z_shell_op_cursor_horiz_move>
400087c0:	e5dff06f          	j	4000861c <shell_process+0x570>
		z_shell_fprintf(sh, SHELL_OPTION, "%s", option);
400087c4:	00070693          	mv	a3,a4
400087c8:	af8d0613          	addi	a2,s10,-1288 # 40032af8 <mpsc_config+0x9c>
400087cc:	00600593          	li	a1,6
400087d0:	00040513          	mv	a0,s0
400087d4:	4ed010ef          	jal	ra,4000a4c0 <z_shell_fprintf>
400087d8:	fddff06f          	j	400087b4 <shell_process+0x708>
	if (common) {
400087dc:	92098ae3          	beqz	s3,40008110 <shell_process+0x64>
		z_shell_op_completion_insert(sh, &completion[arg_len],
400087e0:	41598633          	sub	a2,s3,s5
400087e4:	01061613          	slli	a2,a2,0x10
400087e8:	01065613          	srli	a2,a2,0x10
400087ec:	015a05b3          	add	a1,s4,s5
400087f0:	00040513          	mv	a0,s0
400087f4:	118020ef          	jal	ra,4000a90c <z_shell_op_completion_insert>
400087f8:	919ff06f          	j	40008110 <shell_process+0x64>
	return sh->ctx->cfg.flags.echo == 1;
400087fc:	26c52783          	lw	a5,620(a0)
40008800:	0017d793          	srli	a5,a5,0x1
40008804:	0017f793          	andi	a5,a5,1
				if (z_flag_echo_get(sh)) {
40008808:	900784e3          	beqz	a5,40008110 <shell_process+0x64>
					z_flag_history_exit_set(sh, true);
4000880c:	00100593          	li	a1,1
40008810:	9b8ff0ef          	jal	ra,400079c8 <z_flag_history_exit_set.isra.0>
						z_shell_op_char_backspace(sh);
40008814:	00040513          	mv	a0,s0
40008818:	188020ef          	jal	ra,4000a9a0 <z_shell_op_char_backspace>
4000881c:	8f5ff06f          	j	40008110 <shell_process+0x64>
40008820:	26c52783          	lw	a5,620(a0)
40008824:	0017d793          	srli	a5,a5,0x1
40008828:	0017f793          	andi	a5,a5,1
				if (z_flag_echo_get(sh)) {
4000882c:	8e0782e3          	beqz	a5,40008110 <shell_process+0x64>
					z_flag_history_exit_set(sh, true);
40008830:	00100593          	li	a1,1
40008834:	994ff0ef          	jal	ra,400079c8 <z_flag_history_exit_set.isra.0>
	return sh->ctx->cfg.flags.mode_delete == 1;
40008838:	00842783          	lw	a5,8(s0)
4000883c:	26c7a783          	lw	a5,620(a5)
40008840:	0037d793          	srli	a5,a5,0x3
40008844:	0017f793          	andi	a5,a5,1
					if (z_flag_mode_delete_get(sh)) {
40008848:	fc0796e3          	bnez	a5,40008814 <shell_process+0x768>
		z_shell_op_char_delete(sh);
4000884c:	00040513          	mv	a0,s0
40008850:	0c0020ef          	jal	ra,4000a910 <z_shell_op_char_delete>
		break;
40008854:	8bdff06f          	j	40008110 <shell_process+0x64>
		z_shell_op_left_arrow(sh);
40008858:	00040513          	mv	a0,s0
4000885c:	101010ef          	jal	ra,4000a15c <z_shell_op_left_arrow>
		break;
40008860:	8b1ff06f          	j	40008110 <shell_process+0x64>
		z_shell_op_cursor_end_move(sh);
40008864:	00040513          	mv	a0,s0
40008868:	0d9010ef          	jal	ra,4000a140 <z_shell_op_cursor_end_move>
		if (!z_shell_cursor_in_empty_line(sh)) {
4000886c:	00040513          	mv	a0,s0
40008870:	5b0010ef          	jal	ra,40009e20 <z_shell_cursor_in_empty_line>
40008874:	00051663          	bnez	a0,40008880 <shell_process+0x7d4>
			z_cursor_next_line_move(sh);
40008878:	01442503          	lw	a0,20(s0)
4000887c:	920ff0ef          	jal	ra,4000799c <z_cursor_next_line_move.isra.0>
		z_flag_history_exit_set(sh, true);
40008880:	00842503          	lw	a0,8(s0)
40008884:	00100593          	li	a1,1
40008888:	940ff0ef          	jal	ra,400079c8 <z_flag_history_exit_set.isra.0>
4000888c:	a89ff06f          	j	40008314 <shell_process+0x268>
		z_shell_op_right_arrow(sh);
40008890:	00040513          	mv	a0,s0
40008894:	0e1010ef          	jal	ra,4000a174 <z_shell_op_right_arrow>
		break;
40008898:	879ff06f          	j	40008110 <shell_process+0x64>
		z_shell_op_delete_from_cursor(sh);
4000889c:	00040513          	mv	a0,s0
400088a0:	0f1010ef          	jal	ra,4000a190 <z_shell_op_delete_from_cursor>
		break;
400088a4:	86dff06f          	j	40008110 <shell_process+0x64>
	return sh->ctx->cfg.flags.use_vt100 == 1;
400088a8:	26c72783          	lw	a5,620(a4)
400088ac:	0057d793          	srli	a5,a5,0x5
400088b0:	0017f793          	andi	a5,a5,1
		Z_SHELL_VT100_CMD(sh, SHELL_VT100_CURSORHOME);
400088b4:	00078a63          	beqz	a5,400088c8 <shell_process+0x81c>
400088b8:	01442503          	lw	a0,20(s0)
400088bc:	400325b7          	lui	a1,0x40032
400088c0:	6a858593          	addi	a1,a1,1704 # 400326a8 <eth_config+0xc>
400088c4:	fb5fe0ef          	jal	ra,40007878 <z_shell_raw_fprintf>
400088c8:	00842783          	lw	a5,8(s0)
400088cc:	26c7a783          	lw	a5,620(a5)
400088d0:	0057d793          	srli	a5,a5,0x5
400088d4:	0017f793          	andi	a5,a5,1
		Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEARSCREEN);
400088d8:	00078a63          	beqz	a5,400088ec <shell_process+0x840>
400088dc:	01442503          	lw	a0,20(s0)
400088e0:	400325b7          	lui	a1,0x40032
400088e4:	6b058593          	addi	a1,a1,1712 # 400326b0 <eth_config+0x14>
400088e8:	f91fe0ef          	jal	ra,40007878 <z_shell_raw_fprintf>
		z_shell_print_prompt_and_cmd(sh);
400088ec:	00040513          	mv	a0,s0
400088f0:	0f4020ef          	jal	ra,4000a9e4 <z_shell_print_prompt_and_cmd>
		break;
400088f4:	81dff06f          	j	40008110 <shell_process+0x64>
		history_handle(sh, false);
400088f8:	00000593          	li	a1,0
		history_handle(sh, true);
400088fc:	00040513          	mv	a0,s0
40008900:	8e0ff0ef          	jal	ra,400079e0 <history_handle>
		break;
40008904:	80dff06f          	j	40008110 <shell_process+0x64>
		history_handle(sh, true);
40008908:	00100593          	li	a1,1
4000890c:	ff1ff06f          	j	400088fc <shell_process+0x850>
		z_shell_op_cursor_home_move(sh);
40008910:	00040513          	mv	a0,s0
40008914:	015010ef          	jal	ra,4000a128 <z_shell_op_cursor_home_move>
		cmd_buffer_clear(sh);
40008918:	00040513          	mv	a0,s0
4000891c:	ea9fe0ef          	jal	ra,400077c4 <cmd_buffer_clear>
		z_flag_history_exit_set(sh, true);
40008920:	00842503          	lw	a0,8(s0)
40008924:	00100593          	li	a1,1
40008928:	8a0ff0ef          	jal	ra,400079c8 <z_flag_history_exit_set.isra.0>
4000892c:	00842783          	lw	a5,8(s0)
40008930:	26c7a783          	lw	a5,620(a5)
40008934:	0057d793          	srli	a5,a5,0x5
40008938:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
4000893c:	fc078a63          	beqz	a5,40008110 <shell_process+0x64>
40008940:	01442503          	lw	a0,20(s0)
40008944:	400325b7          	lui	a1,0x40032
40008948:	6a058593          	addi	a1,a1,1696 # 400326a0 <eth_config+0x4>
4000894c:	f2dfe0ef          	jal	ra,40007878 <z_shell_raw_fprintf>
40008950:	fc0ff06f          	j	40008110 <shell_process+0x64>
		z_shell_op_word_remove(sh);
40008954:	00040513          	mv	a0,s0
40008958:	39d010ef          	jal	ra,4000a4f4 <z_shell_op_word_remove>
		z_flag_history_exit_set(sh, true);
4000895c:	00842503          	lw	a0,8(s0)
40008960:	00100593          	li	a1,1
40008964:	864ff0ef          	jal	ra,400079c8 <z_flag_history_exit_set.isra.0>
		break;
40008968:	fa8ff06f          	j	40008110 <shell_process+0x64>
			if (data == '[') {
4000896c:	05b00693          	li	a3,91
40008970:	00d79663          	bne	a5,a3,4000897c <shell_process+0x8d0>
	sh->ctx->receive_state = state;
40008974:	01672423          	sw	s6,8(a4)
}
40008978:	f98ff06f          	j	40008110 <shell_process+0x64>
	return sh->ctx->cfg.flags.echo == 1;
4000897c:	26c72703          	lw	a4,620(a4)
40008980:	00175713          	srli	a4,a4,0x1
40008984:	00177713          	andi	a4,a4,1
			} else if (z_flag_echo_get(sh)) {
40008988:	02070263          	beqz	a4,400089ac <shell_process+0x900>
	if (data == SHELL_VT100_ASCII_ALT_B) {
4000898c:	06200713          	li	a4,98
		z_shell_op_cursor_word_move(sh, -1);
40008990:	fff00593          	li	a1,-1
	if (data == SHELL_VT100_ASCII_ALT_B) {
40008994:	00e78863          	beq	a5,a4,400089a4 <shell_process+0x8f8>
	} else if (data == SHELL_VT100_ASCII_ALT_F) {
40008998:	06600713          	li	a4,102
4000899c:	00e79863          	bne	a5,a4,400089ac <shell_process+0x900>
		z_shell_op_cursor_word_move(sh, 1);
400089a0:	00100593          	li	a1,1
400089a4:	00040513          	mv	a0,s0
400089a8:	66c010ef          	jal	ra,4000a014 <z_shell_op_cursor_word_move>
	sh->ctx->receive_state = state;
400089ac:	00842783          	lw	a5,8(s0)
400089b0:	0007a423          	sw	zero,8(a5)
}
400089b4:	f5cff06f          	j	40008110 <shell_process+0x64>
	sh->ctx->receive_state = state;
400089b8:	00072423          	sw	zero,8(a4)
400089bc:	00842703          	lw	a4,8(s0)
400089c0:	26c72683          	lw	a3,620(a4)
400089c4:	0016d693          	srli	a3,a3,0x1
400089c8:	0016f693          	andi	a3,a3,1
			if (!z_flag_echo_get(sh)) {
400089cc:	f4068263          	beqz	a3,40008110 <shell_process+0x64>
			switch (data) {
400089d0:	fcf78793          	addi	a5,a5,-49
400089d4:	0ff7f793          	zext.b	a5,a5
400089d8:	01b00693          	li	a3,27
400089dc:	f2f6ea63          	bltu	a3,a5,40008110 <shell_process+0x64>
400089e0:	400346b7          	lui	a3,0x40034
400089e4:	00279793          	slli	a5,a5,0x2
400089e8:	bbc68693          	addi	a3,a3,-1092 # 40033bbc <shell_transport_uart_shell_uart+0x190>
400089ec:	00d787b3          	add	a5,a5,a3
400089f0:	0007a783          	lw	a5,0(a5)
400089f4:	00078067          	jr	a5
	sh->ctx->receive_state = state;
400089f8:	00300793          	li	a5,3
400089fc:	00f72423          	sw	a5,8(a4)
		z_shell_op_cursor_end_move(sh);
40008a00:	00040513          	mv	a0,s0
40008a04:	73c010ef          	jal	ra,4000a140 <z_shell_op_cursor_end_move>
		break;
40008a08:	f08ff06f          	j	40008110 <shell_process+0x64>
	sh->ctx->receive_state = state;
40008a0c:	00300793          	li	a5,3
40008a10:	00f72423          	sw	a5,8(a4)
		z_shell_op_cursor_home_move(sh);
40008a14:	00040513          	mv	a0,s0
40008a18:	710010ef          	jal	ra,4000a128 <z_shell_op_cursor_home_move>
		break;
40008a1c:	ef4ff06f          	j	40008110 <shell_process+0x64>
	sh->ctx->receive_state = state;
40008a20:	00300793          	li	a5,3
40008a24:	00f72423          	sw	a5,8(a4)
	return sh->ctx->cfg.flags.insert_mode == 1;
40008a28:	00842503          	lw	a0,8(s0)
40008a2c:	26c52583          	lw	a1,620(a0)
40008a30:	0015f593          	andi	a1,a1,1
				z_flag_insert_mode_set(sh, !status);
40008a34:	0015c593          	xori	a1,a1,1
40008a38:	b51ff06f          	j	40008588 <shell_process+0x4dc>
	sh->ctx->receive_state = state;
40008a3c:	00300793          	li	a5,3
40008a40:	00f72423          	sw	a5,8(a4)
	return sh->ctx->cfg.flags.echo == 1;
40008a44:	00842783          	lw	a5,8(s0)
40008a48:	26c7a783          	lw	a5,620(a5)
40008a4c:	0017d793          	srli	a5,a5,0x1
40008a50:	0017f793          	andi	a5,a5,1
				if (z_flag_echo_get(sh)) {
40008a54:	ea078e63          	beqz	a5,40008110 <shell_process+0x64>
40008a58:	df5ff06f          	j	4000884c <shell_process+0x7a0>

40008a5c <shell_init>:
{
40008a5c:	fc010113          	addi	sp,sp,-64
40008a60:	02812c23          	sw	s0,56(sp)
40008a64:	02912a23          	sw	s1,52(sp)
40008a68:	02112e23          	sw	ra,60(sp)
40008a6c:	03212823          	sw	s2,48(sp)
40008a70:	03312623          	sw	s3,44(sp)
40008a74:	03412423          	sw	s4,40(sp)
40008a78:	03512223          	sw	s5,36(sp)
40008a7c:	03612023          	sw	s6,32(sp)
40008a80:	01712e23          	sw	s7,28(sp)
40008a84:	00050413          	mv	s0,a0
	if (sh->ctx->tid) {
40008a88:	00852503          	lw	a0,8(a0)
		return -EALREADY;
40008a8c:	f8800493          	li	s1,-120
	if (sh->ctx->tid) {
40008a90:	31852783          	lw	a5,792(a0)
40008a94:	14079863          	bnez	a5,40008be4 <shell_init+0x188>
40008a98:	00058a93          	mv	s5,a1
40008a9c:	00060493          	mv	s1,a2
	memset(sh->ctx, 0, sizeof(*sh->ctx));
40008aa0:	00000593          	li	a1,0
40008aa4:	32000613          	li	a2,800
40008aa8:	00068993          	mv	s3,a3
40008aac:	00070a13          	mv	s4,a4
40008ab0:	26c040ef          	jal	ra,4000cd1c <memset>
	sh->ctx->prompt = sh->default_prompt;
40008ab4:	00842783          	lw	a5,8(s0)
40008ab8:	00042703          	lw	a4,0(s0)
40008abc:	00e7a023          	sw	a4,0(a5)
	z_shell_history_init(sh->history);
40008ac0:	00c42503          	lw	a0,12(s0)
40008ac4:	34c030ef          	jal	ra,4000be10 <z_shell_history_init>
	k_mutex_init(&sh->ctx->wr_mtx);
40008ac8:	00842503          	lw	a0,8(s0)
40008acc:	30450513          	addi	a0,a0,772
	return z_impl_k_mutex_init(mutex);
40008ad0:	2b400b13          	li	s6,692
40008ad4:	151260ef          	jal	ra,4002f424 <z_impl_k_mutex_init>
40008ad8:	27400913          	li	s2,628
	for (int i = 0; i < SHELL_SIGNALS; i++) {
40008adc:	2b400b93          	li	s7,692
		k_poll_signal_init(&sh->ctx->signals[i]);
40008ae0:	00842503          	lw	a0,8(s0)
40008ae4:	01250533          	add	a0,a0,s2
	z_impl_k_poll_signal_init(sig);
40008ae8:	5b0290ef          	jal	ra,40032098 <z_impl_k_poll_signal_init>
		k_poll_event_init(&sh->ctx->events[i],
40008aec:	00842503          	lw	a0,8(s0)
40008af0:	00000613          	li	a2,0
40008af4:	00100593          	li	a1,1
40008af8:	012506b3          	add	a3,a0,s2
40008afc:	01650533          	add	a0,a0,s6
	for (int i = 0; i < SHELL_SIGNALS; i++) {
40008b00:	01090913          	addi	s2,s2,16
		k_poll_event_init(&sh->ctx->events[i],
40008b04:	430290ef          	jal	ra,40031f34 <k_poll_event_init>
	for (int i = 0; i < SHELL_SIGNALS; i++) {
40008b08:	014b0b13          	addi	s6,s6,20
40008b0c:	fd791ae3          	bne	s2,s7,40008ae0 <shell_init+0x84>
		sh->stats->log_lost_cnt = 0;
40008b10:	01842783          	lw	a5,24(s0)
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, tx_rdy, val, ret);
40008b14:	00200593          	li	a1,2
	sh->ctx->cfg.flags = cfg_flags;
40008b18:	ffb4f493          	andi	s1,s1,-5
		sh->stats->log_lost_cnt = 0;
40008b1c:	0007a023          	sw	zero,0(a5)
40008b20:	00842503          	lw	a0,8(s0)
40008b24:	27050513          	addi	a0,a0,624
40008b28:	cb9fe0ef          	jal	ra,400077e0 <atomic_or>
	sh->ctx->vt100_ctx.cons.terminal_wid =
40008b2c:	00842783          	lw	a5,8(s0)
40008b30:	05000713          	li	a4,80
40008b34:	02e79723          	sh	a4,46(a5)
	sh->ctx->vt100_ctx.cons.terminal_hei =
40008b38:	00842783          	lw	a5,8(s0)
40008b3c:	01800713          	li	a4,24
40008b40:	02e79623          	sh	a4,44(a5)
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
40008b44:	00842783          	lw	a5,8(s0)
40008b48:	0007a503          	lw	a0,0(a5)
40008b4c:	d01fe0ef          	jal	ra,4000784c <z_shell_strlen>
40008b50:	00842783          	lw	a5,8(s0)
	int ret = sh->iface->api->init(sh->iface, transport_config,
40008b54:	40008637          	lui	a2,0x40008
40008b58:	00040693          	mv	a3,s0
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
40008b5c:	02a78823          	sb	a0,48(a5)
	sh->ctx->cfg.flags = cfg_flags;
40008b60:	00842783          	lw	a5,8(s0)
	int ret = sh->iface->api->init(sh->iface, transport_config,
40008b64:	8f460613          	addi	a2,a2,-1804 # 400078f4 <transport_evt_handler>
40008b68:	000a8593          	mv	a1,s5
	sh->ctx->cfg.flags = cfg_flags;
40008b6c:	2697a623          	sw	s1,620(a5)
	int ret = sh->iface->api->init(sh->iface, transport_config,
40008b70:	00442503          	lw	a0,4(s0)
40008b74:	00052783          	lw	a5,0(a0)
40008b78:	0007a783          	lw	a5,0(a5)
40008b7c:	000780e7          	jalr	a5
40008b80:	00050493          	mv	s1,a0
	if (ret == 0) {
40008b84:	06051063          	bnez	a0,40008be4 <shell_init+0x188>
	sh->ctx->state = state;
40008b88:	00842783          	lw	a5,8(s0)
40008b8c:	00100713          	li	a4,1
40008b90:	00e7a223          	sw	a4,4(a5)
	k_tid_t tid = k_thread_create(sh->thread,
40008b94:	02842503          	lw	a0,40(s0)
				  sh->stack, CONFIG_SHELL_STACK_SIZE,
40008b98:	02c42583          	lw	a1,44(s0)
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
40008b9c:	00000793          	li	a5,0
40008ba0:	00000813          	li	a6,0
40008ba4:	400096b7          	lui	a3,0x40009
40008ba8:	00001637          	lui	a2,0x1
40008bac:	00f12423          	sw	a5,8(sp)
40008bb0:	01012623          	sw	a6,12(sp)
40008bb4:	00098793          	mv	a5,s3
40008bb8:	00012023          	sw	zero,0(sp)
40008bbc:	00e00893          	li	a7,14
40008bc0:	000a0813          	mv	a6,s4
40008bc4:	00040713          	mv	a4,s0
40008bc8:	c9c68693          	addi	a3,a3,-868 # 40008c9c <shell_thread>
40008bcc:	80060613          	addi	a2,a2,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
40008bd0:	3e0260ef          	jal	ra,4002efb0 <z_impl_k_thread_create>
	sh->ctx->tid = tid;
40008bd4:	00842783          	lw	a5,8(s0)
40008bd8:	30a7ac23          	sw	a0,792(a5)
	k_thread_name_set(tid, sh->thread_name);
40008bdc:	02442583          	lw	a1,36(s0)
	return z_impl_k_thread_name_set(thread, str);
40008be0:	104260ef          	jal	ra,4002ece4 <z_impl_k_thread_name_set>
}
40008be4:	03c12083          	lw	ra,60(sp)
40008be8:	03812403          	lw	s0,56(sp)
40008bec:	03012903          	lw	s2,48(sp)
40008bf0:	02c12983          	lw	s3,44(sp)
40008bf4:	02812a03          	lw	s4,40(sp)
40008bf8:	02412a83          	lw	s5,36(sp)
40008bfc:	02012b03          	lw	s6,32(sp)
40008c00:	01c12b83          	lw	s7,28(sp)
40008c04:	00048513          	mv	a0,s1
40008c08:	03412483          	lw	s1,52(sp)
40008c0c:	04010113          	addi	sp,sp,64
40008c10:	00008067          	ret

40008c14 <shell_start>:
{
40008c14:	ff010113          	addi	sp,sp,-16
40008c18:	00812423          	sw	s0,8(sp)
40008c1c:	00112623          	sw	ra,12(sp)
40008c20:	00050413          	mv	s0,a0
	return sh->ctx->state;
40008c24:	00852503          	lw	a0,8(a0)
	if (state_get(sh) != SHELL_STATE_INITIALIZED) {
40008c28:	00100793          	li	a5,1
40008c2c:	00452703          	lw	a4,4(a0)
40008c30:	06f71263          	bne	a4,a5,40008c94 <shell_start+0x80>
	k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
40008c34:	fff00593          	li	a1,-1
40008c38:	fff00613          	li	a2,-1
40008c3c:	30450513          	addi	a0,a0,772
40008c40:	cb1fe0ef          	jal	ra,400078f0 <k_mutex_lock.constprop.0.isra.0>
		z_shell_vt100_color_set(sh, SHELL_NORMAL);
40008c44:	00040513          	mv	a0,s0
40008c48:	00800593          	li	a1,8
40008c4c:	6d4010ef          	jal	ra,4000a320 <z_shell_vt100_color_set>
	if (z_shell_strlen(sh->default_prompt) > 0) {
40008c50:	00042503          	lw	a0,0(s0)
40008c54:	bf9fe0ef          	jal	ra,4000784c <z_shell_strlen>
40008c58:	00050a63          	beqz	a0,40008c6c <shell_start+0x58>
		z_shell_raw_fprintf(sh->fprintf_ctx, "\n\n");
40008c5c:	01442503          	lw	a0,20(s0)
40008c60:	400335b7          	lui	a1,0x40033
40008c64:	22058593          	addi	a1,a1,544 # 40033220 <severity_lvls+0x128>
40008c68:	c11fe0ef          	jal	ra,40007878 <z_shell_raw_fprintf>
	state_set(sh, SHELL_STATE_ACTIVE);
40008c6c:	00040513          	mv	a0,s0
40008c70:	bb4ff0ef          	jal	ra,40008024 <state_set.constprop.0>
	k_mutex_unlock(&sh->ctx->wr_mtx);
40008c74:	00842503          	lw	a0,8(s0)
40008c78:	30450513          	addi	a0,a0,772
40008c7c:	eadfe0ef          	jal	ra,40007b28 <k_mutex_unlock.isra.0>
	return 0;
40008c80:	00000513          	li	a0,0
}
40008c84:	00c12083          	lw	ra,12(sp)
40008c88:	00812403          	lw	s0,8(sp)
40008c8c:	01010113          	addi	sp,sp,16
40008c90:	00008067          	ret
		return -ENOTSUP;
40008c94:	f7a00513          	li	a0,-134
40008c98:	fedff06f          	j	40008c84 <shell_start+0x70>

40008c9c <shell_thread>:
{
40008c9c:	fd010113          	addi	sp,sp,-48
40008ca0:	02812423          	sw	s0,40(sp)
40008ca4:	02912223          	sw	s1,36(sp)
40008ca8:	02112623          	sw	ra,44(sp)
40008cac:	03212023          	sw	s2,32(sp)
40008cb0:	01312e23          	sw	s3,28(sp)
40008cb4:	00050413          	mv	s0,a0
	err = sh->iface->api->enable(sh->iface, false);
40008cb8:	00452503          	lw	a0,4(a0)
{
40008cbc:	00058493          	mv	s1,a1
	err = sh->iface->api->enable(sh->iface, false);
40008cc0:	00000593          	li	a1,0
40008cc4:	00052783          	lw	a5,0(a0)
{
40008cc8:	00c12623          	sw	a2,12(sp)
	err = sh->iface->api->enable(sh->iface, false);
40008ccc:	0087a783          	lw	a5,8(a5)
40008cd0:	000780e7          	jalr	a5
	if (err != 0) {
40008cd4:	10051463          	bnez	a0,40008ddc <shell_thread+0x140>
	if (IS_ENABLED(CONFIG_SHELL_LOG_BACKEND) && log_backend
40008cd8:	00048a63          	beqz	s1,40008cec <shell_thread+0x50>
		z_shell_log_backend_enable(sh->log_backend, (void *)sh,
40008cdc:	00c12603          	lw	a2,12(sp)
40008ce0:	01c42503          	lw	a0,28(s0)
40008ce4:	00040593          	mv	a1,s0
40008ce8:	0b4020ef          	jal	ra,4000ad9c <z_shell_log_backend_enable>
		err = shell_start(sh);
40008cec:	00040513          	mv	a0,s0
40008cf0:	f25ff0ef          	jal	ra,40008c14 <shell_start>
		if (err != 0) {
40008cf4:	0e051463          	bnez	a0,40008ddc <shell_thread+0x140>
		shell_signal_handle(sh, SHELL_SIGNAL_KILL, kill_handler);
40008cf8:	400084b7          	lui	s1,0x40008
		shell_signal_handle(sh, SHELL_SIGNAL_RXRDY, shell_process);
40008cfc:	40008937          	lui	s2,0x40008
			shell_signal_handle(sh, SHELL_SIGNAL_LOG_MSG,
40008d00:	400089b7          	lui	s3,0x40008
		err = k_poll(sh->ctx->events, SHELL_SIGNAL_TXDONE,
40008d04:	00842503          	lw	a0,8(s0)
40008d08:	2b450513          	addi	a0,a0,692
	return z_impl_k_poll(events, num_events, timeout);
40008d0c:	fff00693          	li	a3,-1
40008d10:	fff00613          	li	a2,-1
40008d14:	00300593          	li	a1,3
40008d18:	254290ef          	jal	ra,40031f6c <z_impl_k_poll>
40008d1c:	00050693          	mv	a3,a0
		if (err != 0) {
40008d20:	00842503          	lw	a0,8(s0)
40008d24:	04068a63          	beqz	a3,40008d78 <shell_thread+0xdc>
			k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
40008d28:	fff00593          	li	a1,-1
40008d2c:	fff00613          	li	a2,-1
40008d30:	30450513          	addi	a0,a0,772
40008d34:	00d12623          	sw	a3,12(sp)
40008d38:	bb9fe0ef          	jal	ra,400078f0 <k_mutex_lock.constprop.0.isra.0>
			z_shell_fprintf(sh, SHELL_ERROR,
40008d3c:	00c12683          	lw	a3,12(sp)
40008d40:	40034637          	lui	a2,0x40034
40008d44:	00040513          	mv	a0,s0
40008d48:	c2c60613          	addi	a2,a2,-980 # 40033c2c <shell_transport_uart_shell_uart+0x200>
40008d4c:	00100593          	li	a1,1
40008d50:	770010ef          	jal	ra,4000a4c0 <z_shell_fprintf>
			k_mutex_unlock(&sh->ctx->wr_mtx);
40008d54:	00842503          	lw	a0,8(s0)
}
40008d58:	02812403          	lw	s0,40(sp)
40008d5c:	02c12083          	lw	ra,44(sp)
40008d60:	02412483          	lw	s1,36(sp)
40008d64:	02012903          	lw	s2,32(sp)
40008d68:	01c12983          	lw	s3,28(sp)
			k_mutex_unlock(&sh->ctx->wr_mtx);
40008d6c:	30450513          	addi	a0,a0,772
}
40008d70:	03010113          	addi	sp,sp,48
			k_mutex_unlock(&sh->ctx->wr_mtx);
40008d74:	db5fe06f          	j	40007b28 <k_mutex_unlock.isra.0>
		k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
40008d78:	fff00593          	li	a1,-1
40008d7c:	fff00613          	li	a2,-1
40008d80:	30450513          	addi	a0,a0,772
40008d84:	b6dfe0ef          	jal	ra,400078f0 <k_mutex_lock.constprop.0.isra.0>
		shell_signal_handle(sh, SHELL_SIGNAL_KILL, kill_handler);
40008d88:	91048613          	addi	a2,s1,-1776 # 40007910 <kill_handler>
40008d8c:	00200593          	li	a1,2
40008d90:	00040513          	mv	a0,s0
40008d94:	a55fe0ef          	jal	ra,400077e8 <shell_signal_handle>
		shell_signal_handle(sh, SHELL_SIGNAL_RXRDY, shell_process);
40008d98:	0ac90613          	addi	a2,s2,172 # 400080ac <shell_process>
40008d9c:	00000593          	li	a1,0
40008da0:	00040513          	mv	a0,s0
40008da4:	a45fe0ef          	jal	ra,400077e8 <shell_signal_handle>
			shell_signal_handle(sh, SHELL_SIGNAL_LOG_MSG,
40008da8:	00040513          	mv	a0,s0
40008dac:	f9898613          	addi	a2,s3,-104 # 40007f98 <shell_log_process>
40008db0:	00100593          	li	a1,1
40008db4:	a35fe0ef          	jal	ra,400077e8 <shell_signal_handle>
		if (sh->iface->api->update) {
40008db8:	00442503          	lw	a0,4(s0)
40008dbc:	00052783          	lw	a5,0(a0)
40008dc0:	0147a783          	lw	a5,20(a5)
40008dc4:	00078463          	beqz	a5,40008dcc <shell_thread+0x130>
			sh->iface->api->update(sh->iface);
40008dc8:	000780e7          	jalr	a5
		k_mutex_unlock(&sh->ctx->wr_mtx);
40008dcc:	00842503          	lw	a0,8(s0)
40008dd0:	30450513          	addi	a0,a0,772
40008dd4:	d55fe0ef          	jal	ra,40007b28 <k_mutex_unlock.isra.0>
	while (true) {
40008dd8:	f2dff06f          	j	40008d04 <shell_thread+0x68>
}
40008ddc:	02c12083          	lw	ra,44(sp)
40008de0:	02812403          	lw	s0,40(sp)
40008de4:	02412483          	lw	s1,36(sp)
40008de8:	02012903          	lw	s2,32(sp)
40008dec:	01c12983          	lw	s3,28(sp)
40008df0:	03010113          	addi	sp,sp,48
40008df4:	00008067          	ret

40008df8 <shell_vfprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_vfprintf(const struct shell *sh, enum shell_vt100_color color,
		   const char *fmt, va_list args)
{
40008df8:	fe010113          	addi	sp,sp,-32
40008dfc:	00812c23          	sw	s0,24(sp)
40008e00:	00112e23          	sw	ra,28(sp)
40008e04:	00912a23          	sw	s1,20(sp)
40008e08:	01212823          	sw	s2,16(sp)
40008e0c:	01312623          	sw	s3,12(sp)
40008e10:	00050413          	mv	s0,a0
	return sh->ctx->state;
40008e14:	00852503          	lw	a0,8(a0)
			(k_current_get() != sh->ctx->tid));
	__ASSERT_NO_MSG(sh->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	/* Sending a message to a non-active shell leads to a dead lock. */
	if (state_get(sh) != SHELL_STATE_ACTIVE) {
40008e18:	00200793          	li	a5,2
40008e1c:	00452703          	lw	a4,4(a0)
40008e20:	02f70463          	beq	a4,a5,40008e48 <shell_vfprintf+0x50>
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
		z_shell_print_prompt_and_cmd(sh);
	}
	z_transport_buffer_flush(sh);
	k_mutex_unlock(&sh->ctx->wr_mtx);
}
40008e24:	01812403          	lw	s0,24(sp)
40008e28:	01c12083          	lw	ra,28(sp)
40008e2c:	01412483          	lw	s1,20(sp)
40008e30:	01012903          	lw	s2,16(sp)
40008e34:	00c12983          	lw	s3,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, print_noinit, val, ret);
40008e38:	000015b7          	lui	a1,0x1
40008e3c:	27050513          	addi	a0,a0,624
40008e40:	02010113          	addi	sp,sp,32
40008e44:	99dfe06f          	j	400077e0 <atomic_or>
40008e48:	00058493          	mv	s1,a1
40008e4c:	00060913          	mv	s2,a2
	k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
40008e50:	fff00593          	li	a1,-1
40008e54:	fff00613          	li	a2,-1
40008e58:	30450513          	addi	a0,a0,772
40008e5c:	00068993          	mv	s3,a3
40008e60:	a91fe0ef          	jal	ra,400078f0 <k_mutex_lock.constprop.0.isra.0>
	return sh->ctx->ctx.flags.cmd_ctx == 1;
40008e64:	00842703          	lw	a4,8(s0)
40008e68:	27072783          	lw	a5,624(a4)
40008e6c:	00b7d793          	srli	a5,a5,0xb
40008e70:	0017f793          	andi	a5,a5,1
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
40008e74:	00079a63          	bnez	a5,40008e88 <shell_vfprintf+0x90>
40008e78:	04472783          	lw	a5,68(a4)
40008e7c:	00079663          	bnez	a5,40008e88 <shell_vfprintf+0x90>
		z_shell_cmd_line_erase(sh);
40008e80:	00040513          	mv	a0,s0
40008e84:	32c010ef          	jal	ra,4000a1b0 <z_shell_cmd_line_erase>
	z_shell_vfprintf(sh, color, fmt, args);
40008e88:	00098693          	mv	a3,s3
40008e8c:	00090613          	mv	a2,s2
40008e90:	00048593          	mv	a1,s1
40008e94:	00040513          	mv	a0,s0
40008e98:	568010ef          	jal	ra,4000a400 <z_shell_vfprintf>
40008e9c:	00842703          	lw	a4,8(s0)
40008ea0:	27072783          	lw	a5,624(a4)
40008ea4:	00b7d793          	srli	a5,a5,0xb
40008ea8:	0017f793          	andi	a5,a5,1
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
40008eac:	00079a63          	bnez	a5,40008ec0 <shell_vfprintf+0xc8>
40008eb0:	04472783          	lw	a5,68(a4)
40008eb4:	00079663          	bnez	a5,40008ec0 <shell_vfprintf+0xc8>
		z_shell_print_prompt_and_cmd(sh);
40008eb8:	00040513          	mv	a0,s0
40008ebc:	329010ef          	jal	ra,4000a9e4 <z_shell_print_prompt_and_cmd>
	z_shell_fprintf_buffer_flush(sh->fprintf_ctx);
40008ec0:	01442503          	lw	a0,20(s0)
40008ec4:	37c000ef          	jal	ra,40009240 <z_shell_fprintf_buffer_flush>
	k_mutex_unlock(&sh->ctx->wr_mtx);
40008ec8:	00842503          	lw	a0,8(s0)
}
40008ecc:	01812403          	lw	s0,24(sp)
40008ed0:	01c12083          	lw	ra,28(sp)
40008ed4:	01412483          	lw	s1,20(sp)
40008ed8:	01012903          	lw	s2,16(sp)
40008edc:	00c12983          	lw	s3,12(sp)
	k_mutex_unlock(&sh->ctx->wr_mtx);
40008ee0:	30450513          	addi	a0,a0,772
}
40008ee4:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&sh->ctx->wr_mtx);
40008ee8:	c41fe06f          	j	40007b28 <k_mutex_unlock.isra.0>

40008eec <shell_fprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_fprintf(const struct shell *sh, enum shell_vt100_color color,
		   const char *fmt, ...)
{
40008eec:	fc010113          	addi	sp,sp,-64
40008ef0:	02d12623          	sw	a3,44(sp)
	va_list args;

	va_start(args, fmt);
40008ef4:	02c10693          	addi	a3,sp,44
{
40008ef8:	00112e23          	sw	ra,28(sp)
40008efc:	02e12823          	sw	a4,48(sp)
40008f00:	02f12a23          	sw	a5,52(sp)
40008f04:	03012c23          	sw	a6,56(sp)
40008f08:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
40008f0c:	00d12623          	sw	a3,12(sp)
	shell_vfprintf(sh, color, fmt, args);
40008f10:	ee9ff0ef          	jal	ra,40008df8 <shell_vfprintf>
	va_end(args);
}
40008f14:	01c12083          	lw	ra,28(sp)
40008f18:	04010113          	addi	sp,sp,64
40008f1c:	00008067          	ret

40008f20 <cmd_help>:
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

#if defined(CONFIG_SHELL_TAB)
	shell_print(sh, "Please press the <Tab> button to see all available "
40008f20:	40034637          	lui	a2,0x40034
{
40008f24:	ff010113          	addi	sp,sp,-16
	shell_print(sh, "Please press the <Tab> button to see all available "
40008f28:	c4460613          	addi	a2,a2,-956 # 40033c44 <shell_transport_uart_shell_uart+0x218>
40008f2c:	00800593          	li	a1,8
{
40008f30:	00112623          	sw	ra,12(sp)
40008f34:	00812423          	sw	s0,8(sp)
40008f38:	00050413          	mv	s0,a0
	shell_print(sh, "Please press the <Tab> button to see all available "
40008f3c:	fb1ff0ef          	jal	ra,40008eec <shell_fprintf>
			   "commands.");
#endif

#if defined(CONFIG_SHELL_TAB_AUTOCOMPLETION)
	shell_print(sh,
40008f40:	40034637          	lui	a2,0x40034
40008f44:	00040513          	mv	a0,s0
40008f48:	c8460613          	addi	a2,a2,-892 # 40033c84 <shell_transport_uart_shell_uart+0x258>
40008f4c:	00800593          	li	a1,8
40008f50:	f9dff0ef          	jal	ra,40008eec <shell_fprintf>
		"You can also use the <Tab> button to prompt or auto-complete"
		" all commands or its subcommands.");
#endif

#if defined(CONFIG_SHELL_HELP)
	shell_print(sh,
40008f54:	40034637          	lui	a2,0x40034
40008f58:	00040513          	mv	a0,s0
40008f5c:	ce460613          	addi	a2,a2,-796 # 40033ce4 <shell_transport_uart_shell_uart+0x2b8>
40008f60:	00800593          	li	a1,8
40008f64:	f89ff0ef          	jal	ra,40008eec <shell_fprintf>
		"You can try to call commands with <-h> or <--help> parameter"
		" for more information.");
#endif

#if defined(CONFIG_SHELL_METAKEYS)
	shell_print(sh,
40008f68:	40034637          	lui	a2,0x40034
40008f6c:	00040513          	mv	a0,s0
40008f70:	d3860613          	addi	a2,a2,-712 # 40033d38 <shell_transport_uart_shell_uart+0x30c>
40008f74:	00800593          	li	a1,8
40008f78:	f75ff0ef          	jal	ra,40008eec <shell_fprintf>
		"Please refer to shell documentation for more details.");
#endif

	if (IS_ENABLED(CONFIG_SHELL_HELP)) {
		/* For NULL argument function will print all root commands */
		z_shell_help_subcmd_print(sh, NULL,
40008f7c:	40034637          	lui	a2,0x40034
40008f80:	00040513          	mv	a0,s0
40008f84:	dd460613          	addi	a2,a2,-556 # 40033dd4 <shell_transport_uart_shell_uart+0x3a8>
40008f88:	00000593          	li	a1,0
40008f8c:	218020ef          	jal	ra,4000b1a4 <z_shell_help_subcmd_print>
			shell_print(sh, "  %s", entry->syntax);
		}
	}

	return 0;
}
40008f90:	00c12083          	lw	ra,12(sp)
40008f94:	00812403          	lw	s0,8(sp)
40008f98:	00000513          	li	a0,0
40008f9c:	01010113          	addi	sp,sp,16
40008fa0:	00008067          	ret

40008fa4 <shell_hexdump_line>:
{
40008fa4:	fe010113          	addi	sp,sp,-32
40008fa8:	01312623          	sw	s3,12(sp)
40008fac:	00060993          	mv	s3,a2
	shell_fprintf(sh, SHELL_NORMAL, "%08X: ", offset);
40008fb0:	40034637          	lui	a2,0x40034
{
40008fb4:	01212823          	sw	s2,16(sp)
	shell_fprintf(sh, SHELL_NORMAL, "%08X: ", offset);
40008fb8:	dec60613          	addi	a2,a2,-532 # 40033dec <shell_transport_uart_shell_uart+0x3c0>
{
40008fbc:	00068913          	mv	s2,a3
	shell_fprintf(sh, SHELL_NORMAL, "%08X: ", offset);
40008fc0:	00058693          	mv	a3,a1
40008fc4:	00800593          	li	a1,8
{
40008fc8:	00812c23          	sw	s0,24(sp)
40008fcc:	00112e23          	sw	ra,28(sp)
40008fd0:	00912a23          	sw	s1,20(sp)
40008fd4:	00050413          	mv	s0,a0
	shell_fprintf(sh, SHELL_NORMAL, "%08X: ", offset);
40008fd8:	f15ff0ef          	jal	ra,40008eec <shell_fprintf>
		if (i < len) {
40008fdc:	08091263          	bnez	s2,40009060 <shell_hexdump_line+0xbc>
			shell_fprintf(sh, SHELL_NORMAL, "   ");
40008fe0:	40033637          	lui	a2,0x40033
40008fe4:	b1860613          	addi	a2,a2,-1256 # 40032b18 <mpsc_config+0xbc>
40008fe8:	00800593          	li	a1,8
40008fec:	00040513          	mv	a0,s0
40008ff0:	efdff0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
40008ff4:	00100493          	li	s1,1
			shell_fprintf(sh, SHELL_NORMAL, "   ");
40008ff8:	40033637          	lui	a2,0x40033
40008ffc:	b1860613          	addi	a2,a2,-1256 # 40032b18 <mpsc_config+0xbc>
40009000:	00800593          	li	a1,8
40009004:	00040513          	mv	a0,s0
40009008:	ee5ff0ef          	jal	ra,40008eec <shell_fprintf>
4000900c:	03c0006f          	j	40009048 <shell_hexdump_line+0xa4>
			shell_fprintf(sh, SHELL_NORMAL, " ");
40009010:	40036637          	lui	a2,0x40036
40009014:	72460613          	addi	a2,a2,1828 # 40036724 <CSWTCH.15846+0x10c4>
40009018:	00800593          	li	a1,8
4000901c:	00040513          	mv	a0,s0
40009020:	ecdff0ef          	jal	ra,40008eec <shell_fprintf>
		if (i < len) {
40009024:	00048793          	mv	a5,s1
40009028:	fd24f8e3          	bgeu	s1,s2,40008ff8 <shell_hexdump_line+0x54>
				      data[i] & 0xFF);
4000902c:	00f987b3          	add	a5,s3,a5
			shell_fprintf(sh, SHELL_NORMAL, "%02x ",
40009030:	0007c683          	lbu	a3,0(a5)
40009034:	40033637          	lui	a2,0x40033
40009038:	b1060613          	addi	a2,a2,-1264 # 40032b10 <mpsc_config+0xb4>
4000903c:	00800593          	li	a1,8
40009040:	00040513          	mv	a0,s0
40009044:	ea9ff0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
40009048:	00148493          	addi	s1,s1,1
4000904c:	01000793          	li	a5,16
40009050:	00f48e63          	beq	s1,a5,4000906c <shell_hexdump_line+0xc8>
		if (i > 0 && !(i % 8)) {
40009054:	0074f793          	andi	a5,s1,7
40009058:	fc0796e3          	bnez	a5,40009024 <shell_hexdump_line+0x80>
4000905c:	fb5ff06f          	j	40009010 <shell_hexdump_line+0x6c>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
40009060:	00000493          	li	s1,0
		if (i < len) {
40009064:	00000793          	li	a5,0
40009068:	fc5ff06f          	j	4000902c <shell_hexdump_line+0x88>
	shell_fprintf(sh, SHELL_NORMAL, "|");
4000906c:	40033637          	lui	a2,0x40033
40009070:	b1c60613          	addi	a2,a2,-1252 # 40032b1c <mpsc_config+0xc0>
40009074:	00800593          	li	a1,8
40009078:	00040513          	mv	a0,s0
4000907c:	e71ff0ef          	jal	ra,40008eec <shell_fprintf>
		if (i < len) {
40009080:	02091e63          	bnez	s2,400090bc <shell_hexdump_line+0x118>
			shell_fprintf(sh, SHELL_NORMAL, " ");
40009084:	40036637          	lui	a2,0x40036
40009088:	72460613          	addi	a2,a2,1828 # 40036724 <CSWTCH.15846+0x10c4>
4000908c:	00800593          	li	a1,8
40009090:	00040513          	mv	a0,s0
40009094:	e59ff0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
40009098:	00100493          	li	s1,1
		if (i < len) {
4000909c:	00048793          	mv	a5,s1
400090a0:	0324e263          	bltu	s1,s2,400090c4 <shell_hexdump_line+0x120>
			shell_fprintf(sh, SHELL_NORMAL, " ");
400090a4:	40036637          	lui	a2,0x40036
400090a8:	72460613          	addi	a2,a2,1828 # 40036724 <CSWTCH.15846+0x10c4>
400090ac:	00800593          	li	a1,8
400090b0:	00040513          	mv	a0,s0
400090b4:	e39ff0ef          	jal	ra,40008eec <shell_fprintf>
400090b8:	0380006f          	j	400090f0 <shell_hexdump_line+0x14c>
		if (i < len) {
400090bc:	00000493          	li	s1,0
400090c0:	00000793          	li	a5,0
			char c = data[i];
400090c4:	00f987b3          	add	a5,s3,a5
400090c8:	0007c683          	lbu	a3,0(a5)
			shell_fprintf(sh, SHELL_NORMAL, "%c",
400090cc:	05e00793          	li	a5,94
	return (int)((((unsigned)c) >= ' ') &&
400090d0:	fe068713          	addi	a4,a3,-32
400090d4:	00e7f463          	bgeu	a5,a4,400090dc <shell_hexdump_line+0x138>
400090d8:	02e00693          	li	a3,46
400090dc:	40034637          	lui	a2,0x40034
400090e0:	e3460613          	addi	a2,a2,-460 # 40033e34 <_shell_help+0x18>
400090e4:	00800593          	li	a1,8
400090e8:	00040513          	mv	a0,s0
400090ec:	e01ff0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
400090f0:	00148493          	addi	s1,s1,1
400090f4:	01000793          	li	a5,16
400090f8:	02f48263          	beq	s1,a5,4000911c <shell_hexdump_line+0x178>
		if (i > 0 && !(i % 8)) {
400090fc:	0074f793          	andi	a5,s1,7
40009100:	f8079ee3          	bnez	a5,4000909c <shell_hexdump_line+0xf8>
			shell_fprintf(sh, SHELL_NORMAL, " ");
40009104:	40036637          	lui	a2,0x40036
40009108:	72460613          	addi	a2,a2,1828 # 40036724 <CSWTCH.15846+0x10c4>
4000910c:	00800593          	li	a1,8
40009110:	00040513          	mv	a0,s0
40009114:	dd9ff0ef          	jal	ra,40008eec <shell_fprintf>
40009118:	f85ff06f          	j	4000909c <shell_hexdump_line+0xf8>
	shell_print(sh, "|");
4000911c:	00040513          	mv	a0,s0
}
40009120:	01812403          	lw	s0,24(sp)
40009124:	01c12083          	lw	ra,28(sp)
40009128:	01412483          	lw	s1,20(sp)
4000912c:	01012903          	lw	s2,16(sp)
40009130:	00c12983          	lw	s3,12(sp)
	shell_print(sh, "|");
40009134:	40034637          	lui	a2,0x40034
40009138:	df460613          	addi	a2,a2,-524 # 40033df4 <shell_transport_uart_shell_uart+0x3c8>
4000913c:	00800593          	li	a1,8
}
40009140:	02010113          	addi	sp,sp,32
	shell_print(sh, "|");
40009144:	da9ff06f          	j	40008eec <shell_fprintf>

40009148 <shell_hexdump>:
{
40009148:	fe010113          	addi	sp,sp,-32
4000914c:	00812c23          	sw	s0,24(sp)
40009150:	00912a23          	sw	s1,20(sp)
40009154:	01212823          	sw	s2,16(sp)
40009158:	01412423          	sw	s4,8(sp)
4000915c:	01512223          	sw	s5,4(sp)
40009160:	00112e23          	sw	ra,28(sp)
40009164:	01312623          	sw	s3,12(sp)
40009168:	00050a13          	mv	s4,a0
4000916c:	00058913          	mv	s2,a1
40009170:	00060413          	mv	s0,a2
	const uint8_t *p = data;
40009174:	00058493          	mv	s1,a1
		line_len = MIN(len, SHELL_HEXDUMP_BYTES_IN_LINE);
40009178:	01000a93          	li	s5,16
	while (len) {
4000917c:	02041463          	bnez	s0,400091a4 <shell_hexdump+0x5c>
}
40009180:	01c12083          	lw	ra,28(sp)
40009184:	01812403          	lw	s0,24(sp)
40009188:	01412483          	lw	s1,20(sp)
4000918c:	01012903          	lw	s2,16(sp)
40009190:	00c12983          	lw	s3,12(sp)
40009194:	00812a03          	lw	s4,8(sp)
40009198:	00412a83          	lw	s5,4(sp)
4000919c:	02010113          	addi	sp,sp,32
400091a0:	00008067          	ret
		line_len = MIN(len, SHELL_HEXDUMP_BYTES_IN_LINE);
400091a4:	00040993          	mv	s3,s0
400091a8:	008af463          	bgeu	s5,s0,400091b0 <shell_hexdump+0x68>
400091ac:	01000993          	li	s3,16
		shell_hexdump_line(sh, p - data, p, line_len);
400091b0:	00048613          	mv	a2,s1
400091b4:	412485b3          	sub	a1,s1,s2
400091b8:	00098693          	mv	a3,s3
400091bc:	000a0513          	mv	a0,s4
400091c0:	de5ff0ef          	jal	ra,40008fa4 <shell_hexdump_line>
		len -= line_len;
400091c4:	41340433          	sub	s0,s0,s3
		p += line_len;
400091c8:	013484b3          	add	s1,s1,s3
400091cc:	fb1ff06f          	j	4000917c <shell_hexdump+0x34>

400091d0 <shell_help>:
{
400091d0:	ff010113          	addi	sp,sp,-16
400091d4:	00112623          	sw	ra,12(sp)
400091d8:	00812423          	sw	s0,8(sp)
400091dc:	00050413          	mv	s0,a0
	k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
400091e0:	00852503          	lw	a0,8(a0)
400091e4:	fff00593          	li	a1,-1
400091e8:	fff00613          	li	a2,-1
400091ec:	30450513          	addi	a0,a0,772
400091f0:	f00fe0ef          	jal	ra,400078f0 <k_mutex_lock.constprop.0.isra.0>
	shell_internal_help_print(sh);
400091f4:	00040513          	mv	a0,s0
400091f8:	eb8fe0ef          	jal	ra,400078b0 <shell_internal_help_print>
	k_mutex_unlock(&sh->ctx->wr_mtx);
400091fc:	00842503          	lw	a0,8(s0)
}
40009200:	00812403          	lw	s0,8(sp)
40009204:	00c12083          	lw	ra,12(sp)
	k_mutex_unlock(&sh->ctx->wr_mtx);
40009208:	30450513          	addi	a0,a0,772
}
4000920c:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&sh->ctx->wr_mtx);
40009210:	919fe06f          	j	40007b28 <k_mutex_unlock.isra.0>

40009214 <shell_get_return_value>:
	if (sh == NULL) {
40009214:	00050863          	beqz	a0,40009224 <shell_get_return_value+0x10>
	return sh->ctx->ret_val;
40009218:	00852783          	lw	a5,8(a0)
4000921c:	31c7a503          	lw	a0,796(a5)
	return z_shell_get_return_value(sh);
40009220:	00008067          	ret
		return -EINVAL;
40009224:	fea00513          	li	a0,-22
}
40009228:	00008067          	ret

4000922c <shell_set_bypass>:
	sh->ctx->bypass = bypass;
4000922c:	00852783          	lw	a5,8(a0)
40009230:	04b7a223          	sw	a1,68(a5)
	if (bypass == NULL) {
40009234:	00059463          	bnez	a1,4000923c <shell_set_bypass+0x10>
		cmd_buffer_clear(sh);
40009238:	d8cfe06f          	j	400077c4 <cmd_buffer_clear>
}
4000923c:	00008067          	ret

40009240 <z_shell_fprintf_buffer_flush>:
	}
}


void z_shell_fprintf_buffer_flush(const struct shell_fprintf *sh_fprintf)
{
40009240:	ff010113          	addi	sp,sp,-16
40009244:	00812423          	sw	s0,8(sp)
40009248:	00112623          	sw	ra,12(sp)
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
4000924c:	01052703          	lw	a4,16(a0)
40009250:	00852783          	lw	a5,8(a0)
{
40009254:	00050413          	mv	s0,a0
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
40009258:	00052583          	lw	a1,0(a0)
4000925c:	00072603          	lw	a2,0(a4)
40009260:	00c52503          	lw	a0,12(a0)
40009264:	000780e7          	jalr	a5
			   sh_fprintf->ctrl_blk->buffer_cnt);
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
40009268:	01042783          	lw	a5,16(s0)
4000926c:	0007a023          	sw	zero,0(a5)
}
40009270:	00c12083          	lw	ra,12(sp)
40009274:	00812403          	lw	s0,8(sp)
40009278:	01010113          	addi	sp,sp,16
4000927c:	00008067          	ret

40009280 <z_shell_fprintf_fmt>:
{
40009280:	ff010113          	addi	sp,sp,-16
40009284:	00812423          	sw	s0,8(sp)
40009288:	00060693          	mv	a3,a2
4000928c:	00050413          	mv	s0,a0
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
40009290:	00058613          	mv	a2,a1
40009294:	00050593          	mv	a1,a0
40009298:	40009537          	lui	a0,0x40009
4000929c:	00000713          	li	a4,0
400092a0:	2dc50513          	addi	a0,a0,732 # 400092dc <out_func>
400092a4:	00112623          	sw	ra,12(sp)
400092a8:	ff4f90ef          	jal	ra,40002a9c <z_cbvprintf_impl>
	if (sh_fprintf->ctrl_blk->autoflush) {
400092ac:	01042783          	lw	a5,16(s0)
400092b0:	0047c783          	lbu	a5,4(a5)
400092b4:	00078c63          	beqz	a5,400092cc <z_shell_fprintf_fmt+0x4c>
		z_shell_fprintf_buffer_flush(sh_fprintf);
400092b8:	00040513          	mv	a0,s0
}
400092bc:	00812403          	lw	s0,8(sp)
400092c0:	00c12083          	lw	ra,12(sp)
400092c4:	01010113          	addi	sp,sp,16
		z_shell_fprintf_buffer_flush(sh_fprintf);
400092c8:	f79ff06f          	j	40009240 <z_shell_fprintf_buffer_flush>
}
400092cc:	00c12083          	lw	ra,12(sp)
400092d0:	00812403          	lw	s0,8(sp)
400092d4:	01010113          	addi	sp,sp,16
400092d8:	00008067          	ret

400092dc <out_func>:
	if ((sh->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
400092dc:	00c5a783          	lw	a5,12(a1) # 100c <CONFIG_HEAP_MEM_POOL_SIZE+0xc>
{
400092e0:	ff010113          	addi	sp,sp,-16
400092e4:	00812423          	sw	s0,8(sp)
400092e8:	00912223          	sw	s1,4(sp)
400092ec:	00112623          	sw	ra,12(sp)
	if ((sh->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
400092f0:	0107a703          	lw	a4,16(a5)
400092f4:	00200793          	li	a5,2
{
400092f8:	00050493          	mv	s1,a0
400092fc:	00058413          	mv	s0,a1
	if ((sh->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
40009300:	00f71a63          	bne	a4,a5,40009314 <out_func+0x38>
40009304:	00a00793          	li	a5,10
40009308:	00f51663          	bne	a0,a5,40009314 <out_func+0x38>
		(void)out_func('\r', ctx);
4000930c:	00d00513          	li	a0,13
40009310:	fcdff0ef          	jal	ra,400092dc <out_func>
	sh_fprintf->buffer[sh_fprintf->ctrl_blk->buffer_cnt] = (uint8_t)c;
40009314:	01042703          	lw	a4,16(s0)
40009318:	00042783          	lw	a5,0(s0)
4000931c:	00072703          	lw	a4,0(a4)
40009320:	00e787b3          	add	a5,a5,a4
40009324:	00978023          	sb	s1,0(a5)
	sh_fprintf->ctrl_blk->buffer_cnt++;
40009328:	01042703          	lw	a4,16(s0)
4000932c:	00072783          	lw	a5,0(a4)
40009330:	00178793          	addi	a5,a5,1
40009334:	00f72023          	sw	a5,0(a4)
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
40009338:	01042783          	lw	a5,16(s0)
4000933c:	0007a703          	lw	a4,0(a5)
40009340:	00442783          	lw	a5,4(s0)
40009344:	00f71663          	bne	a4,a5,40009350 <out_func+0x74>
		z_shell_fprintf_buffer_flush(sh_fprintf);
40009348:	00040513          	mv	a0,s0
4000934c:	ef5ff0ef          	jal	ra,40009240 <z_shell_fprintf_buffer_flush>
}
40009350:	00c12083          	lw	ra,12(sp)
40009354:	00812403          	lw	s0,8(sp)
40009358:	00412483          	lw	s1,4(sp)
4000935c:	00000513          	li	a0,0
40009360:	01010113          	addi	sp,sp,16
40009364:	00008067          	ret

40009368 <isspace>:
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
40009368:	02000793          	li	a5,32
4000936c:	00f50863          	beq	a0,a5,4000937c <isspace+0x14>
40009370:	ff750513          	addi	a0,a0,-9
40009374:	00553513          	sltiu	a0,a0,5
40009378:	00008067          	ret
4000937c:	00100513          	li	a0,1
}
40009380:	00008067          	ret

40009384 <z_shell_strlen>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
40009384:	02050263          	beqz	a0,400093a8 <z_shell_strlen+0x24>
{
40009388:	ff010113          	addi	sp,sp,-16
4000938c:	00112623          	sw	ra,12(sp)
	return str == NULL ? 0U : (uint16_t)strlen(str);
40009390:	045030ef          	jal	ra,4000cbd4 <strlen>
}
40009394:	00c12083          	lw	ra,12(sp)
	return str == NULL ? 0U : (uint16_t)strlen(str);
40009398:	01051513          	slli	a0,a0,0x10
4000939c:	01055513          	srli	a0,a0,0x10
}
400093a0:	01010113          	addi	sp,sp,16
400093a4:	00008067          	ret
	return str == NULL ? 0U : (uint16_t)strlen(str);
400093a8:	00000513          	li	a0,0
}
400093ac:	00008067          	ret

400093b0 <z_column_span_with_buffer_offsets_get>:
/* Calculates column number of given position in buffer */
static uint32_t col_num_with_buffer_offset_get(struct shell_multiline_cons *cons,
					    uint16_t buffer_pos)
{
	/* columns are counted from 1 */
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
400093b0:	00c54703          	lbu	a4,12(a0)
400093b4:	00a55783          	lhu	a5,10(a0)
400093b8:	00e585b3          	add	a1,a1,a4
400093bc:	00e60533          	add	a0,a2,a4
400093c0:	02f56533          	rem	a0,a0,a5
400093c4:	02f5e5b3          	rem	a1,a1,a5
					      uint16_t offset1,
					      uint16_t offset2)
{
	return col_num_with_buffer_offset_get(cons, offset2)
			- col_num_with_buffer_offset_get(cons, offset1);
}
400093c8:	40b50533          	sub	a0,a0,a1
400093cc:	00008067          	ret

400093d0 <z_row_span_with_buffer_offsets_get>:
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
400093d0:	00c54703          	lbu	a4,12(a0)
400093d4:	00a55783          	lhu	a5,10(a0)
400093d8:	00e585b3          	add	a1,a1,a4
400093dc:	00e60533          	add	a0,a2,a4
400093e0:	02f54533          	div	a0,a0,a5
400093e4:	02f5c5b3          	div	a1,a1,a5
					   uint16_t offset1,
					   uint16_t offset2)
{
	return line_num_with_buffer_offset_get(cons, offset2)
		- line_num_with_buffer_offset_get(cons, offset1);
}
400093e8:	40b50533          	sub	a0,a0,a1
400093ec:	00008067          	ret

400093f0 <z_shell_multiline_data_calc>:
				 uint16_t buff_pos, uint16_t buff_len)
{
	/* Current cursor position in command.
	 * +1 -> because home position is (1, 1)
	 */
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
400093f0:	00c54683          	lbu	a3,12(a0)
400093f4:	00a55783          	lhu	a5,10(a0)
400093f8:	00d585b3          	add	a1,a1,a3
400093fc:	02f5e733          	rem	a4,a1,a5
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;

	/* Extreme position when cursor is at the end of command. */
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
40009400:	00d60633          	add	a2,a2,a3
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
40009404:	00170713          	addi	a4,a4,1
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
40009408:	02f5c5b3          	div	a1,a1,a5
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
4000940c:	00e51023          	sh	a4,0(a0)
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
40009410:	02f64733          	div	a4,a2,a5
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
40009414:	00158593          	addi	a1,a1,1
40009418:	00b51223          	sh	a1,4(a0)
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
4000941c:	02f66633          	rem	a2,a2,a5
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
40009420:	00170713          	addi	a4,a4,1
40009424:	00e51323          	sh	a4,6(a0)
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
40009428:	00160613          	addi	a2,a2,1
4000942c:	00c51123          	sh	a2,2(a0)
}
40009430:	00008067          	ret

40009434 <z_shell_make_argv>:
}


char z_shell_make_argv(size_t *argc, const char **argv, char *cmd,
		       uint8_t max_argc)
{
40009434:	fb010113          	addi	sp,sp,-80
40009438:	04812423          	sw	s0,72(sp)
4000943c:	05212023          	sw	s2,64(sp)
40009440:	03312e23          	sw	s3,60(sp)
40009444:	03512a23          	sw	s5,52(sp)
40009448:	03612823          	sw	s6,48(sp)
4000944c:	03712623          	sw	s7,44(sp)
40009450:	04112623          	sw	ra,76(sp)
40009454:	04912223          	sw	s1,68(sp)
40009458:	03412c23          	sw	s4,56(sp)
4000945c:	03812423          	sw	s8,40(sp)
40009460:	03912223          	sw	s9,36(sp)
40009464:	03a12023          	sw	s10,32(sp)
40009468:	01b12e23          	sw	s11,28(sp)
4000946c:	00050993          	mv	s3,a0
40009470:	00b12423          	sw	a1,8(sp)
40009474:	00060413          	mv	s0,a2
40009478:	00068a93          	mv	s5,a3
	char quote = 0;
	char c;

	*argc = 0;
4000947c:	00052023          	sw	zero,0(a0)
	char quote = 0;
40009480:	00000913          	li	s2,0
			switch (c) {
40009484:	05c00b13          	li	s6,92
40009488:	02200b93          	li	s7,34
	do {
		c = *cmd;
4000948c:	00044503          	lbu	a0,0(s0)
		if (c == '\0') {
40009490:	28050463          	beqz	a0,40009718 <z_shell_make_argv+0x2e4>
			break;
		}

		if (isspace((int) c) != 0) {
40009494:	ed5ff0ef          	jal	ra,40009368 <isspace>
40009498:	00050c63          	beqz	a0,400094b0 <z_shell_make_argv+0x7c>
			*cmd++ = '\0';
4000949c:	00040023          	sb	zero,0(s0)
400094a0:	00140413          	addi	s0,s0,1
			continue;
400094a4:	fe9ff06f          	j	4000948c <z_shell_make_argv+0x58>
400094a8:	00000913          	li	s2,0
400094ac:	fe1ff06f          	j	4000948c <z_shell_make_argv+0x58>
		}

		argv[(*argc)++] = cmd;
400094b0:	0009a783          	lw	a5,0(s3)
400094b4:	00178713          	addi	a4,a5,1
400094b8:	00e9a023          	sw	a4,0(s3)
400094bc:	00812703          	lw	a4,8(sp)
400094c0:	00279793          	slli	a5,a5,0x2
400094c4:	00f707b3          	add	a5,a4,a5
400094c8:	0087a023          	sw	s0,0(a5)
		if (*argc == max_argc) {
400094cc:	0009a783          	lw	a5,0(s3)
400094d0:	25578463          	beq	a5,s5,40009718 <z_shell_make_argv+0x2e4>
	char quote = 0;
400094d4:	00000913          	li	s2,0
			switch (c) {
400094d8:	02700c13          	li	s8,39
			if (t == '0') {
400094dc:	03000c93          	li	s9,48
			if (t == 'x') {
400094e0:	07800d13          	li	s10,120
		c = *cmd;
400094e4:	00044783          	lbu	a5,0(s0)
		if (c == '\0') {
400094e8:	fa0782e3          	beqz	a5,4000948c <z_shell_make_argv+0x58>
		if (!quote) {
400094ec:	02091e63          	bnez	s2,40009528 <z_shell_make_argv+0xf4>
		c = *cmd;
400094f0:	00078913          	mv	s2,a5
		if (c == '\0') {
400094f4:	00040793          	mv	a5,s0
400094f8:	00078413          	mv	s0,a5
			switch (c) {
400094fc:	01890663          	beq	s2,s8,40009508 <z_shell_make_argv+0xd4>
40009500:	05690e63          	beq	s2,s6,4000955c <z_shell_make_argv+0x128>
40009504:	1f791a63          	bne	s2,s7,400096f8 <z_shell_make_argv+0x2c4>
						z_shell_strlen(cmd));
40009508:	00040513          	mv	a0,s0
4000950c:	e79ff0ef          	jal	ra,40009384 <z_shell_strlen>
40009510:	00050613          	mv	a2,a0
				memmove(cmd, cmd + 1,
40009514:	00140593          	addi	a1,s0,1
40009518:	00040513          	mv	a0,s0
4000951c:	794030ef          	jal	ra,4000ccb0 <memmove>
		c = *cmd;
40009520:	00044783          	lbu	a5,0(s0)
		if (c == '\0') {
40009524:	f60784e3          	beqz	a5,4000948c <z_shell_make_argv+0x58>
				cmd += 1;
40009528:	00040a13          	mv	s4,s0
				memmove(cmd, cmd + 1,
4000952c:	00140413          	addi	s0,s0,1
		if (quote == c) {
40009530:	05279c63          	bne	a5,s2,40009588 <z_shell_make_argv+0x154>
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
40009534:	000a0513          	mv	a0,s4
40009538:	e4dff0ef          	jal	ra,40009384 <z_shell_strlen>
4000953c:	00050613          	mv	a2,a0
40009540:	00040593          	mv	a1,s0
40009544:	000a0513          	mv	a0,s4
40009548:	768030ef          	jal	ra,4000ccb0 <memmove>
		c = *cmd;
4000954c:	000a4903          	lbu	s2,0(s4)
		if (c == '\0') {
40009550:	000a0413          	mv	s0,s4
40009554:	fa0910e3          	bnez	s2,400094f4 <z_shell_make_argv+0xc0>
40009558:	f35ff06f          	j	4000948c <z_shell_make_argv+0x58>
						z_shell_strlen(cmd));
4000955c:	00040513          	mv	a0,s0
40009560:	e25ff0ef          	jal	ra,40009384 <z_shell_strlen>
				memmove(cmd, cmd + 1,
40009564:	00140493          	addi	s1,s0,1
						z_shell_strlen(cmd));
40009568:	00050613          	mv	a2,a0
				memmove(cmd, cmd + 1,
4000956c:	00048593          	mv	a1,s1
40009570:	00040513          	mv	a0,s0
40009574:	73c030ef          	jal	ra,4000ccb0 <memmove>
		c = *cmd;
40009578:	00144903          	lbu	s2,1(s0)
				cmd += 1;
4000957c:	00048413          	mv	s0,s1
		if (c == '\0') {
40009580:	f6091ee3          	bnez	s2,400094fc <z_shell_make_argv+0xc8>
40009584:	f09ff06f          	j	4000948c <z_shell_make_argv+0x58>
		if (quote && c == '\\') {
40009588:	001a4703          	lbu	a4,1(s4)
4000958c:	15679e63          	bne	a5,s6,400096e8 <z_shell_make_argv+0x2b4>
			char t = *(cmd + 1);
40009590:	00070593          	mv	a1,a4
			if (t == quote) {
40009594:	03271063          	bne	a4,s2,400095b4 <z_shell_make_argv+0x180>
						z_shell_strlen(cmd));
40009598:	000a0513          	mv	a0,s4
4000959c:	de9ff0ef          	jal	ra,40009384 <z_shell_strlen>
400095a0:	00050613          	mv	a2,a0
				memmove(cmd, cmd + 1,
400095a4:	00040593          	mv	a1,s0
400095a8:	000a0513          	mv	a0,s4
400095ac:	704030ef          	jal	ra,4000ccb0 <memmove>
				continue;
400095b0:	f35ff06f          	j	400094e4 <z_shell_make_argv+0xb0>
			if (t == '0') {
400095b4:	09971063          	bne	a4,s9,40009634 <z_shell_make_argv+0x200>
400095b8:	00200613          	li	a2,2
				uint8_t v = 0U;
400095bc:	00000493          	li	s1,0
					if (t >= '0' && t <= '7') {
400095c0:	00700813          	li	a6,7
				for (i = 2U; i < (2 + 3); i++) {
400095c4:	00500513          	li	a0,5
					t = *(cmd + i);
400095c8:	00ca07b3          	add	a5,s4,a2
400095cc:	0007c583          	lbu	a1,0(a5)
					if (t >= '0' && t <= '7') {
400095d0:	fd058793          	addi	a5,a1,-48
400095d4:	0ff7f793          	zext.b	a5,a5
400095d8:	04f86863          	bltu	a6,a5,40009628 <z_shell_make_argv+0x1f4>
						v = (v << 3) | (t - '0');
400095dc:	00349493          	slli	s1,s1,0x3
400095e0:	0ff4f493          	zext.b	s1,s1
				for (i = 2U; i < (2 + 3); i++) {
400095e4:	00160613          	addi	a2,a2,1
						v = (v << 3) | (t - '0');
400095e8:	0097e4b3          	or	s1,a5,s1
				for (i = 2U; i < (2 + 3); i++) {
400095ec:	fca61ee3          	bne	a2,a0,400095c8 <z_shell_make_argv+0x194>
400095f0:	00500d93          	li	s11,5
					memmove(cmd, cmd + (i - 1),
400095f4:	fffd8593          	addi	a1,s11,-1
400095f8:	00ba05b3          	add	a1,s4,a1
						z_shell_strlen(cmd) - (i - 2));
400095fc:	000a0513          	mv	a0,s4
					memmove(cmd, cmd + (i - 1),
40009600:	00b12623          	sw	a1,12(sp)
						z_shell_strlen(cmd) - (i - 2));
40009604:	d81ff0ef          	jal	ra,40009384 <z_shell_strlen>
40009608:	ffed8613          	addi	a2,s11,-2
					memmove(cmd, cmd + (i - 1),
4000960c:	40c50633          	sub	a2,a0,a2
					memmove(cmd, cmd + (i - 1),
40009610:	00c12583          	lw	a1,12(sp)
40009614:	000a0513          	mv	a0,s4
40009618:	698030ef          	jal	ra,4000ccb0 <memmove>
		c = *cmd;
4000961c:	001a4783          	lbu	a5,1(s4)
					*cmd++ = v;
40009620:	009a0023          	sb	s1,0(s4)
		if (c == '\0') {
40009624:	f01ff06f          	j	40009524 <z_shell_make_argv+0xf0>
40009628:	0ff67d93          	zext.b	s11,a2
				if (i > 2) {
4000962c:	00200793          	li	a5,2
40009630:	fcfd92e3          	bne	s11,a5,400095f4 <z_shell_make_argv+0x1c0>
			if (t == 'x') {
40009634:	0ba59863          	bne	a1,s10,400096e4 <z_shell_make_argv+0x2b0>
40009638:	00200613          	li	a2,2
				uint8_t v = 0U;
4000963c:	00000493          	li	s1,0
					if (t >= '0' && t <= '9') {
40009640:	00900813          	li	a6,9
				for (i = 2U; i < (2 + 2); i++) {
40009644:	00200513          	li	a0,2
					t = *(cmd + i);
40009648:	00ca07b3          	add	a5,s4,a2
4000964c:	0007c783          	lbu	a5,0(a5)
					if (t >= '0' && t <= '9') {
40009650:	fd078593          	addi	a1,a5,-48
40009654:	0ff5f593          	zext.b	a1,a1
40009658:	04b86063          	bltu	a6,a1,40009698 <z_shell_make_argv+0x264>
						v = (v << 4) | (t - '0');
4000965c:	00449493          	slli	s1,s1,0x4
40009660:	0ff4f493          	zext.b	s1,s1
40009664:	0095e4b3          	or	s1,a1,s1
				for (i = 2U; i < (2 + 2); i++) {
40009668:	02a60463          	beq	a2,a0,40009690 <z_shell_make_argv+0x25c>
4000966c:	00400d93          	li	s11,4
					memmove(cmd, cmd + (i - 1),
40009670:	fffd8593          	addi	a1,s11,-1
40009674:	00ba05b3          	add	a1,s4,a1
						z_shell_strlen(cmd) - (i - 2));
40009678:	000a0513          	mv	a0,s4
					memmove(cmd, cmd + (i - 1),
4000967c:	00b12623          	sw	a1,12(sp)
						z_shell_strlen(cmd) - (i - 2));
40009680:	ffed8d93          	addi	s11,s11,-2
40009684:	d01ff0ef          	jal	ra,40009384 <z_shell_strlen>
					memmove(cmd, cmd + (i - 1),
40009688:	41b50633          	sub	a2,a0,s11
4000968c:	f85ff06f          	j	40009610 <z_shell_make_argv+0x1dc>
40009690:	00300613          	li	a2,3
40009694:	fb5ff06f          	j	40009648 <z_shell_make_argv+0x214>
					} else if ((t >= 'a') &&
40009698:	f9f78593          	addi	a1,a5,-97
4000969c:	0ff5f593          	zext.b	a1,a1
400096a0:	00500893          	li	a7,5
400096a4:	00b8ee63          	bltu	a7,a1,400096c0 <z_shell_make_argv+0x28c>
						v = (v << 4) | (t - 'a' + 10);
400096a8:	00449493          	slli	s1,s1,0x4
400096ac:	0ff4f493          	zext.b	s1,s1
400096b0:	fa978793          	addi	a5,a5,-87
						v = (v << 4) | (t - 'A' + 10);
400096b4:	00f4e4b3          	or	s1,s1,a5
400096b8:	0ff4f493          	zext.b	s1,s1
400096bc:	fadff06f          	j	40009668 <z_shell_make_argv+0x234>
					} else if ((t >= 'A') && (t <= 'F')) {
400096c0:	fbf78593          	addi	a1,a5,-65
400096c4:	0ff5f593          	zext.b	a1,a1
400096c8:	00b8ea63          	bltu	a7,a1,400096dc <z_shell_make_argv+0x2a8>
						v = (v << 4) | (t - 'A' + 10);
400096cc:	00449493          	slli	s1,s1,0x4
400096d0:	0ff4f493          	zext.b	s1,s1
400096d4:	fc978793          	addi	a5,a5,-55
400096d8:	fddff06f          	j	400096b4 <z_shell_make_argv+0x280>
				if (i > 2) {
400096dc:	00200793          	li	a5,2
400096e0:	00f61863          	bne	a2,a5,400096f0 <z_shell_make_argv+0x2bc>
		cmd += 1;
400096e4:	001a0413          	addi	s0,s4,1
		c = *cmd;
400096e8:	00070793          	mv	a5,a4
		if (c == '\0') {
400096ec:	e39ff06f          	j	40009524 <z_shell_make_argv+0xf0>
400096f0:	00300d93          	li	s11,3
400096f4:	f7dff06f          	j	40009670 <z_shell_make_argv+0x23c>
		if (!quote && isspace((int) c) != 0) {
400096f8:	00090513          	mv	a0,s2
400096fc:	c6dff0ef          	jal	ra,40009368 <isspace>
40009700:	da0514e3          	bnez	a0,400094a8 <z_shell_make_argv+0x74>
		c = *cmd;
40009704:	00144903          	lbu	s2,1(s0)
		cmd += 1;
40009708:	00140793          	addi	a5,s0,1
		if (c == '\0') {
4000970c:	de0916e3          	bnez	s2,400094f8 <z_shell_make_argv+0xc4>
		cmd += 1;
40009710:	00078413          	mv	s0,a5
40009714:	d79ff06f          	j	4000948c <z_shell_make_argv+0x58>
		}
		quote = make_argv(&cmd, c);
	} while (true);

	return quote;
}
40009718:	04c12083          	lw	ra,76(sp)
4000971c:	04812403          	lw	s0,72(sp)
40009720:	04412483          	lw	s1,68(sp)
40009724:	03c12983          	lw	s3,60(sp)
40009728:	03812a03          	lw	s4,56(sp)
4000972c:	03412a83          	lw	s5,52(sp)
40009730:	03012b03          	lw	s6,48(sp)
40009734:	02c12b83          	lw	s7,44(sp)
40009738:	02812c03          	lw	s8,40(sp)
4000973c:	02412c83          	lw	s9,36(sp)
40009740:	02012d03          	lw	s10,32(sp)
40009744:	01c12d83          	lw	s11,28(sp)
40009748:	00090513          	mv	a0,s2
4000974c:	04012903          	lw	s2,64(sp)
40009750:	05010113          	addi	sp,sp,80
40009754:	00008067          	ret

40009758 <z_shell_pattern_remove>:

void z_shell_pattern_remove(char *buff, uint16_t *buff_len, const char *pattern)
{
40009758:	fe010113          	addi	sp,sp,-32
4000975c:	01212823          	sw	s2,16(sp)
40009760:	00058913          	mv	s2,a1
	char *pattern_addr = strstr(buff, pattern);
40009764:	00060593          	mv	a1,a2
{
40009768:	00812c23          	sw	s0,24(sp)
4000976c:	00912a23          	sw	s1,20(sp)
40009770:	01312623          	sw	s3,12(sp)
40009774:	00112e23          	sw	ra,28(sp)
40009778:	00060493          	mv	s1,a2
4000977c:	00050993          	mv	s3,a0
	char *pattern_addr = strstr(buff, pattern);
40009780:	31c030ef          	jal	ra,4000ca9c <strstr>
40009784:	00050413          	mv	s0,a0
	uint16_t shift;
	uint16_t pattern_len = z_shell_strlen(pattern);
40009788:	00048513          	mv	a0,s1
4000978c:	bf9ff0ef          	jal	ra,40009384 <z_shell_strlen>

	if (!pattern_addr) {
40009790:	06040863          	beqz	s0,40009800 <z_shell_pattern_remove+0xa8>
40009794:	00050493          	mv	s1,a0
		return;
	}

	if (pattern_addr > buff) {
40009798:	0289f063          	bgeu	s3,s0,400097b8 <z_shell_pattern_remove+0x60>
		if (*(pattern_addr - 1) == ' ') {
4000979c:	fff44703          	lbu	a4,-1(s0)
400097a0:	02000793          	li	a5,32
400097a4:	00f71a63          	bne	a4,a5,400097b8 <z_shell_pattern_remove+0x60>
			pattern_len++; /* space needs to be removed as well */
400097a8:	00150493          	addi	s1,a0,1
400097ac:	01049493          	slli	s1,s1,0x10
400097b0:	0104d493          	srli	s1,s1,0x10
			pattern_addr--; /* set pointer to space */
400097b4:	fff40413          	addi	s0,s0,-1
		}
	}

	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
400097b8:	00040513          	mv	a0,s0
400097bc:	bc9ff0ef          	jal	ra,40009384 <z_shell_strlen>
	*buff_len -= pattern_len;
400097c0:	00095783          	lhu	a5,0(s2)
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
400097c4:	00150613          	addi	a2,a0,1

	memmove(pattern_addr, pattern_addr + pattern_len, shift);
400097c8:	009405b3          	add	a1,s0,s1
	*buff_len -= pattern_len;
400097cc:	409787b3          	sub	a5,a5,s1
400097d0:	00f91023          	sh	a5,0(s2)
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
400097d4:	00040513          	mv	a0,s0
}
400097d8:	01812403          	lw	s0,24(sp)
400097dc:	01c12083          	lw	ra,28(sp)
400097e0:	01012903          	lw	s2,16(sp)
400097e4:	00c12983          	lw	s3,12(sp)
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
400097e8:	40960633          	sub	a2,a2,s1
}
400097ec:	01412483          	lw	s1,20(sp)
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
400097f0:	01061613          	slli	a2,a2,0x10
400097f4:	01065613          	srli	a2,a2,0x10
}
400097f8:	02010113          	addi	sp,sp,32
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
400097fc:	4b40306f          	j	4000ccb0 <memmove>
}
40009800:	01c12083          	lw	ra,28(sp)
40009804:	01812403          	lw	s0,24(sp)
40009808:	01412483          	lw	s1,20(sp)
4000980c:	01012903          	lw	s2,16(sp)
40009810:	00c12983          	lw	s3,12(sp)
40009814:	02010113          	addi	sp,sp,32
40009818:	00008067          	ret

4000981c <z_shell_cmd_get>:

const struct shell_static_entry *z_shell_cmd_get(
					const struct shell_static_entry *parent,
					size_t idx,
					struct shell_static_entry *dloc)
{
4000981c:	ff010113          	addi	sp,sp,-16
40009820:	00050793          	mv	a5,a0
40009824:	00112623          	sw	ra,12(sp)
40009828:	00812423          	sw	s0,8(sp)
4000982c:	00058513          	mv	a0,a1
	const struct shell_static_entry *res = NULL;

	if (parent == NULL) {
40009830:	04079063          	bnez	a5,40009870 <z_shell_cmd_get+0x54>
	TYPE_SECTION_COUNT(union shell_cmd_entry, shell_root_cmds, &len);
40009834:	40032737          	lui	a4,0x40032
40009838:	400327b7          	lui	a5,0x40032
4000983c:	54c70713          	addi	a4,a4,1356 # 4003254c <shell_cmd_clear>
40009840:	57878793          	addi	a5,a5,1400 # 40032578 <z_shell_subcmd_end_marker>
40009844:	40e787b3          	sub	a5,a5,a4
40009848:	0027d793          	srli	a5,a5,0x2
		return  (idx < shell_root_cmd_count()) ?
				shell_root_cmd_get(idx)->entry : NULL;
4000984c:	02f5f663          	bgeu	a1,a5,40009878 <z_shell_cmd_get+0x5c>
40009850:	00259513          	slli	a0,a1,0x2
40009854:	00a70733          	add	a4,a4,a0
40009858:	00072403          	lw	s0,0(a4)
			}
		}
	}

	return res;
}
4000985c:	00c12083          	lw	ra,12(sp)
40009860:	00040513          	mv	a0,s0
40009864:	00812403          	lw	s0,8(sp)
40009868:	01010113          	addi	sp,sp,16
4000986c:	00008067          	ret
	if (parent->subcmd) {
40009870:	0087a783          	lw	a5,8(a5)
40009874:	00079663          	bnez	a5,40009880 <z_shell_cmd_get+0x64>
	const struct shell_static_entry *res = NULL;
40009878:	00000413          	li	s0,0
4000987c:	fe1ff06f          	j	4000985c <z_shell_cmd_get+0x40>
	return (entry >= TYPE_SECTION_START(shell_dynamic_subcmds)) &&
40009880:	40032737          	lui	a4,0x40032
40009884:	58c70713          	addi	a4,a4,1420 # 4003258c <dsub_backend_name_dynamic>
40009888:	02e7e663          	bltu	a5,a4,400098b4 <z_shell_cmd_get+0x98>
4000988c:	40032737          	lui	a4,0x40032
40009890:	5a070713          	addi	a4,a4,1440 # 400325a0 <prefix.1>
40009894:	02e7f063          	bgeu	a5,a4,400098b4 <z_shell_cmd_get+0x98>
			parent->subcmd->dynamic_get(idx, dloc);
40009898:	0007a783          	lw	a5,0(a5)
4000989c:	00060593          	mv	a1,a2
400098a0:	00060413          	mv	s0,a2
400098a4:	000780e7          	jalr	a5
			if (entry_list[idx].syntax != NULL) {
400098a8:	00042783          	lw	a5,0(s0)
400098ac:	fa0798e3          	bnez	a5,4000985c <z_shell_cmd_get+0x40>
400098b0:	fc9ff06f          	j	40009878 <z_shell_cmd_get+0x5c>
	return (entry >= TYPE_SECTION_START(shell_subcmds)) &&
400098b4:	40032737          	lui	a4,0x40032
400098b8:	57870713          	addi	a4,a4,1400 # 40032578 <z_shell_subcmd_end_marker>
400098bc:	00e7e863          	bltu	a5,a4,400098cc <z_shell_cmd_get+0xb0>
400098c0:	40032737          	lui	a4,0x40032
400098c4:	58c70713          	addi	a4,a4,1420 # 4003258c <dsub_backend_name_dynamic>
400098c8:	00e7ec63          	bltu	a5,a4,400098e0 <z_shell_cmd_get+0xc4>
				entry_list = parent->subcmd->entry;
400098cc:	0007a783          	lw	a5,0(a5)
			if (entry_list[idx].syntax != NULL) {
400098d0:	01400713          	li	a4,20
400098d4:	02e50533          	mul	a0,a0,a4
400098d8:	00a78433          	add	s0,a5,a0
400098dc:	fcdff06f          	j	400098a8 <z_shell_cmd_get+0x8c>
				idx++;
400098e0:	00150513          	addi	a0,a0,1
400098e4:	fedff06f          	j	400098d0 <z_shell_cmd_get+0xb4>

400098e8 <z_shell_find_cmd>:
 */
const struct shell_static_entry *z_shell_find_cmd(
					const struct shell_static_entry *parent,
					const char *cmd_str,
					struct shell_static_entry *dloc)
{
400098e8:	fc010113          	addi	sp,sp,-64
400098ec:	02812c23          	sw	s0,56(sp)
400098f0:	03312623          	sw	s3,44(sp)
400098f4:	03412423          	sw	s4,40(sp)
400098f8:	02112e23          	sw	ra,60(sp)
400098fc:	02912a23          	sw	s1,52(sp)
40009900:	03212823          	sw	s2,48(sp)
40009904:	00050413          	mv	s0,a0
40009908:	00058a13          	mv	s4,a1
4000990c:	00060993          	mv	s3,a2
	 * dynamic commands at the same time (current and subcommand) they
	 * will operate on the same memory region what can cause undefined
	 * behaviour.
	 * Hence we need a separate memory for each of them.
	 */
	if (parent) {
40009910:	00050c63          	beqz	a0,40009928 <z_shell_find_cmd+0x40>
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
40009914:	00050593          	mv	a1,a0
40009918:	01400613          	li	a2,20
4000991c:	00c10513          	addi	a0,sp,12
40009920:	3d8030ef          	jal	ra,4000ccf8 <memcpy>
		parent = &parent_cpy;
40009924:	00c10413          	addi	s0,sp,12
40009928:	00000913          	li	s2,0
	}

	while ((entry = z_shell_cmd_get(parent, idx++, dloc)) != NULL) {
4000992c:	00090593          	mv	a1,s2
40009930:	00098613          	mv	a2,s3
40009934:	00040513          	mv	a0,s0
40009938:	ee5ff0ef          	jal	ra,4000981c <z_shell_cmd_get>
4000993c:	00190913          	addi	s2,s2,1
40009940:	00050493          	mv	s1,a0
40009944:	00050a63          	beqz	a0,40009958 <z_shell_find_cmd+0x70>
		if (strcmp(cmd_str, entry->syntax) == 0) {
40009948:	0004a583          	lw	a1,0(s1)
4000994c:	000a0513          	mv	a0,s4
40009950:	2c8030ef          	jal	ra,4000cc18 <strcmp>
40009954:	fc051ce3          	bnez	a0,4000992c <z_shell_find_cmd+0x44>
			return entry;
		}
	}

	return NULL;
}
40009958:	03c12083          	lw	ra,60(sp)
4000995c:	03812403          	lw	s0,56(sp)
40009960:	03012903          	lw	s2,48(sp)
40009964:	02c12983          	lw	s3,44(sp)
40009968:	02812a03          	lw	s4,40(sp)
4000996c:	00048513          	mv	a0,s1
40009970:	03412483          	lw	s1,52(sp)
40009974:	04010113          	addi	sp,sp,64
40009978:	00008067          	ret

4000997c <z_shell_get_last_command>:
					size_t argc,
					const char *argv[],
					size_t *match_arg,
					struct shell_static_entry *dloc,
					bool only_static)
{
4000997c:	fe010113          	addi	sp,sp,-32
40009980:	00812c23          	sw	s0,24(sp)
40009984:	01212823          	sw	s2,16(sp)
40009988:	01312623          	sw	s3,12(sp)
4000998c:	01412423          	sw	s4,8(sp)
40009990:	01512223          	sw	s5,4(sp)
40009994:	00112e23          	sw	ra,28(sp)
40009998:	00912a23          	sw	s1,20(sp)
4000999c:	00058a13          	mv	s4,a1
400099a0:	00060913          	mv	s2,a2
400099a4:	00068413          	mv	s0,a3
400099a8:	00070993          	mv	s3,a4
400099ac:	00078a93          	mv	s5,a5
	const struct shell_static_entry *prev_entry = NULL;

	*match_arg = Z_SHELL_CMD_ROOT_LVL;
400099b0:	0006a023          	sw	zero,0(a3)

	while (*match_arg < argc) {
400099b4:	00042783          	lw	a5,0(s0)

		if (IS_ENABLED(CONFIG_SHELL_WILDCARD)) {
			/* ignore wildcard argument */
			if (z_shell_has_wildcard(argv[*match_arg])) {
				(*match_arg)++;
				continue;
400099b8:	00050493          	mv	s1,a0
	while (*match_arg < argc) {
400099bc:	0747f263          	bgeu	a5,s4,40009a20 <z_shell_get_last_command+0xa4>
			if (z_shell_has_wildcard(argv[*match_arg])) {
400099c0:	00279793          	slli	a5,a5,0x2
400099c4:	00f907b3          	add	a5,s2,a5
400099c8:	0007a503          	lw	a0,0(a5)
400099cc:	458020ef          	jal	ra,4000be24 <z_shell_has_wildcard>
400099d0:	00042683          	lw	a3,0(s0)
400099d4:	00050a63          	beqz	a0,400099e8 <z_shell_get_last_command+0x6c>
				(*match_arg)++;
400099d8:	00168693          	addi	a3,a3,1
400099dc:	00d42023          	sw	a3,0(s0)
				continue;
400099e0:	00048513          	mv	a0,s1
400099e4:	fd1ff06f          	j	400099b4 <z_shell_get_last_command+0x38>
			}
		}

		prev_entry = entry;
		entry = z_shell_find_cmd(entry, argv[*match_arg], dloc);
400099e8:	00269693          	slli	a3,a3,0x2
400099ec:	00d906b3          	add	a3,s2,a3
400099f0:	0006a583          	lw	a1,0(a3)
400099f4:	00098613          	mv	a2,s3
400099f8:	00048513          	mv	a0,s1
400099fc:	eedff0ef          	jal	ra,400098e8 <z_shell_find_cmd>
		if (entry) {
40009a00:	02050063          	beqz	a0,40009a20 <z_shell_get_last_command+0xa4>
			(*match_arg)++;
40009a04:	00042783          	lw	a5,0(s0)
40009a08:	00178713          	addi	a4,a5,1
40009a0c:	00e42023          	sw	a4,0(s0)
		} else {
			entry = prev_entry;
			break;
		}

		if (only_static && (entry == dloc)) {
40009a10:	fa0a82e3          	beqz	s5,400099b4 <z_shell_get_last_command+0x38>
40009a14:	faa990e3          	bne	s3,a0,400099b4 <z_shell_get_last_command+0x38>
			(*match_arg)--;
40009a18:	00f42023          	sw	a5,0(s0)
			return NULL;
40009a1c:	00000493          	li	s1,0
		}
	}

	return entry;
}
40009a20:	01c12083          	lw	ra,28(sp)
40009a24:	01812403          	lw	s0,24(sp)
40009a28:	01012903          	lw	s2,16(sp)
40009a2c:	00c12983          	lw	s3,12(sp)
40009a30:	00812a03          	lw	s4,8(sp)
40009a34:	00412a83          	lw	s5,4(sp)
40009a38:	00048513          	mv	a0,s1
40009a3c:	01412483          	lw	s1,20(sp)
40009a40:	02010113          	addi	sp,sp,32
40009a44:	00008067          	ret

40009a48 <z_shell_spaces_trim>:




void z_shell_spaces_trim(char *str)
{
40009a48:	fd010113          	addi	sp,sp,-48
40009a4c:	01412c23          	sw	s4,24(sp)
40009a50:	00050a13          	mv	s4,a0
40009a54:	02112623          	sw	ra,44(sp)
40009a58:	02812423          	sw	s0,40(sp)
40009a5c:	02912223          	sw	s1,36(sp)
40009a60:	03212023          	sw	s2,32(sp)
40009a64:	01312e23          	sw	s3,28(sp)
40009a68:	01512a23          	sw	s5,20(sp)
	uint16_t len = z_shell_strlen(str);
40009a6c:	919ff0ef          	jal	ra,40009384 <z_shell_strlen>
	uint16_t shift = 0U;

	if (!str) {
40009a70:	0c0a1263          	bnez	s4,40009b34 <z_shell_spaces_trim+0xec>

				break;
			}
		}
	}
}
40009a74:	02c12083          	lw	ra,44(sp)
40009a78:	02812403          	lw	s0,40(sp)
40009a7c:	02412483          	lw	s1,36(sp)
40009a80:	02012903          	lw	s2,32(sp)
40009a84:	01c12983          	lw	s3,28(sp)
40009a88:	01812a03          	lw	s4,24(sp)
40009a8c:	01412a83          	lw	s5,20(sp)
40009a90:	03010113          	addi	sp,sp,48
40009a94:	00008067          	ret
		if (isspace((int)str[i]) != 0) {
40009a98:	013a07b3          	add	a5,s4,s3
40009a9c:	0007c503          	lbu	a0,0(a5)
40009aa0:	00098a93          	mv	s5,s3
			for (uint16_t j = i + 1; j < len; j++) {
40009aa4:	00198993          	addi	s3,s3,1
40009aa8:	01099993          	slli	s3,s3,0x10
40009aac:	0109d993          	srli	s3,s3,0x10
		if (isspace((int)str[i]) != 0) {
40009ab0:	8b9ff0ef          	jal	ra,40009368 <isspace>
40009ab4:	00098493          	mv	s1,s3
40009ab8:	02051c63          	bnez	a0,40009af0 <z_shell_spaces_trim+0xa8>
	for (uint16_t i = 0; i < len - 1; i++) {
40009abc:	fff40793          	addi	a5,s0,-1
40009ac0:	fcf9cce3          	blt	s3,a5,40009a98 <z_shell_spaces_trim+0x50>
40009ac4:	fb1ff06f          	j	40009a74 <z_shell_spaces_trim+0x2c>
				if (isspace((int)str[j]) != 0) {
40009ac8:	009a05b3          	add	a1,s4,s1
40009acc:	0005c503          	lbu	a0,0(a1)
40009ad0:	00b12623          	sw	a1,12(sp)
40009ad4:	895ff0ef          	jal	ra,40009368 <isspace>
40009ad8:	00c12583          	lw	a1,12(sp)
40009adc:	02050263          	beqz	a0,40009b00 <z_shell_spaces_trim+0xb8>
					shift++;
40009ae0:	00190913          	addi	s2,s2,1
40009ae4:	01091913          	slli	s2,s2,0x10
				if (isspace((int)str[j]) != 0) {
40009ae8:	00148493          	addi	s1,s1,1
					shift++;
40009aec:	01095913          	srli	s2,s2,0x10
			for (uint16_t j = i + 1; j < len; j++) {
40009af0:	01049793          	slli	a5,s1,0x10
40009af4:	0107d793          	srli	a5,a5,0x10
40009af8:	fc87e8e3          	bltu	a5,s0,40009ac8 <z_shell_spaces_trim+0x80>
40009afc:	fc1ff06f          	j	40009abc <z_shell_spaces_trim+0x74>
				if (shift > 0) {
40009b00:	fa090ee3          	beqz	s2,40009abc <z_shell_spaces_trim+0x74>
						len - j + 1);
40009b04:	01049613          	slli	a2,s1,0x10
40009b08:	01065613          	srli	a2,a2,0x10
40009b0c:	40c40633          	sub	a2,s0,a2
					memmove(&str[i + 1],
40009b10:	001a8513          	addi	a0,s5,1
					len -= shift;
40009b14:	41240433          	sub	s0,s0,s2
					memmove(&str[i + 1],
40009b18:	00160613          	addi	a2,a2,1
40009b1c:	00aa0533          	add	a0,s4,a0
					len -= shift;
40009b20:	01041413          	slli	s0,s0,0x10
					memmove(&str[i + 1],
40009b24:	18c030ef          	jal	ra,4000ccb0 <memmove>
					len -= shift;
40009b28:	01045413          	srli	s0,s0,0x10
	uint16_t shift = 0U;
40009b2c:	00000913          	li	s2,0
40009b30:	f8dff06f          	j	40009abc <z_shell_spaces_trim+0x74>
40009b34:	00050413          	mv	s0,a0
	for (uint16_t i = 0; i < len - 1; i++) {
40009b38:	00000993          	li	s3,0
40009b3c:	ff1ff06f          	j	40009b2c <z_shell_spaces_trim+0xe4>

40009b40 <z_shell_cmd_trim>:
		*buff_len = *buff_len - i;
	}
}

void z_shell_cmd_trim(const struct shell *sh)
{
40009b40:	fd010113          	addi	sp,sp,-48
40009b44:	03212023          	sw	s2,32(sp)
40009b48:	01412c23          	sw	s4,24(sp)
40009b4c:	02112623          	sw	ra,44(sp)
40009b50:	02812423          	sw	s0,40(sp)
40009b54:	02912223          	sw	s1,36(sp)
40009b58:	01312e23          	sw	s3,28(sp)
	buffer_trim(sh->ctx->cmd_buff, &sh->ctx->cmd_buff_len);
40009b5c:	00852403          	lw	s0,8(a0)
{
40009b60:	00050913          	mv	s2,a0
	if (buff[0] == '\0') {
40009b64:	04e44783          	lbu	a5,78(s0)
40009b68:	04e40a13          	addi	s4,s0,78
40009b6c:	04079663          	bnez	a5,40009bb8 <z_shell_cmd_trim+0x78>
	sh->ctx->cmd_buff_pos = sh->ctx->cmd_buff_len;
40009b70:	00892783          	lw	a5,8(s2)
40009b74:	0487d703          	lhu	a4,72(a5)
40009b78:	04e79523          	sh	a4,74(a5)
}
40009b7c:	02c12083          	lw	ra,44(sp)
40009b80:	02812403          	lw	s0,40(sp)
40009b84:	02412483          	lw	s1,36(sp)
40009b88:	02012903          	lw	s2,32(sp)
40009b8c:	01c12983          	lw	s3,28(sp)
40009b90:	01812a03          	lw	s4,24(sp)
40009b94:	03010113          	addi	sp,sp,48
40009b98:	00008067          	ret
		*buff_len -= 1U;
40009b9c:	fff48493          	addi	s1,s1,-1
40009ba0:	01049493          	slli	s1,s1,0x10
40009ba4:	0104d493          	srli	s1,s1,0x10
40009ba8:	04941423          	sh	s1,72(s0)
		if (*buff_len == 0U) {
40009bac:	00049663          	bnez	s1,40009bb8 <z_shell_cmd_trim+0x78>
			buff[0] = '\0';
40009bb0:	04040723          	sb	zero,78(s0)
			return;
40009bb4:	fbdff06f          	j	40009b70 <z_shell_cmd_trim+0x30>
	while (isspace((int) buff[*buff_len - 1U]) != 0) {
40009bb8:	04845483          	lhu	s1,72(s0)
40009bbc:	009a09b3          	add	s3,s4,s1
40009bc0:	fff9c503          	lbu	a0,-1(s3)
40009bc4:	fa4ff0ef          	jal	ra,40009368 <isspace>
40009bc8:	fc051ae3          	bnez	a0,40009b9c <z_shell_cmd_trim+0x5c>
	buff[*buff_len] = '\0';
40009bcc:	00098023          	sb	zero,0(s3)
	uint16_t i = 0U;
40009bd0:	00000993          	li	s3,0
	while (isspace((int) buff[i++]) != 0) {
40009bd4:	00098493          	mv	s1,s3
40009bd8:	009a05b3          	add	a1,s4,s1
40009bdc:	0005c503          	lbu	a0,0(a1)
40009be0:	00198993          	addi	s3,s3,1
40009be4:	00b12623          	sw	a1,12(sp)
40009be8:	01099993          	slli	s3,s3,0x10
40009bec:	f7cff0ef          	jal	ra,40009368 <isspace>
40009bf0:	00c12583          	lw	a1,12(sp)
40009bf4:	0109d993          	srli	s3,s3,0x10
40009bf8:	fc051ee3          	bnez	a0,40009bd4 <z_shell_cmd_trim+0x94>
	if (--i > 0) {
40009bfc:	f6048ae3          	beqz	s1,40009b70 <z_shell_cmd_trim+0x30>
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
40009c00:	04845603          	lhu	a2,72(s0)
40009c04:	000a0513          	mv	a0,s4
40009c08:	00160613          	addi	a2,a2,1
40009c0c:	40960633          	sub	a2,a2,s1
40009c10:	0a0030ef          	jal	ra,4000ccb0 <memmove>
		*buff_len = *buff_len - i;
40009c14:	04845783          	lhu	a5,72(s0)
40009c18:	409787b3          	sub	a5,a5,s1
40009c1c:	04f41423          	sh	a5,72(s0)
40009c20:	f51ff06f          	j	40009b70 <z_shell_cmd_trim+0x30>

40009c24 <shell_strtoul>:

	return val;
}

unsigned long shell_strtoul(const char *str, int base, int *err)
{
40009c24:	fe010113          	addi	sp,sp,-32
40009c28:	01212823          	sw	s2,16(sp)
40009c2c:	00112e23          	sw	ra,28(sp)
40009c30:	00812c23          	sw	s0,24(sp)
40009c34:	00912a23          	sw	s1,20(sp)
	unsigned long val;
	char *endptr = NULL;

	if (*str == '-') {
40009c38:	00054703          	lbu	a4,0(a0)
	char *endptr = NULL;
40009c3c:	00012623          	sw	zero,12(sp)
	if (*str == '-') {
40009c40:	02d00793          	li	a5,45
{
40009c44:	00060913          	mv	s2,a2
	if (*str == '-') {
40009c48:	02f71663          	bne	a4,a5,40009c74 <shell_strtoul+0x50>
		*err = -EINVAL;
		return 0;
40009c4c:	fea00793          	li	a5,-22
	}

	errno = 0;
	val = strtoul(str, &endptr, base);
	if (errno == ERANGE) {
		*err = -ERANGE;
40009c50:	00f92023          	sw	a5,0(s2)
		return 0;
40009c54:	00000493          	li	s1,0
		*err = -EINVAL;
		return 0;
	}

	return val;
}
40009c58:	01c12083          	lw	ra,28(sp)
40009c5c:	01812403          	lw	s0,24(sp)
40009c60:	01012903          	lw	s2,16(sp)
40009c64:	00048513          	mv	a0,s1
40009c68:	01412483          	lw	s1,20(sp)
40009c6c:	02010113          	addi	sp,sp,32
40009c70:	00008067          	ret
40009c74:	00050413          	mv	s0,a0
40009c78:	00058493          	mv	s1,a1
40009c7c:	718240ef          	jal	ra,4002e394 <z_impl_z_errno>
	val = strtoul(str, &endptr, base);
40009c80:	00048613          	mv	a2,s1
	errno = 0;
40009c84:	00052023          	sw	zero,0(a0)
	val = strtoul(str, &endptr, base);
40009c88:	00c10593          	addi	a1,sp,12
40009c8c:	00040513          	mv	a0,s0
40009c90:	489020ef          	jal	ra,4000c918 <strtoul>
40009c94:	00050493          	mv	s1,a0
40009c98:	6fc240ef          	jal	ra,4002e394 <z_impl_z_errno>
	if (errno == ERANGE) {
40009c9c:	00052703          	lw	a4,0(a0)
40009ca0:	02200793          	li	a5,34
40009ca4:	00f71663          	bne	a4,a5,40009cb0 <shell_strtoul+0x8c>
40009ca8:	fde00793          	li	a5,-34
40009cac:	fa5ff06f          	j	40009c50 <shell_strtoul+0x2c>
40009cb0:	6e4240ef          	jal	ra,4002e394 <z_impl_z_errno>
	} else if (errno || endptr == str || *endptr) {
40009cb4:	00052783          	lw	a5,0(a0)
40009cb8:	f8079ae3          	bnez	a5,40009c4c <shell_strtoul+0x28>
40009cbc:	00c12783          	lw	a5,12(sp)
40009cc0:	f88786e3          	beq	a5,s0,40009c4c <shell_strtoul+0x28>
40009cc4:	0007c783          	lbu	a5,0(a5)
40009cc8:	f80788e3          	beqz	a5,40009c58 <shell_strtoul+0x34>
40009ccc:	f81ff06f          	j	40009c4c <shell_strtoul+0x28>

40009cd0 <z_shell_raw_fprintf>:
{
40009cd0:	fc010113          	addi	sp,sp,-64
40009cd4:	02c12423          	sw	a2,40(sp)
	va_start(args, fmt);
40009cd8:	02810613          	addi	a2,sp,40
{
40009cdc:	00112e23          	sw	ra,28(sp)
40009ce0:	02d12623          	sw	a3,44(sp)
40009ce4:	02e12823          	sw	a4,48(sp)
40009ce8:	02f12a23          	sw	a5,52(sp)
40009cec:	03012c23          	sw	a6,56(sp)
40009cf0:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
40009cf4:	00c12623          	sw	a2,12(sp)
	z_shell_fprintf_fmt(ctx, fmt, args);
40009cf8:	d88ff0ef          	jal	ra,40009280 <z_shell_fprintf_fmt>
}
40009cfc:	01c12083          	lw	ra,28(sp)
40009d00:	04010113          	addi	sp,sp,64
40009d04:	00008067          	ret

40009d08 <z_clear_eos>:
	return sh->ctx->cfg.flags.use_vt100 == 1;
40009d08:	00852783          	lw	a5,8(a0)
40009d0c:	26c7a783          	lw	a5,620(a5)
40009d10:	0057d793          	srli	a5,a5,0x5
40009d14:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
40009d18:	00078a63          	beqz	a5,40009d2c <z_clear_eos+0x24>
40009d1c:	01452503          	lw	a0,20(a0)
40009d20:	400325b7          	lui	a1,0x40032
40009d24:	6b858593          	addi	a1,a1,1720 # 400326b8 <eth_config+0x1c>
40009d28:	fa9ff06f          	j	40009cd0 <z_shell_raw_fprintf>
}
40009d2c:	00008067          	ret

40009d30 <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
40009d30:	400335b7          	lui	a1,0x40033
40009d34:	bf458593          	addi	a1,a1,-1036 # 40032bf4 <severity+0x88>
40009d38:	f99ff06f          	j	40009cd0 <z_shell_raw_fprintf>

40009d3c <full_line_cmd>:

/* Function returns true if command length is equal to multiplicity of terminal
 * width.
 */
static inline bool full_line_cmd(const struct shell *sh)
{
40009d3c:	ff010113          	addi	sp,sp,-16
40009d40:	00812423          	sw	s0,8(sp)
40009d44:	00112623          	sw	ra,12(sp)
40009d48:	00912223          	sw	s1,4(sp)
	return ((sh->ctx->cmd_buff_len + z_shell_strlen(sh->ctx->prompt))
40009d4c:	00852783          	lw	a5,8(a0)
{
40009d50:	00050413          	mv	s0,a0
	return ((sh->ctx->cmd_buff_len + z_shell_strlen(sh->ctx->prompt))
40009d54:	0007a503          	lw	a0,0(a5)
40009d58:	0487d483          	lhu	s1,72(a5)
	return str == NULL ? 0U : (uint16_t)strlen(str);
40009d5c:	00000793          	li	a5,0
40009d60:	00050863          	beqz	a0,40009d70 <full_line_cmd+0x34>
40009d64:	671020ef          	jal	ra,4000cbd4 <strlen>
40009d68:	01051793          	slli	a5,a0,0x10
40009d6c:	0107d793          	srli	a5,a5,0x10
			% sh->ctx->vt100_ctx.cons.terminal_wid == 0U);
40009d70:	00842703          	lw	a4,8(s0)
	return ((sh->ctx->cmd_buff_len + z_shell_strlen(sh->ctx->prompt))
40009d74:	009787b3          	add	a5,a5,s1
}
40009d78:	00c12083          	lw	ra,12(sp)
			% sh->ctx->vt100_ctx.cons.terminal_wid == 0U);
40009d7c:	02e75703          	lhu	a4,46(a4)
}
40009d80:	00812403          	lw	s0,8(sp)
40009d84:	00412483          	lw	s1,4(sp)
			% sh->ctx->vt100_ctx.cons.terminal_wid == 0U);
40009d88:	02e7e533          	rem	a0,a5,a4
}
40009d8c:	01010113          	addi	sp,sp,16
40009d90:	00153513          	seqz	a0,a0
40009d94:	00008067          	ret

40009d98 <z_shell_op_cursor_vert_move>:
	char dir = delta > 0 ? 'A' : 'B';
40009d98:	04100693          	li	a3,65
40009d9c:	00b04663          	bgtz	a1,40009da8 <z_shell_op_cursor_vert_move+0x10>
	if (delta == 0) {
40009da0:	02058c63          	beqz	a1,40009dd8 <z_shell_op_cursor_vert_move+0x40>
	char dir = delta > 0 ? 'A' : 'B';
40009da4:	04200693          	li	a3,66
	return sh->ctx->cfg.flags.use_vt100 == 1;
40009da8:	00852783          	lw	a5,8(a0)
40009dac:	26c7a783          	lw	a5,620(a5)
40009db0:	0057d793          	srli	a5,a5,0x5
40009db4:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, "\e[%d%c", delta, dir);
40009db8:	02078063          	beqz	a5,40009dd8 <z_shell_op_cursor_vert_move+0x40>
	if (delta < 0) {
40009dbc:	41f5d613          	srai	a2,a1,0x1f
40009dc0:	00b645b3          	xor	a1,a2,a1
	Z_SHELL_VT100_CMD(sh, "\e[%d%c", delta, dir);
40009dc4:	01452503          	lw	a0,20(a0)
40009dc8:	40c58633          	sub	a2,a1,a2
40009dcc:	400345b7          	lui	a1,0x40034
40009dd0:	e3058593          	addi	a1,a1,-464 # 40033e30 <_shell_help+0x14>
40009dd4:	efdff06f          	j	40009cd0 <z_shell_raw_fprintf>
}
40009dd8:	00008067          	ret

40009ddc <z_shell_op_cursor_horiz_move>:
	char dir = delta > 0 ? 'C' : 'D';
40009ddc:	04300693          	li	a3,67
40009de0:	00b04663          	bgtz	a1,40009dec <z_shell_op_cursor_horiz_move+0x10>
	if (delta == 0) {
40009de4:	02058c63          	beqz	a1,40009e1c <z_shell_op_cursor_horiz_move+0x40>
	char dir = delta > 0 ? 'C' : 'D';
40009de8:	04400693          	li	a3,68
40009dec:	00852783          	lw	a5,8(a0)
40009df0:	26c7a783          	lw	a5,620(a5)
40009df4:	0057d793          	srli	a5,a5,0x5
40009df8:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, "\e[%d%c", delta, dir);
40009dfc:	02078063          	beqz	a5,40009e1c <z_shell_op_cursor_horiz_move+0x40>
	if (delta < 0) {
40009e00:	41f5d613          	srai	a2,a1,0x1f
40009e04:	00b645b3          	xor	a1,a2,a1
	Z_SHELL_VT100_CMD(sh, "\e[%d%c", delta, dir);
40009e08:	01452503          	lw	a0,20(a0)
40009e0c:	40c58633          	sub	a2,a1,a2
40009e10:	400345b7          	lui	a1,0x40034
40009e14:	e3058593          	addi	a1,a1,-464 # 40033e30 <_shell_help+0x14>
40009e18:	eb9ff06f          	j	40009cd0 <z_shell_raw_fprintf>
}
40009e1c:	00008067          	ret

40009e20 <z_shell_cursor_in_empty_line>:

/* Function returns true if cursor is at beginning of an empty line. */
bool z_shell_cursor_in_empty_line(const struct shell *sh)
{
40009e20:	ff010113          	addi	sp,sp,-16
40009e24:	00812423          	sw	s0,8(sp)
40009e28:	00112623          	sw	ra,12(sp)
40009e2c:	00912223          	sw	s1,4(sp)
	return (((sh->ctx->cmd_buff_pos * sh->ctx->cfg.flags.echo) +
40009e30:	00852703          	lw	a4,8(a0)
{
40009e34:	00050413          	mv	s0,a0
	return (((sh->ctx->cmd_buff_pos * sh->ctx->cfg.flags.echo) +
40009e38:	26c72783          	lw	a5,620(a4)
40009e3c:	04a75483          	lhu	s1,74(a4)
		 z_shell_strlen(sh->ctx->prompt)) %
40009e40:	00072503          	lw	a0,0(a4)
	return (((sh->ctx->cmd_buff_pos * sh->ctx->cfg.flags.echo) +
40009e44:	0017d793          	srli	a5,a5,0x1
40009e48:	0017f793          	andi	a5,a5,1
40009e4c:	02f484b3          	mul	s1,s1,a5
40009e50:	00000793          	li	a5,0
40009e54:	00050863          	beqz	a0,40009e64 <z_shell_cursor_in_empty_line+0x44>
40009e58:	57d020ef          	jal	ra,4000cbd4 <strlen>
40009e5c:	01051793          	slli	a5,a0,0x10
40009e60:	0107d793          	srli	a5,a5,0x10
			sh->ctx->vt100_ctx.cons.terminal_wid ==
40009e64:	00842703          	lw	a4,8(s0)
	return (((sh->ctx->cmd_buff_pos * sh->ctx->cfg.flags.echo) +
40009e68:	009787b3          	add	a5,a5,s1
		0U);
}
40009e6c:	00c12083          	lw	ra,12(sp)
			sh->ctx->vt100_ctx.cons.terminal_wid ==
40009e70:	02e75703          	lhu	a4,46(a4)
}
40009e74:	00812403          	lw	s0,8(sp)
40009e78:	00412483          	lw	s1,4(sp)
		 z_shell_strlen(sh->ctx->prompt)) %
40009e7c:	02e7e533          	rem	a0,a5,a4
}
40009e80:	01010113          	addi	sp,sp,16
40009e84:	00153513          	seqz	a0,a0
40009e88:	00008067          	ret

40009e8c <z_shell_op_cond_next_line>:

void z_shell_op_cond_next_line(const struct shell *sh)
{
40009e8c:	ff010113          	addi	sp,sp,-16
40009e90:	00812423          	sw	s0,8(sp)
40009e94:	00112623          	sw	ra,12(sp)
40009e98:	00050413          	mv	s0,a0
	if (z_shell_cursor_in_empty_line(sh) || full_line_cmd(sh)) {
40009e9c:	f85ff0ef          	jal	ra,40009e20 <z_shell_cursor_in_empty_line>
40009ea0:	00050c63          	beqz	a0,40009eb8 <z_shell_op_cond_next_line+0x2c>
		z_cursor_next_line_move(sh);
40009ea4:	01442503          	lw	a0,20(s0)
	}
}
40009ea8:	00812403          	lw	s0,8(sp)
40009eac:	00c12083          	lw	ra,12(sp)
40009eb0:	01010113          	addi	sp,sp,16
		z_cursor_next_line_move(sh);
40009eb4:	e7dff06f          	j	40009d30 <z_cursor_next_line_move.isra.0>
	if (z_shell_cursor_in_empty_line(sh) || full_line_cmd(sh)) {
40009eb8:	00040513          	mv	a0,s0
40009ebc:	e81ff0ef          	jal	ra,40009d3c <full_line_cmd>
40009ec0:	fe0512e3          	bnez	a0,40009ea4 <z_shell_op_cond_next_line+0x18>
}
40009ec4:	00c12083          	lw	ra,12(sp)
40009ec8:	00812403          	lw	s0,8(sp)
40009ecc:	01010113          	addi	sp,sp,16
40009ed0:	00008067          	ret

40009ed4 <z_shell_op_cursor_position_synchronize>:

void z_shell_op_cursor_position_synchronize(const struct shell *sh)
{
40009ed4:	fe010113          	addi	sp,sp,-32
40009ed8:	00912a23          	sw	s1,20(sp)
40009edc:	01212823          	sw	s2,16(sp)
40009ee0:	01312623          	sw	s3,12(sp)
40009ee4:	00112e23          	sw	ra,28(sp)
40009ee8:	00812c23          	sw	s0,24(sp)
	struct shell_multiline_cons *cons = &sh->ctx->vt100_ctx.cons;
40009eec:	00852403          	lw	s0,8(a0)
{
40009ef0:	00050493          	mv	s1,a0
	bool last_line;

	z_shell_multiline_data_calc(cons, sh->ctx->cmd_buff_pos,
40009ef4:	04845603          	lhu	a2,72(s0)
40009ef8:	04a45583          	lhu	a1,74(s0)
40009efc:	02440513          	addi	a0,s0,36
40009f00:	cf0ff0ef          	jal	ra,400093f0 <z_shell_multiline_data_calc>
	last_line = (cons->cur_y == cons->cur_y_end);

	/* In case cursor reaches the bottom line of a terminal, it will
	 * be moved to the next line.
	 */
	if (full_line_cmd(sh)) {
40009f04:	00048513          	mv	a0,s1
	last_line = (cons->cur_y == cons->cur_y_end);
40009f08:	02845983          	lhu	s3,40(s0)
40009f0c:	02a45903          	lhu	s2,42(s0)
	if (full_line_cmd(sh)) {
40009f10:	e2dff0ef          	jal	ra,40009d3c <full_line_cmd>
40009f14:	00050663          	beqz	a0,40009f20 <z_shell_op_cursor_position_synchronize+0x4c>
		z_cursor_next_line_move(sh);
40009f18:	0144a503          	lw	a0,20(s1)
40009f1c:	e15ff0ef          	jal	ra,40009d30 <z_cursor_next_line_move.isra.0>
	}

	if (last_line) {
40009f20:	03299863          	bne	s3,s2,40009f50 <z_shell_op_cursor_position_synchronize+0x7c>
		z_shell_op_cursor_horiz_move(sh, cons->cur_x -
							       cons->cur_x_end);
	} else {
		z_shell_op_cursor_vert_move(sh, cons->cur_y_end - cons->cur_y);
		z_shell_op_cursor_horiz_move(sh, cons->cur_x -
40009f24:	02445583          	lhu	a1,36(s0)
							       cons->cur_x_end);
40009f28:	02645783          	lhu	a5,38(s0)
	}
}
40009f2c:	01812403          	lw	s0,24(sp)
40009f30:	01c12083          	lw	ra,28(sp)
40009f34:	01012903          	lw	s2,16(sp)
40009f38:	00c12983          	lw	s3,12(sp)
		z_shell_op_cursor_horiz_move(sh, cons->cur_x -
40009f3c:	00048513          	mv	a0,s1
}
40009f40:	01412483          	lw	s1,20(sp)
		z_shell_op_cursor_horiz_move(sh, cons->cur_x -
40009f44:	40f585b3          	sub	a1,a1,a5
}
40009f48:	02010113          	addi	sp,sp,32
		z_shell_op_cursor_horiz_move(sh, cons->cur_x -
40009f4c:	e91ff06f          	j	40009ddc <z_shell_op_cursor_horiz_move>
		z_shell_op_cursor_vert_move(sh, cons->cur_y_end - cons->cur_y);
40009f50:	02a45583          	lhu	a1,42(s0)
40009f54:	02845783          	lhu	a5,40(s0)
40009f58:	00048513          	mv	a0,s1
40009f5c:	40f585b3          	sub	a1,a1,a5
40009f60:	e39ff0ef          	jal	ra,40009d98 <z_shell_op_cursor_vert_move>
40009f64:	fc1ff06f          	j	40009f24 <z_shell_op_cursor_position_synchronize+0x50>

40009f68 <z_shell_op_cursor_move>:

void z_shell_op_cursor_move(const struct shell *sh, int16_t val)
{
40009f68:	fe010113          	addi	sp,sp,-32
40009f6c:	00112e23          	sw	ra,28(sp)
40009f70:	00812c23          	sw	s0,24(sp)
40009f74:	00912a23          	sw	s1,20(sp)
40009f78:	01212823          	sw	s2,16(sp)
40009f7c:	01312623          	sw	s3,12(sp)
40009f80:	00050413          	mv	s0,a0
	struct shell_multiline_cons *cons = &sh->ctx->vt100_ctx.cons;
40009f84:	00852503          	lw	a0,8(a0)
{
40009f88:	00058493          	mv	s1,a1
	uint16_t new_pos = sh->ctx->cmd_buff_pos + val;
	int32_t row_span;
	int32_t col_span;

	z_shell_multiline_data_calc(cons, sh->ctx->cmd_buff_pos,
40009f8c:	04855603          	lhu	a2,72(a0)
	uint16_t new_pos = sh->ctx->cmd_buff_pos + val;
40009f90:	04a55583          	lhu	a1,74(a0)
	z_shell_multiline_data_calc(cons, sh->ctx->cmd_buff_pos,
40009f94:	02450513          	addi	a0,a0,36
	uint16_t new_pos = sh->ctx->cmd_buff_pos + val;
40009f98:	009584b3          	add	s1,a1,s1
	z_shell_multiline_data_calc(cons, sh->ctx->cmd_buff_pos,
40009f9c:	c54ff0ef          	jal	ra,400093f0 <z_shell_multiline_data_calc>
				    sh->ctx->cmd_buff_len);

	/* Calculate the new cursor. */
	row_span = z_row_span_with_buffer_offsets_get(
						&sh->ctx->vt100_ctx.cons,
40009fa0:	00842503          	lw	a0,8(s0)
	uint16_t new_pos = sh->ctx->cmd_buff_pos + val;
40009fa4:	01049493          	slli	s1,s1,0x10
40009fa8:	0104d493          	srli	s1,s1,0x10
	row_span = z_row_span_with_buffer_offsets_get(
40009fac:	04a55583          	lhu	a1,74(a0)
40009fb0:	00048613          	mv	a2,s1
40009fb4:	02450513          	addi	a0,a0,36
40009fb8:	c18ff0ef          	jal	ra,400093d0 <z_row_span_with_buffer_offsets_get>
40009fbc:	00050993          	mv	s3,a0
						sh->ctx->cmd_buff_pos,
						new_pos);
	col_span = z_column_span_with_buffer_offsets_get(
						&sh->ctx->vt100_ctx.cons,
40009fc0:	00842503          	lw	a0,8(s0)
	col_span = z_column_span_with_buffer_offsets_get(
40009fc4:	00048613          	mv	a2,s1
40009fc8:	04a55583          	lhu	a1,74(a0)
40009fcc:	02450513          	addi	a0,a0,36
40009fd0:	be0ff0ef          	jal	ra,400093b0 <z_column_span_with_buffer_offsets_get>
40009fd4:	00050913          	mv	s2,a0
						sh->ctx->cmd_buff_pos,
						new_pos);

	z_shell_op_cursor_vert_move(sh, -row_span);
40009fd8:	413005b3          	neg	a1,s3
40009fdc:	00040513          	mv	a0,s0
40009fe0:	db9ff0ef          	jal	ra,40009d98 <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(sh, col_span);
40009fe4:	00090593          	mv	a1,s2
40009fe8:	00040513          	mv	a0,s0
40009fec:	df1ff0ef          	jal	ra,40009ddc <z_shell_op_cursor_horiz_move>
	sh->ctx->cmd_buff_pos = new_pos;
40009ff0:	00842783          	lw	a5,8(s0)
40009ff4:	04979523          	sh	s1,74(a5)
}
40009ff8:	01c12083          	lw	ra,28(sp)
40009ffc:	01812403          	lw	s0,24(sp)
4000a000:	01412483          	lw	s1,20(sp)
4000a004:	01012903          	lw	s2,16(sp)
4000a008:	00c12983          	lw	s3,12(sp)
4000a00c:	02010113          	addi	sp,sp,32
4000a010:	00008067          	ret

4000a014 <z_shell_op_cursor_word_move>:

	return ret;
}

void z_shell_op_cursor_word_move(const struct shell *sh, int16_t val)
{
4000a014:	fe010113          	addi	sp,sp,-32
4000a018:	00912a23          	sw	s1,20(sp)
4000a01c:	01212823          	sw	s2,16(sp)
4000a020:	00112e23          	sw	ra,28(sp)
4000a024:	00812c23          	sw	s0,24(sp)
4000a028:	01312623          	sw	s3,12(sp)
4000a02c:	01412423          	sw	s4,8(sp)
4000a030:	01512223          	sw	s5,4(sp)
4000a034:	01612023          	sw	s6,0(sp)
4000a038:	00050913          	mv	s2,a0
4000a03c:	00100493          	li	s1,1
	int16_t shift;
	int16_t sign;

	if (val < 0) {
4000a040:	0005da63          	bgez	a1,4000a054 <z_shell_op_cursor_word_move+0x40>
		val = -val;
4000a044:	40b005b3          	neg	a1,a1
4000a048:	01059593          	slli	a1,a1,0x10
4000a04c:	4105d593          	srai	a1,a1,0x10
		sign = -1;
4000a050:	fff00493          	li	s1,-1
4000a054:	01059413          	slli	s0,a1,0x10
4000a058:	01049993          	slli	s3,s1,0x10
4000a05c:	01045413          	srli	s0,s0,0x10
4000a060:	0109d993          	srli	s3,s3,0x10
		    ((idx == len) && (sign > 0))) {
4000a064:	00100a13          	li	s4,1
				(int)'z') ? (chr - 32) : (chr));
}

static inline int isalnum(int chr)
{
	return (int)(isalpha(chr) || isdigit(chr));
4000a068:	01900a93          	li	s5,25
4000a06c:	00900b13          	li	s6,9
4000a070:	04c0006f          	j	4000a0bc <z_shell_op_cursor_word_move+0xa8>
	} else {
		sign = 1;
	}

	while (val--) {
		shift = shift_calc(sh->ctx->cmd_buff,
4000a074:	00892783          	lw	a5,8(s2)
	bool found = false;
4000a078:	00000713          	li	a4,0
		if (((idx == 0U) && (sign < 0)) ||
4000a07c:	fff00893          	li	a7,-1
		shift = shift_calc(sh->ctx->cmd_buff,
4000a080:	04a7d603          	lhu	a2,74(a5)
4000a084:	0487d503          	lhu	a0,72(a5)
4000a088:	04e78813          	addi	a6,a5,78
4000a08c:	00060593          	mv	a1,a2
		if (((idx == 0U) && (sign < 0)) ||
4000a090:	04059c63          	bnez	a1,4000a0e8 <z_shell_op_cursor_word_move+0xd4>
4000a094:	01148463          	beq	s1,a7,4000a09c <z_shell_op_cursor_word_move+0x88>
4000a098:	04051c63          	bnez	a0,4000a0f0 <z_shell_op_cursor_word_move+0xdc>
		idx = pos + ret * sign;
4000a09c:	40c585b3          	sub	a1,a1,a2
				   sh->ctx->cmd_buff_pos,
				   sh->ctx->cmd_buff_len, sign);
		z_shell_op_cursor_move(sh, sign * shift);
4000a0a0:	01059593          	slli	a1,a1,0x10
4000a0a4:	4105d593          	srai	a1,a1,0x10
4000a0a8:	00090513          	mv	a0,s2
4000a0ac:	ebdff0ef          	jal	ra,40009f68 <z_shell_op_cursor_move>
4000a0b0:	fff40593          	addi	a1,s0,-1
4000a0b4:	01059413          	slli	s0,a1,0x10
4000a0b8:	01045413          	srli	s0,s0,0x10
	while (val--) {
4000a0bc:	fa041ce3          	bnez	s0,4000a074 <z_shell_op_cursor_word_move+0x60>
	}
}
4000a0c0:	01c12083          	lw	ra,28(sp)
4000a0c4:	01812403          	lw	s0,24(sp)
4000a0c8:	01412483          	lw	s1,20(sp)
4000a0cc:	01012903          	lw	s2,16(sp)
4000a0d0:	00c12983          	lw	s3,12(sp)
4000a0d4:	00812a03          	lw	s4,8(sp)
4000a0d8:	00412a83          	lw	s5,4(sp)
4000a0dc:	00012b03          	lw	s6,0(sp)
4000a0e0:	02010113          	addi	sp,sp,32
4000a0e4:	00008067          	ret
		if (((idx == 0U) && (sign < 0)) ||
4000a0e8:	00b51463          	bne	a0,a1,4000a0f0 <z_shell_op_cursor_word_move+0xdc>
		    ((idx == len) && (sign > 0))) {
4000a0ec:	fb4488e3          	beq	s1,s4,4000a09c <z_shell_op_cursor_word_move+0x88>
		if (isalnum((int)str[idx]) != 0) {
4000a0f0:	00b807b3          	add	a5,a6,a1
4000a0f4:	0007c783          	lbu	a5,0(a5)
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
4000a0f8:	0207e693          	ori	a3,a5,32
4000a0fc:	f9f68693          	addi	a3,a3,-97
	return (int)(isalpha(chr) || isdigit(chr));
4000a100:	02daf063          	bgeu	s5,a3,4000a120 <z_shell_op_cursor_word_move+0x10c>
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
4000a104:	fd078793          	addi	a5,a5,-48
	return (int)(isalpha(chr) || isdigit(chr));
4000a108:	00fb7c63          	bgeu	s6,a5,4000a120 <z_shell_op_cursor_word_move+0x10c>
			if (found) {
4000a10c:	f80718e3          	bnez	a4,4000a09c <z_shell_op_cursor_word_move+0x88>
	while (1) {
4000a110:	00b985b3          	add	a1,s3,a1
4000a114:	01059593          	slli	a1,a1,0x10
4000a118:	0105d593          	srli	a1,a1,0x10
		idx = pos + ret * sign;
4000a11c:	f75ff06f          	j	4000a090 <z_shell_op_cursor_word_move+0x7c>
			found = true;
4000a120:	00100713          	li	a4,1
4000a124:	fedff06f          	j	4000a110 <z_shell_op_cursor_word_move+0xfc>

4000a128 <z_shell_op_cursor_home_move>:
	z_cursor_restore(sh);
}

void z_shell_op_cursor_home_move(const struct shell *sh)
{
	z_shell_op_cursor_move(sh, -sh->ctx->cmd_buff_pos);
4000a128:	00852783          	lw	a5,8(a0)
4000a12c:	04a7d583          	lhu	a1,74(a5)
4000a130:	40b005b3          	neg	a1,a1
4000a134:	01059593          	slli	a1,a1,0x10
4000a138:	4105d593          	srai	a1,a1,0x10
4000a13c:	e2dff06f          	j	40009f68 <z_shell_op_cursor_move>

4000a140 <z_shell_op_cursor_end_move>:
}

void z_shell_op_cursor_end_move(const struct shell *sh)
{
	z_shell_op_cursor_move(sh, sh->ctx->cmd_buff_len -
4000a140:	00852783          	lw	a5,8(a0)
4000a144:	0487d583          	lhu	a1,72(a5)
4000a148:	04a7d783          	lhu	a5,74(a5)
4000a14c:	40f585b3          	sub	a1,a1,a5
4000a150:	01059593          	slli	a1,a1,0x10
4000a154:	4105d593          	srai	a1,a1,0x10
4000a158:	e11ff06f          	j	40009f68 <z_shell_op_cursor_move>

4000a15c <z_shell_op_left_arrow>:
						sh->ctx->cmd_buff_pos);
}

void z_shell_op_left_arrow(const struct shell *sh)
{
	if (sh->ctx->cmd_buff_pos > 0) {
4000a15c:	00852783          	lw	a5,8(a0)
4000a160:	04a7d783          	lhu	a5,74(a5)
4000a164:	00078663          	beqz	a5,4000a170 <z_shell_op_left_arrow+0x14>
		z_shell_op_cursor_move(sh, -1);
4000a168:	fff00593          	li	a1,-1
4000a16c:	dfdff06f          	j	40009f68 <z_shell_op_cursor_move>
	}
}
4000a170:	00008067          	ret

4000a174 <z_shell_op_right_arrow>:

void z_shell_op_right_arrow(const struct shell *sh)
{
	if (sh->ctx->cmd_buff_pos < sh->ctx->cmd_buff_len) {
4000a174:	00852783          	lw	a5,8(a0)
4000a178:	04a7d703          	lhu	a4,74(a5)
4000a17c:	0487d783          	lhu	a5,72(a5)
4000a180:	00f77663          	bgeu	a4,a5,4000a18c <z_shell_op_right_arrow+0x18>
		z_shell_op_cursor_move(sh, 1);
4000a184:	00100593          	li	a1,1
4000a188:	de1ff06f          	j	40009f68 <z_shell_op_cursor_move>
	}
}
4000a18c:	00008067          	ret

4000a190 <z_shell_op_delete_from_cursor>:
	reprint_from_cursor(sh, --diff, true);
}

void z_shell_op_delete_from_cursor(const struct shell *sh)
{
	sh->ctx->cmd_buff_len = sh->ctx->cmd_buff_pos;
4000a190:	00852703          	lw	a4,8(a0)
4000a194:	04a75683          	lhu	a3,74(a4)
4000a198:	04d71423          	sh	a3,72(a4)
	sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos] = '\0';
4000a19c:	00852783          	lw	a5,8(a0)
4000a1a0:	04a7d703          	lhu	a4,74(a5)
4000a1a4:	00e787b3          	add	a5,a5,a4
4000a1a8:	04078723          	sb	zero,78(a5)

	z_clear_eos(sh);
4000a1ac:	b5dff06f          	j	40009d08 <z_clear_eos>

4000a1b0 <z_shell_cmd_line_erase>:
{
	data_insert(sh, compl, compl_len);
}

void z_shell_cmd_line_erase(const struct shell *sh)
{
4000a1b0:	ff010113          	addi	sp,sp,-16
4000a1b4:	00112623          	sw	ra,12(sp)
4000a1b8:	00812423          	sw	s0,8(sp)
4000a1bc:	00050413          	mv	s0,a0
	z_shell_multiline_data_calc(&sh->ctx->vt100_ctx.cons,
4000a1c0:	00852503          	lw	a0,8(a0)
4000a1c4:	04855603          	lhu	a2,72(a0)
4000a1c8:	04a55583          	lhu	a1,74(a0)
4000a1cc:	02450513          	addi	a0,a0,36
4000a1d0:	a20ff0ef          	jal	ra,400093f0 <z_shell_multiline_data_calc>
				    sh->ctx->cmd_buff_pos,
				    sh->ctx->cmd_buff_len);
	z_shell_op_cursor_horiz_move(sh,
				   -(sh->ctx->vt100_ctx.cons.cur_x - 1));
4000a1d4:	00842783          	lw	a5,8(s0)
	z_shell_op_cursor_horiz_move(sh,
4000a1d8:	00100593          	li	a1,1
4000a1dc:	00040513          	mv	a0,s0
				   -(sh->ctx->vt100_ctx.cons.cur_x - 1));
4000a1e0:	0247d783          	lhu	a5,36(a5)
	z_shell_op_cursor_horiz_move(sh,
4000a1e4:	40f585b3          	sub	a1,a1,a5
4000a1e8:	bf5ff0ef          	jal	ra,40009ddc <z_shell_op_cursor_horiz_move>
	z_shell_op_cursor_vert_move(sh, sh->ctx->vt100_ctx.cons.cur_y - 1);
4000a1ec:	00842783          	lw	a5,8(s0)
4000a1f0:	00040513          	mv	a0,s0
4000a1f4:	0287d583          	lhu	a1,40(a5)
4000a1f8:	fff58593          	addi	a1,a1,-1
4000a1fc:	b9dff0ef          	jal	ra,40009d98 <z_shell_op_cursor_vert_move>

	z_clear_eos(sh);
4000a200:	00040513          	mv	a0,s0
}
4000a204:	00812403          	lw	s0,8(sp)
4000a208:	00c12083          	lw	ra,12(sp)
4000a20c:	01010113          	addi	sp,sp,16
	z_clear_eos(sh);
4000a210:	af9ff06f          	j	40009d08 <z_clear_eos>

4000a214 <z_shell_print_cmd>:
	z_shell_fprintf(sh, SHELL_INFO, "%s", sh->ctx->prompt);
}

void z_shell_print_cmd(const struct shell *sh)
{
	z_shell_raw_fprintf(sh->fprintf_ctx, "%s", sh->ctx->cmd_buff);
4000a214:	00852603          	lw	a2,8(a0)
4000a218:	01452503          	lw	a0,20(a0)
4000a21c:	400335b7          	lui	a1,0x40033
4000a220:	04e60613          	addi	a2,a2,78
4000a224:	af858593          	addi	a1,a1,-1288 # 40032af8 <mpsc_config+0x9c>
4000a228:	aa9ff06f          	j	40009cd0 <z_shell_raw_fprintf>

4000a22c <z_shell_write>:
	}
}

void z_shell_write(const struct shell *sh, const void *data,
		 size_t length)
{
4000a22c:	fc010113          	addi	sp,sp,-64
4000a230:	02812c23          	sw	s0,56(sp)
4000a234:	02912a23          	sw	s1,52(sp)
4000a238:	03212823          	sw	s2,48(sp)
4000a23c:	03312623          	sw	s3,44(sp)
4000a240:	03412423          	sw	s4,40(sp)
4000a244:	03512223          	sw	s5,36(sp)
4000a248:	02112e23          	sw	ra,60(sp)
4000a24c:	00050493          	mv	s1,a0
4000a250:	00058993          	mv	s3,a1
4000a254:	00060413          	mv	s0,a2
	__ASSERT_NO_MSG(sh && data);

	size_t offset = 0;
4000a258:	00000913          	li	s2,0
		(void)err;
		__ASSERT_NO_MSG(err == 0);
		__ASSERT_NO_MSG(length >= tmp_cnt);
		offset += tmp_cnt;
		length -= tmp_cnt;
		if (tmp_cnt == 0 &&
4000a25c:	00300a13          	li	s4,3
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
4000a260:	00200a93          	li	s5,2
	while (length) {
4000a264:	04041263          	bnez	s0,4000a2a8 <z_shell_write+0x7c>
		    (sh->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
			shell_pend_on_txdone(sh);
		}
	}
}
4000a268:	03c12083          	lw	ra,60(sp)
4000a26c:	03812403          	lw	s0,56(sp)
4000a270:	03412483          	lw	s1,52(sp)
4000a274:	03012903          	lw	s2,48(sp)
4000a278:	02c12983          	lw	s3,44(sp)
4000a27c:	02812a03          	lw	s4,40(sp)
4000a280:	02412a83          	lw	s5,36(sp)
4000a284:	04010113          	addi	sp,sp,64
4000a288:	00008067          	ret
	return sh->ctx->ctx.flags.tx_rdy == 1;
4000a28c:	2706a783          	lw	a5,624(a3)
4000a290:	0017d793          	srli	a5,a5,0x1
4000a294:	0017f793          	andi	a5,a5,1
		while (!z_flag_tx_rdy_get(sh)) {
4000a298:	fe078ae3          	beqz	a5,4000a28c <z_shell_write+0x60>
4000a29c:	ffd00593          	li	a1,-3
4000a2a0:	27068513          	addi	a0,a3,624
4000a2a4:	029270ef          	jal	ra,40031acc <z_impl_atomic_and>
		int err = sh->iface->api->write(sh->iface,
4000a2a8:	0044a503          	lw	a0,4(s1)
4000a2ac:	00040613          	mv	a2,s0
4000a2b0:	012985b3          	add	a1,s3,s2
4000a2b4:	00052783          	lw	a5,0(a0)
4000a2b8:	00810693          	addi	a3,sp,8
4000a2bc:	00c7a783          	lw	a5,12(a5)
4000a2c0:	000780e7          	jalr	a5
		offset += tmp_cnt;
4000a2c4:	00812783          	lw	a5,8(sp)
4000a2c8:	00f90933          	add	s2,s2,a5
		length -= tmp_cnt;
4000a2cc:	40f40433          	sub	s0,s0,a5
		if (tmp_cnt == 0 &&
4000a2d0:	f8079ae3          	bnez	a5,4000a264 <z_shell_write+0x38>
		    (sh->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
4000a2d4:	0084a683          	lw	a3,8(s1)
4000a2d8:	0046a783          	lw	a5,4(a3)
		if (tmp_cnt == 0 &&
4000a2dc:	fd4786e3          	beq	a5,s4,4000a2a8 <z_shell_write+0x7c>
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
4000a2e0:	fafae6e3          	bltu	s5,a5,4000a28c <z_shell_write+0x60>
		k_poll_event_init(&event,
4000a2e4:	2a468693          	addi	a3,a3,676
4000a2e8:	00000613          	li	a2,0
4000a2ec:	00100593          	li	a1,1
4000a2f0:	00c10513          	addi	a0,sp,12
4000a2f4:	441270ef          	jal	ra,40031f34 <k_poll_event_init>
4000a2f8:	fff00613          	li	a2,-1
4000a2fc:	fff00693          	li	a3,-1
4000a300:	00100593          	li	a1,1
4000a304:	00c10513          	addi	a0,sp,12
4000a308:	465270ef          	jal	ra,40031f6c <z_impl_k_poll>
		k_poll_signal_reset(&sh->ctx->signals[SHELL_SIGNAL_TXDONE]);
4000a30c:	0084a503          	lw	a0,8(s1)
4000a310:	2a450513          	addi	a0,a0,676
	z_impl_k_poll_signal_reset(sig);
4000a314:	595270ef          	jal	ra,400320a8 <z_impl_k_poll_signal_reset>
	while (length) {
4000a318:	f91ff06f          	j	4000a2a8 <z_shell_write+0x7c>

4000a31c <z_shell_print_stream>:

/* Function shall be only used by the fprintf module. */
void z_shell_print_stream(const void *user_ctx, const char *data, size_t len)
{
	z_shell_write((const struct shell *) user_ctx, data, len);
4000a31c:	f11ff06f          	j	4000a22c <z_shell_write>

4000a320 <z_shell_vt100_color_set>:
{
	if (!IS_ENABLED(CONFIG_SHELL_VT100_COLORS)) {
		return;
	}

	if (color >= VT100_COLOR_END) {
4000a320:	00800713          	li	a4,8
{
4000a324:	00058613          	mv	a2,a1
	if (color >= VT100_COLOR_END) {
4000a328:	04b76863          	bltu	a4,a1,4000a378 <z_shell_vt100_color_set+0x58>
		return;
	}

	if (sh->ctx->vt100_ctx.col.col == color) {
4000a32c:	00852783          	lw	a5,8(a0)
4000a330:	0347a683          	lw	a3,52(a5)
4000a334:	04b68263          	beq	a3,a1,4000a378 <z_shell_vt100_color_set+0x58>
		return;
	}

	sh->ctx->vt100_ctx.col.col = color;
4000a338:	02b7aa23          	sw	a1,52(a5)

	if (color != SHELL_NORMAL) {
4000a33c:	00852783          	lw	a5,8(a0)
	return sh->ctx->cfg.flags.use_vt100 == 1;
4000a340:	26c7a783          	lw	a5,620(a5)
4000a344:	0057d793          	srli	a5,a5,0x5
4000a348:	0017f793          	andi	a5,a5,1
4000a34c:	00e58c63          	beq	a1,a4,4000a364 <z_shell_vt100_color_set+0x44>
		Z_SHELL_VT100_CMD(sh, "\e[1;3%dm", color);
4000a350:	02078463          	beqz	a5,4000a378 <z_shell_vt100_color_set+0x58>
4000a354:	01452503          	lw	a0,20(a0)
4000a358:	400345b7          	lui	a1,0x40034
4000a35c:	e3858593          	addi	a1,a1,-456 # 40033e38 <_shell_help+0x1c>
4000a360:	971ff06f          	j	40009cd0 <z_shell_raw_fprintf>
	} else {
		Z_SHELL_VT100_CMD(sh, SHELL_VT100_MODESOFF);
4000a364:	00078a63          	beqz	a5,4000a378 <z_shell_vt100_color_set+0x58>
4000a368:	01452503          	lw	a0,20(a0)
4000a36c:	400325b7          	lui	a1,0x40032
4000a370:	6c058593          	addi	a1,a1,1728 # 400326c0 <eth_config+0x24>
4000a374:	95dff06f          	j	40009cd0 <z_shell_raw_fprintf>
	}
}
4000a378:	00008067          	ret

4000a37c <z_shell_vt100_colors_restore>:

void z_shell_vt100_colors_restore(const struct shell *sh,
				  const struct shell_vt100_colors *color)
{
4000a37c:	ff010113          	addi	sp,sp,-16
4000a380:	00812423          	sw	s0,8(sp)
4000a384:	00912223          	sw	s1,4(sp)
4000a388:	00112623          	sw	ra,12(sp)
4000a38c:	00058493          	mv	s1,a1
	if (!IS_ENABLED(CONFIG_SHELL_VT100_COLORS)) {
		return;
	}

	z_shell_vt100_color_set(sh, color->col);
4000a390:	0005a583          	lw	a1,0(a1)
{
4000a394:	00050413          	mv	s0,a0
	z_shell_vt100_color_set(sh, color->col);
4000a398:	f89ff0ef          	jal	ra,4000a320 <z_shell_vt100_color_set>
	vt100_bgcolor_set(sh, color->bgcol);
4000a39c:	0044a603          	lw	a2,4(s1)
	if ((bgcolor == SHELL_NORMAL) ||
4000a3a0:	00700793          	li	a5,7
4000a3a4:	04c7e463          	bltu	a5,a2,4000a3ec <z_shell_vt100_colors_restore+0x70>
	    (sh->ctx->vt100_ctx.col.bgcol == bgcolor)) {
4000a3a8:	00842783          	lw	a5,8(s0)
	if ((bgcolor == SHELL_NORMAL) ||
4000a3ac:	0387a703          	lw	a4,56(a5)
4000a3b0:	02e60e63          	beq	a2,a4,4000a3ec <z_shell_vt100_colors_restore+0x70>
	sh->ctx->vt100_ctx.col.bgcol = bgcolor;
4000a3b4:	02c7ac23          	sw	a2,56(a5)
4000a3b8:	00842783          	lw	a5,8(s0)
4000a3bc:	26c7a783          	lw	a5,620(a5)
4000a3c0:	0057d793          	srli	a5,a5,0x5
4000a3c4:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, "\e[403%dm", bgcolor);
4000a3c8:	02078263          	beqz	a5,4000a3ec <z_shell_vt100_colors_restore+0x70>
4000a3cc:	01442503          	lw	a0,20(s0)
}
4000a3d0:	00812403          	lw	s0,8(sp)
4000a3d4:	00c12083          	lw	ra,12(sp)
4000a3d8:	00412483          	lw	s1,4(sp)
	Z_SHELL_VT100_CMD(sh, "\e[403%dm", bgcolor);
4000a3dc:	400345b7          	lui	a1,0x40034
4000a3e0:	e4458593          	addi	a1,a1,-444 # 40033e44 <_shell_help+0x28>
}
4000a3e4:	01010113          	addi	sp,sp,16
	Z_SHELL_VT100_CMD(sh, "\e[403%dm", bgcolor);
4000a3e8:	8e9ff06f          	j	40009cd0 <z_shell_raw_fprintf>
}
4000a3ec:	00c12083          	lw	ra,12(sp)
4000a3f0:	00812403          	lw	s0,8(sp)
4000a3f4:	00412483          	lw	s1,4(sp)
4000a3f8:	01010113          	addi	sp,sp,16
4000a3fc:	00008067          	ret

4000a400 <z_shell_vfprintf>:

void z_shell_vfprintf(const struct shell *sh, enum shell_vt100_color color,
		      const char *fmt, va_list args)
{
4000a400:	fd010113          	addi	sp,sp,-48
4000a404:	02812423          	sw	s0,40(sp)
4000a408:	02912223          	sw	s1,36(sp)
4000a40c:	03212023          	sw	s2,32(sp)
4000a410:	01312e23          	sw	s3,28(sp)
4000a414:	02112623          	sw	ra,44(sp)
4000a418:	00058993          	mv	s3,a1
	return sh->ctx->cfg.flags.use_colors == 1;
4000a41c:	00852583          	lw	a1,8(a0)
4000a420:	00050413          	mv	s0,a0
4000a424:	00060493          	mv	s1,a2
4000a428:	26c5a783          	lw	a5,620(a1)
4000a42c:	00068913          	mv	s2,a3
4000a430:	0047d793          	srli	a5,a5,0x4
4000a434:	0017f793          	andi	a5,a5,1
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
4000a438:	06078063          	beqz	a5,4000a498 <z_shell_vfprintf+0x98>
	    z_flag_use_colors_get(sh)	  &&
4000a43c:	0345a783          	lw	a5,52(a1)
4000a440:	05378c63          	beq	a5,s3,4000a498 <z_shell_vfprintf+0x98>
			     enum shell_vt100_color color);

static inline void z_shell_vt100_colors_store(const struct shell *sh,
					      struct shell_vt100_colors *color)
{
	memcpy(color, &sh->ctx->vt100_ctx.col, sizeof(*color));
4000a444:	00800613          	li	a2,8
4000a448:	03458593          	addi	a1,a1,52
4000a44c:	00810513          	addi	a0,sp,8
4000a450:	0a9020ef          	jal	ra,4000ccf8 <memcpy>
	    (color != sh->ctx->vt100_ctx.col.col)) {
		struct shell_vt100_colors col;

		z_shell_vt100_colors_store(sh, &col);
		z_shell_vt100_color_set(sh, color);
4000a454:	00098593          	mv	a1,s3
4000a458:	00040513          	mv	a0,s0
4000a45c:	ec5ff0ef          	jal	ra,4000a320 <z_shell_vt100_color_set>

		z_shell_fprintf_fmt(sh->fprintf_ctx, fmt, args);
4000a460:	01442503          	lw	a0,20(s0)
4000a464:	00090613          	mv	a2,s2
4000a468:	00048593          	mv	a1,s1
4000a46c:	e15fe0ef          	jal	ra,40009280 <z_shell_fprintf_fmt>

		z_shell_vt100_colors_restore(sh, &col);
4000a470:	00810593          	addi	a1,sp,8
4000a474:	00040513          	mv	a0,s0
4000a478:	f05ff0ef          	jal	ra,4000a37c <z_shell_vt100_colors_restore>
	} else {
		z_shell_fprintf_fmt(sh->fprintf_ctx, fmt, args);
	}
}
4000a47c:	02c12083          	lw	ra,44(sp)
4000a480:	02812403          	lw	s0,40(sp)
4000a484:	02412483          	lw	s1,36(sp)
4000a488:	02012903          	lw	s2,32(sp)
4000a48c:	01c12983          	lw	s3,28(sp)
4000a490:	03010113          	addi	sp,sp,48
4000a494:	00008067          	ret
		z_shell_fprintf_fmt(sh->fprintf_ctx, fmt, args);
4000a498:	01442503          	lw	a0,20(s0)
}
4000a49c:	02812403          	lw	s0,40(sp)
4000a4a0:	02c12083          	lw	ra,44(sp)
4000a4a4:	01c12983          	lw	s3,28(sp)
		z_shell_fprintf_fmt(sh->fprintf_ctx, fmt, args);
4000a4a8:	00090613          	mv	a2,s2
4000a4ac:	00048593          	mv	a1,s1
}
4000a4b0:	02012903          	lw	s2,32(sp)
4000a4b4:	02412483          	lw	s1,36(sp)
4000a4b8:	03010113          	addi	sp,sp,48
		z_shell_fprintf_fmt(sh->fprintf_ctx, fmt, args);
4000a4bc:	dc5fe06f          	j	40009280 <z_shell_fprintf_fmt>

4000a4c0 <z_shell_fprintf>:

void z_shell_fprintf(const struct shell *sh,
		     enum shell_vt100_color color,
		     const char *fmt, ...)
{
4000a4c0:	fc010113          	addi	sp,sp,-64
4000a4c4:	02d12623          	sw	a3,44(sp)
	__ASSERT(z_flag_sync_mode_get(sh) || !k_is_in_isr(),
		 "Thread context required.");

	va_list args;

	va_start(args, fmt);
4000a4c8:	02c10693          	addi	a3,sp,44
{
4000a4cc:	00112e23          	sw	ra,28(sp)
4000a4d0:	02e12823          	sw	a4,48(sp)
4000a4d4:	02f12a23          	sw	a5,52(sp)
4000a4d8:	03012c23          	sw	a6,56(sp)
4000a4dc:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
4000a4e0:	00d12623          	sw	a3,12(sp)
	z_shell_vfprintf(sh, color, fmt, args);
4000a4e4:	f1dff0ef          	jal	ra,4000a400 <z_shell_vfprintf>
	va_end(args);
}
4000a4e8:	01c12083          	lw	ra,28(sp)
4000a4ec:	04010113          	addi	sp,sp,64
4000a4f0:	00008067          	ret

4000a4f4 <z_shell_op_word_remove>:
{
4000a4f4:	fe010113          	addi	sp,sp,-32
4000a4f8:	00112e23          	sw	ra,28(sp)
4000a4fc:	00812c23          	sw	s0,24(sp)
4000a500:	00912a23          	sw	s1,20(sp)
4000a504:	01212823          	sw	s2,16(sp)
4000a508:	01312623          	sw	s3,12(sp)
	char *str = &sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos - 1];
4000a50c:	00852783          	lw	a5,8(a0)
	if ((sh->ctx->cmd_buff_len == 0) ||
4000a510:	0487d603          	lhu	a2,72(a5)
	char *str = &sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos - 1];
4000a514:	04a7d483          	lhu	s1,74(a5)
	if ((sh->ctx->cmd_buff_len == 0) ||
4000a518:	12060e63          	beqz	a2,4000a654 <z_shell_op_word_remove+0x160>
4000a51c:	12048c63          	beqz	s1,4000a654 <z_shell_op_word_remove+0x160>
	char *str = &sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos - 1];
4000a520:	04d48493          	addi	s1,s1,77
4000a524:	009784b3          	add	s1,a5,s1
	char *str_start = &sh->ctx->cmd_buff[0];
4000a528:	04e78713          	addi	a4,a5,78
4000a52c:	00050413          	mv	s0,a0
	char *str = &sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos - 1];
4000a530:	00048793          	mv	a5,s1
	while ((str >= str_start) && (*str == ' ')) {
4000a534:	02000693          	li	a3,32
4000a538:	00e7e663          	bltu	a5,a4,4000a544 <z_shell_op_word_remove+0x50>
4000a53c:	0007c583          	lbu	a1,0(a5)
4000a540:	00d58663          	beq	a1,a3,4000a54c <z_shell_op_word_remove+0x58>
	while ((str >= str_start) && (*str != ' ')) {
4000a544:	02000693          	li	a3,32
4000a548:	0180006f          	j	4000a560 <z_shell_op_word_remove+0x6c>
		--str;
4000a54c:	fff78793          	addi	a5,a5,-1
4000a550:	fe9ff06f          	j	4000a538 <z_shell_op_word_remove+0x44>
	while ((str >= str_start) && (*str != ' ')) {
4000a554:	0007c583          	lbu	a1,0(a5)
4000a558:	00d58663          	beq	a1,a3,4000a564 <z_shell_op_word_remove+0x70>
		--str;
4000a55c:	fff78793          	addi	a5,a5,-1
	while ((str >= str_start) && (*str != ' ')) {
4000a560:	fee7fae3          	bgeu	a5,a4,4000a554 <z_shell_op_word_remove+0x60>
4000a564:	01079913          	slli	s2,a5,0x10
4000a568:	01049493          	slli	s1,s1,0x10
4000a56c:	0104d493          	srli	s1,s1,0x10
4000a570:	01095913          	srli	s2,s2,0x10
4000a574:	41248733          	sub	a4,s1,s2
4000a578:	01071713          	slli	a4,a4,0x10
4000a57c:	01075713          	srli	a4,a4,0x10
	memmove(str + 1, str + 1 + chars_to_delete,
4000a580:	00178993          	addi	s3,a5,1
4000a584:	00170593          	addi	a1,a4,1
4000a588:	40e60633          	sub	a2,a2,a4
4000a58c:	00b785b3          	add	a1,a5,a1
4000a590:	00098513          	mv	a0,s3
4000a594:	71c020ef          	jal	ra,4000ccb0 <memmove>
	sh->ctx->cmd_buff_len -= chars_to_delete;
4000a598:	00842703          	lw	a4,8(s0)
4000a59c:	409905b3          	sub	a1,s2,s1
4000a5a0:	01059593          	slli	a1,a1,0x10
4000a5a4:	04875783          	lhu	a5,72(a4)
4000a5a8:	0105d593          	srli	a1,a1,0x10
	z_shell_op_cursor_move(sh, -chars_to_delete);
4000a5ac:	00040513          	mv	a0,s0
	sh->ctx->cmd_buff_len -= chars_to_delete;
4000a5b0:	00f587b3          	add	a5,a1,a5
4000a5b4:	04f71423          	sh	a5,72(a4)
	sh->ctx->cmd_buff[sh->ctx->cmd_buff_len] = '\0';
4000a5b8:	00842783          	lw	a5,8(s0)
	z_shell_op_cursor_move(sh, -chars_to_delete);
4000a5bc:	01059593          	slli	a1,a1,0x10
4000a5c0:	4105d593          	srai	a1,a1,0x10
	sh->ctx->cmd_buff[sh->ctx->cmd_buff_len] = '\0';
4000a5c4:	0487d703          	lhu	a4,72(a5)
4000a5c8:	00e787b3          	add	a5,a5,a4
4000a5cc:	04078723          	sb	zero,78(a5)
	z_shell_op_cursor_move(sh, -chars_to_delete);
4000a5d0:	999ff0ef          	jal	ra,40009f68 <z_shell_op_cursor_move>
	return sh->ctx->cfg.flags.use_vt100 == 1;
4000a5d4:	00842783          	lw	a5,8(s0)
4000a5d8:	26c7a783          	lw	a5,620(a5)
4000a5dc:	0057d793          	srli	a5,a5,0x5
4000a5e0:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SAVECURSOR);
4000a5e4:	00078a63          	beqz	a5,4000a5f8 <z_shell_op_word_remove+0x104>
4000a5e8:	01442503          	lw	a0,20(s0)
4000a5ec:	400325b7          	lui	a1,0x40032
4000a5f0:	6c858593          	addi	a1,a1,1736 # 400326c8 <eth_config+0x2c>
4000a5f4:	edcff0ef          	jal	ra,40009cd0 <z_shell_raw_fprintf>
	z_shell_fprintf(sh, SHELL_NORMAL, "%s", str + 1);
4000a5f8:	40033637          	lui	a2,0x40033
4000a5fc:	00098693          	mv	a3,s3
4000a600:	af860613          	addi	a2,a2,-1288 # 40032af8 <mpsc_config+0x9c>
4000a604:	00800593          	li	a1,8
4000a608:	00040513          	mv	a0,s0
4000a60c:	eb5ff0ef          	jal	ra,4000a4c0 <z_shell_fprintf>
	z_clear_eos(sh);
4000a610:	00040513          	mv	a0,s0
4000a614:	ef4ff0ef          	jal	ra,40009d08 <z_clear_eos>
	return sh->ctx->cfg.flags.use_vt100 == 1;
4000a618:	00842783          	lw	a5,8(s0)
4000a61c:	26c7a783          	lw	a5,620(a5)
4000a620:	0057d793          	srli	a5,a5,0x5
4000a624:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
4000a628:	02078663          	beqz	a5,4000a654 <z_shell_op_word_remove+0x160>
4000a62c:	01442503          	lw	a0,20(s0)
}
4000a630:	01812403          	lw	s0,24(sp)
4000a634:	01c12083          	lw	ra,28(sp)
4000a638:	01412483          	lw	s1,20(sp)
4000a63c:	01012903          	lw	s2,16(sp)
4000a640:	00c12983          	lw	s3,12(sp)
4000a644:	400325b7          	lui	a1,0x40032
4000a648:	6cc58593          	addi	a1,a1,1740 # 400326cc <eth_config+0x30>
4000a64c:	02010113          	addi	sp,sp,32
4000a650:	e80ff06f          	j	40009cd0 <z_shell_raw_fprintf>
4000a654:	01c12083          	lw	ra,28(sp)
4000a658:	01812403          	lw	s0,24(sp)
4000a65c:	01412483          	lw	s1,20(sp)
4000a660:	01012903          	lw	s2,16(sp)
4000a664:	00c12983          	lw	s3,12(sp)
4000a668:	02010113          	addi	sp,sp,32
4000a66c:	00008067          	ret

4000a670 <reprint_from_cursor>:
{
4000a670:	fe010113          	addi	sp,sp,-32
4000a674:	00812c23          	sw	s0,24(sp)
4000a678:	00912a23          	sw	s1,20(sp)
4000a67c:	01312623          	sw	s3,12(sp)
4000a680:	00112e23          	sw	ra,28(sp)
4000a684:	01212823          	sw	s2,16(sp)
4000a688:	01412423          	sw	s4,8(sp)
4000a68c:	00050413          	mv	s0,a0
4000a690:	00058493          	mv	s1,a1
4000a694:	00060993          	mv	s3,a2
	if (data_removed) {
4000a698:	00060463          	beqz	a2,4000a6a0 <reprint_from_cursor+0x30>
		z_clear_eos(sh);
4000a69c:	e6cff0ef          	jal	ra,40009d08 <z_clear_eos>
	return sh->ctx->cfg.flags.obscure == 1;
4000a6a0:	00842683          	lw	a3,8(s0)
4000a6a4:	26c6a783          	lw	a5,620(a3)
		int len = strlen(&sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos]);
4000a6a8:	04a6d703          	lhu	a4,74(a3)
4000a6ac:	0027d793          	srli	a5,a5,0x2
4000a6b0:	04e70713          	addi	a4,a4,78
4000a6b4:	0017f793          	andi	a5,a5,1
4000a6b8:	00e686b3          	add	a3,a3,a4
	if (z_flag_obscure_get(sh)) {
4000a6bc:	08078263          	beqz	a5,4000a740 <reprint_from_cursor+0xd0>
		int len = strlen(&sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos]);
4000a6c0:	00068513          	mv	a0,a3
4000a6c4:	510020ef          	jal	ra,4000cbd4 <strlen>
4000a6c8:	00050913          	mv	s2,a0
			z_shell_raw_fprintf(sh->fprintf_ctx, "*");
4000a6cc:	40033a37          	lui	s4,0x40033
		while (len--) {
4000a6d0:	04091e63          	bnez	s2,4000a72c <reprint_from_cursor+0xbc>
	sh->ctx->cmd_buff_pos = sh->ctx->cmd_buff_len;
4000a6d4:	00842783          	lw	a5,8(s0)
	if (full_line_cmd(sh)) {
4000a6d8:	00040513          	mv	a0,s0
	sh->ctx->cmd_buff_pos = sh->ctx->cmd_buff_len;
4000a6dc:	0487d703          	lhu	a4,72(a5)
4000a6e0:	04e79523          	sh	a4,74(a5)
	if (full_line_cmd(sh)) {
4000a6e4:	e58ff0ef          	jal	ra,40009d3c <full_line_cmd>
4000a6e8:	00050a63          	beqz	a0,4000a6fc <reprint_from_cursor+0x8c>
		if (((data_removed) && (diff > 0)) || (!data_removed)) {
4000a6ec:	00098463          	beqz	s3,4000a6f4 <reprint_from_cursor+0x84>
4000a6f0:	00048663          	beqz	s1,4000a6fc <reprint_from_cursor+0x8c>
			z_cursor_next_line_move(sh);
4000a6f4:	01442503          	lw	a0,20(s0)
4000a6f8:	e38ff0ef          	jal	ra,40009d30 <z_cursor_next_line_move.isra.0>
	z_shell_op_cursor_move(sh, -diff);
4000a6fc:	00040513          	mv	a0,s0
}
4000a700:	01812403          	lw	s0,24(sp)
4000a704:	01c12083          	lw	ra,28(sp)
4000a708:	01012903          	lw	s2,16(sp)
4000a70c:	00c12983          	lw	s3,12(sp)
4000a710:	00812a03          	lw	s4,8(sp)
	z_shell_op_cursor_move(sh, -diff);
4000a714:	409005b3          	neg	a1,s1
}
4000a718:	01412483          	lw	s1,20(sp)
	z_shell_op_cursor_move(sh, -diff);
4000a71c:	01059593          	slli	a1,a1,0x10
4000a720:	4105d593          	srai	a1,a1,0x10
}
4000a724:	02010113          	addi	sp,sp,32
	z_shell_op_cursor_move(sh, -diff);
4000a728:	841ff06f          	j	40009f68 <z_shell_op_cursor_move>
			z_shell_raw_fprintf(sh->fprintf_ctx, "*");
4000a72c:	01442503          	lw	a0,20(s0)
4000a730:	164a0593          	addi	a1,s4,356 # 40033164 <severity_lvls+0x6c>
4000a734:	fff90913          	addi	s2,s2,-1
4000a738:	d98ff0ef          	jal	ra,40009cd0 <z_shell_raw_fprintf>
4000a73c:	f95ff06f          	j	4000a6d0 <reprint_from_cursor+0x60>
		z_shell_fprintf(sh, SHELL_NORMAL, "%s",
4000a740:	40033637          	lui	a2,0x40033
4000a744:	af860613          	addi	a2,a2,-1288 # 40032af8 <mpsc_config+0x9c>
4000a748:	00800593          	li	a1,8
4000a74c:	00040513          	mv	a0,s0
4000a750:	d71ff0ef          	jal	ra,4000a4c0 <z_shell_fprintf>
4000a754:	f81ff06f          	j	4000a6d4 <reprint_from_cursor+0x64>

4000a758 <data_insert>:
{
4000a758:	fe010113          	addi	sp,sp,-32
4000a75c:	00112e23          	sw	ra,28(sp)
4000a760:	00812c23          	sw	s0,24(sp)
4000a764:	00912a23          	sw	s1,20(sp)
4000a768:	01212823          	sw	s2,16(sp)
4000a76c:	01312623          	sw	s3,12(sp)
4000a770:	01412423          	sw	s4,8(sp)
	uint16_t after = sh->ctx->cmd_buff_len - sh->ctx->cmd_buff_pos;
4000a774:	00852983          	lw	s3,8(a0)
	if ((sh->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
4000a778:	0ff00793          	li	a5,255
	uint16_t after = sh->ctx->cmd_buff_len - sh->ctx->cmd_buff_pos;
4000a77c:	0489d903          	lhu	s2,72(s3)
	if ((sh->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
4000a780:	00c90733          	add	a4,s2,a2
4000a784:	08e7c463          	blt	a5,a4,4000a80c <data_insert+0xb4>
	uint16_t after = sh->ctx->cmd_buff_len - sh->ctx->cmd_buff_pos;
4000a788:	04a9d783          	lhu	a5,74(s3)
4000a78c:	00060413          	mv	s0,a2
4000a790:	00050493          	mv	s1,a0
4000a794:	40f90933          	sub	s2,s2,a5
4000a798:	01091913          	slli	s2,s2,0x10
	char *curr_pos = &sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos];
4000a79c:	04e78793          	addi	a5,a5,78
4000a7a0:	00f989b3          	add	s3,s3,a5
	uint16_t after = sh->ctx->cmd_buff_len - sh->ctx->cmd_buff_pos;
4000a7a4:	01095913          	srli	s2,s2,0x10
4000a7a8:	00058a13          	mv	s4,a1
	memmove(curr_pos + len, curr_pos, after);
4000a7ac:	00090613          	mv	a2,s2
4000a7b0:	00098593          	mv	a1,s3
4000a7b4:	00898533          	add	a0,s3,s0
4000a7b8:	4f8020ef          	jal	ra,4000ccb0 <memmove>
	memcpy(curr_pos, data, len);
4000a7bc:	00040613          	mv	a2,s0
4000a7c0:	000a0593          	mv	a1,s4
4000a7c4:	00098513          	mv	a0,s3
4000a7c8:	530020ef          	jal	ra,4000ccf8 <memcpy>
	sh->ctx->cmd_buff_len += len;
4000a7cc:	0084a703          	lw	a4,8(s1)
4000a7d0:	04875783          	lhu	a5,72(a4)
4000a7d4:	00f407b3          	add	a5,s0,a5
4000a7d8:	04f71423          	sh	a5,72(a4)
	sh->ctx->cmd_buff[sh->ctx->cmd_buff_len] = '\0';
4000a7dc:	0084a783          	lw	a5,8(s1)
4000a7e0:	0487d703          	lhu	a4,72(a5)
4000a7e4:	00e787b3          	add	a5,a5,a4
4000a7e8:	04078723          	sb	zero,78(a5)
	return sh->ctx->cfg.flags.echo == 1;
4000a7ec:	0084a703          	lw	a4,8(s1)
4000a7f0:	26c72783          	lw	a5,620(a4)
4000a7f4:	0017d793          	srli	a5,a5,0x1
4000a7f8:	0017f793          	andi	a5,a5,1
	if (!z_flag_echo_get(sh)) {
4000a7fc:	02079863          	bnez	a5,4000a82c <data_insert+0xd4>
		sh->ctx->cmd_buff_pos += len;
4000a800:	04a75783          	lhu	a5,74(a4)
4000a804:	00f40433          	add	s0,s0,a5
4000a808:	04871523          	sh	s0,74(a4)
}
4000a80c:	01c12083          	lw	ra,28(sp)
4000a810:	01812403          	lw	s0,24(sp)
4000a814:	01412483          	lw	s1,20(sp)
4000a818:	01012903          	lw	s2,16(sp)
4000a81c:	00c12983          	lw	s3,12(sp)
4000a820:	00812a03          	lw	s4,8(sp)
4000a824:	02010113          	addi	sp,sp,32
4000a828:	00008067          	ret
4000a82c:	01812403          	lw	s0,24(sp)
4000a830:	01c12083          	lw	ra,28(sp)
4000a834:	00c12983          	lw	s3,12(sp)
4000a838:	00812a03          	lw	s4,8(sp)
	reprint_from_cursor(sh, after, false);
4000a83c:	00090593          	mv	a1,s2
4000a840:	00048513          	mv	a0,s1
}
4000a844:	01012903          	lw	s2,16(sp)
4000a848:	01412483          	lw	s1,20(sp)
	reprint_from_cursor(sh, after, false);
4000a84c:	00000613          	li	a2,0
}
4000a850:	02010113          	addi	sp,sp,32
	reprint_from_cursor(sh, after, false);
4000a854:	e1dff06f          	j	4000a670 <reprint_from_cursor>

4000a858 <z_shell_op_char_insert>:
{
4000a858:	fe010113          	addi	sp,sp,-32
4000a85c:	00812c23          	sw	s0,24(sp)
4000a860:	00112e23          	sw	ra,28(sp)
	return sh->ctx->cfg.flags.insert_mode == 1;
4000a864:	00852783          	lw	a5,8(a0)
4000a868:	00b107a3          	sb	a1,15(sp)
4000a86c:	00050413          	mv	s0,a0
4000a870:	26c7a703          	lw	a4,620(a5)
4000a874:	00177713          	andi	a4,a4,1
	if (z_flag_insert_mode_get(sh) &&
4000a878:	08070063          	beqz	a4,4000a8f8 <z_shell_op_char_insert+0xa0>
	    (sh->ctx->cmd_buff_len != sh->ctx->cmd_buff_pos)) {
4000a87c:	04a7d703          	lhu	a4,74(a5)
	if (z_flag_insert_mode_get(sh) &&
4000a880:	0487d683          	lhu	a3,72(a5)
4000a884:	06e68a63          	beq	a3,a4,4000a8f8 <z_shell_op_char_insert+0xa0>
	sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos++] = data;
4000a888:	00170693          	addi	a3,a4,1
4000a88c:	04d79523          	sh	a3,74(a5)
		char_replace(sh, data);
4000a890:	0ff5f613          	zext.b	a2,a1
	sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos++] = data;
4000a894:	00e787b3          	add	a5,a5,a4
4000a898:	04c78723          	sb	a2,78(a5)
	return sh->ctx->cfg.flags.echo == 1;
4000a89c:	00852703          	lw	a4,8(a0)
4000a8a0:	26c72783          	lw	a5,620(a4)
4000a8a4:	0017d793          	srli	a5,a5,0x1
4000a8a8:	0017f793          	andi	a5,a5,1
	if (!z_flag_echo_get(sh)) {
4000a8ac:	02078e63          	beqz	a5,4000a8e8 <z_shell_op_char_insert+0x90>
	return sh->ctx->cfg.flags.obscure == 1;
4000a8b0:	26c72783          	lw	a5,620(a4)
4000a8b4:	0027d793          	srli	a5,a5,0x2
4000a8b8:	0017f793          	andi	a5,a5,1
	if (z_flag_obscure_get(sh)) {
4000a8bc:	00078463          	beqz	a5,4000a8c4 <z_shell_op_char_insert+0x6c>
		data = '*';
4000a8c0:	02a00613          	li	a2,42
	z_shell_raw_fprintf(sh->fprintf_ctx, "%c", data);
4000a8c4:	01442503          	lw	a0,20(s0)
4000a8c8:	400345b7          	lui	a1,0x40034
4000a8cc:	e3458593          	addi	a1,a1,-460 # 40033e34 <_shell_help+0x18>
4000a8d0:	c00ff0ef          	jal	ra,40009cd0 <z_shell_raw_fprintf>
	if (z_shell_cursor_in_empty_line(sh)) {
4000a8d4:	00040513          	mv	a0,s0
4000a8d8:	d48ff0ef          	jal	ra,40009e20 <z_shell_cursor_in_empty_line>
4000a8dc:	00050663          	beqz	a0,4000a8e8 <z_shell_op_char_insert+0x90>
		z_cursor_next_line_move(sh);
4000a8e0:	01442503          	lw	a0,20(s0)
4000a8e4:	c4cff0ef          	jal	ra,40009d30 <z_cursor_next_line_move.isra.0>
}
4000a8e8:	01c12083          	lw	ra,28(sp)
4000a8ec:	01812403          	lw	s0,24(sp)
4000a8f0:	02010113          	addi	sp,sp,32
4000a8f4:	00008067          	ret
		data_insert(sh, &data, 1);
4000a8f8:	00100613          	li	a2,1
4000a8fc:	00f10593          	addi	a1,sp,15
4000a900:	00040513          	mv	a0,s0
4000a904:	e55ff0ef          	jal	ra,4000a758 <data_insert>
}
4000a908:	fe1ff06f          	j	4000a8e8 <z_shell_op_char_insert+0x90>

4000a90c <z_shell_op_completion_insert>:
	data_insert(sh, compl, compl_len);
4000a90c:	e4dff06f          	j	4000a758 <data_insert>

4000a910 <z_shell_op_char_delete>:
{
4000a910:	ff010113          	addi	sp,sp,-16
4000a914:	00112623          	sw	ra,12(sp)
4000a918:	00812423          	sw	s0,8(sp)
4000a91c:	00912223          	sw	s1,4(sp)
	uint16_t diff = sh->ctx->cmd_buff_len - sh->ctx->cmd_buff_pos;
4000a920:	00852783          	lw	a5,8(a0)
4000a924:	04a7d703          	lhu	a4,74(a5)
4000a928:	0487d403          	lhu	s0,72(a5)
4000a92c:	40e40433          	sub	s0,s0,a4
4000a930:	01041413          	slli	s0,s0,0x10
4000a934:	01045413          	srli	s0,s0,0x10
	if (diff == 0U) {
4000a938:	04040a63          	beqz	s0,4000a98c <z_shell_op_char_delete+0x7c>
	char *str = &sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos];
4000a93c:	04e70713          	addi	a4,a4,78
4000a940:	00050493          	mv	s1,a0
4000a944:	00e78533          	add	a0,a5,a4
	memmove(str, str + 1, diff);
4000a948:	00040613          	mv	a2,s0
4000a94c:	00150593          	addi	a1,a0,1
4000a950:	360020ef          	jal	ra,4000ccb0 <memmove>
	--sh->ctx->cmd_buff_len;
4000a954:	0084a703          	lw	a4,8(s1)
	reprint_from_cursor(sh, --diff, true);
4000a958:	fff40593          	addi	a1,s0,-1
4000a95c:	00048513          	mv	a0,s1
	--sh->ctx->cmd_buff_len;
4000a960:	04875783          	lhu	a5,72(a4)
	reprint_from_cursor(sh, --diff, true);
4000a964:	01059593          	slli	a1,a1,0x10
4000a968:	00100613          	li	a2,1
	--sh->ctx->cmd_buff_len;
4000a96c:	fff78793          	addi	a5,a5,-1
4000a970:	04f71423          	sh	a5,72(a4)
}
4000a974:	00812403          	lw	s0,8(sp)
4000a978:	00c12083          	lw	ra,12(sp)
4000a97c:	00412483          	lw	s1,4(sp)
	reprint_from_cursor(sh, --diff, true);
4000a980:	0105d593          	srli	a1,a1,0x10
}
4000a984:	01010113          	addi	sp,sp,16
	reprint_from_cursor(sh, --diff, true);
4000a988:	ce9ff06f          	j	4000a670 <reprint_from_cursor>
}
4000a98c:	00c12083          	lw	ra,12(sp)
4000a990:	00812403          	lw	s0,8(sp)
4000a994:	00412483          	lw	s1,4(sp)
4000a998:	01010113          	addi	sp,sp,16
4000a99c:	00008067          	ret

4000a9a0 <z_shell_op_char_backspace>:
	if ((sh->ctx->cmd_buff_len == 0) ||
4000a9a0:	00852783          	lw	a5,8(a0)
4000a9a4:	0487d703          	lhu	a4,72(a5)
4000a9a8:	02070c63          	beqz	a4,4000a9e0 <z_shell_op_char_backspace+0x40>
4000a9ac:	04a7d783          	lhu	a5,74(a5)
4000a9b0:	02078863          	beqz	a5,4000a9e0 <z_shell_op_char_backspace+0x40>
{
4000a9b4:	ff010113          	addi	sp,sp,-16
	z_shell_op_cursor_move(sh, -1);
4000a9b8:	fff00593          	li	a1,-1
{
4000a9bc:	00812423          	sw	s0,8(sp)
4000a9c0:	00112623          	sw	ra,12(sp)
4000a9c4:	00050413          	mv	s0,a0
	z_shell_op_cursor_move(sh, -1);
4000a9c8:	da0ff0ef          	jal	ra,40009f68 <z_shell_op_cursor_move>
	z_shell_op_char_delete(sh);
4000a9cc:	00040513          	mv	a0,s0
}
4000a9d0:	00812403          	lw	s0,8(sp)
4000a9d4:	00c12083          	lw	ra,12(sp)
4000a9d8:	01010113          	addi	sp,sp,16
	z_shell_op_char_delete(sh);
4000a9dc:	f35ff06f          	j	4000a910 <z_shell_op_char_delete>
4000a9e0:	00008067          	ret

4000a9e4 <z_shell_print_prompt_and_cmd>:
{
4000a9e4:	ff010113          	addi	sp,sp,-16
4000a9e8:	00812423          	sw	s0,8(sp)
4000a9ec:	00112623          	sw	ra,12(sp)
	z_shell_fprintf(sh, SHELL_INFO, "%s", sh->ctx->prompt);
4000a9f0:	00852783          	lw	a5,8(a0)
4000a9f4:	40033637          	lui	a2,0x40033
4000a9f8:	af860613          	addi	a2,a2,-1288 # 40032af8 <mpsc_config+0x9c>
4000a9fc:	0007a683          	lw	a3,0(a5)
4000aa00:	00200593          	li	a1,2
{
4000aa04:	00050413          	mv	s0,a0
	z_shell_fprintf(sh, SHELL_INFO, "%s", sh->ctx->prompt);
4000aa08:	ab9ff0ef          	jal	ra,4000a4c0 <z_shell_fprintf>
	return sh->ctx->cfg.flags.echo == 1;
4000aa0c:	00842783          	lw	a5,8(s0)
4000aa10:	26c7a783          	lw	a5,620(a5)
4000aa14:	0017d793          	srli	a5,a5,0x1
4000aa18:	0017f793          	andi	a5,a5,1
	if (z_flag_echo_get(sh)) {
4000aa1c:	02078063          	beqz	a5,4000aa3c <z_shell_print_prompt_and_cmd+0x58>
		z_shell_print_cmd(sh);
4000aa20:	00040513          	mv	a0,s0
4000aa24:	ff0ff0ef          	jal	ra,4000a214 <z_shell_print_cmd>
		z_shell_op_cursor_position_synchronize(sh);
4000aa28:	00040513          	mv	a0,s0
}
4000aa2c:	00812403          	lw	s0,8(sp)
4000aa30:	00c12083          	lw	ra,12(sp)
4000aa34:	01010113          	addi	sp,sp,16
		z_shell_op_cursor_position_synchronize(sh);
4000aa38:	c9cff06f          	j	40009ed4 <z_shell_op_cursor_position_synchronize>
}
4000aa3c:	00c12083          	lw	ra,12(sp)
4000aa40:	00812403          	lw	s0,8(sp)
4000aa44:	01010113          	addi	sp,sp,16
4000aa48:	00008067          	ret

4000aa4c <process_msg_from_buffer>:
		}
	}
}

static bool process_msg_from_buffer(const struct shell *sh)
{
4000aa4c:	fe010113          	addi	sp,sp,-32
4000aa50:	00112e23          	sw	ra,28(sp)
4000aa54:	00812c23          	sw	s0,24(sp)
4000aa58:	00912a23          	sw	s1,20(sp)
4000aa5c:	01212823          	sw	s2,16(sp)
	const struct shell_log_backend *log_backend = sh->log_backend;
4000aa60:	01c52783          	lw	a5,28(a0)
	struct mpsc_pbuf_buffer *mpsc_buffer = log_backend->mpsc_buffer;
4000aa64:	0147a483          	lw	s1,20(a5)
	const struct log_output *log_output = log_backend->log_output;
4000aa68:	0047a903          	lw	s2,4(a5)
	return sh->ctx->cfg.flags.use_colors == 1;
4000aa6c:	00852783          	lw	a5,8(a0)
	union log_msg_generic *msg;
	bool colors = IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
			z_flag_use_colors_get(sh);

	msg = (union log_msg_generic *)mpsc_pbuf_claim(mpsc_buffer);
4000aa70:	00048513          	mv	a0,s1
4000aa74:	26c7a403          	lw	s0,620(a5)
4000aa78:	ca4f90ef          	jal	ra,40003f1c <mpsc_pbuf_claim>
	if (!msg) {
4000aa7c:	04050463          	beqz	a0,4000aac4 <process_msg_from_buffer+0x78>
4000aa80:	00445413          	srli	s0,s0,0x4
4000aa84:	00147413          	andi	s0,s0,1
4000aa88:	00050593          	mv	a1,a0
	log_output_msg_process(log_output, &msg->log, flags);
4000aa8c:	00e40613          	addi	a2,s0,14
4000aa90:	00a12623          	sw	a0,12(sp)
4000aa94:	00090513          	mv	a0,s2
4000aa98:	d7dfa0ef          	jal	ra,40005814 <log_output_msg_process>
		return false;
	}

	process_log_msg(sh, log_output, msg, false, colors);

	mpsc_pbuf_free(mpsc_buffer, &msg->buf);
4000aa9c:	00c12583          	lw	a1,12(sp)
4000aaa0:	00048513          	mv	a0,s1
4000aaa4:	d94f90ef          	jal	ra,40004038 <mpsc_pbuf_free>

	return true;
4000aaa8:	00100513          	li	a0,1
}
4000aaac:	01c12083          	lw	ra,28(sp)
4000aab0:	01812403          	lw	s0,24(sp)
4000aab4:	01412483          	lw	s1,20(sp)
4000aab8:	01012903          	lw	s2,16(sp)
4000aabc:	02010113          	addi	sp,sp,32
4000aac0:	00008067          	ret
		return false;
4000aac4:	00000513          	li	a0,0
4000aac8:	fe5ff06f          	j	4000aaac <process_msg_from_buffer+0x60>

4000aacc <dropped>:
{
4000aacc:	ff010113          	addi	sp,sp,-16
4000aad0:	00812423          	sw	s0,8(sp)
4000aad4:	00112623          	sw	ra,12(sp)
4000aad8:	00912223          	sw	s1,4(sp)
	const struct shell *sh = (const struct shell *)backend->cb->ctx;
4000aadc:	00452783          	lw	a5,4(a0)
{
4000aae0:	00058413          	mv	s0,a1
	const struct shell *sh = (const struct shell *)backend->cb->ctx;
4000aae4:	0007a783          	lw	a5,0(a5)
	const struct shell_log_backend *log_backend = sh->log_backend;
4000aae8:	01c7a483          	lw	s1,28(a5)
		atomic_add(&sh->stats->log_lost_cnt, cnt);
4000aaec:	0187a503          	lw	a0,24(a5)
	return z_impl_atomic_add(target, value);
4000aaf0:	759260ef          	jal	ra,40031a48 <z_impl_atomic_add>
	atomic_add(&log_backend->control_block->dropped_cnt, cnt);
4000aaf4:	0084a503          	lw	a0,8(s1)
4000aaf8:	00040593          	mv	a1,s0
}
4000aafc:	00812403          	lw	s0,8(sp)
4000ab00:	00c12083          	lw	ra,12(sp)
4000ab04:	00412483          	lw	s1,4(sp)
4000ab08:	01010113          	addi	sp,sp,16
4000ab0c:	73d2606f          	j	40031a48 <z_impl_atomic_add>

4000ab10 <process>:

static void process(const struct log_backend *const backend,
		    union log_msg_generic *msg)
{
4000ab10:	fe010113          	addi	sp,sp,-32
4000ab14:	01212823          	sw	s2,16(sp)
4000ab18:	00112e23          	sw	ra,28(sp)
4000ab1c:	00812c23          	sw	s0,24(sp)
4000ab20:	00912a23          	sw	s1,20(sp)
4000ab24:	01312623          	sw	s3,12(sp)
4000ab28:	01412423          	sw	s4,8(sp)
4000ab2c:	01512223          	sw	s5,4(sp)
4000ab30:	01612023          	sw	s6,0(sp)
	const struct shell *sh = (const struct shell *)backend->cb->ctx;
4000ab34:	00452783          	lw	a5,4(a0)
	const struct log_output *log_output = log_backend->log_output;
	bool colors = IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
			z_flag_use_colors_get(sh);
	struct k_poll_signal *signal;

	switch (sh->log_backend->control_block->state) {
4000ab38:	00100693          	li	a3,1
{
4000ab3c:	00058913          	mv	s2,a1
	const struct shell *sh = (const struct shell *)backend->cb->ctx;
4000ab40:	0007a483          	lw	s1,0(a5)
	const struct shell_log_backend *log_backend = sh->log_backend;
4000ab44:	01c4a783          	lw	a5,28(s1)
4000ab48:	0084a703          	lw	a4,8(s1)
	struct mpsc_pbuf_buffer *mpsc_buffer = log_backend->mpsc_buffer;
4000ab4c:	0147aa03          	lw	s4,20(a5)
4000ab50:	26c72403          	lw	s0,620(a4)
	switch (sh->log_backend->control_block->state) {
4000ab54:	0087a703          	lw	a4,8(a5)
	const struct log_output *log_output = log_backend->log_output;
4000ab58:	0047aa83          	lw	s5,4(a5)
	switch (sh->log_backend->control_block->state) {
4000ab5c:	00472703          	lw	a4,4(a4)
4000ab60:	02d70a63          	beq	a4,a3,4000ab94 <process+0x84>
4000ab64:	00300793          	li	a5,3
4000ab68:	12f70863          	beq	a4,a5,4000ac98 <process+0x188>
	case SHELL_LOG_BACKEND_DISABLED:
		__fallthrough;
	default:
		break;
	}
}
4000ab6c:	01c12083          	lw	ra,28(sp)
4000ab70:	01812403          	lw	s0,24(sp)
4000ab74:	01412483          	lw	s1,20(sp)
4000ab78:	01012903          	lw	s2,16(sp)
4000ab7c:	00c12983          	lw	s3,12(sp)
4000ab80:	00812a03          	lw	s4,8(sp)
4000ab84:	00412a83          	lw	s5,4(sp)
4000ab88:	00012b03          	lw	s6,0(sp)
4000ab8c:	02010113          	addi	sp,sp,32
4000ab90:	00008067          	ret
			if (copy_to_pbuffer(mpsc_buffer, msg, log_backend->timeout)) {
4000ab94:	00c7a583          	lw	a1,12(a5)
	return msg->generic.type == Z_LOG_MSG_LOG;
4000ab98:	00094783          	lbu	a5,0(s2)
4000ab9c:	00050b13          	mv	s6,a0
	return 0;
4000aba0:	00000413          	li	s0,0
	if (z_log_item_is_msg(generic_msg)) {
4000aba4:	0047f793          	andi	a5,a5,4
4000aba8:	02079263          	bnez	a5,4000abcc <process+0xbc>
	return Z_LOG_MSG_ALIGNED_WLEN(desc.package_len, desc.data_len);
4000abac:	00092783          	lw	a5,0(s2)
4000abb0:	0097d413          	srli	s0,a5,0x9
4000abb4:	7ff47413          	andi	s0,s0,2047
4000abb8:	0147d793          	srli	a5,a5,0x14
4000abbc:	00f40433          	add	s0,s0,a5
4000abc0:	01740413          	addi	s0,s0,23
4000abc4:	ff847413          	andi	s0,s0,-8
4000abc8:	00245413          	srli	s0,s0,0x2
		t += off;
4000abcc:	00958513          	addi	a0,a1,9
			return t / ((uint64_t)from_hz / to_hz);
4000abd0:	00a00613          	li	a2,10
4000abd4:	00000693          	li	a3,0
4000abd8:	00b535b3          	sltu	a1,a0,a1
4000abdc:	edcf50ef          	jal	ra,400002b8 <__udivdi3>
4000abe0:	00050613          	mv	a2,a0
4000abe4:	00058693          	mv	a3,a1
	dst = mpsc_pbuf_alloc(mpsc_buffer, wlen, K_MSEC(timeout));
4000abe8:	000a0513          	mv	a0,s4
4000abec:	00040593          	mv	a1,s0
4000abf0:	910f90ef          	jal	ra,40003d00 <mpsc_pbuf_alloc>
4000abf4:	00050993          	mv	s3,a0
	if (!dst) {
4000abf8:	02051a63          	bnez	a0,4000ac2c <process+0x11c>
}
4000abfc:	01812403          	lw	s0,24(sp)
4000ac00:	01c12083          	lw	ra,28(sp)
4000ac04:	01412483          	lw	s1,20(sp)
4000ac08:	01012903          	lw	s2,16(sp)
4000ac0c:	00c12983          	lw	s3,12(sp)
4000ac10:	00812a03          	lw	s4,8(sp)
4000ac14:	00412a83          	lw	s5,4(sp)
				dropped(backend, 1);
4000ac18:	000b0513          	mv	a0,s6
}
4000ac1c:	00012b03          	lw	s6,0(sp)
				dropped(backend, 1);
4000ac20:	00100593          	li	a1,1
}
4000ac24:	02010113          	addi	sp,sp,32
				dropped(backend, 1);
4000ac28:	ea5ff06f          	j	4000aacc <dropped>
	dst->hdr.data = msg->buf.hdr.data;
4000ac2c:	00092703          	lw	a4,0(s2)
4000ac30:	00052783          	lw	a5,0(a0)
	memcpy(dst_data, src_data, (wlen - hdr_wlen) * sizeof(uint32_t));
4000ac34:	fff40613          	addi	a2,s0,-1
	dst->hdr.data = msg->buf.hdr.data;
4000ac38:	ffc77713          	andi	a4,a4,-4
4000ac3c:	0037f793          	andi	a5,a5,3
4000ac40:	00e7e7b3          	or	a5,a5,a4
4000ac44:	00f52023          	sw	a5,0(a0)
	memcpy(dst_data, src_data, (wlen - hdr_wlen) * sizeof(uint32_t));
4000ac48:	00261613          	slli	a2,a2,0x2
4000ac4c:	00490593          	addi	a1,s2,4
4000ac50:	00450513          	addi	a0,a0,4
4000ac54:	0a4020ef          	jal	ra,4000ccf8 <memcpy>
	mpsc_pbuf_commit(mpsc_buffer, dst);
4000ac58:	000a0513          	mv	a0,s4
4000ac5c:	00098593          	mv	a1,s3
4000ac60:	a48f90ef          	jal	ra,40003ea8 <mpsc_pbuf_commit>
					signal = &sh->ctx->signals[SHELL_SIGNAL_LOG_MSG];
4000ac64:	0084a503          	lw	a0,8(s1)
4000ac68:	28450513          	addi	a0,a0,644
}
4000ac6c:	01812403          	lw	s0,24(sp)
4000ac70:	01c12083          	lw	ra,28(sp)
4000ac74:	01412483          	lw	s1,20(sp)
4000ac78:	01012903          	lw	s2,16(sp)
4000ac7c:	00c12983          	lw	s3,12(sp)
4000ac80:	00812a03          	lw	s4,8(sp)
4000ac84:	00412a83          	lw	s5,4(sp)
4000ac88:	00012b03          	lw	s6,0(sp)
	return z_impl_k_poll_signal_raise(sig, result);
4000ac8c:	00000593          	li	a1,0
4000ac90:	02010113          	addi	sp,sp,32
4000ac94:	4302706f          	j	400320c4 <z_impl_k_poll_signal_raise>
4000ac98:	00445413          	srli	s0,s0,0x4
		z_shell_cmd_line_erase(sh);
4000ac9c:	00048513          	mv	a0,s1
4000aca0:	00147413          	andi	s0,s0,1
4000aca4:	d0cff0ef          	jal	ra,4000a1b0 <z_shell_cmd_line_erase>
	if (colors) {
4000aca8:	00e40413          	addi	s0,s0,14
		if (k_is_in_isr()) {
4000acac:	7e5230ef          	jal	ra,4002ec90 <k_is_in_isr>
4000acb0:	04050e63          	beqz	a0,4000ad0c <process+0x1fc>
	__asm__ volatile ("csrrc %0, mstatus, %1"
4000acb4:	300479f3          	csrrci	s3,mstatus,8
	return sh->ctx->ctx.flags.cmd_ctx == 1;
4000acb8:	0084a783          	lw	a5,8(s1)
4000acbc:	2707a783          	lw	a5,624(a5)
4000acc0:	00b7d793          	srli	a5,a5,0xb
4000acc4:	0017f793          	andi	a5,a5,1
		if (!z_flag_cmd_ctx_get(sh)) {
4000acc8:	06078063          	beqz	a5,4000ad28 <process+0x218>
	log_output_msg_process(log_output, &msg->log, flags);
4000accc:	00040613          	mv	a2,s0
4000acd0:	00090593          	mv	a1,s2
4000acd4:	000a8513          	mv	a0,s5
4000acd8:	b3dfa0ef          	jal	ra,40005814 <log_output_msg_process>
4000acdc:	0084a783          	lw	a5,8(s1)
4000ace0:	2707a783          	lw	a5,624(a5)
4000ace4:	00b7d793          	srli	a5,a5,0xb
4000ace8:	0017f793          	andi	a5,a5,1
		if (!z_flag_cmd_ctx_get(sh)) {
4000acec:	00079663          	bnez	a5,4000acf8 <process+0x1e8>
			z_shell_print_prompt_and_cmd(sh);
4000acf0:	00048513          	mv	a0,s1
4000acf4:	cf1ff0ef          	jal	ra,4000a9e4 <z_shell_print_prompt_and_cmd>
		if (k_is_in_isr()) {
4000acf8:	799230ef          	jal	ra,4002ec90 <k_is_in_isr>
4000acfc:	02050c63          	beqz	a0,4000ad34 <process+0x224>
			  : "r" (key & MSTATUS_IEN)
4000ad00:	0089f993          	andi	s3,s3,8
	__asm__ volatile ("csrs mstatus, %0"
4000ad04:	3009a073          	csrs	mstatus,s3
}
4000ad08:	e65ff06f          	j	4000ab6c <process+0x5c>
			k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
4000ad0c:	0084a503          	lw	a0,8(s1)
4000ad10:	30450513          	addi	a0,a0,772
	return z_impl_k_mutex_lock(mutex, timeout);
4000ad14:	fff00593          	li	a1,-1
4000ad18:	fff00613          	li	a2,-1
4000ad1c:	720240ef          	jal	ra,4002f43c <z_impl_k_mutex_lock>
	unsigned int key = 0;
4000ad20:	00000993          	li	s3,0
4000ad24:	f95ff06f          	j	4000acb8 <process+0x1a8>
			z_shell_cmd_line_erase(sh);
4000ad28:	00048513          	mv	a0,s1
4000ad2c:	c84ff0ef          	jal	ra,4000a1b0 <z_shell_cmd_line_erase>
4000ad30:	f9dff06f          	j	4000accc <process+0x1bc>
			k_mutex_unlock(&sh->ctx->wr_mtx);
4000ad34:	0084a503          	lw	a0,8(s1)
4000ad38:	30450513          	addi	a0,a0,772
}
4000ad3c:	01812403          	lw	s0,24(sp)
4000ad40:	01c12083          	lw	ra,28(sp)
4000ad44:	01412483          	lw	s1,20(sp)
4000ad48:	01012903          	lw	s2,16(sp)
4000ad4c:	00c12983          	lw	s3,12(sp)
4000ad50:	00812a03          	lw	s4,8(sp)
4000ad54:	00412a83          	lw	s5,4(sp)
4000ad58:	00012b03          	lw	s6,0(sp)
4000ad5c:	02010113          	addi	sp,sp,32
	return z_impl_k_mutex_unlock(mutex);
4000ad60:	0392406f          	j	4002f598 <z_impl_k_mutex_unlock>

4000ad64 <z_shell_log_backend_output_func>:
{
4000ad64:	ff010113          	addi	sp,sp,-16
4000ad68:	00060793          	mv	a5,a2
4000ad6c:	00812423          	sw	s0,8(sp)
	z_shell_print_stream(ctx, data, length);
4000ad70:	00058613          	mv	a2,a1
{
4000ad74:	00058413          	mv	s0,a1
	z_shell_print_stream(ctx, data, length);
4000ad78:	00050593          	mv	a1,a0
4000ad7c:	00078513          	mv	a0,a5
{
4000ad80:	00112623          	sw	ra,12(sp)
	z_shell_print_stream(ctx, data, length);
4000ad84:	d98ff0ef          	jal	ra,4000a31c <z_shell_print_stream>
}
4000ad88:	00c12083          	lw	ra,12(sp)
4000ad8c:	00040513          	mv	a0,s0
4000ad90:	00812403          	lw	s0,8(sp)
4000ad94:	01010113          	addi	sp,sp,16
4000ad98:	00008067          	ret

4000ad9c <z_shell_log_backend_enable>:
{
4000ad9c:	fe010113          	addi	sp,sp,-32
4000ada0:	00112e23          	sw	ra,28(sp)
4000ada4:	00812c23          	sw	s0,24(sp)
4000ada8:	00912a23          	sw	s1,20(sp)
4000adac:	00050413          	mv	s0,a0
4000adb0:	00058493          	mv	s1,a1
	mpsc_pbuf_init(backend->mpsc_buffer, backend->mpsc_buffer_config);
4000adb4:	01052583          	lw	a1,16(a0)
4000adb8:	01452503          	lw	a0,20(a0)
{
4000adbc:	00c12623          	sw	a2,12(sp)
	mpsc_pbuf_init(backend->mpsc_buffer, backend->mpsc_buffer_config);
4000adc0:	ebdf80ef          	jal	ra,40003c7c <mpsc_pbuf_init>
		log_backend_enable(backend->backend, ctx, init_log_level);
4000adc4:	00c12603          	lw	a2,12(sp)
4000adc8:	00042503          	lw	a0,0(s0)
4000adcc:	00048593          	mv	a1,s1
4000add0:	fd9f90ef          	jal	ra,40004da8 <log_backend_enable>
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *output,
				      void *ctx)
{
	output->control_block->ctx = ctx;
4000add4:	00442783          	lw	a5,4(s0)
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
4000add8:	00100713          	li	a4,1
4000addc:	0047a783          	lw	a5,4(a5)
4000ade0:	0097a223          	sw	s1,4(a5)
		backend->control_block->dropped_cnt = 0;
4000ade4:	00842783          	lw	a5,8(s0)
4000ade8:	0007a023          	sw	zero,0(a5)
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
4000adec:	00842783          	lw	a5,8(s0)
4000adf0:	00e7a223          	sw	a4,4(a5)
}
4000adf4:	01c12083          	lw	ra,28(sp)
4000adf8:	01812403          	lw	s0,24(sp)
4000adfc:	01412483          	lw	s1,20(sp)
4000ae00:	02010113          	addi	sp,sp,32
4000ae04:	00008067          	ret

4000ae08 <z_shell_log_backend_disable>:
{
4000ae08:	ff010113          	addi	sp,sp,-16
4000ae0c:	00812423          	sw	s0,8(sp)
4000ae10:	00112623          	sw	ra,12(sp)
4000ae14:	00050413          	mv	s0,a0
	log_backend_disable(backend->backend);
4000ae18:	00052503          	lw	a0,0(a0)
4000ae1c:	ff9f90ef          	jal	ra,40004e14 <log_backend_disable>
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
4000ae20:	00842783          	lw	a5,8(s0)
4000ae24:	00200713          	li	a4,2
4000ae28:	00e7a223          	sw	a4,4(a5)
}
4000ae2c:	00c12083          	lw	ra,12(sp)
4000ae30:	00812403          	lw	s0,8(sp)
4000ae34:	01010113          	addi	sp,sp,16
4000ae38:	00008067          	ret

4000ae3c <panic>:
{
4000ae3c:	ff010113          	addi	sp,sp,-16
4000ae40:	00112623          	sw	ra,12(sp)
4000ae44:	00812423          	sw	s0,8(sp)
	const struct shell *sh = (const struct shell *)backend->cb->ctx;
4000ae48:	00452783          	lw	a5,4(a0)
	err = sh->iface->api->enable(sh->iface, true);
4000ae4c:	00100593          	li	a1,1
	const struct shell *sh = (const struct shell *)backend->cb->ctx;
4000ae50:	0007a403          	lw	s0,0(a5)
	err = sh->iface->api->enable(sh->iface, true);
4000ae54:	00442503          	lw	a0,4(s0)
4000ae58:	00052783          	lw	a5,0(a0)
4000ae5c:	0087a783          	lw	a5,8(a5)
4000ae60:	000780e7          	jalr	a5
	if (err == 0) {
4000ae64:	01c42783          	lw	a5,28(s0)
4000ae68:	06051863          	bnez	a0,4000aed8 <panic+0x9c>
		sh->log_backend->control_block->state =
4000ae6c:	0087a783          	lw	a5,8(a5)
4000ae70:	00300713          	li	a4,3
4000ae74:	00e7a223          	sw	a4,4(a5)
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, sync_mode, val, ret);
4000ae78:	00842503          	lw	a0,8(s0)
4000ae7c:	27050513          	addi	a0,a0,624
	return z_impl_atomic_or(target, value);
4000ae80:	000025b7          	lui	a1,0x2
4000ae84:	429260ef          	jal	ra,40031aac <z_impl_atomic_or>
		z_shell_multiline_data_calc(&sh->ctx->vt100_ctx.cons,
4000ae88:	00842503          	lw	a0,8(s0)
4000ae8c:	04855603          	lhu	a2,72(a0)
4000ae90:	04a55583          	lhu	a1,74(a0)
4000ae94:	02450513          	addi	a0,a0,36
4000ae98:	d58fe0ef          	jal	ra,400093f0 <z_shell_multiline_data_calc>
		z_shell_op_cursor_vert_move(sh, -1);
4000ae9c:	fff00593          	li	a1,-1
4000aea0:	00040513          	mv	a0,s0
4000aea4:	ef5fe0ef          	jal	ra,40009d98 <z_shell_op_cursor_vert_move>
					   -sh->ctx->vt100_ctx.cons.cur_x);
4000aea8:	00842783          	lw	a5,8(s0)
		z_shell_op_cursor_horiz_move(sh,
4000aeac:	00040513          	mv	a0,s0
					   -sh->ctx->vt100_ctx.cons.cur_x);
4000aeb0:	0247d583          	lhu	a1,36(a5)
		z_shell_op_cursor_horiz_move(sh,
4000aeb4:	40b005b3          	neg	a1,a1
4000aeb8:	f25fe0ef          	jal	ra,40009ddc <z_shell_op_cursor_horiz_move>
		while (process_msg_from_buffer(sh)) {
4000aebc:	00040513          	mv	a0,s0
4000aec0:	b8dff0ef          	jal	ra,4000aa4c <process_msg_from_buffer>
4000aec4:	fe051ce3          	bnez	a0,4000aebc <panic+0x80>
}
4000aec8:	00c12083          	lw	ra,12(sp)
4000aecc:	00812403          	lw	s0,8(sp)
4000aed0:	01010113          	addi	sp,sp,16
4000aed4:	00008067          	ret
4000aed8:	00812403          	lw	s0,8(sp)
4000aedc:	00c12083          	lw	ra,12(sp)
		z_shell_log_backend_disable(sh->log_backend);
4000aee0:	00078513          	mv	a0,a5
}
4000aee4:	01010113          	addi	sp,sp,16
		z_shell_log_backend_disable(sh->log_backend);
4000aee8:	f21ff06f          	j	4000ae08 <z_shell_log_backend_disable>

4000aeec <z_shell_log_backend_process>:
{
4000aeec:	fd010113          	addi	sp,sp,-48
4000aef0:	02812423          	sw	s0,40(sp)
4000aef4:	02112623          	sw	ra,44(sp)
4000aef8:	02912223          	sw	s1,36(sp)
4000aefc:	03212023          	sw	s2,32(sp)
4000af00:	01312e23          	sw	s3,28(sp)
			(const struct shell *)backend->backend->cb->ctx;
4000af04:	00052783          	lw	a5,0(a0)
{
4000af08:	00050413          	mv	s0,a0
	dropped = atomic_set(&backend->control_block->dropped_cnt, 0);
4000af0c:	00852503          	lw	a0,8(a0)
	const struct shell *sh =
4000af10:	0047a783          	lw	a5,4(a5)
4000af14:	0007a483          	lw	s1,0(a5)
	return sh->ctx->cfg.flags.use_colors == 1;
4000af18:	0084a783          	lw	a5,8(s1)
4000af1c:	26c7a983          	lw	s3,620(a5)
	return z_impl_atomic_set(target, value);
4000af20:	00000593          	li	a1,0
4000af24:	36d260ef          	jal	ra,40031a90 <z_impl_atomic_set>
	if (dropped) {
4000af28:	02050063          	beqz	a0,4000af48 <z_shell_log_backend_process+0x5c>
4000af2c:	0049d993          	srli	s3,s3,0x4
4000af30:	0019f993          	andi	s3,s3,1
4000af34:	00050913          	mv	s2,a0
		if (colors) {
4000af38:	02099863          	bnez	s3,4000af68 <z_shell_log_backend_process+0x7c>
		log_output_dropped_process(backend->log_output, dropped);
4000af3c:	00050593          	mv	a1,a0
4000af40:	00442503          	lw	a0,4(s0)
4000af44:	995fa0ef          	jal	ra,400058d8 <log_output_dropped_process>
}
4000af48:	02812403          	lw	s0,40(sp)
4000af4c:	02c12083          	lw	ra,44(sp)
4000af50:	02012903          	lw	s2,32(sp)
4000af54:	01c12983          	lw	s3,28(sp)
	return process_msg_from_buffer(sh);
4000af58:	00048513          	mv	a0,s1
}
4000af5c:	02412483          	lw	s1,36(sp)
4000af60:	03010113          	addi	sp,sp,48
	return process_msg_from_buffer(sh);
4000af64:	ae9ff06f          	j	4000aa4c <process_msg_from_buffer>
	memcpy(color, &sh->ctx->vt100_ctx.col, sizeof(*color));
4000af68:	0084a583          	lw	a1,8(s1)
4000af6c:	00800613          	li	a2,8
4000af70:	00810513          	addi	a0,sp,8
4000af74:	03458593          	addi	a1,a1,52 # 2034 <CONFIG_SRAM_SIZE+0x34>
4000af78:	581010ef          	jal	ra,4000ccf8 <memcpy>
			z_shell_vt100_color_set(sh, SHELL_VT100_COLOR_RED);
4000af7c:	00048513          	mv	a0,s1
4000af80:	00100593          	li	a1,1
4000af84:	b9cff0ef          	jal	ra,4000a320 <z_shell_vt100_color_set>
		log_output_dropped_process(backend->log_output, dropped);
4000af88:	00442503          	lw	a0,4(s0)
4000af8c:	00090593          	mv	a1,s2
4000af90:	949fa0ef          	jal	ra,400058d8 <log_output_dropped_process>
			z_shell_vt100_colors_restore(sh, &col);
4000af94:	00810593          	addi	a1,sp,8
4000af98:	00048513          	mv	a0,s1
4000af9c:	be0ff0ef          	jal	ra,4000a37c <z_shell_vt100_colors_restore>
4000afa0:	fa9ff06f          	j	4000af48 <z_shell_log_backend_process+0x5c>

4000afa4 <z_shell_raw_fprintf>:
{
4000afa4:	fc010113          	addi	sp,sp,-64
4000afa8:	02c12423          	sw	a2,40(sp)
	va_start(args, fmt);
4000afac:	02810613          	addi	a2,sp,40
{
4000afb0:	00112e23          	sw	ra,28(sp)
4000afb4:	02d12623          	sw	a3,44(sp)
4000afb8:	02e12823          	sw	a4,48(sp)
4000afbc:	02f12a23          	sw	a5,52(sp)
4000afc0:	03012c23          	sw	a6,56(sp)
4000afc4:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
4000afc8:	00c12623          	sw	a2,12(sp)
	z_shell_fprintf_fmt(ctx, fmt, args);
4000afcc:	ab4fe0ef          	jal	ra,40009280 <z_shell_fprintf_fmt>
}
4000afd0:	01c12083          	lw	ra,28(sp)
4000afd4:	04010113          	addi	sp,sp,64
4000afd8:	00008067          	ret

4000afdc <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
4000afdc:	400335b7          	lui	a1,0x40033
4000afe0:	bf458593          	addi	a1,a1,-1036 # 40032bf4 <severity+0x88>
4000afe4:	fc1ff06f          	j	4000afa4 <z_shell_raw_fprintf>

4000afe8 <formatted_text_print.constprop.0>:
				 size_t terminal_offset, bool offset_first_line)
{
	size_t offset = 0;
	size_t length;

	if (str == NULL) {
4000afe8:	1a058c63          	beqz	a1,4000b1a0 <formatted_text_print.constprop.0+0x1b8>
static void formatted_text_print(const struct shell *sh, const char *str,
4000afec:	fc010113          	addi	sp,sp,-64
4000aff0:	02812c23          	sw	s0,56(sp)
4000aff4:	02912a23          	sw	s1,52(sp)
4000aff8:	03312623          	sw	s3,44(sp)
4000affc:	03412423          	sw	s4,40(sp)
4000b000:	02112e23          	sw	ra,60(sp)
4000b004:	03212823          	sw	s2,48(sp)
4000b008:	03512223          	sw	s5,36(sp)
4000b00c:	03612023          	sw	s6,32(sp)
4000b010:	01712e23          	sw	s7,28(sp)
4000b014:	01812c23          	sw	s8,24(sp)
4000b018:	00050493          	mv	s1,a0
4000b01c:	00058993          	mv	s3,a1
4000b020:	00060a13          	mv	s4,a2
4000b024:	00000413          	li	s0,0
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
4000b028:	02000713          	li	a4,32
4000b02c:	00400693          	li	a3,4
		z_shell_op_cursor_horiz_move(sh, terminal_offset);
	}


	/* Skipping whitespace. */
	while (isspace((int) *(str + offset)) != 0) {
4000b030:	008987b3          	add	a5,s3,s0
4000b034:	0007c783          	lbu	a5,0(a5)
4000b038:	06e78a63          	beq	a5,a4,4000b0ac <formatted_text_print.constprop.0+0xc4>
4000b03c:	ff778793          	addi	a5,a5,-9
4000b040:	06f6f663          	bgeu	a3,a5,4000b0ac <formatted_text_print.constprop.0+0xc4>
	}

	while (true) {
		size_t idx = 0;

		length = z_shell_strlen(str) - offset;
4000b044:	00010ab7          	lui	s5,0x10
4000b048:	fffa8a93          	addi	s5,s5,-1 # ffff <__kernel_ram_size+0x44f7>
4000b04c:	02000b13          	li	s6,32
4000b050:	00400b93          	li	s7,4

		while (true) {
			/* Determining line break. */
			if (isspace((int) (*(str + offset + idx))) != 0) {
				length = idx;
				if (*(str + offset + idx) == '\n') {
4000b054:	00a00c13          	li	s8,10
4000b058:	00098513          	mv	a0,s3
4000b05c:	379010ef          	jal	ra,4000cbd4 <strlen>
		    sh->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
4000b060:	0084a783          	lw	a5,8(s1)
		length = z_shell_strlen(str) - offset;
4000b064:	01557533          	and	a0,a0,s5
4000b068:	40850533          	sub	a0,a0,s0
		    sh->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
4000b06c:	02e7d683          	lhu	a3,46(a5)
4000b070:	008985b3          	add	a1,s3,s0
			for (idx = 0; idx < length; idx++) {
4000b074:	00000913          	li	s2,0
		    sh->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
4000b078:	414687b3          	sub	a5,a3,s4
		if (length <=
4000b07c:	0ca7f263          	bgeu	a5,a0,4000b140 <formatted_text_print.constprop.0+0x158>
			if (isspace((int) (*(str + offset + idx))) != 0) {
4000b080:	01258733          	add	a4,a1,s2
4000b084:	00074703          	lbu	a4,0(a4)
4000b088:	01670863          	beq	a4,s6,4000b098 <formatted_text_print.constprop.0+0xb0>
4000b08c:	ff770613          	addi	a2,a4,-9
4000b090:	00cbe663          	bltu	s7,a2,4000b09c <formatted_text_print.constprop.0+0xb4>
				if (*(str + offset + idx) == '\n') {
4000b094:	0b870c63          	beq	a4,s8,4000b14c <formatted_text_print.constprop.0+0x164>
4000b098:	00090793          	mv	a5,s2
					break;
				}
			}

			if ((idx + terminal_offset) >=
4000b09c:	012a0733          	add	a4,s4,s2
4000b0a0:	0ad77463          	bgeu	a4,a3,4000b148 <formatted_text_print.constprop.0+0x160>
			    sh->ctx->vt100_ctx.cons.terminal_wid) {
				/* End of line reached. */
				break;
			}

			++idx;
4000b0a4:	00190913          	addi	s2,s2,1
			if (isspace((int) (*(str + offset + idx))) != 0) {
4000b0a8:	fd9ff06f          	j	4000b080 <formatted_text_print.constprop.0+0x98>
		++offset;
4000b0ac:	00140413          	addi	s0,s0,1
4000b0b0:	f81ff06f          	j	4000b030 <formatted_text_print.constprop.0+0x48>
			for (idx = 0; idx < length; idx++) {
4000b0b4:	00190913          	addi	s2,s2,1
4000b0b8:	05250463          	beq	a0,s2,4000b100 <formatted_text_print.constprop.0+0x118>
				if (*(str + offset + idx) == '\n') {
4000b0bc:	01258733          	add	a4,a1,s2
4000b0c0:	00074703          	lbu	a4,0(a4)
4000b0c4:	fef718e3          	bne	a4,a5,4000b0b4 <formatted_text_print.constprop.0+0xcc>
	z_shell_fprintf_buffer_flush(sh->fprintf_ctx);
4000b0c8:	0144a503          	lw	a0,20(s1)
4000b0cc:	00b12623          	sw	a1,12(sp)
4000b0d0:	00140413          	addi	s0,s0,1
4000b0d4:	96cfe0ef          	jal	ra,40009240 <z_shell_fprintf_buffer_flush>
					z_shell_write(sh, str + offset, idx);
4000b0d8:	00c12583          	lw	a1,12(sp)
4000b0dc:	00090613          	mv	a2,s2
4000b0e0:	00048513          	mv	a0,s1
4000b0e4:	948ff0ef          	jal	ra,4000a22c <z_shell_write>
					z_cursor_next_line_move(sh);
4000b0e8:	0144a503          	lw	a0,20(s1)
					offset += idx + 1;
4000b0ec:	00890433          	add	s0,s2,s0
					z_cursor_next_line_move(sh);
4000b0f0:	eedff0ef          	jal	ra,4000afdc <z_cursor_next_line_move.isra.0>
					z_shell_op_cursor_horiz_move(sh,
4000b0f4:	000a0593          	mv	a1,s4
4000b0f8:	00048513          	mv	a0,s1
4000b0fc:	ce1fe0ef          	jal	ra,40009ddc <z_shell_op_cursor_horiz_move>
			z_shell_raw_fprintf(sh->fprintf_ctx, str + offset);
4000b100:	0144a503          	lw	a0,20(s1)
4000b104:	008985b3          	add	a1,s3,s0
4000b108:	e9dff0ef          	jal	ra,4000afa4 <z_shell_raw_fprintf>
		z_cursor_next_line_move(sh);
		z_shell_op_cursor_horiz_move(sh, terminal_offset);

	}
	z_cursor_next_line_move(sh);
}
4000b10c:	03812403          	lw	s0,56(sp)
	z_cursor_next_line_move(sh);
4000b110:	0144a503          	lw	a0,20(s1)
}
4000b114:	03c12083          	lw	ra,60(sp)
4000b118:	03412483          	lw	s1,52(sp)
4000b11c:	03012903          	lw	s2,48(sp)
4000b120:	02c12983          	lw	s3,44(sp)
4000b124:	02812a03          	lw	s4,40(sp)
4000b128:	02412a83          	lw	s5,36(sp)
4000b12c:	02012b03          	lw	s6,32(sp)
4000b130:	01c12b83          	lw	s7,28(sp)
4000b134:	01812c03          	lw	s8,24(sp)
4000b138:	04010113          	addi	sp,sp,64
	z_cursor_next_line_move(sh);
4000b13c:	ea1ff06f          	j	4000afdc <z_cursor_next_line_move.isra.0>
				if (*(str + offset + idx) == '\n') {
4000b140:	00a00793          	li	a5,10
4000b144:	f75ff06f          	j	4000b0b8 <formatted_text_print.constprop.0+0xd0>
4000b148:	00078913          	mv	s2,a5
4000b14c:	0144a503          	lw	a0,20(s1)
4000b150:	00b12623          	sw	a1,12(sp)
		offset += length;
4000b154:	01240433          	add	s0,s0,s2
4000b158:	8e8fe0ef          	jal	ra,40009240 <z_shell_fprintf_buffer_flush>
		z_shell_write(sh, str + offset, length);
4000b15c:	00c12583          	lw	a1,12(sp)
4000b160:	00090613          	mv	a2,s2
4000b164:	00048513          	mv	a0,s1
4000b168:	8c4ff0ef          	jal	ra,4000a22c <z_shell_write>
		while (isspace((int) (*(str + offset))) != 0) {
4000b16c:	008987b3          	add	a5,s3,s0
4000b170:	0007c783          	lbu	a5,0(a5)
4000b174:	01678663          	beq	a5,s6,4000b180 <formatted_text_print.constprop.0+0x198>
4000b178:	ff778793          	addi	a5,a5,-9
4000b17c:	00fbe663          	bltu	s7,a5,4000b188 <formatted_text_print.constprop.0+0x1a0>
			++offset;
4000b180:	00140413          	addi	s0,s0,1
4000b184:	fe9ff06f          	j	4000b16c <formatted_text_print.constprop.0+0x184>
		z_cursor_next_line_move(sh);
4000b188:	0144a503          	lw	a0,20(s1)
4000b18c:	e51ff0ef          	jal	ra,4000afdc <z_cursor_next_line_move.isra.0>
		z_shell_op_cursor_horiz_move(sh, terminal_offset);
4000b190:	000a0593          	mv	a1,s4
4000b194:	00048513          	mv	a0,s1
4000b198:	c45fe0ef          	jal	ra,40009ddc <z_shell_op_cursor_horiz_move>
	while (true) {
4000b19c:	ebdff06f          	j	4000b058 <formatted_text_print.constprop.0+0x70>
4000b1a0:	00008067          	ret

4000b1a4 <z_shell_help_subcmd_print>:
 * help string
 */
void z_shell_help_subcmd_print(const struct shell *sh,
			       const struct shell_static_entry *parent,
			       const char *description)
{
4000b1a4:	fa010113          	addi	sp,sp,-96
4000b1a8:	04812c23          	sw	s0,88(sp)
4000b1ac:	04912a23          	sw	s1,84(sp)
4000b1b0:	05212823          	sw	s2,80(sp)
4000b1b4:	05312623          	sw	s3,76(sp)
4000b1b8:	04112e23          	sw	ra,92(sp)
4000b1bc:	00058993          	mv	s3,a1
4000b1c0:	05412423          	sw	s4,72(sp)
4000b1c4:	05512223          	sw	s5,68(sp)
4000b1c8:	05612023          	sw	s6,64(sp)
4000b1cc:	03712e23          	sw	s7,60(sp)
4000b1d0:	03812c23          	sw	s8,56(sp)
4000b1d4:	03912a23          	sw	s9,52(sp)
4000b1d8:	00050413          	mv	s0,a0
4000b1dc:	00060493          	mv	s1,a2
	const struct shell_static_entry *entry = NULL;
	struct shell_static_entry dloc;
	uint16_t longest = 0U;
	size_t idx = 0;
4000b1e0:	00000593          	li	a1,0
	uint16_t longest = 0U;
4000b1e4:	00000913          	li	s2,0

	/* Searching for the longest subcommand to print. */
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
4000b1e8:	01c10613          	addi	a2,sp,28
4000b1ec:	00098513          	mv	a0,s3
4000b1f0:	00158a13          	addi	s4,a1,1
4000b1f4:	e28fe0ef          	jal	ra,4000981c <z_shell_cmd_get>
4000b1f8:	06051c63          	bnez	a0,4000b270 <z_shell_help_subcmd_print+0xcc>
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
	}

	/* No help to print */
	if (longest == 0) {
4000b1fc:	04090063          	beqz	s2,4000b23c <z_shell_help_subcmd_print+0x98>
		return;
	}

	if (description != NULL) {
4000b200:	00048a63          	beqz	s1,4000b214 <z_shell_help_subcmd_print+0x70>
		z_shell_fprintf(sh, SHELL_NORMAL, description);
4000b204:	00048613          	mv	a2,s1
4000b208:	00800593          	li	a1,8
4000b20c:	00040513          	mv	a0,s0
4000b210:	ab0ff0ef          	jal	ra,4000a4c0 <z_shell_fprintf>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
4000b214:	00000593          	li	a1,0
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
4000b218:	40032a37          	lui	s4,0x40032
		z_shell_fprintf(sh, SHELL_NORMAL, "%s%-*s", tabulator,
4000b21c:	40034bb7          	lui	s7,0x40034
		z_shell_fprintf(sh, SHELL_NORMAL, "%s:", tabulator);
4000b220:	40034c37          	lui	s8,0x40034
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
4000b224:	00190c93          	addi	s9,s2,1
	}

	/* Printing subcommands and help string (if exists). */
	idx = 0;

	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
4000b228:	01c10613          	addi	a2,sp,28
4000b22c:	00098513          	mv	a0,s3
4000b230:	00158b13          	addi	s6,a1,1
4000b234:	de8fe0ef          	jal	ra,4000981c <z_shell_cmd_get>
4000b238:	06051663          	bnez	a0,4000b2a4 <z_shell_help_subcmd_print+0x100>
		help_item_print(sh, entry->syntax, longest, entry->help);
	}
}
4000b23c:	05c12083          	lw	ra,92(sp)
4000b240:	05812403          	lw	s0,88(sp)
4000b244:	05412483          	lw	s1,84(sp)
4000b248:	05012903          	lw	s2,80(sp)
4000b24c:	04c12983          	lw	s3,76(sp)
4000b250:	04812a03          	lw	s4,72(sp)
4000b254:	04412a83          	lw	s5,68(sp)
4000b258:	04012b03          	lw	s6,64(sp)
4000b25c:	03c12b83          	lw	s7,60(sp)
4000b260:	03812c03          	lw	s8,56(sp)
4000b264:	03412c83          	lw	s9,52(sp)
4000b268:	06010113          	addi	sp,sp,96
4000b26c:	00008067          	ret
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
4000b270:	00052503          	lw	a0,0(a0)
	return str == NULL ? 0U : (uint16_t)strlen(str);
4000b274:	00000793          	li	a5,0
4000b278:	00050863          	beqz	a0,4000b288 <z_shell_help_subcmd_print+0xe4>
4000b27c:	159010ef          	jal	ra,4000cbd4 <strlen>
4000b280:	01051793          	slli	a5,a0,0x10
4000b284:	0107d793          	srli	a5,a5,0x10
4000b288:	00090713          	mv	a4,s2
4000b28c:	00f97463          	bgeu	s2,a5,4000b294 <z_shell_help_subcmd_print+0xf0>
4000b290:	00078713          	mv	a4,a5
4000b294:	01071913          	slli	s2,a4,0x10
4000b298:	01095913          	srli	s2,s2,0x10
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
4000b29c:	000a0593          	mv	a1,s4
4000b2a0:	f49ff06f          	j	4000b1e8 <z_shell_help_subcmd_print+0x44>
		help_item_print(sh, entry->syntax, longest, entry->help);
4000b2a4:	00052783          	lw	a5,0(a0)
4000b2a8:	00452a83          	lw	s5,4(a0)
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
4000b2ac:	5c4a0513          	addi	a0,s4,1476 # 400325c4 <tabulator.1>
		help_item_print(sh, entry->syntax, longest, entry->help);
4000b2b0:	00f12623          	sw	a5,12(sp)
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
4000b2b4:	121010ef          	jal	ra,4000cbd4 <strlen>
	if ((item_name == NULL) || (item_name[0] == '\0')) {
4000b2b8:	00c12783          	lw	a5,12(sp)
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
4000b2bc:	00050493          	mv	s1,a0
	if ((item_name == NULL) || (item_name[0] == '\0')) {
4000b2c0:	02078863          	beqz	a5,4000b2f0 <z_shell_help_subcmd_print+0x14c>
4000b2c4:	0007c703          	lbu	a4,0(a5)
4000b2c8:	02070463          	beqz	a4,4000b2f0 <z_shell_help_subcmd_print+0x14c>
		z_shell_fprintf(sh, SHELL_NORMAL, "%s%-*s", tabulator,
4000b2cc:	00090713          	mv	a4,s2
4000b2d0:	5c4a0693          	addi	a3,s4,1476
4000b2d4:	e6cb8613          	addi	a2,s7,-404 # 40033e6c <log_backend_shell_api+0x1c>
4000b2d8:	00800593          	li	a1,8
4000b2dc:	00040513          	mv	a0,s0
4000b2e0:	9e0ff0ef          	jal	ra,4000a4c0 <z_shell_fprintf>
	if (item_help == NULL) {
4000b2e4:	000a9a63          	bnez	s5,4000b2f8 <z_shell_help_subcmd_print+0x154>
		z_cursor_next_line_move(sh);
4000b2e8:	01442503          	lw	a0,20(s0)
4000b2ec:	cf1ff0ef          	jal	ra,4000afdc <z_cursor_next_line_move.isra.0>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
4000b2f0:	000b0593          	mv	a1,s6
4000b2f4:	f35ff06f          	j	4000b228 <z_shell_help_subcmd_print+0x84>
		z_shell_fprintf(sh, SHELL_NORMAL, "%s:", tabulator);
4000b2f8:	e74c0613          	addi	a2,s8,-396 # 40033e74 <log_backend_shell_api+0x24>
4000b2fc:	00040513          	mv	a0,s0
4000b300:	5c4a0693          	addi	a3,s4,1476
4000b304:	00800593          	li	a1,8
4000b308:	9b8ff0ef          	jal	ra,4000a4c0 <z_shell_fprintf>
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
4000b30c:	00149613          	slli	a2,s1,0x1
4000b310:	01960633          	add	a2,a2,s9
	formatted_text_print(sh, item_help, offset, false);
4000b314:	01061613          	slli	a2,a2,0x10
4000b318:	01065613          	srli	a2,a2,0x10
4000b31c:	000a8593          	mv	a1,s5
4000b320:	00040513          	mv	a0,s0
4000b324:	cc5ff0ef          	jal	ra,4000afe8 <formatted_text_print.constprop.0>
4000b328:	fc9ff06f          	j	4000b2f0 <z_shell_help_subcmd_print+0x14c>

4000b32c <z_shell_help_cmd_print>:

void z_shell_help_cmd_print(const struct shell *sh,
			    const struct shell_static_entry *cmd)
{
4000b32c:	fe010113          	addi	sp,sp,-32
4000b330:	00812c23          	sw	s0,24(sp)
4000b334:	00912a23          	sw	s1,20(sp)
4000b338:	01212823          	sw	s2,16(sp)
4000b33c:	00112e23          	sw	ra,28(sp)
4000b340:	01312623          	sw	s3,12(sp)
4000b344:	00050913          	mv	s2,a0
	static const char cmd_sep[] = " - "; /* commands separator */
	uint16_t field_width;

	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
4000b348:	0005a503          	lw	a0,0(a1)
{
4000b34c:	00058493          	mv	s1,a1
4000b350:	00000413          	li	s0,0
4000b354:	00050863          	beqz	a0,4000b364 <z_shell_help_cmd_print+0x38>
4000b358:	07d010ef          	jal	ra,4000cbd4 <strlen>
4000b35c:	01051413          	slli	s0,a0,0x10
4000b360:	01045413          	srli	s0,s0,0x10
4000b364:	400329b7          	lui	s3,0x40032
4000b368:	5c098513          	addi	a0,s3,1472 # 400325c0 <cmd_sep.0>
4000b36c:	069010ef          	jal	ra,4000cbd4 <strlen>

	z_shell_fprintf(sh, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
4000b370:	0004a683          	lw	a3,0(s1)
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
4000b374:	00a40433          	add	s0,s0,a0
	z_shell_fprintf(sh, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
4000b378:	40034637          	lui	a2,0x40034
4000b37c:	00090513          	mv	a0,s2
4000b380:	5c098713          	addi	a4,s3,1472
4000b384:	e7860613          	addi	a2,a2,-392 # 40033e78 <log_backend_shell_api+0x28>
4000b388:	00800593          	li	a1,8
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
4000b38c:	01041413          	slli	s0,s0,0x10
	z_shell_fprintf(sh, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
4000b390:	930ff0ef          	jal	ra,4000a4c0 <z_shell_fprintf>
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
4000b394:	01045413          	srli	s0,s0,0x10

	formatted_text_print(sh, cmd->help, field_width, false);
4000b398:	00040613          	mv	a2,s0
}
4000b39c:	01812403          	lw	s0,24(sp)
	formatted_text_print(sh, cmd->help, field_width, false);
4000b3a0:	0044a583          	lw	a1,4(s1)
}
4000b3a4:	01c12083          	lw	ra,28(sp)
4000b3a8:	01412483          	lw	s1,20(sp)
4000b3ac:	00c12983          	lw	s3,12(sp)
	formatted_text_print(sh, cmd->help, field_width, false);
4000b3b0:	00090513          	mv	a0,s2
}
4000b3b4:	01012903          	lw	s2,16(sp)
4000b3b8:	02010113          	addi	sp,sp,32
	formatted_text_print(sh, cmd->help, field_width, false);
4000b3bc:	c2dff06f          	j	4000afe8 <formatted_text_print.constprop.0>

4000b3c0 <z_shell_help_request>:
{
	if (!IS_ENABLED(CONFIG_SHELL_HELP_OPT_PARSE)) {
		return false;
	}

	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
4000b3c0:	400345b7          	lui	a1,0x40034
{
4000b3c4:	ff010113          	addi	sp,sp,-16
	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
4000b3c8:	e8058593          	addi	a1,a1,-384 # 40033e80 <log_backend_shell_api+0x30>
{
4000b3cc:	00812423          	sw	s0,8(sp)
4000b3d0:	00112623          	sw	ra,12(sp)
4000b3d4:	00050413          	mv	s0,a0
	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
4000b3d8:	041010ef          	jal	ra,4000cc18 <strcmp>
4000b3dc:	02050463          	beqz	a0,4000b404 <z_shell_help_request+0x44>
4000b3e0:	400345b7          	lui	a1,0x40034
4000b3e4:	e8458593          	addi	a1,a1,-380 # 40033e84 <log_backend_shell_api+0x34>
4000b3e8:	00040513          	mv	a0,s0
4000b3ec:	02d010ef          	jal	ra,4000cc18 <strcmp>
4000b3f0:	00153513          	seqz	a0,a0
		return true;
	}

	return false;
}
4000b3f4:	00c12083          	lw	ra,12(sp)
4000b3f8:	00812403          	lw	s0,8(sp)
4000b3fc:	01010113          	addi	sp,sp,16
4000b400:	00008067          	ret
		return true;
4000b404:	00100513          	li	a0,1
4000b408:	fedff06f          	j	4000b3f4 <z_shell_help_request+0x34>

4000b40c <cmd_shell_stats_reset>:
				 size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	sh->stats->log_lost_cnt = 0;
4000b40c:	01852783          	lw	a5,24(a0)

	return 0;
}
4000b410:	00000513          	li	a0,0
	sh->stats->log_lost_cnt = 0;
4000b414:	0007a023          	sw	zero,0(a5)
}
4000b418:	00008067          	ret

4000b41c <z_shell_raw_fprintf>:
{
4000b41c:	fc010113          	addi	sp,sp,-64
4000b420:	02c12423          	sw	a2,40(sp)
	va_start(args, fmt);
4000b424:	02810613          	addi	a2,sp,40
{
4000b428:	00112e23          	sw	ra,28(sp)
4000b42c:	02d12623          	sw	a3,44(sp)
4000b430:	02e12823          	sw	a4,48(sp)
4000b434:	02f12a23          	sw	a5,52(sp)
4000b438:	03012c23          	sw	a6,56(sp)
4000b43c:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
4000b440:	00c12623          	sw	a2,12(sp)
	z_shell_fprintf_fmt(ctx, fmt, args);
4000b444:	e3dfd0ef          	jal	ra,40009280 <z_shell_fprintf_fmt>
}
4000b448:	01c12083          	lw	ra,28(sp)
4000b44c:	04010113          	addi	sp,sp,64
4000b450:	00008067          	ret

4000b454 <cmd_resize_default>:

static int cmd_resize_default(const struct shell *sh,
			      size_t argc, char **argv)
{
4000b454:	ff010113          	addi	sp,sp,-16
4000b458:	00812423          	sw	s0,8(sp)
4000b45c:	00112623          	sw	ra,12(sp)
	return sh->ctx->cfg.flags.use_vt100 == 1;
4000b460:	00852783          	lw	a5,8(a0)
4000b464:	00050413          	mv	s0,a0
4000b468:	26c7a783          	lw	a5,620(a5)
4000b46c:	0057d793          	srli	a5,a5,0x5
4000b470:	0017f793          	andi	a5,a5,1
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SETCOL_80);
4000b474:	00078a63          	beqz	a5,4000b488 <cmd_resize_default+0x34>
4000b478:	01452503          	lw	a0,20(a0)
4000b47c:	400325b7          	lui	a1,0x40032
4000b480:	6d058593          	addi	a1,a1,1744 # 400326d0 <eth_config+0x34>
4000b484:	f99ff0ef          	jal	ra,4000b41c <z_shell_raw_fprintf>
	sh->ctx->vt100_ctx.cons.terminal_wid = SHELL_DEFAULT_TERMINAL_WIDTH;
4000b488:	00842783          	lw	a5,8(s0)
4000b48c:	05000713          	li	a4,80
	sh->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;

	return 0;
}
4000b490:	00000513          	li	a0,0
	sh->ctx->vt100_ctx.cons.terminal_wid = SHELL_DEFAULT_TERMINAL_WIDTH;
4000b494:	02e79723          	sh	a4,46(a5)
	sh->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
4000b498:	00842783          	lw	a5,8(s0)
4000b49c:	01800713          	li	a4,24
4000b4a0:	02e79623          	sh	a4,44(a5)
}
4000b4a4:	00c12083          	lw	ra,12(sp)
4000b4a8:	00812403          	lw	s0,8(sp)
4000b4ac:	01010113          	addi	sp,sp,16
4000b4b0:	00008067          	ret

4000b4b4 <cmd_shell_stats_show>:
{
4000b4b4:	ff010113          	addi	sp,sp,-16
4000b4b8:	00112623          	sw	ra,12(sp)
	shell_print(sh, "Lost logs: %lu", sh->stats->log_lost_cnt);
4000b4bc:	01852783          	lw	a5,24(a0)
4000b4c0:	40034637          	lui	a2,0x40034
4000b4c4:	e8c60613          	addi	a2,a2,-372 # 40033e8c <log_backend_shell_api+0x3c>
4000b4c8:	0007a683          	lw	a3,0(a5)
4000b4cc:	00800593          	li	a1,8
4000b4d0:	a1dfd0ef          	jal	ra,40008eec <shell_fprintf>
}
4000b4d4:	00c12083          	lw	ra,12(sp)
4000b4d8:	00000513          	li	a0,0
4000b4dc:	01010113          	addi	sp,sp,16
4000b4e0:	00008067          	ret

4000b4e4 <cmd_backends>:
	shell_print(sh, "Active shell backends:");
4000b4e4:	40034637          	lui	a2,0x40034
{
4000b4e8:	fe010113          	addi	sp,sp,-32
	shell_print(sh, "Active shell backends:");
4000b4ec:	e9c60613          	addi	a2,a2,-356 # 40033e9c <log_backend_shell_api+0x4c>
4000b4f0:	00800593          	li	a1,8
{
4000b4f4:	00812c23          	sw	s0,24(sp)
4000b4f8:	00912a23          	sw	s1,20(sp)
4000b4fc:	01212823          	sw	s2,16(sp)
4000b500:	01412423          	sw	s4,8(sp)
4000b504:	00112e23          	sw	ra,28(sp)
4000b508:	01312623          	sw	s3,12(sp)
4000b50c:	00050913          	mv	s2,a0
	STRUCT_SECTION_FOREACH(shell, obj) {
4000b510:	40032437          	lui	s0,0x40032
	shell_print(sh, "Active shell backends:");
4000b514:	9d9fd0ef          	jal	ra,40008eec <shell_fprintf>
	STRUCT_SECTION_FOREACH(shell, obj) {
4000b518:	400324b7          	lui	s1,0x40032
4000b51c:	51c40413          	addi	s0,s0,1308 # 4003251c <shell_uart>
	uint16_t cnt = 0;
4000b520:	00000693          	li	a3,0
	STRUCT_SECTION_FOREACH(shell, obj) {
4000b524:	54c48493          	addi	s1,s1,1356 # 4003254c <shell_cmd_clear>
		shell_print(sh, "  %2d. :%s", cnt++, obj->ctx->prompt);
4000b528:	40034a37          	lui	s4,0x40034
	STRUCT_SECTION_FOREACH(shell, obj) {
4000b52c:	02946463          	bltu	s0,s1,4000b554 <cmd_backends+0x70>
}
4000b530:	01c12083          	lw	ra,28(sp)
4000b534:	01812403          	lw	s0,24(sp)
4000b538:	01412483          	lw	s1,20(sp)
4000b53c:	01012903          	lw	s2,16(sp)
4000b540:	00c12983          	lw	s3,12(sp)
4000b544:	00812a03          	lw	s4,8(sp)
4000b548:	00000513          	li	a0,0
4000b54c:	02010113          	addi	sp,sp,32
4000b550:	00008067          	ret
		shell_print(sh, "  %2d. :%s", cnt++, obj->ctx->prompt);
4000b554:	00842783          	lw	a5,8(s0)
4000b558:	00168993          	addi	s3,a3,1
4000b55c:	01099993          	slli	s3,s3,0x10
4000b560:	0007a703          	lw	a4,0(a5)
4000b564:	eb4a0613          	addi	a2,s4,-332 # 40033eb4 <log_backend_shell_api+0x64>
4000b568:	00800593          	li	a1,8
4000b56c:	00090513          	mv	a0,s2
4000b570:	0109d993          	srli	s3,s3,0x10
4000b574:	979fd0ef          	jal	ra,40008eec <shell_fprintf>
	STRUCT_SECTION_FOREACH(shell, obj) {
4000b578:	03040413          	addi	s0,s0,48
		shell_print(sh, "  %2d. :%s", cnt++, obj->ctx->prompt);
4000b57c:	00098693          	mv	a3,s3
4000b580:	fadff06f          	j	4000b52c <cmd_backends+0x48>

4000b584 <cmd_history>:
{
4000b584:	fe010113          	addi	sp,sp,-32
4000b588:	00812c23          	sw	s0,24(sp)
4000b58c:	00912a23          	sw	s1,20(sp)
4000b590:	01212823          	sw	s2,16(sp)
4000b594:	00112e23          	sw	ra,28(sp)
4000b598:	00050413          	mv	s0,a0
4000b59c:	00000493          	li	s1,0
			shell_print(sh, "[%3d] %s",
4000b5a0:	40034937          	lui	s2,0x40034
				    sh->ctx->temp_buff, &len);
4000b5a4:	00842603          	lw	a2,8(s0)
		z_shell_history_get(sh->history, true,
4000b5a8:	00c42503          	lw	a0,12(s0)
4000b5ac:	00e10693          	addi	a3,sp,14
4000b5b0:	14e60613          	addi	a2,a2,334
4000b5b4:	00100593          	li	a1,1
4000b5b8:	5fc000ef          	jal	ra,4000bbb4 <z_shell_history_get>
		if (len) {
4000b5bc:	00e15783          	lhu	a5,14(sp)
4000b5c0:	00842703          	lw	a4,8(s0)
4000b5c4:	02078263          	beqz	a5,4000b5e8 <cmd_history+0x64>
			shell_print(sh, "[%3d] %s",
4000b5c8:	00048693          	mv	a3,s1
4000b5cc:	14e70713          	addi	a4,a4,334
4000b5d0:	ec090613          	addi	a2,s2,-320 # 40033ec0 <log_backend_shell_api+0x70>
4000b5d4:	00800593          	li	a1,8
4000b5d8:	00040513          	mv	a0,s0
4000b5dc:	911fd0ef          	jal	ra,40008eec <shell_fprintf>
	while (1) {
4000b5e0:	00148493          	addi	s1,s1,1
		z_shell_history_get(sh->history, true,
4000b5e4:	fc1ff06f          	j	4000b5a4 <cmd_history+0x20>
	sh->ctx->temp_buff[0] = '\0';
4000b5e8:	14070723          	sb	zero,334(a4)
}
4000b5ec:	01c12083          	lw	ra,28(sp)
4000b5f0:	01812403          	lw	s0,24(sp)
4000b5f4:	01412483          	lw	s1,20(sp)
4000b5f8:	01012903          	lw	s2,16(sp)
4000b5fc:	00000513          	li	a0,0
4000b600:	02010113          	addi	sp,sp,32
4000b604:	00008067          	ret

4000b608 <cmd_get_retval>:

	return 0;
}

static int cmd_get_retval(const struct shell *sh, size_t argc, char **argv)
{
4000b608:	ff010113          	addi	sp,sp,-16
4000b60c:	00112623          	sw	ra,12(sp)
4000b610:	00812423          	sw	s0,8(sp)
4000b614:	00050413          	mv	s0,a0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(sh, "%d", shell_get_return_value(sh));
4000b618:	bfdfd0ef          	jal	ra,40009214 <shell_get_return_value>
4000b61c:	40037637          	lui	a2,0x40037
4000b620:	00050693          	mv	a3,a0
4000b624:	8f060613          	addi	a2,a2,-1808 # 400368f0 <CSWTCH.15846+0x1290>
4000b628:	00040513          	mv	a0,s0
4000b62c:	00800593          	li	a1,8
4000b630:	8bdfd0ef          	jal	ra,40008eec <shell_fprintf>
	return 0;
}
4000b634:	00c12083          	lw	ra,12(sp)
4000b638:	00812403          	lw	s0,8(sp)
4000b63c:	00000513          	li	a0,0
4000b640:	01010113          	addi	sp,sp,16
4000b644:	00008067          	ret

4000b648 <cmd_echo>:
{
4000b648:	ff010113          	addi	sp,sp,-16
4000b64c:	00112623          	sw	ra,12(sp)
	if (argc == 2) {
4000b650:	00200793          	li	a5,2
4000b654:	02f59a63          	bne	a1,a5,4000b688 <cmd_echo+0x40>
		shell_error(sh, "%s:%s%s", argv[0],
4000b658:	00462783          	lw	a5,4(a2)
4000b65c:	00062683          	lw	a3,0(a2)
4000b660:	40034737          	lui	a4,0x40034
4000b664:	40034637          	lui	a2,0x40034
4000b668:	ed070713          	addi	a4,a4,-304 # 40033ed0 <log_backend_shell_api+0x80>
4000b66c:	ee860613          	addi	a2,a2,-280 # 40033ee8 <log_backend_shell_api+0x98>
4000b670:	00100593          	li	a1,1
4000b674:	879fd0ef          	jal	ra,40008eec <shell_fprintf>
4000b678:	fea00513          	li	a0,-22
}
4000b67c:	00c12083          	lw	ra,12(sp)
4000b680:	01010113          	addi	sp,sp,16
4000b684:	00008067          	ret
	return sh->ctx->cfg.flags.echo == 1;
4000b688:	00852783          	lw	a5,8(a0)
4000b68c:	00050713          	mv	a4,a0
4000b690:	26c7a783          	lw	a5,620(a5)
4000b694:	0017d793          	srli	a5,a5,0x1
4000b698:	0017f793          	andi	a5,a5,1
	shell_print(sh, "Echo status: %s",
4000b69c:	02078463          	beqz	a5,4000b6c4 <cmd_echo+0x7c>
4000b6a0:	400366b7          	lui	a3,0x40036
4000b6a4:	f1068693          	addi	a3,a3,-240 # 40035f10 <CSWTCH.15846+0x8b0>
4000b6a8:	40034637          	lui	a2,0x40034
4000b6ac:	00070513          	mv	a0,a4
4000b6b0:	ef460613          	addi	a2,a2,-268 # 40033ef4 <log_backend_shell_api+0xa4>
4000b6b4:	00800593          	li	a1,8
4000b6b8:	835fd0ef          	jal	ra,40008eec <shell_fprintf>
	return 0;
4000b6bc:	00000513          	li	a0,0
4000b6c0:	fbdff06f          	j	4000b67c <cmd_echo+0x34>
	shell_print(sh, "Echo status: %s",
4000b6c4:	400346b7          	lui	a3,0x40034
4000b6c8:	ecc68693          	addi	a3,a3,-308 # 40033ecc <log_backend_shell_api+0x7c>
4000b6cc:	fddff06f          	j	4000b6a8 <cmd_echo+0x60>

4000b6d0 <cmd_clear>:
{
4000b6d0:	ff010113          	addi	sp,sp,-16
4000b6d4:	00812423          	sw	s0,8(sp)
4000b6d8:	00112623          	sw	ra,12(sp)
	return sh->ctx->cfg.flags.use_vt100 == 1;
4000b6dc:	00852783          	lw	a5,8(a0)
4000b6e0:	00050413          	mv	s0,a0
4000b6e4:	26c7a783          	lw	a5,620(a5)
4000b6e8:	0057d793          	srli	a5,a5,0x5
4000b6ec:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CURSORHOME);
4000b6f0:	00078a63          	beqz	a5,4000b704 <cmd_clear+0x34>
4000b6f4:	01452503          	lw	a0,20(a0)
4000b6f8:	400325b7          	lui	a1,0x40032
4000b6fc:	6d858593          	addi	a1,a1,1752 # 400326d8 <eth_config+0x3c>
4000b700:	d1dff0ef          	jal	ra,4000b41c <z_shell_raw_fprintf>
4000b704:	00842783          	lw	a5,8(s0)
4000b708:	26c7a783          	lw	a5,620(a5)
4000b70c:	0057d793          	srli	a5,a5,0x5
4000b710:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEARSCREEN);
4000b714:	00078a63          	beqz	a5,4000b728 <cmd_clear+0x58>
4000b718:	01442503          	lw	a0,20(s0)
4000b71c:	400325b7          	lui	a1,0x40032
4000b720:	6e058593          	addi	a1,a1,1760 # 400326e0 <eth_config+0x44>
4000b724:	cf9ff0ef          	jal	ra,4000b41c <z_shell_raw_fprintf>
}
4000b728:	00c12083          	lw	ra,12(sp)
4000b72c:	00812403          	lw	s0,8(sp)
4000b730:	00000513          	li	a0,0
4000b734:	01010113          	addi	sp,sp,16
4000b738:	00008067          	ret

4000b73c <cmd_resize>:
{
4000b73c:	fd010113          	addi	sp,sp,-48
4000b740:	02112623          	sw	ra,44(sp)
4000b744:	02812423          	sw	s0,40(sp)
4000b748:	02912223          	sw	s1,36(sp)
4000b74c:	03212023          	sw	s2,32(sp)
4000b750:	01312e23          	sw	s3,28(sp)
4000b754:	01412c23          	sw	s4,24(sp)
4000b758:	01512a23          	sw	s5,20(sp)
	if (argc != 1) {
4000b75c:	00100793          	li	a5,1
4000b760:	04f58663          	beq	a1,a5,4000b7ac <cmd_resize+0x70>
		shell_error(sh, "%s:%s%s", argv[0],
4000b764:	00462783          	lw	a5,4(a2)
4000b768:	00062683          	lw	a3,0(a2)
4000b76c:	40034737          	lui	a4,0x40034
4000b770:	40034637          	lui	a2,0x40034
4000b774:	ed070713          	addi	a4,a4,-304 # 40033ed0 <log_backend_shell_api+0x80>
4000b778:	ee860613          	addi	a2,a2,-280 # 40033ee8 <log_backend_shell_api+0x98>
4000b77c:	00100593          	li	a1,1
4000b780:	f6cfd0ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
4000b784:	fea00513          	li	a0,-22
}
4000b788:	02c12083          	lw	ra,44(sp)
4000b78c:	02812403          	lw	s0,40(sp)
4000b790:	02412483          	lw	s1,36(sp)
4000b794:	02012903          	lw	s2,32(sp)
4000b798:	01c12983          	lw	s3,28(sp)
4000b79c:	01812a03          	lw	s4,24(sp)
4000b7a0:	01412a83          	lw	s5,20(sp)
4000b7a4:	03010113          	addi	sp,sp,48
4000b7a8:	00008067          	ret
4000b7ac:	00852783          	lw	a5,8(a0)
4000b7b0:	00050413          	mv	s0,a0
4000b7b4:	26c7a783          	lw	a5,620(a5)
4000b7b8:	0057d793          	srli	a5,a5,0x5
4000b7bc:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SAVECURSOR);
4000b7c0:	00078a63          	beqz	a5,4000b7d4 <cmd_resize+0x98>
4000b7c4:	01452503          	lw	a0,20(a0)
4000b7c8:	400325b7          	lui	a1,0x40032
4000b7cc:	6e858593          	addi	a1,a1,1768 # 400326e8 <eth_config+0x4c>
4000b7d0:	c4dff0ef          	jal	ra,4000b41c <z_shell_raw_fprintf>
	z_shell_op_cursor_vert_move(sh, -SHELL_MAX_TERMINAL_SIZE);
4000b7d4:	f0600593          	li	a1,-250
4000b7d8:	00040513          	mv	a0,s0
4000b7dc:	dbcfe0ef          	jal	ra,40009d98 <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(sh, SHELL_MAX_TERMINAL_SIZE);
4000b7e0:	0fa00593          	li	a1,250
4000b7e4:	00040513          	mv	a0,s0
4000b7e8:	df4fe0ef          	jal	ra,40009ddc <z_shell_op_cursor_horiz_move>
	memset(sh->ctx->temp_buff, 0, sizeof(sh->ctx->temp_buff));
4000b7ec:	00842503          	lw	a0,8(s0)
4000b7f0:	10000613          	li	a2,256
4000b7f4:	00000593          	li	a1,0
4000b7f8:	14e50513          	addi	a0,a0,334
	char c = 0;
4000b7fc:	000105a3          	sb	zero,11(sp)
	memset(sh->ctx->temp_buff, 0, sizeof(sh->ctx->temp_buff));
4000b800:	51c010ef          	jal	ra,4000cd1c <memset>
	z_shell_raw_fprintf(sh->fprintf_ctx, cmd_get_terminal_size);
4000b804:	01442503          	lw	a0,20(s0)
4000b808:	400325b7          	lui	a1,0x40032
4000b80c:	5c858593          	addi	a1,a1,1480 # 400325c8 <cmd_get_terminal_size.0>
4000b810:	c0dff0ef          	jal	ra,4000b41c <z_shell_raw_fprintf>
	z_shell_fprintf_buffer_flush(sh->fprintf_ctx);
4000b814:	01442503          	lw	a0,20(s0)
4000b818:	3e800913          	li	s2,1000
	uint16_t buff_idx = 0U;
4000b81c:	00000493          	li	s1,0
4000b820:	a21fd0ef          	jal	ra,40009240 <z_shell_fprintf_buffer_flush>
			if ((c != SHELL_VT100_ASCII_ESC) &&
4000b824:	01b00993          	li	s3,27
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
4000b828:	00900a13          	li	s4,9
			if (c == 'R') { /* End of response from the terminal. */
4000b82c:	05200a93          	li	s5,82
			(void)sh->iface->api->read(sh->iface, &c,
4000b830:	00442503          	lw	a0,4(s0)
4000b834:	00c10693          	addi	a3,sp,12
4000b838:	00100613          	li	a2,1
4000b83c:	00052783          	lw	a5,0(a0)
4000b840:	00b10593          	addi	a1,sp,11
4000b844:	0107a783          	lw	a5,16(a5)
4000b848:	000780e7          	jalr	a5
			if (cnt == 0) {
4000b84c:	00c12783          	lw	a5,12(sp)
4000b850:	06079a63          	bnez	a5,4000b8c4 <cmd_resize+0x188>
	for (uint16_t i = 0; i < 1000; i++) {
4000b854:	fff90913          	addi	s2,s2,-1
4000b858:	01091913          	slli	s2,s2,0x10
	z_impl_k_busy_wait(usec_to_wait);
4000b85c:	3e800513          	li	a0,1000
4000b860:	01095913          	srli	s2,s2,0x10
4000b864:	5f5250ef          	jal	ra,40031658 <z_impl_k_busy_wait>
4000b868:	fc0914e3          	bnez	s2,4000b830 <cmd_resize+0xf4>
	return sh->ctx->cfg.flags.use_vt100 == 1;
4000b86c:	00842783          	lw	a5,8(s0)
4000b870:	26c7a783          	lw	a5,620(a5)
4000b874:	0057d793          	srli	a5,a5,0x5
4000b878:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
4000b87c:	00078a63          	beqz	a5,4000b890 <cmd_resize+0x154>
4000b880:	01442503          	lw	a0,20(s0)
4000b884:	400325b7          	lui	a1,0x40032
4000b888:	6ec58593          	addi	a1,a1,1772 # 400326ec <eth_config+0x50>
4000b88c:	b91ff0ef          	jal	ra,4000b41c <z_shell_raw_fprintf>
		sh->ctx->vt100_ctx.cons.terminal_wid =
4000b890:	00842783          	lw	a5,8(s0)
4000b894:	05000713          	li	a4,80
		shell_warn(sh, "No response from the terminal, assumed 80x24"
4000b898:	40034637          	lui	a2,0x40034
		sh->ctx->vt100_ctx.cons.terminal_wid =
4000b89c:	02e79723          	sh	a4,46(a5)
		sh->ctx->vt100_ctx.cons.terminal_hei =
4000b8a0:	00842783          	lw	a5,8(s0)
4000b8a4:	01800713          	li	a4,24
		shell_warn(sh, "No response from the terminal, assumed 80x24"
4000b8a8:	00040513          	mv	a0,s0
		sh->ctx->vt100_ctx.cons.terminal_hei =
4000b8ac:	02e79623          	sh	a4,44(a5)
		shell_warn(sh, "No response from the terminal, assumed 80x24"
4000b8b0:	f0860613          	addi	a2,a2,-248 # 40033f08 <log_backend_shell_api+0xb8>
4000b8b4:	00300593          	li	a1,3
4000b8b8:	e34fd0ef          	jal	ra,40008eec <shell_fprintf>
4000b8bc:	ff800513          	li	a0,-8
4000b8c0:	ec9ff06f          	j	4000b788 <cmd_resize+0x4c>
			if ((c != SHELL_VT100_ASCII_ESC) &&
4000b8c4:	00b14703          	lbu	a4,11(sp)
			    (sh->ctx->temp_buff[0] !=
4000b8c8:	00842783          	lw	a5,8(s0)
			if ((c != SHELL_VT100_ASCII_ESC) &&
4000b8cc:	13370663          	beq	a4,s3,4000b9f8 <cmd_resize+0x2bc>
4000b8d0:	14e7c683          	lbu	a3,334(a5)
4000b8d4:	f5369ee3          	bne	a3,s3,4000b830 <cmd_resize+0xf4>
			if (c == 'R') { /* End of response from the terminal. */
4000b8d8:	13571063          	bne	a4,s5,4000b9f8 <cmd_resize+0x2bc>
				sh->ctx->temp_buff[buff_idx] = '\0';
4000b8dc:	009787b3          	add	a5,a5,s1
4000b8e0:	14078723          	sb	zero,334(a5)
				if (sh->ctx->temp_buff[1] != '[') {
4000b8e4:	00842603          	lw	a2,8(s0)
4000b8e8:	05b00793          	li	a5,91
4000b8ec:	14f64703          	lbu	a4,335(a2)
4000b8f0:	0af71a63          	bne	a4,a5,4000b9a4 <cmd_resize+0x268>
4000b8f4:	15060593          	addi	a1,a2,336
	*y = 0U;
4000b8f8:	00000693          	li	a3,0
				buff_idx = 2U;
4000b8fc:	00200793          	li	a5,2
				while (sh->ctx->temp_buff[buff_idx] != ';') {
4000b900:	03b00813          	li	a6,59
					*y = *y * 10U +
4000b904:	00a00893          	li	a7,10
					if (buff_idx >=
4000b908:	10000313          	li	t1,256
				while (sh->ctx->temp_buff[buff_idx] != ';') {
4000b90c:	0005c703          	lbu	a4,0(a1)
4000b910:	00078513          	mv	a0,a5
					(sh->ctx->temp_buff[buff_idx++] -
4000b914:	00178793          	addi	a5,a5,1
4000b918:	01079793          	slli	a5,a5,0x10
4000b91c:	0107d793          	srli	a5,a5,0x10
				while (sh->ctx->temp_buff[buff_idx] != ';') {
4000b920:	09071663          	bne	a4,a6,4000b9ac <cmd_resize+0x270>
				if (++buff_idx >= CONFIG_SHELL_CMD_BUFF_SIZE) {
4000b924:	0ff00713          	li	a4,255
4000b928:	f4e502e3          	beq	a0,a4,4000b86c <cmd_resize+0x130>
4000b92c:	00f60533          	add	a0,a2,a5
	*x = 0U;
4000b930:	00000713          	li	a4,0
					*x = *x * 10U +
4000b934:	00a00813          	li	a6,10
					if (buff_idx >=
4000b938:	10000893          	li	a7,256
				while (sh->ctx->temp_buff[buff_idx]
4000b93c:	14e54583          	lbu	a1,334(a0)
							     != '\0') {
4000b940:	08059663          	bnez	a1,4000b9cc <cmd_resize+0x290>
				sh->ctx->temp_buff[0] = 0;
4000b944:	14060723          	sb	zero,334(a2)
				if (*x > SHELL_MAX_TERMINAL_SIZE) {
4000b948:	0fa00593          	li	a1,250
		sh->ctx->vt100_ctx.cons.terminal_wid = x;
4000b94c:	00842603          	lw	a2,8(s0)
				if (*x > SHELL_MAX_TERMINAL_SIZE) {
4000b950:	00070793          	mv	a5,a4
4000b954:	00e5f463          	bgeu	a1,a4,4000b95c <cmd_resize+0x220>
4000b958:	0fa00793          	li	a5,250
		sh->ctx->vt100_ctx.cons.terminal_wid = x;
4000b95c:	02f61723          	sh	a5,46(a2)
				if (*y > SHELL_MAX_TERMINAL_SIZE) {
4000b960:	0fa00613          	li	a2,250
		sh->ctx->vt100_ctx.cons.terminal_hei = y;
4000b964:	00842703          	lw	a4,8(s0)
				if (*y > SHELL_MAX_TERMINAL_SIZE) {
4000b968:	00068793          	mv	a5,a3
4000b96c:	00d67463          	bgeu	a2,a3,4000b974 <cmd_resize+0x238>
4000b970:	0fa00793          	li	a5,250
		sh->ctx->vt100_ctx.cons.terminal_hei = y;
4000b974:	02f71623          	sh	a5,44(a4)
	return sh->ctx->cfg.flags.use_vt100 == 1;
4000b978:	00842783          	lw	a5,8(s0)
4000b97c:	26c7a783          	lw	a5,620(a5)
4000b980:	0057d793          	srli	a5,a5,0x5
4000b984:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
4000b988:	00078a63          	beqz	a5,4000b99c <cmd_resize+0x260>
4000b98c:	01442503          	lw	a0,20(s0)
4000b990:	400325b7          	lui	a1,0x40032
4000b994:	6ec58593          	addi	a1,a1,1772 # 400326ec <eth_config+0x50>
4000b998:	a85ff0ef          	jal	ra,4000b41c <z_shell_raw_fprintf>
	return 0;
4000b99c:	00000513          	li	a0,0
4000b9a0:	de9ff06f          	j	4000b788 <cmd_resize+0x4c>
					sh->ctx->temp_buff[0] = 0;
4000b9a4:	14060723          	sb	zero,334(a2)
					return -EIO;
4000b9a8:	ec5ff06f          	j	4000b86c <cmd_resize+0x130>
					*y = *y * 10U +
4000b9ac:	031686b3          	mul	a3,a3,a7
					if (buff_idx >=
4000b9b0:	00158593          	addi	a1,a1,1
					*y = *y * 10U +
4000b9b4:	fd068693          	addi	a3,a3,-48
4000b9b8:	00d70733          	add	a4,a4,a3
4000b9bc:	01071693          	slli	a3,a4,0x10
4000b9c0:	0106d693          	srli	a3,a3,0x10
					if (buff_idx >=
4000b9c4:	f46794e3          	bne	a5,t1,4000b90c <cmd_resize+0x1d0>
4000b9c8:	ea5ff06f          	j	4000b86c <cmd_resize+0x130>
					*x = *x * 10U +
4000b9cc:	03070733          	mul	a4,a4,a6
					(sh->ctx->temp_buff[buff_idx++] -
4000b9d0:	00178793          	addi	a5,a5,1
4000b9d4:	01079793          	slli	a5,a5,0x10
4000b9d8:	0107d793          	srli	a5,a5,0x10
					if (buff_idx >=
4000b9dc:	00150513          	addi	a0,a0,1
					*x = *x * 10U +
4000b9e0:	fd070713          	addi	a4,a4,-48
4000b9e4:	00e585b3          	add	a1,a1,a4
4000b9e8:	01059713          	slli	a4,a1,0x10
4000b9ec:	01075713          	srli	a4,a4,0x10
					if (buff_idx >=
4000b9f0:	f51796e3          	bne	a5,a7,4000b93c <cmd_resize+0x200>
4000b9f4:	e79ff06f          	j	4000b86c <cmd_resize+0x130>
			sh->ctx->temp_buff[buff_idx] = c;
4000b9f8:	009787b3          	add	a5,a5,s1
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
4000b9fc:	00148493          	addi	s1,s1,1
4000ba00:	01049493          	slli	s1,s1,0x10
			sh->ctx->temp_buff[buff_idx] = c;
4000ba04:	14e78723          	sb	a4,334(a5)
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
4000ba08:	0104d493          	srli	s1,s1,0x10
4000ba0c:	e29a72e3          	bgeu	s4,s1,4000b830 <cmd_resize+0xf4>
				sh->ctx->temp_buff[0] = 0;
4000ba10:	00842783          	lw	a5,8(s0)
4000ba14:	14078723          	sb	zero,334(a5)
				return -ENOMEM;
4000ba18:	e55ff06f          	j	4000b86c <cmd_resize+0x130>

4000ba1c <cmd_vt100_off>:
{
4000ba1c:	ff010113          	addi	sp,sp,-16
4000ba20:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, use_vt100, val, ret);
4000ba24:	00852503          	lw	a0,8(a0)
4000ba28:	26c50513          	addi	a0,a0,620
	return z_impl_atomic_and(target, value);
4000ba2c:	fdf00593          	li	a1,-33
4000ba30:	09c260ef          	jal	ra,40031acc <z_impl_atomic_and>
}
4000ba34:	00c12083          	lw	ra,12(sp)
4000ba38:	00000513          	li	a0,0
4000ba3c:	01010113          	addi	sp,sp,16
4000ba40:	00008067          	ret

4000ba44 <cmd_bacskpace_mode_delete>:
{
4000ba44:	ff010113          	addi	sp,sp,-16
4000ba48:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, mode_delete, val, ret);
4000ba4c:	00852503          	lw	a0,8(a0)
4000ba50:	26c50513          	addi	a0,a0,620
	return z_impl_atomic_or(target, value);
4000ba54:	00800593          	li	a1,8
4000ba58:	054260ef          	jal	ra,40031aac <z_impl_atomic_or>
}
4000ba5c:	00c12083          	lw	ra,12(sp)
4000ba60:	00000513          	li	a0,0
4000ba64:	01010113          	addi	sp,sp,16
4000ba68:	00008067          	ret

4000ba6c <cmd_colors_off>:
{
4000ba6c:	ff010113          	addi	sp,sp,-16
4000ba70:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, use_colors, val, ret);
4000ba74:	00852503          	lw	a0,8(a0)
4000ba78:	26c50513          	addi	a0,a0,620
	return z_impl_atomic_and(target, value);
4000ba7c:	fef00593          	li	a1,-17
4000ba80:	04c260ef          	jal	ra,40031acc <z_impl_atomic_and>
}
4000ba84:	00c12083          	lw	ra,12(sp)
4000ba88:	00000513          	li	a0,0
4000ba8c:	01010113          	addi	sp,sp,16
4000ba90:	00008067          	ret

4000ba94 <cmd_bacskpace_mode_backspace>:
{
4000ba94:	ff010113          	addi	sp,sp,-16
4000ba98:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, mode_delete, val, ret);
4000ba9c:	00852503          	lw	a0,8(a0)
4000baa0:	26c50513          	addi	a0,a0,620
4000baa4:	ff700593          	li	a1,-9
4000baa8:	024260ef          	jal	ra,40031acc <z_impl_atomic_and>
}
4000baac:	00c12083          	lw	ra,12(sp)
4000bab0:	00000513          	li	a0,0
4000bab4:	01010113          	addi	sp,sp,16
4000bab8:	00008067          	ret

4000babc <cmd_echo_off>:
{
4000babc:	ff010113          	addi	sp,sp,-16
4000bac0:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, echo, val, ret);
4000bac4:	00852503          	lw	a0,8(a0)
4000bac8:	26c50513          	addi	a0,a0,620
4000bacc:	ffd00593          	li	a1,-3
4000bad0:	7fd250ef          	jal	ra,40031acc <z_impl_atomic_and>
}
4000bad4:	00c12083          	lw	ra,12(sp)
4000bad8:	00000513          	li	a0,0
4000badc:	01010113          	addi	sp,sp,16
4000bae0:	00008067          	ret

4000bae4 <cmd_colors_on>:
{
4000bae4:	ff010113          	addi	sp,sp,-16
4000bae8:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, use_colors, val, ret);
4000baec:	00852503          	lw	a0,8(a0)
4000baf0:	26c50513          	addi	a0,a0,620
	return z_impl_atomic_or(target, value);
4000baf4:	01000593          	li	a1,16
4000baf8:	7b5250ef          	jal	ra,40031aac <z_impl_atomic_or>
}
4000bafc:	00c12083          	lw	ra,12(sp)
4000bb00:	00000513          	li	a0,0
4000bb04:	01010113          	addi	sp,sp,16
4000bb08:	00008067          	ret

4000bb0c <cmd_vt100_on>:
{
4000bb0c:	ff010113          	addi	sp,sp,-16
4000bb10:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, use_vt100, val, ret);
4000bb14:	00852503          	lw	a0,8(a0)
4000bb18:	26c50513          	addi	a0,a0,620
4000bb1c:	02000593          	li	a1,32
4000bb20:	78d250ef          	jal	ra,40031aac <z_impl_atomic_or>
}
4000bb24:	00c12083          	lw	ra,12(sp)
4000bb28:	00000513          	li	a0,0
4000bb2c:	01010113          	addi	sp,sp,16
4000bb30:	00008067          	ret

4000bb34 <cmd_echo_on>:
{
4000bb34:	ff010113          	addi	sp,sp,-16
4000bb38:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, echo, val, ret);
4000bb3c:	00852503          	lw	a0,8(a0)
4000bb40:	26c50513          	addi	a0,a0,620
4000bb44:	00200593          	li	a1,2
4000bb48:	765250ef          	jal	ra,40031aac <z_impl_atomic_or>
}
4000bb4c:	00c12083          	lw	ra,12(sp)
4000bb50:	00000513          	li	a0,0
4000bb54:	01010113          	addi	sp,sp,16
4000bb58:	00008067          	ret

4000bb5c <remove_from_tail.part.0>:
	memcpy(item->data, src, len);
	sys_dlist_prepend(&history->list, &item->dnode);
}

/* Returns true if element was removed. */
static bool remove_from_tail(struct shell_history *history)
4000bb5c:	ff010113          	addi	sp,sp,-16
4000bb60:	00112623          	sw	ra,12(sp)
 * @return a pointer to the tail element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_tail(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->tail;
4000bb64:	00852783          	lw	a5,8(a0)

	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);

	total_len = offsetof(struct shell_history_item, data) +
			h_item->len + h_item->padding;
	ring_buf_get(history->ring_buf, NULL, total_len);
4000bb68:	00000593          	li	a1,0
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
4000bb6c:	0047a683          	lw	a3,4(a5)
	sys_dnode_t *const next = node->next;
4000bb70:	0007a703          	lw	a4,0(a5)

	prev->next = next;
4000bb74:	00e6a023          	sw	a4,0(a3)
	next->prev = prev;
4000bb78:	00d72223          	sw	a3,4(a4)
			h_item->len + h_item->padding;
4000bb7c:	0087d603          	lhu	a2,8(a5)
	node->next = NULL;
4000bb80:	0007a023          	sw	zero,0(a5)
	node->prev = NULL;
4000bb84:	0007a223          	sw	zero,4(a5)
4000bb88:	00a7d783          	lhu	a5,10(a5)
	ring_buf_get(history->ring_buf, NULL, total_len);
4000bb8c:	00052503          	lw	a0,0(a0)
			h_item->len + h_item->padding;
4000bb90:	00f60633          	add	a2,a2,a5
	ring_buf_get(history->ring_buf, NULL, total_len);
4000bb94:	00c60613          	addi	a2,a2,12
4000bb98:	c71f70ef          	jal	ra,40003808 <ring_buf_get>

	return true;
}
4000bb9c:	00c12083          	lw	ra,12(sp)
4000bba0:	00100513          	li	a0,1
4000bba4:	01010113          	addi	sp,sp,16
4000bba8:	00008067          	ret

4000bbac <z_shell_history_mode_exit>:
	history->current = NULL;
4000bbac:	00052623          	sw	zero,12(a0)
}
4000bbb0:	00008067          	ret

4000bbb4 <z_shell_history_get>:
{
4000bbb4:	ff010113          	addi	sp,sp,-16
4000bbb8:	01212023          	sw	s2,0(sp)
4000bbbc:	00112623          	sw	ra,12(sp)
4000bbc0:	00812423          	sw	s0,8(sp)
4000bbc4:	00912223          	sw	s1,4(sp)
	return list->head == list;
4000bbc8:	00452403          	lw	s0,4(a0)
	if (sys_dlist_is_empty(&history->list)) {
4000bbcc:	00450793          	addi	a5,a0,4
{
4000bbd0:	00068913          	mv	s2,a3
	if (sys_dlist_is_empty(&history->list)) {
4000bbd4:	02f41263          	bne	s0,a5,4000bbf8 <z_shell_history_get+0x44>
		*len = 0U;
4000bbd8:	00091023          	sh	zero,0(s2)
		return false;
4000bbdc:	00000513          	li	a0,0
}
4000bbe0:	00c12083          	lw	ra,12(sp)
4000bbe4:	00812403          	lw	s0,8(sp)
4000bbe8:	00412483          	lw	s1,4(sp)
4000bbec:	00012903          	lw	s2,0(sp)
4000bbf0:	01010113          	addi	sp,sp,16
4000bbf4:	00008067          	ret
		if (history->current == NULL) {
4000bbf8:	00c52783          	lw	a5,12(a0)
4000bbfc:	00060493          	mv	s1,a2
	if (!up) { /* button down */
4000bc00:	04059463          	bnez	a1,4000bc48 <z_shell_history_get+0x94>
		if (history->current == NULL) {
4000bc04:	fc078ae3          	beqz	a5,4000bbd8 <z_shell_history_get+0x24>
	return (node == list->head) ? NULL : node->prev;
4000bc08:	00f41663          	bne	s0,a5,4000bc14 <z_shell_history_get+0x60>
	history->current = l_item;
4000bc0c:	00052623          	sw	zero,12(a0)
	if (l_item) {
4000bc10:	fc9ff06f          	j	4000bbd8 <z_shell_history_get+0x24>
4000bc14:	0047a403          	lw	s0,4(a5)
	history->current = l_item;
4000bc18:	00852623          	sw	s0,12(a0)
	if (l_item) {
4000bc1c:	fa040ee3          	beqz	s0,4000bbd8 <z_shell_history_get+0x24>
		memcpy(dst, h_item->data, h_item->len);
4000bc20:	00845603          	lhu	a2,8(s0)
4000bc24:	00048513          	mv	a0,s1
4000bc28:	00c40593          	addi	a1,s0,12
4000bc2c:	0cc010ef          	jal	ra,4000ccf8 <memcpy>
		*len = h_item->len;
4000bc30:	00845783          	lhu	a5,8(s0)
		return true;
4000bc34:	00100513          	li	a0,1
		*len = h_item->len;
4000bc38:	00f91023          	sh	a5,0(s2)
		dst[*len] = '\0';
4000bc3c:	00f484b3          	add	s1,s1,a5
4000bc40:	00048023          	sb	zero,0(s1)
		return true;
4000bc44:	f9dff06f          	j	4000bbe0 <z_shell_history_get+0x2c>
		sys_dlist_peek_head_not_empty(&history->list) :
4000bc48:	fc0788e3          	beqz	a5,4000bc18 <z_shell_history_get+0x64>
	return (node == list->tail) ? NULL : node->next;
4000bc4c:	00852703          	lw	a4,8(a0)
4000bc50:	faf70ee3          	beq	a4,a5,4000bc0c <z_shell_history_get+0x58>
4000bc54:	0007a403          	lw	s0,0(a5)
4000bc58:	fc1ff06f          	j	4000bc18 <z_shell_history_get+0x64>

4000bc5c <z_shell_history_purge>:

void z_shell_history_purge(struct shell_history *history)
{
4000bc5c:	ff010113          	addi	sp,sp,-16
4000bc60:	00812423          	sw	s0,8(sp)
4000bc64:	00912223          	sw	s1,4(sp)
4000bc68:	00112623          	sw	ra,12(sp)
4000bc6c:	00050413          	mv	s0,a0
	if (sys_dlist_is_empty(&history->list)) {
4000bc70:	00450493          	addi	s1,a0,4
4000bc74:	00442783          	lw	a5,4(s0)
4000bc78:	00978863          	beq	a5,s1,4000bc88 <z_shell_history_purge+0x2c>
4000bc7c:	00040513          	mv	a0,s0
4000bc80:	eddff0ef          	jal	ra,4000bb5c <remove_from_tail.part.0>
	while (remove_from_tail(history)) {
4000bc84:	fe0518e3          	bnez	a0,4000bc74 <z_shell_history_purge+0x18>
	}
}
4000bc88:	00c12083          	lw	ra,12(sp)
4000bc8c:	00812403          	lw	s0,8(sp)
4000bc90:	00412483          	lw	s1,4(sp)
4000bc94:	01010113          	addi	sp,sp,16
4000bc98:	00008067          	ret

4000bc9c <z_shell_history_put>:

void z_shell_history_put(struct shell_history *history, uint8_t *line,
			 size_t len)
{
4000bc9c:	fc010113          	addi	sp,sp,-64
4000bca0:	02912a23          	sw	s1,52(sp)
4000bca4:	03512223          	sw	s5,36(sp)
4000bca8:	02112e23          	sw	ra,60(sp)
4000bcac:	02812c23          	sw	s0,56(sp)
4000bcb0:	03212823          	sw	s2,48(sp)
4000bcb4:	03312623          	sw	s3,44(sp)
4000bcb8:	03412423          	sw	s4,40(sp)
4000bcbc:	03612023          	sw	s6,32(sp)
4000bcc0:	01712e23          	sw	s7,28(sp)
	return buf->size;
4000bcc4:	00052783          	lw	a5,0(a0)
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item, *h_prev_item;
	uint32_t total_len = len + offsetof(struct shell_history_item, data);
4000bcc8:	00c60493          	addi	s1,a2,12
	uint32_t claim_len;
	uint32_t claim2_len;
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
4000bccc:	40900ab3          	neg	s5,s1

	/* align to word. */
	total_len += padding;

	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
4000bcd0:	01c7a783          	lw	a5,28(a5)
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
4000bcd4:	003afa93          	andi	s5,s5,3
	total_len += padding;
4000bcd8:	009a84b3          	add	s1,s5,s1
	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
4000bcdc:	0297ee63          	bltu	a5,s1,4000bd18 <z_shell_history_put+0x7c>
	history->current = NULL;
4000bce0:	00052623          	sw	zero,12(a0)
4000bce4:	00050413          	mv	s0,a0
4000bce8:	00060a13          	mv	s4,a2
		return;
	}

	z_shell_history_mode_exit(history);

	if (len == 0) {
4000bcec:	02060663          	beqz	a2,4000bd18 <z_shell_history_put+0x7c>
	return list->head == list;
4000bcf0:	00452983          	lw	s3,4(a0)
		return;
	}

	l_item = sys_dlist_peek_head(&history->list);
4000bcf4:	00450b13          	addi	s6,a0,4
4000bcf8:	00058b93          	mv	s7,a1
	return sys_dlist_is_empty(list) ? NULL : list->head;
4000bcfc:	053b0463          	beq	s6,s3,4000bd44 <z_shell_history_put+0xa8>
	h_prev_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);

	if (l_item &&
4000bd00:	04098463          	beqz	s3,4000bd48 <z_shell_history_put+0xac>
	   (h_prev_item->len == len) &&
4000bd04:	0089d783          	lhu	a5,8(s3)
	if (l_item &&
4000bd08:	04c79063          	bne	a5,a2,4000bd48 <z_shell_history_put+0xac>
	   (memcmp(h_prev_item->data, line, len) == 0)) {
4000bd0c:	00c98513          	addi	a0,s3,12
4000bd10:	769000ef          	jal	ra,4000cc78 <memcmp>
	   (h_prev_item->len == len) &&
4000bd14:	02051a63          	bnez	a0,4000bd48 <z_shell_history_put+0xac>
		}

		ring_buf_put_finish(history->ring_buf, 0);
		remove_from_tail(history);
	} while (1);
}
4000bd18:	03c12083          	lw	ra,60(sp)
4000bd1c:	03812403          	lw	s0,56(sp)
4000bd20:	03412483          	lw	s1,52(sp)
4000bd24:	03012903          	lw	s2,48(sp)
4000bd28:	02c12983          	lw	s3,44(sp)
4000bd2c:	02812a03          	lw	s4,40(sp)
4000bd30:	02412a83          	lw	s5,36(sp)
4000bd34:	02012b03          	lw	s6,32(sp)
4000bd38:	01c12b83          	lw	s7,28(sp)
4000bd3c:	04010113          	addi	sp,sp,64
4000bd40:	00008067          	ret
4000bd44:	00000993          	li	s3,0
		if (ring_buf_is_empty(history->ring_buf)) {
4000bd48:	00042783          	lw	a5,0(s0)
4000bd4c:	0107a683          	lw	a3,16(a5)
4000bd50:	0087a703          	lw	a4,8(a5)
4000bd54:	00e69e63          	bne	a3,a4,4000bd70 <z_shell_history_put+0xd4>
	buf->put_head = buf->put_tail = buf->put_base = value;
4000bd58:	0007a623          	sw	zero,12(a5)
4000bd5c:	0007a423          	sw	zero,8(a5)
4000bd60:	0007a223          	sw	zero,4(a5)
	buf->get_head = buf->get_tail = buf->get_base = value;
4000bd64:	0007ac23          	sw	zero,24(a5)
4000bd68:	0007aa23          	sw	zero,20(a5)
4000bd6c:	0007a823          	sw	zero,16(a5)
		claim_len = ring_buf_put_claim(history->ring_buf,
4000bd70:	00042503          	lw	a0,0(s0)
4000bd74:	00048613          	mv	a2,s1
4000bd78:	00c10593          	addi	a1,sp,12
4000bd7c:	8adf70ef          	jal	ra,40003628 <ring_buf_put_claim>
4000bd80:	00050913          	mv	s2,a0
		if (claim_len < total_len) {
4000bd84:	06957463          	bgeu	a0,s1,4000bdec <z_shell_history_put+0x150>
				ring_buf_put_claim(history->ring_buf,
4000bd88:	00042503          	lw	a0,0(s0)
4000bd8c:	00048613          	mv	a2,s1
4000bd90:	00c10593          	addi	a1,sp,12
4000bd94:	895f70ef          	jal	ra,40003628 <ring_buf_put_claim>
			if (claim2_len == total_len) {
4000bd98:	04a49c63          	bne	s1,a0,4000bdf0 <z_shell_history_put+0x154>
				h_prev_item->padding += claim_len;
4000bd9c:	00a9d783          	lhu	a5,10(s3)
4000bda0:	012787b3          	add	a5,a5,s2
4000bda4:	00f99523          	sh	a5,10(s3)
				total_len += claim_len;
4000bda8:	00990933          	add	s2,s2,s1
			add_to_head(history, h_item, line, len, padding);
4000bdac:	00c12483          	lw	s1,12(sp)
	memcpy(item->data, src, len);
4000bdb0:	000b8593          	mv	a1,s7
4000bdb4:	000a0613          	mv	a2,s4
	item->len = len;
4000bdb8:	01449423          	sh	s4,8(s1)
	item->padding = padding;
4000bdbc:	01549523          	sh	s5,10(s1)
	memcpy(item->data, src, len);
4000bdc0:	00c48513          	addi	a0,s1,12
4000bdc4:	735000ef          	jal	ra,4000ccf8 <memcpy>
	sys_dnode_t *const head = list->head;
4000bdc8:	00442783          	lw	a5,4(s0)
	node->prev = list;
4000bdcc:	0164a223          	sw	s6,4(s1)
			ring_buf_put_finish(history->ring_buf, claim_len);
4000bdd0:	00090593          	mv	a1,s2
	node->next = head;
4000bdd4:	00f4a023          	sw	a5,0(s1)
	head->prev = node;
4000bdd8:	0097a223          	sw	s1,4(a5)
4000bddc:	00042503          	lw	a0,0(s0)
	list->head = node;
4000bde0:	00942223          	sw	s1,4(s0)
4000bde4:	8a5f70ef          	jal	ra,40003688 <ring_buf_put_finish>
			break;
4000bde8:	f31ff06f          	j	4000bd18 <z_shell_history_put+0x7c>
		if (claim_len == total_len) {
4000bdec:	fca480e3          	beq	s1,a0,4000bdac <z_shell_history_put+0x110>
		ring_buf_put_finish(history->ring_buf, 0);
4000bdf0:	00042503          	lw	a0,0(s0)
4000bdf4:	00000593          	li	a1,0
4000bdf8:	891f70ef          	jal	ra,40003688 <ring_buf_put_finish>
	if (sys_dlist_is_empty(&history->list)) {
4000bdfc:	00442783          	lw	a5,4(s0)
4000be00:	f4fb04e3          	beq	s6,a5,4000bd48 <z_shell_history_put+0xac>
4000be04:	00040513          	mv	a0,s0
4000be08:	d55ff0ef          	jal	ra,4000bb5c <remove_from_tail.part.0>
4000be0c:	f3dff06f          	j	4000bd48 <z_shell_history_put+0xac>

4000be10 <z_shell_history_init>:

void z_shell_history_init(struct shell_history *history)
{
	sys_dlist_init(&history->list);
4000be10:	00450793          	addi	a5,a0,4
	list->head = (sys_dnode_t *)list;
4000be14:	00f52223          	sw	a5,4(a0)
	list->tail = (sys_dnode_t *)list;
4000be18:	00f52423          	sw	a5,8(a0)
	history->current = NULL;
4000be1c:	00052623          	sw	zero,12(a0)
}
4000be20:	00008067          	ret

4000be24 <z_shell_has_wildcard>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
4000be24:	06050263          	beqz	a0,4000be88 <z_shell_has_wildcard+0x64>

	return ret_val;
}

bool z_shell_has_wildcard(const char *str)
{
4000be28:	ff010113          	addi	sp,sp,-16
4000be2c:	00812423          	sw	s0,8(sp)
4000be30:	00112623          	sw	ra,12(sp)
4000be34:	00050413          	mv	s0,a0
4000be38:	59d000ef          	jal	ra,4000cbd4 <strlen>
	uint16_t str_len = z_shell_strlen(str);

	for (size_t i = 0; i < str_len; i++) {
4000be3c:	01051513          	slli	a0,a0,0x10
4000be40:	00000793          	li	a5,0
4000be44:	01055513          	srli	a0,a0,0x10
		if ((str[i] == '?') || (str[i] == '*')) {
4000be48:	03f00693          	li	a3,63
4000be4c:	02a00613          	li	a2,42
	for (size_t i = 0; i < str_len; i++) {
4000be50:	00a7ec63          	bltu	a5,a0,4000be68 <z_shell_has_wildcard+0x44>
			return true;
		}
	}

	return false;
4000be54:	00000513          	li	a0,0
}
4000be58:	00c12083          	lw	ra,12(sp)
4000be5c:	00812403          	lw	s0,8(sp)
4000be60:	01010113          	addi	sp,sp,16
4000be64:	00008067          	ret
		if ((str[i] == '?') || (str[i] == '*')) {
4000be68:	00f40733          	add	a4,s0,a5
4000be6c:	00074703          	lbu	a4,0(a4)
4000be70:	00d70863          	beq	a4,a3,4000be80 <z_shell_has_wildcard+0x5c>
4000be74:	00c70663          	beq	a4,a2,4000be80 <z_shell_has_wildcard+0x5c>
	for (size_t i = 0; i < str_len; i++) {
4000be78:	00178793          	addi	a5,a5,1
4000be7c:	fd5ff06f          	j	4000be50 <z_shell_has_wildcard+0x2c>
			return true;
4000be80:	00100513          	li	a0,1
4000be84:	fd5ff06f          	j	4000be58 <z_shell_has_wildcard+0x34>
	return false;
4000be88:	00000513          	li	a0,0
}
4000be8c:	00008067          	ret

4000be90 <z_shell_wildcard_prepare>:

void z_shell_wildcard_prepare(const struct shell *sh)
{
4000be90:	ff010113          	addi	sp,sp,-16
4000be94:	00112623          	sw	ra,12(sp)
4000be98:	00812423          	sw	s0,8(sp)
4000be9c:	00050413          	mv	s0,a0
	 *    buffer with all expanded commands is copied to Command buffer.
	 * 7. Deepest found handler is executed and all lower level commands,
	 *    including expanded commands, are passed as arguments.
	 */

	memset(sh->ctx->temp_buff, 0, sizeof(sh->ctx->temp_buff));
4000bea0:	00852503          	lw	a0,8(a0)
4000bea4:	10000613          	li	a2,256
4000bea8:	00000593          	li	a1,0
4000beac:	14e50513          	addi	a0,a0,334
4000beb0:	66d000ef          	jal	ra,4000cd1c <memset>
	memcpy(sh->ctx->temp_buff,
4000beb4:	00842503          	lw	a0,8(s0)
4000beb8:	04855603          	lhu	a2,72(a0)
4000bebc:	04e50593          	addi	a1,a0,78
4000bec0:	14e50513          	addi	a0,a0,334
4000bec4:	635000ef          	jal	ra,4000ccf8 <memcpy>

	/* Function shell_spaces_trim must be used instead of shell_make_argv.
	 * At this point it is important to keep temp_buff as one string.
	 * It will allow to find wildcard commands easily with strstr function.
	 */
	z_shell_spaces_trim(sh->ctx->temp_buff);
4000bec8:	00842503          	lw	a0,8(s0)
4000becc:	14e50513          	addi	a0,a0,334
4000bed0:	b79fd0ef          	jal	ra,40009a48 <z_shell_spaces_trim>

	/* +1 for EOS*/
	sh->ctx->cmd_tmp_buff_len = z_shell_strlen(sh->ctx->temp_buff) + 1;
4000bed4:	00842503          	lw	a0,8(s0)
4000bed8:	14e50513          	addi	a0,a0,334
4000bedc:	4f9000ef          	jal	ra,4000cbd4 <strlen>
4000bee0:	00842783          	lw	a5,8(s0)
4000bee4:	00150513          	addi	a0,a0,1
4000bee8:	04a79623          	sh	a0,76(a5)
}
4000beec:	00c12083          	lw	ra,12(sp)
4000bef0:	00812403          	lw	s0,8(sp)
4000bef4:	01010113          	addi	sp,sp,16
4000bef8:	00008067          	ret

4000befc <z_shell_wildcard_process>:


enum shell_wildcard_status z_shell_wildcard_process(const struct shell *sh,
					const struct shell_static_entry *cmd,
					const char *pattern)
{
4000befc:	fa010113          	addi	sp,sp,-96
4000bf00:	04112e23          	sw	ra,92(sp)
4000bf04:	04812c23          	sw	s0,88(sp)
4000bf08:	04912a23          	sw	s1,84(sp)
4000bf0c:	05212823          	sw	s2,80(sp)
4000bf10:	05312623          	sw	s3,76(sp)
4000bf14:	05412423          	sw	s4,72(sp)
4000bf18:	05512223          	sw	s5,68(sp)
4000bf1c:	05612023          	sw	s6,64(sp)
4000bf20:	03712e23          	sw	s7,60(sp)
4000bf24:	03812c23          	sw	s8,56(sp)
4000bf28:	03912a23          	sw	s9,52(sp)
4000bf2c:	03a12823          	sw	s10,48(sp)
4000bf30:	03b12623          	sw	s11,44(sp)
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_NOT_FOUND;

	if (cmd == NULL) {
4000bf34:	04059463          	bnez	a1,4000bf7c <z_shell_wildcard_process+0x80>
		return ret_val;
4000bf38:	00300413          	li	s0,3
	 * and it will try to add matching commands.
	 */
	ret_val = commands_expand(sh, cmd, pattern);

	return ret_val;
}
4000bf3c:	05c12083          	lw	ra,92(sp)
4000bf40:	00040513          	mv	a0,s0
4000bf44:	05812403          	lw	s0,88(sp)
4000bf48:	05412483          	lw	s1,84(sp)
4000bf4c:	05012903          	lw	s2,80(sp)
4000bf50:	04c12983          	lw	s3,76(sp)
4000bf54:	04812a03          	lw	s4,72(sp)
4000bf58:	04412a83          	lw	s5,68(sp)
4000bf5c:	04012b03          	lw	s6,64(sp)
4000bf60:	03c12b83          	lw	s7,60(sp)
4000bf64:	03812c03          	lw	s8,56(sp)
4000bf68:	03412c83          	lw	s9,52(sp)
4000bf6c:	03012d03          	lw	s10,48(sp)
4000bf70:	02c12d83          	lw	s11,44(sp)
4000bf74:	06010113          	addi	sp,sp,96
4000bf78:	00008067          	ret
4000bf7c:	00050993          	mv	s3,a0
	if (!z_shell_has_wildcard(pattern)) {
4000bf80:	00060513          	mv	a0,a2
4000bf84:	00058a13          	mv	s4,a1
4000bf88:	00060913          	mv	s2,a2
4000bf8c:	e99ff0ef          	jal	ra,4000be24 <z_shell_has_wildcard>
4000bf90:	fa0504e3          	beqz	a0,4000bf38 <z_shell_wildcard_process+0x3c>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
4000bf94:	00010bb7          	lui	s7,0x10
	size_t cnt = 0;
4000bf98:	00000b13          	li	s6,0
	size_t cmd_idx = 0;
4000bf9c:	00000593          	li	a1,0
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
4000bfa0:	00200413          	li	s0,2
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
4000bfa4:	0ff00c93          	li	s9,255
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
4000bfa8:	fffb8b93          	addi	s7,s7,-1 # ffff <__kernel_ram_size+0x44f7>
	completion_addr[cmd_len] = ' ';
4000bfac:	02000d13          	li	s10,32
4000bfb0:	0680006f          	j	4000c018 <z_shell_wildcard_process+0x11c>
	completion_addr = strstr(buff, pattern);
4000bfb4:	00090593          	mv	a1,s2
4000bfb8:	14ea8513          	addi	a0,s5,334
4000bfbc:	2e1000ef          	jal	ra,4000ca9c <strstr>
4000bfc0:	00050493          	mv	s1,a0
	if (!completion_addr) {
4000bfc4:	0e050263          	beqz	a0,4000c0a8 <z_shell_wildcard_process+0x1ac>
4000bfc8:	40d000ef          	jal	ra,4000cbd4 <strlen>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
4000bfcc:	01757633          	and	a2,a0,s7
4000bfd0:	00140513          	addi	a0,s0,1
4000bfd4:	00048593          	mv	a1,s1
4000bfd8:	00160613          	addi	a2,a2,1
4000bfdc:	00a48533          	add	a0,s1,a0
4000bfe0:	4d1000ef          	jal	ra,4000ccb0 <memmove>
	memcpy(completion_addr, cmd, cmd_len);
4000bfe4:	00040613          	mv	a2,s0
4000bfe8:	00048513          	mv	a0,s1
4000bfec:	000d8593          	mv	a1,s11
	completion_addr[cmd_len] = ' ';
4000bff0:	008484b3          	add	s1,s1,s0
	memcpy(completion_addr, cmd, cmd_len);
4000bff4:	505000ef          	jal	ra,4000ccf8 <memcpy>
	completion_addr[cmd_len] = ' ';
4000bff8:	01a48023          	sb	s10,0(s1)
	*buff_len += cmd_len + 1; /* + 1 for space */
4000bffc:	04cad783          	lhu	a5,76(s5)
			cnt++;
4000c000:	001b0b13          	addi	s6,s6,1
	*buff_len += cmd_len + 1; /* + 1 for space */
4000c004:	00178793          	addi	a5,a5,1
4000c008:	00f40433          	add	s0,s0,a5
4000c00c:	048a9623          	sh	s0,76(s5)
			ret_val = command_add(sh->ctx->temp_buff,
4000c010:	00000413          	li	s0,0
4000c014:	000c0593          	mv	a1,s8
	while ((entry = z_shell_cmd_get(cmd, cmd_idx++, &dloc)) != NULL) {
4000c018:	00c10613          	addi	a2,sp,12
4000c01c:	000a0513          	mv	a0,s4
4000c020:	00158c13          	addi	s8,a1,1
4000c024:	ff8fd0ef          	jal	ra,4000981c <z_shell_cmd_get>
4000c028:	00050493          	mv	s1,a0
4000c02c:	06050063          	beqz	a0,4000c08c <z_shell_wildcard_process+0x190>
		if (fnmatch(pattern, entry->syntax, 0) == 0) {
4000c030:	0004a583          	lw	a1,0(s1)
4000c034:	00000613          	li	a2,0
4000c038:	00090513          	mv	a0,s2
4000c03c:	1dc010ef          	jal	ra,4000d218 <fnmatch>
4000c040:	fc051ae3          	bnez	a0,4000c014 <z_shell_wildcard_process+0x118>
					      entry->syntax, pattern);
4000c044:	0004ad83          	lw	s11,0(s1)
			ret_val = command_add(sh->ctx->temp_buff,
4000c048:	0089aa83          	lw	s5,8(s3)
4000c04c:	00000413          	li	s0,0
4000c050:	000d8a63          	beqz	s11,4000c064 <z_shell_wildcard_process+0x168>
4000c054:	000d8513          	mv	a0,s11
4000c058:	37d000ef          	jal	ra,4000cbd4 <strlen>
4000c05c:	01051413          	slli	s0,a0,0x10
4000c060:	01045413          	srli	s0,s0,0x10
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
4000c064:	04cad783          	lhu	a5,76(s5)
4000c068:	008787b3          	add	a5,a5,s0
4000c06c:	f4fcd4e3          	bge	s9,a5,4000bfb4 <z_shell_wildcard_process+0xb8>
				z_shell_fprintf(sh, SHELL_WARNING,
4000c070:	40034637          	lui	a2,0x40034
4000c074:	00090693          	mv	a3,s2
4000c078:	61460613          	addi	a2,a2,1556 # 40034614 <shell_m_sub_colors+0x3c>
4000c07c:	00300593          	li	a1,3
4000c080:	00098513          	mv	a0,s3
4000c084:	c3cfe0ef          	jal	ra,4000a4c0 <z_shell_fprintf>
			ret_val = command_add(sh->ctx->temp_buff,
4000c088:	00100413          	li	s0,1
	if (cnt > 0) {
4000c08c:	ea0b08e3          	beqz	s6,4000bf3c <z_shell_wildcard_process+0x40>
		z_shell_pattern_remove(sh->ctx->temp_buff,
4000c090:	0089a503          	lw	a0,8(s3)
4000c094:	00090613          	mv	a2,s2
4000c098:	04c50593          	addi	a1,a0,76
4000c09c:	14e50513          	addi	a0,a0,334
4000c0a0:	eb8fd0ef          	jal	ra,40009758 <z_shell_pattern_remove>
	return ret_val;
4000c0a4:	e99ff06f          	j	4000bf3c <z_shell_wildcard_process+0x40>
4000c0a8:	00200413          	li	s0,2
4000c0ac:	fe1ff06f          	j	4000c08c <z_shell_wildcard_process+0x190>

4000c0b0 <z_shell_wildcard_finalize>:

void z_shell_wildcard_finalize(const struct shell *sh)
{
4000c0b0:	ff010113          	addi	sp,sp,-16
4000c0b4:	00812423          	sw	s0,8(sp)
4000c0b8:	00112623          	sw	ra,12(sp)
4000c0bc:	00050413          	mv	s0,a0
	memcpy(sh->ctx->cmd_buff,
4000c0c0:	00852503          	lw	a0,8(a0)
4000c0c4:	04c55603          	lhu	a2,76(a0)
4000c0c8:	14e50593          	addi	a1,a0,334
4000c0cc:	04e50513          	addi	a0,a0,78
4000c0d0:	429000ef          	jal	ra,4000ccf8 <memcpy>
	       sh->ctx->temp_buff,
	       sh->ctx->cmd_tmp_buff_len);
	sh->ctx->cmd_buff_len = sh->ctx->cmd_tmp_buff_len;
4000c0d4:	00842783          	lw	a5,8(s0)
4000c0d8:	04c7d703          	lhu	a4,76(a5)
4000c0dc:	04e79423          	sh	a4,72(a5)
}
4000c0e0:	00c12083          	lw	ra,12(sp)
4000c0e4:	00812403          	lw	s0,8(sp)
4000c0e8:	01010113          	addi	sp,sp,16
4000c0ec:	00008067          	ret

4000c0f0 <arch_cpu_idle>:
	__asm__ volatile ("csrs mstatus, %0"
4000c0f0:	00800793          	li	a5,8
4000c0f4:	3007a073          	csrs	mstatus,a5
 */

void __weak arch_cpu_idle(void)
{
	irq_unlock(MSTATUS_IEN);
}
4000c0f8:	00008067          	ret

4000c0fc <z_log_msg_static_create.constprop.0>:
4000c0fc:	00000693          	li	a3,0
4000c100:	e95f806f          	j	40004f94 <z_impl_z_log_msg_static_create>

4000c104 <z_riscv_fatal_error>:
 #define NO_REG "                "
#endif

FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf)
{
4000c104:	fb010113          	addi	sp,sp,-80
4000c108:	04812423          	sw	s0,72(sp)
4000c10c:	05212023          	sw	s2,64(sp)
4000c110:	03512a23          	sw	s5,52(sp)
4000c114:	04112623          	sw	ra,76(sp)
4000c118:	04912223          	sw	s1,68(sp)
4000c11c:	03312e23          	sw	s3,60(sp)
4000c120:	03412c23          	sw	s4,56(sp)
4000c124:	03612823          	sw	s6,48(sp)
4000c128:	03712623          	sw	s7,44(sp)
4000c12c:	05010413          	addi	s0,sp,80
4000c130:	00050a93          	mv	s5,a0
4000c134:	00058913          	mv	s2,a1
	if (esf != NULL) {
4000c138:	34058a63          	beqz	a1,4000c48c <z_riscv_fatal_error+0x388>
		LOG_ERR("     a0: " PR_REG "    t0: " PR_REG, esf->a0, esf->t0);
4000c13c:	400444b7          	lui	s1,0x40044
4000c140:	7ac4a783          	lw	a5,1964(s1) # 400447ac <log_dynamic_os>
4000c144:	0077f793          	andi	a5,a5,7
4000c148:	34078263          	beqz	a5,4000c48c <z_riscv_fatal_error+0x388>
4000c14c:	00010b93          	mv	s7,sp
4000c150:	fe010113          	addi	sp,sp,-32
4000c154:	0205a683          	lw	a3,32(a1)
4000c158:	0045a703          	lw	a4,4(a1)
4000c15c:	00010613          	mv	a2,sp
4000c160:	400347b7          	lui	a5,0x40034
4000c164:	00002b37          	lui	s6,0x2
4000c168:	66878793          	addi	a5,a5,1640 # 40034668 <shell_m_sub_colors+0x90>
4000c16c:	00400a13          	li	s4,4
4000c170:	040b0993          	addi	s3,s6,64 # 2040 <CONFIG_SRAM_SIZE+0x40>
4000c174:	00f62a23          	sw	a5,20(a2)
4000c178:	00d62c23          	sw	a3,24(a2)
4000c17c:	00e62e23          	sw	a4,28(a2)
4000c180:	01462823          	sw	s4,16(a2)
4000c184:	00098593          	mv	a1,s3
4000c188:	01060613          	addi	a2,a2,16
4000c18c:	7ac48513          	addi	a0,s1,1964
4000c190:	f6dff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
		LOG_ERR("     a1: " PR_REG "    t1: " PR_REG, esf->a1, esf->t1);
4000c194:	7ac4a783          	lw	a5,1964(s1)
4000c198:	000b8113          	mv	sp,s7
4000c19c:	0077f793          	andi	a5,a5,7
4000c1a0:	2e078663          	beqz	a5,4000c48c <z_riscv_fatal_error+0x388>
4000c1a4:	fe010113          	addi	sp,sp,-32
4000c1a8:	02492683          	lw	a3,36(s2)
4000c1ac:	00892703          	lw	a4,8(s2)
4000c1b0:	00010613          	mv	a2,sp
4000c1b4:	400347b7          	lui	a5,0x40034
4000c1b8:	68478793          	addi	a5,a5,1668 # 40034684 <shell_m_sub_colors+0xac>
4000c1bc:	00f62a23          	sw	a5,20(a2)
4000c1c0:	00d62c23          	sw	a3,24(a2)
4000c1c4:	00e62e23          	sw	a4,28(a2)
4000c1c8:	01462823          	sw	s4,16(a2)
4000c1cc:	00098593          	mv	a1,s3
4000c1d0:	01060613          	addi	a2,a2,16
4000c1d4:	7ac48513          	addi	a0,s1,1964
4000c1d8:	f25ff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
		LOG_ERR("     a2: " PR_REG "    t2: " PR_REG, esf->a2, esf->t2);
4000c1dc:	7ac4a783          	lw	a5,1964(s1)
4000c1e0:	000b8113          	mv	sp,s7
4000c1e4:	0077f793          	andi	a5,a5,7
4000c1e8:	2a078263          	beqz	a5,4000c48c <z_riscv_fatal_error+0x388>
4000c1ec:	fe010113          	addi	sp,sp,-32
4000c1f0:	02892683          	lw	a3,40(s2)
4000c1f4:	00c92703          	lw	a4,12(s2)
4000c1f8:	00010613          	mv	a2,sp
4000c1fc:	400347b7          	lui	a5,0x40034
4000c200:	6a078793          	addi	a5,a5,1696 # 400346a0 <shell_m_sub_colors+0xc8>
4000c204:	00f62a23          	sw	a5,20(a2)
4000c208:	00d62c23          	sw	a3,24(a2)
4000c20c:	00e62e23          	sw	a4,28(a2)
4000c210:	01462823          	sw	s4,16(a2)
4000c214:	00098593          	mv	a1,s3
4000c218:	01060613          	addi	a2,a2,16
4000c21c:	7ac48513          	addi	a0,s1,1964
4000c220:	eddff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
#if defined(CONFIG_RISCV_ISA_RV32E)
		LOG_ERR("     a3: " PR_REG, esf->a3);
		LOG_ERR("     a4: " PR_REG, esf->a4);
		LOG_ERR("     a5: " PR_REG, esf->a5);
#else
		LOG_ERR("     a3: " PR_REG "    t3: " PR_REG, esf->a3, esf->t3);
4000c224:	7ac4a783          	lw	a5,1964(s1)
4000c228:	000b8113          	mv	sp,s7
4000c22c:	0077f793          	andi	a5,a5,7
4000c230:	24078e63          	beqz	a5,4000c48c <z_riscv_fatal_error+0x388>
4000c234:	fe010113          	addi	sp,sp,-32
4000c238:	02c92683          	lw	a3,44(s2)
4000c23c:	01092703          	lw	a4,16(s2)
4000c240:	00010613          	mv	a2,sp
4000c244:	400347b7          	lui	a5,0x40034
4000c248:	6bc78793          	addi	a5,a5,1724 # 400346bc <shell_m_sub_colors+0xe4>
4000c24c:	00f62a23          	sw	a5,20(a2)
4000c250:	00d62c23          	sw	a3,24(a2)
4000c254:	00e62e23          	sw	a4,28(a2)
4000c258:	01462823          	sw	s4,16(a2)
4000c25c:	00098593          	mv	a1,s3
4000c260:	01060613          	addi	a2,a2,16
4000c264:	7ac48513          	addi	a0,s1,1964
4000c268:	e95ff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
		LOG_ERR("     a4: " PR_REG "    t4: " PR_REG, esf->a4, esf->t4);
4000c26c:	7ac4a783          	lw	a5,1964(s1)
4000c270:	000b8113          	mv	sp,s7
4000c274:	0077f793          	andi	a5,a5,7
4000c278:	20078a63          	beqz	a5,4000c48c <z_riscv_fatal_error+0x388>
4000c27c:	fe010113          	addi	sp,sp,-32
4000c280:	03092683          	lw	a3,48(s2)
4000c284:	01492703          	lw	a4,20(s2)
4000c288:	00010613          	mv	a2,sp
4000c28c:	400347b7          	lui	a5,0x40034
4000c290:	6d878793          	addi	a5,a5,1752 # 400346d8 <shell_m_sub_colors+0x100>
4000c294:	00f62a23          	sw	a5,20(a2)
4000c298:	00d62c23          	sw	a3,24(a2)
4000c29c:	00e62e23          	sw	a4,28(a2)
4000c2a0:	01462823          	sw	s4,16(a2)
4000c2a4:	00098593          	mv	a1,s3
4000c2a8:	01060613          	addi	a2,a2,16
4000c2ac:	7ac48513          	addi	a0,s1,1964
4000c2b0:	e4dff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
		LOG_ERR("     a5: " PR_REG "    t5: " PR_REG, esf->a5, esf->t5);
4000c2b4:	7ac4a783          	lw	a5,1964(s1)
4000c2b8:	000b8113          	mv	sp,s7
4000c2bc:	0077f793          	andi	a5,a5,7
4000c2c0:	1c078663          	beqz	a5,4000c48c <z_riscv_fatal_error+0x388>
4000c2c4:	fe010113          	addi	sp,sp,-32
4000c2c8:	03492683          	lw	a3,52(s2)
4000c2cc:	01892703          	lw	a4,24(s2)
4000c2d0:	00010613          	mv	a2,sp
4000c2d4:	400347b7          	lui	a5,0x40034
4000c2d8:	6f478793          	addi	a5,a5,1780 # 400346f4 <shell_m_sub_colors+0x11c>
4000c2dc:	00f62a23          	sw	a5,20(a2)
4000c2e0:	00d62c23          	sw	a3,24(a2)
4000c2e4:	00e62e23          	sw	a4,28(a2)
4000c2e8:	01462823          	sw	s4,16(a2)
4000c2ec:	00098593          	mv	a1,s3
4000c2f0:	01060613          	addi	a2,a2,16
4000c2f4:	7ac48513          	addi	a0,s1,1964
4000c2f8:	e05ff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
		LOG_ERR("     a6: " PR_REG "    t6: " PR_REG, esf->a6, esf->t6);
4000c2fc:	7ac4a783          	lw	a5,1964(s1)
4000c300:	000b8113          	mv	sp,s7
4000c304:	0077f793          	andi	a5,a5,7
4000c308:	18078263          	beqz	a5,4000c48c <z_riscv_fatal_error+0x388>
4000c30c:	fe010113          	addi	sp,sp,-32
4000c310:	03892683          	lw	a3,56(s2)
4000c314:	01c92703          	lw	a4,28(s2)
4000c318:	00010613          	mv	a2,sp
4000c31c:	400347b7          	lui	a5,0x40034
4000c320:	71078793          	addi	a5,a5,1808 # 40034710 <shell_m_sub_colors+0x138>
4000c324:	00f62a23          	sw	a5,20(a2)
4000c328:	00d62c23          	sw	a3,24(a2)
4000c32c:	00e62e23          	sw	a4,28(a2)
4000c330:	01462823          	sw	s4,16(a2)
4000c334:	00098593          	mv	a1,s3
4000c338:	01060613          	addi	a2,a2,16
4000c33c:	7ac48513          	addi	a0,s1,1964
4000c340:	dbdff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
		LOG_ERR("     a7: " PR_REG, esf->a7);
4000c344:	7ac4a783          	lw	a5,1964(s1)
4000c348:	000b8113          	mv	sp,s7
4000c34c:	0077f793          	andi	a5,a5,7
4000c350:	12078e63          	beqz	a5,4000c48c <z_riscv_fatal_error+0x388>
4000c354:	fe010113          	addi	sp,sp,-32
4000c358:	03c92703          	lw	a4,60(s2)
4000c35c:	00010613          	mv	a2,sp
4000c360:	400347b7          	lui	a5,0x40034
4000c364:	72c78793          	addi	a5,a5,1836 # 4003472c <shell_m_sub_colors+0x154>
4000c368:	00f62a23          	sw	a5,20(a2)
4000c36c:	00300793          	li	a5,3
4000c370:	00f62823          	sw	a5,16(a2)
4000c374:	00e62c23          	sw	a4,24(a2)
4000c378:	840b0593          	addi	a1,s6,-1984
4000c37c:	01060613          	addi	a2,a2,16
4000c380:	7ac48513          	addi	a0,s1,1964
4000c384:	d79ff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
#endif /* CONFIG_RISCV_ISA_RV32E */
#ifdef CONFIG_USERSPACE
		LOG_ERR("     sp: " PR_REG, esf->sp);
#endif
		LOG_ERR("     ra: " PR_REG, esf->ra);
4000c388:	7ac4a783          	lw	a5,1964(s1)
4000c38c:	000b8113          	mv	sp,s7
4000c390:	0077f793          	andi	a5,a5,7
4000c394:	0e078c63          	beqz	a5,4000c48c <z_riscv_fatal_error+0x388>
4000c398:	00010993          	mv	s3,sp
4000c39c:	fe010113          	addi	sp,sp,-32
4000c3a0:	00092703          	lw	a4,0(s2)
4000c3a4:	00010613          	mv	a2,sp
4000c3a8:	400347b7          	lui	a5,0x40034
4000c3ac:	73c78793          	addi	a5,a5,1852 # 4003473c <shell_m_sub_colors+0x164>
4000c3b0:	00300a13          	li	s4,3
4000c3b4:	000025b7          	lui	a1,0x2
4000c3b8:	00f62a23          	sw	a5,20(a2)
4000c3bc:	00e62c23          	sw	a4,24(a2)
4000c3c0:	01462823          	sw	s4,16(a2)
4000c3c4:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
4000c3c8:	01060613          	addi	a2,a2,16
4000c3cc:	7ac48513          	addi	a0,s1,1964
4000c3d0:	d2dff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
		LOG_ERR("   mepc: " PR_REG, esf->mepc);
4000c3d4:	7ac4a783          	lw	a5,1964(s1)
4000c3d8:	00098113          	mv	sp,s3
4000c3dc:	0077f793          	andi	a5,a5,7
4000c3e0:	0a078663          	beqz	a5,4000c48c <z_riscv_fatal_error+0x388>
4000c3e4:	fe010113          	addi	sp,sp,-32
4000c3e8:	04092703          	lw	a4,64(s2)
4000c3ec:	00010613          	mv	a2,sp
4000c3f0:	400347b7          	lui	a5,0x40034
4000c3f4:	74c78793          	addi	a5,a5,1868 # 4003474c <shell_m_sub_colors+0x174>
4000c3f8:	00f62a23          	sw	a5,20(a2)
4000c3fc:	00e62c23          	sw	a4,24(a2)
4000c400:	01462823          	sw	s4,16(a2)
4000c404:	840b0593          	addi	a1,s6,-1984
4000c408:	01060613          	addi	a2,a2,16
4000c40c:	7ac48513          	addi	a0,s1,1964
4000c410:	cedff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
		LOG_ERR("mstatus: " PR_REG, esf->mstatus);
4000c414:	7ac4a783          	lw	a5,1964(s1)
4000c418:	00098113          	mv	sp,s3
4000c41c:	0077f793          	andi	a5,a5,7
4000c420:	06078663          	beqz	a5,4000c48c <z_riscv_fatal_error+0x388>
4000c424:	fe010113          	addi	sp,sp,-32
4000c428:	04492703          	lw	a4,68(s2)
4000c42c:	00010613          	mv	a2,sp
4000c430:	400347b7          	lui	a5,0x40034
4000c434:	75c78793          	addi	a5,a5,1884 # 4003475c <shell_m_sub_colors+0x184>
4000c438:	00f62a23          	sw	a5,20(a2)
4000c43c:	00e62c23          	sw	a4,24(a2)
4000c440:	01462823          	sw	s4,16(a2)
4000c444:	840b0593          	addi	a1,s6,-1984
4000c448:	01060613          	addi	a2,a2,16
4000c44c:	7ac48513          	addi	a0,s1,1964
4000c450:	cadff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
		LOG_ERR("");
4000c454:	7ac4a783          	lw	a5,1964(s1)
4000c458:	00098113          	mv	sp,s3
4000c45c:	0077f793          	andi	a5,a5,7
4000c460:	02078663          	beqz	a5,4000c48c <z_riscv_fatal_error+0x388>
4000c464:	400337b7          	lui	a5,0x40033
4000c468:	1e878793          	addi	a5,a5,488 # 400331e8 <severity_lvls+0xf0>
4000c46c:	000015b7          	lui	a1,0x1
4000c470:	fcf42623          	sw	a5,-52(s0)
4000c474:	fc840613          	addi	a2,s0,-56
4000c478:	00200793          	li	a5,2
4000c47c:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4000c480:	7ac48513          	addi	a0,s1,1964
4000c484:	fcf42423          	sw	a5,-56(s0)
4000c488:	c75ff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
	}

	z_fatal_error(reason, esf);
4000c48c:	00090593          	mv	a1,s2
4000c490:	000a8513          	mv	a0,s5
4000c494:	771210ef          	jal	ra,4002e404 <z_fatal_error>

4000c498 <_Fault>:

	return false;
}

void _Fault(z_arch_esf_t *esf)
{
4000c498:	fc010113          	addi	sp,sp,-64
4000c49c:	02812c23          	sw	s0,56(sp)
4000c4a0:	03212823          	sw	s2,48(sp)
4000c4a4:	02112e23          	sw	ra,60(sp)
4000c4a8:	02912a23          	sw	s1,52(sp)
4000c4ac:	03312623          	sw	s3,44(sp)
4000c4b0:	03412423          	sw	s4,40(sp)
4000c4b4:	03512223          	sw	s5,36(sp)
4000c4b8:	04010413          	addi	s0,sp,64
4000c4bc:	00050913          	mv	s2,a0
	}
#endif /* CONFIG_USERSPACE */

	unsigned long mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
4000c4c0:	34202a73          	csrr	s4,mcause

#ifndef CONFIG_SOC_OPENISA_RV32M1_RISCV32
	unsigned long mtval;
	__asm__ volatile("csrr %0, mtval" : "=r" (mtval));
4000c4c4:	343029f3          	csrr	s3,mtval
#endif

	mcause &= SOC_MCAUSE_EXP_MASK;
	LOG_ERR("");
4000c4c8:	400444b7          	lui	s1,0x40044
4000c4cc:	7ac4a783          	lw	a5,1964(s1) # 400447ac <log_dynamic_os>
4000c4d0:	0077f793          	andi	a5,a5,7
4000c4d4:	0e078863          	beqz	a5,4000c5c4 <_Fault+0x12c>
4000c4d8:	400337b7          	lui	a5,0x40033
4000c4dc:	1e878793          	addi	a5,a5,488 # 400331e8 <severity_lvls+0xf0>
4000c4e0:	000015b7          	lui	a1,0x1
4000c4e4:	fcf42e23          	sw	a5,-36(s0)
4000c4e8:	fd840613          	addi	a2,s0,-40
4000c4ec:	00200793          	li	a5,2
4000c4f0:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4000c4f4:	7ac48513          	addi	a0,s1,1964
4000c4f8:	fcf42c23          	sw	a5,-40(s0)
4000c4fc:	c01ff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
	LOG_ERR(" mcause: %ld, %s", mcause, cause_str(mcause));
4000c500:	7ac4a783          	lw	a5,1964(s1)
4000c504:	0077f793          	andi	a5,a5,7
4000c508:	0a078e63          	beqz	a5,4000c5c4 <_Fault+0x12c>
	mcause &= SOC_MCAUSE_EXP_MASK;
4000c50c:	800007b7          	lui	a5,0x80000
4000c510:	fff78713          	addi	a4,a5,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
4000c514:	ff078793          	addi	a5,a5,-16
4000c518:	00ea7733          	and	a4,s4,a4
	switch (cause) {
4000c51c:	00fa7a33          	and	s4,s4,a5
4000c520:	0a0a1863          	bnez	s4,4000c5d0 <_Fault+0x138>
4000c524:	400357b7          	lui	a5,0x40035
4000c528:	00271693          	slli	a3,a4,0x2
4000c52c:	8f878793          	addi	a5,a5,-1800 # 400348f8 <CSWTCH.1860>
4000c530:	00d787b3          	add	a5,a5,a3
4000c534:	0007a783          	lw	a5,0(a5)
	LOG_ERR(" mcause: %ld, %s", mcause, cause_str(mcause));
4000c538:	00010a13          	mv	s4,sp
4000c53c:	fd010113          	addi	sp,sp,-48
4000c540:	00010613          	mv	a2,sp
4000c544:	00f62e23          	sw	a5,28(a2)
4000c548:	30100793          	li	a5,769
4000c54c:	02f61023          	sh	a5,32(a2)
4000c550:	400346b7          	lui	a3,0x40034
4000c554:	010007b7          	lui	a5,0x1000
4000c558:	00478793          	addi	a5,a5,4 # 1000004 <__rom_region_size+0xfc7048>
4000c55c:	77468693          	addi	a3,a3,1908 # 40034774 <shell_m_sub_colors+0x19c>
4000c560:	00002ab7          	lui	s5,0x2
4000c564:	00f62823          	sw	a5,16(a2)
4000c568:	00d62a23          	sw	a3,20(a2)
4000c56c:	00e62c23          	sw	a4,24(a2)
4000c570:	440a8593          	addi	a1,s5,1088 # 2440 <CONFIG_SRAM_SIZE+0x440>
4000c574:	01060613          	addi	a2,a2,16
4000c578:	7ac48513          	addi	a0,s1,1964
4000c57c:	b81ff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
#ifndef CONFIG_SOC_OPENISA_RV32M1_RISCV32
	LOG_ERR("  mtval: %lx", mtval);
4000c580:	7ac4a783          	lw	a5,1964(s1)
4000c584:	000a0113          	mv	sp,s4
4000c588:	0077f793          	andi	a5,a5,7
4000c58c:	02078c63          	beqz	a5,4000c5c4 <_Fault+0x12c>
4000c590:	fe010113          	addi	sp,sp,-32
4000c594:	00010613          	mv	a2,sp
4000c598:	400347b7          	lui	a5,0x40034
4000c59c:	78878793          	addi	a5,a5,1928 # 40034788 <shell_m_sub_colors+0x1b0>
4000c5a0:	00f62a23          	sw	a5,20(a2)
4000c5a4:	00300793          	li	a5,3
4000c5a8:	01362c23          	sw	s3,24(a2)
4000c5ac:	00f62823          	sw	a5,16(a2)
4000c5b0:	840a8593          	addi	a1,s5,-1984
4000c5b4:	01060613          	addi	a2,a2,16
4000c5b8:	7ac48513          	addi	a0,s1,1964
4000c5bc:	b41ff0ef          	jal	ra,4000c0fc <z_log_msg_static_create.constprop.0>
4000c5c0:	000a0113          	mv	sp,s4

	if (bad_stack_pointer(esf)) {
		reason = K_ERR_STACK_CHK_FAIL;
	}

	z_riscv_fatal_error(reason, esf);
4000c5c4:	00090593          	mv	a1,s2
4000c5c8:	00000513          	li	a0,0
4000c5cc:	b39ff0ef          	jal	ra,4000c104 <z_riscv_fatal_error>
	mcause &= SOC_MCAUSE_EXP_MASK;
4000c5d0:	400347b7          	lui	a5,0x40034
4000c5d4:	76c78793          	addi	a5,a5,1900 # 4003476c <shell_m_sub_colors+0x194>
4000c5d8:	f61ff06f          	j	4000c538 <_Fault+0xa0>

4000c5dc <z_irq_spurious>:
#include <zephyr/arch/riscv/csr.h>

LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_irq_spurious(const void *unused)
{
4000c5dc:	ff010113          	addi	sp,sp,-16
4000c5e0:	00812423          	sw	s0,8(sp)
4000c5e4:	00112623          	sw	ra,12(sp)
4000c5e8:	00912223          	sw	s1,4(sp)
4000c5ec:	01010413          	addi	s0,sp,16
	unsigned long mcause;

	ARG_UNUSED(unused);

	mcause = csr_read(mcause);
4000c5f0:	342027f3          	csrr	a5,mcause

	mcause &= SOC_MCAUSE_EXP_MASK;

	LOG_ERR("Spurious interrupt detected! IRQ: %ld", mcause);
4000c5f4:	40044537          	lui	a0,0x40044
4000c5f8:	7ac52703          	lw	a4,1964(a0) # 400447ac <log_dynamic_os>
4000c5fc:	00777713          	andi	a4,a4,7
4000c600:	04070663          	beqz	a4,4000c64c <z_irq_spurious+0x70>
4000c604:	00010493          	mv	s1,sp
4000c608:	fe010113          	addi	sp,sp,-32
4000c60c:	00010613          	mv	a2,sp
	mcause &= SOC_MCAUSE_EXP_MASK;
4000c610:	00179793          	slli	a5,a5,0x1
4000c614:	0017d793          	srli	a5,a5,0x1
	LOG_ERR("Spurious interrupt detected! IRQ: %ld", mcause);
4000c618:	40035737          	lui	a4,0x40035
4000c61c:	93870713          	addi	a4,a4,-1736 # 40034938 <CSWTCH.1860+0x40>
4000c620:	00f62c23          	sw	a5,24(a2)
4000c624:	00300793          	li	a5,3
4000c628:	00e62a23          	sw	a4,20(a2)
4000c62c:	00f62823          	sw	a5,16(a2)
4000c630:	000025b7          	lui	a1,0x2
4000c634:	00000693          	li	a3,0
4000c638:	01060613          	addi	a2,a2,16
4000c63c:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
4000c640:	7ac50513          	addi	a0,a0,1964
4000c644:	951f80ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
4000c648:	00048113          	mv	sp,s1
	if (mcause == RISCV_MACHINE_EXT_IRQ) {
		LOG_ERR("PLIC interrupt line causing the IRQ: %d",
			riscv_plic_get_irq());
	}
#endif
	z_riscv_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
4000c64c:	00000593          	li	a1,0
4000c650:	00100513          	li	a0,1
4000c654:	ab1ff0ef          	jal	ra,4000c104 <z_riscv_fatal_error>

4000c658 <_PrepC>:
 *
 * This routine prepares for the execution of and runs C code.
 */

void _PrepC(void)
{
4000c658:	ff010113          	addi	sp,sp,-16
4000c65c:	00112623          	sw	ra,12(sp)
	z_bss_zero();
4000c660:	040220ef          	jal	ra,4002e6a0 <z_bss_zero>
	z_data_copy();
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
#endif
	z_cstart();
4000c664:	128220ef          	jal	ra,4002e78c <z_cstart>

4000c668 <__initialize>:
/*
 * Remainder of asm-land initialization code before we can jump into
 * the C domain
 */
SECTION_FUNC(TEXT, __initialize)
	csrr a0, mhartid
4000c668:	f1402573          	csrr	a0,mhartid
	li t0, CONFIG_RV_BOOT_HART
4000c66c:	00000293          	li	t0,0
	beq a0, t0, boot_first_core
4000c670:	00550463          	beq	a0,t0,4000c678 <boot_first_core>
	j boot_secondary_core
4000c674:	0440006f          	j	4000c6b8 <boot_secondary_core>

4000c678 <boot_first_core>:
	fscsr zero
#endif

#ifdef CONFIG_INIT_STACKS
	/* Pre-populate all bytes in z_interrupt_stacks with 0xAA */
	la t0, z_interrupt_stacks
4000c678:	00030297          	auipc	t0,0x30
4000c67c:	35828293          	addi	t0,t0,856 # 4003c9d0 <z_interrupt_stacks>
	li t1, __z_interrupt_stack_SIZEOF
4000c680:	00001337          	lui	t1,0x1
4000c684:	80030313          	addi	t1,t1,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add t1, t1, t0
4000c688:	00530333          	add	t1,t1,t0

	/* Populate z_interrupt_stacks with 0xaaaaaaaa */
	li t2, 0xaaaaaaaa
4000c68c:	aaaab3b7          	lui	t2,0xaaaab
4000c690:	aaa38393          	addi	t2,t2,-1366 # aaaaaaaa <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xaaaaaaab>

4000c694 <aa_loop>:
aa_loop:
	sw t2, 0x00(t0)
4000c694:	0072a023          	sw	t2,0(t0)
	addi t0, t0, 4
4000c698:	00428293          	addi	t0,t0,4
	blt t0, t1, aa_loop
4000c69c:	fe62cce3          	blt	t0,t1,4000c694 <aa_loop>

	/*
	 * Initially, setup stack pointer to
	 * z_interrupt_stacks + __z_interrupt_stack_SIZEOF
	 */
	la sp, z_interrupt_stacks
4000c6a0:	00030117          	auipc	sp,0x30
4000c6a4:	33010113          	addi	sp,sp,816 # 4003c9d0 <z_interrupt_stacks>
	li t0, __z_interrupt_stack_SIZEOF
4000c6a8:	000012b7          	lui	t0,0x1
4000c6ac:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add sp, sp, t0
4000c6b0:	00510133          	add	sp,sp,t0

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
4000c6b4:	fa5ff0ef          	jal	ra,4000c658 <_PrepC>

4000c6b8 <boot_secondary_core>:

	la t0, riscv_cpu_wake_flag
	sr zero, 0(t0)
	j z_riscv_secondary_cpu_init
#else
	j loop_unconfigured_cores
4000c6b8:	0040006f          	j	4000c6bc <loop_unconfigured_cores>

4000c6bc <loop_unconfigured_cores>:
#endif

loop_unconfigured_cores:
	wfi
4000c6bc:	10500073          	wfi
	j loop_unconfigured_cores
4000c6c0:	ffdff06f          	j	4000c6bc <loop_unconfigured_cores>

4000c6c4 <z_riscv_switch>:

/* void z_riscv_switch(k_thread_t *switch_to, k_thread_t *switch_from) */
SECTION_FUNC(TEXT, z_riscv_switch)

	/* Save the old thread's callee-saved registers */
	DO_CALLEE_SAVED(sr, a1)
4000c6c4:	0215aa23          	sw	ra,52(a1)
4000c6c8:	0285ac23          	sw	s0,56(a1)
4000c6cc:	0295ae23          	sw	s1,60(a1)
4000c6d0:	0525a023          	sw	s2,64(a1)
4000c6d4:	0535a223          	sw	s3,68(a1)
4000c6d8:	0545a423          	sw	s4,72(a1)
4000c6dc:	0555a623          	sw	s5,76(a1)
4000c6e0:	0565a823          	sw	s6,80(a1)
4000c6e4:	0575aa23          	sw	s7,84(a1)
4000c6e8:	0585ac23          	sw	s8,88(a1)
4000c6ec:	0595ae23          	sw	s9,92(a1)
4000c6f0:	07a5a023          	sw	s10,96(a1)
4000c6f4:	07b5a223          	sw	s11,100(a1)

	/* Save the old thread's stack pointer */
	sr sp, _thread_offset_to_sp(a1)
4000c6f8:	0225a823          	sw	sp,48(a1)

	/* Set thread->switch_handle = thread to mark completion */
	sr a1, ___thread_t_switch_handle_OFFSET(a1)
4000c6fc:	0cb5a023          	sw	a1,192(a1)

	/* Get the new thread's stack pointer */
	lr sp, _thread_offset_to_sp(a0)
4000c700:	03052103          	lw	sp,48(a0)
	call z_thread_mark_switched_in
	mv a0, s0
#endif

	/* Restore the new thread's callee-saved registers */
	DO_CALLEE_SAVED(lr, a0)
4000c704:	03452083          	lw	ra,52(a0)
4000c708:	03852403          	lw	s0,56(a0)
4000c70c:	03c52483          	lw	s1,60(a0)
4000c710:	04052903          	lw	s2,64(a0)
4000c714:	04452983          	lw	s3,68(a0)
4000c718:	04852a03          	lw	s4,72(a0)
4000c71c:	04c52a83          	lw	s5,76(a0)
4000c720:	05052b03          	lw	s6,80(a0)
4000c724:	05452b83          	lw	s7,84(a0)
4000c728:	05852c03          	lw	s8,88(a0)
4000c72c:	05c52c83          	lw	s9,92(a0)
4000c730:	06052d03          	lw	s10,96(a0)
4000c734:	06452d83          	lw	s11,100(a0)

	/* Return to arch_switch() or _irq_wrapper() */
	ret
4000c738:	00008067          	ret

4000c73c <arch_new_thread>:
#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	const struct soc_esf soc_esf_init = {SOC_ESF_INIT};
#endif

	/* Initial stack frame for thread */
	stack_init = (struct __esf *)Z_STACK_PTR_ALIGN(
4000c73c:	fb060613          	addi	a2,a2,-80
 * @param ptr Proposed stack pointer address
 * @return Properly aligned stack pointer address
 */
static inline char *z_stack_ptr_align(char *ptr)
{
	return (char *)ROUND_DOWN(ptr, ARCH_STACK_PTR_ALIGN);
4000c740:	ff067613          	andi	a2,a2,-16
				);

	/* Setup the initial stack frame */
	stack_init->a0 = (unsigned long)entry;
	stack_init->a1 = (unsigned long)p1;
	stack_init->a2 = (unsigned long)p2;
4000c744:	02f62423          	sw	a5,40(a2)
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to z_thread_entry, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = MSTATUS_DEF_RESTORE;
4000c748:	000027b7          	lui	a5,0x2
4000c74c:	88078793          	addi	a5,a5,-1920 # 1880 <CONFIG_HEAP_MEM_POOL_SIZE+0x880>
4000c750:	04f62223          	sw	a5,68(a2)
		/* User thread */
		stack_init->mepc = (unsigned long)k_thread_user_mode_enter;

	} else {
		/* Supervisor thread */
		stack_init->mepc = (unsigned long)z_thread_entry;
4000c754:	400027b7          	lui	a5,0x40002
4000c758:	d5078793          	addi	a5,a5,-688 # 40001d50 <z_thread_entry>
4000c75c:	04f62023          	sw	a5,64(a2)
#endif

	thread->callee_saved.sp = (unsigned long)stack_init;

	/* where to go when returning from z_riscv_switch() */
	thread->callee_saved.ra = (unsigned long)z_riscv_thread_start;
4000c760:	400007b7          	lui	a5,0x40000
	stack_init->a0 = (unsigned long)entry;
4000c764:	02d62023          	sw	a3,32(a2)
	stack_init->a1 = (unsigned long)p1;
4000c768:	02e62223          	sw	a4,36(a2)
	stack_init->a3 = (unsigned long)p3;
4000c76c:	03062623          	sw	a6,44(a2)
	thread->callee_saved.ra = (unsigned long)z_riscv_thread_start;
4000c770:	15478793          	addi	a5,a5,340 # 40000154 <z_riscv_thread_start>
	thread->callee_saved.sp = (unsigned long)stack_init;
4000c774:	02c52823          	sw	a2,48(a0)
	thread->callee_saved.ra = (unsigned long)z_riscv_thread_start;
4000c778:	02f52a23          	sw	a5,52(a0)

	/* our switch handle is the thread pointer itself */
	thread->switch_handle = thread;
4000c77c:	0ca52023          	sw	a0,192(a0)
}
4000c780:	00008067          	ret

4000c784 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
4000c784:	ff010113          	addi	sp,sp,-16
4000c788:	00812423          	sw	s0,8(sp)
4000c78c:	01212023          	sw	s2,0(sp)
4000c790:	00112623          	sw	ra,12(sp)
4000c794:	00058913          	mv	s2,a1
4000c798:	00912223          	sw	s1,4(sp)
4000c79c:	00050693          	mv	a3,a0
	register const char *s = nptr;
4000c7a0:	00050413          	mv	s0,a0
4000c7a4:	02000813          	li	a6,32
4000c7a8:	00400593          	li	a1,4
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
4000c7ac:	00040713          	mv	a4,s0
4000c7b0:	00044783          	lbu	a5,0(s0)
4000c7b4:	00140413          	addi	s0,s0,1
4000c7b8:	ff078ae3          	beq	a5,a6,4000c7ac <strtol+0x28>
4000c7bc:	ff778513          	addi	a0,a5,-9
4000c7c0:	fea5f6e3          	bgeu	a1,a0,4000c7ac <strtol+0x28>
	} while (isspace((unsigned char)c) != 0);
	if (c == '-') {
4000c7c4:	02d00593          	li	a1,45
4000c7c8:	02b79a63          	bne	a5,a1,4000c7fc <strtol+0x78>
		neg = 1;
		c = *s++;
4000c7cc:	00174783          	lbu	a5,1(a4)
4000c7d0:	00270413          	addi	s0,a4,2
		neg = 1;
4000c7d4:	00100813          	li	a6,1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
4000c7d8:	02061e63          	bnez	a2,4000c814 <strtol+0x90>
4000c7dc:	03000713          	li	a4,48
		s += 2;
		base = 16;
	}

	if (base == 0) {
		base = c == '0' ? 8 : 10;
4000c7e0:	00a00613          	li	a2,10
	if ((base == 0 || base == 16) &&
4000c7e4:	04e79e63          	bne	a5,a4,4000c840 <strtol+0xbc>
	    c == '0' && (*s == 'x' || *s == 'X')) {
4000c7e8:	00044703          	lbu	a4,0(s0)
4000c7ec:	05800593          	li	a1,88
		base = c == '0' ? 8 : 10;
4000c7f0:	00800613          	li	a2,8
	    c == '0' && (*s == 'x' || *s == 'X')) {
4000c7f4:	0df77713          	andi	a4,a4,223
4000c7f8:	0380006f          	j	4000c830 <strtol+0xac>
	} else if (c == '+') {
4000c7fc:	02b00593          	li	a1,43
	register int neg = 0, any, cutlim;
4000c800:	00000813          	li	a6,0
	} else if (c == '+') {
4000c804:	fcb79ae3          	bne	a5,a1,4000c7d8 <strtol+0x54>
		c = *s++;
4000c808:	00174783          	lbu	a5,1(a4)
4000c80c:	00270413          	addi	s0,a4,2
4000c810:	fc9ff06f          	j	4000c7d8 <strtol+0x54>
	if ((base == 0 || base == 16) &&
4000c814:	01000713          	li	a4,16
4000c818:	02e61463          	bne	a2,a4,4000c840 <strtol+0xbc>
4000c81c:	03000713          	li	a4,48
4000c820:	02e79063          	bne	a5,a4,4000c840 <strtol+0xbc>
	    c == '0' && (*s == 'x' || *s == 'X')) {
4000c824:	00044703          	lbu	a4,0(s0)
4000c828:	05800593          	li	a1,88
4000c82c:	0df77713          	andi	a4,a4,223
4000c830:	00b71863          	bne	a4,a1,4000c840 <strtol+0xbc>
		c = s[1];
4000c834:	00144783          	lbu	a5,1(s0)
		base = 16;
4000c838:	01000613          	li	a2,16
		s += 2;
4000c83c:	00240413          	addi	s0,s0,2
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
4000c840:	800004b7          	lui	s1,0x80000
4000c844:	fff48493          	addi	s1,s1,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
4000c848:	009804b3          	add	s1,a6,s1
	cutlim = cutoff % (unsigned long)base;
4000c84c:	02c4feb3          	remu	t4,s1,a2
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
4000c850:	00000593          	li	a1,0
4000c854:	00000513          	li	a0,0
		if (isdigit((unsigned char)c) != 0) {
4000c858:	00900f13          	li	t5,9
			c -= '0';
		} else if (isalpha((unsigned char)c) != 0) {
4000c85c:	01900e13          	li	t3,25
			break;
		}
		if (c >= base) {
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
4000c860:	fff00f93          	li	t6,-1
	cutoff /= (unsigned long)base;
4000c864:	02c4d333          	divu	t1,s1,a2
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
4000c868:	fd078713          	addi	a4,a5,-48
		if (isdigit((unsigned char)c) != 0) {
4000c86c:	02ef6c63          	bltu	t5,a4,4000c8a4 <strtol+0x120>
			c -= '0';
4000c870:	00070793          	mv	a5,a4
		if (c >= base) {
4000c874:	04c7da63          	bge	a5,a2,4000c8c8 <strtol+0x144>
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
4000c878:	03f58063          	beq	a1,t6,4000c898 <strtol+0x114>
			any = -1;
4000c87c:	fff00593          	li	a1,-1
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
4000c880:	00a36c63          	bltu	t1,a0,4000c898 <strtol+0x114>
4000c884:	00651463          	bne	a0,t1,4000c88c <strtol+0x108>
4000c888:	00fec863          	blt	t4,a5,4000c898 <strtol+0x114>
		} else {
			any = 1;
4000c88c:	00100593          	li	a1,1
			acc *= base;
4000c890:	02a60533          	mul	a0,a2,a0
			acc += c;
4000c894:	00a78533          	add	a0,a5,a0
	for (acc = 0, any = 0;; c = *s++) {
4000c898:	00140413          	addi	s0,s0,1
4000c89c:	fff44783          	lbu	a5,-1(s0)
		if (isdigit((unsigned char)c) != 0) {
4000c8a0:	fc9ff06f          	j	4000c868 <strtol+0xe4>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
4000c8a4:	0207e713          	ori	a4,a5,32
4000c8a8:	f9f70713          	addi	a4,a4,-97
		} else if (isalpha((unsigned char)c) != 0) {
4000c8ac:	00ee6e63          	bltu	t3,a4,4000c8c8 <strtol+0x144>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
4000c8b0:	fbf78893          	addi	a7,a5,-65
			c -= isupper((unsigned char)c) != 0 ? 'A' - 10 : 'a' - 10;
4000c8b4:	03700713          	li	a4,55
4000c8b8:	011e7463          	bgeu	t3,a7,4000c8c0 <strtol+0x13c>
4000c8bc:	05700713          	li	a4,87
4000c8c0:	40e787b3          	sub	a5,a5,a4
4000c8c4:	fb1ff06f          	j	4000c874 <strtol+0xf0>
		}
	}

	if (any < 0) {
4000c8c8:	fff00793          	li	a5,-1
4000c8cc:	02f59863          	bne	a1,a5,4000c8fc <strtol+0x178>
4000c8d0:	2c5210ef          	jal	ra,4002e394 <z_impl_z_errno>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
4000c8d4:	02200793          	li	a5,34
4000c8d8:	00f52023          	sw	a5,0(a0)
		acc = neg ? LONG_MIN : LONG_MAX;
4000c8dc:	00048513          	mv	a0,s1
	} else if (neg) {
		acc = -acc;
	}

	if (endptr != NULL) {
4000c8e0:	02091663          	bnez	s2,4000c90c <strtol+0x188>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
4000c8e4:	00c12083          	lw	ra,12(sp)
4000c8e8:	00812403          	lw	s0,8(sp)
4000c8ec:	00412483          	lw	s1,4(sp)
4000c8f0:	00012903          	lw	s2,0(sp)
4000c8f4:	01010113          	addi	sp,sp,16
4000c8f8:	00008067          	ret
	} else if (neg) {
4000c8fc:	00080463          	beqz	a6,4000c904 <strtol+0x180>
		acc = -acc;
4000c900:	40a00533          	neg	a0,a0
	if (endptr != NULL) {
4000c904:	fe0900e3          	beqz	s2,4000c8e4 <strtol+0x160>
		*endptr = (char *)(any ? s - 1 : nptr);
4000c908:	00058463          	beqz	a1,4000c910 <strtol+0x18c>
4000c90c:	fff40693          	addi	a3,s0,-1
4000c910:	00d92023          	sw	a3,0(s2)
4000c914:	fd1ff06f          	j	4000c8e4 <strtol+0x160>

4000c918 <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
4000c918:	ff010113          	addi	sp,sp,-16
4000c91c:	00812423          	sw	s0,8(sp)
4000c920:	00912223          	sw	s1,4(sp)
4000c924:	00112623          	sw	ra,12(sp)
4000c928:	00058493          	mv	s1,a1
4000c92c:	00050693          	mv	a3,a0
	register const char *s = nptr;
4000c930:	00050413          	mv	s0,a0
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
4000c934:	02000813          	li	a6,32
4000c938:	00400593          	li	a1,4

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
4000c93c:	00040713          	mv	a4,s0
4000c940:	00044783          	lbu	a5,0(s0)
4000c944:	00140413          	addi	s0,s0,1
4000c948:	ff078ae3          	beq	a5,a6,4000c93c <strtoul+0x24>
4000c94c:	ff778513          	addi	a0,a5,-9
4000c950:	fea5f6e3          	bgeu	a1,a0,4000c93c <strtoul+0x24>
	} while (isspace((unsigned char)c) != 0);
	if (c == '-') {
4000c954:	02d00593          	li	a1,45
4000c958:	02b79a63          	bne	a5,a1,4000c98c <strtoul+0x74>
		neg = 1;
		c = *s++;
4000c95c:	00174783          	lbu	a5,1(a4)
4000c960:	00270413          	addi	s0,a4,2
		neg = 1;
4000c964:	00100313          	li	t1,1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
4000c968:	02061e63          	bnez	a2,4000c9a4 <strtoul+0x8c>
4000c96c:	03000713          	li	a4,48
		s += 2;
		base = 16;
	}

	if (base == 0) {
		base = c == '0' ? 8 : 10;
4000c970:	00a00613          	li	a2,10
	if ((base == 0 || base == 16) &&
4000c974:	04e79e63          	bne	a5,a4,4000c9d0 <strtoul+0xb8>
	    c == '0' && (*s == 'x' || *s == 'X')) {
4000c978:	00044703          	lbu	a4,0(s0)
4000c97c:	05800593          	li	a1,88
		base = c == '0' ? 8 : 10;
4000c980:	00800613          	li	a2,8
	    c == '0' && (*s == 'x' || *s == 'X')) {
4000c984:	0df77713          	andi	a4,a4,223
4000c988:	0380006f          	j	4000c9c0 <strtoul+0xa8>
	} else if (c == '+') {
4000c98c:	02b00593          	li	a1,43
	register int neg = 0, any, cutlim;
4000c990:	00000313          	li	t1,0
	} else if (c == '+') {
4000c994:	fcb79ae3          	bne	a5,a1,4000c968 <strtoul+0x50>
		c = *s++;
4000c998:	00174783          	lbu	a5,1(a4)
4000c99c:	00270413          	addi	s0,a4,2
4000c9a0:	fc9ff06f          	j	4000c968 <strtoul+0x50>
	if ((base == 0 || base == 16) &&
4000c9a4:	01000713          	li	a4,16
4000c9a8:	02e61463          	bne	a2,a4,4000c9d0 <strtoul+0xb8>
4000c9ac:	03000713          	li	a4,48
4000c9b0:	02e79063          	bne	a5,a4,4000c9d0 <strtoul+0xb8>
	    c == '0' && (*s == 'x' || *s == 'X')) {
4000c9b4:	00044703          	lbu	a4,0(s0)
4000c9b8:	05800593          	li	a1,88
4000c9bc:	0df77713          	andi	a4,a4,223
4000c9c0:	00b71863          	bne	a4,a1,4000c9d0 <strtoul+0xb8>
		c = s[1];
4000c9c4:	00144783          	lbu	a5,1(s0)
		base = 16;
4000c9c8:	01000613          	li	a2,16
		s += 2;
4000c9cc:	00240413          	addi	s0,s0,2
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
4000c9d0:	fff00713          	li	a4,-1
4000c9d4:	02c75e33          	divu	t3,a4,a2
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
4000c9d8:	00000593          	li	a1,0
4000c9dc:	00000513          	li	a0,0
		if (isdigit((unsigned char)c) != 0) {
4000c9e0:	00900f13          	li	t5,9
			c -= '0';
		} else if (isalpha((unsigned char)c) != 0) {
4000c9e4:	01900e93          	li	t4,25
			break;
		}
		if (c >= base) {
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
4000c9e8:	fff00f93          	li	t6,-1
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
4000c9ec:	02c77833          	remu	a6,a4,a2
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
4000c9f0:	fd078713          	addi	a4,a5,-48
		if (isdigit((unsigned char)c) != 0) {
4000c9f4:	02ef6c63          	bltu	t5,a4,4000ca2c <strtoul+0x114>
			c -= '0';
4000c9f8:	00070793          	mv	a5,a4
		if (c >= base) {
4000c9fc:	04c7da63          	bge	a5,a2,4000ca50 <strtoul+0x138>
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
4000ca00:	03f58063          	beq	a1,t6,4000ca20 <strtoul+0x108>
			any = -1;
4000ca04:	fff00593          	li	a1,-1
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
4000ca08:	00ae6c63          	bltu	t3,a0,4000ca20 <strtoul+0x108>
4000ca0c:	01c51463          	bne	a0,t3,4000ca14 <strtoul+0xfc>
4000ca10:	00f84863          	blt	a6,a5,4000ca20 <strtoul+0x108>
		} else {
			any = 1;
4000ca14:	00100593          	li	a1,1
			acc *= base;
4000ca18:	02a60533          	mul	a0,a2,a0
			acc += c;
4000ca1c:	00a78533          	add	a0,a5,a0
	for (acc = 0, any = 0;; c = *s++) {
4000ca20:	00140413          	addi	s0,s0,1
4000ca24:	fff44783          	lbu	a5,-1(s0)
		if (isdigit((unsigned char)c) != 0) {
4000ca28:	fc9ff06f          	j	4000c9f0 <strtoul+0xd8>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
4000ca2c:	0207e713          	ori	a4,a5,32
4000ca30:	f9f70713          	addi	a4,a4,-97
		} else if (isalpha((unsigned char)c) != 0) {
4000ca34:	00eeee63          	bltu	t4,a4,4000ca50 <strtoul+0x138>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
4000ca38:	fbf78893          	addi	a7,a5,-65
			c -= isupper((unsigned char)c) != 0 ? 'A' - 10 : 'a' - 10;
4000ca3c:	03700713          	li	a4,55
4000ca40:	011ef463          	bgeu	t4,a7,4000ca48 <strtoul+0x130>
4000ca44:	05700713          	li	a4,87
4000ca48:	40e787b3          	sub	a5,a5,a4
4000ca4c:	fb1ff06f          	j	4000c9fc <strtoul+0xe4>
		}
	}
	if (any < 0) {
4000ca50:	fff00793          	li	a5,-1
4000ca54:	02f59663          	bne	a1,a5,4000ca80 <strtoul+0x168>
4000ca58:	13d210ef          	jal	ra,4002e394 <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
4000ca5c:	02200793          	li	a5,34
4000ca60:	00f52023          	sw	a5,0(a0)
		acc = ULONG_MAX;
4000ca64:	fff00513          	li	a0,-1
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
4000ca68:	02049463          	bnez	s1,4000ca90 <strtoul+0x178>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
4000ca6c:	00c12083          	lw	ra,12(sp)
4000ca70:	00812403          	lw	s0,8(sp)
4000ca74:	00412483          	lw	s1,4(sp)
4000ca78:	01010113          	addi	sp,sp,16
4000ca7c:	00008067          	ret
	} else if (neg) {
4000ca80:	00030463          	beqz	t1,4000ca88 <strtoul+0x170>
		acc = -acc;
4000ca84:	40a00533          	neg	a0,a0
	if (endptr != NULL) {
4000ca88:	fe0482e3          	beqz	s1,4000ca6c <strtoul+0x154>
		*endptr = (char *)(any ? s - 1 : nptr);
4000ca8c:	00058463          	beqz	a1,4000ca94 <strtoul+0x17c>
4000ca90:	fff40693          	addi	a3,s0,-1
4000ca94:	00d4a023          	sw	a3,0(s1)
	return acc;
4000ca98:	fd5ff06f          	j	4000ca6c <strtoul+0x154>

4000ca9c <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
4000ca9c:	fe010113          	addi	sp,sp,-32
4000caa0:	00812c23          	sw	s0,24(sp)
4000caa4:	00112e23          	sw	ra,28(sp)
4000caa8:	00912a23          	sw	s1,20(sp)
4000caac:	01212823          	sw	s2,16(sp)
4000cab0:	01312623          	sw	s3,12(sp)
4000cab4:	01412423          	sw	s4,8(sp)
	char c, sc;
	size_t len;

	c = *find++;
4000cab8:	0005ca03          	lbu	s4,0(a1)
{
4000cabc:	00050413          	mv	s0,a0
	if (c != 0) {
4000cac0:	020a0c63          	beqz	s4,4000caf8 <strstr+0x5c>
	c = *find++;
4000cac4:	00158493          	addi	s1,a1,1
		len = strlen(find);
4000cac8:	00048513          	mv	a0,s1
4000cacc:	108000ef          	jal	ra,4000cbd4 <strlen>
4000cad0:	00050913          	mv	s2,a0
		do {
			do {
				sc = *s++;
4000cad4:	00044783          	lbu	a5,0(s0)
4000cad8:	00140993          	addi	s3,s0,1
				if (sc == 0) {
4000cadc:	04078463          	beqz	a5,4000cb24 <strstr+0x88>
					return NULL;
				}
			} while (sc != c);
4000cae0:	02fa1e63          	bne	s4,a5,4000cb1c <strstr+0x80>
		} while (strncmp(s, find, len) != 0);
4000cae4:	00090613          	mv	a2,s2
4000cae8:	00048593          	mv	a1,s1
4000caec:	00098513          	mv	a0,s3
4000caf0:	14c000ef          	jal	ra,4000cc3c <strncmp>
4000caf4:	02051463          	bnez	a0,4000cb1c <strstr+0x80>
		s--;
	}
	return (char *)s;
}
4000caf8:	01c12083          	lw	ra,28(sp)
4000cafc:	00040513          	mv	a0,s0
4000cb00:	01812403          	lw	s0,24(sp)
4000cb04:	01412483          	lw	s1,20(sp)
4000cb08:	01012903          	lw	s2,16(sp)
4000cb0c:	00c12983          	lw	s3,12(sp)
4000cb10:	00812a03          	lw	s4,8(sp)
4000cb14:	02010113          	addi	sp,sp,32
4000cb18:	00008067          	ret
{
4000cb1c:	00098413          	mv	s0,s3
4000cb20:	fb5ff06f          	j	4000cad4 <strstr+0x38>
					return NULL;
4000cb24:	00000413          	li	s0,0
4000cb28:	fd1ff06f          	j	4000caf8 <strstr+0x5c>

4000cb2c <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
4000cb2c:	00050793          	mv	a5,a0
4000cb30:	0005c703          	lbu	a4,0(a1)
4000cb34:	00071663          	bnez	a4,4000cb40 <strcpy+0x14>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
4000cb38:	00078023          	sb	zero,0(a5)

	return dest;
}
4000cb3c:	00008067          	ret
		*d = *s;
4000cb40:	00e78023          	sb	a4,0(a5)
		s++;
4000cb44:	00158593          	addi	a1,a1,1
		d++;
4000cb48:	00178793          	addi	a5,a5,1
		s++;
4000cb4c:	fe5ff06f          	j	4000cb30 <strcpy+0x4>

4000cb50 <strncpy>:

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
	char *dest = d;

	while ((n > 0) && *s != '\0') {
4000cb50:	00050793          	mv	a5,a0
4000cb54:	00061863          	bnez	a2,4000cb64 <strncpy+0x14>
4000cb58:	00c78633          	add	a2,a5,a2
		s++;
		d++;
		n--;
	}

	while (n > 0) {
4000cb5c:	02c79263          	bne	a5,a2,4000cb80 <strncpy+0x30>
		d++;
		n--;
	}

	return dest;
}
4000cb60:	00008067          	ret
	while ((n > 0) && *s != '\0') {
4000cb64:	0005c703          	lbu	a4,0(a1)
4000cb68:	fe0708e3          	beqz	a4,4000cb58 <strncpy+0x8>
		*d = *s;
4000cb6c:	00e78023          	sb	a4,0(a5)
		s++;
4000cb70:	00158593          	addi	a1,a1,1
		d++;
4000cb74:	00178793          	addi	a5,a5,1
		n--;
4000cb78:	fff60613          	addi	a2,a2,-1
4000cb7c:	fd9ff06f          	j	4000cb54 <strncpy+0x4>
		*d = '\0';
4000cb80:	00078023          	sb	zero,0(a5)
		d++;
4000cb84:	00178793          	addi	a5,a5,1
		n--;
4000cb88:	fd5ff06f          	j	4000cb5c <strncpy+0xc>

4000cb8c <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
4000cb8c:	0ff5f593          	zext.b	a1,a1

	while ((*s != tmp) && (*s != '\0')) {
4000cb90:	00054783          	lbu	a5,0(a0)
4000cb94:	00b78863          	beq	a5,a1,4000cba4 <strchr+0x18>
4000cb98:	00079863          	bnez	a5,4000cba8 <strchr+0x1c>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
4000cb9c:	00058463          	beqz	a1,4000cba4 <strchr+0x18>
4000cba0:	00000513          	li	a0,0
}
4000cba4:	00008067          	ret
		s++;
4000cba8:	00150513          	addi	a0,a0,1
4000cbac:	fe5ff06f          	j	4000cb90 <strchr+0x4>

4000cbb0 <strrchr>:
 *
 * @return pointer to last instance of found byte, or NULL if not found
 */

char *strrchr(const char *s, int c)
{
4000cbb0:	00050793          	mv	a5,a0
	char *match = NULL;

	do {
		if (*s == (char)c) {
4000cbb4:	0ff5f593          	zext.b	a1,a1
	char *match = NULL;
4000cbb8:	00000513          	li	a0,0
		if (*s == (char)c) {
4000cbbc:	0007c703          	lbu	a4,0(a5)
4000cbc0:	00b71463          	bne	a4,a1,4000cbc8 <strrchr+0x18>
4000cbc4:	00078513          	mv	a0,a5
			match = (char *)s;
		}
	} while (*s++);
4000cbc8:	00178793          	addi	a5,a5,1
4000cbcc:	fe0718e3          	bnez	a4,4000cbbc <strrchr+0xc>

	return match;
}
4000cbd0:	00008067          	ret

4000cbd4 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
4000cbd4:	00050793          	mv	a5,a0
	size_t n = 0;
4000cbd8:	00000513          	li	a0,0

	while (*s != '\0') {
4000cbdc:	00a78733          	add	a4,a5,a0
4000cbe0:	00074703          	lbu	a4,0(a4)
4000cbe4:	00071463          	bnez	a4,4000cbec <strlen+0x18>
		s++;
		n++;
	}

	return n;
}
4000cbe8:	00008067          	ret
		n++;
4000cbec:	00150513          	addi	a0,a0,1
4000cbf0:	fedff06f          	j	4000cbdc <strlen+0x8>

4000cbf4 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
4000cbf4:	00050793          	mv	a5,a0
	size_t n = 0;
4000cbf8:	00000513          	li	a0,0

	while (*s != '\0' && n < maxlen) {
4000cbfc:	00a78733          	add	a4,a5,a0
4000cc00:	00074703          	lbu	a4,0(a4)
4000cc04:	00070463          	beqz	a4,4000cc0c <strnlen+0x18>
4000cc08:	00b51463          	bne	a0,a1,4000cc10 <strnlen+0x1c>
		s++;
		n++;
	}

	return n;
}
4000cc0c:	00008067          	ret
		n++;
4000cc10:	00150513          	addi	a0,a0,1
4000cc14:	fe9ff06f          	j	4000cbfc <strnlen+0x8>

4000cc18 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
4000cc18:	00054783          	lbu	a5,0(a0)
4000cc1c:	0005c703          	lbu	a4,0(a1)
4000cc20:	00e79463          	bne	a5,a4,4000cc28 <strcmp+0x10>
4000cc24:	00079663          	bnez	a5,4000cc30 <strcmp+0x18>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
4000cc28:	40e78533          	sub	a0,a5,a4
4000cc2c:	00008067          	ret
		s1++;
4000cc30:	00150513          	addi	a0,a0,1
		s2++;
4000cc34:	00158593          	addi	a1,a1,1
4000cc38:	fe1ff06f          	j	4000cc18 <strcmp>

4000cc3c <strncmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
4000cc3c:	02060a63          	beqz	a2,4000cc70 <strncmp+0x34>
4000cc40:	00054703          	lbu	a4,0(a0)
4000cc44:	0005c783          	lbu	a5,0(a1)
4000cc48:	00e79463          	bne	a5,a4,4000cc50 <strncmp+0x14>
4000cc4c:	00079a63          	bnez	a5,4000cc60 <strncmp+0x24>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
4000cc50:	00054503          	lbu	a0,0(a0)
4000cc54:	0005c783          	lbu	a5,0(a1)
4000cc58:	40f50533          	sub	a0,a0,a5
}
4000cc5c:	00008067          	ret
		s1++;
4000cc60:	00150513          	addi	a0,a0,1
		s2++;
4000cc64:	00158593          	addi	a1,a1,1
		n--;
4000cc68:	fff60613          	addi	a2,a2,-1
4000cc6c:	fd1ff06f          	j	4000cc3c <strncmp>
	return (n == 0) ? 0 : (*s1 - *s2);
4000cc70:	00000513          	li	a0,0
4000cc74:	00008067          	ret

4000cc78 <memcmp>:
int memcmp(const void *m1, const void *m2, size_t n)
{
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
4000cc78:	02060863          	beqz	a2,4000cca8 <memcmp+0x30>
4000cc7c:	fff60613          	addi	a2,a2,-1
4000cc80:	00000713          	li	a4,0
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
4000cc84:	00e507b3          	add	a5,a0,a4
4000cc88:	00e586b3          	add	a3,a1,a4
4000cc8c:	0007c783          	lbu	a5,0(a5)
4000cc90:	0006c683          	lbu	a3,0(a3)
4000cc94:	00e60663          	beq	a2,a4,4000cca0 <memcmp+0x28>
4000cc98:	00170713          	addi	a4,a4,1
4000cc9c:	fed784e3          	beq	a5,a3,4000cc84 <memcmp+0xc>
		c1++;
		c2++;
	}

	return *c1 - *c2;
4000cca0:	40d78533          	sub	a0,a5,a3
4000cca4:	00008067          	ret
		return 0;
4000cca8:	00000513          	li	a0,0
}
4000ccac:	00008067          	ret

4000ccb0 <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
4000ccb0:	40b507b3          	sub	a5,a0,a1
4000ccb4:	02c7fe63          	bgeu	a5,a2,4000ccf0 <memmove+0x40>
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
			n--;
4000ccb8:	fff60613          	addi	a2,a2,-1
			dest[n] = src[n];
4000ccbc:	00c587b3          	add	a5,a1,a2
4000ccc0:	0007c703          	lbu	a4,0(a5)
4000ccc4:	00c507b3          	add	a5,a0,a2
4000ccc8:	00e78023          	sb	a4,0(a5)
		while (n > 0) {
4000cccc:	fe0616e3          	bnez	a2,4000ccb8 <memmove+0x8>
4000ccd0:	00008067          	ret
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
			*dest = *src;
4000ccd4:	00f58733          	add	a4,a1,a5
4000ccd8:	00074683          	lbu	a3,0(a4)
4000ccdc:	00f50733          	add	a4,a0,a5
4000cce0:	00178793          	addi	a5,a5,1
4000cce4:	00d70023          	sb	a3,0(a4)
		while (n > 0) {
4000cce8:	fef616e3          	bne	a2,a5,4000ccd4 <memmove+0x24>
			n--;
		}
	}

	return d;
}
4000ccec:	00008067          	ret
4000ccf0:	00000793          	li	a5,0
4000ccf4:	ff5ff06f          	j	4000cce8 <memmove+0x38>

4000ccf8 <memcpy>:
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
4000ccf8:	00000793          	li	a5,0
4000ccfc:	00f61463          	bne	a2,a5,4000cd04 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
4000cd00:	00008067          	ret
		*(d_byte++) = *(s_byte++);
4000cd04:	00f586b3          	add	a3,a1,a5
4000cd08:	0006c683          	lbu	a3,0(a3)
4000cd0c:	00f50733          	add	a4,a0,a5
4000cd10:	00178793          	addi	a5,a5,1
4000cd14:	00d70023          	sb	a3,0(a4)
		n--;
4000cd18:	fe5ff06f          	j	4000ccfc <memcpy+0x4>

4000cd1c <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
4000cd1c:	0ff5f593          	zext.b	a1,a1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
4000cd20:	00c50633          	add	a2,a0,a2
	unsigned char *d_byte = (unsigned char *)buf;
4000cd24:	00050793          	mv	a5,a0
	while (n > 0) {
4000cd28:	00c79463          	bne	a5,a2,4000cd30 <memset+0x14>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
4000cd2c:	00008067          	ret
		*(d_byte++) = c_byte;
4000cd30:	00178793          	addi	a5,a5,1
4000cd34:	feb78fa3          	sb	a1,-1(a5)
		n--;
4000cd38:	ff1ff06f          	j	4000cd28 <memset+0xc>

4000cd3c <memchr>:
 *
 * @return pointer to start of found byte
 */

void *memchr(const void *s, int c, size_t n)
{
4000cd3c:	00050793          	mv	a5,a0
	if (n != 0) {
4000cd40:	02060063          	beqz	a2,4000cd60 <memchr+0x24>
4000cd44:	00c50633          	add	a2,a0,a2
		const unsigned char *p = s;

		do {
			if (*p++ == (unsigned char)c) {
4000cd48:	0ff5f593          	zext.b	a1,a1
4000cd4c:	00078513          	mv	a0,a5
4000cd50:	00054703          	lbu	a4,0(a0)
4000cd54:	00178793          	addi	a5,a5,1
4000cd58:	00b70663          	beq	a4,a1,4000cd64 <memchr+0x28>
				return ((void *)(p - 1));
			}

		} while (--n != 0);
4000cd5c:	fec798e3          	bne	a5,a2,4000cd4c <memchr+0x10>
	}

	return NULL;
4000cd60:	00000513          	li	a0,0
}
4000cd64:	00008067          	ret

4000cd68 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
4000cd68:	fff00513          	li	a0,-1
4000cd6c:	00008067          	ret

4000cd70 <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
4000cd70:	400447b7          	lui	a5,0x40044
4000cd74:	6ca7a223          	sw	a0,1732(a5) # 400446c4 <_stdout_hook>
}
4000cd78:	00008067          	ret

4000cd7c <sprintf_out>:
	int len;
};

static int sprintf_out(int c, struct emitter *p)
{
	if (p->len > 1) { /* need to reserve a byte for EOS */
4000cd7c:	0045a703          	lw	a4,4(a1)
4000cd80:	00100793          	li	a5,1
4000cd84:	02e7d263          	bge	a5,a4,4000cda8 <sprintf_out+0x2c>
		*(p->ptr) = c;
4000cd88:	0005a783          	lw	a5,0(a1)
4000cd8c:	00a78023          	sb	a0,0(a5)
		p->ptr += 1;
4000cd90:	0005a783          	lw	a5,0(a1)
4000cd94:	00178793          	addi	a5,a5,1
4000cd98:	00f5a023          	sw	a5,0(a1)
		p->len -= 1;
4000cd9c:	0045a783          	lw	a5,4(a1)
4000cda0:	fff78793          	addi	a5,a5,-1
4000cda4:	00f5a223          	sw	a5,4(a1)
	}
	return 0; /* indicate keep going so we get the total count */
}
4000cda8:	00000513          	li	a0,0
4000cdac:	00008067          	ret

4000cdb0 <snprintf>:

int snprintf(char *ZRESTRICT str, size_t len,
	     const char *ZRESTRICT format, ...)
{
4000cdb0:	fc010113          	addi	sp,sp,-64
4000cdb4:	00112e23          	sw	ra,28(sp)
4000cdb8:	02d12623          	sw	a3,44(sp)
4000cdbc:	02e12823          	sw	a4,48(sp)
4000cdc0:	02f12a23          	sw	a5,52(sp)
4000cdc4:	03012c23          	sw	a6,56(sp)
4000cdc8:	03112e23          	sw	a7,60(sp)

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
4000cdcc:	00059463          	bnez	a1,4000cdd4 <snprintf+0x24>
		str = &dummy; /* write final NUL to dummy, can't change *s */
4000cdd0:	00310513          	addi	a0,sp,3
	}

	p.ptr = str;
4000cdd4:	00a12423          	sw	a0,8(sp)
4000cdd8:	4000d537          	lui	a0,0x4000d
	p.len = (int) len;
4000cddc:	00b12623          	sw	a1,12(sp)

	va_start(vargs, format);
4000cde0:	02c10693          	addi	a3,sp,44
4000cde4:	00810593          	addi	a1,sp,8
4000cde8:	00000713          	li	a4,0
4000cdec:	d7c50513          	addi	a0,a0,-644 # 4000cd7c <sprintf_out>
4000cdf0:	00d12223          	sw	a3,4(sp)
4000cdf4:	ca9f50ef          	jal	ra,40002a9c <z_cbvprintf_impl>
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
	va_end(vargs);

	*(p.ptr) = 0;
4000cdf8:	00812783          	lw	a5,8(sp)
4000cdfc:	00078023          	sb	zero,0(a5)
	return r;
}
4000ce00:	01c12083          	lw	ra,28(sp)
4000ce04:	04010113          	addi	sp,sp,64
4000ce08:	00008067          	ret

4000ce0c <foldcase>:
#define EOS '\0'

static inline int foldcase(int ch, int flags)
{

	if ((flags & FNM_CASEFOLD) != 0 && isupper(ch)) {
4000ce0c:	0085f593          	andi	a1,a1,8
4000ce10:	00058a63          	beqz	a1,4000ce24 <foldcase+0x18>
4000ce14:	fbf50793          	addi	a5,a0,-65
4000ce18:	01900713          	li	a4,25
4000ce1c:	00f76463          	bltu	a4,a5,4000ce24 <foldcase+0x18>
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
4000ce20:	02050513          	addi	a0,a0,32
		return tolower(ch);
	}

	return ch;
}
4000ce24:	00008067          	ret

4000ce28 <fnmatchx>:
static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
{
	const char *stringstart, *r;
	char c, test;

	if (pattern == NULL || string == NULL) {
4000ce28:	00051663          	bnez	a0,4000ce34 <fnmatchx+0xc>
		return FNM_NOMATCH;
4000ce2c:	00100513          	li	a0,1

			break;
		}
	}
	/* NOTREACHED */
}
4000ce30:	00008067          	ret
{
4000ce34:	fb010113          	addi	sp,sp,-80
4000ce38:	03512a23          	sw	s5,52(sp)
4000ce3c:	04112623          	sw	ra,76(sp)
4000ce40:	04812423          	sw	s0,72(sp)
4000ce44:	04912223          	sw	s1,68(sp)
4000ce48:	05212023          	sw	s2,64(sp)
4000ce4c:	03312e23          	sw	s3,60(sp)
4000ce50:	03412c23          	sw	s4,56(sp)
4000ce54:	03612823          	sw	s6,48(sp)
4000ce58:	03712623          	sw	s7,44(sp)
4000ce5c:	03812423          	sw	s8,40(sp)
4000ce60:	03912223          	sw	s9,36(sp)
4000ce64:	03a12023          	sw	s10,32(sp)
4000ce68:	01b12e23          	sw	s11,28(sp)
4000ce6c:	00058a93          	mv	s5,a1
	if (pattern == NULL || string == NULL) {
4000ce70:	0c058863          	beqz	a1,4000cf40 <fnmatchx+0x118>
4000ce74:	00050b93          	mv	s7,a0
4000ce78:	00068b13          	mv	s6,a3
		return FNM_NORES;
4000ce7c:	00300513          	li	a0,3
	if (recursion-- == 0) {
4000ce80:	0c068263          	beqz	a3,4000cf44 <fnmatchx+0x11c>
4000ce84:	00060413          	mv	s0,a2
4000ce88:	00058493          	mv	s1,a1
		if (c == '\\' && !(flags & FNM_NOESCAPE)) {
4000ce8c:	05c00c13          	li	s8,92
		c = FOLDCASE(*pattern++, flags);
4000ce90:	000bc503          	lbu	a0,0(s7)
4000ce94:	00040593          	mv	a1,s0
4000ce98:	001b8993          	addi	s3,s7,1
4000ce9c:	f71ff0ef          	jal	ra,4000ce0c <foldcase>
4000cea0:	00050793          	mv	a5,a0
4000cea4:	0ff57a13          	zext.b	s4,a0
		switch (c) {
4000cea8:	03f00713          	li	a4,63
4000ceac:	0ff57513          	zext.b	a0,a0
			if ((flags & FNM_LEADING_DIR) && *string == '/') {
4000ceb0:	0004c903          	lbu	s2,0(s1)
		switch (c) {
4000ceb4:	06e50c63          	beq	a0,a4,4000cf2c <fnmatchx+0x104>
4000ceb8:	0c07f793          	andi	a5,a5,192
4000cebc:	02079463          	bnez	a5,4000cee4 <fnmatchx+0xbc>
4000cec0:	04050a63          	beqz	a0,4000cf14 <fnmatchx+0xec>
4000cec4:	02a00793          	li	a5,42
4000cec8:	0ef50463          	beq	a0,a5,4000cfb0 <fnmatchx+0x188>
			if (c != FOLDCASE(*string++, flags)) {
4000cecc:	00040593          	mv	a1,s0
4000ced0:	00090513          	mv	a0,s2
4000ced4:	00148493          	addi	s1,s1,1
4000ced8:	f35ff0ef          	jal	ra,4000ce0c <foldcase>
4000cedc:	0caa0663          	beq	s4,a0,4000cfa8 <fnmatchx+0x180>
4000cee0:	0600006f          	j	4000cf40 <fnmatchx+0x118>
		switch (c) {
4000cee4:	05b00793          	li	a5,91
4000cee8:	1cf50263          	beq	a0,a5,4000d0ac <fnmatchx+0x284>
4000ceec:	ff8510e3          	bne	a0,s8,4000cecc <fnmatchx+0xa4>
			if (!(flags & FNM_NOESCAPE)) {
4000cef0:	00147793          	andi	a5,s0,1
4000cef4:	fc079ce3          	bnez	a5,4000cecc <fnmatchx+0xa4>
				c = FOLDCASE(*pattern++, flags);
4000cef8:	001bc503          	lbu	a0,1(s7)
4000cefc:	00040593          	mv	a1,s0
4000cf00:	f0dff0ef          	jal	ra,4000ce0c <foldcase>
4000cf04:	0ff57a13          	zext.b	s4,a0
				if (c == EOS) {
4000cf08:	fc0a02e3          	beqz	s4,4000cecc <fnmatchx+0xa4>
				c = FOLDCASE(*pattern++, flags);
4000cf0c:	002b8993          	addi	s3,s7,2
4000cf10:	fbdff06f          	j	4000cecc <fnmatchx+0xa4>
			if ((flags & FNM_LEADING_DIR) && *string == '/') {
4000cf14:	01047413          	andi	s0,s0,16
4000cf18:	00040663          	beqz	s0,4000cf24 <fnmatchx+0xfc>
4000cf1c:	02f00793          	li	a5,47
4000cf20:	02f90263          	beq	s2,a5,4000cf44 <fnmatchx+0x11c>
			return *string == EOS ? 0 : FNM_NOMATCH;
4000cf24:	01203533          	snez	a0,s2
4000cf28:	01c0006f          	j	4000cf44 <fnmatchx+0x11c>
			if (*string == EOS) {
4000cf2c:	00090a63          	beqz	s2,4000cf40 <fnmatchx+0x118>
			if (*string == '/' && (flags & FNM_PATHNAME)) {
4000cf30:	02f00793          	li	a5,47
4000cf34:	04f91663          	bne	s2,a5,4000cf80 <fnmatchx+0x158>
4000cf38:	00247793          	andi	a5,s0,2
4000cf3c:	06078463          	beqz	a5,4000cfa4 <fnmatchx+0x17c>
		return FNM_NOMATCH;
4000cf40:	00100513          	li	a0,1
}
4000cf44:	04c12083          	lw	ra,76(sp)
4000cf48:	04812403          	lw	s0,72(sp)
4000cf4c:	04412483          	lw	s1,68(sp)
4000cf50:	04012903          	lw	s2,64(sp)
4000cf54:	03c12983          	lw	s3,60(sp)
4000cf58:	03812a03          	lw	s4,56(sp)
4000cf5c:	03412a83          	lw	s5,52(sp)
4000cf60:	03012b03          	lw	s6,48(sp)
4000cf64:	02c12b83          	lw	s7,44(sp)
4000cf68:	02812c03          	lw	s8,40(sp)
4000cf6c:	02412c83          	lw	s9,36(sp)
4000cf70:	02012d03          	lw	s10,32(sp)
4000cf74:	01c12d83          	lw	s11,28(sp)
4000cf78:	05010113          	addi	sp,sp,80
4000cf7c:	00008067          	ret
			if (*string == '.' && (flags & FNM_PERIOD) &&
4000cf80:	02e00713          	li	a4,46
4000cf84:	02e91063          	bne	s2,a4,4000cfa4 <fnmatchx+0x17c>
4000cf88:	00447713          	andi	a4,s0,4
4000cf8c:	00070c63          	beqz	a4,4000cfa4 <fnmatchx+0x17c>
4000cf90:	fb5488e3          	beq	s1,s5,4000cf40 <fnmatchx+0x118>
			     ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
4000cf94:	00247713          	andi	a4,s0,2
			    (string == stringstart ||
4000cf98:	00070663          	beqz	a4,4000cfa4 <fnmatchx+0x17c>
			     ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
4000cf9c:	fff4c703          	lbu	a4,-1(s1)
4000cfa0:	faf700e3          	beq	a4,a5,4000cf40 <fnmatchx+0x118>
			++string;
4000cfa4:	00148493          	addi	s1,s1,1
			break;
4000cfa8:	00098b93          	mv	s7,s3
4000cfac:	ee5ff06f          	j	4000ce90 <fnmatchx+0x68>
			c = FOLDCASE(*pattern, flags);
4000cfb0:	001bc503          	lbu	a0,1(s7)
4000cfb4:	00040593          	mv	a1,s0
			while (c == '*') {
4000cfb8:	02a00a13          	li	s4,42
			c = FOLDCASE(*pattern, flags);
4000cfbc:	e51ff0ef          	jal	ra,4000ce0c <foldcase>
4000cfc0:	0ff57513          	zext.b	a0,a0
			while (c == '*') {
4000cfc4:	05450c63          	beq	a0,s4,4000d01c <fnmatchx+0x1f4>
			if (*string == '.' && (flags & FNM_PERIOD) &&
4000cfc8:	02e00793          	li	a5,46
4000cfcc:	02f91263          	bne	s2,a5,4000cff0 <fnmatchx+0x1c8>
4000cfd0:	00447793          	andi	a5,s0,4
4000cfd4:	00078e63          	beqz	a5,4000cff0 <fnmatchx+0x1c8>
4000cfd8:	f75484e3          	beq	s1,s5,4000cf40 <fnmatchx+0x118>
			     ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
4000cfdc:	00247793          	andi	a5,s0,2
			    (string == stringstart ||
4000cfe0:	00078863          	beqz	a5,4000cff0 <fnmatchx+0x1c8>
			     ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
4000cfe4:	fff4c703          	lbu	a4,-1(s1)
4000cfe8:	02f00793          	li	a5,47
4000cfec:	f4f70ae3          	beq	a4,a5,4000cf40 <fnmatchx+0x118>
			if (c == EOS) {
4000cff0:	04051263          	bnez	a0,4000d034 <fnmatchx+0x20c>
				if (flags & FNM_PATHNAME) {
4000cff4:	00247513          	andi	a0,s0,2
4000cff8:	f40506e3          	beqz	a0,4000cf44 <fnmatchx+0x11c>
					return (flags & FNM_LEADING_DIR) ||
4000cffc:	01047413          	andi	s0,s0,16
				return 0;
4000d000:	00000513          	li	a0,0
						       : FNM_NOMATCH;
4000d004:	f40410e3          	bnez	s0,4000cf44 <fnmatchx+0x11c>
							       strchr(string, '/') == NULL
4000d008:	02f00593          	li	a1,47
4000d00c:	00048513          	mv	a0,s1
4000d010:	b7dff0ef          	jal	ra,4000cb8c <strchr>
						       : FNM_NOMATCH;
4000d014:	00a03533          	snez	a0,a0
4000d018:	f2dff06f          	j	4000cf44 <fnmatchx+0x11c>
				c = FOLDCASE(*++pattern, flags);
4000d01c:	0019c503          	lbu	a0,1(s3)
4000d020:	00040593          	mv	a1,s0
4000d024:	00198993          	addi	s3,s3,1
4000d028:	de5ff0ef          	jal	ra,4000ce0c <foldcase>
4000d02c:	0ff57513          	zext.b	a0,a0
4000d030:	f95ff06f          	j	4000cfc4 <fnmatchx+0x19c>
			} else if (c == '/' && flags & FNM_PATHNAME) {
4000d034:	02f00793          	li	a5,47
4000d038:	02f51263          	bne	a0,a5,4000d05c <fnmatchx+0x234>
4000d03c:	00247793          	andi	a5,s0,2
4000d040:	00078e63          	beqz	a5,4000d05c <fnmatchx+0x234>
				string = strchr(string, '/');
4000d044:	00048513          	mv	a0,s1
4000d048:	02f00593          	li	a1,47
4000d04c:	b41ff0ef          	jal	ra,4000cb8c <strchr>
4000d050:	00050493          	mv	s1,a0
				if (string == NULL) {
4000d054:	f4051ae3          	bnez	a0,4000cfa8 <fnmatchx+0x180>
4000d058:	ee9ff06f          	j	4000cf40 <fnmatchx+0x118>
	if (recursion-- == 0) {
4000d05c:	fffb0b13          	addi	s6,s6,-1
				int e = fnmatchx(pattern, string, flags & ~FNM_PERIOD, recursion);
4000d060:	ffb47a13          	andi	s4,s0,-5
				if (e != FNM_NOMATCH) {
4000d064:	00100a93          	li	s5,1
				if (test == '/' && flags & FNM_PATHNAME) {
4000d068:	02f00b93          	li	s7,47
4000d06c:	00247c13          	andi	s8,s0,2
				test = FOLDCASE(*string, flags);
4000d070:	0004c503          	lbu	a0,0(s1)
4000d074:	00040593          	mv	a1,s0
4000d078:	d95ff0ef          	jal	ra,4000ce0c <foldcase>
4000d07c:	0ff57913          	zext.b	s2,a0
				if (test == EOS) {
4000d080:	ec0900e3          	beqz	s2,4000cf40 <fnmatchx+0x118>
				int e = fnmatchx(pattern, string, flags & ~FNM_PERIOD, recursion);
4000d084:	000b0693          	mv	a3,s6
4000d088:	000a0613          	mv	a2,s4
4000d08c:	00048593          	mv	a1,s1
4000d090:	00098513          	mv	a0,s3
4000d094:	d95ff0ef          	jal	ra,4000ce28 <fnmatchx>
				if (e != FNM_NOMATCH) {
4000d098:	eb5516e3          	bne	a0,s5,4000cf44 <fnmatchx+0x11c>
				if (test == '/' && flags & FNM_PATHNAME) {
4000d09c:	01791463          	bne	s2,s7,4000d0a4 <fnmatchx+0x27c>
4000d0a0:	ea0c10e3          	bnez	s8,4000cf40 <fnmatchx+0x118>
				++string;
4000d0a4:	00148493          	addi	s1,s1,1
			do {
4000d0a8:	fc9ff06f          	j	4000d070 <fnmatchx+0x248>
			if (*string == EOS) {
4000d0ac:	e8090ae3          	beqz	s2,4000cf40 <fnmatchx+0x118>
			if (*string == '/' && flags & FNM_PATHNAME) {
4000d0b0:	02f00793          	li	a5,47
4000d0b4:	08f91663          	bne	s2,a5,4000d140 <fnmatchx+0x318>
4000d0b8:	00247793          	andi	a5,s0,2
4000d0bc:	e80792e3          	bnez	a5,4000cf40 <fnmatchx+0x118>
			r = rangematch(pattern, FOLDCASE(*string, flags), flags);
4000d0c0:	00040593          	mv	a1,s0
4000d0c4:	02f00513          	li	a0,47
4000d0c8:	d45ff0ef          	jal	ra,4000ce0c <foldcase>
	negate = *pattern == '!' || *pattern == '^';
4000d0cc:	001bc783          	lbu	a5,1(s7)
4000d0d0:	02100713          	li	a4,33
			r = rangematch(pattern, FOLDCASE(*string, flags), flags);
4000d0d4:	00050a13          	mv	s4,a0
	negate = *pattern == '!' || *pattern == '^';
4000d0d8:	00e78663          	beq	a5,a4,4000d0e4 <fnmatchx+0x2bc>
4000d0dc:	05e00713          	li	a4,94
4000d0e0:	06e79663          	bne	a5,a4,4000d14c <fnmatchx+0x324>
		++pattern;
4000d0e4:	002b8b93          	addi	s7,s7,2
4000d0e8:	00100c93          	li	s9,1
	for (need = true, ok = false, c = FOLDCASE(*pattern++, flags); c != ']' || need;
4000d0ec:	000bc503          	lbu	a0,0(s7)
4000d0f0:	00040593          	mv	a1,s0
4000d0f4:	001b8d13          	addi	s10,s7,1
4000d0f8:	d15ff0ef          	jal	ra,4000ce0c <foldcase>
4000d0fc:	0ff57d93          	zext.b	s11,a0
4000d100:	05d00713          	li	a4,93
4000d104:	04ed8a63          	beq	s11,a4,4000d158 <fnmatchx+0x330>
4000d108:	00000b93          	li	s7,0
		if (c == '/') {
4000d10c:	02f00793          	li	a5,47
4000d110:	0efd8863          	beq	s11,a5,4000d200 <fnmatchx+0x3d8>
		if (c == '\\' && !(flags & FNM_NOESCAPE)) {
4000d114:	038d9063          	bne	s11,s8,4000d134 <fnmatchx+0x30c>
4000d118:	00147713          	andi	a4,s0,1
4000d11c:	00071e63          	bnez	a4,4000d138 <fnmatchx+0x310>
			c = FOLDCASE(*pattern++, flags);
4000d120:	000d4503          	lbu	a0,0(s10)
4000d124:	00040593          	mv	a1,s0
4000d128:	001d0d13          	addi	s10,s10,1
4000d12c:	ce1ff0ef          	jal	ra,4000ce0c <foldcase>
4000d130:	0ff57d93          	zext.b	s11,a0
		if (c == EOS) {
4000d134:	e00d86e3          	beqz	s11,4000cf40 <fnmatchx+0x118>
4000d138:	000d0713          	mv	a4,s10
4000d13c:	0240006f          	j	4000d160 <fnmatchx+0x338>
			r = rangematch(pattern, FOLDCASE(*string, flags), flags);
4000d140:	00040593          	mv	a1,s0
4000d144:	00090513          	mv	a0,s2
4000d148:	f81ff06f          	j	4000d0c8 <fnmatchx+0x2a0>
4000d14c:	00098b93          	mv	s7,s3
	negate = *pattern == '!' || *pattern == '^';
4000d150:	00000c93          	li	s9,0
4000d154:	f99ff06f          	j	4000d0ec <fnmatchx+0x2c4>
	for (need = true, ok = false, c = FOLDCASE(*pattern++, flags); c != ']' || need;
4000d158:	000d0713          	mv	a4,s10
4000d15c:	00000b93          	li	s7,0
		if (*pattern == '-') {
4000d160:	000d4603          	lbu	a2,0(s10)
4000d164:	02d00793          	li	a5,45
4000d168:	06f61663          	bne	a2,a5,4000d1d4 <fnmatchx+0x3ac>
			c2 = FOLDCASE(*(pattern + 1), flags);
4000d16c:	001d4503          	lbu	a0,1(s10)
4000d170:	00040593          	mv	a1,s0
4000d174:	00e12623          	sw	a4,12(sp)
4000d178:	c95ff0ef          	jal	ra,4000ce0c <foldcase>
4000d17c:	0ff57513          	zext.b	a0,a0
			if (c2 != EOS && c2 != ']') {
4000d180:	00c12703          	lw	a4,12(sp)
4000d184:	04050a63          	beqz	a0,4000d1d8 <fnmatchx+0x3b0>
4000d188:	05d00613          	li	a2,93
4000d18c:	04c50663          	beq	a0,a2,4000d1d8 <fnmatchx+0x3b0>
				if (c2 == '\\' && !(flags & FNM_NOESCAPE)) {
4000d190:	05c00613          	li	a2,92
				pattern += 2;
4000d194:	002d0713          	addi	a4,s10,2
				if (c2 == '\\' && !(flags & FNM_NOESCAPE)) {
4000d198:	02c51663          	bne	a0,a2,4000d1c4 <fnmatchx+0x39c>
4000d19c:	00147613          	andi	a2,s0,1
4000d1a0:	02061263          	bnez	a2,4000d1c4 <fnmatchx+0x39c>
					c2 = FOLDCASE(*pattern++, flags);
4000d1a4:	002d4503          	lbu	a0,2(s10)
4000d1a8:	003d0713          	addi	a4,s10,3
4000d1ac:	00040593          	mv	a1,s0
4000d1b0:	00e12623          	sw	a4,12(sp)
4000d1b4:	c59ff0ef          	jal	ra,4000ce0c <foldcase>
4000d1b8:	0ff57513          	zext.b	a0,a0
				if (c2 == EOS) {
4000d1bc:	d80502e3          	beqz	a0,4000cf40 <fnmatchx+0x118>
					c2 = FOLDCASE(*pattern++, flags);
4000d1c0:	00c12703          	lw	a4,12(sp)
				if (c <= test && test <= c2) {
4000d1c4:	01ba4a63          	blt	s4,s11,4000d1d8 <fnmatchx+0x3b0>
4000d1c8:	01454863          	blt	a0,s4,4000d1d8 <fnmatchx+0x3b0>
			ok = true;
4000d1cc:	00100b93          	li	s7,1
4000d1d0:	0080006f          	j	4000d1d8 <fnmatchx+0x3b0>
		} else if (c == test) {
4000d1d4:	ff4d8ce3          	beq	s11,s4,4000d1cc <fnmatchx+0x3a4>
	     c = FOLDCASE(*pattern++, flags)) {
4000d1d8:	00074503          	lbu	a0,0(a4)
4000d1dc:	00040593          	mv	a1,s0
4000d1e0:	00170d13          	addi	s10,a4,1
4000d1e4:	c29ff0ef          	jal	ra,4000ce0c <foldcase>
4000d1e8:	0ff57d93          	zext.b	s11,a0
	for (need = true, ok = false, c = FOLDCASE(*pattern++, flags); c != ']' || need;
4000d1ec:	05d00793          	li	a5,93
4000d1f0:	f0fd9ee3          	bne	s11,a5,4000d10c <fnmatchx+0x2e4>
	return ok == negate ? NULL : pattern;
4000d1f4:	d57c86e3          	beq	s9,s7,4000cf40 <fnmatchx+0x118>
			if (r == (void *)-1) {
4000d1f8:	fff00793          	li	a5,-1
4000d1fc:	00fd1863          	bne	s10,a5,4000d20c <fnmatchx+0x3e4>
				if (*string != '[') {
4000d200:	05b00793          	li	a5,91
4000d204:	d2f91ee3          	bne	s2,a5,4000cf40 <fnmatchx+0x118>
		c = FOLDCASE(*pattern++, flags);
4000d208:	00098d13          	mv	s10,s3
			++string;
4000d20c:	00148493          	addi	s1,s1,1
			break;
4000d210:	000d0993          	mv	s3,s10
4000d214:	d95ff06f          	j	4000cfa8 <fnmatchx+0x180>

4000d218 <fnmatch>:

int fnmatch(const char *pattern, const char *string, int flags)
{
	return fnmatchx(pattern, string, flags, 64);
4000d218:	04000693          	li	a3,64
4000d21c:	c0dff06f          	j	4000ce28 <fnmatchx>

4000d220 <z_impl_sys_rand32_get>:
static const struct device *const entropy_dev =
	DEVICE_DT_GET(DT_CHOSEN(zephyr_entropy));

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
uint32_t z_impl_sys_rand32_get(void)
{
4000d220:	fe010113          	addi	sp,sp,-32
4000d224:	00112e23          	sw	ra,28(sp)

static inline int z_impl_entropy_get_entropy(const struct device *dev,
					     uint8_t *buffer,
					     uint16_t length)
{
	const struct entropy_driver_api *api =
4000d228:	40032537          	lui	a0,0x40032
4000d22c:	2fc50793          	addi	a5,a0,764 # 400322fc <__device_dts_ord_18>
		(const struct entropy_driver_api *)dev->api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
4000d230:	0087a783          	lw	a5,8(a5)
4000d234:	00400613          	li	a2,4
4000d238:	00c10593          	addi	a1,sp,12
4000d23c:	0007a783          	lw	a5,0(a5)
4000d240:	2fc50513          	addi	a0,a0,764
4000d244:	000780e7          	jalr	a5
	__ASSERT(device_is_ready(entropy_dev), "Entropy device %s not ready",
		 entropy_dev->name);

	ret = entropy_get_entropy(entropy_dev, (uint8_t *)&random_num,
				  sizeof(random_num));
	if (unlikely(ret < 0)) {
4000d248:	00055663          	bgez	a0,4000d254 <z_impl_sys_rand32_get+0x34>
	return sys_clock_cycle_get_32();
4000d24c:	51d1f0ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
		 * 32-bit of data.  There's not much that can be done in this
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		random_num = k_cycle_get_32();
4000d250:	00a12623          	sw	a0,12(sp)
	}

	return random_num;
}
4000d254:	01c12083          	lw	ra,28(sp)
4000d258:	00c12503          	lw	a0,12(sp)
4000d25c:	02010113          	addi	sp,sp,32
4000d260:	00008067          	ret

4000d264 <z_impl_sys_rand_get>:
	return 0;
}

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
void z_impl_sys_rand_get(void *dst, size_t outlen)
{
4000d264:	fd010113          	addi	sp,sp,-48
4000d268:	02912223          	sw	s1,36(sp)
4000d26c:	03212023          	sw	s2,32(sp)
4000d270:	02112623          	sw	ra,44(sp)
4000d274:	02812423          	sw	s0,40(sp)
4000d278:	01312e23          	sw	s3,28(sp)
4000d27c:	01412c23          	sw	s4,24(sp)
4000d280:	00050913          	mv	s2,a0
4000d284:	00058493          	mv	s1,a1
	const struct entropy_driver_api *api =
4000d288:	40032537          	lui	a0,0x40032
4000d28c:	2fc50793          	addi	a5,a0,764 # 400322fc <__device_dts_ord_18>
	return api->get_entropy(dev, buffer, length);
4000d290:	0087a783          	lw	a5,8(a5)
4000d294:	01059613          	slli	a2,a1,0x10
4000d298:	01065613          	srli	a2,a2,0x10
4000d29c:	0007a783          	lw	a5,0(a5)
4000d2a0:	00090593          	mv	a1,s2
4000d2a4:	2fc50513          	addi	a0,a0,764
4000d2a8:	000780e7          	jalr	a5
	if (unlikely(ret < 0)) {
4000d2ac:	02055e63          	bgez	a0,4000d2e8 <z_impl_sys_rand_get+0x84>
		uint32_t len = 0;
4000d2b0:	00000413          	li	s0,0
			if (copylen > blocksize) {
4000d2b4:	00400a13          	li	s4,4
4000d2b8:	02c0006f          	j	4000d2e4 <z_impl_sys_rand_get+0x80>
			size_t copylen = outlen - len;
4000d2bc:	408489b3          	sub	s3,s1,s0
			if (copylen > blocksize) {
4000d2c0:	013a7463          	bgeu	s4,s3,4000d2c8 <z_impl_sys_rand_get+0x64>
4000d2c4:	00400993          	li	s3,4
4000d2c8:	4a11f0ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
			random_num = k_cycle_get_32();
4000d2cc:	00a12623          	sw	a0,12(sp)
			(void)memcpy(&(dst[len]), &random_num, copylen);
4000d2d0:	00098613          	mv	a2,s3
4000d2d4:	00890533          	add	a0,s2,s0
4000d2d8:	00c10593          	addi	a1,sp,12
4000d2dc:	a1dff0ef          	jal	ra,4000ccf8 <memcpy>
			len += copylen;
4000d2e0:	01340433          	add	s0,s0,s3
		while (len < outlen) {
4000d2e4:	fc946ce3          	bltu	s0,s1,4000d2bc <z_impl_sys_rand_get+0x58>
	rand_get(dst, outlen, false);
}
4000d2e8:	02c12083          	lw	ra,44(sp)
4000d2ec:	02812403          	lw	s0,40(sp)
4000d2f0:	02412483          	lw	s1,36(sp)
4000d2f4:	02012903          	lw	s2,32(sp)
4000d2f8:	01c12983          	lw	s3,28(sp)
4000d2fc:	01812a03          	lw	s4,24(sp)
4000d300:	03010113          	addi	sp,sp,48
4000d304:	00008067          	ret

4000d308 <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, uint8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
4000d308:	00008067          	ret

4000d30c <net_buf_id>:
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
4000d30c:	00a54703          	lbu	a4,10(a0)
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
4000d310:	02c00693          	li	a3,44
4000d314:	400457b7          	lui	a5,0x40045
4000d318:	02d70733          	mul	a4,a4,a3
4000d31c:	92878793          	addi	a5,a5,-1752 # 40044928 <dns_msg_pool>
4000d320:	00e787b3          	add	a5,a5,a4
4000d324:	0287a703          	lw	a4,40(a5)
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
4000d328:	01c7c783          	lbu	a5,28(a5)
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
4000d32c:	40e50533          	sub	a0,a0,a4
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
4000d330:	01b78793          	addi	a5,a5,27
4000d334:	ffc7f793          	andi	a5,a5,-4
}
4000d338:	02f55533          	divu	a0,a0,a5
4000d33c:	00008067          	ret

4000d340 <fixed_data_alloc>:
{
4000d340:	ff010113          	addi	sp,sp,-16
4000d344:	00112623          	sw	ra,12(sp)
4000d348:	00812423          	sw	s0,8(sp)
4000d34c:	00912223          	sw	s1,4(sp)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
4000d350:	00a54703          	lbu	a4,10(a0)
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
4000d354:	02c00693          	li	a3,44
4000d358:	400457b7          	lui	a5,0x40045
4000d35c:	02d70733          	mul	a4,a4,a3
4000d360:	92878793          	addi	a5,a5,-1752 # 40044928 <dns_msg_pool>
4000d364:	00e787b3          	add	a5,a5,a4
4000d368:	0247a783          	lw	a5,36(a5)
	*size = MIN(fixed->data_size, *size);
4000d36c:	0005a703          	lw	a4,0(a1)
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
4000d370:	0047a783          	lw	a5,4(a5)
	*size = MIN(fixed->data_size, *size);
4000d374:	0007a683          	lw	a3,0(a5)
4000d378:	00e6f463          	bgeu	a3,a4,4000d380 <fixed_data_alloc+0x40>
4000d37c:	00068713          	mv	a4,a3
4000d380:	00e5a023          	sw	a4,0(a1)
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
4000d384:	0007a483          	lw	s1,0(a5)
4000d388:	0047a403          	lw	s0,4(a5)
4000d38c:	f81ff0ef          	jal	ra,4000d30c <net_buf_id>
4000d390:	02950533          	mul	a0,a0,s1
}
4000d394:	00c12083          	lw	ra,12(sp)
4000d398:	00412483          	lw	s1,4(sp)
4000d39c:	00a40533          	add	a0,s0,a0
4000d3a0:	00812403          	lw	s0,8(sp)
4000d3a4:	01010113          	addi	sp,sp,16
4000d3a8:	00008067          	ret

4000d3ac <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
4000d3ac:	fc010113          	addi	sp,sp,-64
4000d3b0:	02912a23          	sw	s1,52(sp)
4000d3b4:	00b12623          	sw	a1,12(sp)
4000d3b8:	00050493          	mv	s1,a0
	uint64_t end = sys_clock_timeout_end_calc(timeout);
4000d3bc:	00068593          	mv	a1,a3
4000d3c0:	00060513          	mv	a0,a2
{
4000d3c4:	03212823          	sw	s2,48(sp)
4000d3c8:	03312623          	sw	s3,44(sp)
4000d3cc:	03412423          	sw	s4,40(sp)
4000d3d0:	03512223          	sw	s5,36(sp)
4000d3d4:	03612023          	sw	s6,32(sp)
4000d3d8:	01712e23          	sw	s7,28(sp)
4000d3dc:	02112e23          	sw	ra,60(sp)
4000d3e0:	02812c23          	sw	s0,56(sp)
4000d3e4:	01812c23          	sw	s8,24(sp)
4000d3e8:	00060a93          	mv	s5,a2
4000d3ec:	00068993          	mv	s3,a3
4000d3f0:	00060913          	mv	s2,a2
4000d3f4:	00068b93          	mv	s7,a3
	uint64_t end = sys_clock_timeout_end_calc(timeout);
4000d3f8:	2c8240ef          	jal	ra,400316c0 <sys_clock_timeout_end_calc>
4000d3fc:	00050a13          	mv	s4,a0
4000d400:	00058b13          	mv	s6,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
4000d404:	30047c73          	csrrci	s8,mstatus,8
	key = k_spin_lock(&pool->lock);

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
4000d408:	01a4d783          	lhu	a5,26(s1)
4000d40c:	008c7c13          	andi	s8,s8,8
4000d410:	10078c63          	beqz	a5,4000d528 <net_buf_alloc_len+0x17c>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
4000d414:	0184d703          	lhu	a4,24(s1)
4000d418:	0ae7fa63          	bgeu	a5,a4,4000d4cc <net_buf_alloc_len+0x120>
	return z_impl_k_queue_get(queue, timeout);
4000d41c:	00000593          	li	a1,0
4000d420:	00000613          	li	a2,0
4000d424:	00048513          	mv	a0,s1
4000d428:	404220ef          	jal	ra,4002f82c <z_impl_k_queue_get>
4000d42c:	00050413          	mv	s0,a0
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
4000d430:	08050e63          	beqz	a0,4000d4cc <net_buf_alloc_len+0x120>
	__asm__ volatile ("csrs mstatus, %0"
4000d434:	300c2073          	csrs	mstatus,s8
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
4000d438:	00c12783          	lw	a5,12(sp)
4000d43c:	14078063          	beqz	a5,4000d57c <net_buf_alloc_len+0x1d0>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
4000d440:	0159e9b3          	or	s3,s3,s5
4000d444:	02098863          	beqz	s3,4000d474 <net_buf_alloc_len+0xc8>
4000d448:	fff00793          	li	a5,-1
4000d44c:	00f91463          	bne	s2,a5,4000d454 <net_buf_alloc_len+0xa8>
4000d450:	032b8263          	beq	s7,s2,4000d474 <net_buf_alloc_len+0xc8>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - sys_clock_tick_get();
4000d454:	1a4240ef          	jal	ra,400315f8 <sys_clock_tick_get>
4000d458:	40aa0933          	sub	s2,s4,a0
4000d45c:	012a3a33          	sltu	s4,s4,s2
4000d460:	40bb0b33          	sub	s6,s6,a1
4000d464:	414b0bb3          	sub	s7,s6,s4

			if (remaining <= 0) {
4000d468:	000bd663          	bgez	s7,4000d474 <net_buf_alloc_len+0xc8>
4000d46c:	00000913          	li	s2,0
4000d470:	00000b93          	li	s7,0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
4000d474:	00a44783          	lbu	a5,10(s0)
	return pool->alloc->cb->alloc(buf, size, timeout);
4000d478:	02c00993          	li	s3,44
4000d47c:	400454b7          	lui	s1,0x40045
4000d480:	033787b3          	mul	a5,a5,s3
4000d484:	92848493          	addi	s1,s1,-1752 # 40044928 <dns_msg_pool>
4000d488:	00090613          	mv	a2,s2
4000d48c:	000b8693          	mv	a3,s7
4000d490:	00c10593          	addi	a1,sp,12
4000d494:	00040513          	mv	a0,s0
4000d498:	00f487b3          	add	a5,s1,a5
4000d49c:	0247a783          	lw	a5,36(a5)
4000d4a0:	0007a783          	lw	a5,0(a5)
4000d4a4:	0007a783          	lw	a5,0(a5)
4000d4a8:	000780e7          	jalr	a5
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
4000d4ac:	00a42a23          	sw	a0,20(s0)
		if (!buf->__buf) {
4000d4b0:	0c051863          	bnez	a0,4000d580 <net_buf_alloc_len+0x1d4>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
4000d4b4:	00a44503          	lbu	a0,10(s0)
4000d4b8:	00040593          	mv	a1,s0
4000d4bc:	03350533          	mul	a0,a0,s3
4000d4c0:	00a48533          	add	a0,s1,a0
4000d4c4:	354220ef          	jal	ra,4002f818 <k_queue_prepend>
}
4000d4c8:	07c0006f          	j	4000d544 <net_buf_alloc_len+0x198>
		uninit_count = pool->uninit_count--;
4000d4cc:	01a4d683          	lhu	a3,26(s1)
4000d4d0:	fff68793          	addi	a5,a3,-1
4000d4d4:	00f49d23          	sh	a5,26(s1)
4000d4d8:	300c2073          	csrs	mstatus,s8
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
4000d4dc:	01c4c783          	lbu	a5,28(s1)
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
4000d4e0:	0184d703          	lhu	a4,24(s1)
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
4000d4e4:	0284a403          	lw	s0,40(s1)
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
4000d4e8:	01b78793          	addi	a5,a5,27
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
4000d4ec:	40d70733          	sub	a4,a4,a3
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
4000d4f0:	ffc7f793          	andi	a5,a5,-4
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
4000d4f4:	02e787b3          	mul	a5,a5,a4
	return pool - TYPE_SECTION_START(net_buf_pool);
4000d4f8:	ba2e9737          	lui	a4,0xba2e9
4000d4fc:	ba370713          	addi	a4,a4,-1117 # ba2e8ba3 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xba2e8ba4>
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
4000d500:	00f40433          	add	s0,s0,a5
	return pool - TYPE_SECTION_START(net_buf_pool);
4000d504:	400457b7          	lui	a5,0x40045
4000d508:	92878793          	addi	a5,a5,-1752 # 40044928 <dns_msg_pool>
4000d50c:	40f487b3          	sub	a5,s1,a5
4000d510:	4027d793          	srai	a5,a5,0x2
4000d514:	02e787b3          	mul	a5,a5,a4
	buf->pool_id = pool_id(pool);
4000d518:	00f40523          	sb	a5,10(s0)
	buf->user_data_size = pool->user_data_size;
4000d51c:	01c4c783          	lbu	a5,28(s1)
4000d520:	00f405a3          	sb	a5,11(s0)
		goto success;
4000d524:	f15ff06f          	j	4000d438 <net_buf_alloc_len+0x8c>
4000d528:	300c2073          	csrs	mstatus,s8
4000d52c:	000a8593          	mv	a1,s5
4000d530:	00098613          	mv	a2,s3
4000d534:	00048513          	mv	a0,s1
4000d538:	2f4220ef          	jal	ra,4002f82c <z_impl_k_queue_get>
4000d53c:	00050413          	mv	s0,a0
	if (!buf) {
4000d540:	ee051ce3          	bnez	a0,4000d438 <net_buf_alloc_len+0x8c>
		return NULL;
4000d544:	00000413          	li	s0,0
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
4000d548:	03c12083          	lw	ra,60(sp)
4000d54c:	00040513          	mv	a0,s0
4000d550:	03812403          	lw	s0,56(sp)
4000d554:	03412483          	lw	s1,52(sp)
4000d558:	03012903          	lw	s2,48(sp)
4000d55c:	02c12983          	lw	s3,44(sp)
4000d560:	02812a03          	lw	s4,40(sp)
4000d564:	02412a83          	lw	s5,36(sp)
4000d568:	02012b03          	lw	s6,32(sp)
4000d56c:	01c12b83          	lw	s7,28(sp)
4000d570:	01812c03          	lw	s8,24(sp)
4000d574:	04010113          	addi	sp,sp,64
4000d578:	00008067          	ret
		buf->__buf = NULL;
4000d57c:	00042a23          	sw	zero,20(s0)
	buf->ref   = 1U;
4000d580:	00100793          	li	a5,1
4000d584:	00f41423          	sh	a5,8(s0)
	buf->size  = size;
4000d588:	00c12783          	lw	a5,12(sp)
	buf->frags = NULL;
4000d58c:	00042223          	sw	zero,4(s0)
	buf->len  = 0U;
4000d590:	00041823          	sh	zero,16(s0)
	buf->size  = size;
4000d594:	00f41923          	sh	a5,18(s0)
	buf->data = buf->__buf;
4000d598:	01442783          	lw	a5,20(s0)
4000d59c:	00f42623          	sw	a5,12(s0)
	return buf;
4000d5a0:	fa9ff06f          	j	4000d548 <net_buf_alloc_len+0x19c>

4000d5a4 <net_buf_alloc_fixed>:
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool,
				    k_timeout_t timeout)
{
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
4000d5a4:	02452783          	lw	a5,36(a0)
{
4000d5a8:	00060693          	mv	a3,a2
4000d5ac:	00058613          	mv	a2,a1

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
4000d5b0:	0047a783          	lw	a5,4(a5)
4000d5b4:	0007a583          	lw	a1,0(a5)
4000d5b8:	df5ff06f          	j	4000d3ac <net_buf_alloc_len>

4000d5bc <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
4000d5bc:	fe010113          	addi	sp,sp,-32
4000d5c0:	00912a23          	sw	s1,20(sp)
4000d5c4:	400454b7          	lui	s1,0x40045
4000d5c8:	00812c23          	sw	s0,24(sp)
4000d5cc:	01212823          	sw	s2,16(sp)
4000d5d0:	00112e23          	sw	ra,28(sp)
4000d5d4:	01312623          	sw	s3,12(sp)
4000d5d8:	00050413          	mv	s0,a0
4000d5dc:	92848493          	addi	s1,s1,-1752 # 40044928 <dns_msg_pool>
	pool->alloc->cb->unref(buf, data);
4000d5e0:	02c00913          	li	s2,44
	__ASSERT_NO_MSG(buf);

	while (buf) {
4000d5e4:	02041063          	bnez	s0,4000d604 <net_buf_unref+0x48>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
4000d5e8:	01c12083          	lw	ra,28(sp)
4000d5ec:	01812403          	lw	s0,24(sp)
4000d5f0:	01412483          	lw	s1,20(sp)
4000d5f4:	01012903          	lw	s2,16(sp)
4000d5f8:	00c12983          	lw	s3,12(sp)
4000d5fc:	02010113          	addi	sp,sp,32
4000d600:	00008067          	ret
		if (--buf->ref > 0) {
4000d604:	00844783          	lbu	a5,8(s0)
		struct net_buf *frags = buf->frags;
4000d608:	00442983          	lw	s3,4(s0)
		if (--buf->ref > 0) {
4000d60c:	fff78793          	addi	a5,a5,-1
4000d610:	0ff7f793          	zext.b	a5,a5
4000d614:	00f40423          	sb	a5,8(s0)
4000d618:	fc0798e3          	bnez	a5,4000d5e8 <net_buf_unref+0x2c>
		if (buf->__buf) {
4000d61c:	01442583          	lw	a1,20(s0)
4000d620:	02058a63          	beqz	a1,4000d654 <net_buf_unref+0x98>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
4000d624:	00944783          	lbu	a5,9(s0)
4000d628:	0017f793          	andi	a5,a5,1
4000d62c:	02079263          	bnez	a5,4000d650 <net_buf_unref+0x94>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
4000d630:	00a44783          	lbu	a5,10(s0)
	pool->alloc->cb->unref(buf, data);
4000d634:	00040513          	mv	a0,s0
4000d638:	032787b3          	mul	a5,a5,s2
4000d63c:	00f487b3          	add	a5,s1,a5
4000d640:	0247a783          	lw	a5,36(a5)
4000d644:	0007a783          	lw	a5,0(a5)
4000d648:	0087a783          	lw	a5,8(a5)
4000d64c:	000780e7          	jalr	a5
			buf->__buf = NULL;
4000d650:	00042a23          	sw	zero,20(s0)
		pool = net_buf_pool_get(buf->pool_id);
4000d654:	00a44503          	lbu	a0,10(s0)
		buf->data = NULL;
4000d658:	00042623          	sw	zero,12(s0)
		buf->frags = NULL;
4000d65c:	00042223          	sw	zero,4(s0)
		if (pool->destroy) {
4000d660:	03250533          	mul	a0,a0,s2
4000d664:	00a48533          	add	a0,s1,a0
4000d668:	02052783          	lw	a5,32(a0)
4000d66c:	00078a63          	beqz	a5,4000d680 <net_buf_unref+0xc4>
			pool->destroy(buf);
4000d670:	00040513          	mv	a0,s0
4000d674:	000780e7          	jalr	a5
{
4000d678:	00098413          	mv	s0,s3
4000d67c:	f69ff06f          	j	4000d5e4 <net_buf_unref+0x28>
	k_lifo_put(&pool->free, buf);
4000d680:	00040593          	mv	a1,s0
4000d684:	194220ef          	jal	ra,4002f818 <k_queue_prepend>
}
4000d688:	ff1ff06f          	j	4000d678 <net_buf_unref+0xbc>

4000d68c <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
4000d68c:	00050793          	mv	a5,a0
	__ASSERT_NO_MSG(buf);

	while (buf->frags) {
4000d690:	00078513          	mv	a0,a5
4000d694:	0047a783          	lw	a5,4(a5)
4000d698:	fe079ce3          	bnez	a5,4000d690 <net_buf_frag_last+0x4>
		buf = buf->frags;
	}

	return buf;
}
4000d69c:	00008067          	ret

4000d6a0 <net_buf_frag_insert>:
void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
	__ASSERT_NO_MSG(parent);
	__ASSERT_NO_MSG(frag);

	if (parent->frags) {
4000d6a0:	00452703          	lw	a4,4(a0)
4000d6a4:	00070c63          	beqz	a4,4000d6bc <net_buf_frag_insert+0x1c>
4000d6a8:	00058793          	mv	a5,a1
	while (buf->frags) {
4000d6ac:	00078693          	mv	a3,a5
4000d6b0:	0047a783          	lw	a5,4(a5)
4000d6b4:	fe079ce3          	bnez	a5,4000d6ac <net_buf_frag_insert+0xc>
		net_buf_frag_last(frag)->frags = parent->frags;
4000d6b8:	00e6a223          	sw	a4,4(a3)
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
4000d6bc:	00b52223          	sw	a1,4(a0)
}
4000d6c0:	00008067          	ret

4000d6c4 <net_buf_frag_add>:

struct net_buf *net_buf_frag_add(struct net_buf *head, struct net_buf *frag)
{
	__ASSERT_NO_MSG(frag);

	if (!head) {
4000d6c4:	00051c63          	bnez	a0,4000d6dc <net_buf_frag_add+0x18>
	buf->ref++;
4000d6c8:	0085c783          	lbu	a5,8(a1)
		return net_buf_ref(frag);
4000d6cc:	00058513          	mv	a0,a1
	buf->ref++;
4000d6d0:	00178793          	addi	a5,a5,1
4000d6d4:	00f58423          	sb	a5,8(a1)
	}

	net_buf_frag_insert(net_buf_frag_last(head), frag);

	return head;
}
4000d6d8:	00008067          	ret
{
4000d6dc:	ff010113          	addi	sp,sp,-16
4000d6e0:	00812423          	sw	s0,8(sp)
4000d6e4:	00112623          	sw	ra,12(sp)
4000d6e8:	00050413          	mv	s0,a0
4000d6ec:	00050793          	mv	a5,a0
	while (buf->frags) {
4000d6f0:	00078513          	mv	a0,a5
4000d6f4:	0047a783          	lw	a5,4(a5)
4000d6f8:	fe079ce3          	bnez	a5,4000d6f0 <net_buf_frag_add+0x2c>
	net_buf_frag_insert(net_buf_frag_last(head), frag);
4000d6fc:	fa5ff0ef          	jal	ra,4000d6a0 <net_buf_frag_insert>
}
4000d700:	00c12083          	lw	ra,12(sp)
	net_buf_frag_insert(net_buf_frag_last(head), frag);
4000d704:	00040513          	mv	a0,s0
}
4000d708:	00812403          	lw	s0,8(sp)
4000d70c:	01010113          	addi	sp,sp,16
4000d710:	00008067          	ret

4000d714 <net_buf_linearize>:
	return next_frag;
}

size_t net_buf_linearize(void *dst, size_t dst_len, struct net_buf *src,
			 size_t offset, size_t len)
{
4000d714:	fe010113          	addi	sp,sp,-32
4000d718:	00812c23          	sw	s0,24(sp)
4000d71c:	00912a23          	sw	s1,20(sp)
4000d720:	01412423          	sw	s4,8(sp)
4000d724:	00112e23          	sw	ra,28(sp)
4000d728:	01212823          	sw	s2,16(sp)
4000d72c:	01312623          	sw	s3,12(sp)
4000d730:	00050a13          	mv	s4,a0
4000d734:	00058413          	mv	s0,a1
4000d738:	00060493          	mv	s1,a2
	len = MIN(len, dst_len);

	frag = src;

	/* find the right fragment to start copying from */
	while (frag && offset >= frag->len) {
4000d73c:	02049c63          	bnez	s1,4000d774 <net_buf_linearize+0x60>
4000d740:	00000993          	li	s3,0
		/* after the first iteration, this value will be 0 */
		offset = 0;
	}

	return copied;
}
4000d744:	01c12083          	lw	ra,28(sp)
4000d748:	01812403          	lw	s0,24(sp)
4000d74c:	01412483          	lw	s1,20(sp)
4000d750:	01012903          	lw	s2,16(sp)
4000d754:	00812a03          	lw	s4,8(sp)
4000d758:	00098513          	mv	a0,s3
4000d75c:	00c12983          	lw	s3,12(sp)
4000d760:	02010113          	addi	sp,sp,32
4000d764:	00008067          	ret
		frag = frag->frags;
4000d768:	0044a483          	lw	s1,4(s1)
		offset -= frag->len;
4000d76c:	40f686b3          	sub	a3,a3,a5
		frag = frag->frags;
4000d770:	fcdff06f          	j	4000d73c <net_buf_linearize+0x28>
	while (frag && offset >= frag->len) {
4000d774:	0104d783          	lhu	a5,16(s1)
4000d778:	fef6f8e3          	bgeu	a3,a5,4000d768 <net_buf_linearize+0x54>
	len = MIN(len, dst_len);
4000d77c:	00877463          	bgeu	a4,s0,4000d784 <net_buf_linearize+0x70>
4000d780:	00070413          	mv	s0,a4
4000d784:	00000993          	li	s3,0
	while (frag && len > 0) {
4000d788:	fa048ee3          	beqz	s1,4000d744 <net_buf_linearize+0x30>
4000d78c:	fa040ce3          	beqz	s0,4000d744 <net_buf_linearize+0x30>
		to_copy = MIN(len, frag->len - offset);
4000d790:	0104d903          	lhu	s2,16(s1)
4000d794:	40d90933          	sub	s2,s2,a3
4000d798:	01247463          	bgeu	s0,s2,4000d7a0 <net_buf_linearize+0x8c>
4000d79c:	00040913          	mv	s2,s0
		memcpy((uint8_t *)dst + copied, frag->data + offset, to_copy);
4000d7a0:	00c4a583          	lw	a1,12(s1)
4000d7a4:	013a0533          	add	a0,s4,s3
4000d7a8:	00090613          	mv	a2,s2
4000d7ac:	00d585b3          	add	a1,a1,a3
4000d7b0:	d48ff0ef          	jal	ra,4000ccf8 <memcpy>
		copied += to_copy;
4000d7b4:	012989b3          	add	s3,s3,s2
		frag = frag->frags;
4000d7b8:	0044a483          	lw	s1,4(s1)
		len -= to_copy;
4000d7bc:	41240433          	sub	s0,s0,s2
		offset = 0;
4000d7c0:	00000693          	li	a3,0
4000d7c4:	fc5ff06f          	j	4000d788 <net_buf_linearize+0x74>

4000d7c8 <net_buf_simple_add>:
	return buf->data + buf->len;
4000d7c8:	00455783          	lhu	a5,4(a0)
4000d7cc:	00052703          	lw	a4,0(a0)

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
4000d7d0:	00b785b3          	add	a1,a5,a1
4000d7d4:	00b51223          	sh	a1,4(a0)
	return tail;
}
4000d7d8:	00f70533          	add	a0,a4,a5
4000d7dc:	00008067          	ret

4000d7e0 <net_buf_simple_add_be16>:
4000d7e0:	00455703          	lhu	a4,4(a0)
4000d7e4:	00052783          	lw	a5,0(a0)
4000d7e8:	00e787b3          	add	a5,a5,a4
	buf->len += len;
4000d7ec:	00270713          	addi	a4,a4,2
4000d7f0:	00e51223          	sh	a4,4(a0)
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
4000d7f4:	0085d713          	srli	a4,a1,0x8
4000d7f8:	00e78023          	sb	a4,0(a5)
	dst[1] = val;
4000d7fc:	00b780a3          	sb	a1,1(a5)
void net_buf_simple_add_be16(struct net_buf_simple *buf, uint16_t val)
{
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_be16(val, net_buf_simple_add(buf, sizeof(val)));
}
4000d800:	00008067          	ret

4000d804 <net_buf_simple_pull>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
4000d804:	00455703          	lhu	a4,4(a0)
{
4000d808:	00050793          	mv	a5,a0
	buf->len -= len;
4000d80c:	40b70733          	sub	a4,a4,a1
4000d810:	00e51223          	sh	a4,4(a0)
	return buf->data += len;
4000d814:	00052503          	lw	a0,0(a0)
4000d818:	00b50533          	add	a0,a0,a1
4000d81c:	00a7a023          	sw	a0,0(a5)
}
4000d820:	00008067          	ret

4000d824 <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
4000d824:	00050793          	mv	a5,a0

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
4000d828:	0047d703          	lhu	a4,4(a5)
	void *data = buf->data;
4000d82c:	00052503          	lw	a0,0(a0)
	buf->len -= len;
4000d830:	40b70733          	sub	a4,a4,a1
	buf->data += len;
4000d834:	00b505b3          	add	a1,a0,a1
	buf->len -= len;
4000d838:	00e79223          	sh	a4,4(a5)
	buf->data += len;
4000d83c:	00b7a023          	sw	a1,0(a5)

	return data;
}
4000d840:	00008067          	ret

4000d844 <net_buf_simple_max_len>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
4000d844:	00052783          	lw	a5,0(a0)
4000d848:	00852703          	lw	a4,8(a0)
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
}

uint16_t net_buf_simple_max_len(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf);
4000d84c:	00655503          	lhu	a0,6(a0)
	return buf->data - buf->__buf;
4000d850:	40e787b3          	sub	a5,a5,a4
	return buf->size - net_buf_simple_headroom(buf);
4000d854:	40f50533          	sub	a0,a0,a5
}
4000d858:	01051513          	slli	a0,a0,0x10
4000d85c:	01055513          	srli	a0,a0,0x10
4000d860:	00008067          	ret

4000d864 <net_ipv4_is_addr_mcast>:
 *
 * @return True if address is multicast address, False otherwise.
 */
static inline bool net_ipv4_is_addr_mcast(const struct in_addr *addr)
{
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
4000d864:	00054503          	lbu	a0,0(a0)
4000d868:	f00007b7          	lui	a5,0xf0000
4000d86c:	01851513          	slli	a0,a0,0x18
4000d870:	00f57533          	and	a0,a0,a5
4000d874:	200007b7          	lui	a5,0x20000
4000d878:	00f50533          	add	a0,a0,a5
}
4000d87c:	00153513          	seqz	a0,a0
4000d880:	00008067          	ret

4000d884 <ethernet_flags>:
 *
 * @return a pointer to the iface L2 data
 */
static inline void *net_if_l2_data(struct net_if *iface)
{
	return iface->if_dev->l2_data;
4000d884:	00052783          	lw	a5,0(a0)

enum net_l2_flags ethernet_flags(struct net_if *iface)
{
	struct ethernet_context *ctx = net_if_l2_data(iface);

	return ctx->ethernet_l2_flags;
4000d888:	0087a783          	lw	a5,8(a5) # 20000008 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1a0a1f08>
}
4000d88c:	0187c503          	lbu	a0,24(a5)
4000d890:	00008067          	ret

4000d894 <ethernet_enable>:
{
4000d894:	ff010113          	addi	sp,sp,-16
4000d898:	00112623          	sw	ra,12(sp)
4000d89c:	00812423          	sw	s0,8(sp)
4000d8a0:	00912223          	sw	s1,4(sp)
 *
 * @return a pointer to the device driver instance
 */
static inline const struct device *net_if_get_device(struct net_if *iface)
{
	return iface->if_dev->dev;
4000d8a4:	00052783          	lw	a5,0(a0)
4000d8a8:	0007a703          	lw	a4,0(a5)
	const struct ethernet_api *eth =
4000d8ac:	00872483          	lw	s1,8(a4)
	if (!eth) {
4000d8b0:	04048e63          	beqz	s1,4000d90c <ethernet_enable+0x78>
	if (!state) {
4000d8b4:	04059463          	bnez	a1,4000d8fc <ethernet_enable+0x68>
4000d8b8:	00050413          	mv	s0,a0
		net_arp_clear_cache(iface);
4000d8bc:	091010ef          	jal	ra,4000f14c <net_arp_clear_cache>
		if (eth->stop) {
4000d8c0:	00c4a783          	lw	a5,12(s1)
4000d8c4:	00079e63          	bnez	a5,4000d8e0 <ethernet_enable+0x4c>
	int ret = 0;
4000d8c8:	00000513          	li	a0,0
}
4000d8cc:	00c12083          	lw	ra,12(sp)
4000d8d0:	00812403          	lw	s0,8(sp)
4000d8d4:	00412483          	lw	s1,4(sp)
4000d8d8:	01010113          	addi	sp,sp,16
4000d8dc:	00008067          	ret
4000d8e0:	00042703          	lw	a4,0(s0)
			ret = eth->stop(net_if_get_device(iface));
4000d8e4:	00072503          	lw	a0,0(a4)
}
4000d8e8:	00812403          	lw	s0,8(sp)
4000d8ec:	00c12083          	lw	ra,12(sp)
4000d8f0:	00412483          	lw	s1,4(sp)
4000d8f4:	01010113          	addi	sp,sp,16
			ret = eth->start(net_if_get_device(iface));
4000d8f8:	00078067          	jr	a5
		if (eth->start) {
4000d8fc:	0084a783          	lw	a5,8(s1)
4000d900:	fc0784e3          	beqz	a5,4000d8c8 <ethernet_enable+0x34>
			ret = eth->start(net_if_get_device(iface));
4000d904:	00070513          	mv	a0,a4
4000d908:	fe1ff06f          	j	4000d8e8 <ethernet_enable+0x54>
		return -ENOENT;
4000d90c:	ffe00513          	li	a0,-2
4000d910:	fbdff06f          	j	4000d8cc <ethernet_enable+0x38>

4000d914 <net_eth_is_addr_broadcast>:
} __packed;


static inline bool net_eth_is_addr_broadcast(struct net_eth_addr *addr)
{
	if (addr->addr[0] == 0xff &&
4000d914:	00054683          	lbu	a3,0(a0)
4000d918:	0ff00713          	li	a4,255
{
4000d91c:	00050793          	mv	a5,a0
	    addr->addr[4] == 0xff &&
	    addr->addr[5] == 0xff) {
		return true;
	}

	return false;
4000d920:	00000513          	li	a0,0
	if (addr->addr[0] == 0xff &&
4000d924:	02e69c63          	bne	a3,a4,4000d95c <net_eth_is_addr_broadcast+0x48>
4000d928:	0017c703          	lbu	a4,1(a5)
	return false;
4000d92c:	00000513          	li	a0,0
	if (addr->addr[0] == 0xff &&
4000d930:	02d71663          	bne	a4,a3,4000d95c <net_eth_is_addr_broadcast+0x48>
	    addr->addr[1] == 0xff &&
4000d934:	0027c683          	lbu	a3,2(a5)
4000d938:	02e69263          	bne	a3,a4,4000d95c <net_eth_is_addr_broadcast+0x48>
	    addr->addr[2] == 0xff &&
4000d93c:	0037c703          	lbu	a4,3(a5)
4000d940:	00d71e63          	bne	a4,a3,4000d95c <net_eth_is_addr_broadcast+0x48>
	    addr->addr[3] == 0xff &&
4000d944:	0047c683          	lbu	a3,4(a5)
4000d948:	00e69a63          	bne	a3,a4,4000d95c <net_eth_is_addr_broadcast+0x48>
	    addr->addr[4] == 0xff &&
4000d94c:	0057c503          	lbu	a0,5(a5)
4000d950:	f0150513          	addi	a0,a0,-255
4000d954:	00153513          	seqz	a0,a0
4000d958:	00008067          	ret
}
4000d95c:	00008067          	ret

4000d960 <net_eth_is_addr_multicast>:
}

static inline bool net_eth_is_addr_multicast(struct net_eth_addr *addr)
{
#if defined(CONFIG_NET_IPV6)
	if (addr->addr[0] == 0x33 &&
4000d960:	00054703          	lbu	a4,0(a0)
4000d964:	03300693          	li	a3,51
{
4000d968:	00050793          	mv	a5,a0
	if (addr->addr[0] == 0x33 &&
4000d96c:	00d71a63          	bne	a4,a3,4000d980 <net_eth_is_addr_multicast+0x20>
4000d970:	00154503          	lbu	a0,1(a0)
4000d974:	fcd50513          	addi	a0,a0,-51
	}
#endif

#if defined(CONFIG_NET_IPV4)
	if (addr->addr[0] == 0x01 &&
	    addr->addr[1] == 0x00 &&
4000d978:	00153513          	seqz	a0,a0
		return true;
	}
#endif

	return false;
}
4000d97c:	00008067          	ret
	if (addr->addr[0] == 0x01 &&
4000d980:	00100693          	li	a3,1
	return false;
4000d984:	00000513          	li	a0,0
	if (addr->addr[0] == 0x01 &&
4000d988:	fed71ae3          	bne	a4,a3,4000d97c <net_eth_is_addr_multicast+0x1c>
4000d98c:	0017c703          	lbu	a4,1(a5)
4000d990:	fe0716e3          	bnez	a4,4000d97c <net_eth_is_addr_multicast+0x1c>
	    addr->addr[1] == 0x00 &&
4000d994:	0027c503          	lbu	a0,2(a5)
4000d998:	fa250513          	addi	a0,a0,-94
4000d99c:	fddff06f          	j	4000d978 <net_eth_is_addr_multicast+0x18>

4000d9a0 <carrier_on_off>:
{
	struct ethernet_context *ctx = CONTAINER_OF(work, struct ethernet_context,
						    carrier_work);
	bool eth_carrier_up;

	if (ctx->iface == NULL) {
4000d9a0:	01052783          	lw	a5,16(a0)
4000d9a4:	06078c63          	beqz	a5,4000da1c <carrier_on_off+0x7c>
{
4000d9a8:	ff010113          	addi	sp,sp,-16
4000d9ac:	00812423          	sw	s0,8(sp)
4000d9b0:	00050413          	mv	s0,a0
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_bit(const atomic_t *target, int bit)
{
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
4000d9b4:	ffc50513          	addi	a0,a0,-4
4000d9b8:	00112623          	sw	ra,12(sp)
4000d9bc:	0cc240ef          	jal	ra,40031a88 <atomic_get>
		return;
	}

	eth_carrier_up = atomic_test_bit(&ctx->flags, ETH_CARRIER_UP);

	if (eth_carrier_up == ctx->is_net_carrier_up) {
4000d9c0:	01442703          	lw	a4,20(s0)

	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
4000d9c4:	00157793          	andi	a5,a0,1
4000d9c8:	00875713          	srli	a4,a4,0x8
4000d9cc:	00177713          	andi	a4,a4,1
4000d9d0:	02f70e63          	beq	a4,a5,4000da0c <carrier_on_off+0x6c>
		return;
	}

	ctx->is_net_carrier_up = eth_carrier_up;
4000d9d4:	01544703          	lbu	a4,21(s0)

	NET_DBG("Carrier %s for interface %p", eth_carrier_up ? "ON" : "OFF",
		ctx->iface);

	if (eth_carrier_up) {
		ethernet_mgmt_raise_carrier_on_event(ctx->iface);
4000d9d8:	01042503          	lw	a0,16(s0)
	ctx->is_net_carrier_up = eth_carrier_up;
4000d9dc:	ffe77713          	andi	a4,a4,-2
4000d9e0:	00f76733          	or	a4,a4,a5
4000d9e4:	00e40aa3          	sb	a4,21(s0)
	if (eth_carrier_up) {
4000d9e8:	00078a63          	beqz	a5,4000d9fc <carrier_on_off+0x5c>
		net_if_carrier_on(ctx->iface);
	} else {
		ethernet_mgmt_raise_carrier_off_event(ctx->iface);
		net_if_carrier_off(ctx->iface);
	}
}
4000d9ec:	00812403          	lw	s0,8(sp)
4000d9f0:	00c12083          	lw	ra,12(sp)
4000d9f4:	01010113          	addi	sp,sp,16
		net_if_carrier_on(ctx->iface);
4000d9f8:	3dc0606f          	j	40013dd4 <net_if_carrier_on>
}
4000d9fc:	00812403          	lw	s0,8(sp)
4000da00:	00c12083          	lw	ra,12(sp)
4000da04:	01010113          	addi	sp,sp,16
		net_if_carrier_off(ctx->iface);
4000da08:	4100606f          	j	40013e18 <net_if_carrier_off>
}
4000da0c:	00c12083          	lw	ra,12(sp)
4000da10:	00812403          	lw	s0,8(sp)
4000da14:	01010113          	addi	sp,sp,16
4000da18:	00008067          	ret
4000da1c:	00008067          	ret

4000da20 <ethernet_recv>:
{
4000da20:	fd010113          	addi	sp,sp,-48
4000da24:	01312e23          	sw	s3,28(sp)
4000da28:	02112623          	sw	ra,44(sp)
4000da2c:	02812423          	sw	s0,40(sp)
4000da30:	02912223          	sw	s1,36(sp)
4000da34:	03212023          	sw	s2,32(sp)
4000da38:	01412c23          	sw	s4,24(sp)
4000da3c:	01512a23          	sw	s5,20(sp)
4000da40:	01612823          	sw	s6,16(sp)
4000da44:	01712623          	sw	s7,12(sp)
	return net_buf_frags_len(pkt->frags);
}

static inline uint8_t *net_pkt_data(struct net_pkt *pkt)
{
	return pkt->frags->data;
4000da48:	0085a783          	lw	a5,8(a1)
4000da4c:	00050993          	mv	s3,a0
4000da50:	00c7a903          	lw	s2,12(a5)
	if (hdr == NULL || pkt->buffer->len < hdr_len) {
4000da54:	0c090c63          	beqz	s2,4000db2c <ethernet_recv+0x10c>
4000da58:	0107d703          	lhu	a4,16(a5)
4000da5c:	00d00793          	li	a5,13
4000da60:	0ce7f663          	bgeu	a5,a4,4000db2c <ethernet_recv+0x10c>
4000da64:	00d94483          	lbu	s1,13(s2)
4000da68:	00c94783          	lbu	a5,12(s2)
4000da6c:	00058413          	mv	s0,a1
	type = ntohs(hdr->type);
4000da70:	00849493          	slli	s1,s1,0x8
4000da74:	00f4e4b3          	or	s1,s1,a5
4000da78:	0084d713          	srli	a4,s1,0x8
4000da7c:	00849793          	slli	a5,s1,0x8
4000da80:	00e7e7b3          	or	a5,a5,a4
	switch (type) {
4000da84:	00009737          	lui	a4,0x9
4000da88:	01079793          	slli	a5,a5,0x10
4000da8c:	e8870693          	addi	a3,a4,-376 # 8e88 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4e88>
4000da90:	0107d793          	srli	a5,a5,0x10
4000da94:	26d48a63          	beq	s1,a3,4000dd08 <ethernet_recv+0x2e8>
4000da98:	88e70713          	addi	a4,a4,-1906
4000da9c:	08f76263          	bltu	a4,a5,4000db20 <ethernet_recv+0x100>
4000daa0:	0000e737          	lui	a4,0xe
4000daa4:	d8670713          	addi	a4,a4,-634 # dd86 <__kernel_ram_size+0x227e>
4000daa8:	24e48463          	beq	s1,a4,4000dcf0 <ethernet_recv+0x2d0>
4000daac:	00008737          	lui	a4,0x8
4000dab0:	6dd70713          	addi	a4,a4,1757 # 86dd <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x46dd>
4000dab4:	00f76a63          	bltu	a4,a5,4000dac8 <ethernet_recv+0xa8>
4000dab8:	00800713          	li	a4,8
4000dabc:	06e48c63          	beq	s1,a4,4000db34 <ethernet_recv+0x114>
4000dac0:	60800713          	li	a4,1544
4000dac4:	06e48863          	beq	s1,a4,4000db34 <ethernet_recv+0x114>
4000dac8:	0009a783          	lw	a5,0(s3)
4000dacc:	0007a503          	lw	a0,0(a5)
{
	struct net_stats_eth *stats;
	const struct ethernet_api *api = ((const struct ethernet_api *)
		net_if_get_device(iface)->api);

	if (!api->get_stats) {
4000dad0:	00852783          	lw	a5,8(a0)
4000dad4:	0047a783          	lw	a5,4(a5)
4000dad8:	00078c63          	beqz	a5,4000daf0 <ethernet_recv+0xd0>
		return;
	}

	stats = api->get_stats(net_if_get_device(iface));
4000dadc:	000780e7          	jalr	a5
	if (!stats) {
4000dae0:	00050863          	beqz	a0,4000daf0 <ethernet_recv+0xd0>
		return;
	}

	stats->unknown_protocol++;
4000dae4:	0a852783          	lw	a5,168(a0)
4000dae8:	00178793          	addi	a5,a5,1
4000daec:	0af52423          	sw	a5,168(a0)
	return NET_DROP;
4000daf0:	00200513          	li	a0,2
}
4000daf4:	02c12083          	lw	ra,44(sp)
4000daf8:	02812403          	lw	s0,40(sp)
4000dafc:	02412483          	lw	s1,36(sp)
4000db00:	02012903          	lw	s2,32(sp)
4000db04:	01c12983          	lw	s3,28(sp)
4000db08:	01812a03          	lw	s4,24(sp)
4000db0c:	01412a83          	lw	s5,20(sp)
4000db10:	01012b03          	lw	s6,16(sp)
4000db14:	00c12b83          	lw	s7,12(sp)
4000db18:	03010113          	addi	sp,sp,48
4000db1c:	00008067          	ret
	switch (type) {
4000db20:	0000d7b7          	lui	a5,0xd
4000db24:	c8878793          	addi	a5,a5,-888 # cc88 <__kernel_ram_size+0x1180>
4000db28:	faf490e3          	bne	s1,a5,4000dac8 <ethernet_recv+0xa8>
	if (!iface) {
4000db2c:	20099063          	bnez	s3,4000dd2c <ethernet_recv+0x30c>
4000db30:	fc1ff06f          	j	4000daf0 <ethernet_recv+0xd0>
	pkt->family = family;
4000db34:	03744703          	lbu	a4,55(s0)
		family = AF_INET;
4000db38:	00100a13          	li	s4,1
4000db3c:	01f77713          	andi	a4,a4,31
4000db40:	02076713          	ori	a4,a4,32
4000db44:	02e40ba3          	sb	a4,55(s0)
	lladdr->addr = hdr->src.addr;
4000db48:	00690713          	addi	a4,s2,6
4000db4c:	02e42223          	sw	a4,36(s0)
	lladdr->len = sizeof(struct net_eth_addr);
4000db50:	30600713          	li	a4,774
4000db54:	02e41423          	sh	a4,40(s0)
	lladdr->addr = hdr->dst.addr;
4000db58:	03242623          	sw	s2,44(s0)
	lladdr->len = sizeof(struct net_eth_addr);
4000db5c:	02e41823          	sh	a4,48(s0)
	return pkt->ll_proto_type;
}

static inline void net_pkt_set_ll_proto_type(struct net_pkt *pkt, uint16_t type)
{
	pkt->ll_proto_type = type;
4000db60:	02f41a23          	sh	a5,52(s0)
	if (!net_eth_is_addr_broadcast((struct net_eth_addr *)lladdr->addr) &&
4000db64:	00090513          	mv	a0,s2
4000db68:	dadff0ef          	jal	ra,4000d914 <net_eth_is_addr_broadcast>
4000db6c:	1a050263          	beqz	a0,4000dd10 <ethernet_recv+0x2f0>
 *
 * @return New beginning of the buffer data.
 */
static inline void *net_buf_pull(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull(&buf->b, len);
4000db70:	00842503          	lw	a0,8(s0)
4000db74:	00e00593          	li	a1,14
4000db78:	00c50513          	addi	a0,a0,12
4000db7c:	c89ff0ef          	jal	ra,4000d804 <net_buf_simple_pull>
	if (IS_ENABLED(CONFIG_NET_IPV4) && type == NET_ETH_PTYPE_IP &&
4000db80:	00800793          	li	a5,8
4000db84:	08f49a63          	bne	s1,a5,4000dc18 <ethernet_recv+0x1f8>
	if (net_eth_is_addr_broadcast(&hdr->dst) &&
4000db88:	00090513          	mv	a0,s2
4000db8c:	d89ff0ef          	jal	ra,4000d914 <net_eth_is_addr_broadcast>
	return pkt->frags->data;
4000db90:	00842783          	lw	a5,8(s0)
4000db94:	08050263          	beqz	a0,4000dc18 <ethernet_recv+0x1f8>
4000db98:	00c7ab83          	lw	s7,12(a5)
	    !(net_ipv4_is_addr_mcast((struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
4000db9c:	010b8a93          	addi	s5,s7,16
4000dba0:	000a8513          	mv	a0,s5
4000dba4:	cc1ff0ef          	jal	ra,4000d864 <net_ipv4_is_addr_mcast>
	if (net_eth_is_addr_broadcast(&hdr->dst) &&
4000dba8:	06051863          	bnez	a0,4000dc18 <ethernet_recv+0x1f8>
	return pkt->iface;
4000dbac:	01842b03          	lw	s6,24(s0)
 */
#if defined(CONFIG_NET_NATIVE_IPV4)
static inline bool net_ipv4_is_addr_bcast(struct net_if *iface,
					  const struct in_addr *addr)
{
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000dbb0:	04d070ef          	jal	ra,400153fc <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000dbb4:	011bc703          	lbu	a4,17(s7)
4000dbb8:	010bc783          	lbu	a5,16(s7)
4000dbbc:	00054683          	lbu	a3,0(a0)
4000dbc0:	00871713          	slli	a4,a4,0x8
4000dbc4:	00f76733          	or	a4,a4,a5
4000dbc8:	012bc783          	lbu	a5,18(s7)
4000dbcc:	01079793          	slli	a5,a5,0x10
4000dbd0:	00e7e7b3          	or	a5,a5,a4
4000dbd4:	013bc703          	lbu	a4,19(s7)
4000dbd8:	01871713          	slli	a4,a4,0x18
4000dbdc:	00f76733          	or	a4,a4,a5
4000dbe0:	00154783          	lbu	a5,1(a0)
4000dbe4:	00879793          	slli	a5,a5,0x8
4000dbe8:	00d7e7b3          	or	a5,a5,a3
4000dbec:	00254683          	lbu	a3,2(a0)
4000dbf0:	01069693          	slli	a3,a3,0x10
4000dbf4:	00f6e6b3          	or	a3,a3,a5
4000dbf8:	00354783          	lbu	a5,3(a0)
4000dbfc:	01879793          	slli	a5,a5,0x18
4000dc00:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000dc04:	00f70a63          	beq	a4,a5,4000dc18 <ethernet_recv+0x1f8>
		return true;
	}

	return net_if_ipv4_is_addr_bcast(iface, addr);
4000dc08:	000a8593          	mv	a1,s5
4000dc0c:	000b0513          	mv	a0,s6
4000dc10:	464050ef          	jal	ra,40013074 <net_if_ipv4_is_addr_bcast>
	    !(net_ipv4_is_addr_mcast((struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
4000dc14:	f0050ce3          	beqz	a0,4000db2c <ethernet_recv+0x10c>
	ethernet_update_rx_stats(iface, hdr, net_pkt_get_len(pkt) + hdr_len);
4000dc18:	00842783          	lw	a5,8(s0)
 *
 * @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;
4000dc1c:	00000a93          	li	s5,0

	while (buf) {
4000dc20:	14079863          	bnez	a5,4000dd70 <ethernet_recv+0x350>
4000dc24:	0009a783          	lw	a5,0(s3)
4000dc28:	0007a503          	lw	a0,0(a5)
	if (!api->get_stats) {
4000dc2c:	00852783          	lw	a5,8(a0)
4000dc30:	0047a783          	lw	a5,4(a5)
4000dc34:	00078e63          	beqz	a5,4000dc50 <ethernet_recv+0x230>
	stats = api->get_stats(net_if_get_device(iface));
4000dc38:	000780e7          	jalr	a5
	if (!stats) {
4000dc3c:	00050a63          	beqz	a0,4000dc50 <ethernet_recv+0x230>
	stats->bytes.received += bytes;
4000dc40:	00452783          	lw	a5,4(a0)
4000dc44:	00ea8a93          	addi	s5,s5,14
4000dc48:	015787b3          	add	a5,a5,s5
4000dc4c:	00f52223          	sw	a5,4(a0)
4000dc50:	0009a783          	lw	a5,0(s3)
4000dc54:	0007a503          	lw	a0,0(a5)
	if (!api->get_stats) {
4000dc58:	00852783          	lw	a5,8(a0)
4000dc5c:	0047a783          	lw	a5,4(a5)
4000dc60:	00078c63          	beqz	a5,4000dc78 <ethernet_recv+0x258>
	stats = api->get_stats(net_if_get_device(iface));
4000dc64:	000780e7          	jalr	a5
	if (!stats) {
4000dc68:	00050863          	beqz	a0,4000dc78 <ethernet_recv+0x258>
	stats->pkts.rx++;
4000dc6c:	00c52783          	lw	a5,12(a0)
4000dc70:	00178793          	addi	a5,a5,1
4000dc74:	00f52623          	sw	a5,12(a0)
	if (net_eth_is_addr_broadcast(&hdr->dst)) {
4000dc78:	00090513          	mv	a0,s2
4000dc7c:	c99ff0ef          	jal	ra,4000d914 <net_eth_is_addr_broadcast>
4000dc80:	10050063          	beqz	a0,4000dd80 <ethernet_recv+0x360>
4000dc84:	0009a783          	lw	a5,0(s3)
4000dc88:	0007a503          	lw	a0,0(a5)
	if (!api->get_stats) {
4000dc8c:	00852783          	lw	a5,8(a0)
4000dc90:	0047a783          	lw	a5,4(a5)
4000dc94:	00078c63          	beqz	a5,4000dcac <ethernet_recv+0x28c>
	stats = api->get_stats(net_if_get_device(iface));
4000dc98:	000780e7          	jalr	a5
	if (!stats) {
4000dc9c:	00050863          	beqz	a0,4000dcac <ethernet_recv+0x28c>
	stats->broadcast.rx++;
4000dca0:	01452783          	lw	a5,20(a0)
4000dca4:	00178793          	addi	a5,a5,1
4000dca8:	00f52a23          	sw	a5,20(a0)
	if (IS_ENABLED(CONFIG_NET_ARP) &&
4000dcac:	00100793          	li	a5,1
4000dcb0:	10fa1463          	bne	s4,a5,4000ddb8 <ethernet_recv+0x398>
	    family == AF_INET && type == NET_ETH_PTYPE_ARP) {
4000dcb4:	60800793          	li	a5,1544
4000dcb8:	10f49063          	bne	s1,a5,4000ddb8 <ethernet_recv+0x398>
		return net_arp_input(pkt, hdr);
4000dcbc:	00040513          	mv	a0,s0
}
4000dcc0:	02812403          	lw	s0,40(sp)
4000dcc4:	02c12083          	lw	ra,44(sp)
4000dcc8:	02412483          	lw	s1,36(sp)
4000dccc:	01c12983          	lw	s3,28(sp)
4000dcd0:	01812a03          	lw	s4,24(sp)
4000dcd4:	01412a83          	lw	s5,20(sp)
4000dcd8:	01012b03          	lw	s6,16(sp)
4000dcdc:	00c12b83          	lw	s7,12(sp)
		return net_arp_input(pkt, hdr);
4000dce0:	00090593          	mv	a1,s2
}
4000dce4:	02012903          	lw	s2,32(sp)
4000dce8:	03010113          	addi	sp,sp,48
		return net_arp_input(pkt, hdr);
4000dcec:	0500106f          	j	4000ed3c <net_arp_input>
	pkt->family = family;
4000dcf0:	0375c703          	lbu	a4,55(a1)
		family = AF_INET6;
4000dcf4:	00200a13          	li	s4,2
4000dcf8:	01f77713          	andi	a4,a4,31
4000dcfc:	04076713          	ori	a4,a4,64
4000dd00:	02e58ba3          	sb	a4,55(a1)
		break;
4000dd04:	e45ff06f          	j	4000db48 <ethernet_recv+0x128>
	switch (type) {
4000dd08:	00000a13          	li	s4,0
4000dd0c:	e3dff06f          	j	4000db48 <ethernet_recv+0x128>
	    !net_eth_is_addr_multicast((struct net_eth_addr *)lladdr->addr) &&
4000dd10:	00090513          	mv	a0,s2
4000dd14:	c4dff0ef          	jal	ra,4000d960 <net_eth_is_addr_multicast>
	if (!net_eth_is_addr_broadcast((struct net_eth_addr *)lladdr->addr) &&
4000dd18:	e4051ce3          	bnez	a0,4000db70 <ethernet_recv+0x150>
 *
 * @return a pointer to the network link address
 */
static inline struct net_linkaddr *net_if_get_link_addr(struct net_if *iface)
{
	return &iface->if_dev->link_addr;
4000dd1c:	0009a783          	lw	a5,0(s3)
{
	if (!lladdr1 || !lladdr2) {
		return false;
	}

	if (lladdr1->len != lladdr2->len) {
4000dd20:	00600713          	li	a4,6
4000dd24:	0147c683          	lbu	a3,20(a5)
4000dd28:	02e68863          	beq	a3,a4,4000dd58 <ethernet_recv+0x338>
	return iface->if_dev->dev;
4000dd2c:	0009a783          	lw	a5,0(s3)
4000dd30:	0007a503          	lw	a0,0(a5)
	if (!api->get_stats) {
4000dd34:	00852783          	lw	a5,8(a0)
4000dd38:	0047a783          	lw	a5,4(a5)
4000dd3c:	da078ae3          	beqz	a5,4000daf0 <ethernet_recv+0xd0>
	stats = api->get_stats(net_if_get_device(iface));
4000dd40:	000780e7          	jalr	a5
	if (!stats) {
4000dd44:	da0506e3          	beqz	a0,4000daf0 <ethernet_recv+0xd0>
	stats->errors.rx++;
4000dd48:	02452783          	lw	a5,36(a0)
4000dd4c:	00178793          	addi	a5,a5,1
4000dd50:	02f52223          	sw	a5,36(a0)
4000dd54:	d9dff06f          	j	4000daf0 <ethernet_recv+0xd0>
		return false;
	}

	return !memcmp(lladdr1->addr, lladdr2->addr, lladdr1->len);
4000dd58:	0107a503          	lw	a0,16(a5)
4000dd5c:	00600613          	li	a2,6
4000dd60:	00090593          	mv	a1,s2
4000dd64:	f15fe0ef          	jal	ra,4000cc78 <memcmp>
		    (struct net_eth_addr *)lladdr->addr) &&
4000dd68:	e00504e3          	beqz	a0,4000db70 <ethernet_recv+0x150>
4000dd6c:	fc1ff06f          	j	4000dd2c <ethernet_recv+0x30c>
		bytes += buf->len;
4000dd70:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
4000dd74:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4000dd78:	00ea8ab3          	add	s5,s5,a4
		buf = buf->frags;
4000dd7c:	ea5ff06f          	j	4000dc20 <ethernet_recv+0x200>
	} else if (net_eth_is_addr_multicast(&hdr->dst)) {
4000dd80:	00090513          	mv	a0,s2
4000dd84:	bddff0ef          	jal	ra,4000d960 <net_eth_is_addr_multicast>
4000dd88:	f20502e3          	beqz	a0,4000dcac <ethernet_recv+0x28c>
4000dd8c:	0009a783          	lw	a5,0(s3)
4000dd90:	0007a503          	lw	a0,0(a5)
	if (!api->get_stats) {
4000dd94:	00852783          	lw	a5,8(a0)
4000dd98:	0047a783          	lw	a5,4(a5)
4000dd9c:	f00788e3          	beqz	a5,4000dcac <ethernet_recv+0x28c>
	stats = api->get_stats(net_if_get_device(iface));
4000dda0:	000780e7          	jalr	a5
	if (!stats) {
4000dda4:	f00504e3          	beqz	a0,4000dcac <ethernet_recv+0x28c>
	stats->multicast.rx++;
4000dda8:	01c52783          	lw	a5,28(a0)
4000ddac:	00178793          	addi	a5,a5,1
4000ddb0:	00f52e23          	sw	a5,28(a0)
4000ddb4:	ef9ff06f          	j	4000dcac <ethernet_recv+0x28c>
	return pkt->family;
4000ddb8:	03442703          	lw	a4,52(s0)
	return pkt->frags->data;
4000ddbc:	00842683          	lw	a3,8(s0)
	if (net_pkt_family(pkt) == AF_INET) {
4000ddc0:	00100613          	li	a2,1
4000ddc4:	01d75713          	srli	a4,a4,0x1d
4000ddc8:	00c6a783          	lw	a5,12(a3)
4000ddcc:	02c71c63          	bne	a4,a2,4000de04 <ethernet_recv+0x3e4>
4000ddd0:	0037c703          	lbu	a4,3(a5)
4000ddd4:	0027c603          	lbu	a2,2(a5)
4000ddd8:	00871713          	slli	a4,a4,0x8
4000dddc:	00c76733          	or	a4,a4,a2
4000dde0:	00871793          	slli	a5,a4,0x8
4000dde4:	00875713          	srli	a4,a4,0x8
4000dde8:	00e7e7b3          	or	a5,a5,a4
		len = ntohs(NET_IPV6_HDR(pkt)->len) + NET_IPV6H_LEN;
4000ddec:	01079793          	slli	a5,a5,0x10
4000ddf0:	0107d793          	srli	a5,a5,0x10
	if (len < NET_ETH_MINIMAL_FRAME_SIZE - sizeof(struct net_eth_hdr)) {
4000ddf4:	02d00713          	li	a4,45
4000ddf8:	02f77863          	bgeu	a4,a5,4000de28 <ethernet_recv+0x408>
	return NET_CONTINUE;
4000ddfc:	00100513          	li	a0,1
4000de00:	cf5ff06f          	j	4000daf4 <ethernet_recv+0xd4>
		len = ntohs(NET_IPV6_HDR(pkt)->len) + NET_IPV6H_LEN;
4000de04:	0057c703          	lbu	a4,5(a5)
4000de08:	0047c603          	lbu	a2,4(a5)
4000de0c:	00871713          	slli	a4,a4,0x8
4000de10:	00c76733          	or	a4,a4,a2
4000de14:	00871793          	slli	a5,a4,0x8
4000de18:	00875713          	srli	a4,a4,0x8
4000de1c:	00e7e7b3          	or	a5,a5,a4
4000de20:	02878793          	addi	a5,a5,40
4000de24:	fc9ff06f          	j	4000ddec <ethernet_recv+0x3cc>
			if (frag->len < len) {
4000de28:	0106d703          	lhu	a4,16(a3)
4000de2c:	00f77e63          	bgeu	a4,a5,4000de48 <ethernet_recv+0x428>
				len -= frag->len;
4000de30:	40e787b3          	sub	a5,a5,a4
4000de34:	01079793          	slli	a5,a5,0x10
4000de38:	0107d793          	srli	a5,a5,0x10
		for (frag = pkt->frags; frag; frag = frag->frags) {
4000de3c:	0046a683          	lw	a3,4(a3)
4000de40:	fe0694e3          	bnez	a3,4000de28 <ethernet_recv+0x408>
4000de44:	fb9ff06f          	j	4000ddfc <ethernet_recv+0x3dc>
				frag->len = len;
4000de48:	00f69823          	sh	a5,16(a3)
				len = 0U;
4000de4c:	00000793          	li	a5,0
4000de50:	fedff06f          	j	4000de3c <ethernet_recv+0x41c>

4000de54 <net_eth_broadcast_addr>:
	return &broadcast_eth_addr;
4000de54:	40032537          	lui	a0,0x40032
}
4000de58:	5ec50513          	addi	a0,a0,1516 # 400325ec <broadcast_eth_addr>
4000de5c:	00008067          	ret

4000de60 <net_eth_ipv4_mcast_to_mac_addr>:
	mac_addr->addr[0] = 0x01;
4000de60:	00100793          	li	a5,1
4000de64:	00f58023          	sb	a5,0(a1)
	mac_addr->addr[2] = 0x5e;
4000de68:	05e00793          	li	a5,94
	mac_addr->addr[1] = 0x00;
4000de6c:	000580a3          	sb	zero,1(a1)
	mac_addr->addr[2] = 0x5e;
4000de70:	00f58123          	sb	a5,2(a1)
	mac_addr->addr[3] = ipv4_addr->s4_addr[1];
4000de74:	00154783          	lbu	a5,1(a0)
4000de78:	00f581a3          	sb	a5,3(a1)
	mac_addr->addr[4] = ipv4_addr->s4_addr[2];
4000de7c:	00254703          	lbu	a4,2(a0)
	mac_addr->addr[3] &= 0x7f;
4000de80:	07f7f793          	andi	a5,a5,127
	mac_addr->addr[4] = ipv4_addr->s4_addr[2];
4000de84:	00e58223          	sb	a4,4(a1)
	mac_addr->addr[5] = ipv4_addr->s4_addr[3];
4000de88:	00354703          	lbu	a4,3(a0)
	mac_addr->addr[3] &= 0x7f;
4000de8c:	00f581a3          	sb	a5,3(a1)
	mac_addr->addr[5] = ipv4_addr->s4_addr[3];
4000de90:	00e582a3          	sb	a4,5(a1)
}
4000de94:	00008067          	ret

4000de98 <ethernet_send>:
{
4000de98:	fc010113          	addi	sp,sp,-64
4000de9c:	03212823          	sw	s2,48(sp)
4000dea0:	02112e23          	sw	ra,60(sp)
4000dea4:	02812c23          	sw	s0,56(sp)
4000dea8:	02912a23          	sw	s1,52(sp)
4000deac:	03312623          	sw	s3,44(sp)
4000deb0:	03412423          	sw	s4,40(sp)
4000deb4:	03512223          	sw	s5,36(sp)
4000deb8:	03612023          	sw	s6,32(sp)
4000debc:	01712e23          	sw	s7,28(sp)
4000dec0:	00052783          	lw	a5,0(a0)
		ret = -ENOENT;
4000dec4:	ffe00913          	li	s2,-2
	const struct ethernet_api *api = net_if_get_device(iface)->api;
4000dec8:	0007a783          	lw	a5,0(a5)
4000decc:	0087ab03          	lw	s6,8(a5)
	if (!api) {
4000ded0:	2c0b0063          	beqz	s6,4000e190 <ethernet_send+0x2f8>
	return pkt->family;
4000ded4:	0345a783          	lw	a5,52(a1)
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
4000ded8:	00100713          	li	a4,1
4000dedc:	00050993          	mv	s3,a0
4000dee0:	01d7d793          	srli	a5,a5,0x1d
4000dee4:	00058493          	mv	s1,a1
4000dee8:	20e79c63          	bne	a5,a4,4000e100 <ethernet_send+0x268>
	return pkt->frags->data;
4000deec:	0085a783          	lw	a5,8(a1)
	return pkt->iface;
4000def0:	0185a903          	lw	s2,24(a1)
	return pkt->frags->data;
4000def4:	00c7a403          	lw	s0,12(a5)
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000def8:	504070ef          	jal	ra,400153fc <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000defc:	00054683          	lbu	a3,0(a0)
4000df00:	01144703          	lbu	a4,17(s0)
4000df04:	01044783          	lbu	a5,16(s0)
4000df08:	00871713          	slli	a4,a4,0x8
4000df0c:	00f76733          	or	a4,a4,a5
4000df10:	01244783          	lbu	a5,18(s0)
4000df14:	01079793          	slli	a5,a5,0x10
4000df18:	00e7e7b3          	or	a5,a5,a4
4000df1c:	01344703          	lbu	a4,19(s0)
4000df20:	01871713          	slli	a4,a4,0x18
4000df24:	00f76733          	or	a4,a4,a5
4000df28:	00154783          	lbu	a5,1(a0)
4000df2c:	00879793          	slli	a5,a5,0x8
4000df30:	00d7e7b3          	or	a5,a5,a3
4000df34:	00254683          	lbu	a3,2(a0)
4000df38:	01069693          	slli	a3,a3,0x10
4000df3c:	00f6e6b3          	or	a3,a3,a5
4000df40:	00354783          	lbu	a5,3(a0)
4000df44:	01879793          	slli	a5,a5,0x18
4000df48:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000df4c:	14f71463          	bne	a4,a5,4000e094 <ethernet_send+0x1fc>
				ptype = htons(NET_ETH_PTYPE_IP);
4000df50:	00048413          	mv	s0,s1
4000df54:	00800a13          	li	s4,8
	if (!net_pkt_lladdr_dst(pkt)->addr) {
4000df58:	02c42783          	lw	a5,44(s0)
4000df5c:	00079c63          	bnez	a5,4000df74 <ethernet_send+0xdc>
		net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)broadcast_eth_addr.addr;
4000df60:	400327b7          	lui	a5,0x40032
4000df64:	5ec78793          	addi	a5,a5,1516 # 400325ec <broadcast_eth_addr>
4000df68:	02f42623          	sw	a5,44(s0)
		net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
4000df6c:	00600793          	li	a5,6
4000df70:	02f40823          	sb	a5,48(s0)
	hdr_frag = net_pkt_get_frag(pkt, hdr_len, NET_BUF_TIMEOUT);
4000df74:	00a00613          	li	a2,10
4000df78:	00000693          	li	a3,0
4000df7c:	00e00593          	li	a1,14
4000df80:	00040513          	mv	a0,s0
4000df84:	009090ef          	jal	ra,4001778c <net_pkt_get_frag>
4000df88:	00050a93          	mv	s5,a0
	if (!hdr_frag) {
4000df8c:	20050063          	beqz	a0,4000e18c <ethernet_send+0x2f4>
		if (ptype == htons(NET_ETH_PTYPE_ARP) ||
4000df90:	60800793          	li	a5,1544
		hdr = (struct net_eth_hdr *)(hdr_frag->data);
4000df94:	00c52903          	lw	s2,12(a0)
		if (ptype == htons(NET_ETH_PTYPE_ARP) ||
4000df98:	1efa0263          	beq	s4,a5,4000e17c <ethernet_send+0x2e4>
	return pkt->family;
4000df9c:	03442783          	lw	a5,52(s0)
	if (net_pkt_family(pkt) == AF_INET &&
4000dfa0:	00100713          	li	a4,1
4000dfa4:	01d7d793          	srli	a5,a5,0x1d
4000dfa8:	18e79463          	bne	a5,a4,4000e130 <ethernet_send+0x298>
	return pkt->frags->data;
4000dfac:	00842783          	lw	a5,8(s0)
	    net_ipv4_is_addr_mcast((struct in_addr *)NET_IPV4_HDR(pkt)->dst)) {
4000dfb0:	00c7ab83          	lw	s7,12(a5)
4000dfb4:	010b8b93          	addi	s7,s7,16
4000dfb8:	000b8513          	mv	a0,s7
4000dfbc:	8a9ff0ef          	jal	ra,4000d864 <net_ipv4_is_addr_mcast>
	if (net_pkt_family(pkt) == AF_INET &&
4000dfc0:	1a050e63          	beqz	a0,4000e17c <ethernet_send+0x2e4>
		net_eth_ipv4_mcast_to_mac_addr(
4000dfc4:	00090593          	mv	a1,s2
4000dfc8:	000b8513          	mv	a0,s7
4000dfcc:	e95ff0ef          	jal	ra,4000de60 <net_eth_ipv4_mcast_to_mac_addr>
		memcpy(&hdr->src, net_pkt_lladdr_src(pkt)->addr,
4000dfd0:	02442583          	lw	a1,36(s0)
4000dfd4:	00600613          	li	a2,6
4000dfd8:	00690513          	addi	a0,s2,6
4000dfdc:	d1dfe0ef          	jal	ra,4000ccf8 <memcpy>
		hdr->type = ptype;
4000dfe0:	008a5793          	srli	a5,s4,0x8
4000dfe4:	00f906a3          	sb	a5,13(s2)
4000dfe8:	01490623          	sb	s4,12(s2)
	return net_buf_simple_add(&buf->b, len);
4000dfec:	00e00593          	li	a1,14
4000dff0:	00ca8513          	addi	a0,s5,12
4000dff4:	fd4ff0ef          	jal	ra,4000d7c8 <net_buf_simple_add>
	net_pkt_frag_insert(pkt, hdr_frag);
4000dff8:	000a8593          	mv	a1,s5
4000dffc:	00040513          	mv	a0,s0
4000e000:	095090ef          	jal	ra,40017894 <net_pkt_frag_insert>
	net_pkt_cursor_init(pkt);
4000e004:	00040513          	mv	a0,s0
4000e008:	2e9090ef          	jal	ra,40017af0 <net_pkt_cursor_init>
4000e00c:	0009a703          	lw	a4,0(s3)
			      struct net_if *iface,
			      struct net_pkt *pkt)
{
	net_capture_pkt(iface, pkt);

	return send_fn(dev, pkt);
4000e010:	01cb2783          	lw	a5,28(s6)
4000e014:	00040593          	mv	a1,s0
4000e018:	00072503          	lw	a0,0(a4)
4000e01c:	000780e7          	jalr	a5
4000e020:	00050913          	mv	s2,a0
	if (ret != 0) {
4000e024:	18050e63          	beqz	a0,4000e1c0 <ethernet_send+0x328>
4000e028:	0009a783          	lw	a5,0(s3)
4000e02c:	0007a503          	lw	a0,0(a5)
	if (!api->get_stats) {
4000e030:	00852783          	lw	a5,8(a0)
4000e034:	0047a783          	lw	a5,4(a5)
4000e038:	00078c63          	beqz	a5,4000e050 <ethernet_send+0x1b8>
	stats = api->get_stats(net_if_get_device(iface));
4000e03c:	000780e7          	jalr	a5
	if (!stats) {
4000e040:	00050863          	beqz	a0,4000e050 <ethernet_send+0x1b8>
	stats->errors.tx++;
4000e044:	02052783          	lw	a5,32(a0)
4000e048:	00178793          	addi	a5,a5,1
4000e04c:	02f52023          	sw	a5,32(a0)
	buf = pkt->buffer;
4000e050:	00842503          	lw	a0,8(s0)
	pkt->buffer = buf->frags;
4000e054:	00452783          	lw	a5,4(a0)
4000e058:	00f42423          	sw	a5,8(s0)
	buf->frags = NULL;
4000e05c:	00052223          	sw	zero,4(a0)
	net_pkt_frag_unref(buf);
4000e060:	7b0090ef          	jal	ra,40017810 <net_pkt_frag_unref>
		if (IS_ENABLED(CONFIG_NET_ARP) && ptype == htons(NET_ETH_PTYPE_ARP)) {
4000e064:	60800793          	li	a5,1544
4000e068:	12fa1463          	bne	s4,a5,4000e190 <ethernet_send+0x2f8>
			net_pkt_ref(orig_pkt);
4000e06c:	00048513          	mv	a0,s1
4000e070:	744090ef          	jal	ra,400177b4 <net_pkt_ref>
4000e074:	00842783          	lw	a5,8(s0)
			if (net_arp_clear_pending(iface,
4000e078:	00098513          	mv	a0,s3
				(struct in_addr *)NET_IPV4_HDR(pkt)->dst)) {
4000e07c:	00c7a583          	lw	a1,12(a5)
			if (net_arp_clear_pending(iface,
4000e080:	01058593          	addi	a1,a1,16
4000e084:	224010ef          	jal	ra,4000f2a8 <net_arp_clear_pending>
	net_pkt_unref(pkt);
4000e088:	00040513          	mv	a0,s0
4000e08c:	790090ef          	jal	ra,4001781c <net_pkt_unref>
4000e090:	1000006f          	j	4000e190 <ethernet_send+0x2f8>
	return net_if_ipv4_is_addr_bcast(iface, addr);
4000e094:	01040593          	addi	a1,s0,16
4000e098:	00090513          	mv	a0,s2
4000e09c:	7d9040ef          	jal	ra,40013074 <net_if_ipv4_is_addr_bcast>
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
4000e0a0:	ea0518e3          	bnez	a0,4000df50 <ethernet_send+0xb8>
4000e0a4:	0084a783          	lw	a5,8(s1)
	    net_ipv4_is_addr_mcast((struct in_addr *)NET_IPV4_HDR(pkt)->dst)) {
4000e0a8:	00c7a583          	lw	a1,12(a5)
4000e0ac:	01058593          	addi	a1,a1,16
4000e0b0:	00058513          	mv	a0,a1
4000e0b4:	00b12623          	sw	a1,12(sp)
4000e0b8:	facff0ef          	jal	ra,4000d864 <net_ipv4_is_addr_mcast>
	if (ethernet_ipv4_dst_is_broadcast_or_mcast(pkt)) {
4000e0bc:	e8051ae3          	bnez	a0,4000df50 <ethernet_send+0xb8>
		arp_pkt = net_arp_prepare(pkt, (struct in_addr *)NET_IPV4_HDR(pkt)->dst, NULL);
4000e0c0:	00c12583          	lw	a1,12(sp)
4000e0c4:	00000613          	li	a2,0
4000e0c8:	00048513          	mv	a0,s1
4000e0cc:	019000ef          	jal	ra,4000e8e4 <net_arp_prepare>
4000e0d0:	00050413          	mv	s0,a0
		if (!arp_pkt) {
4000e0d4:	0a050c63          	beqz	a0,4000e18c <ethernet_send+0x2f4>
				ptype = htons(NET_ETH_PTYPE_IP);
4000e0d8:	00800a13          	li	s4,8
		if (pkt != arp_pkt) {
4000e0dc:	e6a48ee3          	beq	s1,a0,4000df58 <ethernet_send+0xc0>
			net_pkt_unref(pkt);
4000e0e0:	00048513          	mv	a0,s1
4000e0e4:	738090ef          	jal	ra,4001781c <net_pkt_unref>
	pkt->family = family;
4000e0e8:	03744783          	lbu	a5,55(s0)
4000e0ec:	01f7f793          	andi	a5,a5,31
4000e0f0:	0207e793          	ori	a5,a5,32
4000e0f4:	02f40ba3          	sb	a5,55(s0)
		ptype = htons(NET_ETH_PTYPE_ARP);
4000e0f8:	60800a13          	li	s4,1544
}
4000e0fc:	e5dff06f          	j	4000df58 <ethernet_send+0xc0>
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
4000e100:	00200713          	li	a4,2
4000e104:	00e78e63          	beq	a5,a4,4000e120 <ethernet_send+0x288>
	pkt->family = family;
4000e108:	0375c783          	lbu	a5,55(a1)
}
4000e10c:	00058413          	mv	s0,a1
	pkt->family = family;
4000e110:	01f7f793          	andi	a5,a5,31
4000e114:	0207e793          	ori	a5,a5,32
4000e118:	02f58ba3          	sb	a5,55(a1)
4000e11c:	fddff06f          	j	4000e0f8 <ethernet_send+0x260>
		ptype = htons(NET_ETH_PTYPE_IPV6);
4000e120:	0000ea37          	lui	s4,0xe
4000e124:	00058413          	mv	s0,a1
4000e128:	d86a0a13          	addi	s4,s4,-634 # dd86 <__kernel_ram_size+0x227e>
4000e12c:	e2dff06f          	j	4000df58 <ethernet_send+0xc0>
	if (net_pkt_family(pkt) == AF_INET6 &&
4000e130:	00200713          	li	a4,2
4000e134:	04e79463          	bne	a5,a4,4000e17c <ethernet_send+0x2e4>
	return pkt->frags->data;
4000e138:	00842783          	lw	a5,8(s0)
	return addr->s6_addr[0] == 0xFF;
4000e13c:	00c7a783          	lw	a5,12(a5)
4000e140:	0187c703          	lbu	a4,24(a5)
4000e144:	0ff00793          	li	a5,255
4000e148:	02f71a63          	bne	a4,a5,4000e17c <ethernet_send+0x2e4>
		memcpy(dst, (uint8_t *)multicast_eth_addr.addr,
4000e14c:	400325b7          	lui	a1,0x40032
4000e150:	00200613          	li	a2,2
4000e154:	5f458593          	addi	a1,a1,1524 # 400325f4 <multicast_eth_addr>
4000e158:	00090513          	mv	a0,s2
4000e15c:	b9dfe0ef          	jal	ra,4000ccf8 <memcpy>
4000e160:	00842783          	lw	a5,8(s0)
		memcpy((uint8_t *)dst + 2,
4000e164:	00400613          	li	a2,4
4000e168:	00290513          	addi	a0,s2,2
4000e16c:	00c7a583          	lw	a1,12(a5)
4000e170:	02458593          	addi	a1,a1,36
			memcpy(&hdr->dst, net_pkt_lladdr_dst(pkt)->addr,
4000e174:	b85fe0ef          	jal	ra,4000ccf8 <memcpy>
4000e178:	e59ff06f          	j	4000dfd0 <ethernet_send+0x138>
4000e17c:	02c42583          	lw	a1,44(s0)
4000e180:	00600613          	li	a2,6
4000e184:	00090513          	mv	a0,s2
4000e188:	fedff06f          	j	4000e174 <ethernet_send+0x2dc>
				ret = -ENOMEM;
4000e18c:	ff400913          	li	s2,-12
}
4000e190:	03c12083          	lw	ra,60(sp)
4000e194:	03812403          	lw	s0,56(sp)
4000e198:	03412483          	lw	s1,52(sp)
4000e19c:	02c12983          	lw	s3,44(sp)
4000e1a0:	02812a03          	lw	s4,40(sp)
4000e1a4:	02412a83          	lw	s5,36(sp)
4000e1a8:	02012b03          	lw	s6,32(sp)
4000e1ac:	01c12b83          	lw	s7,28(sp)
4000e1b0:	00090513          	mv	a0,s2
4000e1b4:	03012903          	lw	s2,48(sp)
4000e1b8:	04010113          	addi	sp,sp,64
4000e1bc:	00008067          	ret
	ethernet_update_tx_stats(iface, pkt);
4000e1c0:	00842783          	lw	a5,8(s0)
	size_t bytes = 0;
4000e1c4:	00000913          	li	s2,0
	return pkt->frags->data;
4000e1c8:	00c7a483          	lw	s1,12(a5)
		bytes += buf->len;
4000e1cc:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
4000e1d0:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4000e1d4:	00e90933          	add	s2,s2,a4
	while (buf) {
4000e1d8:	fe079ae3          	bnez	a5,4000e1cc <ethernet_send+0x334>
4000e1dc:	0009a783          	lw	a5,0(s3)
4000e1e0:	0007a503          	lw	a0,0(a5)
	if (!api->get_stats) {
4000e1e4:	00852783          	lw	a5,8(a0)
4000e1e8:	0047a783          	lw	a5,4(a5)
4000e1ec:	00078c63          	beqz	a5,4000e204 <ethernet_send+0x36c>
	stats = api->get_stats(net_if_get_device(iface));
4000e1f0:	000780e7          	jalr	a5
	if (!stats) {
4000e1f4:	00050863          	beqz	a0,4000e204 <ethernet_send+0x36c>
	stats->bytes.sent += bytes;
4000e1f8:	00052783          	lw	a5,0(a0)
4000e1fc:	012787b3          	add	a5,a5,s2
4000e200:	00f52023          	sw	a5,0(a0)
4000e204:	0009a783          	lw	a5,0(s3)
4000e208:	0007a503          	lw	a0,0(a5)
	if (!api->get_stats) {
4000e20c:	00852783          	lw	a5,8(a0)
4000e210:	0047a783          	lw	a5,4(a5)
4000e214:	00078c63          	beqz	a5,4000e22c <ethernet_send+0x394>
	stats = api->get_stats(net_if_get_device(iface));
4000e218:	000780e7          	jalr	a5
	if (!stats) {
4000e21c:	00050863          	beqz	a0,4000e22c <ethernet_send+0x394>
	stats->pkts.tx++;
4000e220:	00852783          	lw	a5,8(a0)
4000e224:	00178793          	addi	a5,a5,1
4000e228:	00f52423          	sw	a5,8(a0)
	if (net_eth_is_addr_multicast(&hdr->dst)) {
4000e22c:	00048513          	mv	a0,s1
4000e230:	f30ff0ef          	jal	ra,4000d960 <net_eth_is_addr_multicast>
4000e234:	04050863          	beqz	a0,4000e284 <ethernet_send+0x3ec>
4000e238:	0009a783          	lw	a5,0(s3)
4000e23c:	0007a503          	lw	a0,0(a5)
	if (!api->get_stats) {
4000e240:	00852783          	lw	a5,8(a0)
4000e244:	0047a783          	lw	a5,4(a5)
4000e248:	00078c63          	beqz	a5,4000e260 <ethernet_send+0x3c8>
	stats = api->get_stats(net_if_get_device(iface));
4000e24c:	000780e7          	jalr	a5
	if (!stats) {
4000e250:	00050863          	beqz	a0,4000e260 <ethernet_send+0x3c8>
	stats->multicast.tx++;
4000e254:	01852783          	lw	a5,24(a0)
4000e258:	00178793          	addi	a5,a5,1
4000e25c:	00f52c23          	sw	a5,24(a0)
	ret = net_pkt_get_len(pkt);
4000e260:	00842503          	lw	a0,8(s0)
	size_t bytes = 0;
4000e264:	00000913          	li	s2,0
4000e268:	00050793          	mv	a5,a0
	while (buf) {
4000e26c:	04079863          	bnez	a5,4000e2bc <ethernet_send+0x424>
	pkt->buffer = buf->frags;
4000e270:	00452783          	lw	a5,4(a0)
4000e274:	00f42423          	sw	a5,8(s0)
	buf->frags = NULL;
4000e278:	00052223          	sw	zero,4(a0)
	net_pkt_frag_unref(buf);
4000e27c:	594090ef          	jal	ra,40017810 <net_pkt_frag_unref>
4000e280:	e09ff06f          	j	4000e088 <ethernet_send+0x1f0>
	} else if (net_eth_is_addr_broadcast(&hdr->dst)) {
4000e284:	00048513          	mv	a0,s1
4000e288:	e8cff0ef          	jal	ra,4000d914 <net_eth_is_addr_broadcast>
4000e28c:	fc050ae3          	beqz	a0,4000e260 <ethernet_send+0x3c8>
4000e290:	0009a783          	lw	a5,0(s3)
4000e294:	0007a503          	lw	a0,0(a5)
	if (!api->get_stats) {
4000e298:	00852783          	lw	a5,8(a0)
4000e29c:	0047a783          	lw	a5,4(a5)
4000e2a0:	fc0780e3          	beqz	a5,4000e260 <ethernet_send+0x3c8>
	stats = api->get_stats(net_if_get_device(iface));
4000e2a4:	000780e7          	jalr	a5
	if (!stats) {
4000e2a8:	fa050ce3          	beqz	a0,4000e260 <ethernet_send+0x3c8>
	stats->broadcast.tx++;
4000e2ac:	01052783          	lw	a5,16(a0)
4000e2b0:	00178793          	addi	a5,a5,1
4000e2b4:	00f52823          	sw	a5,16(a0)
4000e2b8:	fa9ff06f          	j	4000e260 <ethernet_send+0x3c8>
		bytes += buf->len;
4000e2bc:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
4000e2c0:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4000e2c4:	00e90933          	add	s2,s2,a4
		buf = buf->frags;
4000e2c8:	fa5ff06f          	j	4000e26c <ethernet_send+0x3d4>

4000e2cc <ethernet_init>:
			&params, sizeof(struct ethernet_req_params));
}
#endif/* CONFIG_NET_PROMISCUOUS_MODE */

void ethernet_init(struct net_if *iface)
{
4000e2cc:	ff010113          	addi	sp,sp,-16
4000e2d0:	00912223          	sw	s1,4(sp)
4000e2d4:	00112623          	sw	ra,12(sp)
4000e2d8:	00812423          	sw	s0,8(sp)
	return iface->if_dev->l2_data;
4000e2dc:	00052783          	lw	a5,0(a0)

	NET_DBG("Initializing Ethernet L2 %p for iface %p", ctx, iface);

	ctx->ethernet_l2_flags = NET_L2_MULTICAST;
	ctx->iface = iface;
	k_work_init(&ctx->carrier_work, carrier_on_off);
4000e2e0:	4000e5b7          	lui	a1,0x4000e
{
4000e2e4:	00050493          	mv	s1,a0
4000e2e8:	0087a403          	lw	s0,8(a5)
	ctx->ethernet_l2_flags = NET_L2_MULTICAST;
4000e2ec:	00100793          	li	a5,1
	k_work_init(&ctx->carrier_work, carrier_on_off);
4000e2f0:	9a058593          	addi	a1,a1,-1632 # 4000d9a0 <carrier_on_off>
	ctx->ethernet_l2_flags = NET_L2_MULTICAST;
4000e2f4:	00f40c23          	sb	a5,24(s0)
	ctx->iface = iface;
4000e2f8:	00a42a23          	sw	a0,20(s0)
	k_work_init(&ctx->carrier_work, carrier_on_off);
4000e2fc:	00440513          	addi	a0,s0,4
4000e300:	3f1210ef          	jal	ra,4002fef0 <k_work_init>
	return iface->if_dev->dev;
4000e304:	0004a783          	lw	a5,0(s1)
4000e308:	0007a503          	lw	a0,0(a5)
enum ethernet_hw_caps net_eth_get_hw_capabilities(struct net_if *iface)
{
	const struct ethernet_api *eth =
		(struct ethernet_api *)net_if_get_device(iface)->api;

	if (!eth->get_capabilities) {
4000e30c:	00852783          	lw	a5,8(a0)
4000e310:	0107a783          	lw	a5,16(a5)
4000e314:	00078e63          	beqz	a5,4000e330 <ethernet_init+0x64>
		return (enum ethernet_hw_caps)0;
	}

	return eth->get_capabilities(net_if_get_device(iface));
4000e318:	000780e7          	jalr	a5

	if (net_eth_get_hw_capabilities(iface) & ETHERNET_PROMISC_MODE) {
4000e31c:	40057513          	andi	a0,a0,1024
4000e320:	00050863          	beqz	a0,4000e330 <ethernet_init+0x64>
		ctx->ethernet_l2_flags |= NET_L2_PROMISC_MODE;
4000e324:	01844783          	lbu	a5,24(s0)
4000e328:	0047e793          	ori	a5,a5,4
4000e32c:	00f40c23          	sb	a5,24(s0)
			break;
		}
	}
#endif

	net_arp_init();
4000e330:	034010ef          	jal	ra,4000f364 <net_arp_init>

	ctx->is_init = true;
4000e334:	01944783          	lbu	a5,25(s0)
4000e338:	0027e793          	ori	a5,a5,2
4000e33c:	00f40ca3          	sb	a5,25(s0)
}
4000e340:	00c12083          	lw	ra,12(sp)
4000e344:	00812403          	lw	s0,8(sp)
4000e348:	00412483          	lw	s1,4(sp)
4000e34c:	01010113          	addi	sp,sp,16
4000e350:	00008067          	ret

4000e354 <sys_slist_prepend>:
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
4000e354:	00052783          	lw	a5,0(a0)
	parent->next = child;
4000e358:	00f5a023          	sw	a5,0(a1)
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node);

Z_GENLIST_PREPEND(slist, snode)
4000e35c:	00452783          	lw	a5,4(a0)
	list->head = node;
4000e360:	00b52023          	sw	a1,0(a0)
Z_GENLIST_PREPEND(slist, snode)
4000e364:	00079463          	bnez	a5,4000e36c <sys_slist_prepend+0x18>
	list->tail = node;
4000e368:	00b52223          	sw	a1,4(a0)
Z_GENLIST_PREPEND(slist, snode)
4000e36c:	00008067          	ret

4000e370 <sys_slist_remove>:
	return node->next;
4000e370:	00062783          	lw	a5,0(a2)
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
4000e374:	00059e63          	bnez	a1,4000e390 <sys_slist_remove+0x20>
4000e378:	00452703          	lw	a4,4(a0)
	list->head = node;
4000e37c:	00f52023          	sw	a5,0(a0)
Z_GENLIST_REMOVE(slist, snode)
4000e380:	00e61463          	bne	a2,a4,4000e388 <sys_slist_remove+0x18>
	list->tail = node;
4000e384:	00f52223          	sw	a5,4(a0)
	parent->next = child;
4000e388:	00062023          	sw	zero,0(a2)
Z_GENLIST_REMOVE(slist, snode)
4000e38c:	00008067          	ret
	parent->next = child;
4000e390:	00f5a023          	sw	a5,0(a1)
Z_GENLIST_REMOVE(slist, snode)
4000e394:	00452783          	lw	a5,4(a0)
4000e398:	fef618e3          	bne	a2,a5,4000e388 <sys_slist_remove+0x18>
	list->tail = node;
4000e39c:	00b52223          	sw	a1,4(a0)
}
4000e3a0:	fe9ff06f          	j	4000e388 <sys_slist_remove+0x18>

4000e3a4 <k_uptime_get_32>:
 *    @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option
 *
 * @return The low 32 bits of the current uptime, in milliseconds.
 */
static inline uint32_t k_uptime_get_32(void)
{
4000e3a4:	ff010113          	addi	sp,sp,-16
4000e3a8:	00112623          	sw	ra,12(sp)
	return z_impl_k_uptime_ticks();
4000e3ac:	2a8230ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
	return (uint32_t)k_uptime_get();
}
4000e3b0:	00c12083          	lw	ra,12(sp)
4000e3b4:	00a00793          	li	a5,10
4000e3b8:	02a78533          	mul	a0,a5,a0
4000e3bc:	01010113          	addi	sp,sp,16
4000e3c0:	00008067          	ret

4000e3c4 <arp_entry_get_last_from_table>:

	return CONTAINER_OF(node, struct arp_entry, node);
}

static struct arp_entry *arp_entry_get_last_from_table(void)
{
4000e3c4:	ff010113          	addi	sp,sp,-16
	return list->tail;
4000e3c8:	40039537          	lui	a0,0x40039
4000e3cc:	00112623          	sw	ra,12(sp)
4000e3d0:	00812423          	sw	s0,8(sp)
4000e3d4:	02050793          	addi	a5,a0,32 # 40039020 <arp_table>
4000e3d8:	0047a403          	lw	s0,4(a5)
	/* We assume last entry is the oldest one,
	 * so is the preferred one to be taken out.
	 */

	node = sys_slist_peek_tail(&arp_table);
	if (!node) {
4000e3dc:	02040063          	beqz	s0,4000e3fc <arp_entry_get_last_from_table+0x38>
	return list->head;
4000e3e0:	0007a783          	lw	a5,0(a5)
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4000e3e4:	00000593          	li	a1,0
4000e3e8:	00078a63          	beqz	a5,4000e3fc <arp_entry_get_last_from_table+0x38>
4000e3ec:	02f41263          	bne	s0,a5,4000e410 <arp_entry_get_last_from_table+0x4c>
4000e3f0:	00040613          	mv	a2,s0
4000e3f4:	02050513          	addi	a0,a0,32
4000e3f8:	f79ff0ef          	jal	ra,4000e370 <sys_slist_remove>
	}

	sys_slist_find_and_remove(&arp_table, node);

	return CONTAINER_OF(node, struct arp_entry, node);
}
4000e3fc:	00c12083          	lw	ra,12(sp)
4000e400:	00040513          	mv	a0,s0
4000e404:	00812403          	lw	s0,8(sp)
4000e408:	01010113          	addi	sp,sp,16
4000e40c:	00008067          	ret
	return node->next;
4000e410:	00078593          	mv	a1,a5
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4000e414:	0007a783          	lw	a5,0(a5)
4000e418:	fd1ff06f          	j	4000e3e8 <arp_entry_get_last_from_table+0x24>

4000e41c <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
4000e41c:	00058613          	mv	a2,a1
4000e420:	00050593          	mv	a1,a0
	return z_impl_k_mutex_lock(mutex, timeout);
4000e424:	4003a537          	lui	a0,0x4003a
4000e428:	48850513          	addi	a0,a0,1160 # 4003a488 <arp_mutex>
4000e42c:	0102106f          	j	4002f43c <z_impl_k_mutex_lock>

4000e430 <k_mutex_unlock.constprop.0.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
4000e430:	4003a537          	lui	a0,0x4003a
4000e434:	48850513          	addi	a0,a0,1160 # 4003a488 <arp_mutex>
4000e438:	1602106f          	j	4002f598 <z_impl_k_mutex_unlock>

4000e43c <if_get_addr.isra.0>:
					  struct in_addr *addr)
{
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
	int i;

	if (!ipv4) {
4000e43c:	08050663          	beqz	a0,4000e4c8 <if_get_addr.isra.0+0x8c>
		return NULL;
	}

	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
		if (ipv4->unicast[i].is_used &&
4000e440:	02c52783          	lw	a5,44(a0)
4000e444:	00100713          	li	a4,1
4000e448:	0197d793          	srli	a5,a5,0x19
4000e44c:	0017f793          	andi	a5,a5,1
4000e450:	06078a63          	beqz	a5,4000e4c4 <if_get_addr.isra.0+0x88>
4000e454:	00055783          	lhu	a5,0(a0)
4000e458:	06e79663          	bne	a5,a4,4000e4c4 <if_get_addr.isra.0+0x88>
		    ipv4->unicast[i].address.family == AF_INET &&
4000e45c:	02d50703          	lb	a4,45(a0)
4000e460:	06f71263          	bne	a4,a5,4000e4c4 <if_get_addr.isra.0+0x88>
		    ipv4->unicast[i].addr_state == NET_ADDR_PREFERRED &&
4000e464:	04058c63          	beqz	a1,4000e4bc <if_get_addr.isra.0+0x80>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000e468:	0015c703          	lbu	a4,1(a1)
4000e46c:	0005c783          	lbu	a5,0(a1)
4000e470:	00454683          	lbu	a3,4(a0)
4000e474:	00871713          	slli	a4,a4,0x8
4000e478:	00f76733          	or	a4,a4,a5
4000e47c:	0025c783          	lbu	a5,2(a1)
4000e480:	01079793          	slli	a5,a5,0x10
4000e484:	00e7e7b3          	or	a5,a5,a4
4000e488:	0035c703          	lbu	a4,3(a1)
4000e48c:	01871713          	slli	a4,a4,0x18
4000e490:	00f76733          	or	a4,a4,a5
4000e494:	00554783          	lbu	a5,5(a0)
4000e498:	00879793          	slli	a5,a5,0x8
4000e49c:	00d7e7b3          	or	a5,a5,a3
4000e4a0:	00654683          	lbu	a3,6(a0)
4000e4a4:	01069693          	slli	a3,a3,0x10
4000e4a8:	00f6e6b3          	or	a3,a3,a5
4000e4ac:	00754783          	lbu	a5,7(a0)
4000e4b0:	01879793          	slli	a5,a5,0x18
4000e4b4:	00d7e7b3          	or	a5,a5,a3
		    (!addr ||
4000e4b8:	00f71663          	bne	a4,a5,4000e4c4 <if_get_addr.isra.0+0x88>
		     net_ipv4_addr_cmp(addr,
				       &ipv4->unicast[i].address.in_addr))) {
			return &ipv4->unicast[i].address.in_addr;
4000e4bc:	00450513          	addi	a0,a0,4
4000e4c0:	00008067          	ret
		return NULL;
4000e4c4:	00000513          	li	a0,0
		}
	}

	return NULL;
}
4000e4c8:	00008067          	ret

4000e4cc <arp_entry_find.isra.0>:
	SYS_SLIST_FOR_EACH_CONTAINER(list, entry, node) {
4000e4cc:	00051463          	bnez	a0,4000e4d4 <arp_entry_find.isra.0+0x8>
}
4000e4d0:	00008067          	ret
		if (entry->iface == iface &&
4000e4d4:	00852783          	lw	a5,8(a0)
4000e4d8:	04b79c63          	bne	a5,a1,4000e530 <arp_entry_find.isra.0+0x64>
4000e4dc:	00d54703          	lbu	a4,13(a0)
4000e4e0:	00c54783          	lbu	a5,12(a0)
4000e4e4:	00064803          	lbu	a6,0(a2)
4000e4e8:	00871713          	slli	a4,a4,0x8
4000e4ec:	00f76733          	or	a4,a4,a5
4000e4f0:	00e54783          	lbu	a5,14(a0)
4000e4f4:	01079793          	slli	a5,a5,0x10
4000e4f8:	00e7e7b3          	or	a5,a5,a4
4000e4fc:	00f54703          	lbu	a4,15(a0)
4000e500:	01871713          	slli	a4,a4,0x18
4000e504:	00f76733          	or	a4,a4,a5
4000e508:	00164783          	lbu	a5,1(a2)
4000e50c:	00879793          	slli	a5,a5,0x8
4000e510:	0107e7b3          	or	a5,a5,a6
4000e514:	00264803          	lbu	a6,2(a2)
4000e518:	01081813          	slli	a6,a6,0x10
4000e51c:	00f86833          	or	a6,a6,a5
4000e520:	00364783          	lbu	a5,3(a2)
4000e524:	01879793          	slli	a5,a5,0x18
4000e528:	0107e7b3          	or	a5,a5,a6
4000e52c:	faf702e3          	beq	a4,a5,4000e4d0 <arp_entry_find.isra.0+0x4>
		if (previous) {
4000e530:	00068463          	beqz	a3,4000e538 <arp_entry_find.isra.0+0x6c>
			*previous = &entry->node;
4000e534:	00a6a023          	sw	a0,0(a3)
	return node->next;
4000e538:	00052503          	lw	a0,0(a0)
4000e53c:	f91ff06f          	j	4000e4cc <arp_entry_find.isra.0>

4000e540 <arp_update>:
static void arp_update(struct net_if *iface,
		       struct in_addr *src,
		       struct net_eth_addr *hwaddr,
		       bool gratuitous,
		       bool force)
{
4000e540:	fc010113          	addi	sp,sp,-64
4000e544:	02912a23          	sw	s1,52(sp)
4000e548:	03212823          	sw	s2,48(sp)
4000e54c:	03612023          	sw	s6,32(sp)
4000e550:	00050913          	mv	s2,a0
4000e554:	00058493          	mv	s1,a1
	struct arp_entry *entry;
	struct net_pkt *pkt;

	NET_DBG("src %s", net_sprint_ipv4_addr(src));

	k_mutex_lock(&arp_mutex, K_FOREVER);
4000e558:	fff00513          	li	a0,-1
4000e55c:	fff00593          	li	a1,-1
4000e560:	40039b37          	lui	s6,0x40039
{
4000e564:	03312623          	sw	s3,44(sp)
4000e568:	03412423          	sw	s4,40(sp)
4000e56c:	03512223          	sw	s5,36(sp)
4000e570:	01712e23          	sw	s7,28(sp)
4000e574:	02112e23          	sw	ra,60(sp)
4000e578:	02812c23          	sw	s0,56(sp)
4000e57c:	00060993          	mv	s3,a2
4000e580:	00068a93          	mv	s5,a3
4000e584:	00070a13          	mv	s4,a4
	k_mutex_lock(&arp_mutex, K_FOREVER);
4000e588:	e95ff0ef          	jal	ra,4000e41c <k_mutex_lock.constprop.0.isra.0>
	sys_snode_t *prev = NULL;
4000e58c:	028b2b83          	lw	s7,40(s6) # 40039028 <arp_pending_entries>
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
4000e590:	00c10693          	addi	a3,sp,12
4000e594:	00048613          	mv	a2,s1
4000e598:	00090593          	mv	a1,s2
4000e59c:	000b8513          	mv	a0,s7
	sys_snode_t *prev = NULL;
4000e5a0:	00012623          	sw	zero,12(sp)
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
4000e5a4:	f29ff0ef          	jal	ra,4000e4cc <arp_entry_find.isra.0>
	if (entry) {
4000e5a8:	0a051263          	bnez	a0,4000e64c <arp_update+0x10c>
	if (sys_slist_is_empty(&arp_pending_entries)) {
4000e5ac:	000b9863          	bnez	s7,4000e5bc <arp_update+0x7c>
		k_work_cancel_delayable(&arp_request_timer);
4000e5b0:	4003a537          	lui	a0,0x4003a
4000e5b4:	91050513          	addi	a0,a0,-1776 # 40039910 <arp_request_timer>
4000e5b8:	3b5210ef          	jal	ra,4003016c <k_work_cancel_delayable>

	entry = arp_entry_get_pending(iface, src);
	if (!entry) {
		if (IS_ENABLED(CONFIG_NET_ARP_GRATUITOUS) && gratuitous) {
4000e5bc:	020a8863          	beqz	s5,4000e5ec <arp_update+0xac>
	entry = arp_entry_find(&arp_table, iface, src, &prev);
4000e5c0:	400397b7          	lui	a5,0x40039
4000e5c4:	0207a503          	lw	a0,32(a5) # 40039020 <arp_table>
4000e5c8:	00c10693          	addi	a3,sp,12
4000e5cc:	00048613          	mv	a2,s1
4000e5d0:	00090593          	mv	a1,s2
4000e5d4:	ef9ff0ef          	jal	ra,4000e4cc <arp_entry_find.isra.0>
	if (entry) {
4000e5d8:	00050a63          	beqz	a0,4000e5ec <arp_update+0xac>
		memcpy(&entry->eth, hwaddr, sizeof(struct net_eth_addr));
4000e5dc:	00600613          	li	a2,6
4000e5e0:	00098593          	mv	a1,s3
4000e5e4:	01050513          	addi	a0,a0,16
4000e5e8:	f10fe0ef          	jal	ra,4000ccf8 <memcpy>
			arp_gratuitous(iface, src, hwaddr);
		}

		if (force) {
4000e5ec:	020a0a63          	beqz	s4,4000e620 <arp_update+0xe0>
			sys_snode_t *prev = NULL;
			struct arp_entry *entry;

			entry = arp_entry_find(&arp_table, iface, src, &prev);
4000e5f0:	40039a37          	lui	s4,0x40039
4000e5f4:	020a2503          	lw	a0,32(s4) # 40039020 <arp_table>
4000e5f8:	00c10693          	addi	a3,sp,12
4000e5fc:	00048613          	mv	a2,s1
4000e600:	00090593          	mv	a1,s2
			sys_snode_t *prev = NULL;
4000e604:	00012623          	sw	zero,12(sp)
			entry = arp_entry_find(&arp_table, iface, src, &prev);
4000e608:	ec5ff0ef          	jal	ra,4000e4cc <arp_entry_find.isra.0>
			if (entry) {
4000e60c:	0c050463          	beqz	a0,4000e6d4 <arp_update+0x194>
				memcpy(&entry->eth, hwaddr,
4000e610:	00600613          	li	a2,6
4000e614:	00098593          	mv	a1,s3
4000e618:	01050513          	addi	a0,a0,16
4000e61c:	edcfe0ef          	jal	ra,4000ccf8 <memcpy>

		net_if_queue_tx(iface, pkt);
	}

	k_mutex_unlock(&arp_mutex);
}
4000e620:	03812403          	lw	s0,56(sp)
4000e624:	03c12083          	lw	ra,60(sp)
4000e628:	03412483          	lw	s1,52(sp)
4000e62c:	03012903          	lw	s2,48(sp)
4000e630:	02c12983          	lw	s3,44(sp)
4000e634:	02812a03          	lw	s4,40(sp)
4000e638:	02412a83          	lw	s5,36(sp)
4000e63c:	02012b03          	lw	s6,32(sp)
4000e640:	01c12b83          	lw	s7,28(sp)
4000e644:	04010113          	addi	sp,sp,64
		k_mutex_unlock(&arp_mutex);
4000e648:	de9ff06f          	j	4000e430 <k_mutex_unlock.constprop.0.isra.0>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
4000e64c:	00c12583          	lw	a1,12(sp)
4000e650:	00050613          	mv	a2,a0
4000e654:	00050413          	mv	s0,a0
4000e658:	028b0513          	addi	a0,s6,40
4000e65c:	d15ff0ef          	jal	ra,4000e370 <sys_slist_remove>
	if (sys_slist_is_empty(&arp_pending_entries)) {
4000e660:	028b2783          	lw	a5,40(s6)
4000e664:	00079863          	bnez	a5,4000e674 <arp_update+0x134>
		k_work_cancel_delayable(&arp_request_timer);
4000e668:	4003a537          	lui	a0,0x4003a
4000e66c:	91050513          	addi	a0,a0,-1776 # 40039910 <arp_request_timer>
4000e670:	2fd210ef          	jal	ra,4003016c <k_work_cancel_delayable>
	memcpy(&entry->eth, hwaddr, sizeof(struct net_eth_addr));
4000e674:	00098593          	mv	a1,s3
4000e678:	00600613          	li	a2,6
4000e67c:	01040513          	addi	a0,s0,16
4000e680:	e78fe0ef          	jal	ra,4000ccf8 <memcpy>
	sys_slist_prepend(&arp_table, &entry->node);
4000e684:	40039537          	lui	a0,0x40039
4000e688:	00040593          	mv	a1,s0
4000e68c:	02050513          	addi	a0,a0,32 # 40039020 <arp_table>
4000e690:	cc5ff0ef          	jal	ra,4000e354 <sys_slist_prepend>
		pkt = k_fifo_get(&entry->pending_queue, K_FOREVER);
4000e694:	01840493          	addi	s1,s0,24
		net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
4000e698:	00600993          	li	s3,6
	while (!k_fifo_is_empty(&entry->pending_queue)) {
4000e69c:	01842783          	lw	a5,24(s0)
4000e6a0:	f80780e3          	beqz	a5,4000e620 <arp_update+0xe0>
	return z_impl_k_queue_get(queue, timeout);
4000e6a4:	fff00593          	li	a1,-1
4000e6a8:	fff00613          	li	a2,-1
4000e6ac:	00048513          	mv	a0,s1
4000e6b0:	17c210ef          	jal	ra,4002f82c <z_impl_k_queue_get>
4000e6b4:	00852783          	lw	a5,8(a0)
		net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
4000e6b8:	03350823          	sb	s3,48(a0)
4000e6bc:	00050593          	mv	a1,a0
		net_pkt_lladdr_dst(pkt)->addr =
4000e6c0:	00c7a783          	lw	a5,12(a5)
4000e6c4:	02f52623          	sw	a5,44(a0)
		net_if_queue_tx(iface, pkt);
4000e6c8:	00090513          	mv	a0,s2
4000e6cc:	2d8050ef          	jal	ra,400139a4 <net_if_queue_tx>
4000e6d0:	fcdff06f          	j	4000e69c <arp_update+0x15c>
	return list->head;
4000e6d4:	40039537          	lui	a0,0x40039
4000e6d8:	03052403          	lw	s0,48(a0) # 40039030 <arp_free_entries>
	if (!node) {
4000e6dc:	08040263          	beqz	s0,4000e760 <arp_update+0x220>
	sys_slist_remove(&arp_free_entries, NULL, node);
4000e6e0:	00040613          	mv	a2,s0
4000e6e4:	00000593          	li	a1,0
4000e6e8:	03050513          	addi	a0,a0,48
4000e6ec:	c85ff0ef          	jal	ra,4000e370 <sys_slist_remove>
					entry->req_start = k_uptime_get_32();
4000e6f0:	cb5ff0ef          	jal	ra,4000e3a4 <k_uptime_get_32>
4000e6f4:	00a42223          	sw	a0,4(s0)
					entry->iface = iface;
4000e6f8:	01242423          	sw	s2,8(s0)
					net_ipaddr_copy(&entry->ip, src);
4000e6fc:	0014c783          	lbu	a5,1(s1)
4000e700:	0004c703          	lbu	a4,0(s1)
					memcpy(&entry->eth, hwaddr, sizeof(entry->eth));
4000e704:	00098593          	mv	a1,s3
					net_ipaddr_copy(&entry->ip, src);
4000e708:	00879793          	slli	a5,a5,0x8
4000e70c:	00e7e7b3          	or	a5,a5,a4
4000e710:	0024c703          	lbu	a4,2(s1)
					memcpy(&entry->eth, hwaddr, sizeof(entry->eth));
4000e714:	00600613          	li	a2,6
4000e718:	01040513          	addi	a0,s0,16
					net_ipaddr_copy(&entry->ip, src);
4000e71c:	01071713          	slli	a4,a4,0x10
4000e720:	00f76733          	or	a4,a4,a5
4000e724:	0034c783          	lbu	a5,3(s1)
4000e728:	00e40623          	sb	a4,12(s0)
4000e72c:	01879793          	slli	a5,a5,0x18
4000e730:	00e7e7b3          	or	a5,a5,a4
4000e734:	0087d713          	srli	a4,a5,0x8
4000e738:	00e406a3          	sb	a4,13(s0)
4000e73c:	0107d713          	srli	a4,a5,0x10
4000e740:	0187d793          	srli	a5,a5,0x18
4000e744:	00e40723          	sb	a4,14(s0)
4000e748:	00f407a3          	sb	a5,15(s0)
					memcpy(&entry->eth, hwaddr, sizeof(entry->eth));
4000e74c:	dacfe0ef          	jal	ra,4000ccf8 <memcpy>
					sys_slist_prepend(&arp_table, &entry->node);
4000e750:	00040593          	mv	a1,s0
4000e754:	020a0513          	addi	a0,s4,32
4000e758:	bfdff0ef          	jal	ra,4000e354 <sys_slist_prepend>
4000e75c:	ec5ff06f          	j	4000e620 <arp_update+0xe0>
					entry = arp_entry_get_last_from_table();
4000e760:	c65ff0ef          	jal	ra,4000e3c4 <arp_entry_get_last_from_table>
4000e764:	00050413          	mv	s0,a0
				if (entry) {
4000e768:	f80514e3          	bnez	a0,4000e6f0 <arp_update+0x1b0>
4000e76c:	eb5ff06f          	j	4000e620 <arp_update+0xe0>

4000e770 <arp_entry_cleanup>:
{
4000e770:	ff010113          	addi	sp,sp,-16
4000e774:	00812423          	sw	s0,8(sp)
4000e778:	00912223          	sw	s1,4(sp)
4000e77c:	00112623          	sw	ra,12(sp)
4000e780:	00050413          	mv	s0,a0
			pkt = k_fifo_get(&entry->pending_queue, K_FOREVER);
4000e784:	01850493          	addi	s1,a0,24
	if (pending) {
4000e788:	04059663          	bnez	a1,4000e7d4 <arp_entry_cleanup+0x64>
	entry->iface = NULL;
4000e78c:	00042423          	sw	zero,8(s0)
	(void)memset(&entry->ip, 0, sizeof(struct in_addr));
4000e790:	00400613          	li	a2,4
4000e794:	00000593          	li	a1,0
4000e798:	00c40513          	addi	a0,s0,12
4000e79c:	d80fe0ef          	jal	ra,4000cd1c <memset>
	(void)memset(&entry->eth, 0, sizeof(struct net_eth_addr));
4000e7a0:	01040513          	addi	a0,s0,16
}
4000e7a4:	00812403          	lw	s0,8(sp)
4000e7a8:	00c12083          	lw	ra,12(sp)
4000e7ac:	00412483          	lw	s1,4(sp)
	(void)memset(&entry->eth, 0, sizeof(struct net_eth_addr));
4000e7b0:	00600613          	li	a2,6
4000e7b4:	00000593          	li	a1,0
}
4000e7b8:	01010113          	addi	sp,sp,16
	(void)memset(&entry->eth, 0, sizeof(struct net_eth_addr));
4000e7bc:	d60fe06f          	j	4000cd1c <memset>
4000e7c0:	fff00593          	li	a1,-1
4000e7c4:	fff00613          	li	a2,-1
4000e7c8:	00048513          	mv	a0,s1
4000e7cc:	060210ef          	jal	ra,4002f82c <z_impl_k_queue_get>
			net_pkt_unref(pkt);
4000e7d0:	04c090ef          	jal	ra,4001781c <net_pkt_unref>
		while (!k_fifo_is_empty(&entry->pending_queue)) {
4000e7d4:	01842783          	lw	a5,24(s0)
4000e7d8:	fe0794e3          	bnez	a5,4000e7c0 <arp_entry_cleanup+0x50>
4000e7dc:	fb1ff06f          	j	4000e78c <arp_entry_cleanup+0x1c>

4000e7e0 <arp_request_timeout>:
{
4000e7e0:	fe010113          	addi	sp,sp,-32
4000e7e4:	00112e23          	sw	ra,28(sp)
4000e7e8:	00812c23          	sw	s0,24(sp)
4000e7ec:	00912a23          	sw	s1,20(sp)
4000e7f0:	01212823          	sw	s2,16(sp)
4000e7f4:	01412423          	sw	s4,8(sp)
4000e7f8:	01312623          	sw	s3,12(sp)
	uint32_t current = k_uptime_get_32();
4000e7fc:	ba9ff0ef          	jal	ra,4000e3a4 <k_uptime_get_32>
4000e800:	00050493          	mv	s1,a0
	k_mutex_lock(&arp_mutex, K_FOREVER);
4000e804:	fff00593          	li	a1,-1
4000e808:	fff00513          	li	a0,-1
4000e80c:	40039a37          	lui	s4,0x40039
4000e810:	c0dff0ef          	jal	ra,4000e41c <k_mutex_lock.constprop.0.isra.0>
4000e814:	028a2403          	lw	s0,40(s4) # 40039028 <arp_pending_entries>
4000e818:	00000913          	li	s2,0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
4000e81c:	00040463          	beqz	s0,4000e824 <arp_request_timeout+0x44>
	return node->next;
4000e820:	00042903          	lw	s2,0(s0)
			    ARP_REQUEST_TIMEOUT - current) > 0) {
4000e824:	7d000993          	li	s3,2000
4000e828:	409989b3          	sub	s3,s3,s1
	return list->tail;
4000e82c:	400394b7          	lui	s1,0x40039
4000e830:	03048493          	addi	s1,s1,48 # 40039030 <arp_free_entries>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
4000e834:	02041263          	bnez	s0,4000e858 <arp_request_timeout+0x78>
}
4000e838:	01812403          	lw	s0,24(sp)
4000e83c:	01c12083          	lw	ra,28(sp)
4000e840:	01412483          	lw	s1,20(sp)
4000e844:	01012903          	lw	s2,16(sp)
4000e848:	00c12983          	lw	s3,12(sp)
4000e84c:	00812a03          	lw	s4,8(sp)
4000e850:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&arp_mutex);
4000e854:	bddff06f          	j	4000e430 <k_mutex_unlock.constprop.0.isra.0>
			    ARP_REQUEST_TIMEOUT - current) > 0) {
4000e858:	00442583          	lw	a1,4(s0)
4000e85c:	00b985b3          	add	a1,s3,a1
		if ((int32_t)(entry->req_start +
4000e860:	04b04c63          	bgtz	a1,4000e8b8 <arp_request_timeout+0xd8>
		arp_entry_cleanup(entry, true);
4000e864:	00100593          	li	a1,1
4000e868:	00040513          	mv	a0,s0
4000e86c:	f05ff0ef          	jal	ra,4000e770 <arp_entry_cleanup>
		sys_slist_remove(&arp_pending_entries, NULL, &entry->node);
4000e870:	00040613          	mv	a2,s0
4000e874:	00000593          	li	a1,0
4000e878:	028a0513          	addi	a0,s4,40
4000e87c:	af5ff0ef          	jal	ra,4000e370 <sys_slist_remove>
	parent->next = child;
4000e880:	00042023          	sw	zero,0(s0)
	return list->tail;
4000e884:	0044a783          	lw	a5,4(s1)
Z_GENLIST_APPEND(slist, snode)
4000e888:	02079263          	bnez	a5,4000e8ac <arp_request_timeout+0xcc>
	list->tail = node;
4000e88c:	0084a223          	sw	s0,4(s1)
	list->head = node;
4000e890:	0084a023          	sw	s0,0(s1)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
4000e894:	00000793          	li	a5,0
4000e898:	00090463          	beqz	s2,4000e8a0 <arp_request_timeout+0xc0>
	return node->next;
4000e89c:	00092783          	lw	a5,0(s2)
4000e8a0:	00090413          	mv	s0,s2
4000e8a4:	00078913          	mv	s2,a5
4000e8a8:	f8dff06f          	j	4000e834 <arp_request_timeout+0x54>
	parent->next = child;
4000e8ac:	0087a023          	sw	s0,0(a5)
	list->tail = node;
4000e8b0:	0084a223          	sw	s0,4(s1)
}
4000e8b4:	fe1ff06f          	j	4000e894 <arp_request_timeout+0xb4>
		t += off;
4000e8b8:	00958513          	addi	a0,a1,9
			return t / ((uint64_t)from_hz / to_hz);
4000e8bc:	00a00613          	li	a2,10
4000e8c0:	00000693          	li	a3,0
4000e8c4:	00b535b3          	sltu	a1,a0,a1
4000e8c8:	9f1f10ef          	jal	ra,400002b8 <__udivdi3>
		k_work_reschedule(&arp_request_timer,
4000e8cc:	00058613          	mv	a2,a1
4000e8d0:	00050593          	mv	a1,a0
4000e8d4:	4003a537          	lui	a0,0x4003a
4000e8d8:	91050513          	addi	a0,a0,-1776 # 40039910 <arp_request_timer>
4000e8dc:	079210ef          	jal	ra,40030154 <k_work_reschedule>
4000e8e0:	f59ff06f          	j	4000e838 <arp_request_timeout+0x58>

4000e8e4 <net_arp_prepare>:
{
4000e8e4:	fb010113          	addi	sp,sp,-80
4000e8e8:	04812423          	sw	s0,72(sp)
4000e8ec:	04112623          	sw	ra,76(sp)
4000e8f0:	04912223          	sw	s1,68(sp)
4000e8f4:	05212023          	sw	s2,64(sp)
4000e8f8:	03312e23          	sw	s3,60(sp)
4000e8fc:	03412c23          	sw	s4,56(sp)
4000e900:	03512a23          	sw	s5,52(sp)
4000e904:	03612823          	sw	s6,48(sp)
4000e908:	03712623          	sw	s7,44(sp)
4000e90c:	03812423          	sw	s8,40(sp)
4000e910:	05010413          	addi	s0,sp,80
	if (!pkt || !pkt->buffer) {
4000e914:	04051063          	bnez	a0,4000e954 <net_arp_prepare+0x70>
		return NULL;
4000e918:	00000a13          	li	s4,0
}
4000e91c:	fb040113          	addi	sp,s0,-80
4000e920:	04c12083          	lw	ra,76(sp)
4000e924:	000a0513          	mv	a0,s4
4000e928:	04812403          	lw	s0,72(sp)
4000e92c:	04412483          	lw	s1,68(sp)
4000e930:	04012903          	lw	s2,64(sp)
4000e934:	03c12983          	lw	s3,60(sp)
4000e938:	03812a03          	lw	s4,56(sp)
4000e93c:	03412a83          	lw	s5,52(sp)
4000e940:	03012b03          	lw	s6,48(sp)
4000e944:	02c12b83          	lw	s7,44(sp)
4000e948:	02812c03          	lw	s8,40(sp)
4000e94c:	05010113          	addi	sp,sp,80
4000e950:	00008067          	ret
	if (!pkt || !pkt->buffer) {
4000e954:	00852783          	lw	a5,8(a0)
4000e958:	00050993          	mv	s3,a0
4000e95c:	fa078ee3          	beqz	a5,4000e918 <net_arp_prepare+0x34>
4000e960:	00058a93          	mv	s5,a1
4000e964:	00060b13          	mv	s6,a2
	if (!current_ip && !is_ipv4_ll_used &&
4000e968:	0a061063          	bnez	a2,4000ea08 <net_arp_prepare+0x124>
	    !net_if_ipv4_addr_mask_cmp(net_pkt_iface(pkt), request_ip)) {
4000e96c:	01852503          	lw	a0,24(a0)
4000e970:	5e0040ef          	jal	ra,40012f50 <net_if_ipv4_addr_mask_cmp>
	if (!current_ip && !is_ipv4_ll_used &&
4000e974:	08051a63          	bnez	a0,4000ea08 <net_arp_prepare+0x124>
	return pkt->iface;
4000e978:	0189a583          	lw	a1,24(s3)
		struct net_if_ipv4 *ipv4 = net_pkt_iface(pkt)->config.ip.ipv4;
4000e97c:	0c05a783          	lw	a5,192(a1)
		if (ipv4) {
4000e980:	08078463          	beqz	a5,4000ea08 <net_arp_prepare+0x124>
	return UNALIGNED_GET(&addr->s_addr) == 0;
4000e984:	0497c683          	lbu	a3,73(a5)
4000e988:	0487c703          	lbu	a4,72(a5)
			addr = &ipv4->gw;
4000e98c:	04878a93          	addi	s5,a5,72
4000e990:	00869693          	slli	a3,a3,0x8
4000e994:	00e6e6b3          	or	a3,a3,a4
4000e998:	04a7c703          	lbu	a4,74(a5)
4000e99c:	04b7c783          	lbu	a5,75(a5)
4000e9a0:	01071713          	slli	a4,a4,0x10
4000e9a4:	00d76733          	or	a4,a4,a3
4000e9a8:	01879793          	slli	a5,a5,0x18
4000e9ac:	00e7e7b3          	or	a5,a5,a4
			if (net_ipv4_is_addr_unspecified(addr)) {
4000e9b0:	04079c63          	bnez	a5,4000ea08 <net_arp_prepare+0x124>
				NET_ERR("Gateway not set for iface %p",
4000e9b4:	40044537          	lui	a0,0x40044
4000e9b8:	74452783          	lw	a5,1860(a0) # 40044744 <log_dynamic_net_arp>
4000e9bc:	0077f793          	andi	a5,a5,7
4000e9c0:	f4078ce3          	beqz	a5,4000e918 <net_arp_prepare+0x34>
4000e9c4:	00010493          	mv	s1,sp
4000e9c8:	fe010113          	addi	sp,sp,-32
4000e9cc:	00010613          	mv	a2,sp
4000e9d0:	400357b7          	lui	a5,0x40035
4000e9d4:	99478793          	addi	a5,a5,-1644 # 40034994 <net_buf_fixed_cb+0x34>
4000e9d8:	00f62a23          	sw	a5,20(a2)
4000e9dc:	00300793          	li	a5,3
4000e9e0:	00b62c23          	sw	a1,24(a2)
4000e9e4:	00f62823          	sw	a5,16(a2)
4000e9e8:	000025b7          	lui	a1,0x2
4000e9ec:	00000693          	li	a3,0
4000e9f0:	01060613          	addi	a2,a2,16
4000e9f4:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
4000e9f8:	74450513          	addi	a0,a0,1860
4000e9fc:	d98f60ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
4000ea00:	00048113          	mv	sp,s1
4000ea04:	f15ff06f          	j	4000e918 <net_arp_prepare+0x34>
	k_mutex_lock(&arp_mutex, K_FOREVER);
4000ea08:	fff00513          	li	a0,-1
4000ea0c:	fff00593          	li	a1,-1
4000ea10:	40039937          	lui	s2,0x40039
4000ea14:	a09ff0ef          	jal	ra,4000e41c <k_mutex_lock.constprop.0.isra.0>
4000ea18:	02092a03          	lw	s4,32(s2) # 40039020 <arp_table>
4000ea1c:	0189a583          	lw	a1,24(s3)
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
4000ea20:	fcc40693          	addi	a3,s0,-52
4000ea24:	000a8613          	mv	a2,s5
4000ea28:	000a0513          	mv	a0,s4
4000ea2c:	fab42e23          	sw	a1,-68(s0)
	sys_snode_t *prev = NULL;
4000ea30:	fc042623          	sw	zero,-52(s0)
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
4000ea34:	a99ff0ef          	jal	ra,4000e4cc <arp_entry_find.isra.0>
	if (entry) {
4000ea38:	fbc42583          	lw	a1,-68(s0)
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
4000ea3c:	00050493          	mv	s1,a0
	if (entry) {
4000ea40:	22051e63          	bnez	a0,4000ec7c <net_arp_prepare+0x398>
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
4000ea44:	40039bb7          	lui	s7,0x40039
4000ea48:	028ba503          	lw	a0,40(s7) # 40039028 <arp_pending_entries>
4000ea4c:	00000693          	li	a3,0
4000ea50:	000a8613          	mv	a2,s5
4000ea54:	a79ff0ef          	jal	ra,4000e4cc <arp_entry_find.isra.0>
4000ea58:	00050913          	mv	s2,a0
		if (!entry) {
4000ea5c:	26051e63          	bnez	a0,4000ecd8 <net_arp_prepare+0x3f4>
	return list->head;
4000ea60:	40039537          	lui	a0,0x40039
4000ea64:	03052483          	lw	s1,48(a0) # 40039030 <arp_free_entries>
	if (!node) {
4000ea68:	26048263          	beqz	s1,4000eccc <net_arp_prepare+0x3e8>
	sys_slist_remove(&arp_free_entries, NULL, node);
4000ea6c:	00048613          	mv	a2,s1
4000ea70:	00000593          	li	a1,0
4000ea74:	03050513          	addi	a0,a0,48
4000ea78:	8f9ff0ef          	jal	ra,4000e370 <sys_slist_remove>
4000ea7c:	0189ac03          	lw	s8,24(s3)
	if (current_ip) {
4000ea80:	00098a13          	mv	s4,s3
4000ea84:	020b1463          	bnez	s6,4000eaac <net_arp_prepare+0x1c8>
		pkt = net_pkt_alloc_with_buffer(iface,
4000ea88:	00a00713          	li	a4,10
4000ea8c:	00000793          	li	a5,0
4000ea90:	00000693          	li	a3,0
4000ea94:	00000613          	li	a2,0
4000ea98:	01c00593          	li	a1,28
4000ea9c:	000c0513          	mv	a0,s8
4000eaa0:	5e8090ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
4000eaa4:	00050a13          	mv	s4,a0
		if (!pkt) {
4000eaa8:	1c050663          	beqz	a0,4000ec74 <net_arp_prepare+0x390>
	return net_buf_simple_add(&buf->b, len);
4000eaac:	008a2503          	lw	a0,8(s4)
4000eab0:	01c00593          	li	a1,28
4000eab4:	00c50513          	addi	a0,a0,12
4000eab8:	d11fe0ef          	jal	ra,4000d7c8 <net_buf_simple_add>
	return pkt->frags->data;
4000eabc:	008a2783          	lw	a5,8(s4)
4000eac0:	00c7a903          	lw	s2,12(a5)
	if (entry) {
4000eac4:	24048063          	beqz	s1,4000ed04 <net_arp_prepare+0x420>
			k_fifo_put(&entry->pending_queue, net_pkt_ref(pending));
4000eac8:	00098513          	mv	a0,s3
4000eacc:	4e9080ef          	jal	ra,400177b4 <net_pkt_ref>
4000ead0:	00050593          	mv	a1,a0
4000ead4:	01848513          	addi	a0,s1,24
4000ead8:	52d200ef          	jal	ra,4002f804 <k_queue_append>
	return pkt->iface;
4000eadc:	018a2683          	lw	a3,24(s4)
		entry->iface = net_pkt_iface(pkt);
4000eae0:	00d4a423          	sw	a3,8(s1)
		net_ipaddr_copy(&entry->ip, next_addr);
4000eae4:	001ac783          	lbu	a5,1(s5)
4000eae8:	000ac703          	lbu	a4,0(s5)
4000eaec:	00879793          	slli	a5,a5,0x8
4000eaf0:	00e7e7b3          	or	a5,a5,a4
4000eaf4:	002ac703          	lbu	a4,2(s5)
4000eaf8:	01071713          	slli	a4,a4,0x10
4000eafc:	00f76733          	or	a4,a4,a5
4000eb00:	003ac783          	lbu	a5,3(s5)
4000eb04:	00e48623          	sb	a4,12(s1)
4000eb08:	01879793          	slli	a5,a5,0x18
4000eb0c:	00e7e7b3          	or	a5,a5,a4
4000eb10:	0087d713          	srli	a4,a5,0x8
4000eb14:	00e486a3          	sb	a4,13(s1)
4000eb18:	0107d713          	srli	a4,a5,0x10
4000eb1c:	0187d793          	srli	a5,a5,0x18
4000eb20:	00e48723          	sb	a4,14(s1)
4000eb24:	00f487a3          	sb	a5,15(s1)
			(uint8_t *)net_if_get_link_addr(entry->iface)->addr;
4000eb28:	0006a783          	lw	a5,0(a3)
4000eb2c:	0107a783          	lw	a5,16(a5)
		net_pkt_lladdr_src(pkt)->addr =
4000eb30:	02fa2223          	sw	a5,36(s4)
	parent->next = child;
4000eb34:	0004a023          	sw	zero,0(s1)
	return list->tail;
4000eb38:	028b8793          	addi	a5,s7,40
4000eb3c:	0047a703          	lw	a4,4(a5)
Z_GENLIST_APPEND(slist, snode)
4000eb40:	1a071c63          	bnez	a4,4000ecf8 <net_arp_prepare+0x414>
	list->tail = node;
4000eb44:	0097a223          	sw	s1,4(a5)
	list->head = node;
4000eb48:	0097a023          	sw	s1,0(a5)
	entry->req_start = k_uptime_get_32();
4000eb4c:	859ff0ef          	jal	ra,4000e3a4 <k_uptime_get_32>
4000eb50:	00a4a223          	sw	a0,4(s1)
}

static inline k_ticks_t k_work_delayable_remaining_get(
	const struct k_work_delayable *dwork)
{
	return z_timeout_remaining(&dwork->timeout);
4000eb54:	4003a537          	lui	a0,0x4003a
4000eb58:	92050513          	addi	a0,a0,-1760 # 40039920 <arp_request_timer+0x10>
4000eb5c:	12d220ef          	jal	ra,40031488 <z_timeout_remaining>
	if (!k_work_delayable_remaining_get(&arp_request_timer)) {
4000eb60:	00b56533          	or	a0,a0,a1
4000eb64:	00051c63          	bnez	a0,4000eb7c <net_arp_prepare+0x298>
		k_work_reschedule(&arp_request_timer,
4000eb68:	4003a537          	lui	a0,0x4003a
4000eb6c:	0c800593          	li	a1,200
4000eb70:	00000613          	li	a2,0
4000eb74:	91050513          	addi	a0,a0,-1776 # 40039910 <arp_request_timer>
4000eb78:	5dc210ef          	jal	ra,40030154 <k_work_reschedule>
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
4000eb7c:	00600b93          	li	s7,6
4000eb80:	037a0423          	sb	s7,40(s4)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)net_eth_broadcast_addr();
4000eb84:	ad0ff0ef          	jal	ra,4000de54 <net_eth_broadcast_addr>
4000eb88:	02aa2623          	sw	a0,44(s4)
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
4000eb8c:	037a0823          	sb	s7,48(s4)
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
4000eb90:	00800713          	li	a4,8
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
4000eb94:	00100793          	li	a5,1
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
4000eb98:	00e90123          	sb	a4,2(s2)
	hdr->protolen = sizeof(struct in_addr);
4000eb9c:	00400713          	li	a4,4
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
4000eba0:	00f900a3          	sb	a5,1(s2)
	hdr->protolen = sizeof(struct in_addr);
4000eba4:	00e902a3          	sb	a4,5(s2)
	hdr->opcode = htons(NET_ARP_REQUEST);
4000eba8:	00f903a3          	sb	a5,7(s2)
	(void)memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
4000ebac:	00600613          	li	a2,6
4000ebb0:	00000593          	li	a1,0
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
4000ebb4:	00090023          	sb	zero,0(s2)
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
4000ebb8:	000901a3          	sb	zero,3(s2)
	hdr->hwlen = sizeof(struct net_eth_addr);
4000ebbc:	01790223          	sb	s7,4(s2)
	hdr->opcode = htons(NET_ARP_REQUEST);
4000ebc0:	00090323          	sb	zero,6(s2)
	(void)memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
4000ebc4:	01290513          	addi	a0,s2,18
4000ebc8:	954fe0ef          	jal	ra,4000cd1c <memset>
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
4000ebcc:	001ac783          	lbu	a5,1(s5)
4000ebd0:	000ac703          	lbu	a4,0(s5)
	memcpy(hdr->src_hwaddr.addr, net_pkt_lladdr_src(pkt)->addr,
4000ebd4:	00600613          	li	a2,6
4000ebd8:	00879793          	slli	a5,a5,0x8
4000ebdc:	00e7e7b3          	or	a5,a5,a4
4000ebe0:	002ac703          	lbu	a4,2(s5)
4000ebe4:	00890513          	addi	a0,s2,8
4000ebe8:	01071713          	slli	a4,a4,0x10
4000ebec:	00f76733          	or	a4,a4,a5
4000ebf0:	003ac783          	lbu	a5,3(s5)
4000ebf4:	00e90c23          	sb	a4,24(s2)
4000ebf8:	01879793          	slli	a5,a5,0x18
4000ebfc:	00e7e7b3          	or	a5,a5,a4
4000ec00:	0087d713          	srli	a4,a5,0x8
4000ec04:	00e90ca3          	sb	a4,25(s2)
4000ec08:	0107d713          	srli	a4,a5,0x10
4000ec0c:	0187d793          	srli	a5,a5,0x18
4000ec10:	00e90d23          	sb	a4,26(s2)
4000ec14:	00f90da3          	sb	a5,27(s2)
4000ec18:	024a2583          	lw	a1,36(s4)
4000ec1c:	8dcfe0ef          	jal	ra,4000ccf8 <memcpy>
	} else if (!entry) {
4000ec20:	0e049a63          	bnez	s1,4000ed14 <net_arp_prepare+0x430>
	return pkt->frags->data;
4000ec24:	0089a783          	lw	a5,8(s3)
		my_addr = (struct in_addr *)NET_IPV4_HDR(pending)->src;
4000ec28:	00c7a503          	lw	a0,12(a5)
4000ec2c:	00c50513          	addi	a0,a0,12
4000ec30:	00154783          	lbu	a5,1(a0)
4000ec34:	00054703          	lbu	a4,0(a0)
4000ec38:	00879793          	slli	a5,a5,0x8
4000ec3c:	00e7e7b3          	or	a5,a5,a4
4000ec40:	00254703          	lbu	a4,2(a0)
4000ec44:	01071713          	slli	a4,a4,0x10
4000ec48:	00f76733          	or	a4,a4,a5
4000ec4c:	00354783          	lbu	a5,3(a0)
4000ec50:	00e90723          	sb	a4,14(s2)
4000ec54:	01879793          	slli	a5,a5,0x18
4000ec58:	00e7e7b3          	or	a5,a5,a4
4000ec5c:	0087d713          	srli	a4,a5,0x8
4000ec60:	00e907a3          	sb	a4,15(s2)
4000ec64:	0107d713          	srli	a4,a5,0x10
4000ec68:	0187d793          	srli	a5,a5,0x18
4000ec6c:	00e90823          	sb	a4,16(s2)
4000ec70:	00f908a3          	sb	a5,17(s2)
		k_mutex_unlock(&arp_mutex);
4000ec74:	fbcff0ef          	jal	ra,4000e430 <k_mutex_unlock.constprop.0.isra.0>
		return req;
4000ec78:	ca5ff06f          	j	4000e91c <net_arp_prepare+0x38>
		if (&entry->node != sys_slist_peek_head(&arp_table)) {
4000ec7c:	03450063          	beq	a0,s4,4000ec9c <net_arp_prepare+0x3b8>
			sys_slist_remove(&arp_table, prev, &entry->node);
4000ec80:	fcc42583          	lw	a1,-52(s0)
4000ec84:	00050613          	mv	a2,a0
4000ec88:	02090513          	addi	a0,s2,32
4000ec8c:	ee4ff0ef          	jal	ra,4000e370 <sys_slist_remove>
			sys_slist_prepend(&arp_table, &entry->node);
4000ec90:	00048593          	mv	a1,s1
4000ec94:	02090513          	addi	a0,s2,32
4000ec98:	ebcff0ef          	jal	ra,4000e354 <sys_slist_prepend>
	k_mutex_unlock(&arp_mutex);
4000ec9c:	f94ff0ef          	jal	ra,4000e430 <k_mutex_unlock.constprop.0.isra.0>
	return &iface->if_dev->link_addr;
4000eca0:	0084a783          	lw	a5,8(s1)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)&entry->eth;
4000eca4:	01048493          	addi	s1,s1,16
	return pkt;
4000eca8:	00098a13          	mv	s4,s3
		(uint8_t *)net_if_get_link_addr(entry->iface)->addr;
4000ecac:	0007a783          	lw	a5,0(a5)
4000ecb0:	0107a783          	lw	a5,16(a5)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)&entry->eth;
4000ecb4:	0299a623          	sw	s1,44(s3)
	net_pkt_lladdr_src(pkt)->addr =
4000ecb8:	02f9a223          	sw	a5,36(s3)
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
4000ecbc:	00600793          	li	a5,6
4000ecc0:	02f98423          	sb	a5,40(s3)
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
4000ecc4:	02f98823          	sb	a5,48(s3)
	return pkt;
4000ecc8:	c55ff06f          	j	4000e91c <net_arp_prepare+0x38>
				entry = arp_entry_get_last_from_table();
4000eccc:	ef8ff0ef          	jal	ra,4000e3c4 <arp_entry_get_last_from_table>
4000ecd0:	00050493          	mv	s1,a0
4000ecd4:	da9ff06f          	j	4000ea7c <net_arp_prepare+0x198>
						  net_pkt_ref(pkt))) {
4000ecd8:	00098513          	mv	a0,s3
4000ecdc:	2d9080ef          	jal	ra,400177b4 <net_pkt_ref>
4000ece0:	00050593          	mv	a1,a0
			    k_queue_unique_append(&entry->pending_queue._queue,
4000ece4:	01890513          	addi	a0,s2,24
4000ece8:	3dd200ef          	jal	ra,4002f8c4 <k_queue_unique_append>
			if (!net_pkt_ipv4_auto(pkt) &&
4000ecec:	d80508e3          	beqz	a0,4000ea7c <net_arp_prepare+0x198>
				k_mutex_unlock(&arp_mutex);
4000ecf0:	f40ff0ef          	jal	ra,4000e430 <k_mutex_unlock.constprop.0.isra.0>
				return NULL;
4000ecf4:	c25ff06f          	j	4000e918 <net_arp_prepare+0x34>
	parent->next = child;
4000ecf8:	00972023          	sw	s1,0(a4)
	list->tail = node;
4000ecfc:	0097a223          	sw	s1,4(a5)
}
4000ed00:	e4dff06f          	j	4000eb4c <net_arp_prepare+0x268>
			(uint8_t *)net_if_get_link_addr(iface)->addr;
4000ed04:	000c2783          	lw	a5,0(s8)
4000ed08:	0107a783          	lw	a5,16(a5)
		net_pkt_lladdr_src(pkt)->addr =
4000ed0c:	02fa2223          	sw	a5,36(s4)
4000ed10:	e6dff06f          	j	4000eb7c <net_arp_prepare+0x298>
		my_addr = if_get_addr(entry->iface, current_ip);
4000ed14:	0084a783          	lw	a5,8(s1)
4000ed18:	000b0593          	mv	a1,s6
4000ed1c:	0c07a503          	lw	a0,192(a5)
4000ed20:	f1cff0ef          	jal	ra,4000e43c <if_get_addr.isra.0>
	if (my_addr) {
4000ed24:	f00516e3          	bnez	a0,4000ec30 <net_arp_prepare+0x34c>
		(void)memset(&hdr->src_ipaddr, 0, sizeof(struct in_addr));
4000ed28:	00400613          	li	a2,4
4000ed2c:	00000593          	li	a1,0
4000ed30:	00e90513          	addi	a0,s2,14
4000ed34:	fe9fd0ef          	jal	ra,4000cd1c <memset>
4000ed38:	f3dff06f          	j	4000ec74 <net_arp_prepare+0x390>

4000ed3c <net_arp_input>:
	return true;
}

enum net_verdict net_arp_input(struct net_pkt *pkt,
			       struct net_eth_hdr *eth_hdr)
{
4000ed3c:	fc010113          	addi	sp,sp,-64
4000ed40:	02912a23          	sw	s1,52(sp)
4000ed44:	03212823          	sw	s2,48(sp)
4000ed48:	02112e23          	sw	ra,60(sp)
4000ed4c:	02812c23          	sw	s0,56(sp)
4000ed50:	03312623          	sw	s3,44(sp)
4000ed54:	03412423          	sw	s4,40(sp)
4000ed58:	03512223          	sw	s5,36(sp)
4000ed5c:	03612023          	sw	s6,32(sp)
4000ed60:	01712e23          	sw	s7,28(sp)
4000ed64:	00852683          	lw	a3,8(a0)
4000ed68:	00050493          	mv	s1,a0
4000ed6c:	00058913          	mv	s2,a1
4000ed70:	00068793          	mv	a5,a3
	size_t bytes = 0;
4000ed74:	00000713          	li	a4,0
	while (buf) {
4000ed78:	04079263          	bnez	a5,4000edbc <net_arp_input+0x80>
4000ed7c:	00c6a403          	lw	s0,12(a3)
	struct net_eth_addr *dst_hw_addr;
	struct net_arp_hdr *arp_hdr;
	struct net_pkt *reply;
	struct in_addr *addr;

	if (net_pkt_get_len(pkt) < (sizeof(struct net_arp_hdr) -
4000ed80:	408907b3          	sub	a5,s2,s0
4000ed84:	01c78793          	addi	a5,a5,28
4000ed88:	04f77263          	bgeu	a4,a5,4000edcc <net_arp_input+0x90>
				    (net_pkt_ip_data(pkt) - (uint8_t *)eth_hdr))) {
		NET_DBG("Invalid ARP header (len %zu, min %zu bytes) %p",
			net_pkt_get_len(pkt), sizeof(struct net_arp_hdr) -
			(net_pkt_ip_data(pkt) - (uint8_t *)eth_hdr), pkt);
		return NET_DROP;
4000ed8c:	00200513          	li	a0,2
	}

	net_pkt_unref(pkt);

	return NET_OK;
}
4000ed90:	03c12083          	lw	ra,60(sp)
4000ed94:	03812403          	lw	s0,56(sp)
4000ed98:	03412483          	lw	s1,52(sp)
4000ed9c:	03012903          	lw	s2,48(sp)
4000eda0:	02c12983          	lw	s3,44(sp)
4000eda4:	02812a03          	lw	s4,40(sp)
4000eda8:	02412a83          	lw	s5,36(sp)
4000edac:	02012b03          	lw	s6,32(sp)
4000edb0:	01c12b83          	lw	s7,28(sp)
4000edb4:	04010113          	addi	sp,sp,64
4000edb8:	00008067          	ret
		bytes += buf->len;
4000edbc:	0107d603          	lhu	a2,16(a5)
		buf = buf->frags;
4000edc0:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4000edc4:	00c70733          	add	a4,a4,a2
		buf = buf->frags;
4000edc8:	fb1ff06f          	j	4000ed78 <net_arp_input+0x3c>
	if (ntohs(arp_hdr->hwtype) != NET_ARP_HTYPE_ETH ||
4000edcc:	00144703          	lbu	a4,1(s0)
4000edd0:	00044783          	lbu	a5,0(s0)
4000edd4:	00871713          	slli	a4,a4,0x8
4000edd8:	00f76733          	or	a4,a4,a5
4000eddc:	10000793          	li	a5,256
4000ede0:	faf716e3          	bne	a4,a5,4000ed8c <net_arp_input+0x50>
4000ede4:	00344783          	lbu	a5,3(s0)
4000ede8:	00244683          	lbu	a3,2(s0)
4000edec:	00879793          	slli	a5,a5,0x8
4000edf0:	00d7e7b3          	or	a5,a5,a3
4000edf4:	00800693          	li	a3,8
4000edf8:	f8d79ae3          	bne	a5,a3,4000ed8c <net_arp_input+0x50>
	    ntohs(arp_hdr->protocol) != NET_ETH_PTYPE_IP ||
4000edfc:	00444683          	lbu	a3,4(s0)
4000ee00:	00600793          	li	a5,6
4000ee04:	f8f694e3          	bne	a3,a5,4000ed8c <net_arp_input+0x50>
	    arp_hdr->hwlen != sizeof(struct net_eth_addr) ||
4000ee08:	00544683          	lbu	a3,5(s0)
4000ee0c:	00400793          	li	a5,4
4000ee10:	f6f69ee3          	bne	a3,a5,4000ed8c <net_arp_input+0x50>
	    arp_hdr->protolen != NET_ARP_IPV4_PTYPE_SIZE ||
4000ee14:	00e44683          	lbu	a3,14(s0)
4000ee18:	07f00793          	li	a5,127
4000ee1c:	f6f688e3          	beq	a3,a5,4000ed8c <net_arp_input+0x50>
	switch (ntohs(arp_hdr->opcode)) {
4000ee20:	00744783          	lbu	a5,7(s0)
4000ee24:	00644683          	lbu	a3,6(s0)
4000ee28:	00879793          	slli	a5,a5,0x8
4000ee2c:	00d7e7b3          	or	a5,a5,a3
4000ee30:	00e78e63          	beq	a5,a4,4000ee4c <net_arp_input+0x110>
4000ee34:	20000713          	li	a4,512
4000ee38:	28e78063          	beq	a5,a4,4000f0b8 <net_arp_input+0x37c>
	net_pkt_unref(pkt);
4000ee3c:	00048513          	mv	a0,s1
4000ee40:	1dd080ef          	jal	ra,4001781c <net_pkt_unref>
	return NET_OK;
4000ee44:	00000513          	li	a0,0
4000ee48:	f49ff06f          	j	4000ed90 <net_arp_input+0x54>
4000ee4c:	0184a783          	lw	a5,24(s1)
		if (memcmp(&arp_hdr->src_hwaddr,
4000ee50:	00840b93          	addi	s7,s0,8
4000ee54:	00600613          	li	a2,6
			   net_if_get_link_addr(net_pkt_iface(pkt))->addr,
4000ee58:	0007a783          	lw	a5,0(a5)
		if (memcmp(&arp_hdr->src_hwaddr,
4000ee5c:	000b8513          	mv	a0,s7
4000ee60:	0107a583          	lw	a1,16(a5)
4000ee64:	e15fd0ef          	jal	ra,4000cc78 <memcmp>
4000ee68:	f20502e3          	beqz	a0,4000ed8c <net_arp_input+0x50>
				   net_eth_broadcast_addr(),
4000ee6c:	fe9fe0ef          	jal	ra,4000de54 <net_eth_broadcast_addr>
4000ee70:	00050593          	mv	a1,a0
			if (memcmp(&eth_hdr->dst,
4000ee74:	00600613          	li	a2,6
4000ee78:	00090513          	mv	a0,s2
4000ee7c:	dfdfd0ef          	jal	ra,4000cc78 <memcmp>
4000ee80:	04051863          	bnez	a0,4000eed0 <net_arp_input+0x194>
				   net_eth_broadcast_addr(),
4000ee84:	fd1fe0ef          	jal	ra,4000de54 <net_eth_broadcast_addr>
4000ee88:	00050593          	mv	a1,a0
			    memcmp(&arp_hdr->dst_hwaddr,
4000ee8c:	00600613          	li	a2,6
4000ee90:	01240513          	addi	a0,s0,18
4000ee94:	de5fd0ef          	jal	ra,4000cc78 <memcmp>
				   sizeof(struct net_eth_addr)) == 0 &&
4000ee98:	02051c63          	bnez	a0,4000eed0 <net_arp_input+0x194>
			    memcmp(&arp_hdr->dst_ipaddr, &arp_hdr->src_ipaddr,
4000ee9c:	00e40593          	addi	a1,s0,14
4000eea0:	00400613          	li	a2,4
4000eea4:	01840513          	addi	a0,s0,24
4000eea8:	00b12623          	sw	a1,12(sp)
4000eeac:	dcdfd0ef          	jal	ra,4000cc78 <memcmp>
				   sizeof(struct net_eth_addr)) == 0 &&
4000eeb0:	00c12583          	lw	a1,12(sp)
4000eeb4:	00051e63          	bnez	a0,4000eed0 <net_arp_input+0x194>
				arp_update(net_pkt_iface(pkt),
4000eeb8:	00000713          	li	a4,0
4000eebc:	00100693          	li	a3,1
4000eec0:	000b8613          	mv	a2,s7
			arp_update(net_pkt_iface(pkt),
4000eec4:	0184a503          	lw	a0,24(s1)
4000eec8:	e78ff0ef          	jal	ra,4000e540 <arp_update>
4000eecc:	f71ff06f          	j	4000ee3c <net_arp_input+0x100>
		if (memcmp(&eth_hdr->dst, net_eth_broadcast_addr(),
4000eed0:	f85fe0ef          	jal	ra,4000de54 <net_eth_broadcast_addr>
4000eed4:	00050593          	mv	a1,a0
4000eed8:	00600613          	li	a2,6
4000eedc:	00090513          	mv	a0,s2
4000eee0:	d99fd0ef          	jal	ra,4000cc78 <memcmp>
4000eee4:	00051e63          	bnez	a0,4000ef00 <net_arp_input+0x1c4>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
4000eee8:	00e44783          	lbu	a5,14(s0)
4000eeec:	f0000737          	lui	a4,0xf0000
4000eef0:	01879793          	slli	a5,a5,0x18
4000eef4:	00e7f7b3          	and	a5,a5,a4
			   sizeof(struct net_eth_addr)) == 0 &&
4000eef8:	e0000737          	lui	a4,0xe0000
4000eefc:	e8e788e3          	beq	a5,a4,4000ed8c <net_arp_input+0x50>
	return pkt->iface;
4000ef00:	0184a983          	lw	s3,24(s1)
		addr = if_get_addr(net_pkt_iface(pkt),
4000ef04:	01840593          	addi	a1,s0,24
4000ef08:	0c09a503          	lw	a0,192(s3)
4000ef0c:	d30ff0ef          	jal	ra,4000e43c <if_get_addr.isra.0>
		if (!addr) {
4000ef10:	e6050ee3          	beqz	a0,4000ed8c <net_arp_input+0x50>
	if (addr->addr[0] == 0x00 &&
4000ef14:	01244783          	lbu	a5,18(s0)
4000ef18:	18079c63          	bnez	a5,4000f0b0 <net_arp_input+0x374>
4000ef1c:	01344783          	lbu	a5,19(s0)
4000ef20:	18079863          	bnez	a5,4000f0b0 <net_arp_input+0x374>
	    addr->addr[1] == 0x00 &&
4000ef24:	01444783          	lbu	a5,20(s0)
4000ef28:	18079463          	bnez	a5,4000f0b0 <net_arp_input+0x374>
	    addr->addr[2] == 0x00 &&
4000ef2c:	01544783          	lbu	a5,21(s0)
4000ef30:	18079063          	bnez	a5,4000f0b0 <net_arp_input+0x374>
	    addr->addr[3] == 0x00 &&
4000ef34:	01644783          	lbu	a5,22(s0)
4000ef38:	16079c63          	bnez	a5,4000f0b0 <net_arp_input+0x374>
	    addr->addr[4] == 0x00 &&
4000ef3c:	01744783          	lbu	a5,23(s0)
4000ef40:	16079863          	bnez	a5,4000f0b0 <net_arp_input+0x374>
			arp_update(net_pkt_iface(pkt),
4000ef44:	00100713          	li	a4,1
4000ef48:	00000693          	li	a3,0
4000ef4c:	000b8613          	mv	a2,s7
4000ef50:	00e40593          	addi	a1,s0,14
4000ef54:	00098513          	mv	a0,s3
4000ef58:	de8ff0ef          	jal	ra,4000e540 <arp_update>
4000ef5c:	0184a983          	lw	s3,24(s1)
	pkt = net_pkt_alloc_with_buffer(iface, sizeof(struct net_arp_hdr),
4000ef60:	00a00713          	li	a4,10
4000ef64:	00000793          	li	a5,0
4000ef68:	00000693          	li	a3,0
4000ef6c:	00000613          	li	a2,0
4000ef70:	01c00593          	li	a1,28
4000ef74:	00098513          	mv	a0,s3
4000ef78:	110090ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
4000ef7c:	00050913          	mv	s2,a0
	if (!pkt) {
4000ef80:	ea050ee3          	beqz	a0,4000ee3c <net_arp_input+0x100>
	return net_buf_simple_add(&buf->b, len);
4000ef84:	00852503          	lw	a0,8(a0)
4000ef88:	01c00593          	li	a1,28
	hdr->hwlen = sizeof(struct net_eth_addr);
4000ef8c:	00600a93          	li	s5,6
4000ef90:	00c50513          	addi	a0,a0,12
4000ef94:	835fe0ef          	jal	ra,4000d7c8 <net_buf_simple_add>
	return pkt->frags->data;
4000ef98:	00892783          	lw	a5,8(s2)
	memcpy(&hdr->dst_hwaddr.addr, &dst_addr->addr,
4000ef9c:	000b8593          	mv	a1,s7
4000efa0:	00600613          	li	a2,6
4000efa4:	00c7a403          	lw	s0,12(a5)
4000efa8:	0084a783          	lw	a5,8(s1)
4000efac:	01240b13          	addi	s6,s0,18
4000efb0:	00c7aa03          	lw	s4,12(a5)
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
4000efb4:	00100793          	li	a5,1
4000efb8:	00f400a3          	sb	a5,1(s0)
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
4000efbc:	00800793          	li	a5,8
4000efc0:	00f40123          	sb	a5,2(s0)
	hdr->protolen = sizeof(struct in_addr);
4000efc4:	00400793          	li	a5,4
4000efc8:	00f402a3          	sb	a5,5(s0)
	hdr->opcode = htons(NET_ARP_REPLY);
4000efcc:	00200793          	li	a5,2
4000efd0:	00f403a3          	sb	a5,7(s0)
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
4000efd4:	00040023          	sb	zero,0(s0)
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
4000efd8:	000401a3          	sb	zero,3(s0)
	hdr->hwlen = sizeof(struct net_eth_addr);
4000efdc:	01540223          	sb	s5,4(s0)
	hdr->opcode = htons(NET_ARP_REPLY);
4000efe0:	00040323          	sb	zero,6(s0)
	memcpy(&hdr->dst_hwaddr.addr, &dst_addr->addr,
4000efe4:	000b0513          	mv	a0,s6
4000efe8:	d11fd0ef          	jal	ra,4000ccf8 <memcpy>
	memcpy(&hdr->src_hwaddr.addr, net_if_get_link_addr(iface)->addr,
4000efec:	0009a783          	lw	a5,0(s3)
4000eff0:	00600613          	li	a2,6
4000eff4:	00840513          	addi	a0,s0,8
4000eff8:	0107a583          	lw	a1,16(a5)
4000effc:	cfdfd0ef          	jal	ra,4000ccf8 <memcpy>
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
4000f000:	00fa4783          	lbu	a5,15(s4)
4000f004:	00ea4703          	lbu	a4,14(s4)
			net_if_queue_tx(net_pkt_iface(reply), reply);
4000f008:	00090593          	mv	a1,s2
4000f00c:	00879793          	slli	a5,a5,0x8
4000f010:	00e7e7b3          	or	a5,a5,a4
4000f014:	010a4703          	lbu	a4,16(s4)
4000f018:	01071713          	slli	a4,a4,0x10
4000f01c:	00f76733          	or	a4,a4,a5
4000f020:	011a4783          	lbu	a5,17(s4)
4000f024:	00e40c23          	sb	a4,24(s0)
4000f028:	01879793          	slli	a5,a5,0x18
4000f02c:	00e7e7b3          	or	a5,a5,a4
4000f030:	0087d713          	srli	a4,a5,0x8
4000f034:	00e40ca3          	sb	a4,25(s0)
4000f038:	0107d713          	srli	a4,a5,0x10
4000f03c:	0187d793          	srli	a5,a5,0x18
4000f040:	00e40d23          	sb	a4,26(s0)
4000f044:	00f40da3          	sb	a5,27(s0)
4000f048:	019a4783          	lbu	a5,25(s4)
4000f04c:	018a4703          	lbu	a4,24(s4)
4000f050:	00879793          	slli	a5,a5,0x8
4000f054:	00e7e7b3          	or	a5,a5,a4
4000f058:	01aa4703          	lbu	a4,26(s4)
4000f05c:	01071713          	slli	a4,a4,0x10
4000f060:	00f76733          	or	a4,a4,a5
4000f064:	01ba4783          	lbu	a5,27(s4)
4000f068:	00e40723          	sb	a4,14(s0)
4000f06c:	01879793          	slli	a5,a5,0x18
4000f070:	00e7e7b3          	or	a5,a5,a4
4000f074:	0087d713          	srli	a4,a5,0x8
4000f078:	00e407a3          	sb	a4,15(s0)
4000f07c:	0107d713          	srli	a4,a5,0x10
4000f080:	0187d793          	srli	a5,a5,0x18
4000f084:	00e40823          	sb	a4,16(s0)
4000f088:	00f408a3          	sb	a5,17(s0)
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
4000f08c:	0009a783          	lw	a5,0(s3)
			net_if_queue_tx(net_pkt_iface(reply), reply);
4000f090:	01892503          	lw	a0,24(s2)
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
4000f094:	0107a783          	lw	a5,16(a5)
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
4000f098:	03590423          	sb	s5,40(s2)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)&hdr->dst_hwaddr.addr;
4000f09c:	03692623          	sw	s6,44(s2)
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
4000f0a0:	02f92223          	sw	a5,36(s2)
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
4000f0a4:	03590823          	sb	s5,48(s2)
			net_if_queue_tx(net_pkt_iface(reply), reply);
4000f0a8:	0fd040ef          	jal	ra,400139a4 <net_if_queue_tx>
4000f0ac:	d91ff06f          	j	4000ee3c <net_arp_input+0x100>
			dst_hw_addr = &eth_hdr->src;
4000f0b0:	00690b93          	addi	s7,s2,6
4000f0b4:	ea9ff06f          	j	4000ef5c <net_arp_input+0x220>
		if (net_ipv4_is_my_addr((struct in_addr *)arp_hdr->dst_ipaddr)) {
4000f0b8:	01840913          	addi	s2,s0,24
 */
static inline bool net_ipv4_is_my_addr(const struct in_addr *addr)
{
	bool ret;

	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
4000f0bc:	00000593          	li	a1,0
4000f0c0:	00090513          	mv	a0,s2
4000f0c4:	1ec040ef          	jal	ra,400132b0 <net_if_ipv4_addr_lookup>
	if (!ret) {
4000f0c8:	00050c63          	beqz	a0,4000f0e0 <net_arp_input+0x3a4>
			arp_update(net_pkt_iface(pkt),
4000f0cc:	00000713          	li	a4,0
4000f0d0:	00000693          	li	a3,0
4000f0d4:	00840613          	addi	a2,s0,8
4000f0d8:	00e40593          	addi	a1,s0,14
4000f0dc:	de9ff06f          	j	4000eec4 <net_arp_input+0x188>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000f0e0:	31c060ef          	jal	ra,400153fc <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000f0e4:	01944703          	lbu	a4,25(s0)
4000f0e8:	01844783          	lbu	a5,24(s0)
4000f0ec:	00054683          	lbu	a3,0(a0)
4000f0f0:	00871713          	slli	a4,a4,0x8
4000f0f4:	00f76733          	or	a4,a4,a5
4000f0f8:	01a44783          	lbu	a5,26(s0)
4000f0fc:	01079793          	slli	a5,a5,0x10
4000f100:	00e7e7b3          	or	a5,a5,a4
4000f104:	01b44703          	lbu	a4,27(s0)
4000f108:	01871713          	slli	a4,a4,0x18
4000f10c:	00f76733          	or	a4,a4,a5
4000f110:	00154783          	lbu	a5,1(a0)
4000f114:	00879793          	slli	a5,a5,0x8
4000f118:	00d7e7b3          	or	a5,a5,a3
4000f11c:	00254683          	lbu	a3,2(a0)
4000f120:	01069693          	slli	a3,a3,0x10
4000f124:	00f6e6b3          	or	a3,a3,a5
4000f128:	00354783          	lbu	a5,3(a0)
4000f12c:	01879793          	slli	a5,a5,0x18
4000f130:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000f134:	f8f70ce3          	beq	a4,a5,4000f0cc <net_arp_input+0x390>
	return net_if_ipv4_is_addr_bcast(iface, addr);
4000f138:	00090593          	mv	a1,s2
4000f13c:	00000513          	li	a0,0
4000f140:	735030ef          	jal	ra,40013074 <net_if_ipv4_is_addr_bcast>
		if (net_ipv4_is_my_addr((struct in_addr *)arp_hdr->dst_ipaddr)) {
4000f144:	ce050ce3          	beqz	a0,4000ee3c <net_arp_input+0x100>
4000f148:	f85ff06f          	j	4000f0cc <net_arp_input+0x390>

4000f14c <net_arp_clear_cache>:

void net_arp_clear_cache(struct net_if *iface)
{
4000f14c:	fe010113          	addi	sp,sp,-32
4000f150:	00912a23          	sw	s1,20(sp)
4000f154:	01412423          	sw	s4,8(sp)
4000f158:	00050493          	mv	s1,a0
	sys_snode_t *prev = NULL;
	struct arp_entry *entry, *next;

	NET_DBG("Flushing ARP table");

	k_mutex_lock(&arp_mutex, K_FOREVER);
4000f15c:	fff00593          	li	a1,-1
4000f160:	fff00513          	li	a0,-1
	return list->head;
4000f164:	40039a37          	lui	s4,0x40039
{
4000f168:	00812c23          	sw	s0,24(sp)
4000f16c:	00112e23          	sw	ra,28(sp)
4000f170:	01212823          	sw	s2,16(sp)
4000f174:	01312623          	sw	s3,12(sp)
4000f178:	01512223          	sw	s5,4(sp)
4000f17c:	01612023          	sw	s6,0(sp)
	k_mutex_lock(&arp_mutex, K_FOREVER);
4000f180:	a9cff0ef          	jal	ra,4000e41c <k_mutex_lock.constprop.0.isra.0>
4000f184:	020a2403          	lw	s0,32(s4) # 40039020 <arp_table>

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
4000f188:	00040a63          	beqz	s0,4000f19c <net_arp_clear_cache+0x50>
	return node->next;
4000f18c:	00042903          	lw	s2,0(s0)
4000f190:	00000993          	li	s3,0
		}

		arp_entry_cleanup(entry, false);

		sys_slist_remove(&arp_table, prev, &entry->node);
		sys_slist_prepend(&arp_free_entries, &entry->node);
4000f194:	40039ab7          	lui	s5,0x40039
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
4000f198:	06041063          	bnez	s0,4000f1f8 <net_arp_clear_cache+0xac>
	return list->head;
4000f19c:	40039a37          	lui	s4,0x40039
4000f1a0:	028a2403          	lw	s0,40(s4) # 40039028 <arp_pending_entries>
4000f1a4:	028a0a93          	addi	s5,s4,40

	prev = NULL;

	NET_DBG("Flushing ARP pending requests");

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
4000f1a8:	00040a63          	beqz	s0,4000f1bc <net_arp_clear_cache+0x70>
	return node->next;
4000f1ac:	00042903          	lw	s2,0(s0)
4000f1b0:	00000993          	li	s3,0
		}

		arp_entry_cleanup(entry, true);

		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
		sys_slist_prepend(&arp_free_entries, &entry->node);
4000f1b4:	40039b37          	lui	s6,0x40039
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
4000f1b8:	08041c63          	bnez	s0,4000f250 <net_arp_clear_cache+0x104>
	}

	if (sys_slist_is_empty(&arp_pending_entries)) {
4000f1bc:	000aa783          	lw	a5,0(s5) # 40039000 <sum>
4000f1c0:	00079863          	bnez	a5,4000f1d0 <net_arp_clear_cache+0x84>
		k_work_cancel_delayable(&arp_request_timer);
4000f1c4:	4003a537          	lui	a0,0x4003a
4000f1c8:	91050513          	addi	a0,a0,-1776 # 40039910 <arp_request_timer>
4000f1cc:	7a1200ef          	jal	ra,4003016c <k_work_cancel_delayable>
	}

	k_mutex_unlock(&arp_mutex);
}
4000f1d0:	01812403          	lw	s0,24(sp)
4000f1d4:	01c12083          	lw	ra,28(sp)
4000f1d8:	01412483          	lw	s1,20(sp)
4000f1dc:	01012903          	lw	s2,16(sp)
4000f1e0:	00c12983          	lw	s3,12(sp)
4000f1e4:	00812a03          	lw	s4,8(sp)
4000f1e8:	00412a83          	lw	s5,4(sp)
4000f1ec:	00012b03          	lw	s6,0(sp)
4000f1f0:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&arp_mutex);
4000f1f4:	a3cff06f          	j	4000e430 <k_mutex_unlock.constprop.0.isra.0>
			prev = &entry->node;
4000f1f8:	00040793          	mv	a5,s0
		if (iface && iface != entry->iface) {
4000f1fc:	00048663          	beqz	s1,4000f208 <net_arp_clear_cache+0xbc>
4000f200:	00842703          	lw	a4,8(s0)
4000f204:	02971863          	bne	a4,s1,4000f234 <net_arp_clear_cache+0xe8>
		arp_entry_cleanup(entry, false);
4000f208:	00000593          	li	a1,0
4000f20c:	00040513          	mv	a0,s0
4000f210:	d60ff0ef          	jal	ra,4000e770 <arp_entry_cleanup>
		sys_slist_remove(&arp_table, prev, &entry->node);
4000f214:	00040613          	mv	a2,s0
4000f218:	00098593          	mv	a1,s3
4000f21c:	020a0513          	addi	a0,s4,32
4000f220:	950ff0ef          	jal	ra,4000e370 <sys_slist_remove>
		sys_slist_prepend(&arp_free_entries, &entry->node);
4000f224:	00040593          	mv	a1,s0
4000f228:	030a8513          	addi	a0,s5,48
4000f22c:	928ff0ef          	jal	ra,4000e354 <sys_slist_prepend>
4000f230:	00098793          	mv	a5,s3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
4000f234:	00000713          	li	a4,0
4000f238:	00090463          	beqz	s2,4000f240 <net_arp_clear_cache+0xf4>
4000f23c:	00092703          	lw	a4,0(s2)
4000f240:	00090413          	mv	s0,s2
4000f244:	00078993          	mv	s3,a5
4000f248:	00070913          	mv	s2,a4
4000f24c:	f4dff06f          	j	4000f198 <net_arp_clear_cache+0x4c>
			prev = &entry->node;
4000f250:	00040793          	mv	a5,s0
		if (iface && iface != entry->iface) {
4000f254:	00048663          	beqz	s1,4000f260 <net_arp_clear_cache+0x114>
4000f258:	00842703          	lw	a4,8(s0)
4000f25c:	02e49863          	bne	s1,a4,4000f28c <net_arp_clear_cache+0x140>
		arp_entry_cleanup(entry, true);
4000f260:	00100593          	li	a1,1
4000f264:	00040513          	mv	a0,s0
4000f268:	d08ff0ef          	jal	ra,4000e770 <arp_entry_cleanup>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
4000f26c:	00040613          	mv	a2,s0
4000f270:	00098593          	mv	a1,s3
4000f274:	028a0513          	addi	a0,s4,40
4000f278:	8f8ff0ef          	jal	ra,4000e370 <sys_slist_remove>
		sys_slist_prepend(&arp_free_entries, &entry->node);
4000f27c:	00040593          	mv	a1,s0
4000f280:	030b0513          	addi	a0,s6,48 # 40039030 <arp_free_entries>
4000f284:	8d0ff0ef          	jal	ra,4000e354 <sys_slist_prepend>
4000f288:	00098793          	mv	a5,s3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
4000f28c:	00000713          	li	a4,0
4000f290:	00090463          	beqz	s2,4000f298 <net_arp_clear_cache+0x14c>
4000f294:	00092703          	lw	a4,0(s2)
4000f298:	00090413          	mv	s0,s2
4000f29c:	00078993          	mv	s3,a5
4000f2a0:	00070913          	mv	s2,a4
4000f2a4:	f15ff06f          	j	4000f1b8 <net_arp_clear_cache+0x6c>

4000f2a8 <net_arp_clear_pending>:
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
4000f2a8:	400397b7          	lui	a5,0x40039

int net_arp_clear_pending(struct net_if *iface, struct in_addr *dst)
{
4000f2ac:	00058613          	mv	a2,a1
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
4000f2b0:	00050593          	mv	a1,a0
4000f2b4:	0287a503          	lw	a0,40(a5) # 40039028 <arp_pending_entries>
{
4000f2b8:	ff010113          	addi	sp,sp,-16
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
4000f2bc:	00000693          	li	a3,0
{
4000f2c0:	00112623          	sw	ra,12(sp)
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
4000f2c4:	a08ff0ef          	jal	ra,4000e4cc <arp_entry_find.isra.0>
	struct arp_entry *entry = arp_entry_find_pending(iface, dst);

	if (!entry) {
4000f2c8:	00050e63          	beqz	a0,4000f2e4 <net_arp_clear_pending+0x3c>
		return -ENOENT;
	}

	arp_entry_cleanup(entry, true);
4000f2cc:	00100593          	li	a1,1
4000f2d0:	ca0ff0ef          	jal	ra,4000e770 <arp_entry_cleanup>

	return 0;
4000f2d4:	00000513          	li	a0,0
}
4000f2d8:	00c12083          	lw	ra,12(sp)
4000f2dc:	01010113          	addi	sp,sp,16
4000f2e0:	00008067          	ret
		return -ENOENT;
4000f2e4:	ffe00513          	li	a0,-2
4000f2e8:	ff1ff06f          	j	4000f2d8 <net_arp_clear_pending+0x30>

4000f2ec <net_arp_foreach>:

int net_arp_foreach(net_arp_cb_t cb, void *user_data)
{
4000f2ec:	fe010113          	addi	sp,sp,-32
4000f2f0:	01212823          	sw	s2,16(sp)
4000f2f4:	01312623          	sw	s3,12(sp)
4000f2f8:	00050913          	mv	s2,a0
4000f2fc:	00058993          	mv	s3,a1
	int ret = 0;
	struct arp_entry *entry;

	k_mutex_lock(&arp_mutex, K_FOREVER);
4000f300:	fff00513          	li	a0,-1
4000f304:	fff00593          	li	a1,-1
{
4000f308:	00812c23          	sw	s0,24(sp)
4000f30c:	00912a23          	sw	s1,20(sp)
4000f310:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&arp_mutex, K_FOREVER);
4000f314:	908ff0ef          	jal	ra,4000e41c <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4000f318:	400397b7          	lui	a5,0x40039
4000f31c:	0207a403          	lw	s0,32(a5) # 40039020 <arp_table>
4000f320:	00000493          	li	s1,0

	SYS_SLIST_FOR_EACH_CONTAINER(&arp_table, entry, node) {
4000f324:	02041463          	bnez	s0,4000f34c <net_arp_foreach+0x60>
		ret++;
		cb(entry, user_data);
	}

	k_mutex_unlock(&arp_mutex);
4000f328:	908ff0ef          	jal	ra,4000e430 <k_mutex_unlock.constprop.0.isra.0>

	return ret;
}
4000f32c:	01c12083          	lw	ra,28(sp)
4000f330:	01812403          	lw	s0,24(sp)
4000f334:	01012903          	lw	s2,16(sp)
4000f338:	00c12983          	lw	s3,12(sp)
4000f33c:	00048513          	mv	a0,s1
4000f340:	01412483          	lw	s1,20(sp)
4000f344:	02010113          	addi	sp,sp,32
4000f348:	00008067          	ret
		cb(entry, user_data);
4000f34c:	00040513          	mv	a0,s0
4000f350:	00098593          	mv	a1,s3
4000f354:	000900e7          	jalr	s2
		ret++;
4000f358:	00148493          	addi	s1,s1,1
	return node->next;
4000f35c:	00042403          	lw	s0,0(s0)
4000f360:	fc5ff06f          	j	4000f324 <net_arp_foreach+0x38>

4000f364 <net_arp_init>:

void net_arp_init(void)
{
4000f364:	ff010113          	addi	sp,sp,-16
4000f368:	00912223          	sw	s1,4(sp)
	int i;

	if (arp_cache_initialized) {
4000f36c:	400394b7          	lui	s1,0x40039
4000f370:	1094c783          	lbu	a5,265(s1) # 40039109 <arp_cache_initialized>
{
4000f374:	00112623          	sw	ra,12(sp)
4000f378:	00812423          	sw	s0,8(sp)
	if (arp_cache_initialized) {
4000f37c:	08079a63          	bnez	a5,4000f410 <net_arp_init+0xac>
	list->head = NULL;
4000f380:	40039437          	lui	s0,0x40039
4000f384:	03040793          	addi	a5,s0,48 # 40039030 <arp_free_entries>
4000f388:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
4000f38c:	0007a223          	sw	zero,4(a5)
	list->head = NULL;
4000f390:	400397b7          	lui	a5,0x40039
4000f394:	02878793          	addi	a5,a5,40 # 40039028 <arp_pending_entries>
4000f398:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
4000f39c:	0007a223          	sw	zero,4(a5)
	list->head = NULL;
4000f3a0:	400397b7          	lui	a5,0x40039
4000f3a4:	02078793          	addi	a5,a5,32 # 40039020 <arp_table>
4000f3a8:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
4000f3ac:	0007a223          	sw	zero,4(a5)
	z_impl_k_queue_init(queue);
4000f3b0:	4003a537          	lui	a0,0x4003a
4000f3b4:	4b450513          	addi	a0,a0,1204 # 4003a4b4 <arp_entries+0x18>
4000f3b8:	428200ef          	jal	ra,4002f7e0 <z_impl_k_queue_init>
	sys_slist_init(&arp_table);

	for (i = 0; i < CONFIG_NET_ARP_TABLE_SIZE; i++) {
		/* Inserting entry as free with initialised packet queue */
		k_fifo_init(&arp_entries[i].pending_queue);
		sys_slist_prepend(&arp_free_entries, &arp_entries[i].node);
4000f3bc:	4003a5b7          	lui	a1,0x4003a
4000f3c0:	49c58593          	addi	a1,a1,1180 # 4003a49c <arp_entries>
4000f3c4:	03040513          	addi	a0,s0,48
4000f3c8:	f8dfe0ef          	jal	ra,4000e354 <sys_slist_prepend>
4000f3cc:	4003a537          	lui	a0,0x4003a
4000f3d0:	4e450513          	addi	a0,a0,1252 # 4003a4e4 <arp_entries+0x48>
4000f3d4:	40c200ef          	jal	ra,4002f7e0 <z_impl_k_queue_init>
4000f3d8:	4003a5b7          	lui	a1,0x4003a
4000f3dc:	03040513          	addi	a0,s0,48
4000f3e0:	4cc58593          	addi	a1,a1,1228 # 4003a4cc <arp_entries+0x30>
4000f3e4:	f71fe0ef          	jal	ra,4000e354 <sys_slist_prepend>
	}

	k_work_init_delayable(&arp_request_timer, arp_request_timeout);
4000f3e8:	4000e5b7          	lui	a1,0x4000e
4000f3ec:	4003a537          	lui	a0,0x4003a
4000f3f0:	7e058593          	addi	a1,a1,2016 # 4000e7e0 <arp_request_timeout>
4000f3f4:	91050513          	addi	a0,a0,-1776 # 40039910 <arp_request_timer>
4000f3f8:	40d200ef          	jal	ra,40030004 <k_work_init_delayable>
	return z_impl_k_mutex_init(mutex);
4000f3fc:	4003a537          	lui	a0,0x4003a
4000f400:	48850513          	addi	a0,a0,1160 # 4003a488 <arp_mutex>
4000f404:	020200ef          	jal	ra,4002f424 <z_impl_k_mutex_init>

	k_mutex_init(&arp_mutex);

	arp_cache_initialized = true;
4000f408:	00100793          	li	a5,1
4000f40c:	10f484a3          	sb	a5,265(s1)
}
4000f410:	00c12083          	lw	ra,12(sp)
4000f414:	00812403          	lw	s0,8(sp)
4000f418:	00412483          	lw	s1,4(sp)
4000f41c:	01010113          	addi	sp,sp,16
4000f420:	00008067          	ret

4000f424 <net_ipv6_is_addr_loopback>:
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4000f424:	00154703          	lbu	a4,1(a0)
4000f428:	00054683          	lbu	a3,0(a0)
{
4000f42c:	00050793          	mv	a5,a0
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4000f430:	00871713          	slli	a4,a4,0x8
4000f434:	00d76733          	or	a4,a4,a3
4000f438:	00254683          	lbu	a3,2(a0)
4000f43c:	01069693          	slli	a3,a3,0x10
4000f440:	00e6e6b3          	or	a3,a3,a4
4000f444:	00354703          	lbu	a4,3(a0)
4000f448:	01871713          	slli	a4,a4,0x18
4000f44c:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000f450:	0c071263          	bnez	a4,4000f514 <net_ipv6_is_addr_loopback+0xf0>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4000f454:	00554703          	lbu	a4,5(a0)
4000f458:	00454683          	lbu	a3,4(a0)
4000f45c:	00871713          	slli	a4,a4,0x8
4000f460:	00d76733          	or	a4,a4,a3
4000f464:	00654683          	lbu	a3,6(a0)
4000f468:	01069693          	slli	a3,a3,0x10
4000f46c:	00e6e6b3          	or	a3,a3,a4
4000f470:	00754703          	lbu	a4,7(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000f474:	00000513          	li	a0,0
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4000f478:	01871713          	slli	a4,a4,0x18
4000f47c:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4000f480:	08071c63          	bnez	a4,4000f518 <net_ipv6_is_addr_loopback+0xf4>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000f484:	0097c703          	lbu	a4,9(a5)
4000f488:	0087c683          	lbu	a3,8(a5)
4000f48c:	00871713          	slli	a4,a4,0x8
4000f490:	00d76733          	or	a4,a4,a3
4000f494:	00a7c683          	lbu	a3,10(a5)
4000f498:	01069693          	slli	a3,a3,0x10
4000f49c:	00e6e6b3          	or	a3,a3,a4
4000f4a0:	00b7c703          	lbu	a4,11(a5)
4000f4a4:	01871713          	slli	a4,a4,0x18
4000f4a8:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4000f4ac:	06071663          	bnez	a4,4000f518 <net_ipv6_is_addr_loopback+0xf4>
		ntohl(UNALIGNED_GET(&addr->s6_addr32[3])) == 1;
4000f4b0:	00d7c683          	lbu	a3,13(a5)
4000f4b4:	00c7c703          	lbu	a4,12(a5)
4000f4b8:	00869693          	slli	a3,a3,0x8
4000f4bc:	00e6e6b3          	or	a3,a3,a4
4000f4c0:	00e7c703          	lbu	a4,14(a5)
4000f4c4:	00f7c783          	lbu	a5,15(a5)
4000f4c8:	01071713          	slli	a4,a4,0x10
4000f4cc:	01879793          	slli	a5,a5,0x18
4000f4d0:	00d76733          	or	a4,a4,a3
4000f4d4:	00e7e6b3          	or	a3,a5,a4
4000f4d8:	0187d513          	srli	a0,a5,0x18
4000f4dc:	01871713          	slli	a4,a4,0x18
4000f4e0:	00e56533          	or	a0,a0,a4
4000f4e4:	00010737          	lui	a4,0x10
4000f4e8:	0086d793          	srli	a5,a3,0x8
4000f4ec:	f0070713          	addi	a4,a4,-256 # ff00 <__kernel_ram_size+0x43f8>
4000f4f0:	00e7f7b3          	and	a5,a5,a4
4000f4f4:	00f56533          	or	a0,a0,a5
4000f4f8:	00869693          	slli	a3,a3,0x8
4000f4fc:	00ff07b7          	lui	a5,0xff0
4000f500:	00f6f6b3          	and	a3,a3,a5
4000f504:	00d56533          	or	a0,a0,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000f508:	fff50513          	addi	a0,a0,-1
4000f50c:	00153513          	seqz	a0,a0
4000f510:	00008067          	ret
4000f514:	00000513          	li	a0,0
}
4000f518:	00008067          	ret

4000f51c <net_init>:

	return status;
}

static int net_init(void)
{
4000f51c:	ff010113          	addi	sp,sp,-16
4000f520:	00112623          	sw	ra,12(sp)
	net_hostname_init();

	NET_DBG("Priority %d", CONFIG_NET_INIT_PRIO);

	net_pkt_init();
4000f524:	4a0090ef          	jal	ra,400189c4 <net_pkt_init>

	net_context_init();
4000f528:	591070ef          	jal	ra,400172b8 <net_context_init>
	net_icmpv4_init();
4000f52c:	5150a0ef          	jal	ra,4001a240 <net_icmpv4_init>
	net_icmpv6_init();
4000f530:	5510b0ef          	jal	ra,4001b280 <net_icmpv6_init>
	net_ipv4_init();
4000f534:	3ec0b0ef          	jal	ra,4001a920 <net_ipv4_init>
	net_ipv6_init();
4000f538:	28d0c0ef          	jal	ra,4001bfc4 <net_ipv6_init>
		net_conn_init();
4000f53c:	3500a0ef          	jal	ra,4001988c <net_conn_init>
	net_tcp_init();
4000f540:	678150ef          	jal	ra,40024bb8 <net_tcp_init>
	net_route_init();
4000f544:	4cd100ef          	jal	ra,40020210 <net_route_init>

	l3_init();

	net_mgmt_event_init();
4000f548:	2c8060ef          	jal	ra,40015810 <net_mgmt_event_init>
	net_if_init();
4000f54c:	115040ef          	jal	ra,40013e60 <net_if_init>
	net_tc_rx_init();
4000f550:	4ec090ef          	jal	ra,40018a3c <net_tc_rx_init>
	net_if_post_init();
4000f554:	47d040ef          	jal	ra,400141d0 <net_if_post_init>
	dns_init_resolver();
4000f558:	3791c0ef          	jal	ra,4002c0d0 <dns_init_resolver>
	net_shell_init();
4000f55c:	0551a0ef          	jal	ra,40029db0 <net_shell_init>

	init_rx_queues();

	return services_init();
}
4000f560:	00c12083          	lw	ra,12(sp)
4000f564:	00000513          	li	a0,0
4000f568:	01010113          	addi	sp,sp,16
4000f56c:	00008067          	ret

4000f570 <processing_data>:
{
4000f570:	ff010113          	addi	sp,sp,-16
4000f574:	00812423          	sw	s0,8(sp)
4000f578:	00112623          	sw	ra,12(sp)
4000f57c:	00912223          	sw	s1,4(sp)
	pkt->l2_processed = is_l2_processed;
4000f580:	03854783          	lbu	a5,56(a0)
4000f584:	00050413          	mv	s0,a0
4000f588:	fef7f793          	andi	a5,a5,-17
4000f58c:	02f50c23          	sb	a5,56(a0)
	if (!pkt->frags) {
4000f590:	00852783          	lw	a5,8(a0)
4000f594:	04079063          	bnez	a5,4000f5d4 <processing_data+0x64>
	  SET_STAT(_iface->_cmd); }
/* Core stats */

static inline void net_stats_update_processing_error(struct net_if *iface)
{
	UPDATE_STAT(iface, stats.processing_error++);
4000f598:	4003b7b7          	lui	a5,0x4003b
4000f59c:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4000f5a0:	0007a703          	lw	a4,0(a5)
	return pkt->iface;
4000f5a4:	01842683          	lw	a3,24(s0)
4000f5a8:	00170713          	addi	a4,a4,1
4000f5ac:	00e7a023          	sw	a4,0(a5)
4000f5b0:	0046a783          	lw	a5,4(a3)
4000f5b4:	00178793          	addi	a5,a5,1
4000f5b8:	00f6a223          	sw	a5,4(a3)
			net_pkt_unref(pkt);
4000f5bc:	00040513          	mv	a0,s0
}
4000f5c0:	00812403          	lw	s0,8(sp)
4000f5c4:	00c12083          	lw	ra,12(sp)
4000f5c8:	00412483          	lw	s1,4(sp)
4000f5cc:	01010113          	addi	sp,sp,16
			net_pkt_unref(pkt);
4000f5d0:	24c0806f          	j	4001781c <net_pkt_unref>
4000f5d4:	00058493          	mv	s1,a1
	if (!is_loopback && !locally_routed) {
4000f5d8:	02059c63          	bnez	a1,4000f610 <processing_data+0xa0>
		ret = net_if_recv_data(net_pkt_iface(pkt), pkt);
4000f5dc:	00050593          	mv	a1,a0
4000f5e0:	01852503          	lw	a0,24(a0)
4000f5e4:	174040ef          	jal	ra,40013758 <net_if_recv_data>
		if (ret != NET_CONTINUE) {
4000f5e8:	00100793          	li	a5,1
4000f5ec:	02f50263          	beq	a0,a5,4000f610 <processing_data+0xa0>
			if (ret == NET_DROP) {
4000f5f0:	00200793          	li	a5,2
4000f5f4:	faf502e3          	beq	a0,a5,4000f598 <processing_data+0x28>
	switch (process_data(pkt, is_loopback)) {
4000f5f8:	fc0512e3          	bnez	a0,4000f5bc <processing_data+0x4c>
}
4000f5fc:	00c12083          	lw	ra,12(sp)
4000f600:	00812403          	lw	s0,8(sp)
4000f604:	00412483          	lw	s1,4(sp)
4000f608:	01010113          	addi	sp,sp,16
4000f60c:	00008067          	ret
	pkt->l2_processed = is_l2_processed;
4000f610:	03844783          	lbu	a5,56(s0)
	net_pkt_cursor_init(pkt);
4000f614:	00040513          	mv	a0,s0
4000f618:	0107e793          	ori	a5,a5,16
4000f61c:	02f40c23          	sb	a5,56(s0)
4000f620:	4d0080ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	return pkt->family;
4000f624:	03442783          	lw	a5,52(s0)
	if (IS_ENABLED(CONFIG_NET_IP) && (family == AF_INET || family == AF_INET6 ||
4000f628:	f807cae3          	bltz	a5,4000f5bc <processing_data+0x4c>
	return pkt->frags->data;
4000f62c:	00842783          	lw	a5,8(s0)
		if (IS_ENABLED(CONFIG_NET_IPV6) && vtc_vhl == 0x60) {
4000f630:	06000713          	li	a4,96
		uint8_t vtc_vhl = NET_IPV6_HDR(pkt)->vtc & 0xf0;
4000f634:	00c7a783          	lw	a5,12(a5)
4000f638:	0007c783          	lbu	a5,0(a5)
4000f63c:	0f07f793          	andi	a5,a5,240
		if (IS_ENABLED(CONFIG_NET_IPV6) && vtc_vhl == 0x60) {
4000f640:	00e79a63          	bne	a5,a4,4000f654 <processing_data+0xe4>
			return net_ipv6_input(pkt, is_loopback);
4000f644:	00048593          	mv	a1,s1
4000f648:	00040513          	mv	a0,s0
4000f64c:	2a80c0ef          	jal	ra,4001b8f4 <net_ipv6_input>
4000f650:	fa9ff06f          	j	4000f5f8 <processing_data+0x88>
		} else if (IS_ENABLED(CONFIG_NET_IPV4) && vtc_vhl == 0x40) {
4000f654:	04000713          	li	a4,64
4000f658:	00e79863          	bne	a5,a4,4000f668 <processing_data+0xf8>
			return net_ipv4_input(pkt);
4000f65c:	00040513          	mv	a0,s0
4000f660:	7750a0ef          	jal	ra,4001a5d4 <net_ipv4_input>
4000f664:	f95ff06f          	j	4000f5f8 <processing_data+0x88>
}

static inline void net_stats_update_ip_errors_protoerr(struct net_if *iface)
{
	UPDATE_STAT(iface, stats.ip_errors.protoerr++);
4000f668:	4003b7b7          	lui	a5,0x4003b
4000f66c:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4000f670:	0207a703          	lw	a4,32(a5)
	return pkt->iface;
4000f674:	01842683          	lw	a3,24(s0)
4000f678:	00170713          	addi	a4,a4,1
4000f67c:	02e7a023          	sw	a4,32(a5)
4000f680:	0246a703          	lw	a4,36(a3)
4000f684:	00170713          	addi	a4,a4,1
4000f688:	02e6a223          	sw	a4,36(a3)
}

static inline void net_stats_update_ip_errors_vhlerr(struct net_if *iface)
{
	UPDATE_STAT(iface, stats.ip_errors.vhlerr++);
4000f68c:	00c7a703          	lw	a4,12(a5)
4000f690:	01842683          	lw	a3,24(s0)
4000f694:	00170713          	addi	a4,a4,1
4000f698:	00e7a623          	sw	a4,12(a5)
4000f69c:	0106a783          	lw	a5,16(a3)
4000f6a0:	00178793          	addi	a5,a5,1
4000f6a4:	00f6a823          	sw	a5,16(a3)
4000f6a8:	f15ff06f          	j	4000f5bc <processing_data+0x4c>

4000f6ac <net_send_data>:
	if (!pkt || !pkt->frags) {
4000f6ac:	3e050063          	beqz	a0,4000fa8c <net_send_data+0x3e0>
{
4000f6b0:	fe010113          	addi	sp,sp,-32
4000f6b4:	00812c23          	sw	s0,24(sp)
4000f6b8:	00112e23          	sw	ra,28(sp)
4000f6bc:	00912a23          	sw	s1,20(sp)
4000f6c0:	01212823          	sw	s2,16(sp)
	if (!pkt || !pkt->frags) {
4000f6c4:	00852783          	lw	a5,8(a0)
4000f6c8:	00050413          	mv	s0,a0
		return -ENODATA;
4000f6cc:	fc300513          	li	a0,-61
	if (!pkt || !pkt->frags) {
4000f6d0:	06078863          	beqz	a5,4000f740 <net_send_data+0x94>
4000f6d4:	01842783          	lw	a5,24(s0)
		return -EINVAL;
4000f6d8:	fea00513          	li	a0,-22
	if (!net_pkt_iface(pkt)) {
4000f6dc:	06078263          	beqz	a5,4000f740 <net_send_data+0x94>
	return pkt->family;
4000f6e0:	03442703          	lw	a4,52(s0)
	switch (net_pkt_family(pkt)) {
4000f6e4:	00100693          	li	a3,1
4000f6e8:	01d75713          	srli	a4,a4,0x1d
4000f6ec:	06d70663          	beq	a4,a3,4000f758 <net_send_data+0xac>
4000f6f0:	00200693          	li	a3,2
4000f6f4:	08d70463          	beq	a4,a3,4000f77c <net_send_data+0xd0>
	net_pkt_trim_buffer(pkt);
4000f6f8:	00040513          	mv	a0,s0
4000f6fc:	308080ef          	jal	ra,40017a04 <net_pkt_trim_buffer>
	net_pkt_cursor_init(pkt);
4000f700:	00040513          	mv	a0,s0
4000f704:	3ec080ef          	jal	ra,40017af0 <net_pkt_cursor_init>
4000f708:	03442783          	lw	a5,52(s0)
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
4000f70c:	00200713          	li	a4,2
4000f710:	01d7d793          	srli	a5,a5,0x1d
4000f714:	14e79c63          	bne	a5,a4,4000f86c <net_send_data+0x1c0>
	return pkt->frags->data;
4000f718:	00842783          	lw	a5,8(s0)
		if (net_ipv6_addr_cmp((struct in6_addr *)NET_IPV6_HDR(pkt)->dst,
4000f71c:	00c7a483          	lw	s1,12(a5)
4000f720:	4e9050ef          	jal	ra,40015408 <net_ipv6_unspecified_address>
4000f724:	00050593          	mv	a1,a0
4000f728:	01848493          	addi	s1,s1,24
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4000f72c:	01000613          	li	a2,16
4000f730:	00048513          	mv	a0,s1
4000f734:	d44fd0ef          	jal	ra,4000cc78 <memcmp>
4000f738:	06051463          	bnez	a0,4000f7a0 <net_send_data+0xf4>
			return -EADDRNOTAVAIL;
4000f73c:	f8300513          	li	a0,-125
}
4000f740:	01c12083          	lw	ra,28(sp)
4000f744:	01812403          	lw	s0,24(sp)
4000f748:	01412483          	lw	s1,20(sp)
4000f74c:	01012903          	lw	s2,16(sp)
4000f750:	02010113          	addi	sp,sp,32
4000f754:	00008067          	ret
	UPDATE_STAT(iface, stats.ipv4.drop++);
}

static inline void net_stats_update_ipv4_sent(struct net_if *iface)
{
	UPDATE_STAT(iface, stats.ipv4.sent++);
4000f758:	4003b737          	lui	a4,0x4003b
4000f75c:	ed070713          	addi	a4,a4,-304 # 4003aed0 <net_stats>
4000f760:	03872683          	lw	a3,56(a4)
4000f764:	00168693          	addi	a3,a3,1
4000f768:	02d72c23          	sw	a3,56(a4)
4000f76c:	03c7a703          	lw	a4,60(a5)
4000f770:	00170713          	addi	a4,a4,1
4000f774:	02e7ae23          	sw	a4,60(a5)
}
4000f778:	f81ff06f          	j	4000f6f8 <net_send_data+0x4c>
	UPDATE_STAT(iface, stats.ipv6.sent++);
4000f77c:	4003b737          	lui	a4,0x4003b
4000f780:	ed070713          	addi	a4,a4,-304 # 4003aed0 <net_stats>
4000f784:	02872683          	lw	a3,40(a4)
4000f788:	00168693          	addi	a3,a3,1
4000f78c:	02d72423          	sw	a3,40(a4)
4000f790:	02c7a703          	lw	a4,44(a5)
4000f794:	00170713          	addi	a4,a4,1
4000f798:	02e7a623          	sw	a4,44(a5)
}
4000f79c:	f5dff06f          	j	4000f6f8 <net_send_data+0x4c>
4000f7a0:	00842783          	lw	a5,8(s0)
				(struct in6_addr *)NET_IPV6_HDR(pkt)->dst) ||
4000f7a4:	00c7a483          	lw	s1,12(a5)
4000f7a8:	01848493          	addi	s1,s1,24
		if (net_ipv6_is_addr_loopback(
4000f7ac:	00048513          	mv	a0,s1
4000f7b0:	c75ff0ef          	jal	ra,4000f424 <net_ipv6_is_addr_loopback>
4000f7b4:	06050063          	beqz	a0,4000f814 <net_send_data+0x168>
4000f7b8:	00842783          	lw	a5,8(s0)
	memcpy(dest, src, sizeof(struct in6_addr));
4000f7bc:	01000613          	li	a2,16
4000f7c0:	00010513          	mv	a0,sp
			net_ipv6_addr_copy_raw((uint8_t *)&addr, NET_IPV6_HDR(pkt)->src);
4000f7c4:	00c7a583          	lw	a1,12(a5)
4000f7c8:	00858593          	addi	a1,a1,8
4000f7cc:	d2cfd0ef          	jal	ra,4000ccf8 <memcpy>
4000f7d0:	00842783          	lw	a5,8(s0)
4000f7d4:	01000613          	li	a2,16
4000f7d8:	00c7a503          	lw	a0,12(a5)
4000f7dc:	01850593          	addi	a1,a0,24
4000f7e0:	00850513          	addi	a0,a0,8
4000f7e4:	d14fd0ef          	jal	ra,4000ccf8 <memcpy>
4000f7e8:	00842783          	lw	a5,8(s0)
4000f7ec:	01000613          	li	a2,16
4000f7f0:	00010593          	mv	a1,sp
			net_ipv6_addr_copy_raw(NET_IPV6_HDR(pkt)->dst, (uint8_t *)&addr);
4000f7f4:	00c7a503          	lw	a0,12(a5)
4000f7f8:	01850513          	addi	a0,a0,24
4000f7fc:	cfcfd0ef          	jal	ra,4000ccf8 <memcpy>
		processing_data(pkt, true);
4000f800:	00100593          	li	a1,1
4000f804:	00040513          	mv	a0,s0
4000f808:	d69ff0ef          	jal	ra,4000f570 <processing_data>
		return 0;
4000f80c:	00000513          	li	a0,0
4000f810:	f31ff06f          	j	4000f740 <net_send_data+0x94>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
4000f814:	00000593          	li	a1,0
4000f818:	00048513          	mv	a0,s1
4000f81c:	095010ef          	jal	ra,400110b0 <net_if_ipv6_addr_lookup>
				(struct in6_addr *)NET_IPV6_HDR(pkt)->dst) ||
4000f820:	f8051ce3          	bnez	a0,4000f7b8 <net_send_data+0x10c>
4000f824:	00842783          	lw	a5,8(s0)
4000f828:	00c7a503          	lw	a0,12(a5)
 * false otherwise.
 */
static inline bool net_ipv6_is_addr_mcast_scope(const struct in6_addr *addr,
						int scope)
{
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
4000f82c:	0ff00793          	li	a5,255
4000f830:	01854703          	lbu	a4,24(a0)
4000f834:	00f71863          	bne	a4,a5,4000f844 <net_send_data+0x198>
4000f838:	01954703          	lbu	a4,25(a0)
4000f83c:	00100793          	li	a5,1
4000f840:	fcf700e3          	beq	a4,a5,4000f800 <net_send_data+0x154>
		if (net_ipv6_is_addr_loopback(
4000f844:	00850513          	addi	a0,a0,8
4000f848:	bddff0ef          	jal	ra,4000f424 <net_ipv6_is_addr_loopback>
4000f84c:	ee0518e3          	bnez	a0,4000f73c <net_send_data+0x90>
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
4000f850:	01842503          	lw	a0,24(s0)
4000f854:	00040593          	mv	a1,s0
4000f858:	174040ef          	jal	ra,400139cc <net_if_send_data>
4000f85c:	00200793          	li	a5,2
4000f860:	faf516e3          	bne	a0,a5,4000f80c <net_send_data+0x160>
		return -EIO;
4000f864:	ffb00513          	li	a0,-5
4000f868:	ed9ff06f          	j	4000f740 <net_send_data+0x94>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
4000f86c:	00100713          	li	a4,1
4000f870:	fee790e3          	bne	a5,a4,4000f850 <net_send_data+0x1a4>
4000f874:	00842783          	lw	a5,8(s0)
4000f878:	00c7a483          	lw	s1,12(a5)
		if (net_ipv4_addr_cmp((struct in_addr *)NET_IPV4_HDR(pkt)->dst,
4000f87c:	375050ef          	jal	ra,400153f0 <net_ipv4_unspecified_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000f880:	00054683          	lbu	a3,0(a0)
4000f884:	0114c703          	lbu	a4,17(s1)
4000f888:	0104c783          	lbu	a5,16(s1)
4000f88c:	00871713          	slli	a4,a4,0x8
4000f890:	00f76733          	or	a4,a4,a5
4000f894:	0124c783          	lbu	a5,18(s1)
4000f898:	01079793          	slli	a5,a5,0x10
4000f89c:	00e7e7b3          	or	a5,a5,a4
4000f8a0:	0134c703          	lbu	a4,19(s1)
4000f8a4:	01871713          	slli	a4,a4,0x18
4000f8a8:	00f76733          	or	a4,a4,a5
4000f8ac:	00154783          	lbu	a5,1(a0)
4000f8b0:	00879793          	slli	a5,a5,0x8
4000f8b4:	00d7e7b3          	or	a5,a5,a3
4000f8b8:	00254683          	lbu	a3,2(a0)
4000f8bc:	01069693          	slli	a3,a3,0x10
4000f8c0:	00f6e6b3          	or	a3,a3,a5
4000f8c4:	00354783          	lbu	a5,3(a0)
4000f8c8:	01879793          	slli	a5,a5,0x18
4000f8cc:	00d7e7b3          	or	a5,a5,a3
4000f8d0:	e6f706e3          	beq	a4,a5,4000f73c <net_send_data+0x90>
4000f8d4:	00842783          	lw	a5,8(s0)
4000f8d8:	00c7a483          	lw	s1,12(a5)
		if (net_ipv4_is_addr_loopback((struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
4000f8dc:	07f00793          	li	a5,127
4000f8e0:	0104c703          	lbu	a4,16(s1)
4000f8e4:	0af71063          	bne	a4,a5,4000f984 <net_send_data+0x2d8>
4000f8e8:	00842783          	lw	a5,8(s0)
4000f8ec:	00c7a783          	lw	a5,12(a5)
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
4000f8f0:	00d7c703          	lbu	a4,13(a5)
4000f8f4:	00c7c683          	lbu	a3,12(a5)
4000f8f8:	0107c583          	lbu	a1,16(a5)
4000f8fc:	00871713          	slli	a4,a4,0x8
4000f900:	00d76733          	or	a4,a4,a3
4000f904:	0117c683          	lbu	a3,17(a5)
4000f908:	00e7c603          	lbu	a2,14(a5)
4000f90c:	00869693          	slli	a3,a3,0x8
4000f910:	00b6e6b3          	or	a3,a3,a1
4000f914:	0127c583          	lbu	a1,18(a5)
4000f918:	01061613          	slli	a2,a2,0x10
4000f91c:	00e66633          	or	a2,a2,a4
4000f920:	01059593          	slli	a1,a1,0x10
4000f924:	00d5e5b3          	or	a1,a1,a3
4000f928:	0137c683          	lbu	a3,19(a5)
4000f92c:	00b78623          	sb	a1,12(a5)
4000f930:	00f7c703          	lbu	a4,15(a5)
4000f934:	01869693          	slli	a3,a3,0x18
4000f938:	00b6e6b3          	or	a3,a3,a1
4000f93c:	0086d593          	srli	a1,a3,0x8
4000f940:	00b786a3          	sb	a1,13(a5)
4000f944:	0106d593          	srli	a1,a3,0x10
4000f948:	0186d693          	srli	a3,a3,0x18
4000f94c:	00d787a3          	sb	a3,15(a5)
4000f950:	00b78723          	sb	a1,14(a5)
4000f954:	00842783          	lw	a5,8(s0)
4000f958:	01871713          	slli	a4,a4,0x18
4000f95c:	00c76733          	or	a4,a4,a2
4000f960:	00c7a783          	lw	a5,12(a5)
4000f964:	00875693          	srli	a3,a4,0x8
4000f968:	00d788a3          	sb	a3,17(a5)
4000f96c:	01075693          	srli	a3,a4,0x10
4000f970:	01875713          	srli	a4,a4,0x18
4000f974:	00c78823          	sb	a2,16(a5)
4000f978:	00d78923          	sb	a3,18(a5)
4000f97c:	00e789a3          	sb	a4,19(a5)
	if (status < 0) {
4000f980:	e81ff06f          	j	4000f800 <net_send_data+0x154>
	return pkt->iface;
4000f984:	01842903          	lw	s2,24(s0)
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000f988:	275050ef          	jal	ra,400153fc <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000f98c:	0114c703          	lbu	a4,17(s1)
4000f990:	0104c783          	lbu	a5,16(s1)
4000f994:	00054683          	lbu	a3,0(a0)
4000f998:	00871713          	slli	a4,a4,0x8
4000f99c:	00f76733          	or	a4,a4,a5
4000f9a0:	0124c783          	lbu	a5,18(s1)
4000f9a4:	01079793          	slli	a5,a5,0x10
4000f9a8:	00e7e7b3          	or	a5,a5,a4
4000f9ac:	0134c703          	lbu	a4,19(s1)
4000f9b0:	01871713          	slli	a4,a4,0x18
4000f9b4:	00f76733          	or	a4,a4,a5
4000f9b8:	00154783          	lbu	a5,1(a0)
4000f9bc:	00879793          	slli	a5,a5,0x8
4000f9c0:	00d7e7b3          	or	a5,a5,a3
4000f9c4:	00254683          	lbu	a3,2(a0)
4000f9c8:	01069693          	slli	a3,a3,0x10
4000f9cc:	00f6e6b3          	or	a3,a3,a5
4000f9d0:	00354783          	lbu	a5,3(a0)
4000f9d4:	01879793          	slli	a5,a5,0x18
4000f9d8:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000f9dc:	08f70c63          	beq	a4,a5,4000fa74 <net_send_data+0x3c8>
	return net_if_ipv4_is_addr_bcast(iface, addr);
4000f9e0:	01048593          	addi	a1,s1,16
4000f9e4:	00090513          	mv	a0,s2
4000f9e8:	68c030ef          	jal	ra,40013074 <net_if_ipv4_is_addr_bcast>
		if (net_ipv4_is_addr_loopback((struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
4000f9ec:	08051463          	bnez	a0,4000fa74 <net_send_data+0x3c8>
	return pkt->frags->data;
4000f9f0:	00842783          	lw	a5,8(s0)
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
4000f9f4:	00000593          	li	a1,0
4000f9f8:	00c7a903          	lw	s2,12(a5)
		     net_ipv4_is_my_addr((struct in_addr *)NET_IPV4_HDR(pkt)->dst))) {
4000f9fc:	01090493          	addi	s1,s2,16
4000fa00:	00048513          	mv	a0,s1
4000fa04:	0ad030ef          	jal	ra,400132b0 <net_if_ipv4_addr_lookup>
	if (!ret) {
4000fa08:	ee0510e3          	bnez	a0,4000f8e8 <net_send_data+0x23c>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000fa0c:	1f1050ef          	jal	ra,400153fc <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000fa10:	01194703          	lbu	a4,17(s2)
4000fa14:	01094783          	lbu	a5,16(s2)
4000fa18:	00054683          	lbu	a3,0(a0)
4000fa1c:	00871713          	slli	a4,a4,0x8
4000fa20:	00f76733          	or	a4,a4,a5
4000fa24:	01294783          	lbu	a5,18(s2)
4000fa28:	01079793          	slli	a5,a5,0x10
4000fa2c:	00e7e7b3          	or	a5,a5,a4
4000fa30:	01394703          	lbu	a4,19(s2)
4000fa34:	01871713          	slli	a4,a4,0x18
4000fa38:	00f76733          	or	a4,a4,a5
4000fa3c:	00154783          	lbu	a5,1(a0)
4000fa40:	00879793          	slli	a5,a5,0x8
4000fa44:	00d7e7b3          	or	a5,a5,a3
4000fa48:	00254683          	lbu	a3,2(a0)
4000fa4c:	01069693          	slli	a3,a3,0x10
4000fa50:	00f6e6b3          	or	a3,a3,a5
4000fa54:	00354783          	lbu	a5,3(a0)
4000fa58:	01879793          	slli	a5,a5,0x18
4000fa5c:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000fa60:	e8f704e3          	beq	a4,a5,4000f8e8 <net_send_data+0x23c>
	return net_if_ipv4_is_addr_bcast(iface, addr);
4000fa64:	00048593          	mv	a1,s1
4000fa68:	00000513          	li	a0,0
4000fa6c:	608030ef          	jal	ra,40013074 <net_if_ipv4_is_addr_bcast>
				     (struct in_addr *)NET_IPV4_HDR(pkt)->dst) == false &&
4000fa70:	e6051ce3          	bnez	a0,4000f8e8 <net_send_data+0x23c>
4000fa74:	00842783          	lw	a5,8(s0)
	return addr->s4_addr[0] == 127U;
4000fa78:	00c7a783          	lw	a5,12(a5)
		if (net_ipv4_is_addr_loopback((struct in_addr *)NET_IPV4_HDR(pkt)->src)) {
4000fa7c:	00c7c703          	lbu	a4,12(a5)
4000fa80:	07f00793          	li	a5,127
4000fa84:	dcf716e3          	bne	a4,a5,4000f850 <net_send_data+0x1a4>
4000fa88:	cb5ff06f          	j	4000f73c <net_send_data+0x90>
		return -ENODATA;
4000fa8c:	fc300513          	li	a0,-61
}
4000fa90:	00008067          	ret

4000fa94 <net_process_rx_packet>:
	return pkt->iface;
4000fa94:	01852603          	lw	a2,24(a0)
	pkt_len = net_pkt_get_len(pkt);
4000fa98:	00852703          	lw	a4,8(a0)
	size_t bytes = 0;
4000fa9c:	00000793          	li	a5,0
	while (buf) {
4000faa0:	02071663          	bnez	a4,4000facc <net_process_rx_packet+0x38>
	UPDATE_STAT(iface, stats.bytes.received += bytes);
4000faa4:	4003b737          	lui	a4,0x4003b
4000faa8:	ed070713          	addi	a4,a4,-304 # 4003aed0 <net_stats>
4000faac:	00872683          	lw	a3,8(a4)
	processing_data(pkt, is_loopback);
4000fab0:	00000593          	li	a1,0
4000fab4:	00f686b3          	add	a3,a3,a5
4000fab8:	00d72423          	sw	a3,8(a4)
4000fabc:	00c62703          	lw	a4,12(a2)
4000fac0:	00f707b3          	add	a5,a4,a5
4000fac4:	00f62623          	sw	a5,12(a2)
4000fac8:	aa9ff06f          	j	4000f570 <processing_data>
		bytes += buf->len;
4000facc:	01075683          	lhu	a3,16(a4)
		buf = buf->frags;
4000fad0:	00472703          	lw	a4,4(a4)
		bytes += buf->len;
4000fad4:	00d787b3          	add	a5,a5,a3
		buf = buf->frags;
4000fad8:	fc9ff06f          	j	4000faa0 <net_process_rx_packet+0xc>

4000fadc <net_recv_data>:
	if (!pkt || !iface) {
4000fadc:	0a058a63          	beqz	a1,4000fb90 <net_recv_data+0xb4>
{
4000fae0:	ff010113          	addi	sp,sp,-16
4000fae4:	00912223          	sw	s1,4(sp)
4000fae8:	00112623          	sw	ra,12(sp)
4000faec:	00050493          	mv	s1,a0
4000faf0:	00812423          	sw	s0,8(sp)
		return -EINVAL;
4000faf4:	fea00513          	li	a0,-22
	if (!pkt || !iface) {
4000faf8:	08048263          	beqz	s1,4000fb7c <net_recv_data+0xa0>
4000fafc:	0085a783          	lw	a5,8(a1)
4000fb00:	00058413          	mv	s0,a1
		return -ENODATA;
4000fb04:	fc300513          	li	a0,-61
	return !pkt->buffer || !net_pkt_data(pkt) || pkt->buffer->len == 0;
4000fb08:	06078a63          	beqz	a5,4000fb7c <net_recv_data+0xa0>
4000fb0c:	00c7a703          	lw	a4,12(a5)
4000fb10:	06070663          	beqz	a4,4000fb7c <net_recv_data+0xa0>
4000fb14:	0107d783          	lhu	a5,16(a5)
4000fb18:	06078263          	beqz	a5,4000fb7c <net_recv_data+0xa0>
	return atomic_test_bit(iface->if_dev->flags, value);
4000fb1c:	0004a503          	lw	a0,0(s1)
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
4000fb20:	00c50513          	addi	a0,a0,12
4000fb24:	765210ef          	jal	ra,40031a88 <atomic_get>
	if (!net_if_flag_is_set(iface, NET_IF_UP)) {
4000fb28:	00157793          	andi	a5,a0,1
		return -ENETDOWN;
4000fb2c:	f8d00513          	li	a0,-115
	if (!net_if_flag_is_set(iface, NET_IF_UP)) {
4000fb30:	04078663          	beqz	a5,4000fb7c <net_recv_data+0xa0>
				    (struct in6_addr *)NET_IPV6_HDR(pkt)->src);
}

static inline void net_pkt_set_overwrite(struct net_pkt *pkt, bool overwrite)
{
	pkt->overwrite = overwrite;
4000fb34:	03744783          	lbu	a5,55(s0)
	net_pkt_cursor_init(pkt);
4000fb38:	00040513          	mv	a0,s0
4000fb3c:	0017e793          	ori	a5,a5,1
4000fb40:	02f40ba3          	sb	a5,55(s0)
4000fb44:	7ad070ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	pkt->iface = iface;
4000fb48:	00942c23          	sw	s1,24(s0)
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
4000fb4c:	0004a783          	lw	a5,0(s1)
	uint8_t tc = net_rx_priority2tc(prio);
4000fb50:	04144503          	lbu	a0,65(s0)
4000fb54:	0157c783          	lbu	a5,21(a5)
4000fb58:	02f404a3          	sb	a5,41(s0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
4000fb5c:	0004a783          	lw	a5,0(s1)
4000fb60:	0157c783          	lbu	a5,21(a5)
4000fb64:	02f408a3          	sb	a5,49(s0)
4000fb68:	6b1080ef          	jal	ra,40018a18 <net_rx_priority2tc>
		net_tc_submit_to_rx_queue(tc, pkt);
4000fb6c:	0ff57513          	zext.b	a0,a0
4000fb70:	00040593          	mv	a1,s0
4000fb74:	685080ef          	jal	ra,400189f8 <net_tc_submit_to_rx_queue>
	return 0;
4000fb78:	00000513          	li	a0,0
}
4000fb7c:	00c12083          	lw	ra,12(sp)
4000fb80:	00812403          	lw	s0,8(sp)
4000fb84:	00412483          	lw	s1,4(sp)
4000fb88:	01010113          	addi	sp,sp,16
4000fb8c:	00008067          	ret
		return -EINVAL;
4000fb90:	fea00513          	li	a0,-22
}
4000fb94:	00008067          	ret

4000fb98 <sys_slist_append>:
	parent->next = child;
4000fb98:	0005a023          	sw	zero,0(a1)
	return list->tail;
4000fb9c:	00452783          	lw	a5,4(a0)
Z_GENLIST_APPEND(slist, snode)
4000fba0:	00079863          	bnez	a5,4000fbb0 <sys_slist_append+0x18>
	list->tail = node;
4000fba4:	00b52223          	sw	a1,4(a0)
	list->head = node;
4000fba8:	00b52023          	sw	a1,0(a0)
}
4000fbac:	00008067          	ret
	parent->next = child;
4000fbb0:	00b7a023          	sw	a1,0(a5)
	list->tail = node;
4000fbb4:	00b52223          	sw	a1,4(a0)
Z_GENLIST_APPEND(slist, snode)
4000fbb8:	00008067          	ret

4000fbbc <sys_slist_find_and_remove>:
	return list->head;
4000fbbc:	00052783          	lw	a5,0(a0)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4000fbc0:	00000713          	li	a4,0
4000fbc4:	00079663          	bnez	a5,4000fbd0 <sys_slist_find_and_remove+0x14>
4000fbc8:	00000513          	li	a0,0
4000fbcc:	00008067          	ret
4000fbd0:	02b79e63          	bne	a5,a1,4000fc0c <sys_slist_find_and_remove+0x50>
	return node->next;
4000fbd4:	0005a783          	lw	a5,0(a1)
Z_GENLIST_REMOVE(slist, snode)
4000fbd8:	02071063          	bnez	a4,4000fbf8 <sys_slist_find_and_remove+0x3c>
4000fbdc:	00452703          	lw	a4,4(a0)
	list->head = node;
4000fbe0:	00f52023          	sw	a5,0(a0)
Z_GENLIST_REMOVE(slist, snode)
4000fbe4:	00e59463          	bne	a1,a4,4000fbec <sys_slist_find_and_remove+0x30>
	list->tail = node;
4000fbe8:	00f52223          	sw	a5,4(a0)
	parent->next = child;
4000fbec:	0005a023          	sw	zero,0(a1)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4000fbf0:	00100513          	li	a0,1
Z_GENLIST_REMOVE(slist, snode)
4000fbf4:	00008067          	ret
	parent->next = child;
4000fbf8:	00f72023          	sw	a5,0(a4)
Z_GENLIST_REMOVE(slist, snode)
4000fbfc:	00452783          	lw	a5,4(a0)
4000fc00:	fef596e3          	bne	a1,a5,4000fbec <sys_slist_find_and_remove+0x30>
	list->tail = node;
4000fc04:	00e52223          	sw	a4,4(a0)
}
4000fc08:	fe5ff06f          	j	4000fbec <sys_slist_find_and_remove+0x30>
	return node->next;
4000fc0c:	00078713          	mv	a4,a5
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4000fc10:	0007a783          	lw	a5,0(a5)
4000fc14:	fb1ff06f          	j	4000fbc4 <sys_slist_find_and_remove+0x8>

4000fc18 <net_ipv6_is_addr_loopback>:
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4000fc18:	00154703          	lbu	a4,1(a0)
4000fc1c:	00054683          	lbu	a3,0(a0)
{
4000fc20:	00050793          	mv	a5,a0
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4000fc24:	00871713          	slli	a4,a4,0x8
4000fc28:	00d76733          	or	a4,a4,a3
4000fc2c:	00254683          	lbu	a3,2(a0)
4000fc30:	01069693          	slli	a3,a3,0x10
4000fc34:	00e6e6b3          	or	a3,a3,a4
4000fc38:	00354703          	lbu	a4,3(a0)
4000fc3c:	01871713          	slli	a4,a4,0x18
4000fc40:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000fc44:	0c071263          	bnez	a4,4000fd08 <net_ipv6_is_addr_loopback+0xf0>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4000fc48:	00554703          	lbu	a4,5(a0)
4000fc4c:	00454683          	lbu	a3,4(a0)
4000fc50:	00871713          	slli	a4,a4,0x8
4000fc54:	00d76733          	or	a4,a4,a3
4000fc58:	00654683          	lbu	a3,6(a0)
4000fc5c:	01069693          	slli	a3,a3,0x10
4000fc60:	00e6e6b3          	or	a3,a3,a4
4000fc64:	00754703          	lbu	a4,7(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000fc68:	00000513          	li	a0,0
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4000fc6c:	01871713          	slli	a4,a4,0x18
4000fc70:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4000fc74:	08071c63          	bnez	a4,4000fd0c <net_ipv6_is_addr_loopback+0xf4>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000fc78:	0097c703          	lbu	a4,9(a5)
4000fc7c:	0087c683          	lbu	a3,8(a5)
4000fc80:	00871713          	slli	a4,a4,0x8
4000fc84:	00d76733          	or	a4,a4,a3
4000fc88:	00a7c683          	lbu	a3,10(a5)
4000fc8c:	01069693          	slli	a3,a3,0x10
4000fc90:	00e6e6b3          	or	a3,a3,a4
4000fc94:	00b7c703          	lbu	a4,11(a5)
4000fc98:	01871713          	slli	a4,a4,0x18
4000fc9c:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4000fca0:	06071663          	bnez	a4,4000fd0c <net_ipv6_is_addr_loopback+0xf4>
		ntohl(UNALIGNED_GET(&addr->s6_addr32[3])) == 1;
4000fca4:	00d7c683          	lbu	a3,13(a5)
4000fca8:	00c7c703          	lbu	a4,12(a5)
4000fcac:	00869693          	slli	a3,a3,0x8
4000fcb0:	00e6e6b3          	or	a3,a3,a4
4000fcb4:	00e7c703          	lbu	a4,14(a5)
4000fcb8:	00f7c783          	lbu	a5,15(a5)
4000fcbc:	01071713          	slli	a4,a4,0x10
4000fcc0:	01879793          	slli	a5,a5,0x18
4000fcc4:	00d76733          	or	a4,a4,a3
4000fcc8:	00e7e6b3          	or	a3,a5,a4
4000fccc:	0187d513          	srli	a0,a5,0x18
4000fcd0:	01871713          	slli	a4,a4,0x18
4000fcd4:	00e56533          	or	a0,a0,a4
4000fcd8:	00010737          	lui	a4,0x10
4000fcdc:	0086d793          	srli	a5,a3,0x8
4000fce0:	f0070713          	addi	a4,a4,-256 # ff00 <__kernel_ram_size+0x43f8>
4000fce4:	00e7f7b3          	and	a5,a5,a4
4000fce8:	00f56533          	or	a0,a0,a5
4000fcec:	00869693          	slli	a3,a3,0x8
4000fcf0:	00ff07b7          	lui	a5,0xff0
4000fcf4:	00f6f6b3          	and	a3,a3,a5
4000fcf8:	00d56533          	or	a0,a0,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000fcfc:	fff50513          	addi	a0,a0,-1
4000fd00:	00153513          	seqz	a0,a0
4000fd04:	00008067          	ret
4000fd08:	00000513          	li	a0,0
}
4000fd0c:	00008067          	ret

4000fd10 <net_ipv4_is_ll_addr>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xFFFF0000) == 0xA9FE0000;
4000fd10:	00154783          	lbu	a5,1(a0)
4000fd14:	00054703          	lbu	a4,0(a0)
4000fd18:	00879793          	slli	a5,a5,0x8
4000fd1c:	00e7e7b3          	or	a5,a5,a4
4000fd20:	00254703          	lbu	a4,2(a0)
4000fd24:	01071713          	slli	a4,a4,0x10
4000fd28:	00f76733          	or	a4,a4,a5
4000fd2c:	00354783          	lbu	a5,3(a0)
4000fd30:	01879793          	slli	a5,a5,0x18
4000fd34:	00e7e6b3          	or	a3,a5,a4
4000fd38:	0187d513          	srli	a0,a5,0x18
4000fd3c:	01871713          	slli	a4,a4,0x18
4000fd40:	00e56533          	or	a0,a0,a4
4000fd44:	00010737          	lui	a4,0x10
4000fd48:	0086d793          	srli	a5,a3,0x8
4000fd4c:	f0070713          	addi	a4,a4,-256 # ff00 <__kernel_ram_size+0x43f8>
4000fd50:	00e7f7b3          	and	a5,a5,a4
4000fd54:	00f56533          	or	a0,a0,a5
4000fd58:	00869693          	slli	a3,a3,0x8
4000fd5c:	00ff07b7          	lui	a5,0xff0
4000fd60:	00f6f6b3          	and	a3,a3,a5
4000fd64:	00d56533          	or	a0,a0,a3
4000fd68:	ffff07b7          	lui	a5,0xffff0
4000fd6c:	00f57533          	and	a0,a0,a5
4000fd70:	560207b7          	lui	a5,0x56020
4000fd74:	00f50533          	add	a0,a0,a5
}
4000fd78:	00153513          	seqz	a0,a0
4000fd7c:	00008067          	ret

4000fd80 <net_if_l2>:
	if (!iface || !iface->if_dev) {
4000fd80:	00050863          	beqz	a0,4000fd90 <net_if_l2+0x10>
4000fd84:	00052503          	lw	a0,0(a0)
4000fd88:	00050463          	beqz	a0,4000fd90 <net_if_l2+0x10>
	return iface->if_dev->l2;
4000fd8c:	00452503          	lw	a0,4(a0)
}
4000fd90:	00008067          	ret

4000fd94 <l2_flags_get>:

	return NULL;
}

static enum net_l2_flags l2_flags_get(struct net_if *iface)
{
4000fd94:	ff010113          	addi	sp,sp,-16
4000fd98:	00812423          	sw	s0,8(sp)
4000fd9c:	00112623          	sw	ra,12(sp)
4000fda0:	00050413          	mv	s0,a0
	enum net_l2_flags flags = 0;

	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
4000fda4:	fddff0ef          	jal	ra,4000fd80 <net_if_l2>
4000fda8:	02050063          	beqz	a0,4000fdc8 <l2_flags_get+0x34>
4000fdac:	00c52783          	lw	a5,12(a0)
4000fdb0:	00078c63          	beqz	a5,4000fdc8 <l2_flags_get+0x34>
		flags = net_if_l2(iface)->get_flags(iface);
4000fdb4:	00040513          	mv	a0,s0
	}

	return flags;
}
4000fdb8:	00812403          	lw	s0,8(sp)
4000fdbc:	00c12083          	lw	ra,12(sp)
4000fdc0:	01010113          	addi	sp,sp,16
		flags = net_if_l2(iface)->get_flags(iface);
4000fdc4:	00078067          	jr	a5 # 56020000 <__data_region_end+0x15fdb538>
}
4000fdc8:	00c12083          	lw	ra,12(sp)
4000fdcc:	00812403          	lw	s0,8(sp)
4000fdd0:	00000513          	li	a0,0
4000fdd4:	01010113          	addi	sp,sp,16
4000fdd8:	00008067          	ret

4000fddc <get_ipaddr_diff>:

#if defined(CONFIG_NET_NATIVE_IPV4) || defined(CONFIG_NET_NATIVE_IPV6)
/* Return how many bits are shared between two IP addresses */
static uint8_t get_ipaddr_diff(const uint8_t *src, const uint8_t *dst, int addr_len)
{
4000fddc:	00050693          	mv	a3,a0
	uint8_t j, k, xor;
	uint8_t len = 0U;

	for (j = 0U; j < addr_len; j++) {
4000fde0:	00000713          	li	a4,0
4000fde4:	00371793          	slli	a5,a4,0x3
4000fde8:	0ff7f513          	zext.b	a0,a5
4000fdec:	06c75063          	bge	a4,a2,4000fe4c <get_ipaddr_diff+0x70>
		if (src[j] == dst[j]) {
4000fdf0:	00e687b3          	add	a5,a3,a4
4000fdf4:	00e58833          	add	a6,a1,a4
4000fdf8:	0007c783          	lbu	a5,0(a5)
4000fdfc:	00084803          	lbu	a6,0(a6)
4000fe00:	01079863          	bne	a5,a6,4000fe10 <get_ipaddr_diff+0x34>
	for (j = 0U; j < addr_len; j++) {
4000fe04:	00170713          	addi	a4,a4,1
4000fe08:	0ff77713          	zext.b	a4,a4
4000fe0c:	fd9ff06f          	j	4000fde4 <get_ipaddr_diff+0x8>
			len += 8U;
		} else {
			xor = src[j] ^ dst[j];
4000fe10:	0107c7b3          	xor	a5,a5,a6
			for (k = 0U; k < 8; k++) {
				if (!(xor & 0x80)) {
4000fe14:	01879713          	slli	a4,a5,0x18
4000fe18:	41875713          	srai	a4,a4,0x18
4000fe1c:	02074863          	bltz	a4,4000fe4c <get_ipaddr_diff+0x70>
4000fe20:	00850713          	addi	a4,a0,8
4000fe24:	0ff77713          	zext.b	a4,a4
					len++;
4000fe28:	00150513          	addi	a0,a0,1
					xor <<= 1;
4000fe2c:	00179793          	slli	a5,a5,0x1
					len++;
4000fe30:	0ff57513          	zext.b	a0,a0
					xor <<= 1;
4000fe34:	0ff7f793          	zext.b	a5,a5
			for (k = 0U; k < 8; k++) {
4000fe38:	00e51463          	bne	a0,a4,4000fe40 <get_ipaddr_diff+0x64>
4000fe3c:	00008067          	ret
				if (!(xor & 0x80)) {
4000fe40:	01879693          	slli	a3,a5,0x18
4000fe44:	4186d693          	srai	a3,a3,0x18
4000fe48:	fe06d0e3          	bgez	a3,4000fe28 <get_ipaddr_diff+0x4c>
			break;
		}
	}

	return len;
}
4000fe4c:	00008067          	ret

4000fe50 <net_ipv6_is_prefix>:
	if (length > 128) {
4000fe50:	08000793          	li	a5,128
4000fe54:	02c7f663          	bgeu	a5,a2,4000fe80 <net_ipv6_is_prefix+0x30>
		return false;
4000fe58:	00000513          	li	a0,0
}
4000fe5c:	00008067          	ret
		return false;
4000fe60:	00000513          	li	a0,0
}
4000fe64:	01c12083          	lw	ra,28(sp)
4000fe68:	01812403          	lw	s0,24(sp)
4000fe6c:	01412483          	lw	s1,20(sp)
4000fe70:	01012903          	lw	s2,16(sp)
4000fe74:	00c12983          	lw	s3,12(sp)
4000fe78:	02010113          	addi	sp,sp,32
4000fe7c:	00008067          	ret
{
4000fe80:	fe010113          	addi	sp,sp,-32
4000fe84:	01312623          	sw	s3,12(sp)
	if (memcmp(addr1, addr2, bytes)) {
4000fe88:	00365993          	srli	s3,a2,0x3
{
4000fe8c:	00812c23          	sw	s0,24(sp)
4000fe90:	00060413          	mv	s0,a2
	if (memcmp(addr1, addr2, bytes)) {
4000fe94:	00098613          	mv	a2,s3
{
4000fe98:	00912a23          	sw	s1,20(sp)
4000fe9c:	01212823          	sw	s2,16(sp)
4000fea0:	00112e23          	sw	ra,28(sp)
4000fea4:	00050913          	mv	s2,a0
4000fea8:	00058493          	mv	s1,a1
	if (memcmp(addr1, addr2, bytes)) {
4000feac:	dcdfc0ef          	jal	ra,4000cc78 <memcmp>
4000feb0:	fa0518e3          	bnez	a0,4000fe60 <net_ipv6_is_prefix+0x10>
4000feb4:	40800433          	neg	s0,s0
4000feb8:	00747413          	andi	s0,s0,7
		return true;
4000febc:	00100513          	li	a0,1
	if (!remain) {
4000fec0:	fa0402e3          	beqz	s0,4000fe64 <net_ipv6_is_prefix+0x14>
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
4000fec4:	01390933          	add	s2,s2,s3
4000fec8:	013484b3          	add	s1,s1,s3
4000fecc:	0004c783          	lbu	a5,0(s1)
4000fed0:	00094503          	lbu	a0,0(s2)
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
4000fed4:	00800713          	li	a4,8
4000fed8:	40870733          	sub	a4,a4,s0
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
4000fedc:	00f54533          	xor	a0,a0,a5
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
4000fee0:	0ff00793          	li	a5,255
4000fee4:	00e797b3          	sll	a5,a5,a4
4000fee8:	0ff7c793          	xori	a5,a5,255
4000feec:	008797b3          	sll	a5,a5,s0
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
4000fef0:	00f57533          	and	a0,a0,a5
4000fef4:	00153513          	seqz	a0,a0
4000fef8:	f6dff06f          	j	4000fe64 <net_ipv6_is_prefix+0x14>

4000fefc <net_ipv6_addr_cmp>:
{
4000fefc:	ff010113          	addi	sp,sp,-16
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4000ff00:	01000613          	li	a2,16
{
4000ff04:	00112623          	sw	ra,12(sp)
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4000ff08:	d71fc0ef          	jal	ra,4000cc78 <memcmp>
}
4000ff0c:	00c12083          	lw	ra,12(sp)
4000ff10:	00153513          	seqz	a0,a0
4000ff14:	01010113          	addi	sp,sp,16
4000ff18:	00008067          	ret

4000ff1c <k_uptime_get_32>:
{
4000ff1c:	ff010113          	addi	sp,sp,-16
4000ff20:	00112623          	sw	ra,12(sp)
	return z_impl_k_uptime_ticks();
4000ff24:	730210ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
}
4000ff28:	00c12083          	lw	ra,12(sp)
4000ff2c:	00a00793          	li	a5,10
4000ff30:	02a78533          	mul	a0,a5,a0
4000ff34:	01010113          	addi	sp,sp,16
4000ff38:	00008067          	ret

4000ff3c <atomic_clear_bit>:
 * @param target Address of atomic variable or array.
 * @param bit Bit number (starting from 0).
 */
static inline void atomic_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
4000ff3c:	00100713          	li	a4,1

	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
4000ff40:	0055d793          	srli	a5,a1,0x5
	atomic_val_t mask = ATOMIC_MASK(bit);
4000ff44:	00b71733          	sll	a4,a4,a1
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
4000ff48:	00279793          	slli	a5,a5,0x2
	return z_impl_atomic_and(target, value);
4000ff4c:	fff74593          	not	a1,a4
4000ff50:	00f50533          	add	a0,a0,a5
4000ff54:	3792106f          	j	40031acc <z_impl_atomic_and>

4000ff58 <iface_router_notify_deletion.constprop.0>:

static void iface_router_notify_deletion(struct net_if_router *router,
					 const char *delete_reason)
{
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
	    router->address.family == AF_INET6) {
4000ff58:	00455783          	lhu	a5,4(a0)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
4000ff5c:	00200713          	li	a4,2
4000ff60:	00e79e63          	bne	a5,a4,4000ff7c <iface_router_notify_deletion.constprop.0+0x24>
		NET_DBG("IPv6 router %s %s",
			net_sprint_ipv6_addr(net_if_router_ipv6(router)),
			delete_reason);

		net_mgmt_event_notify_with_info(NET_EVENT_IPV6_ROUTER_DEL,
4000ff64:	01852583          	lw	a1,24(a0)
4000ff68:	00850613          	addi	a2,a0,8
4000ff6c:	e0600537          	lui	a0,0xe0600
4000ff70:	01000693          	li	a3,16
4000ff74:	00a50513          	addi	a0,a0,10 # e060000a <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000b>
		   router->address.family == AF_INET) {
		NET_DBG("IPv4 router %s %s",
			net_sprint_ipv4_addr(net_if_router_ipv4(router)),
			delete_reason);

		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ROUTER_DEL,
4000ff78:	7540506f          	j	400156cc <net_mgmt_event_notify_with_info>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
4000ff7c:	00100713          	li	a4,1
4000ff80:	00e79e63          	bne	a5,a4,4000ff9c <iface_router_notify_deletion.constprop.0+0x44>
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ROUTER_DEL,
4000ff84:	01852583          	lw	a1,24(a0)
4000ff88:	00850613          	addi	a2,a0,8
4000ff8c:	e0040537          	lui	a0,0xe0040
4000ff90:	01000693          	li	a3,16
4000ff94:	00650513          	addi	a0,a0,6 # e0040006 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0040007>
4000ff98:	fe1ff06f          	j	4000ff78 <iface_router_notify_deletion.constprop.0+0x20>
						router->iface,
						&router->address.in_addr,
						sizeof(struct in6_addr));
	}
}
4000ff9c:	00008067          	ret

4000ffa0 <z_log_msg_static_create.constprop.0>:
4000ffa0:	00000693          	li	a3,0
4000ffa4:	ff1f406f          	j	40004f94 <z_impl_z_log_msg_static_create>

4000ffa8 <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
4000ffa8:	00058613          	mv	a2,a1
4000ffac:	00050593          	mv	a1,a0
	return z_impl_k_mutex_lock(mutex, timeout);
4000ffb0:	40045537          	lui	a0,0x40045
4000ffb4:	83450513          	addi	a0,a0,-1996 # 40044834 <lock>
4000ffb8:	4841f06f          	j	4002f43c <z_impl_k_mutex_lock>

4000ffbc <k_mutex_unlock.constprop.0.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
4000ffbc:	40045537          	lui	a0,0x40045
4000ffc0:	83450513          	addi	a0,a0,-1996 # 40044834 <lock>
4000ffc4:	5d41f06f          	j	4002f598 <z_impl_k_mutex_unlock>

4000ffc8 <if_ipv4_get_addr>:
	return src;
}

static struct in_addr *if_ipv4_get_addr(struct net_if *iface,
					enum net_addr_state addr_state, bool ll)
{
4000ffc8:	ff010113          	addi	sp,sp,-16
4000ffcc:	00812423          	sw	s0,8(sp)
4000ffd0:	00912223          	sw	s1,4(sp)
4000ffd4:	00050413          	mv	s0,a0
4000ffd8:	00058493          	mv	s1,a1
	struct in_addr *addr = NULL;
	struct net_if_ipv4 *ipv4;
	int i;

	k_mutex_lock(&lock, K_FOREVER);
4000ffdc:	fff00513          	li	a0,-1
4000ffe0:	fff00593          	li	a1,-1
{
4000ffe4:	01212023          	sw	s2,0(sp)
4000ffe8:	00112623          	sw	ra,12(sp)
4000ffec:	00060913          	mv	s2,a2
	k_mutex_lock(&lock, K_FOREVER);
4000fff0:	fb9ff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>

	if (!iface) {
4000fff4:	00040663          	beqz	s0,40010000 <if_ipv4_get_addr+0x38>
		goto out;
	}

	ipv4 = iface->config.ip.ipv4;
4000fff8:	0c042403          	lw	s0,192(s0)
	if (!ipv4) {
4000fffc:	02041663          	bnez	s0,40010028 <if_ipv4_get_addr+0x60>
		addr = &ipv4->unicast[i].address.in_addr;
		goto out;
	}

out:
	k_mutex_unlock(&lock);
40010000:	fbdff0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>

	return addr;
}
40010004:	00c12083          	lw	ra,12(sp)
40010008:	00040513          	mv	a0,s0
4001000c:	00812403          	lw	s0,8(sp)
40010010:	00412483          	lw	s1,4(sp)
40010014:	00012903          	lw	s2,0(sp)
40010018:	01010113          	addi	sp,sp,16
4001001c:	00008067          	ret
			if (ll) {
40010020:	fe0900e3          	beqz	s2,40010000 <if_ipv4_get_addr+0x38>
40010024:	0440006f          	j	40010068 <if_ipv4_get_addr+0xa0>
		if (!ipv4->unicast[i].is_used ||
40010028:	02c42783          	lw	a5,44(s0)
4001002c:	0197d793          	srli	a5,a5,0x19
40010030:	0017f793          	andi	a5,a5,1
40010034:	02078a63          	beqz	a5,40010068 <if_ipv4_get_addr+0xa0>
40010038:	fff00793          	li	a5,-1
4001003c:	00f48663          	beq	s1,a5,40010048 <if_ipv4_get_addr+0x80>
		    (addr_state != NET_ADDR_ANY_STATE &&
40010040:	02d40783          	lb	a5,45(s0)
40010044:	02979263          	bne	a5,s1,40010068 <if_ipv4_get_addr+0xa0>
		     ipv4->unicast[i].addr_state != addr_state) ||
40010048:	00045703          	lhu	a4,0(s0)
4001004c:	00100793          	li	a5,1
40010050:	00f71c63          	bne	a4,a5,40010068 <if_ipv4_get_addr+0xa0>
		if (net_ipv4_is_ll_addr(&ipv4->unicast[i].address.in_addr)) {
40010054:	00440413          	addi	s0,s0,4
40010058:	00040513          	mv	a0,s0
4001005c:	cb5ff0ef          	jal	ra,4000fd10 <net_ipv4_is_ll_addr>
40010060:	fc0500e3          	beqz	a0,40010020 <if_ipv4_get_addr+0x58>
			if (!ll) {
40010064:	f8091ee3          	bnez	s2,40010000 <if_ipv4_get_addr+0x38>
	struct in_addr *addr = NULL;
40010068:	00000413          	li	s0,0
4001006c:	f95ff06f          	j	40010000 <if_ipv4_get_addr+0x38>

40010070 <iface_router_lookup>:
{
40010070:	fd010113          	addi	sp,sp,-48
40010074:	01412c23          	sw	s4,24(sp)
40010078:	01512a23          	sw	s5,20(sp)
4001007c:	00058a13          	mv	s4,a1
40010080:	00050a93          	mv	s5,a0
	k_mutex_lock(&lock, K_FOREVER);
40010084:	fff00593          	li	a1,-1
40010088:	fff00513          	li	a0,-1
{
4001008c:	02812423          	sw	s0,40(sp)
40010090:	02912223          	sw	s1,36(sp)
40010094:	03212023          	sw	s2,32(sp)
40010098:	01312e23          	sw	s3,28(sp)
4001009c:	02112623          	sw	ra,44(sp)
		if (!routers[i].is_used ||
400100a0:	4003a9b7          	lui	s3,0x4003a
{
400100a4:	00060493          	mv	s1,a2
	k_mutex_lock(&lock, K_FOREVER);
400100a8:	f01ff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
		if (!routers[i].is_used ||
400100ac:	6b098793          	addi	a5,s3,1712 # 4003a6b0 <routers>
400100b0:	0227d783          	lhu	a5,34(a5)
400100b4:	4003a437          	lui	s0,0x4003a
400100b8:	6b840413          	addi	s0,s0,1720 # 4003a6b8 <routers+0x8>
400100bc:	0017f793          	andi	a5,a5,1
400100c0:	6b098993          	addi	s3,s3,1712
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
400100c4:	00000913          	li	s2,0
		if (!routers[i].is_used ||
400100c8:	08078c63          	beqz	a5,40010160 <iface_router_lookup+0xf0>
400100cc:	ffc45783          	lhu	a5,-4(s0)
400100d0:	09479863          	bne	a5,s4,40010160 <iface_router_lookup+0xf0>
		    routers[i].address.family != family ||
400100d4:	01042783          	lw	a5,16(s0)
400100d8:	09579463          	bne	a5,s5,40010160 <iface_router_lookup+0xf0>
		if ((IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6 &&
400100dc:	00200793          	li	a5,2
400100e0:	06fa0863          	beq	s4,a5,40010150 <iface_router_lookup+0xe0>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
400100e4:	0014c783          	lbu	a5,1(s1)
400100e8:	0004c703          	lbu	a4,0(s1)
400100ec:	00879793          	slli	a5,a5,0x8
400100f0:	00e7e7b3          	or	a5,a5,a4
400100f4:	0024c703          	lbu	a4,2(s1)
400100f8:	01071713          	slli	a4,a4,0x10
400100fc:	00f76733          	or	a4,a4,a5
40010100:	0034c783          	lbu	a5,3(s1)
40010104:	01879793          	slli	a5,a5,0x18
40010108:	00e7e7b3          	or	a5,a5,a4
		    (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET &&
4001010c:	00042703          	lw	a4,0(s0)
40010110:	04e79863          	bne	a5,a4,40010160 <iface_router_lookup+0xf0>
			router = &routers[i];
40010114:	02400793          	li	a5,36
40010118:	02f90933          	mul	s2,s2,a5
4001011c:	01298533          	add	a0,s3,s2
			goto out;
40010120:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
40010124:	e99ff0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40010128:	02c12083          	lw	ra,44(sp)
4001012c:	02812403          	lw	s0,40(sp)
40010130:	00c12503          	lw	a0,12(sp)
40010134:	02412483          	lw	s1,36(sp)
40010138:	02012903          	lw	s2,32(sp)
4001013c:	01c12983          	lw	s3,28(sp)
40010140:	01812a03          	lw	s4,24(sp)
40010144:	01412a83          	lw	s5,20(sp)
40010148:	03010113          	addi	sp,sp,48
4001014c:	00008067          	ret
		     net_ipv6_addr_cmp(net_if_router_ipv6(&routers[i]),
40010150:	00048593          	mv	a1,s1
40010154:	00040513          	mv	a0,s0
40010158:	da5ff0ef          	jal	ra,4000fefc <net_ipv6_addr_cmp>
		if ((IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6 &&
4001015c:	fa051ce3          	bnez	a0,40010114 <iface_router_lookup+0xa4>
	struct net_if_router *router = NULL;
40010160:	00000513          	li	a0,0
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
40010164:	fa091ee3          	bnez	s2,40010120 <iface_router_lookup+0xb0>
		if (!routers[i].is_used ||
40010168:	0469d783          	lhu	a5,70(s3)
4001016c:	0017f793          	andi	a5,a5,1
40010170:	fa0788e3          	beqz	a5,40010120 <iface_router_lookup+0xb0>
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
40010174:	02440413          	addi	s0,s0,36
40010178:	00100913          	li	s2,1
4001017c:	f51ff06f          	j	400100cc <iface_router_lookup+0x5c>

40010180 <iface_router_update_timer>:
{
40010180:	ff010113          	addi	sp,sp,-16
40010184:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
40010188:	fff00593          	li	a1,-1
{
4001018c:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
40010190:	fff00513          	li	a0,-1
{
40010194:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
40010198:	e11ff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4001019c:	400397b7          	lui	a5,0x40039
400101a0:	0687a703          	lw	a4,104(a5) # 40039068 <active_router_timers>
400101a4:	00000693          	li	a3,0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
400101a8:	00070463          	beqz	a4,400101b0 <iface_router_update_timer+0x30>
	return node->next;
400101ac:	00072683          	lw	a3,0(a4)
400101b0:	fff00513          	li	a0,-1
	ends += MSEC_PER_SEC * router->lifetime;
400101b4:	3e800613          	li	a2,1000
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
400101b8:	02071463          	bnez	a4,400101e0 <iface_router_update_timer+0x60>
	if (new_delay == UINT32_MAX) {
400101bc:	fff00793          	li	a5,-1
400101c0:	04f51e63          	bne	a0,a5,4001021c <iface_router_update_timer+0x9c>
		k_work_cancel_delayable(&router_timer);
400101c4:	4003a537          	lui	a0,0x4003a
400101c8:	a0050513          	addi	a0,a0,-1536 # 40039a00 <router_timer>
400101cc:	7a11f0ef          	jal	ra,4003016c <k_work_cancel_delayable>
}
400101d0:	00812403          	lw	s0,8(sp)
400101d4:	00c12083          	lw	ra,12(sp)
400101d8:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
400101dc:	de1ff06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>
	return (int32_t)(ends - now);
400101e0:	01c72783          	lw	a5,28(a4)
	ends += MSEC_PER_SEC * router->lifetime;
400101e4:	02075703          	lhu	a4,32(a4)
	return (int32_t)(ends - now);
400101e8:	408787b3          	sub	a5,a5,s0
	ends += MSEC_PER_SEC * router->lifetime;
400101ec:	02c70733          	mul	a4,a4,a2
	return (int32_t)(ends - now);
400101f0:	00e787b3          	add	a5,a5,a4
		if (ends <= 0) {
400101f4:	02f05263          	blez	a5,40010218 <iface_router_update_timer+0x98>
		new_delay = MIN((uint32_t)ends, new_delay);
400101f8:	00a7f463          	bgeu	a5,a0,40010200 <iface_router_update_timer+0x80>
400101fc:	00078513          	mv	a0,a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
40010200:	00000793          	li	a5,0
40010204:	00068463          	beqz	a3,4001020c <iface_router_update_timer+0x8c>
40010208:	0006a783          	lw	a5,0(a3)
4001020c:	00068713          	mv	a4,a3
40010210:	00078693          	mv	a3,a5
40010214:	fa5ff06f          	j	400101b8 <iface_router_update_timer+0x38>
			new_delay = 0;
40010218:	00000513          	li	a0,0
4001021c:	00a00613          	li	a2,10
40010220:	00000693          	li	a3,0
40010224:	00950513          	addi	a0,a0,9
40010228:	00000593          	li	a1,0
4001022c:	88cf00ef          	jal	ra,400002b8 <__udivdi3>
		k_work_reschedule(&router_timer, K_MSEC(new_delay));
40010230:	00058613          	mv	a2,a1
40010234:	00050593          	mv	a1,a0
40010238:	4003a537          	lui	a0,0x4003a
4001023c:	a0050513          	addi	a0,a0,-1536 # 40039a00 <router_timer>
40010240:	7151f0ef          	jal	ra,40030154 <k_work_reschedule>
40010244:	f8dff06f          	j	400101d0 <iface_router_update_timer+0x50>

40010248 <iface_router_add>:
{
40010248:	fd010113          	addi	sp,sp,-48
4001024c:	01412c23          	sw	s4,24(sp)
40010250:	01712623          	sw	s7,12(sp)
40010254:	00050a13          	mv	s4,a0
40010258:	00058b93          	mv	s7,a1
	k_mutex_lock(&lock, K_FOREVER);
4001025c:	fff00513          	li	a0,-1
40010260:	fff00593          	li	a1,-1
{
40010264:	03212023          	sw	s2,32(sp)
40010268:	01312e23          	sw	s3,28(sp)
4001026c:	01512a23          	sw	s5,20(sp)
40010270:	01612823          	sw	s6,16(sp)
40010274:	01812423          	sw	s8,8(sp)
		if (routers[i].is_used) {
40010278:	4003a937          	lui	s2,0x4003a
{
4001027c:	02112623          	sw	ra,44(sp)
40010280:	02812423          	sw	s0,40(sp)
40010284:	02912223          	sw	s1,36(sp)
40010288:	00060b13          	mv	s6,a2
4001028c:	00068993          	mv	s3,a3
40010290:	00070c13          	mv	s8,a4
	k_mutex_lock(&lock, K_FOREVER);
40010294:	d15ff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
		if (routers[i].is_used) {
40010298:	6b090793          	addi	a5,s2,1712 # 4003a6b0 <routers>
4001029c:	0227d783          	lhu	a5,34(a5)
400102a0:	6b090913          	addi	s2,s2,1712
400102a4:	00000a93          	li	s5,0
400102a8:	0017f793          	andi	a5,a5,1
400102ac:	04078863          	beqz	a5,400102fc <iface_router_add+0xb4>
400102b0:	04695783          	lhu	a5,70(s2)
	struct net_if_router *router = NULL;
400102b4:	00000413          	li	s0,0
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
400102b8:	00100a93          	li	s5,1
		if (routers[i].is_used) {
400102bc:	0017f793          	andi	a5,a5,1
400102c0:	02078e63          	beqz	a5,400102fc <iface_router_add+0xb4>
	k_mutex_unlock(&lock);
400102c4:	cf9ff0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
400102c8:	02c12083          	lw	ra,44(sp)
400102cc:	00040513          	mv	a0,s0
400102d0:	02812403          	lw	s0,40(sp)
400102d4:	02412483          	lw	s1,36(sp)
400102d8:	02012903          	lw	s2,32(sp)
400102dc:	01c12983          	lw	s3,28(sp)
400102e0:	01812a03          	lw	s4,24(sp)
400102e4:	01412a83          	lw	s5,20(sp)
400102e8:	01012b03          	lw	s6,16(sp)
400102ec:	00c12b83          	lw	s7,12(sp)
400102f0:	00812c03          	lw	s8,8(sp)
400102f4:	03010113          	addi	sp,sp,48
400102f8:	00008067          	ret
		routers[i].is_used = true;
400102fc:	02400493          	li	s1,36
40010300:	029a84b3          	mul	s1,s5,s1
40010304:	00990433          	add	s0,s2,s1
40010308:	02244783          	lbu	a5,34(s0)
		routers[i].iface = iface;
4001030c:	01442c23          	sw	s4,24(s0)
		routers[i].address.family = family;
40010310:	01741223          	sh	s7,4(s0)
		routers[i].is_used = true;
40010314:	0017e793          	ori	a5,a5,1
40010318:	02f40123          	sb	a5,34(s0)
		if (lifetime) {
4001031c:	060c0a63          	beqz	s8,40010390 <iface_router_add+0x148>
			routers[i].is_default = true;
40010320:	0ff7f793          	zext.b	a5,a5
40010324:	ff97f793          	andi	a5,a5,-7
40010328:	0027e793          	ori	a5,a5,2
4001032c:	02f40123          	sb	a5,34(s0)
			routers[i].lifetime = lifetime;
40010330:	03841023          	sh	s8,32(s0)
			routers[i].life_start = k_uptime_get_32();
40010334:	be9ff0ef          	jal	ra,4000ff1c <k_uptime_get_32>
40010338:	00a42e23          	sw	a0,28(s0)
			sys_slist_append(&active_router_timers,
4001033c:	40039537          	lui	a0,0x40039
40010340:	06850513          	addi	a0,a0,104 # 40039068 <active_router_timers>
40010344:	00040593          	mv	a1,s0
40010348:	851ff0ef          	jal	ra,4000fb98 <sys_slist_append>
			iface_router_update_timer(routers[i].life_start);
4001034c:	01c42503          	lw	a0,28(s0)
40010350:	e31ff0ef          	jal	ra,40010180 <iface_router_update_timer>
 * @return pointer to the IPv6 address, or NULL if none
 */
#if defined(CONFIG_NET_NATIVE_IPV6)
static inline struct in6_addr *net_if_router_ipv6(struct net_if_router *router)
{
	return &router->address.in6_addr;
40010354:	00848493          	addi	s1,s1,8
		if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40010358:	00200793          	li	a5,2
4001035c:	009904b3          	add	s1,s2,s1
40010360:	04fb9463          	bne	s7,a5,400103a8 <iface_router_add+0x160>
			memcpy(net_if_router_ipv6(&routers[i]), addr,
40010364:	01000613          	li	a2,16
40010368:	000b0593          	mv	a1,s6
4001036c:	00048513          	mv	a0,s1
40010370:	989fc0ef          	jal	ra,4000ccf8 <memcpy>
			net_mgmt_event_notify_with_info(
40010374:	e0600537          	lui	a0,0xe0600
40010378:	01000693          	li	a3,16
4001037c:	00048613          	mv	a2,s1
40010380:	000a0593          	mv	a1,s4
40010384:	00950513          	addi	a0,a0,9 # e0600009 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000a>
			net_mgmt_event_notify_with_info(
40010388:	344050ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
		goto out;
4001038c:	f39ff06f          	j	400102c4 <iface_router_add+0x7c>
			routers[i].is_default = false;
40010390:	02244783          	lbu	a5,34(s0)
			routers[i].lifetime = 0;
40010394:	02041023          	sh	zero,32(s0)
			routers[i].is_default = false;
40010398:	ff97f793          	andi	a5,a5,-7
4001039c:	0047e793          	ori	a5,a5,4
400103a0:	02f40123          	sb	a5,34(s0)
400103a4:	fb1ff06f          	j	40010354 <iface_router_add+0x10c>
			memcpy(net_if_router_ipv4(&routers[i]), addr,
400103a8:	00400613          	li	a2,4
400103ac:	000b0593          	mv	a1,s6
400103b0:	00048513          	mv	a0,s1
400103b4:	945fc0ef          	jal	ra,4000ccf8 <memcpy>
			routers[i].is_default = is_default;
400103b8:	02400793          	li	a5,36
400103bc:	02fa8ab3          	mul	s5,s5,a5
400103c0:	0019f993          	andi	s3,s3,1
400103c4:	00199993          	slli	s3,s3,0x1
			net_mgmt_event_notify_with_info(
400103c8:	e0040537          	lui	a0,0xe0040
400103cc:	00400693          	li	a3,4
400103d0:	00048613          	mv	a2,s1
400103d4:	000a0593          	mv	a1,s4
400103d8:	00550513          	addi	a0,a0,5 # e0040005 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0040006>
			routers[i].is_default = is_default;
400103dc:	01590933          	add	s2,s2,s5
400103e0:	02294783          	lbu	a5,34(s2)
400103e4:	ffd7f793          	andi	a5,a5,-3
400103e8:	0137e7b3          	or	a5,a5,s3
400103ec:	02f90123          	sb	a5,34(s2)
			net_mgmt_event_notify_with_info(
400103f0:	f99ff06f          	j	40010388 <iface_router_add+0x140>

400103f4 <iface_router_rm>:
{
400103f4:	fe010113          	addi	sp,sp,-32
400103f8:	00812c23          	sw	s0,24(sp)
	k_mutex_lock(&lock, K_FOREVER);
400103fc:	fff00593          	li	a1,-1
{
40010400:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
40010404:	fff00513          	li	a0,-1
{
40010408:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001040c:	b9dff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (!router->is_used) {
40010410:	02244783          	lbu	a5,34(s0)
	bool ret = false;
40010414:	00000513          	li	a0,0
	if (!router->is_used) {
40010418:	0017f793          	andi	a5,a5,1
4001041c:	02078c63          	beqz	a5,40010454 <iface_router_rm+0x60>
	iface_router_notify_deletion(router, "has been removed");
40010420:	00040513          	mv	a0,s0
40010424:	b35ff0ef          	jal	ra,4000ff58 <iface_router_notify_deletion.constprop.0>
	if (sys_slist_find_and_remove(&active_router_timers, &router->node)) {
40010428:	40039537          	lui	a0,0x40039
4001042c:	00040593          	mv	a1,s0
40010430:	06850513          	addi	a0,a0,104 # 40039068 <active_router_timers>
40010434:	f88ff0ef          	jal	ra,4000fbbc <sys_slist_find_and_remove>
40010438:	00050663          	beqz	a0,40010444 <iface_router_rm+0x50>
		iface_router_update_timer(k_uptime_get_32());
4001043c:	ae1ff0ef          	jal	ra,4000ff1c <k_uptime_get_32>
40010440:	d41ff0ef          	jal	ra,40010180 <iface_router_update_timer>
	router->is_used = false;
40010444:	02244783          	lbu	a5,34(s0)
	ret = true;
40010448:	00100513          	li	a0,1
	router->is_used = false;
4001044c:	ffe7f793          	andi	a5,a5,-2
40010450:	02f40123          	sb	a5,34(s0)
	ret = true;
40010454:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
40010458:	b65ff0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
4001045c:	01c12083          	lw	ra,28(sp)
40010460:	01812403          	lw	s0,24(sp)
40010464:	00c12503          	lw	a0,12(sp)
40010468:	02010113          	addi	sp,sp,32
4001046c:	00008067          	ret

40010470 <address_lifetime_timeout>:
{
40010470:	fe010113          	addi	sp,sp,-32
40010474:	00112e23          	sw	ra,28(sp)
40010478:	01312623          	sw	s3,12(sp)
4001047c:	01512223          	sw	s5,4(sp)
40010480:	00812c23          	sw	s0,24(sp)
40010484:	00912a23          	sw	s1,20(sp)
40010488:	01212823          	sw	s2,16(sp)
4001048c:	01412423          	sw	s4,8(sp)
40010490:	01612023          	sw	s6,0(sp)
	uint32_t current_time = k_uptime_get_32();
40010494:	a89ff0ef          	jal	ra,4000ff1c <k_uptime_get_32>
40010498:	00050993          	mv	s3,a0
	k_mutex_lock(&lock, K_FOREVER);
4001049c:	fff00593          	li	a1,-1
400104a0:	fff00513          	li	a0,-1
400104a4:	b05ff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
400104a8:	40039ab7          	lui	s5,0x40039
400104ac:	060aa783          	lw	a5,96(s5) # 40039060 <active_address_lifetime_timers>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_address_lifetime_timers,
400104b0:	0a078663          	beqz	a5,4001055c <address_lifetime_timeout+0xec>
	return node->next;
400104b4:	0007a403          	lw	s0,0(a5)
400104b8:	fec78913          	addi	s2,a5,-20
400104bc:	00040463          	beqz	s0,400104c4 <address_lifetime_timeout+0x54>
400104c0:	fec40413          	addi	s0,s0,-20
{
400104c4:	fff00493          	li	s1,-1
	ifaddr->addr_state = NET_ADDR_DEPRECATED;
400104c8:	00200b13          	li	s6,2
400104cc:	00c0006f          	j	400104d8 <address_lifetime_timeout+0x68>
{
400104d0:	00040913          	mv	s2,s0
400104d4:	00078413          	mv	s0,a5
		struct net_timeout *timeout = &current->lifetime;
400104d8:	01490a13          	addi	s4,s2,20
		uint32_t this_update = net_timeout_evaluate(timeout,
400104dc:	00098593          	mv	a1,s3
400104e0:	000a0513          	mv	a0,s4
400104e4:	645030ef          	jal	ra,40014328 <net_timeout_evaluate>
		if (this_update == 0U) {
400104e8:	02051c63          	bnez	a0,40010520 <address_lifetime_timeout+0xb0>
	sys_slist_find_and_remove(&active_address_lifetime_timers,
400104ec:	000a0593          	mv	a1,s4
	ifaddr->addr_state = NET_ADDR_DEPRECATED;
400104f0:	036906a3          	sb	s6,45(s2)
	sys_slist_find_and_remove(&active_address_lifetime_timers,
400104f4:	060a8513          	addi	a0,s5,96
400104f8:	ec4ff0ef          	jal	ra,4000fbbc <sys_slist_find_and_remove>
	net_timeout_set(&ifaddr->lifetime, 0, 0);
400104fc:	00000613          	li	a2,0
40010500:	00000593          	li	a1,0
40010504:	000a0513          	mv	a0,s4
40010508:	521030ef          	jal	ra,40014228 <net_timeout_set>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_address_lifetime_timers,
4001050c:	02040063          	beqz	s0,4001052c <address_lifetime_timeout+0xbc>
40010510:	01442783          	lw	a5,20(s0)
40010514:	fa078ee3          	beqz	a5,400104d0 <address_lifetime_timeout+0x60>
40010518:	fec78793          	addi	a5,a5,-20
4001051c:	fb5ff06f          	j	400104d0 <address_lifetime_timeout+0x60>
		if (this_update < next_update) {
40010520:	00957463          	bgeu	a0,s1,40010528 <address_lifetime_timeout+0xb8>
40010524:	00050493          	mv	s1,a0
		if (current == next) {
40010528:	ff2412e3          	bne	s0,s2,4001050c <address_lifetime_timeout+0x9c>
	if (next_update != UINT32_MAX) {
4001052c:	fff00793          	li	a5,-1
40010530:	02f48663          	beq	s1,a5,4001055c <address_lifetime_timeout+0xec>
		t += off;
40010534:	00948513          	addi	a0,s1,9
			return t / ((uint64_t)from_hz / to_hz);
40010538:	00a00613          	li	a2,10
4001053c:	00000693          	li	a3,0
40010540:	009535b3          	sltu	a1,a0,s1
40010544:	d75ef0ef          	jal	ra,400002b8 <__udivdi3>
		k_work_reschedule(&address_lifetime_timer, K_MSEC(next_update));
40010548:	00058613          	mv	a2,a1
4001054c:	00050593          	mv	a1,a0
40010550:	4003a537          	lui	a0,0x4003a
40010554:	9d050513          	addi	a0,a0,-1584 # 400399d0 <address_lifetime_timer>
40010558:	3fd1f0ef          	jal	ra,40030154 <k_work_reschedule>
}
4001055c:	01812403          	lw	s0,24(sp)
40010560:	01c12083          	lw	ra,28(sp)
40010564:	01412483          	lw	s1,20(sp)
40010568:	01012903          	lw	s2,16(sp)
4001056c:	00c12983          	lw	s3,12(sp)
40010570:	00812a03          	lw	s4,8(sp)
40010574:	00412a83          	lw	s5,4(sp)
40010578:	00012b03          	lw	s6,0(sp)
4001057c:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
40010580:	a3dff06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>

40010584 <iface_router_find_default.constprop.0>:
static struct net_if_router *iface_router_find_default(struct net_if *iface,
40010584:	ff010113          	addi	sp,sp,-16
40010588:	00912223          	sw	s1,4(sp)
4001058c:	01212023          	sw	s2,0(sp)
40010590:	00050493          	mv	s1,a0
40010594:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
40010598:	fff00513          	li	a0,-1
4001059c:	fff00593          	li	a1,-1
static struct net_if_router *iface_router_find_default(struct net_if *iface,
400105a0:	00112623          	sw	ra,12(sp)
400105a4:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
400105a8:	a01ff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
		if (!routers[i].is_used ||
400105ac:	4003a7b7          	lui	a5,0x4003a
400105b0:	6b078713          	addi	a4,a5,1712 # 4003a6b0 <routers>
400105b4:	02072703          	lw	a4,32(a4)
400105b8:	6b078793          	addi	a5,a5,1712
400105bc:	01075693          	srli	a3,a4,0x10
400105c0:	0016f693          	andi	a3,a3,1
400105c4:	02068263          	beqz	a3,400105e8 <iface_router_find_default.constprop.0+0x64>
		    !routers[i].is_default ||
400105c8:	01175713          	srli	a4,a4,0x11
		if (!routers[i].is_used ||
400105cc:	00177713          	andi	a4,a4,1
400105d0:	00070c63          	beqz	a4,400105e8 <iface_router_find_default.constprop.0+0x64>
		    !routers[i].is_default ||
400105d4:	0047d703          	lhu	a4,4(a5)
400105d8:	01271863          	bne	a4,s2,400105e8 <iface_router_find_default.constprop.0+0x64>
		if (iface && iface != routers[i].iface) {
400105dc:	04048063          	beqz	s1,4001061c <iface_router_find_default.constprop.0+0x98>
400105e0:	0187a703          	lw	a4,24(a5)
400105e4:	02e48c63          	beq	s1,a4,4001061c <iface_router_find_default.constprop.0+0x98>
		if (!routers[i].is_used ||
400105e8:	0447a703          	lw	a4,68(a5)
	struct net_if_router *router = NULL;
400105ec:	00000413          	li	s0,0
		if (!routers[i].is_used ||
400105f0:	01075693          	srli	a3,a4,0x10
400105f4:	0016f693          	andi	a3,a3,1
400105f8:	02068a63          	beqz	a3,4001062c <iface_router_find_default.constprop.0+0xa8>
		    !routers[i].is_default ||
400105fc:	01175713          	srli	a4,a4,0x11
		if (!routers[i].is_used ||
40010600:	00177713          	andi	a4,a4,1
40010604:	02070463          	beqz	a4,4001062c <iface_router_find_default.constprop.0+0xa8>
		    !routers[i].is_default ||
40010608:	0287d703          	lhu	a4,40(a5)
4001060c:	03271063          	bne	a4,s2,4001062c <iface_router_find_default.constprop.0+0xa8>
		if (iface && iface != routers[i].iface) {
40010610:	02049e63          	bnez	s1,4001064c <iface_router_find_default.constprop.0+0xc8>
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
40010614:	00100413          	li	s0,1
40010618:	0080006f          	j	40010620 <iface_router_find_default.constprop.0+0x9c>
4001061c:	00000413          	li	s0,0
		router = &routers[i];
40010620:	02400713          	li	a4,36
40010624:	02e40433          	mul	s0,s0,a4
40010628:	00878433          	add	s0,a5,s0
	k_mutex_unlock(&lock);
4001062c:	991ff0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40010630:	00c12083          	lw	ra,12(sp)
40010634:	00040513          	mv	a0,s0
40010638:	00812403          	lw	s0,8(sp)
4001063c:	00412483          	lw	s1,4(sp)
40010640:	00012903          	lw	s2,0(sp)
40010644:	01010113          	addi	sp,sp,16
40010648:	00008067          	ret
		if (iface && iface != routers[i].iface) {
4001064c:	03c7a703          	lw	a4,60(a5)
40010650:	fce49ee3          	bne	s1,a4,4001062c <iface_router_find_default.constprop.0+0xa8>
40010654:	fc1ff06f          	j	40010614 <iface_router_find_default.constprop.0+0x90>

40010658 <net_if_flag_is_set>:
	if (iface == NULL) {
40010658:	02050c63          	beqz	a0,40010690 <net_if_flag_is_set+0x38>
{
4001065c:	ff010113          	addi	sp,sp,-16
40010660:	00812423          	sw	s0,8(sp)
40010664:	00112623          	sw	ra,12(sp)
	return atomic_test_bit(iface->if_dev->flags, value);
40010668:	00052503          	lw	a0,0(a0)
4001066c:	00058413          	mv	s0,a1
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
40010670:	00c50513          	addi	a0,a0,12
40010674:	414210ef          	jal	ra,40031a88 <atomic_get>
}
40010678:	00c12083          	lw	ra,12(sp)
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
4001067c:	40855533          	sra	a0,a0,s0
40010680:	00812403          	lw	s0,8(sp)
40010684:	00157513          	andi	a0,a0,1
40010688:	01010113          	addi	sp,sp,16
4001068c:	00008067          	ret
		return false;
40010690:	00000513          	li	a0,0
}
40010694:	00008067          	ret

40010698 <net_if_ipv6_start_dad>:
{
40010698:	ff010113          	addi	sp,sp,-16
4001069c:	00812423          	sw	s0,8(sp)
400106a0:	00912223          	sw	s1,4(sp)
400106a4:	00112623          	sw	ra,12(sp)
400106a8:	00058413          	mv	s0,a1
	ifaddr->addr_state = NET_ADDR_TENTATIVE;
400106ac:	020586a3          	sb	zero,45(a1)
 */
static inline bool net_if_is_up(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_UP) &&
400106b0:	00000593          	li	a1,0
{
400106b4:	00050493          	mv	s1,a0
400106b8:	fa1ff0ef          	jal	ra,40010658 <net_if_flag_is_set>
400106bc:	06050e63          	beqz	a0,40010738 <net_if_ipv6_start_dad+0xa0>
	       net_if_flag_is_set(iface, NET_IF_RUNNING);
400106c0:	00800593          	li	a1,8
400106c4:	00048513          	mv	a0,s1
400106c8:	f91ff0ef          	jal	ra,40010658 <net_if_flag_is_set>
	return net_if_flag_is_set(iface, NET_IF_UP) &&
400106cc:	06050663          	beqz	a0,40010738 <net_if_ipv6_start_dad+0xa0>
		ifaddr->dad_count = 1U;
400106d0:	00100793          	li	a5,1
400106d4:	02f40723          	sb	a5,46(s0)
		if (!net_ipv6_start_dad(iface, ifaddr)) {
400106d8:	00040593          	mv	a1,s0
400106dc:	00048513          	mv	a0,s1
400106e0:	0840e0ef          	jal	ra,4001e764 <net_ipv6_start_dad>
400106e4:	04051a63          	bnez	a0,40010738 <net_if_ipv6_start_dad+0xa0>
			ifaddr->dad_start = k_uptime_get_32();
400106e8:	835ff0ef          	jal	ra,4000ff1c <k_uptime_get_32>
400106ec:	02a42423          	sw	a0,40(s0)
			sys_slist_append(&active_dad_timers, &ifaddr->dad_node);
400106f0:	40039537          	lui	a0,0x40039
400106f4:	02440593          	addi	a1,s0,36
400106f8:	05050513          	addi	a0,a0,80 # 40039050 <active_dad_timers>
400106fc:	c9cff0ef          	jal	ra,4000fb98 <sys_slist_append>
	return z_timeout_remaining(&dwork->timeout);
40010700:	4003a537          	lui	a0,0x4003a
40010704:	98050513          	addi	a0,a0,-1664 # 40039980 <dad_timer+0x10>
40010708:	581200ef          	jal	ra,40031488 <z_timeout_remaining>
			if (!k_work_delayable_remaining_get(&dad_timer)) {
4001070c:	00b56533          	or	a0,a0,a1
40010710:	02051463          	bnez	a0,40010738 <net_if_ipv6_start_dad+0xa0>
}
40010714:	00812403          	lw	s0,8(sp)
40010718:	00c12083          	lw	ra,12(sp)
4001071c:	00412483          	lw	s1,4(sp)
				k_work_reschedule(&dad_timer,
40010720:	4003a537          	lui	a0,0x4003a
40010724:	00a00593          	li	a1,10
40010728:	00000613          	li	a2,0
4001072c:	97050513          	addi	a0,a0,-1680 # 40039970 <dad_timer>
}
40010730:	01010113          	addi	sp,sp,16
				k_work_reschedule(&dad_timer,
40010734:	2211f06f          	j	40030154 <k_work_reschedule>
}
40010738:	00c12083          	lw	ra,12(sp)
4001073c:	00812403          	lw	s0,8(sp)
40010740:	00412483          	lw	s1,4(sp)
40010744:	01010113          	addi	sp,sp,16
40010748:	00008067          	ret

4001074c <net_if_ipv4_get_best_match.isra.0>:
static struct in_addr *net_if_ipv4_get_best_match(struct net_if *iface,
4001074c:	fe010113          	addi	sp,sp,-32
40010750:	01212823          	sw	s2,16(sp)
40010754:	00112e23          	sw	ra,28(sp)
40010758:	00812c23          	sw	s0,24(sp)
4001075c:	00912a23          	sw	s1,20(sp)
40010760:	01312623          	sw	s3,12(sp)
		return NULL;
40010764:	00000913          	li	s2,0
	if (!ipv4) {
40010768:	06050263          	beqz	a0,400107cc <net_if_ipv4_get_best_match.isra.0+0x80>
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
4001076c:	02c52703          	lw	a4,44(a0)
40010770:	020106b7          	lui	a3,0x2010
40010774:	020007b7          	lui	a5,0x2000
40010778:	f0068693          	addi	a3,a3,-256 # 200ff00 <__rom_region_size+0x1fd6f44>
4001077c:	10078793          	addi	a5,a5,256 # 2000100 <__rom_region_size+0x1fc7144>
40010780:	00d77733          	and	a4,a4,a3
40010784:	04f71463          	bne	a4,a5,400107cc <net_if_ipv4_get_best_match.isra.0+0x80>
40010788:	00055703          	lhu	a4,0(a0)
4001078c:	00100793          	li	a5,1
40010790:	02f71e63          	bne	a4,a5,400107cc <net_if_ipv4_get_best_match.isra.0+0x80>
	    !net_ipv4_is_ll_addr(&addr->address.in_addr)) {
40010794:	00450413          	addi	s0,a0,4
40010798:	00040513          	mv	a0,s0
4001079c:	00058993          	mv	s3,a1
400107a0:	00060493          	mv	s1,a2
400107a4:	d6cff0ef          	jal	ra,4000fd10 <net_ipv4_is_ll_addr>
	    addr->address.family == AF_INET &&
400107a8:	02051263          	bnez	a0,400107cc <net_if_ipv4_get_best_match.isra.0+0x80>
	return get_ipaddr_diff((const uint8_t *)src, (const uint8_t *)dst, 4);
400107ac:	00400613          	li	a2,4
400107b0:	00040593          	mv	a1,s0
400107b4:	00098513          	mv	a0,s3
400107b8:	e24ff0ef          	jal	ra,4000fddc <get_ipaddr_diff>
		if (len >= *best_so_far) {
400107bc:	0004c783          	lbu	a5,0(s1)
400107c0:	00f56663          	bltu	a0,a5,400107cc <net_if_ipv4_get_best_match.isra.0+0x80>
			*best_so_far = len;
400107c4:	00a48023          	sb	a0,0(s1)
	    !net_ipv4_is_ll_addr(&addr->address.in_addr)) {
400107c8:	00040913          	mv	s2,s0
}
400107cc:	01c12083          	lw	ra,28(sp)
400107d0:	01812403          	lw	s0,24(sp)
400107d4:	01412483          	lw	s1,20(sp)
400107d8:	00c12983          	lw	s3,12(sp)
400107dc:	00090513          	mv	a0,s2
400107e0:	01012903          	lw	s2,16(sp)
400107e4:	02010113          	addi	sp,sp,32
400107e8:	00008067          	ret

400107ec <net_if_ipv6_get_best_match.isra.0>:
static struct in6_addr *net_if_ipv6_get_best_match(struct net_if *iface,
400107ec:	fc010113          	addi	sp,sp,-64
400107f0:	03612023          	sw	s6,32(sp)
400107f4:	02112e23          	sw	ra,60(sp)
400107f8:	02812c23          	sw	s0,56(sp)
400107fc:	02912a23          	sw	s1,52(sp)
40010800:	03212823          	sw	s2,48(sp)
40010804:	03312623          	sw	s3,44(sp)
40010808:	03412423          	sw	s4,40(sp)
4001080c:	03512223          	sw	s5,36(sp)
40010810:	01712e23          	sw	s7,28(sp)
40010814:	01812c23          	sw	s8,24(sp)
40010818:	01912a23          	sw	s9,20(sp)
4001081c:	01a12823          	sw	s10,16(sp)
40010820:	01b12623          	sw	s11,12(sp)
		return NULL;
40010824:	00000b13          	li	s6,0
	if (!ipv6) {
40010828:	0c050863          	beqz	a0,400108f8 <net_if_ipv6_get_best_match.isra.0+0x10c>
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
4001082c:	02010bb7          	lui	s7,0x2010
40010830:	02000c37          	lui	s8,0x2000
40010834:	00050913          	mv	s2,a0
40010838:	00058993          	mv	s3,a1
4001083c:	00060a93          	mv	s5,a2
40010840:	00050413          	mv	s0,a0
	struct in6_addr *src = NULL;
40010844:	00000b13          	li	s6,0
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40010848:	00000a13          	li	s4,0
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
4001084c:	03000d93          	li	s11,48
40010850:	f00b8b93          	addi	s7,s7,-256 # 200ff00 <__rom_region_size+0x1fd6f44>
40010854:	100c0c13          	addi	s8,s8,256 # 2000100 <__rom_region_size+0x1fc7144>
40010858:	00200693          	li	a3,2
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4001085c:	00300d13          	li	s10,3
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
40010860:	03ba07b3          	mul	a5,s4,s11
40010864:	00f907b3          	add	a5,s2,a5
40010868:	02c7a483          	lw	s1,44(a5)
4001086c:	0174f7b3          	and	a5,s1,s7
40010870:	07879e63          	bne	a5,s8,400108ec <net_if_ipv6_get_best_match.isra.0+0x100>
40010874:	00045783          	lhu	a5,0(s0)
40010878:	06d79a63          	bne	a5,a3,400108ec <net_if_ipv6_get_best_match.isra.0+0x100>
	return UNALIGNED_GET(&addr->s6_addr16[0]) == htons(0xFE80);
4001087c:	00544783          	lbu	a5,5(s0)
40010880:	00444703          	lbu	a4,4(s0)
40010884:	00879793          	slli	a5,a5,0x8
	    addr->address.family == AF_INET6 &&
40010888:	00e7e7b3          	or	a5,a5,a4
4001088c:	00008737          	lui	a4,0x8
40010890:	0fe70713          	addi	a4,a4,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
40010894:	04e78c63          	beq	a5,a4,400108ec <net_if_ipv6_get_best_match.isra.0+0x100>
		len = get_diff_ipv6(dst, &ipv6->unicast[i].address.in6_addr);
40010898:	00440c93          	addi	s9,s0,4
	return get_ipaddr_diff((const uint8_t *)src, (const uint8_t *)dst, 16);
4001089c:	01000613          	li	a2,16
400108a0:	000c8593          	mv	a1,s9
400108a4:	00098513          	mv	a0,s3
400108a8:	d34ff0ef          	jal	ra,4000fddc <get_ipaddr_diff>
		if (len >= *best_so_far) {
400108ac:	000ac783          	lbu	a5,0(s5)
400108b0:	00200693          	li	a3,2
400108b4:	02f56c63          	bltu	a0,a5,400108ec <net_if_ipv6_get_best_match.isra.0+0x100>
			if (ipv6->unicast[i].is_mesh_local && len < 64 &&
400108b8:	01a4d493          	srli	s1,s1,0x1a
400108bc:	0014f493          	andi	s1,s1,1
400108c0:	02048263          	beqz	s1,400108e4 <net_if_ipv6_get_best_match.isra.0+0xf8>
400108c4:	03f00793          	li	a5,63
400108c8:	00a7ee63          	bltu	a5,a0,400108e4 <net_if_ipv6_get_best_match.isra.0+0xf8>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
400108cc:	0009c703          	lbu	a4,0(s3)
400108d0:	0ff00793          	li	a5,255
400108d4:	00f71c63          	bne	a4,a5,400108ec <net_if_ipv6_get_best_match.isra.0+0x100>
400108d8:	0019c703          	lbu	a4,1(s3)
400108dc:	00300793          	li	a5,3
400108e0:	00f71663          	bne	a4,a5,400108ec <net_if_ipv6_get_best_match.isra.0+0x100>
			*best_so_far = len;
400108e4:	00aa8023          	sb	a0,0(s5)
			src = &ipv6->unicast[i].address.in6_addr;
400108e8:	000c8b13          	mv	s6,s9
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
400108ec:	001a0a13          	addi	s4,s4,1
400108f0:	03040413          	addi	s0,s0,48
400108f4:	f7aa16e3          	bne	s4,s10,40010860 <net_if_ipv6_get_best_match.isra.0+0x74>
}
400108f8:	03c12083          	lw	ra,60(sp)
400108fc:	03812403          	lw	s0,56(sp)
40010900:	03412483          	lw	s1,52(sp)
40010904:	03012903          	lw	s2,48(sp)
40010908:	02c12983          	lw	s3,44(sp)
4001090c:	02812a03          	lw	s4,40(sp)
40010910:	02412a83          	lw	s5,36(sp)
40010914:	01c12b83          	lw	s7,28(sp)
40010918:	01812c03          	lw	s8,24(sp)
4001091c:	01412c83          	lw	s9,20(sp)
40010920:	01012d03          	lw	s10,16(sp)
40010924:	00c12d83          	lw	s11,12(sp)
40010928:	000b0513          	mv	a0,s6
4001092c:	02012b03          	lw	s6,32(sp)
40010930:	04010113          	addi	sp,sp,64
40010934:	00008067          	ret

40010938 <need_calc_checksum>:

	k_mutex_unlock(&lock);
}

static bool need_calc_checksum(struct net_if *iface, enum ethernet_hw_caps caps)
{
40010938:	ff010113          	addi	sp,sp,-16
4001093c:	00812423          	sw	s0,8(sp)
40010940:	00912223          	sw	s1,4(sp)
40010944:	00112623          	sw	ra,12(sp)
40010948:	00050493          	mv	s1,a0
4001094c:	00058413          	mv	s0,a1
#if defined(CONFIG_NET_L2_ETHERNET)
	if (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {
40010950:	c30ff0ef          	jal	ra,4000fd80 <net_if_l2>
40010954:	400457b7          	lui	a5,0x40045
40010958:	ab878793          	addi	a5,a5,-1352 # 40044ab8 <_net_l2_ETHERNET>
4001095c:	04a79063          	bne	a5,a0,4001099c <need_calc_checksum+0x64>
	return iface->if_dev->dev;
40010960:	0004a783          	lw	a5,0(s1)
40010964:	0007a503          	lw	a0,0(a5)
	if (!eth->get_capabilities) {
40010968:	00852783          	lw	a5,8(a0)
4001096c:	0107a703          	lw	a4,16(a5)
		return (enum ethernet_hw_caps)0;
40010970:	00000793          	li	a5,0
	if (!eth->get_capabilities) {
40010974:	00070663          	beqz	a4,40010980 <need_calc_checksum+0x48>
	return eth->get_capabilities(net_if_get_device(iface));
40010978:	000700e7          	jalr	a4
4001097c:	00050793          	mv	a5,a0
		return true;
	}

	return !(net_eth_get_hw_capabilities(iface) & caps);
40010980:	00f47533          	and	a0,s0,a5
40010984:	00153513          	seqz	a0,a0
	ARG_UNUSED(iface);
	ARG_UNUSED(caps);

	return true;
#endif
}
40010988:	00c12083          	lw	ra,12(sp)
4001098c:	00812403          	lw	s0,8(sp)
40010990:	00412483          	lw	s1,4(sp)
40010994:	01010113          	addi	sp,sp,16
40010998:	00008067          	ret
		return true;
4001099c:	00100513          	li	a0,1
400109a0:	fe9ff06f          	j	40010988 <need_calc_checksum+0x50>

400109a4 <net_if_flag_set.isra.0>:
	return z_impl_atomic_or(target, value);
400109a4:	00100793          	li	a5,1
400109a8:	00b795b3          	sll	a1,a5,a1
400109ac:	00c50513          	addi	a0,a0,12
400109b0:	0fc2106f          	j	40031aac <z_impl_atomic_or>

400109b4 <net_if_flag_test_and_set.isra.0>:
static inline bool net_if_flag_test_and_set(struct net_if *iface,
400109b4:	ff010113          	addi	sp,sp,-16
400109b8:	00812423          	sw	s0,8(sp)
	atomic_val_t mask = ATOMIC_MASK(bit);
400109bc:	00100413          	li	s0,1
400109c0:	00112623          	sw	ra,12(sp)
400109c4:	00b41433          	sll	s0,s0,a1
400109c8:	00040593          	mv	a1,s0
400109cc:	00c50513          	addi	a0,a0,12
400109d0:	0dc210ef          	jal	ra,40031aac <z_impl_atomic_or>
}
400109d4:	00c12083          	lw	ra,12(sp)
	return (old & mask) != 0;
400109d8:	00a47533          	and	a0,s0,a0
400109dc:	00812403          	lw	s0,8(sp)
400109e0:	00a03533          	snez	a0,a0
400109e4:	01010113          	addi	sp,sp,16
400109e8:	00008067          	ret

400109ec <atomic_test_and_clear_bit>:
{
400109ec:	ff010113          	addi	sp,sp,-16
400109f0:	00812423          	sw	s0,8(sp)
	atomic_val_t mask = ATOMIC_MASK(bit);
400109f4:	00100413          	li	s0,1
{
400109f8:	00112623          	sw	ra,12(sp)
	atomic_val_t mask = ATOMIC_MASK(bit);
400109fc:	00b41433          	sll	s0,s0,a1
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
40010a00:	0055d593          	srli	a1,a1,0x5
40010a04:	00259793          	slli	a5,a1,0x2
	return z_impl_atomic_and(target, value);
40010a08:	00f50533          	add	a0,a0,a5
40010a0c:	fff44593          	not	a1,s0
40010a10:	0bc210ef          	jal	ra,40031acc <z_impl_atomic_and>
}
40010a14:	00c12083          	lw	ra,12(sp)
	return (old & mask) != 0;
40010a18:	00a47533          	and	a0,s0,a0
}
40010a1c:	00812403          	lw	s0,8(sp)
40010a20:	00a03533          	snez	a0,a0
40010a24:	01010113          	addi	sp,sp,16
40010a28:	00008067          	ret

40010a2c <iface_router_expired>:
{
40010a2c:	fe010113          	addi	sp,sp,-32
40010a30:	00112e23          	sw	ra,28(sp)
40010a34:	00812c23          	sw	s0,24(sp)
40010a38:	00912a23          	sw	s1,20(sp)
40010a3c:	01312623          	sw	s3,12(sp)
40010a40:	01212823          	sw	s2,16(sp)
40010a44:	01412423          	sw	s4,8(sp)
40010a48:	01512223          	sw	s5,4(sp)
	uint32_t current_time = k_uptime_get_32();
40010a4c:	cd0ff0ef          	jal	ra,4000ff1c <k_uptime_get_32>
40010a50:	00050993          	mv	s3,a0
	k_mutex_lock(&lock, K_FOREVER);
40010a54:	fff00593          	li	a1,-1
40010a58:	fff00513          	li	a0,-1
	return list->head;
40010a5c:	400394b7          	lui	s1,0x40039
40010a60:	d48ff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
40010a64:	0684a403          	lw	s0,104(s1) # 40039068 <active_router_timers>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
40010a68:	00040c63          	beqz	s0,40010a80 <iface_router_expired+0x54>
	return node->next;
40010a6c:	00042a03          	lw	s4,0(s0)
40010a70:	06848493          	addi	s1,s1,104
40010a74:	00000913          	li	s2,0
	ends += MSEC_PER_SEC * router->lifetime;
40010a78:	3e800a93          	li	s5,1000
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
40010a7c:	02041863          	bnez	s0,40010aac <iface_router_expired+0x80>
	iface_router_update_timer(current_time);
40010a80:	00098513          	mv	a0,s3
40010a84:	efcff0ef          	jal	ra,40010180 <iface_router_update_timer>
}
40010a88:	01812403          	lw	s0,24(sp)
40010a8c:	01c12083          	lw	ra,28(sp)
40010a90:	01412483          	lw	s1,20(sp)
40010a94:	01012903          	lw	s2,16(sp)
40010a98:	00c12983          	lw	s3,12(sp)
40010a9c:	00812a03          	lw	s4,8(sp)
40010aa0:	00412a83          	lw	s5,4(sp)
40010aa4:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
40010aa8:	d14ff06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>
	ends += MSEC_PER_SEC * router->lifetime;
40010aac:	02045703          	lhu	a4,32(s0)
	return (int32_t)(ends - now);
40010ab0:	01c42783          	lw	a5,28(s0)
			prev_node = &router->node;
40010ab4:	00040693          	mv	a3,s0
	ends += MSEC_PER_SEC * router->lifetime;
40010ab8:	03570733          	mul	a4,a4,s5
	return (int32_t)(ends - now);
40010abc:	413787b3          	sub	a5,a5,s3
40010ac0:	00e787b3          	add	a5,a5,a4
		if (ends > 0) {
40010ac4:	02f04c63          	bgtz	a5,40010afc <iface_router_expired+0xd0>
		iface_router_notify_deletion(router, "has expired");
40010ac8:	00040513          	mv	a0,s0
40010acc:	c8cff0ef          	jal	ra,4000ff58 <iface_router_notify_deletion.constprop.0>
Z_GENLIST_REMOVE(slist, snode)
40010ad0:	00042783          	lw	a5,0(s0)
40010ad4:	04091263          	bnez	s2,40010b18 <iface_router_expired+0xec>
40010ad8:	0044a703          	lw	a4,4(s1)
	list->head = node;
40010adc:	00f4a023          	sw	a5,0(s1)
Z_GENLIST_REMOVE(slist, snode)
40010ae0:	00e41463          	bne	s0,a4,40010ae8 <iface_router_expired+0xbc>
	list->tail = node;
40010ae4:	00f4a223          	sw	a5,4(s1)
		router->is_used = false;
40010ae8:	02244783          	lbu	a5,34(s0)
	parent->next = child;
40010aec:	00042023          	sw	zero,0(s0)
40010af0:	00090693          	mv	a3,s2
40010af4:	ffe7f793          	andi	a5,a5,-2
40010af8:	02f40123          	sb	a5,34(s0)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
40010afc:	00000793          	li	a5,0
40010b00:	000a0463          	beqz	s4,40010b08 <iface_router_expired+0xdc>
	return node->next;
40010b04:	000a2783          	lw	a5,0(s4)
40010b08:	000a0413          	mv	s0,s4
40010b0c:	00068913          	mv	s2,a3
40010b10:	00078a13          	mv	s4,a5
40010b14:	f69ff06f          	j	40010a7c <iface_router_expired+0x50>
	parent->next = child;
40010b18:	00f92023          	sw	a5,0(s2)
Z_GENLIST_REMOVE(slist, snode)
40010b1c:	0044a783          	lw	a5,4(s1)
40010b20:	fcf414e3          	bne	s0,a5,40010ae8 <iface_router_expired+0xbc>
	list->tail = node;
40010b24:	0124a223          	sw	s2,4(s1)
}
40010b28:	fc1ff06f          	j	40010ae8 <iface_router_expired+0xbc>

40010b2c <z_impl_net_if_get_by_index>:
	if (index <= 0) {
40010b2c:	02a05463          	blez	a0,40010b54 <z_impl_net_if_get_by_index+0x28>
	if (&_net_if_list_start[index - 1] >= _net_if_list_end) {
40010b30:	0c400793          	li	a5,196
40010b34:	fff50513          	addi	a0,a0,-1
40010b38:	02f50533          	mul	a0,a0,a5
40010b3c:	400457b7          	lui	a5,0x40045
40010b40:	9d878793          	addi	a5,a5,-1576 # 400449d8 <__net_if_dts_ord_12_0>
40010b44:	00f50533          	add	a0,a0,a5
40010b48:	400457b7          	lui	a5,0x40045
40010b4c:	a9c78793          	addi	a5,a5,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
40010b50:	00f56463          	bltu	a0,a5,40010b58 <z_impl_net_if_get_by_index+0x2c>
		return NULL;
40010b54:	00000513          	li	a0,0
}
40010b58:	00008067          	ret

40010b5c <net_if_get_by_index>:
		union { uintptr_t x; int val; } parm0 = { .val = index };
		return (struct net_if *) arch_syscall_invoke1(parm0.x, K_SYSCALL_NET_IF_GET_BY_INDEX);
	}
#endif
	compiler_barrier();
	return z_impl_net_if_get_by_index(index);
40010b5c:	fd1ff06f          	j	40010b2c <z_impl_net_if_get_by_index>

40010b60 <net_context_send_cb>:
	if (!context) {
40010b60:	08050e63          	beqz	a0,40010bfc <net_context_send_cb+0x9c>
{
40010b64:	ff010113          	addi	sp,sp,-16
40010b68:	00812423          	sw	s0,8(sp)
40010b6c:	00112623          	sw	ra,12(sp)
	if (context->send_cb) {
40010b70:	04c52783          	lw	a5,76(a0)
40010b74:	00050413          	mv	s0,a0
40010b78:	00078663          	beqz	a5,40010b84 <net_context_send_cb+0x24>
		context->send_cb(context, status, context->user_data);
40010b7c:	00452603          	lw	a2,4(a0)
40010b80:	000780e7          	jalr	a5
 *
 * @return Network context IP protocol.
 */
static inline uint16_t net_context_get_proto(struct net_context *context)
{
	return context->proto;
40010b84:	07245783          	lhu	a5,114(s0)
	if (IS_ENABLED(CONFIG_NET_UDP) &&
40010b88:	01100713          	li	a4,17
40010b8c:	02e79e63          	bne	a5,a4,40010bc8 <net_context_send_cb+0x68>
static inline
struct net_if *net_context_get_iface(struct net_context *context)
{
	NET_ASSERT(context);

	return net_if_get_by_index(context->iface);
40010b90:	07640503          	lb	a0,118(s0)
40010b94:	fc9ff0ef          	jal	ra,40010b5c <net_if_get_by_index>

#if defined(CONFIG_NET_STATISTICS_UDP) && defined(CONFIG_NET_NATIVE_UDP)
/* UDP stats */
static inline void net_stats_update_udp_sent(struct net_if *iface)
{
	UPDATE_STAT(iface, stats.udp.sent++);
40010b98:	4003b7b7          	lui	a5,0x4003b
40010b9c:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40010ba0:	0987a703          	lw	a4,152(a5)
40010ba4:	00170713          	addi	a4,a4,1
40010ba8:	08e7ac23          	sw	a4,152(a5)
40010bac:	09c52783          	lw	a5,156(a0)
40010bb0:	00178793          	addi	a5,a5,1
40010bb4:	08f52e23          	sw	a5,156(a0)
}
40010bb8:	00c12083          	lw	ra,12(sp)
40010bbc:	00812403          	lw	s0,8(sp)
40010bc0:	01010113          	addi	sp,sp,16
40010bc4:	00008067          	ret
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
40010bc8:	00600713          	li	a4,6
40010bcc:	fee796e3          	bne	a5,a4,40010bb8 <net_context_send_cb+0x58>
40010bd0:	07640503          	lb	a0,118(s0)
40010bd4:	f89ff0ef          	jal	ra,40010b5c <net_if_get_by_index>
	UPDATE_STAT(iface, stats.tcp.drop++);
}

static inline void net_stats_update_tcp_seg_sent(struct net_if *iface)
{
	UPDATE_STAT(iface, stats.tcp.sent++);
40010bd8:	4003b7b7          	lui	a5,0x4003b
40010bdc:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40010be0:	06c7a703          	lw	a4,108(a5)
40010be4:	00170713          	addi	a4,a4,1
40010be8:	06e7a623          	sw	a4,108(a5)
40010bec:	07052783          	lw	a5,112(a0)
40010bf0:	00178793          	addi	a5,a5,1
40010bf4:	06f52823          	sw	a5,112(a0)
}
40010bf8:	fc1ff06f          	j	40010bb8 <net_context_send_cb+0x58>
40010bfc:	00008067          	ret

40010c00 <net_if_stats_reset>:
	STRUCT_SECTION_FOREACH(net_if, tmp) {
40010c00:	400457b7          	lui	a5,0x40045
40010c04:	40045737          	lui	a4,0x40045
40010c08:	9d878793          	addi	a5,a5,-1576 # 400449d8 <__net_if_dts_ord_12_0>
40010c0c:	a9c70713          	addi	a4,a4,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
40010c10:	00e7e463          	bltu	a5,a4,40010c18 <net_if_stats_reset+0x18>
}
40010c14:	00008067          	ret
		if (iface == tmp) {
40010c18:	00a79a63          	bne	a5,a0,40010c2c <net_if_stats_reset+0x2c>
			memset(&iface->stats, 0, sizeof(iface->stats));
40010c1c:	0b800613          	li	a2,184
40010c20:	00000593          	li	a1,0
40010c24:	00478513          	addi	a0,a5,4
40010c28:	8f4fc06f          	j	4000cd1c <memset>
	STRUCT_SECTION_FOREACH(net_if, tmp) {
40010c2c:	0c478793          	addi	a5,a5,196
40010c30:	fe1ff06f          	j	40010c10 <net_if_stats_reset+0x10>

40010c34 <net_if_stats_reset_all>:
{
40010c34:	ff010113          	addi	sp,sp,-16
40010c38:	00812423          	sw	s0,8(sp)
40010c3c:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
40010c40:	fff00513          	li	a0,-1
40010c44:	fff00593          	li	a1,-1
	STRUCT_SECTION_FOREACH(net_if, iface) {
40010c48:	40045437          	lui	s0,0x40045
40010c4c:	400454b7          	lui	s1,0x40045
{
40010c50:	00112623          	sw	ra,12(sp)
	STRUCT_SECTION_FOREACH(net_if, iface) {
40010c54:	9d840413          	addi	s0,s0,-1576 # 400449d8 <__net_if_dts_ord_12_0>
	k_mutex_lock(&lock, K_FOREVER);
40010c58:	b50ff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
40010c5c:	a9c48493          	addi	s1,s1,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
40010c60:	00946c63          	bltu	s0,s1,40010c78 <net_if_stats_reset_all+0x44>
}
40010c64:	00812403          	lw	s0,8(sp)
40010c68:	00c12083          	lw	ra,12(sp)
40010c6c:	00412483          	lw	s1,4(sp)
40010c70:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
40010c74:	b48ff06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>
		memset(&iface->stats, 0, sizeof(iface->stats));
40010c78:	00440513          	addi	a0,s0,4
40010c7c:	0b800613          	li	a2,184
40010c80:	00000593          	li	a1,0
40010c84:	898fc0ef          	jal	ra,4000cd1c <memset>
	STRUCT_SECTION_FOREACH(net_if, iface) {
40010c88:	0c440413          	addi	s0,s0,196
40010c8c:	fd5ff06f          	j	40010c60 <net_if_stats_reset_all+0x2c>

40010c90 <net_if_set_link_addr_locked>:
{
40010c90:	fd010113          	addi	sp,sp,-48
40010c94:	02812423          	sw	s0,40(sp)
40010c98:	01312e23          	sw	s3,28(sp)
40010c9c:	00050413          	mv	s0,a0
40010ca0:	00058993          	mv	s3,a1
	k_mutex_lock(&lock, K_FOREVER);
40010ca4:	fff00513          	li	a0,-1
40010ca8:	fff00593          	li	a1,-1
{
40010cac:	02912223          	sw	s1,36(sp)
40010cb0:	03212023          	sw	s2,32(sp)
40010cb4:	02112623          	sw	ra,44(sp)
40010cb8:	00060913          	mv	s2,a2
40010cbc:	00068493          	mv	s1,a3
	k_mutex_lock(&lock, K_FOREVER);
40010cc0:	ae8ff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_flag_is_set(iface, NET_IF_RUNNING)) {
40010cc4:	00800593          	li	a1,8
40010cc8:	00040513          	mv	a0,s0
40010ccc:	98dff0ef          	jal	ra,40010658 <net_if_flag_is_set>
40010cd0:	04051263          	bnez	a0,40010d14 <net_if_set_link_addr_locked+0x84>
	return &iface->if_dev->link_addr;
40010cd4:	00042783          	lw	a5,0(s0)
	net_if_get_link_addr(iface)->addr = addr;
40010cd8:	0137a823          	sw	s3,16(a5)
	return &iface->if_dev->link_addr;
40010cdc:	00042783          	lw	a5,0(s0)
	net_if_get_link_addr(iface)->len = len;
40010ce0:	01278a23          	sb	s2,20(a5)
	return &iface->if_dev->link_addr;
40010ce4:	00042783          	lw	a5,0(s0)
	net_if_get_link_addr(iface)->type = type;
40010ce8:	00978aa3          	sb	s1,21(a5)
	return 0;
40010cec:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
40010cf0:	accff0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40010cf4:	02c12083          	lw	ra,44(sp)
40010cf8:	02812403          	lw	s0,40(sp)
40010cfc:	00c12503          	lw	a0,12(sp)
40010d00:	02412483          	lw	s1,36(sp)
40010d04:	02012903          	lw	s2,32(sp)
40010d08:	01c12983          	lw	s3,28(sp)
40010d0c:	03010113          	addi	sp,sp,48
40010d10:	00008067          	ret
		return -EPERM;
40010d14:	fff00513          	li	a0,-1
40010d18:	fd5ff06f          	j	40010cec <net_if_set_link_addr_locked+0x5c>

40010d1c <net_if_lookup_by_dev>:
	STRUCT_SECTION_FOREACH(net_if, iface) {
40010d1c:	400457b7          	lui	a5,0x40045
{
40010d20:	00050713          	mv	a4,a0
	STRUCT_SECTION_FOREACH(net_if, iface) {
40010d24:	9d878513          	addi	a0,a5,-1576 # 400449d8 <__net_if_dts_ord_12_0>
40010d28:	400457b7          	lui	a5,0x40045
40010d2c:	a9c78793          	addi	a5,a5,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
40010d30:	00f56663          	bltu	a0,a5,40010d3c <net_if_lookup_by_dev+0x20>
	return NULL;
40010d34:	00000513          	li	a0,0
}
40010d38:	00008067          	ret
	return iface->if_dev->dev;
40010d3c:	00052683          	lw	a3,0(a0)
		if (net_if_get_device(iface) == dev) {
40010d40:	0006a683          	lw	a3,0(a3)
40010d44:	fed70ae3          	beq	a4,a3,40010d38 <net_if_lookup_by_dev+0x1c>
	STRUCT_SECTION_FOREACH(net_if, iface) {
40010d48:	0c450513          	addi	a0,a0,196
40010d4c:	fe5ff06f          	j	40010d30 <net_if_lookup_by_dev+0x14>

40010d50 <net_if_get_default>:
	if (&_net_if_list_start[0] == &_net_if_list_end[0]) {
40010d50:	40045737          	lui	a4,0x40045
40010d54:	400457b7          	lui	a5,0x40045
40010d58:	a9c78793          	addi	a5,a5,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
40010d5c:	9d870693          	addi	a3,a4,-1576 # 400449d8 <__net_if_dts_ord_12_0>
		return NULL;
40010d60:	00000513          	li	a0,0
	if (&_net_if_list_start[0] == &_net_if_list_end[0]) {
40010d64:	00f68a63          	beq	a3,a5,40010d78 <net_if_get_default+0x28>
	if (default_iface != NULL) {
40010d68:	400397b7          	lui	a5,0x40039
40010d6c:	0707a503          	lw	a0,112(a5) # 40039070 <default_iface>
40010d70:	00051463          	bnez	a0,40010d78 <net_if_get_default+0x28>
	return iface ? iface : _net_if_list_start;
40010d74:	9d870513          	addi	a0,a4,-1576
}
40010d78:	00008067          	ret

40010d7c <net_if_mcast_monitor>:
{
40010d7c:	fe010113          	addi	sp,sp,-32
40010d80:	00912a23          	sw	s1,20(sp)
40010d84:	01212823          	sw	s2,16(sp)
40010d88:	00050493          	mv	s1,a0
40010d8c:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
40010d90:	fff00513          	li	a0,-1
40010d94:	fff00593          	li	a1,-1
{
40010d98:	01312623          	sw	s3,12(sp)
40010d9c:	00112e23          	sw	ra,28(sp)
40010da0:	00812c23          	sw	s0,24(sp)
40010da4:	00060993          	mv	s3,a2
	k_mutex_lock(&lock, K_FOREVER);
40010da8:	a00ff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
40010dac:	400397b7          	lui	a5,0x40039
40010db0:	0387a783          	lw	a5,56(a5) # 40039038 <mcast_monitor_callbacks>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&mcast_monitor_callbacks,
40010db4:	00078663          	beqz	a5,40010dc0 <net_if_mcast_monitor+0x44>
	return node->next;
40010db8:	0007a403          	lw	s0,0(a5)
40010dbc:	02079063          	bnez	a5,40010ddc <net_if_mcast_monitor+0x60>
}
40010dc0:	01812403          	lw	s0,24(sp)
40010dc4:	01c12083          	lw	ra,28(sp)
40010dc8:	01412483          	lw	s1,20(sp)
40010dcc:	01012903          	lw	s2,16(sp)
40010dd0:	00c12983          	lw	s3,12(sp)
40010dd4:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
40010dd8:	9e4ff06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>
		if (iface == mon->iface) {
40010ddc:	0047a703          	lw	a4,4(a5)
40010de0:	00971c63          	bne	a4,s1,40010df8 <net_if_mcast_monitor+0x7c>
			mon->cb(iface, addr, is_joined);
40010de4:	0087a783          	lw	a5,8(a5)
40010de8:	00098613          	mv	a2,s3
40010dec:	00090593          	mv	a1,s2
40010df0:	00048513          	mv	a0,s1
40010df4:	000780e7          	jalr	a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&mcast_monitor_callbacks,
40010df8:	00000713          	li	a4,0
40010dfc:	00040463          	beqz	s0,40010e04 <net_if_mcast_monitor+0x88>
40010e00:	00042703          	lw	a4,0(s0)
40010e04:	00040793          	mv	a5,s0
40010e08:	00070413          	mv	s0,a4
40010e0c:	fb1ff06f          	j	40010dbc <net_if_mcast_monitor+0x40>

40010e10 <net_if_config_ipv6_get>:
{
40010e10:	fe010113          	addi	sp,sp,-32
40010e14:	00812c23          	sw	s0,24(sp)
40010e18:	00912a23          	sw	s1,20(sp)
40010e1c:	00050413          	mv	s0,a0
40010e20:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
40010e24:	fff00513          	li	a0,-1
40010e28:	fff00593          	li	a1,-1
{
40010e2c:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
40010e30:	978ff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (!net_if_flag_is_set(iface, NET_IF_IPV6)) {
40010e34:	00700593          	li	a1,7
40010e38:	00040513          	mv	a0,s0
40010e3c:	81dff0ef          	jal	ra,40010658 <net_if_flag_is_set>
40010e40:	04050c63          	beqz	a0,40010e98 <net_if_config_ipv6_get+0x88>
	if (iface->config.ip.ipv6) {
40010e44:	0bc42783          	lw	a5,188(s0)
40010e48:	02078863          	beqz	a5,40010e78 <net_if_config_ipv6_get+0x68>
		if (ipv6) {
40010e4c:	00048463          	beqz	s1,40010e54 <net_if_config_ipv6_get+0x44>
			*ipv6 = &ipv6_addresses[i].ipv6;
40010e50:	00f4a023          	sw	a5,0(s1)
	int ret = 0;
40010e54:	00000513          	li	a0,0
40010e58:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
40010e5c:	960ff0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40010e60:	01c12083          	lw	ra,28(sp)
40010e64:	01812403          	lw	s0,24(sp)
40010e68:	00c12503          	lw	a0,12(sp)
40010e6c:	01412483          	lw	s1,20(sp)
40010e70:	02010113          	addi	sp,sp,32
40010e74:	00008067          	ret
		if (ipv6_addresses[i].iface) {
40010e78:	4003a7b7          	lui	a5,0x4003a
40010e7c:	55478793          	addi	a5,a5,1364 # 4003a554 <ipv6_addresses>
40010e80:	1587a703          	lw	a4,344(a5)
	ret = -ESRCH;
40010e84:	ffd00513          	li	a0,-3
		if (ipv6_addresses[i].iface) {
40010e88:	fc0718e3          	bnez	a4,40010e58 <net_if_config_ipv6_get+0x48>
		iface->config.ip.ipv6 = &ipv6_addresses[i].ipv6;
40010e8c:	0af42e23          	sw	a5,188(s0)
		ipv6_addresses[i].iface = iface;
40010e90:	1487ac23          	sw	s0,344(a5)
40010e94:	fb9ff06f          	j	40010e4c <net_if_config_ipv6_get+0x3c>
		ret = -ENOTSUP;
40010e98:	f7a00513          	li	a0,-134
40010e9c:	fbdff06f          	j	40010e58 <net_if_config_ipv6_get+0x48>

40010ea0 <net_if_start_rs>:
{
40010ea0:	ff010113          	addi	sp,sp,-16
40010ea4:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
40010ea8:	fff00593          	li	a1,-1
{
40010eac:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
40010eb0:	fff00513          	li	a0,-1
{
40010eb4:	00112623          	sw	ra,12(sp)
40010eb8:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
40010ebc:	8ecff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {
40010ec0:	00b00593          	li	a1,11
40010ec4:	00040513          	mv	a0,s0
40010ec8:	f90ff0ef          	jal	ra,40010658 <net_if_flag_is_set>
40010ecc:	04051c63          	bnez	a0,40010f24 <net_if_start_rs+0x84>
	ipv6 = iface->config.ip.ipv6;
40010ed0:	0bc42483          	lw	s1,188(s0)
	if (!ipv6) {
40010ed4:	04048863          	beqz	s1,40010f24 <net_if_start_rs+0x84>
	if (!net_ipv6_start_rs(iface)) {
40010ed8:	00040513          	mv	a0,s0
40010edc:	5b90d0ef          	jal	ra,4001ec94 <net_ipv6_start_rs>
40010ee0:	04051263          	bnez	a0,40010f24 <net_if_start_rs+0x84>
		ipv6->rs_start = k_uptime_get_32();
40010ee4:	838ff0ef          	jal	ra,4000ff1c <k_uptime_get_32>
40010ee8:	14a4a823          	sw	a0,336(s1)
		sys_slist_append(&active_rs_timers, &ipv6->rs_node);
40010eec:	40039537          	lui	a0,0x40039
40010ef0:	14c48593          	addi	a1,s1,332
40010ef4:	04850513          	addi	a0,a0,72 # 40039048 <active_rs_timers>
40010ef8:	ca1fe0ef          	jal	ra,4000fb98 <sys_slist_append>
40010efc:	4003a537          	lui	a0,0x4003a
40010f00:	95050513          	addi	a0,a0,-1712 # 40039950 <rs_timer+0x10>
40010f04:	584200ef          	jal	ra,40031488 <z_timeout_remaining>
		if (!k_work_delayable_remaining_get(&rs_timer)) {
40010f08:	00b56533          	or	a0,a0,a1
40010f0c:	00051c63          	bnez	a0,40010f24 <net_if_start_rs+0x84>
			k_work_reschedule(&rs_timer, K_MSEC(RS_TIMEOUT));
40010f10:	4003a537          	lui	a0,0x4003a
40010f14:	06400593          	li	a1,100
40010f18:	00000613          	li	a2,0
40010f1c:	94050513          	addi	a0,a0,-1728 # 40039940 <rs_timer>
40010f20:	2341f0ef          	jal	ra,40030154 <k_work_reschedule>
}
40010f24:	00812403          	lw	s0,8(sp)
40010f28:	00c12083          	lw	ra,12(sp)
40010f2c:	00412483          	lw	s1,4(sp)
40010f30:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
40010f34:	888ff06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>

40010f38 <rs_timeout>:
{
40010f38:	fe010113          	addi	sp,sp,-32
40010f3c:	00112e23          	sw	ra,28(sp)
40010f40:	00912a23          	sw	s1,20(sp)
40010f44:	01212823          	sw	s2,16(sp)
40010f48:	00812c23          	sw	s0,24(sp)
40010f4c:	01312623          	sw	s3,12(sp)
40010f50:	01412423          	sw	s4,8(sp)
40010f54:	01512223          	sw	s5,4(sp)
	uint32_t current_time = k_uptime_get_32();
40010f58:	fc5fe0ef          	jal	ra,4000ff1c <k_uptime_get_32>
40010f5c:	00050913          	mv	s2,a0
	k_mutex_lock(&lock, K_FOREVER);
40010f60:	fff00593          	li	a1,-1
40010f64:	fff00513          	li	a0,-1
40010f68:	840ff0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
40010f6c:	400394b7          	lui	s1,0x40039
40010f70:	0484a703          	lw	a4,72(s1) # 40039048 <active_rs_timers>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_rs_timers,
40010f74:	0c070463          	beqz	a4,4001103c <rs_timeout+0x104>
	return node->next;
40010f78:	00072403          	lw	s0,0(a4)
40010f7c:	04848493          	addi	s1,s1,72
40010f80:	eb470793          	addi	a5,a4,-332
40010f84:	00040463          	beqz	s0,40010f8c <rs_timeout+0x54>
40010f88:	eb440413          	addi	s0,s0,-332
		delay = (int32_t)(ipv6->rs_start + RS_TIMEOUT - current_time);
40010f8c:	3e800993          	li	s3,1000
40010f90:	412989b3          	sub	s3,s3,s2
		STRUCT_SECTION_FOREACH(net_if, tmp) {
40010f94:	40045937          	lui	s2,0x40045
40010f98:	40045ab7          	lui	s5,0x40045
40010f9c:	a9c90913          	addi	s2,s2,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
			if (ipv6->rs_count < RS_COUNT) {
40010fa0:	00200a13          	li	s4,2
40010fa4:	00c0006f          	j	40010fb0 <rs_timeout+0x78>
{
40010fa8:	00040793          	mv	a5,s0
40010fac:	00070413          	mv	s0,a4
		delay = (int32_t)(ipv6->rs_start + RS_TIMEOUT - current_time);
40010fb0:	1507a583          	lw	a1,336(a5)
40010fb4:	00b985b3          	add	a1,s3,a1
		if (delay > 0) {
40010fb8:	04b04e63          	bgtz	a1,40011014 <rs_timeout+0xdc>
40010fbc:	14c7a683          	lw	a3,332(a5)
Z_GENLIST_REMOVE(slist, snode)
40010fc0:	0044a603          	lw	a2,4(s1)
		sys_slist_remove(&active_rs_timers, NULL, &ipv6->rs_node);
40010fc4:	14c78713          	addi	a4,a5,332
	list->head = node;
40010fc8:	00d4a023          	sw	a3,0(s1)
Z_GENLIST_REMOVE(slist, snode)
40010fcc:	00e61463          	bne	a2,a4,40010fd4 <rs_timeout+0x9c>
	list->tail = node;
40010fd0:	00d4a223          	sw	a3,4(s1)
		ipv6->rs_count++;
40010fd4:	1547c703          	lbu	a4,340(a5)
	parent->next = child;
40010fd8:	1407a623          	sw	zero,332(a5)
		STRUCT_SECTION_FOREACH(net_if, tmp) {
40010fdc:	9d8a8513          	addi	a0,s5,-1576 # 400449d8 <__net_if_dts_ord_12_0>
		ipv6->rs_count++;
40010fe0:	00170713          	addi	a4,a4,1
40010fe4:	0ff77713          	zext.b	a4,a4
40010fe8:	14e78a23          	sb	a4,340(a5)
		STRUCT_SECTION_FOREACH(net_if, tmp) {
40010fec:	01256c63          	bltu	a0,s2,40011004 <rs_timeout+0xcc>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_rs_timers,
40010ff0:	04040663          	beqz	s0,4001103c <rs_timeout+0x104>
	return node->next;
40010ff4:	14c42703          	lw	a4,332(s0)
40010ff8:	fa0708e3          	beqz	a4,40010fa8 <rs_timeout+0x70>
40010ffc:	eb470713          	addi	a4,a4,-332
40011000:	fa9ff06f          	j	40010fa8 <rs_timeout+0x70>
			if (tmp->config.ip.ipv6 == ipv6) {
40011004:	0bc52683          	lw	a3,188(a0)
40011008:	04f68c63          	beq	a3,a5,40011060 <rs_timeout+0x128>
		STRUCT_SECTION_FOREACH(net_if, tmp) {
4001100c:	0c450513          	addi	a0,a0,196
40011010:	fddff06f          	j	40010fec <rs_timeout+0xb4>
		t += off;
40011014:	00958513          	addi	a0,a1,9
			return t / ((uint64_t)from_hz / to_hz);
40011018:	00a00613          	li	a2,10
4001101c:	00000693          	li	a3,0
40011020:	00b535b3          	sltu	a1,a0,a1
40011024:	a94ef0ef          	jal	ra,400002b8 <__udivdi3>
		k_work_reschedule(&rs_timer, K_MSEC(ipv6->rs_start +
40011028:	00058613          	mv	a2,a1
4001102c:	00050593          	mv	a1,a0
40011030:	4003a537          	lui	a0,0x4003a
40011034:	94050513          	addi	a0,a0,-1728 # 40039940 <rs_timer>
40011038:	11c1f0ef          	jal	ra,40030154 <k_work_reschedule>
}
4001103c:	01812403          	lw	s0,24(sp)
40011040:	01c12083          	lw	ra,28(sp)
40011044:	01412483          	lw	s1,20(sp)
40011048:	01012903          	lw	s2,16(sp)
4001104c:	00c12983          	lw	s3,12(sp)
40011050:	00812a03          	lw	s4,8(sp)
40011054:	00412a83          	lw	s5,4(sp)
40011058:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
4001105c:	f61fe06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>
			if (ipv6->rs_count < RS_COUNT) {
40011060:	f8ea68e3          	bltu	s4,a4,40010ff0 <rs_timeout+0xb8>
				net_if_start_rs(iface);
40011064:	e3dff0ef          	jal	ra,40010ea0 <net_if_start_rs>
40011068:	f89ff06f          	j	40010ff0 <rs_timeout+0xb8>

4001106c <net_if_stop_rs>:
{
4001106c:	ff010113          	addi	sp,sp,-16
40011070:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
40011074:	fff00593          	li	a1,-1
{
40011078:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4001107c:	fff00513          	li	a0,-1
{
40011080:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
40011084:	f25fe0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
40011088:	0bc42583          	lw	a1,188(s0)
	if (!ipv6) {
4001108c:	00058a63          	beqz	a1,400110a0 <net_if_stop_rs+0x34>
	sys_slist_find_and_remove(&active_rs_timers, &ipv6->rs_node);
40011090:	40039537          	lui	a0,0x40039
40011094:	14c58593          	addi	a1,a1,332
40011098:	04850513          	addi	a0,a0,72 # 40039048 <active_rs_timers>
4001109c:	b21fe0ef          	jal	ra,4000fbbc <sys_slist_find_and_remove>
}
400110a0:	00812403          	lw	s0,8(sp)
400110a4:	00c12083          	lw	ra,12(sp)
400110a8:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
400110ac:	f11fe06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>

400110b0 <net_if_ipv6_addr_lookup>:
{
400110b0:	fd010113          	addi	sp,sp,-48
400110b4:	02912223          	sw	s1,36(sp)
400110b8:	01312e23          	sw	s3,28(sp)
400110bc:	01512a23          	sw	s5,20(sp)
400110c0:	01612823          	sw	s6,16(sp)
400110c4:	00058993          	mv	s3,a1
400110c8:	00050b13          	mv	s6,a0
	k_mutex_lock(&lock, K_FOREVER);
400110cc:	fff00593          	li	a1,-1
400110d0:	fff00513          	li	a0,-1
	STRUCT_SECTION_FOREACH(net_if, iface) {
400110d4:	400454b7          	lui	s1,0x40045
400110d8:	40045ab7          	lui	s5,0x40045
{
400110dc:	01712623          	sw	s7,12(sp)
400110e0:	01812423          	sw	s8,8(sp)
400110e4:	01912223          	sw	s9,4(sp)
400110e8:	02112623          	sw	ra,44(sp)
400110ec:	02812423          	sw	s0,40(sp)
400110f0:	03212023          	sw	s2,32(sp)
400110f4:	01412c23          	sw	s4,24(sp)
	STRUCT_SECTION_FOREACH(net_if, iface) {
400110f8:	9d848493          	addi	s1,s1,-1576 # 400449d8 <__net_if_dts_ord_12_0>
	k_mutex_lock(&lock, K_FOREVER);
400110fc:	eadfe0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
40011100:	a9ca8a93          	addi	s5,s5,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
			if (!ipv6->unicast[i].is_used ||
40011104:	03000b93          	li	s7,48
40011108:	00200c13          	li	s8,2
		for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4001110c:	00300c93          	li	s9,3
	STRUCT_SECTION_FOREACH(net_if, iface) {
40011110:	0154e663          	bltu	s1,s5,4001111c <net_if_ipv6_addr_lookup+0x6c>
	struct net_if_addr *ifaddr = NULL;
40011114:	00000413          	li	s0,0
40011118:	0640006f          	j	4001117c <net_if_ipv6_addr_lookup+0xcc>
		struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
4001111c:	0bc4a403          	lw	s0,188(s1)
		if (!ipv6) {
40011120:	00041663          	bnez	s0,4001112c <net_if_ipv6_addr_lookup+0x7c>
	STRUCT_SECTION_FOREACH(net_if, iface) {
40011124:	0c448493          	addi	s1,s1,196
40011128:	fe9ff06f          	j	40011110 <net_if_ipv6_addr_lookup+0x60>
4001112c:	00440a13          	addi	s4,s0,4
		for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40011130:	00000913          	li	s2,0
			if (!ipv6->unicast[i].is_used ||
40011134:	037907b3          	mul	a5,s2,s7
40011138:	00f407b3          	add	a5,s0,a5
4001113c:	02c7a783          	lw	a5,44(a5)
40011140:	0197d793          	srli	a5,a5,0x19
40011144:	0017f793          	andi	a5,a5,1
40011148:	06078863          	beqz	a5,400111b8 <net_if_ipv6_addr_lookup+0x108>
4001114c:	ffca5783          	lhu	a5,-4(s4)
40011150:	07879463          	bne	a5,s8,400111b8 <net_if_ipv6_addr_lookup+0x108>
			if (net_ipv6_is_prefix(
40011154:	08000613          	li	a2,128
40011158:	000a0593          	mv	a1,s4
4001115c:	000b0513          	mv	a0,s6
40011160:	cf1fe0ef          	jal	ra,4000fe50 <net_ipv6_is_prefix>
40011164:	04050a63          	beqz	a0,400111b8 <net_if_ipv6_addr_lookup+0x108>
				if (ret) {
40011168:	00098463          	beqz	s3,40011170 <net_if_ipv6_addr_lookup+0xc0>
					*ret = iface;
4001116c:	0099a023          	sw	s1,0(s3)
				ifaddr = &ipv6->unicast[i];
40011170:	03000793          	li	a5,48
40011174:	02f90933          	mul	s2,s2,a5
40011178:	01240433          	add	s0,s0,s2
	k_mutex_unlock(&lock);
4001117c:	e41fe0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40011180:	02c12083          	lw	ra,44(sp)
40011184:	00040513          	mv	a0,s0
40011188:	02812403          	lw	s0,40(sp)
4001118c:	02412483          	lw	s1,36(sp)
40011190:	02012903          	lw	s2,32(sp)
40011194:	01c12983          	lw	s3,28(sp)
40011198:	01812a03          	lw	s4,24(sp)
4001119c:	01412a83          	lw	s5,20(sp)
400111a0:	01012b03          	lw	s6,16(sp)
400111a4:	00c12b83          	lw	s7,12(sp)
400111a8:	00812c03          	lw	s8,8(sp)
400111ac:	00412c83          	lw	s9,4(sp)
400111b0:	03010113          	addi	sp,sp,48
400111b4:	00008067          	ret
		for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
400111b8:	00190913          	addi	s2,s2,1
400111bc:	030a0a13          	addi	s4,s4,48
400111c0:	f7991ae3          	bne	s2,s9,40011134 <net_if_ipv6_addr_lookup+0x84>
400111c4:	f61ff06f          	j	40011124 <net_if_ipv6_addr_lookup+0x74>

400111c8 <dad_timeout>:
{
400111c8:	fd010113          	addi	sp,sp,-48
400111cc:	02112623          	sw	ra,44(sp)
400111d0:	03212023          	sw	s2,32(sp)
400111d4:	01312e23          	sw	s3,28(sp)
400111d8:	02812423          	sw	s0,40(sp)
400111dc:	02912223          	sw	s1,36(sp)
400111e0:	01412c23          	sw	s4,24(sp)
400111e4:	01512a23          	sw	s5,20(sp)
400111e8:	01612823          	sw	s6,16(sp)
	uint32_t current_time = k_uptime_get_32();
400111ec:	d31fe0ef          	jal	ra,4000ff1c <k_uptime_get_32>
400111f0:	00050993          	mv	s3,a0
	k_mutex_lock(&lock, K_FOREVER);
400111f4:	fff00593          	li	a1,-1
400111f8:	fff00513          	li	a0,-1
400111fc:	dadfe0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
40011200:	40039937          	lui	s2,0x40039
40011204:	05092783          	lw	a5,80(s2) # 40039050 <active_dad_timers>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,
40011208:	0e078263          	beqz	a5,400112ec <dad_timeout+0x124>
	return node->next;
4001120c:	0007a483          	lw	s1,0(a5)
40011210:	05090913          	addi	s2,s2,80
40011214:	fdc78413          	addi	s0,a5,-36
40011218:	00048463          	beqz	s1,40011220 <dad_timeout+0x58>
4001121c:	fdc48493          	addi	s1,s1,-36
				  DAD_TIMEOUT - current_time);
40011220:	06400a13          	li	s4,100
40011224:	413a0a33          	sub	s4,s4,s3
			net_mgmt_event_notify_with_info(
40011228:	e06009b7          	lui	s3,0xe0600
		ifaddr->addr_state = NET_ADDR_PREFERRED;
4001122c:	00100b13          	li	s6,1
			net_mgmt_event_notify_with_info(
40011230:	00d98993          	addi	s3,s3,13 # e060000d <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000e>
40011234:	04c0006f          	j	40011280 <dad_timeout+0xb8>
		t += off;
40011238:	00978513          	addi	a0,a5,9
		k_work_reschedule(&dad_timer, K_MSEC((uint32_t)delay));
4001123c:	41f7d593          	srai	a1,a5,0x1f
40011240:	00f537b3          	sltu	a5,a0,a5
			return t / ((uint64_t)from_hz / to_hz);
40011244:	00a00613          	li	a2,10
40011248:	00000693          	li	a3,0
4001124c:	00b785b3          	add	a1,a5,a1
40011250:	868ef0ef          	jal	ra,400002b8 <__udivdi3>
40011254:	00058613          	mv	a2,a1
40011258:	00050593          	mv	a1,a0
4001125c:	4003a537          	lui	a0,0x4003a
40011260:	97050513          	addi	a0,a0,-1680 # 40039970 <dad_timer>
40011264:	6f11e0ef          	jal	ra,40030154 <k_work_reschedule>
40011268:	0840006f          	j	400112ec <dad_timeout+0x124>
4001126c:	0244a783          	lw	a5,36(s1)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,
40011270:	00078463          	beqz	a5,40011278 <dad_timeout+0xb0>
40011274:	fdc78793          	addi	a5,a5,-36
{
40011278:	00048413          	mv	s0,s1
4001127c:	00078493          	mv	s1,a5
				  DAD_TIMEOUT - current_time);
40011280:	02842783          	lw	a5,40(s0)
40011284:	00fa07b3          	add	a5,s4,a5
		if (delay > 0) {
40011288:	faf048e3          	bgtz	a5,40011238 <dad_timeout+0x70>
4001128c:	02442703          	lw	a4,36(s0)
Z_GENLIST_REMOVE(slist, snode)
40011290:	00492683          	lw	a3,4(s2)
		sys_slist_remove(&active_dad_timers, NULL, &ifaddr->dad_node);
40011294:	02440793          	addi	a5,s0,36
	list->head = node;
40011298:	00e92023          	sw	a4,0(s2)
Z_GENLIST_REMOVE(slist, snode)
4001129c:	00f69463          	bne	a3,a5,400112a4 <dad_timeout+0xdc>
	list->tail = node;
400112a0:	00e92223          	sw	a4,4(s2)
		tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr,
400112a4:	00440a93          	addi	s5,s0,4
	parent->next = child;
400112a8:	02042223          	sw	zero,36(s0)
		ifaddr->addr_state = NET_ADDR_PREFERRED;
400112ac:	036406a3          	sb	s6,45(s0)
		tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr,
400112b0:	00c10593          	addi	a1,sp,12
400112b4:	000a8513          	mv	a0,s5
		iface = NULL;
400112b8:	00012623          	sw	zero,12(sp)
		tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr,
400112bc:	df5ff0ef          	jal	ra,400110b0 <net_if_ipv6_addr_lookup>
		if (tmp == ifaddr) {
400112c0:	02a41463          	bne	s0,a0,400112e8 <dad_timeout+0x120>
			net_mgmt_event_notify_with_info(
400112c4:	00c12403          	lw	s0,12(sp)
400112c8:	00098513          	mv	a0,s3
400112cc:	01000693          	li	a3,16
400112d0:	00040593          	mv	a1,s0
400112d4:	000a8613          	mv	a2,s5
400112d8:	3f4040ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
			net_ipv6_nbr_rm(iface, &ifaddr->address.in6_addr);
400112dc:	000a8593          	mv	a1,s5
400112e0:	00040513          	mv	a0,s0
400112e4:	6000b0ef          	jal	ra,4001c8e4 <net_ipv6_nbr_rm>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,
400112e8:	f80492e3          	bnez	s1,4001126c <dad_timeout+0xa4>
}
400112ec:	02812403          	lw	s0,40(sp)
400112f0:	02c12083          	lw	ra,44(sp)
400112f4:	02412483          	lw	s1,36(sp)
400112f8:	02012903          	lw	s2,32(sp)
400112fc:	01c12983          	lw	s3,28(sp)
40011300:	01812a03          	lw	s4,24(sp)
40011304:	01412a83          	lw	s5,20(sp)
40011308:	01012b03          	lw	s6,16(sp)
4001130c:	03010113          	addi	sp,sp,48
	k_mutex_unlock(&lock);
40011310:	cadfe06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>

40011314 <net_if_ipv6_addr_lookup_by_iface>:
{
40011314:	fd010113          	addi	sp,sp,-48
40011318:	02812423          	sw	s0,40(sp)
4001131c:	01412c23          	sw	s4,24(sp)
40011320:	00050413          	mv	s0,a0
40011324:	00058a13          	mv	s4,a1
	k_mutex_lock(&lock, K_FOREVER);
40011328:	fff00513          	li	a0,-1
4001132c:	fff00593          	li	a1,-1
{
40011330:	01312e23          	sw	s3,28(sp)
40011334:	02112623          	sw	ra,44(sp)
40011338:	02912223          	sw	s1,36(sp)
4001133c:	03212023          	sw	s2,32(sp)
40011340:	01512a23          	sw	s5,20(sp)
40011344:	01612823          	sw	s6,16(sp)
40011348:	01712623          	sw	s7,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001134c:	c5dfe0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
40011350:	0bc42983          	lw	s3,188(s0)
	if (!ipv6) {
40011354:	04098c63          	beqz	s3,400113ac <net_if_ipv6_addr_lookup_by_iface+0x98>
40011358:	00498913          	addi	s2,s3,4
4001135c:	00000493          	li	s1,0
		if (!ipv6->unicast[i].is_used ||
40011360:	03000b13          	li	s6,48
40011364:	00200b93          	li	s7,2
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40011368:	00300a93          	li	s5,3
		if (!ipv6->unicast[i].is_used ||
4001136c:	03648433          	mul	s0,s1,s6
40011370:	00898433          	add	s0,s3,s0
40011374:	02c42783          	lw	a5,44(s0)
40011378:	0197d793          	srli	a5,a5,0x19
4001137c:	0017f793          	andi	a5,a5,1
40011380:	02078063          	beqz	a5,400113a0 <net_if_ipv6_addr_lookup_by_iface+0x8c>
40011384:	ffc95783          	lhu	a5,-4(s2)
40011388:	01779c63          	bne	a5,s7,400113a0 <net_if_ipv6_addr_lookup_by_iface+0x8c>
		if (net_ipv6_is_prefix(
4001138c:	08000613          	li	a2,128
40011390:	00090593          	mv	a1,s2
40011394:	000a0513          	mv	a0,s4
40011398:	ab9fe0ef          	jal	ra,4000fe50 <net_ipv6_is_prefix>
4001139c:	00051a63          	bnez	a0,400113b0 <net_if_ipv6_addr_lookup_by_iface+0x9c>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
400113a0:	00148493          	addi	s1,s1,1
400113a4:	03090913          	addi	s2,s2,48
400113a8:	fd5492e3          	bne	s1,s5,4001136c <net_if_ipv6_addr_lookup_by_iface+0x58>
	struct net_if_addr *ifaddr = NULL;
400113ac:	00000413          	li	s0,0
	k_mutex_unlock(&lock);
400113b0:	c0dfe0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
400113b4:	02c12083          	lw	ra,44(sp)
400113b8:	00040513          	mv	a0,s0
400113bc:	02812403          	lw	s0,40(sp)
400113c0:	02412483          	lw	s1,36(sp)
400113c4:	02012903          	lw	s2,32(sp)
400113c8:	01c12983          	lw	s3,28(sp)
400113cc:	01812a03          	lw	s4,24(sp)
400113d0:	01412a83          	lw	s5,20(sp)
400113d4:	01012b03          	lw	s6,16(sp)
400113d8:	00c12b83          	lw	s7,12(sp)
400113dc:	03010113          	addi	sp,sp,48
400113e0:	00008067          	ret

400113e4 <net_if_ipv6_addr_update_lifetime>:
{
400113e4:	ff010113          	addi	sp,sp,-16
400113e8:	00812423          	sw	s0,8(sp)
400113ec:	00912223          	sw	s1,4(sp)
400113f0:	00050413          	mv	s0,a0
400113f4:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
400113f8:	fff00513          	li	a0,-1
400113fc:	fff00593          	li	a1,-1
{
40011400:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
40011404:	ba5fe0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	ifaddr->addr_state = NET_ADDR_PREFERRED;
40011408:	00100793          	li	a5,1
4001140c:	02f406a3          	sb	a5,45(s0)
	sys_slist_append(&active_address_lifetime_timers,
40011410:	40039537          	lui	a0,0x40039
40011414:	01440413          	addi	s0,s0,20
40011418:	00040593          	mv	a1,s0
4001141c:	06050513          	addi	a0,a0,96 # 40039060 <active_address_lifetime_timers>
40011420:	f78fe0ef          	jal	ra,4000fb98 <sys_slist_append>
	net_timeout_set(&ifaddr->lifetime, vlifetime, k_uptime_get_32());
40011424:	af9fe0ef          	jal	ra,4000ff1c <k_uptime_get_32>
40011428:	00050613          	mv	a2,a0
4001142c:	00048593          	mv	a1,s1
40011430:	00040513          	mv	a0,s0
40011434:	5f5020ef          	jal	ra,40014228 <net_timeout_set>
	k_work_reschedule(&address_lifetime_timer, K_NO_WAIT);
40011438:	4003a537          	lui	a0,0x4003a
4001143c:	00000593          	li	a1,0
40011440:	00000613          	li	a2,0
40011444:	9d050513          	addi	a0,a0,-1584 # 400399d0 <address_lifetime_timer>
40011448:	50d1e0ef          	jal	ra,40030154 <k_work_reschedule>
}
4001144c:	00812403          	lw	s0,8(sp)
40011450:	00c12083          	lw	ra,12(sp)
40011454:	00412483          	lw	s1,4(sp)
40011458:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
4001145c:	b61fe06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>

40011460 <net_if_ipv6_addr_add>:
{
40011460:	fa010113          	addi	sp,sp,-96
40011464:	04812c23          	sw	s0,88(sp)
40011468:	05212823          	sw	s2,80(sp)
4001146c:	05512223          	sw	s5,68(sp)
40011470:	03712e23          	sw	s7,60(sp)
40011474:	03812c23          	sw	s8,56(sp)
40011478:	06010413          	addi	s0,sp,96
4001147c:	04112e23          	sw	ra,92(sp)
40011480:	04912a23          	sw	s1,84(sp)
40011484:	05312623          	sw	s3,76(sp)
40011488:	05412423          	sw	s4,72(sp)
4001148c:	05612023          	sw	s6,64(sp)
40011490:	03912a23          	sw	s9,52(sp)
40011494:	03a12823          	sw	s10,48(sp)
40011498:	00050913          	mv	s2,a0
	k_mutex_lock(&lock, K_FOREVER);
4001149c:	fff00513          	li	a0,-1
{
400114a0:	00058a93          	mv	s5,a1
	k_mutex_lock(&lock, K_FOREVER);
400114a4:	fff00593          	li	a1,-1
{
400114a8:	00060c13          	mv	s8,a2
400114ac:	00068b93          	mv	s7,a3
	k_mutex_lock(&lock, K_FOREVER);
400114b0:	af9fe0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
400114b4:	fac40593          	addi	a1,s0,-84
400114b8:	00090513          	mv	a0,s2
400114bc:	955ff0ef          	jal	ra,40010e10 <net_if_config_ipv6_get>
400114c0:	04055663          	bgez	a0,4001150c <net_if_ipv6_addr_add+0xac>
	struct net_if_addr *ifaddr = NULL;
400114c4:	00000493          	li	s1,0
	k_mutex_unlock(&lock);
400114c8:	af5fe0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
400114cc:	fa040113          	addi	sp,s0,-96
400114d0:	05c12083          	lw	ra,92(sp)
400114d4:	00048513          	mv	a0,s1
400114d8:	05812403          	lw	s0,88(sp)
400114dc:	05412483          	lw	s1,84(sp)
400114e0:	05012903          	lw	s2,80(sp)
400114e4:	04c12983          	lw	s3,76(sp)
400114e8:	04812a03          	lw	s4,72(sp)
400114ec:	04412a83          	lw	s5,68(sp)
400114f0:	04012b03          	lw	s6,64(sp)
400114f4:	03c12b83          	lw	s7,60(sp)
400114f8:	03812c03          	lw	s8,56(sp)
400114fc:	03412c83          	lw	s9,52(sp)
40011500:	03012d03          	lw	s10,48(sp)
40011504:	06010113          	addi	sp,sp,96
40011508:	00008067          	ret
	ifaddr = ipv6_addr_find(iface, addr);
4001150c:	0bc92b03          	lw	s6,188(s2)
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40011510:	00000993          	li	s3,0
		if (!ipv6->unicast[i].is_used) {
40011514:	03000d13          	li	s10,48
40011518:	004b0a13          	addi	s4,s6,4
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4001151c:	00300c93          	li	s9,3
		if (!ipv6->unicast[i].is_used) {
40011520:	03a984b3          	mul	s1,s3,s10
40011524:	009b04b3          	add	s1,s6,s1
40011528:	02c4a783          	lw	a5,44(s1)
4001152c:	0197d793          	srli	a5,a5,0x19
40011530:	0017f793          	andi	a5,a5,1
40011534:	00078a63          	beqz	a5,40011548 <net_if_ipv6_addr_add+0xe8>
		if (net_ipv6_addr_cmp(
40011538:	000a0593          	mv	a1,s4
4001153c:	000a8513          	mv	a0,s5
40011540:	9bdfe0ef          	jal	ra,4000fefc <net_ipv6_addr_cmp>
40011544:	f80512e3          	bnez	a0,400114c8 <net_if_ipv6_addr_add+0x68>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40011548:	00198993          	addi	s3,s3,1
4001154c:	030a0a13          	addi	s4,s4,48
40011550:	fd9998e3          	bne	s3,s9,40011520 <net_if_ipv6_addr_add+0xc0>
		if (ipv6->unicast[i].is_used) {
40011554:	fac42b03          	lw	s6,-84(s0)
40011558:	02cb2783          	lw	a5,44(s6)
4001155c:	0197d793          	srli	a5,a5,0x19
40011560:	0017f793          	andi	a5,a5,1
40011564:	24078e63          	beqz	a5,400117c0 <net_if_ipv6_addr_add+0x360>
40011568:	05cb2783          	lw	a5,92(s6)
4001156c:	0197d793          	srli	a5,a5,0x19
40011570:	0017f793          	andi	a5,a5,1
40011574:	24078a63          	beqz	a5,400117c8 <net_if_ipv6_addr_add+0x368>
40011578:	08cb2783          	lw	a5,140(s6)
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4001157c:	00200a13          	li	s4,2
		if (ipv6->unicast[i].is_used) {
40011580:	0197d793          	srli	a5,a5,0x19
40011584:	0017f793          	andi	a5,a5,1
40011588:	f2079ee3          	bnez	a5,400114c4 <net_if_ipv6_addr_add+0x64>
		net_if_addr_init(&ipv6->unicast[i], addr, addr_type,
4001158c:	03000993          	li	s3,48
40011590:	033a09b3          	mul	s3,s4,s3
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
40011594:	01000613          	li	a2,16
40011598:	000a8593          	mv	a1,s5
4001159c:	fb040513          	addi	a0,s0,-80
		net_if_addr_init(&ipv6->unicast[i], addr, addr_type,
400115a0:	013b04b3          	add	s1,s6,s3
	ifaddr->is_used = true;
400115a4:	02f4c783          	lbu	a5,47(s1)
	ifaddr->addr_type = addr_type;
400115a8:	03848623          	sb	s8,44(s1)
	ifaddr->is_used = true;
400115ac:	0027e793          	ori	a5,a5,2
400115b0:	02f487a3          	sb	a5,47(s1)
	ifaddr->address.family = AF_INET6;
400115b4:	00200793          	li	a5,2
400115b8:	00f49023          	sh	a5,0(s1)
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
400115bc:	f3cfb0ef          	jal	ra,4000ccf8 <memcpy>
400115c0:	01000613          	li	a2,16
400115c4:	fb040593          	addi	a1,s0,-80
400115c8:	00448513          	addi	a0,s1,4
400115cc:	f2cfb0ef          	jal	ra,4000ccf8 <memcpy>
	if (vlifetime) {
400115d0:	02f4c783          	lbu	a5,47(s1)
400115d4:	1e0b8e63          	beqz	s7,400117d0 <net_if_ipv6_addr_add+0x370>
		ifaddr->is_infinite = false;
400115d8:	ffe7f793          	andi	a5,a5,-2
400115dc:	02f487a3          	sb	a5,47(s1)
		net_if_ipv6_addr_update_lifetime(ifaddr, vlifetime);
400115e0:	000b8593          	mv	a1,s7
400115e4:	00048513          	mv	a0,s1
400115e8:	dfdff0ef          	jal	ra,400113e4 <net_if_ipv6_addr_update_lifetime>
		if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT) &&
400115ec:	00090513          	mv	a0,s2
400115f0:	fa4fe0ef          	jal	ra,4000fd94 <l2_flags_get>
			join_mcast_nodes(iface,
400115f4:	00498993          	addi	s3,s3,4
		if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT) &&
400115f8:	00857513          	andi	a0,a0,8
			join_mcast_nodes(iface,
400115fc:	013b09b3          	add	s3,s6,s3
		if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT) &&
40011600:	1c051e63          	bnez	a0,400117dc <net_if_ipv6_addr_add+0x37c>
		    !net_ipv6_is_addr_loopback(addr) &&
40011604:	000a8513          	mv	a0,s5
40011608:	e10fe0ef          	jal	ra,4000fc18 <net_ipv6_is_addr_loopback>
		if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT) &&
4001160c:	1c051863          	bnez	a0,400117dc <net_if_ipv6_addr_add+0x37c>
		    !net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {
40011610:	00b00593          	li	a1,11
40011614:	00090513          	mv	a0,s2
40011618:	840ff0ef          	jal	ra,40010658 <net_if_flag_is_set>
		    !net_ipv6_is_addr_loopback(addr) &&
4001161c:	1c051063          	bnez	a0,400117dc <net_if_ipv6_addr_add+0x37c>
	flags = l2_flags_get(iface);
40011620:	00090513          	mv	a0,s2
40011624:	f70fe0ef          	jal	ra,4000fd94 <l2_flags_get>
	if (flags & NET_L2_MULTICAST) {
40011628:	00157793          	andi	a5,a0,1
	flags = l2_flags_get(iface);
4001162c:	00050a93          	mv	s5,a0
	if (flags & NET_L2_MULTICAST) {
40011630:	16078463          	beqz	a5,40011798 <net_if_ipv6_addr_add+0x338>
					uint16_t addr0, uint16_t addr1,
					uint16_t addr2, uint16_t addr3,
					uint16_t addr4, uint16_t addr5,
					uint16_t addr6, uint16_t addr7)
{
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
40011634:	2ff00793          	li	a5,767
	UNALIGNED_PUT(htons(addr1), &addr->s6_addr16[1]);
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
	UNALIGNED_PUT(htons(addr3), &addr->s6_addr16[3]);
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
	UNALIGNED_PUT(htons(addr5), &addr->s6_addr16[5]);
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
40011638:	01000c37          	lui	s8,0x1000
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
4001163c:	fcf42023          	sw	a5,-64(s0)
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
40011640:	fc042223          	sw	zero,-60(s0)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
40011644:	fc042423          	sw	zero,-56(s0)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
40011648:	fd842623          	sw	s8,-52(s0)
	ret = net_ipv6_mld_join(iface, &addr);
4001164c:	fc040593          	addi	a1,s0,-64
40011650:	00090513          	mv	a0,s2
40011654:	4c50d0ef          	jal	ra,4001f318 <net_ipv6_mld_join>
40011658:	00050b93          	mv	s7,a0
	if (ret < 0 && ret != -EALREADY) {
4001165c:	06055863          	bgez	a0,400116cc <net_if_ipv6_addr_add+0x26c>
40011660:	f8800793          	li	a5,-120
40011664:	06f50463          	beq	a0,a5,400116cc <net_if_ipv6_addr_add+0x26c>
		NET_ERR("Cannot join all nodes address %s (%d)",
40011668:	40044cb7          	lui	s9,0x40044
4001166c:	774ca783          	lw	a5,1908(s9) # 40044774 <log_dynamic_net_if>
40011670:	0077f793          	andi	a5,a5,7
40011674:	04078c63          	beqz	a5,400116cc <net_if_ipv6_addr_add+0x26c>
40011678:	fc040593          	addi	a1,s0,-64
4001167c:	00200513          	li	a0,2
40011680:	234030ef          	jal	ra,400148b4 <net_sprint_addr>
40011684:	00010d13          	mv	s10,sp
40011688:	fd010113          	addi	sp,sp,-48
4001168c:	00010613          	mv	a2,sp
40011690:	400357b7          	lui	a5,0x40035
40011694:	9dc78793          	addi	a5,a5,-1572 # 400349dc <net_buf_fixed_cb+0x7c>
40011698:	00f62a23          	sw	a5,20(a2)
4001169c:	20000793          	li	a5,512
400116a0:	02f61023          	sh	a5,32(a2)
400116a4:	000025b7          	lui	a1,0x2
400116a8:	004c0793          	addi	a5,s8,4 # 1000004 <__rom_region_size+0xfc7048>
400116ac:	00a62c23          	sw	a0,24(a2)
400116b0:	01762e23          	sw	s7,28(a2)
400116b4:	00f62823          	sw	a5,16(a2)
400116b8:	44058593          	addi	a1,a1,1088 # 2440 <CONFIG_SRAM_SIZE+0x440>
400116bc:	01060613          	addi	a2,a2,16
400116c0:	774c8513          	addi	a0,s9,1908
400116c4:	8ddfe0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
400116c8:	000d0113          	mv	sp,s10
		if (!(flags & NET_L2_MULTICAST_SKIP_JOIN_SOLICIT_NODE)) {
400116cc:	002afa93          	andi	s5,s5,2
400116d0:	0c0a9463          	bnez	s5,40011798 <net_if_ipv6_addr_add+0x338>
	dst->s6_addr[0]   = 0xFF;
400116d4:	2ff00793          	li	a5,767
400116d8:	fcf42023          	sw	a5,-64(s0)
	dst->s6_addr[12]  = 0xFF;
400116dc:	fff00793          	li	a5,-1
400116e0:	fcf40623          	sb	a5,-52(s0)
	dst->s6_addr[13]  = src->s6_addr[13];
400116e4:	03000793          	li	a5,48
400116e8:	02fa07b3          	mul	a5,s4,a5
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
400116ec:	01000ab7          	lui	s5,0x1000
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
400116f0:	fc042223          	sw	zero,-60(s0)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
400116f4:	fd542423          	sw	s5,-56(s0)
	ret = net_ipv6_mld_join(iface, &addr);
400116f8:	fc040593          	addi	a1,s0,-64
400116fc:	00090513          	mv	a0,s2
	dst->s6_addr[13]  = src->s6_addr[13];
40011700:	00fb07b3          	add	a5,s6,a5
40011704:	0117c783          	lbu	a5,17(a5)
40011708:	fcf406a3          	sb	a5,-51(s0)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
4001170c:	00f9c783          	lbu	a5,15(s3)
40011710:	00e9c703          	lbu	a4,14(s3)
40011714:	00879793          	slli	a5,a5,0x8
40011718:	00e7e7b3          	or	a5,a5,a4
4001171c:	fcf41723          	sh	a5,-50(s0)
40011720:	3f90d0ef          	jal	ra,4001f318 <net_ipv6_mld_join>
40011724:	00050a13          	mv	s4,a0
	if (ret < 0 && ret != -EALREADY) {
40011728:	06055863          	bgez	a0,40011798 <net_if_ipv6_addr_add+0x338>
4001172c:	f8800793          	li	a5,-120
40011730:	06f50463          	beq	a0,a5,40011798 <net_if_ipv6_addr_add+0x338>
		NET_ERR("Cannot join solicit node address %s (%d)",
40011734:	40044bb7          	lui	s7,0x40044
40011738:	774ba783          	lw	a5,1908(s7) # 40044774 <log_dynamic_net_if>
4001173c:	0077f793          	andi	a5,a5,7
40011740:	04078c63          	beqz	a5,40011798 <net_if_ipv6_addr_add+0x338>
40011744:	fc040593          	addi	a1,s0,-64
40011748:	00200513          	li	a0,2
4001174c:	168030ef          	jal	ra,400148b4 <net_sprint_addr>
40011750:	00010b13          	mv	s6,sp
40011754:	fd010113          	addi	sp,sp,-48
40011758:	00010613          	mv	a2,sp
4001175c:	400357b7          	lui	a5,0x40035
40011760:	a0478793          	addi	a5,a5,-1532 # 40034a04 <net_buf_fixed_cb+0xa4>
40011764:	00f62a23          	sw	a5,20(a2)
40011768:	004a8a93          	addi	s5,s5,4 # 1000004 <__rom_region_size+0xfc7048>
4001176c:	20000793          	li	a5,512
40011770:	000025b7          	lui	a1,0x2
40011774:	00a62c23          	sw	a0,24(a2)
40011778:	01462e23          	sw	s4,28(a2)
4001177c:	02f61023          	sh	a5,32(a2)
40011780:	01562823          	sw	s5,16(a2)
40011784:	44058593          	addi	a1,a1,1088 # 2440 <CONFIG_SRAM_SIZE+0x440>
40011788:	01060613          	addi	a2,a2,16
4001178c:	774b8513          	addi	a0,s7,1908
40011790:	811fe0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
40011794:	000b0113          	mv	sp,s6
			net_if_ipv6_start_dad(iface, &ipv6->unicast[i]);
40011798:	00048593          	mv	a1,s1
4001179c:	00090513          	mv	a0,s2
400117a0:	ef9fe0ef          	jal	ra,40010698 <net_if_ipv6_start_dad>
		net_mgmt_event_notify_with_info(
400117a4:	e0600537          	lui	a0,0xe0600
400117a8:	01000693          	li	a3,16
400117ac:	00098613          	mv	a2,s3
400117b0:	00090593          	mv	a1,s2
400117b4:	00150513          	addi	a0,a0,1 # e0600001 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600002>
400117b8:	715030ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
		goto out;
400117bc:	d0dff06f          	j	400114c8 <net_if_ipv6_addr_add+0x68>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
400117c0:	00000a13          	li	s4,0
400117c4:	dc9ff06f          	j	4001158c <net_if_ipv6_addr_add+0x12c>
400117c8:	00100a13          	li	s4,1
400117cc:	dc1ff06f          	j	4001158c <net_if_ipv6_addr_add+0x12c>
		ifaddr->is_infinite = true;
400117d0:	0017e793          	ori	a5,a5,1
400117d4:	02f487a3          	sb	a5,47(s1)
400117d8:	e15ff06f          	j	400115ec <net_if_ipv6_addr_add+0x18c>
			ipv6->unicast[i].addr_state = NET_ADDR_PREFERRED;
400117dc:	03000793          	li	a5,48
400117e0:	02fa0a33          	mul	s4,s4,a5
400117e4:	00100713          	li	a4,1
400117e8:	014b07b3          	add	a5,s6,s4
400117ec:	02e786a3          	sb	a4,45(a5)
400117f0:	fb5ff06f          	j	400117a4 <net_if_ipv6_addr_add+0x344>

400117f4 <net_if_start_dad>:
{
400117f4:	fa010113          	addi	sp,sp,-96
400117f8:	04812c23          	sw	s0,88(sp)
400117fc:	04912a23          	sw	s1,84(sp)
40011800:	06010413          	addi	s0,sp,96
40011804:	04112e23          	sw	ra,92(sp)
40011808:	05212823          	sw	s2,80(sp)
4001180c:	05312623          	sw	s3,76(sp)
40011810:	05412423          	sw	s4,72(sp)
40011814:	05512223          	sw	s5,68(sp)
40011818:	05612023          	sw	s6,64(sp)
4001181c:	00050493          	mv	s1,a0
	k_mutex_lock(&lock, K_FOREVER);
40011820:	fff00593          	li	a1,-1
40011824:	fff00513          	li	a0,-1
	struct in6_addr addr = { };
40011828:	fa042c23          	sw	zero,-72(s0)
4001182c:	fa042e23          	sw	zero,-68(s0)
40011830:	fc042023          	sw	zero,-64(s0)
40011834:	fc042223          	sw	zero,-60(s0)
	k_mutex_lock(&lock, K_FOREVER);
40011838:	f70fe0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	ret = net_if_config_ipv6_get(iface, &ipv6);
4001183c:	fb440593          	addi	a1,s0,-76
40011840:	00048513          	mv	a0,s1
40011844:	dccff0ef          	jal	ra,40010e10 <net_if_config_ipv6_get>
	if (ret < 0) {
40011848:	06055a63          	bgez	a0,400118bc <net_if_start_dad+0xc8>
		if (ret != -ENOTSUP) {
4001184c:	f7a00793          	li	a5,-134
40011850:	02f50e63          	beq	a0,a5,4001188c <net_if_start_dad+0x98>
			NET_WARN("Cannot do DAD IPv6 config is not valid.");
40011854:	40044537          	lui	a0,0x40044
40011858:	77452783          	lw	a5,1908(a0) # 40044774 <log_dynamic_net_if>
4001185c:	0067f793          	andi	a5,a5,6
40011860:	02078663          	beqz	a5,4001188c <net_if_start_dad+0x98>
40011864:	400357b7          	lui	a5,0x40035
40011868:	a3078793          	addi	a5,a5,-1488 # 40034a30 <net_buf_fixed_cb+0xd0>
4001186c:	000015b7          	lui	a1,0x1
40011870:	fcf42e23          	sw	a5,-36(s0)
40011874:	fd840613          	addi	a2,s0,-40
40011878:	00200793          	li	a5,2
4001187c:	08058593          	addi	a1,a1,128 # 1080 <CONFIG_HEAP_MEM_POOL_SIZE+0x80>
40011880:	77450513          	addi	a0,a0,1908
40011884:	fcf42c23          	sw	a5,-40(s0)
40011888:	f18fe0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
	k_mutex_unlock(&lock);
4001188c:	f30fe0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40011890:	fa040113          	addi	sp,s0,-96
40011894:	05c12083          	lw	ra,92(sp)
40011898:	05812403          	lw	s0,88(sp)
4001189c:	05412483          	lw	s1,84(sp)
400118a0:	05012903          	lw	s2,80(sp)
400118a4:	04c12983          	lw	s3,76(sp)
400118a8:	04812a03          	lw	s4,72(sp)
400118ac:	04412a83          	lw	s5,68(sp)
400118b0:	04012b03          	lw	s6,64(sp)
400118b4:	06010113          	addi	sp,sp,96
400118b8:	00008067          	ret
	if (!ipv6) {
400118bc:	fb442783          	lw	a5,-76(s0)
400118c0:	fc0786e3          	beqz	a5,4001188c <net_if_start_dad+0x98>
	return &iface->if_dev->link_addr;
400118c4:	0004a903          	lw	s2,0(s1)
 *  @param lladdr Link local address
 */
static inline void net_ipv6_addr_create_iid(struct in6_addr *addr,
					    struct net_linkaddr *lladdr)
{
	UNALIGNED_PUT(htonl(0xfe800000), &addr->s6_addr32[0]);
400118c8:	000087b7          	lui	a5,0x8
400118cc:	0fe78793          	addi	a5,a5,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
400118d0:	faf42c23          	sw	a5,-72(s0)
	UNALIGNED_PUT(0, &addr->s6_addr32[1]);

	switch (lladdr->len) {
400118d4:	01494783          	lbu	a5,20(s2)
	UNALIGNED_PUT(0, &addr->s6_addr32[1]);
400118d8:	fa042e23          	sw	zero,-68(s0)
	switch (lladdr->len) {
400118dc:	00600713          	li	a4,6
400118e0:	12e78663          	beq	a5,a4,40011a0c <net_if_start_dad+0x218>
400118e4:	00800713          	li	a4,8
400118e8:	16e78a63          	beq	a5,a4,40011a5c <net_if_start_dad+0x268>
400118ec:	00200713          	li	a4,2
400118f0:	02e79a63          	bne	a5,a4,40011924 <net_if_start_dad+0x130>
	case 2:
		/* The generated IPv6 shall not toggle the
		 * Universal/Local bit. RFC 6282 ch 3.2.2
		 */
		if (lladdr->type == NET_LINK_IEEE802154) {
400118f4:	01594703          	lbu	a4,21(s2)
400118f8:	00100793          	li	a5,1
400118fc:	02f71463          	bne	a4,a5,40011924 <net_if_start_dad+0x130>
			UNALIGNED_PUT(0, &addr->s6_addr32[2]);
40011900:	ff0007b7          	lui	a5,0xff000
40011904:	fcf42023          	sw	a5,-64(s0)
			addr->s6_addr[11] = 0xff;
			addr->s6_addr[12] = 0xfe;
40011908:	0fe00793          	li	a5,254
4001190c:	fcf41223          	sh	a5,-60(s0)
			addr->s6_addr[13] = 0U;
			addr->s6_addr[14] = lladdr->addr[0];
40011910:	01092783          	lw	a5,16(s2)
40011914:	0007c703          	lbu	a4,0(a5) # ff000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xff000001>
40011918:	fce40323          	sb	a4,-58(s0)
			addr->s6_addr[15] = lladdr->addr[1];
4001191c:	0017c783          	lbu	a5,1(a5)
40011920:	fcf403a3          	sb	a5,-57(s0)
	ifaddr = net_if_ipv6_addr_add(iface, &addr, NET_ADDR_AUTOCONF, 0);
40011924:	00000693          	li	a3,0
40011928:	00100613          	li	a2,1
4001192c:	fb840593          	addi	a1,s0,-72
40011930:	00048513          	mv	a0,s1
40011934:	b2dff0ef          	jal	ra,40011460 <net_if_ipv6_addr_add>
40011938:	00050993          	mv	s3,a0
	if (!ifaddr) {
4001193c:	06051663          	bnez	a0,400119a8 <net_if_start_dad+0x1b4>
		NET_ERR("Cannot add %s address to interface %p, DAD fails",
40011940:	40044937          	lui	s2,0x40044
40011944:	77492783          	lw	a5,1908(s2) # 40044774 <log_dynamic_net_if>
40011948:	0077f793          	andi	a5,a5,7
4001194c:	04078e63          	beqz	a5,400119a8 <net_if_start_dad+0x1b4>
40011950:	fb840593          	addi	a1,s0,-72
40011954:	00200513          	li	a0,2
40011958:	75d020ef          	jal	ra,400148b4 <net_sprint_addr>
4001195c:	00010a13          	mv	s4,sp
40011960:	fd010113          	addi	sp,sp,-48
40011964:	00010613          	mv	a2,sp
40011968:	400357b7          	lui	a5,0x40035
4001196c:	a5878793          	addi	a5,a5,-1448 # 40034a58 <net_buf_fixed_cb+0xf8>
40011970:	00f62a23          	sw	a5,20(a2)
40011974:	20000793          	li	a5,512
40011978:	02f61023          	sh	a5,32(a2)
4001197c:	010007b7          	lui	a5,0x1000
40011980:	00478793          	addi	a5,a5,4 # 1000004 <__rom_region_size+0xfc7048>
40011984:	000025b7          	lui	a1,0x2
40011988:	00a62c23          	sw	a0,24(a2)
4001198c:	00962e23          	sw	s1,28(a2)
40011990:	00f62823          	sw	a5,16(a2)
40011994:	44058593          	addi	a1,a1,1088 # 2440 <CONFIG_SRAM_SIZE+0x440>
40011998:	01060613          	addi	a2,a2,16
4001199c:	77490513          	addi	a0,s2,1908
400119a0:	e00fe0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
400119a4:	000a0113          	mv	sp,s4
{
400119a8:	00000913          	li	s2,0
		if (!ipv6->unicast[i].is_used ||
400119ac:	03000a93          	li	s5,48
400119b0:	00200b13          	li	s6,2
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
400119b4:	00300a13          	li	s4,3
		if (!ipv6->unicast[i].is_used ||
400119b8:	03590733          	mul	a4,s2,s5
400119bc:	fb442503          	lw	a0,-76(s0)
400119c0:	00e505b3          	add	a1,a0,a4
400119c4:	02c5a783          	lw	a5,44(a1)
400119c8:	0197d793          	srli	a5,a5,0x19
400119cc:	0017f793          	andi	a5,a5,1
400119d0:	02078863          	beqz	a5,40011a00 <net_if_start_dad+0x20c>
400119d4:	0005d783          	lhu	a5,0(a1)
400119d8:	03679463          	bne	a5,s6,40011a00 <net_if_start_dad+0x20c>
		    ipv6->unicast[i].address.family != AF_INET6 ||
400119dc:	fab42623          	sw	a1,-84(s0)
400119e0:	02b98063          	beq	s3,a1,40011a00 <net_if_start_dad+0x20c>
		    net_ipv6_is_addr_loopback(
400119e4:	00470713          	addi	a4,a4,4
400119e8:	00e50533          	add	a0,a0,a4
400119ec:	a2cfe0ef          	jal	ra,4000fc18 <net_ipv6_is_addr_loopback>
		    &ipv6->unicast[i] == ifaddr ||
400119f0:	00051863          	bnez	a0,40011a00 <net_if_start_dad+0x20c>
		net_if_ipv6_start_dad(iface, &ipv6->unicast[i]);
400119f4:	fac42583          	lw	a1,-84(s0)
400119f8:	00048513          	mv	a0,s1
400119fc:	c9dfe0ef          	jal	ra,40010698 <net_if_ipv6_start_dad>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40011a00:	00190913          	addi	s2,s2,1
40011a04:	fb491ae3          	bne	s2,s4,400119b8 <net_if_start_dad+0x1c4>
out:
40011a08:	e85ff06f          	j	4001188c <net_if_start_dad+0x98>
		break;
	case 6:
		/* We do not toggle the Universal/Local bit
		 * in Bluetooth. See RFC 7668 ch 3.2.2
		 */
		memcpy(&addr->s6_addr[8], lladdr->addr, 3);
40011a0c:	01092583          	lw	a1,16(s2)
40011a10:	00300613          	li	a2,3
40011a14:	fc040513          	addi	a0,s0,-64
40011a18:	ae0fb0ef          	jal	ra,4000ccf8 <memcpy>
		addr->s6_addr[11] = 0xff;
		addr->s6_addr[12] = 0xfe;
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
40011a1c:	01092583          	lw	a1,16(s2)
		addr->s6_addr[11] = 0xff;
40011a20:	fff00793          	li	a5,-1
40011a24:	fcf401a3          	sb	a5,-61(s0)
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
40011a28:	00300613          	li	a2,3
		addr->s6_addr[12] = 0xfe;
40011a2c:	ffe00793          	li	a5,-2
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
40011a30:	00358593          	addi	a1,a1,3
40011a34:	fc540513          	addi	a0,s0,-59
		addr->s6_addr[12] = 0xfe;
40011a38:	fcf40223          	sb	a5,-60(s0)
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
40011a3c:	abcfb0ef          	jal	ra,4000ccf8 <memcpy>
		if (lladdr->type == NET_LINK_BLUETOOTH) {
			addr->s6_addr[8] ^= 0x02;
		}
#endif

		if (lladdr->type == NET_LINK_ETHERNET) {
40011a40:	01594703          	lbu	a4,21(s2)
40011a44:	00300793          	li	a5,3
40011a48:	ecf71ee3          	bne	a4,a5,40011924 <net_if_start_dad+0x130>
		}

		break;
	case 8:
		memcpy(&addr->s6_addr[8], lladdr->addr, lladdr->len);
		addr->s6_addr[8] ^= 0x02;
40011a4c:	fc044783          	lbu	a5,-64(s0)
40011a50:	0027c793          	xori	a5,a5,2
40011a54:	fcf40023          	sb	a5,-64(s0)
		break;
40011a58:	ecdff06f          	j	40011924 <net_if_start_dad+0x130>
		memcpy(&addr->s6_addr[8], lladdr->addr, lladdr->len);
40011a5c:	01092583          	lw	a1,16(s2)
40011a60:	00800613          	li	a2,8
40011a64:	fc040513          	addi	a0,s0,-64
40011a68:	a90fb0ef          	jal	ra,4000ccf8 <memcpy>
40011a6c:	fe1ff06f          	j	40011a4c <net_if_start_dad+0x258>

40011a70 <update_operational_state>:
	return "";
#endif /* CONFIG_NET_IF_LOG_LEVEL >= LOG_LEVEL_DBG */
}

static void update_operational_state(struct net_if *iface)
{
40011a70:	ff010113          	addi	sp,sp,-16
40011a74:	00812423          	sw	s0,8(sp)
40011a78:	00912223          	sw	s1,4(sp)
40011a7c:	00112623          	sw	ra,12(sp)
40011a80:	01212023          	sw	s2,0(sp)
40011a84:	01010413          	addi	s0,sp,16
	enum net_if_oper_state prev_state = iface->if_dev->oper_state;
40011a88:	00052783          	lw	a5,0(a0)
 */
static inline bool net_if_is_admin_up(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_UP);
40011a8c:	00000593          	li	a1,0
{
40011a90:	00050493          	mv	s1,a0
	enum net_if_oper_state prev_state = iface->if_dev->oper_state;
40011a94:	01a7c903          	lbu	s2,26(a5)
40011a98:	bc1fe0ef          	jal	ra,40010658 <net_if_flag_is_set>
	enum net_if_oper_state new_state = NET_IF_OPER_UNKNOWN;

	if (!net_if_is_admin_up(iface)) {
40011a9c:	04051a63          	bnez	a0,40011af0 <update_operational_state+0x80>
		iface->if_dev->oper_state = oper_state;
40011aa0:	0004a703          	lw	a4,0(s1)
40011aa4:	00200793          	li	a5,2
40011aa8:	00f70d23          	sb	a5,26(a4)
	return iface->if_dev->oper_state;
40011aac:	0004a503          	lw	a0,0(s1)
	}

	new_state = NET_IF_OPER_UP;

exit:
	if (net_if_oper_state_set(iface, new_state) != new_state) {
40011ab0:	01a54703          	lbu	a4,26(a0)
40011ab4:	0ef71063          	bne	a4,a5,40011b94 <update_operational_state+0x124>
	if (net_if_oper_state(iface) == NET_IF_OPER_UP) {
		if (prev_state != NET_IF_OPER_UP) {
			notify_iface_up(iface);
		}
	} else {
		if (prev_state == NET_IF_OPER_UP) {
40011ab8:	00600793          	li	a5,6
40011abc:	0af91e63          	bne	s2,a5,40011b78 <update_operational_state+0x108>
	atomic_clear_bit(iface->if_dev->flags, value);
40011ac0:	00800593          	li	a1,8
40011ac4:	00c50513          	addi	a0,a0,12
40011ac8:	c74fe0ef          	jal	ra,4000ff3c <atomic_clear_bit>
				     const void *info, size_t length);

static inline void net_mgmt_event_notify(uint32_t mgmt_event,
					 struct net_if *iface)
{
	net_mgmt_event_notify_with_info(mgmt_event, iface, NULL, 0);
40011acc:	d0010537          	lui	a0,0xd0010
40011ad0:	00000693          	li	a3,0
40011ad4:	00000613          	li	a2,0
40011ad8:	00048593          	mv	a1,s1
40011adc:	00150513          	addi	a0,a0,1 # d0010001 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd0010002>
40011ae0:	3ed030ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
	    !(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
40011ae4:	00048513          	mv	a0,s1
40011ae8:	aacfe0ef          	jal	ra,4000fd94 <l2_flags_get>
}
40011aec:	08c0006f          	j	40011b78 <update_operational_state+0x108>
 */
static inline bool net_if_is_carrier_ok(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_LOWER_UP);
40011af0:	00900593          	li	a1,9
40011af4:	00048513          	mv	a0,s1
40011af8:	b61fe0ef          	jal	ra,40010658 <net_if_flag_is_set>
	if (!net_if_is_carrier_ok(iface)) {
40011afc:	fa0502e3          	beqz	a0,40011aa0 <update_operational_state+0x30>
 */
static inline bool net_if_is_dormant(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_DORMANT);
40011b00:	00a00593          	li	a1,10
40011b04:	00048513          	mv	a0,s1
40011b08:	b51fe0ef          	jal	ra,40010658 <net_if_flag_is_set>
		iface->if_dev->oper_state = oper_state;
40011b0c:	0004a703          	lw	a4,0(s1)
40011b10:	00600793          	li	a5,6
40011b14:	40a787b3          	sub	a5,a5,a0
40011b18:	0ff7f793          	zext.b	a5,a5
40011b1c:	00f70d23          	sb	a5,26(a4)
	return iface->if_dev->oper_state;
40011b20:	0004a503          	lw	a0,0(s1)
	if (net_if_oper_state_set(iface, new_state) != new_state) {
40011b24:	01a54703          	lbu	a4,26(a0)
40011b28:	06f70a63          	beq	a4,a5,40011b9c <update_operational_state+0x12c>
		NET_ERR("Failed to update oper state to %d", new_state);
40011b2c:	40044537          	lui	a0,0x40044
40011b30:	77452703          	lw	a4,1908(a0) # 40044774 <log_dynamic_net_if>
40011b34:	00777713          	andi	a4,a4,7
40011b38:	04070063          	beqz	a4,40011b78 <update_operational_state+0x108>
40011b3c:	00010493          	mv	s1,sp
40011b40:	fe010113          	addi	sp,sp,-32
40011b44:	00010613          	mv	a2,sp
40011b48:	40035737          	lui	a4,0x40035
40011b4c:	00f62c23          	sw	a5,24(a2)
40011b50:	a8c70713          	addi	a4,a4,-1396 # 40034a8c <net_buf_fixed_cb+0x12c>
40011b54:	00300793          	li	a5,3
40011b58:	000025b7          	lui	a1,0x2
40011b5c:	00e62a23          	sw	a4,20(a2)
40011b60:	00f62823          	sw	a5,16(a2)
40011b64:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
40011b68:	01060613          	addi	a2,a2,16
40011b6c:	77450513          	addi	a0,a0,1908
40011b70:	c30fe0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
40011b74:	00048113          	mv	sp,s1
			notify_iface_down(iface);
		}
	}
}
40011b78:	ff040113          	addi	sp,s0,-16
40011b7c:	00c12083          	lw	ra,12(sp)
40011b80:	00812403          	lw	s0,8(sp)
40011b84:	00412483          	lw	s1,4(sp)
40011b88:	00012903          	lw	s2,0(sp)
40011b8c:	01010113          	addi	sp,sp,16
40011b90:	00008067          	ret
		new_state = NET_IF_OPER_DOWN;
40011b94:	00200793          	li	a5,2
40011b98:	f95ff06f          	j	40011b2c <update_operational_state+0xbc>
	if (net_if_oper_state(iface) == NET_IF_OPER_UP) {
40011b9c:	00600793          	li	a5,6
40011ba0:	f0f71ce3          	bne	a4,a5,40011ab8 <update_operational_state+0x48>
		if (prev_state != NET_IF_OPER_UP) {
40011ba4:	fce90ae3          	beq	s2,a4,40011b78 <update_operational_state+0x108>
	net_if_flag_set(iface, NET_IF_RUNNING);
40011ba8:	00800593          	li	a1,8
40011bac:	df9fe0ef          	jal	ra,400109a4 <net_if_flag_set.isra.0>
40011bb0:	d0010537          	lui	a0,0xd0010
40011bb4:	00000693          	li	a3,0
40011bb8:	00000613          	li	a2,0
40011bbc:	00048593          	mv	a1,s1
40011bc0:	00250513          	addi	a0,a0,2 # d0010002 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd0010003>
40011bc4:	309030ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
	    !(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
40011bc8:	00048513          	mv	a0,s1
40011bcc:	9c8fe0ef          	jal	ra,4000fd94 <l2_flags_get>
	if (!is_iface_offloaded(iface) &&
40011bd0:	00857513          	andi	a0,a0,8
40011bd4:	fa0512e3          	bnez	a0,40011b78 <update_operational_state+0x108>
	if (!net_if_flag_is_set(iface, NET_IF_IPV6) ||
40011bd8:	00700593          	li	a1,7
40011bdc:	00048513          	mv	a0,s1
40011be0:	a79fe0ef          	jal	ra,40010658 <net_if_flag_is_set>
40011be4:	f8050ae3          	beqz	a0,40011b78 <update_operational_state+0x108>
	    net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {
40011be8:	00b00593          	li	a1,11
40011bec:	00048513          	mv	a0,s1
40011bf0:	a69fe0ef          	jal	ra,40010658 <net_if_flag_is_set>
	if (!net_if_flag_is_set(iface, NET_IF_IPV6) ||
40011bf4:	f80512e3          	bnez	a0,40011b78 <update_operational_state+0x108>
		net_if_start_dad(iface);
40011bf8:	00048513          	mv	a0,s1
40011bfc:	bf9ff0ef          	jal	ra,400117f4 <net_if_start_dad>
	net_if_start_rs(iface);
40011c00:	00048513          	mv	a0,s1
40011c04:	a9cff0ef          	jal	ra,40010ea0 <net_if_start_rs>
40011c08:	f71ff06f          	j	40011b78 <update_operational_state+0x108>

40011c0c <net_if_ipv6_maddr_rm>:
{
40011c0c:	fc010113          	addi	sp,sp,-64
40011c10:	03312623          	sw	s3,44(sp)
40011c14:	03512223          	sw	s5,36(sp)
40011c18:	00050993          	mv	s3,a0
40011c1c:	00058a93          	mv	s5,a1
	k_mutex_lock(&lock, K_FOREVER);
40011c20:	fff00513          	li	a0,-1
40011c24:	fff00593          	li	a1,-1
{
40011c28:	03412423          	sw	s4,40(sp)
40011c2c:	02112e23          	sw	ra,60(sp)
40011c30:	02812c23          	sw	s0,56(sp)
40011c34:	02912a23          	sw	s1,52(sp)
40011c38:	03212823          	sw	s2,48(sp)
40011c3c:	03612023          	sw	s6,32(sp)
40011c40:	01712e23          	sw	s7,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
40011c44:	b64fe0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
40011c48:	0bc9aa03          	lw	s4,188(s3)
	if (!ipv6) {
40011c4c:	0a0a0263          	beqz	s4,40011cf0 <net_if_ipv6_maddr_rm+0xe4>
40011c50:	094a0613          	addi	a2,s4,148
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
40011c54:	00000913          	li	s2,0
		if (!ipv6->mcast[i].is_used) {
40011c58:	01800b93          	li	s7,24
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
40011c5c:	00400b13          	li	s6,4
		if (!ipv6->mcast[i].is_used) {
40011c60:	037904b3          	mul	s1,s2,s7
40011c64:	009a04b3          	add	s1,s4,s1
40011c68:	0a44a783          	lw	a5,164(s1)
40011c6c:	0017f793          	andi	a5,a5,1
40011c70:	06078a63          	beqz	a5,40011ce4 <net_if_ipv6_maddr_rm+0xd8>
		if (!net_ipv6_addr_cmp(&ipv6->mcast[i].address.in6_addr,
40011c74:	00060513          	mv	a0,a2
40011c78:	000a8593          	mv	a1,s5
40011c7c:	00c12623          	sw	a2,12(sp)
40011c80:	a7cfe0ef          	jal	ra,4000fefc <net_ipv6_addr_cmp>
40011c84:	00c12603          	lw	a2,12(sp)
40011c88:	00050413          	mv	s0,a0
40011c8c:	04050c63          	beqz	a0,40011ce4 <net_if_ipv6_maddr_rm+0xd8>
		ipv6->mcast[i].is_used = false;
40011c90:	0a44c783          	lbu	a5,164(s1)
		net_mgmt_event_notify_with_info(
40011c94:	e0600537          	lui	a0,0xe0600
40011c98:	01000693          	li	a3,16
		ipv6->mcast[i].is_used = false;
40011c9c:	ffe7f793          	andi	a5,a5,-2
40011ca0:	0af48223          	sb	a5,164(s1)
		net_mgmt_event_notify_with_info(
40011ca4:	00098593          	mv	a1,s3
40011ca8:	00450513          	addi	a0,a0,4 # e0600004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600005>
40011cac:	221030ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
	k_mutex_unlock(&lock);
40011cb0:	b0cfe0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40011cb4:	03c12083          	lw	ra,60(sp)
40011cb8:	00040513          	mv	a0,s0
40011cbc:	03812403          	lw	s0,56(sp)
40011cc0:	03412483          	lw	s1,52(sp)
40011cc4:	03012903          	lw	s2,48(sp)
40011cc8:	02c12983          	lw	s3,44(sp)
40011ccc:	02812a03          	lw	s4,40(sp)
40011cd0:	02412a83          	lw	s5,36(sp)
40011cd4:	02012b03          	lw	s6,32(sp)
40011cd8:	01c12b83          	lw	s7,28(sp)
40011cdc:	04010113          	addi	sp,sp,64
40011ce0:	00008067          	ret
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
40011ce4:	00190913          	addi	s2,s2,1
40011ce8:	01860613          	addi	a2,a2,24
40011cec:	f7691ae3          	bne	s2,s6,40011c60 <net_if_ipv6_maddr_rm+0x54>
	bool ret = false;
40011cf0:	00000413          	li	s0,0
40011cf4:	fbdff06f          	j	40011cb0 <net_if_ipv6_maddr_rm+0xa4>

40011cf8 <net_if_ipv6_addr_rm>:
{
40011cf8:	fc010113          	addi	sp,sp,-64
40011cfc:	03212823          	sw	s2,48(sp)
40011d00:	03412423          	sw	s4,40(sp)
40011d04:	00058913          	mv	s2,a1
40011d08:	00050a13          	mv	s4,a0
	k_mutex_lock(&lock, K_FOREVER);
40011d0c:	fff00593          	li	a1,-1
40011d10:	fff00513          	li	a0,-1
{
40011d14:	02812c23          	sw	s0,56(sp)
40011d18:	02112e23          	sw	ra,60(sp)
40011d1c:	02912a23          	sw	s1,52(sp)
40011d20:	03312623          	sw	s3,44(sp)
40011d24:	03512223          	sw	s5,36(sp)
40011d28:	03612023          	sw	s6,32(sp)
40011d2c:	01712e23          	sw	s7,28(sp)
40011d30:	01812c23          	sw	s8,24(sp)
40011d34:	01912a23          	sw	s9,20(sp)
	k_mutex_lock(&lock, K_FOREVER);
40011d38:	a70fe0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
40011d3c:	0bca2403          	lw	s0,188(s4)
	if (!ipv6) {
40011d40:	04041263          	bnez	s0,40011d84 <net_if_ipv6_addr_rm+0x8c>
	bool ret = false;
40011d44:	00000993          	li	s3,0
	k_mutex_unlock(&lock);
40011d48:	a74fe0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40011d4c:	03c12083          	lw	ra,60(sp)
40011d50:	03812403          	lw	s0,56(sp)
40011d54:	03412483          	lw	s1,52(sp)
40011d58:	03012903          	lw	s2,48(sp)
40011d5c:	02812a03          	lw	s4,40(sp)
40011d60:	02412a83          	lw	s5,36(sp)
40011d64:	02012b03          	lw	s6,32(sp)
40011d68:	01c12b83          	lw	s7,28(sp)
40011d6c:	01812c03          	lw	s8,24(sp)
40011d70:	01412c83          	lw	s9,20(sp)
40011d74:	00098513          	mv	a0,s3
40011d78:	02c12983          	lw	s3,44(sp)
40011d7c:	04010113          	addi	sp,sp,64
40011d80:	00008067          	ret
40011d84:	00440a93          	addi	s5,s0,4
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40011d88:	00000493          	li	s1,0
		if (!ipv6->unicast[i].is_used) {
40011d8c:	03000c93          	li	s9,48
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40011d90:	00300c13          	li	s8,3
		if (!ipv6->unicast[i].is_used) {
40011d94:	03948b33          	mul	s6,s1,s9
40011d98:	01640bb3          	add	s7,s0,s6
40011d9c:	02cba783          	lw	a5,44(s7)
40011da0:	0197d793          	srli	a5,a5,0x19
40011da4:	0017f793          	andi	a5,a5,1
40011da8:	0c078263          	beqz	a5,40011e6c <net_if_ipv6_addr_rm+0x174>
		if (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr,
40011dac:	00090593          	mv	a1,s2
40011db0:	000a8513          	mv	a0,s5
40011db4:	948fe0ef          	jal	ra,4000fefc <net_ipv6_addr_cmp>
40011db8:	00050993          	mv	s3,a0
40011dbc:	0a050863          	beqz	a0,40011e6c <net_if_ipv6_addr_rm+0x174>
		if (!ipv6->unicast[i].is_infinite) {
40011dc0:	02fbc783          	lbu	a5,47(s7)
40011dc4:	0017f793          	andi	a5,a5,1
40011dc8:	02079663          	bnez	a5,40011df4 <net_if_ipv6_addr_rm+0xfc>
			sys_slist_find_and_remove(
40011dcc:	014b0593          	addi	a1,s6,20
40011dd0:	40039b37          	lui	s6,0x40039
40011dd4:	00b405b3          	add	a1,s0,a1
40011dd8:	060b0513          	addi	a0,s6,96 # 40039060 <active_address_lifetime_timers>
40011ddc:	de1fd0ef          	jal	ra,4000fbbc <sys_slist_find_and_remove>
			if (sys_slist_is_empty(
40011de0:	060b2783          	lw	a5,96(s6)
40011de4:	00079863          	bnez	a5,40011df4 <net_if_ipv6_addr_rm+0xfc>
				k_work_cancel_delayable(
40011de8:	4003a537          	lui	a0,0x4003a
40011dec:	9d050513          	addi	a0,a0,-1584 # 400399d0 <address_lifetime_timer>
40011df0:	37c1e0ef          	jal	ra,4003016c <k_work_cancel_delayable>
		ipv6->unicast[i].is_used = false;
40011df4:	03000793          	li	a5,48
40011df8:	02f484b3          	mul	s1,s1,a5
		net_if_ipv6_maddr_rm(iface, &maddr);
40011dfc:	00010593          	mv	a1,sp
40011e00:	000a0513          	mv	a0,s4
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
40011e04:	00012223          	sw	zero,4(sp)
		ipv6->unicast[i].is_used = false;
40011e08:	00940433          	add	s0,s0,s1
40011e0c:	02f44783          	lbu	a5,47(s0)
40011e10:	ffd7f793          	andi	a5,a5,-3
40011e14:	02f407a3          	sb	a5,47(s0)
	dst->s6_addr[0]   = 0xFF;
40011e18:	2ff00793          	li	a5,767
40011e1c:	00f12023          	sw	a5,0(sp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
40011e20:	010007b7          	lui	a5,0x1000
40011e24:	00f12423          	sw	a5,8(sp)
	dst->s6_addr[12]  = 0xFF;
40011e28:	fff00793          	li	a5,-1
40011e2c:	00f10623          	sb	a5,12(sp)
	dst->s6_addr[13]  = src->s6_addr[13];
40011e30:	00d94783          	lbu	a5,13(s2)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
40011e34:	00e94703          	lbu	a4,14(s2)
	dst->s6_addr[13]  = src->s6_addr[13];
40011e38:	00f106a3          	sb	a5,13(sp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
40011e3c:	00f94783          	lbu	a5,15(s2)
40011e40:	00879793          	slli	a5,a5,0x8
40011e44:	00e7e7b3          	or	a5,a5,a4
40011e48:	00f11723          	sh	a5,14(sp)
		net_if_ipv6_maddr_rm(iface, &maddr);
40011e4c:	dc1ff0ef          	jal	ra,40011c0c <net_if_ipv6_maddr_rm>
		net_mgmt_event_notify_with_info(
40011e50:	e0600537          	lui	a0,0xe0600
40011e54:	01000693          	li	a3,16
40011e58:	000a8613          	mv	a2,s5
40011e5c:	000a0593          	mv	a1,s4
40011e60:	00250513          	addi	a0,a0,2 # e0600002 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600003>
40011e64:	069030ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
		goto out;
40011e68:	ee1ff06f          	j	40011d48 <net_if_ipv6_addr_rm+0x50>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40011e6c:	00148493          	addi	s1,s1,1
40011e70:	030a8a93          	addi	s5,s5,48
40011e74:	f38490e3          	bne	s1,s8,40011d94 <net_if_ipv6_addr_rm+0x9c>
40011e78:	ecdff06f          	j	40011d44 <net_if_ipv6_addr_rm+0x4c>

40011e7c <net_if_ipv6_dad_failed>:
{
40011e7c:	fd010113          	addi	sp,sp,-48
40011e80:	02812423          	sw	s0,40(sp)
40011e84:	02912223          	sw	s1,36(sp)
40011e88:	03010413          	addi	s0,sp,48
40011e8c:	02112623          	sw	ra,44(sp)
40011e90:	03212023          	sw	s2,32(sp)
40011e94:	01312e23          	sw	s3,28(sp)
40011e98:	fca42e23          	sw	a0,-36(s0)
40011e9c:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
40011ea0:	fff00513          	li	a0,-1
40011ea4:	fff00593          	li	a1,-1
40011ea8:	900fe0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	ifaddr = net_if_ipv6_addr_lookup(addr, &iface);
40011eac:	fdc40593          	addi	a1,s0,-36
40011eb0:	00048513          	mv	a0,s1
40011eb4:	9fcff0ef          	jal	ra,400110b0 <net_if_ipv6_addr_lookup>
	if (!ifaddr) {
40011eb8:	08051a63          	bnez	a0,40011f4c <net_if_ipv6_dad_failed+0xd0>
		NET_ERR("Cannot find %s address in interface %p",
40011ebc:	40044937          	lui	s2,0x40044
40011ec0:	77492783          	lw	a5,1908(s2) # 40044774 <log_dynamic_net_if>
40011ec4:	0077f793          	andi	a5,a5,7
40011ec8:	06078063          	beqz	a5,40011f28 <net_if_ipv6_dad_failed+0xac>
40011ecc:	00048593          	mv	a1,s1
40011ed0:	00200513          	li	a0,2
40011ed4:	1e1020ef          	jal	ra,400148b4 <net_sprint_addr>
40011ed8:	00010493          	mv	s1,sp
40011edc:	fd010113          	addi	sp,sp,-48
40011ee0:	fdc42703          	lw	a4,-36(s0)
40011ee4:	00010613          	mv	a2,sp
40011ee8:	400357b7          	lui	a5,0x40035
40011eec:	ab078793          	addi	a5,a5,-1360 # 40034ab0 <net_buf_fixed_cb+0x150>
40011ef0:	00f62a23          	sw	a5,20(a2)
40011ef4:	20000793          	li	a5,512
40011ef8:	02f61023          	sh	a5,32(a2)
40011efc:	010007b7          	lui	a5,0x1000
40011f00:	00478793          	addi	a5,a5,4 # 1000004 <__rom_region_size+0xfc7048>
40011f04:	000025b7          	lui	a1,0x2
40011f08:	00a62c23          	sw	a0,24(a2)
40011f0c:	00e62e23          	sw	a4,28(a2)
40011f10:	00f62823          	sw	a5,16(a2)
40011f14:	44058593          	addi	a1,a1,1088 # 2440 <CONFIG_SRAM_SIZE+0x440>
40011f18:	01060613          	addi	a2,a2,16
40011f1c:	77490513          	addi	a0,s2,1908
40011f20:	880fe0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
40011f24:	00048113          	mv	sp,s1
	k_mutex_unlock(&lock);
40011f28:	894fe0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40011f2c:	fd040113          	addi	sp,s0,-48
40011f30:	02c12083          	lw	ra,44(sp)
40011f34:	02812403          	lw	s0,40(sp)
40011f38:	02412483          	lw	s1,36(sp)
40011f3c:	02012903          	lw	s2,32(sp)
40011f40:	01c12983          	lw	s3,28(sp)
40011f44:	03010113          	addi	sp,sp,48
40011f48:	00008067          	ret
40011f4c:	00050913          	mv	s2,a0
	sys_slist_find_and_remove(&active_dad_timers, &ifaddr->dad_node);
40011f50:	02450593          	addi	a1,a0,36
40011f54:	40039537          	lui	a0,0x40039
40011f58:	05050513          	addi	a0,a0,80 # 40039050 <active_dad_timers>
40011f5c:	c61fd0ef          	jal	ra,4000fbbc <sys_slist_find_and_remove>
	net_mgmt_event_notify_with_info(NET_EVENT_IPV6_DAD_FAILED, iface,
40011f60:	fdc42983          	lw	s3,-36(s0)
40011f64:	e0600537          	lui	a0,0xe0600
40011f68:	01000693          	li	a3,16
40011f6c:	00098593          	mv	a1,s3
40011f70:	00490613          	addi	a2,s2,4
40011f74:	00e50513          	addi	a0,a0,14 # e060000e <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000f>
40011f78:	754030ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
	net_if_ipv6_addr_rm(iface, addr);
40011f7c:	00048593          	mv	a1,s1
40011f80:	00098513          	mv	a0,s3
40011f84:	d75ff0ef          	jal	ra,40011cf8 <net_if_ipv6_addr_rm>
40011f88:	fa1ff06f          	j	40011f28 <net_if_ipv6_dad_failed+0xac>

40011f8c <remove_prefix_addresses>:
{
40011f8c:	fd010113          	addi	sp,sp,-48
40011f90:	02812423          	sw	s0,40(sp)
40011f94:	02912223          	sw	s1,36(sp)
40011f98:	03212023          	sw	s2,32(sp)
40011f9c:	01312e23          	sw	s3,28(sp)
40011fa0:	01412c23          	sw	s4,24(sp)
40011fa4:	01512a23          	sw	s5,20(sp)
40011fa8:	01612823          	sw	s6,16(sp)
40011fac:	01712623          	sw	s7,12(sp)
40011fb0:	01812423          	sw	s8,8(sp)
40011fb4:	01912223          	sw	s9,4(sp)
40011fb8:	02112623          	sw	ra,44(sp)
40011fbc:	00050913          	mv	s2,a0
40011fc0:	00058493          	mv	s1,a1
40011fc4:	00060993          	mv	s3,a2
40011fc8:	00068a13          	mv	s4,a3
40011fcc:	00458413          	addi	s0,a1,4
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40011fd0:	00000c93          	li	s9,0
		if (!ipv6->unicast[i].is_used ||
40011fd4:	03000b13          	li	s6,48
40011fd8:	00200b93          	li	s7,2
		    ipv6->unicast[i].address.family != AF_INET6 ||
40011fdc:	00100c13          	li	s8,1
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40011fe0:	00300a93          	li	s5,3
		if (!ipv6->unicast[i].is_used ||
40011fe4:	036c87b3          	mul	a5,s9,s6
40011fe8:	00f487b3          	add	a5,s1,a5
40011fec:	02c7a783          	lw	a5,44(a5)
40011ff0:	0197d793          	srli	a5,a5,0x19
40011ff4:	0017f793          	andi	a5,a5,1
40011ff8:	02078a63          	beqz	a5,4001202c <remove_prefix_addresses+0xa0>
40011ffc:	ffc45783          	lhu	a5,-4(s0)
40012000:	03779663          	bne	a5,s7,4001202c <remove_prefix_addresses+0xa0>
		    ipv6->unicast[i].address.family != AF_INET6 ||
40012004:	02844783          	lbu	a5,40(s0)
40012008:	03879263          	bne	a5,s8,4001202c <remove_prefix_addresses+0xa0>
		if (net_ipv6_is_prefix(
4001200c:	000a0613          	mv	a2,s4
40012010:	00040593          	mv	a1,s0
40012014:	00098513          	mv	a0,s3
40012018:	e39fd0ef          	jal	ra,4000fe50 <net_ipv6_is_prefix>
4001201c:	00050863          	beqz	a0,4001202c <remove_prefix_addresses+0xa0>
			net_if_ipv6_addr_rm(iface,
40012020:	00040593          	mv	a1,s0
40012024:	00090513          	mv	a0,s2
40012028:	cd1ff0ef          	jal	ra,40011cf8 <net_if_ipv6_addr_rm>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4001202c:	001c8c93          	addi	s9,s9,1
40012030:	03040413          	addi	s0,s0,48
40012034:	fb5c98e3          	bne	s9,s5,40011fe4 <remove_prefix_addresses+0x58>
}
40012038:	02c12083          	lw	ra,44(sp)
4001203c:	02812403          	lw	s0,40(sp)
40012040:	02412483          	lw	s1,36(sp)
40012044:	02012903          	lw	s2,32(sp)
40012048:	01c12983          	lw	s3,28(sp)
4001204c:	01812a03          	lw	s4,24(sp)
40012050:	01412a83          	lw	s5,20(sp)
40012054:	01012b03          	lw	s6,16(sp)
40012058:	00c12b83          	lw	s7,12(sp)
4001205c:	00812c03          	lw	s8,8(sp)
40012060:	00412c83          	lw	s9,4(sp)
40012064:	03010113          	addi	sp,sp,48
40012068:	00008067          	ret

4001206c <prefix_lifetime_timeout>:
{
4001206c:	fc010113          	addi	sp,sp,-64
40012070:	02112e23          	sw	ra,60(sp)
40012074:	02812c23          	sw	s0,56(sp)
40012078:	02912a23          	sw	s1,52(sp)
4001207c:	03312623          	sw	s3,44(sp)
40012080:	03212823          	sw	s2,48(sp)
40012084:	03412423          	sw	s4,40(sp)
	uint32_t current_time = k_uptime_get_32();
40012088:	e95fd0ef          	jal	ra,4000ff1c <k_uptime_get_32>
4001208c:	00050993          	mv	s3,a0
	k_mutex_lock(&lock, K_FOREVER);
40012090:	fff00593          	li	a1,-1
40012094:	fff00513          	li	a0,-1
40012098:	f11fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4001209c:	400397b7          	lui	a5,0x40039
400120a0:	0587a403          	lw	s0,88(a5) # 40039058 <active_prefix_lifetime_timers>
400120a4:	00000493          	li	s1,0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
400120a8:	00040463          	beqz	s0,400120b0 <prefix_lifetime_timeout+0x44>
	return node->next;
400120ac:	00042483          	lw	s1,0(s0)
	net_mgmt_event_notify_with_info(
400120b0:	e0600a37          	lui	s4,0xe0600
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
400120b4:	fff00913          	li	s2,-1
	net_mgmt_event_notify_with_info(
400120b8:	006a0a13          	addi	s4,s4,6 # e0600006 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600007>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
400120bc:	08040063          	beqz	s0,4001213c <prefix_lifetime_timeout+0xd0>
		uint32_t this_update = net_timeout_evaluate(timeout,
400120c0:	00098593          	mv	a1,s3
400120c4:	00040513          	mv	a0,s0
400120c8:	260020ef          	jal	ra,40014328 <net_timeout_evaluate>
		if (this_update == 0U) {
400120cc:	06051263          	bnez	a0,40012130 <prefix_lifetime_timeout+0xc4>
	ifprefix->is_used = false;
400120d0:	02544783          	lbu	a5,37(s0)
	if (net_if_config_ipv6_get(ifprefix->iface, &ipv6) < 0) {
400120d4:	02042503          	lw	a0,32(s0)
400120d8:	01c10593          	addi	a1,sp,28
	ifprefix->is_used = false;
400120dc:	ffd7f793          	andi	a5,a5,-3
400120e0:	02f402a3          	sb	a5,37(s0)
	if (net_if_config_ipv6_get(ifprefix->iface, &ipv6) < 0) {
400120e4:	d2dfe0ef          	jal	ra,40010e10 <net_if_config_ipv6_get>
400120e8:	02054863          	bltz	a0,40012118 <prefix_lifetime_timeout+0xac>
	remove_prefix_addresses(ifprefix->iface, ipv6, &ifprefix->prefix,
400120ec:	02444683          	lbu	a3,36(s0)
400120f0:	01c12583          	lw	a1,28(sp)
400120f4:	02042503          	lw	a0,32(s0)
400120f8:	01040613          	addi	a2,s0,16
400120fc:	00c12623          	sw	a2,12(sp)
40012100:	e8dff0ef          	jal	ra,40011f8c <remove_prefix_addresses>
	net_mgmt_event_notify_with_info(
40012104:	00c12603          	lw	a2,12(sp)
40012108:	02042583          	lw	a1,32(s0)
4001210c:	01000693          	li	a3,16
40012110:	000a0513          	mv	a0,s4
40012114:	5b8030ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
40012118:	00000793          	li	a5,0
4001211c:	00048463          	beqz	s1,40012124 <prefix_lifetime_timeout+0xb8>
40012120:	0004a783          	lw	a5,0(s1)
40012124:	00048413          	mv	s0,s1
40012128:	00078493          	mv	s1,a5
4001212c:	f91ff06f          	j	400120bc <prefix_lifetime_timeout+0x50>
		if (this_update < next_update) {
40012130:	01257463          	bgeu	a0,s2,40012138 <prefix_lifetime_timeout+0xcc>
40012134:	00050913          	mv	s2,a0
		if (current == next) {
40012138:	fe9410e3          	bne	s0,s1,40012118 <prefix_lifetime_timeout+0xac>
	if (next_update != UINT32_MAX) {
4001213c:	fff00793          	li	a5,-1
40012140:	02f90663          	beq	s2,a5,4001216c <prefix_lifetime_timeout+0x100>
		t += off;
40012144:	00990513          	addi	a0,s2,9
			return t / ((uint64_t)from_hz / to_hz);
40012148:	00a00613          	li	a2,10
4001214c:	00000693          	li	a3,0
40012150:	012535b3          	sltu	a1,a0,s2
40012154:	964ee0ef          	jal	ra,400002b8 <__udivdi3>
		k_work_reschedule(&prefix_lifetime_timer, K_MSEC(next_update));
40012158:	00058613          	mv	a2,a1
4001215c:	00050593          	mv	a1,a0
40012160:	4003a537          	lui	a0,0x4003a
40012164:	9a050513          	addi	a0,a0,-1632 # 400399a0 <prefix_lifetime_timer>
40012168:	7ed1d0ef          	jal	ra,40030154 <k_work_reschedule>
}
4001216c:	03812403          	lw	s0,56(sp)
40012170:	03c12083          	lw	ra,60(sp)
40012174:	03412483          	lw	s1,52(sp)
40012178:	03012903          	lw	s2,48(sp)
4001217c:	02c12983          	lw	s3,44(sp)
40012180:	02812a03          	lw	s4,40(sp)
40012184:	04010113          	addi	sp,sp,64
	k_mutex_unlock(&lock);
40012188:	e35fd06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>

4001218c <net_if_ipv6_maddr_lookup>:
{
4001218c:	fd010113          	addi	sp,sp,-48
40012190:	02812423          	sw	s0,40(sp)
40012194:	01312e23          	sw	s3,28(sp)
40012198:	01412c23          	sw	s4,24(sp)
4001219c:	01612823          	sw	s6,16(sp)
400121a0:	00058993          	mv	s3,a1
400121a4:	00050b13          	mv	s6,a0
	k_mutex_lock(&lock, K_FOREVER);
400121a8:	fff00593          	li	a1,-1
400121ac:	fff00513          	li	a0,-1
	STRUCT_SECTION_FOREACH(net_if, iface) {
400121b0:	40045437          	lui	s0,0x40045
400121b4:	40045a37          	lui	s4,0x40045
{
400121b8:	01712623          	sw	s7,12(sp)
400121bc:	01812423          	sw	s8,8(sp)
400121c0:	01912223          	sw	s9,4(sp)
400121c4:	02112623          	sw	ra,44(sp)
400121c8:	02912223          	sw	s1,36(sp)
400121cc:	03212023          	sw	s2,32(sp)
400121d0:	01512a23          	sw	s5,20(sp)
	STRUCT_SECTION_FOREACH(net_if, iface) {
400121d4:	9d840413          	addi	s0,s0,-1576 # 400449d8 <__net_if_dts_ord_12_0>
	k_mutex_lock(&lock, K_FOREVER);
400121d8:	dd1fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
400121dc:	a9ca0a13          	addi	s4,s4,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
			if (!ipv6->mcast[i].is_used ||
400121e0:	01800b93          	li	s7,24
400121e4:	00200c13          	li	s8,2
		for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
400121e8:	00400c93          	li	s9,4
	STRUCT_SECTION_FOREACH(net_if, iface) {
400121ec:	01446663          	bltu	s0,s4,400121f8 <net_if_ipv6_maddr_lookup+0x6c>
	struct net_if_mcast_addr *ifmaddr = NULL;
400121f0:	00000493          	li	s1,0
400121f4:	07c0006f          	j	40012270 <net_if_ipv6_maddr_lookup+0xe4>
		struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
400121f8:	0bc42483          	lw	s1,188(s0)
		if (ret && *ret && iface != *ret) {
400121fc:	0a098863          	beqz	s3,400122ac <net_if_ipv6_maddr_lookup+0x120>
40012200:	0009a783          	lw	a5,0(s3)
40012204:	0a078463          	beqz	a5,400122ac <net_if_ipv6_maddr_lookup+0x120>
40012208:	00878a63          	beq	a5,s0,4001221c <net_if_ipv6_maddr_lookup+0x90>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4001220c:	0c440413          	addi	s0,s0,196
40012210:	ff4470e3          	bgeu	s0,s4,400121f0 <net_if_ipv6_maddr_lookup+0x64>
		struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
40012214:	0bc42483          	lw	s1,188(s0)
		if (ret && *ret && iface != *ret) {
40012218:	fe9ff06f          	j	40012200 <net_if_ipv6_maddr_lookup+0x74>
		if (!ipv6) {
4001221c:	fe0488e3          	beqz	s1,4001220c <net_if_ipv6_maddr_lookup+0x80>
40012220:	09448a93          	addi	s5,s1,148
		for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
40012224:	00000913          	li	s2,0
			if (!ipv6->mcast[i].is_used ||
40012228:	037907b3          	mul	a5,s2,s7
4001222c:	00f487b3          	add	a5,s1,a5
40012230:	0a47a783          	lw	a5,164(a5)
40012234:	0017f793          	andi	a5,a5,1
40012238:	08078063          	beqz	a5,400122b8 <net_if_ipv6_maddr_lookup+0x12c>
4001223c:	ffcad783          	lhu	a5,-4(s5)
40012240:	07879c63          	bne	a5,s8,400122b8 <net_if_ipv6_maddr_lookup+0x12c>
			if (net_ipv6_is_prefix(
40012244:	08000613          	li	a2,128
40012248:	000a8593          	mv	a1,s5
4001224c:	000b0513          	mv	a0,s6
40012250:	c01fd0ef          	jal	ra,4000fe50 <net_ipv6_is_prefix>
40012254:	06050263          	beqz	a0,400122b8 <net_if_ipv6_maddr_lookup+0x12c>
				if (ret) {
40012258:	00098463          	beqz	s3,40012260 <net_if_ipv6_maddr_lookup+0xd4>
					*ret = iface;
4001225c:	0089a023          	sw	s0,0(s3)
				ifmaddr = &ipv6->mcast[i];
40012260:	01800793          	li	a5,24
40012264:	02f90933          	mul	s2,s2,a5
40012268:	09090913          	addi	s2,s2,144
4001226c:	012484b3          	add	s1,s1,s2
	k_mutex_unlock(&lock);
40012270:	d4dfd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40012274:	02c12083          	lw	ra,44(sp)
40012278:	02812403          	lw	s0,40(sp)
4001227c:	02012903          	lw	s2,32(sp)
40012280:	01c12983          	lw	s3,28(sp)
40012284:	01812a03          	lw	s4,24(sp)
40012288:	01412a83          	lw	s5,20(sp)
4001228c:	01012b03          	lw	s6,16(sp)
40012290:	00c12b83          	lw	s7,12(sp)
40012294:	00812c03          	lw	s8,8(sp)
40012298:	00412c83          	lw	s9,4(sp)
4001229c:	00048513          	mv	a0,s1
400122a0:	02412483          	lw	s1,36(sp)
400122a4:	03010113          	addi	sp,sp,48
400122a8:	00008067          	ret
		if (!ipv6) {
400122ac:	f6049ae3          	bnez	s1,40012220 <net_if_ipv6_maddr_lookup+0x94>
	STRUCT_SECTION_FOREACH(net_if, iface) {
400122b0:	0c440413          	addi	s0,s0,196
400122b4:	f39ff06f          	j	400121ec <net_if_ipv6_maddr_lookup+0x60>
		for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
400122b8:	00190913          	addi	s2,s2,1
400122bc:	018a8a93          	addi	s5,s5,24
400122c0:	f79914e3          	bne	s2,s9,40012228 <net_if_ipv6_maddr_lookup+0x9c>
400122c4:	fedff06f          	j	400122b0 <net_if_ipv6_maddr_lookup+0x124>

400122c8 <net_if_ipv6_maddr_add>:
{
400122c8:	fc010113          	addi	sp,sp,-64
400122cc:	02812c23          	sw	s0,56(sp)
400122d0:	03212823          	sw	s2,48(sp)
400122d4:	04010413          	addi	s0,sp,64
400122d8:	02112e23          	sw	ra,60(sp)
400122dc:	02912a23          	sw	s1,52(sp)
400122e0:	03312623          	sw	s3,44(sp)
400122e4:	03412423          	sw	s4,40(sp)
400122e8:	fca42623          	sw	a0,-52(s0)
400122ec:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
400122f0:	fff00513          	li	a0,-1
400122f4:	fff00593          	li	a1,-1
400122f8:	cb1fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
400122fc:	fcc42503          	lw	a0,-52(s0)
40012300:	fdc40593          	addi	a1,s0,-36
40012304:	b0dfe0ef          	jal	ra,40010e10 <net_if_config_ipv6_get>
40012308:	08054263          	bltz	a0,4001238c <net_if_ipv6_maddr_add+0xc4>
	if (!net_ipv6_is_addr_mcast(addr)) {
4001230c:	00094703          	lbu	a4,0(s2)
40012310:	0ff00793          	li	a5,255
40012314:	06f71c63          	bne	a4,a5,4001238c <net_if_ipv6_maddr_add+0xc4>
	if (net_if_ipv6_maddr_lookup(addr, &iface)) {
40012318:	fcc40593          	addi	a1,s0,-52
4001231c:	00090513          	mv	a0,s2
40012320:	e6dff0ef          	jal	ra,4001218c <net_if_ipv6_maddr_lookup>
40012324:	08050c63          	beqz	a0,400123bc <net_if_ipv6_maddr_add+0xf4>
		NET_WARN("Multicast address %s is is already registered.",
40012328:	400444b7          	lui	s1,0x40044
4001232c:	7744a783          	lw	a5,1908(s1) # 40044774 <log_dynamic_net_if>
40012330:	0067f793          	andi	a5,a5,6
40012334:	04078c63          	beqz	a5,4001238c <net_if_ipv6_maddr_add+0xc4>
40012338:	00090593          	mv	a1,s2
4001233c:	00200513          	li	a0,2
40012340:	574020ef          	jal	ra,400148b4 <net_sprint_addr>
40012344:	00010913          	mv	s2,sp
40012348:	fe010113          	addi	sp,sp,-32
4001234c:	00010613          	mv	a2,sp
40012350:	400357b7          	lui	a5,0x40035
40012354:	ad878793          	addi	a5,a5,-1320 # 40034ad8 <net_buf_fixed_cb+0x178>
40012358:	00f62a23          	sw	a5,20(a2)
4001235c:	20000793          	li	a5,512
40012360:	00f61e23          	sh	a5,28(a2)
40012364:	010007b7          	lui	a5,0x1000
40012368:	00378793          	addi	a5,a5,3 # 1000003 <__rom_region_size+0xfc7047>
4001236c:	000025b7          	lui	a1,0x2
40012370:	00a62c23          	sw	a0,24(a2)
40012374:	00f62823          	sw	a5,16(a2)
40012378:	c8058593          	addi	a1,a1,-896 # 1c80 <CONFIG_HEAP_MEM_POOL_SIZE+0xc80>
4001237c:	01060613          	addi	a2,a2,16
40012380:	77448513          	addi	a0,s1,1908
40012384:	c1dfd0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
40012388:	00090113          	mv	sp,s2
	struct net_if_mcast_addr *ifmaddr = NULL;
4001238c:	00000493          	li	s1,0
	k_mutex_unlock(&lock);
40012390:	c2dfd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40012394:	fc040113          	addi	sp,s0,-64
40012398:	03c12083          	lw	ra,60(sp)
4001239c:	00048513          	mv	a0,s1
400123a0:	03812403          	lw	s0,56(sp)
400123a4:	03412483          	lw	s1,52(sp)
400123a8:	03012903          	lw	s2,48(sp)
400123ac:	02c12983          	lw	s3,44(sp)
400123b0:	02812a03          	lw	s4,40(sp)
400123b4:	04010113          	addi	sp,sp,64
400123b8:	00008067          	ret
		if (ipv6->mcast[i].is_used) {
400123bc:	fdc42483          	lw	s1,-36(s0)
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
400123c0:	00000713          	li	a4,0
		if (ipv6->mcast[i].is_used) {
400123c4:	01800593          	li	a1,24
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
400123c8:	00400613          	li	a2,4
		if (ipv6->mcast[i].is_used) {
400123cc:	02b709b3          	mul	s3,a4,a1
400123d0:	013487b3          	add	a5,s1,s3
400123d4:	0a47a683          	lw	a3,164(a5)
400123d8:	0016f693          	andi	a3,a3,1
400123dc:	00068863          	beqz	a3,400123ec <net_if_ipv6_maddr_add+0x124>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
400123e0:	00170713          	addi	a4,a4,1
400123e4:	fec714e3          	bne	a4,a2,400123cc <net_if_ipv6_maddr_add+0x104>
400123e8:	fa5ff06f          	j	4001238c <net_if_ipv6_maddr_add+0xc4>
		ipv6->mcast[i].is_used = true;
400123ec:	0a47c703          	lbu	a4,164(a5)
		memcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);
400123f0:	09498a13          	addi	s4,s3,148
400123f4:	01448a33          	add	s4,s1,s4
		ipv6->mcast[i].is_used = true;
400123f8:	00176713          	ori	a4,a4,1
400123fc:	0ae78223          	sb	a4,164(a5)
		ipv6->mcast[i].address.family = AF_INET6;
40012400:	00200713          	li	a4,2
40012404:	08e79823          	sh	a4,144(a5)
		memcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);
40012408:	01000613          	li	a2,16
4001240c:	00090593          	mv	a1,s2
40012410:	000a0513          	mv	a0,s4
40012414:	8e5fa0ef          	jal	ra,4000ccf8 <memcpy>
		net_mgmt_event_notify_with_info(
40012418:	fcc42583          	lw	a1,-52(s0)
4001241c:	e0600537          	lui	a0,0xe0600
40012420:	01000693          	li	a3,16
40012424:	000a0613          	mv	a2,s4
40012428:	00350513          	addi	a0,a0,3 # e0600003 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600004>
		ifmaddr = &ipv6->mcast[i];
4001242c:	09098993          	addi	s3,s3,144
		net_mgmt_event_notify_with_info(
40012430:	29c030ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
		ifmaddr = &ipv6->mcast[i];
40012434:	013484b3          	add	s1,s1,s3
		goto out;
40012438:	f59ff06f          	j	40012390 <net_if_ipv6_maddr_add+0xc8>

4001243c <net_if_ipv6_maddr_join>:
{
4001243c:	ff010113          	addi	sp,sp,-16
40012440:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012444:	fff00593          	li	a1,-1
{
40012448:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4001244c:	fff00513          	li	a0,-1
{
40012450:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012454:	b55fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	addr->is_joined = true;
40012458:	01444783          	lbu	a5,20(s0)
4001245c:	0027e793          	ori	a5,a5,2
40012460:	00f40a23          	sb	a5,20(s0)
}
40012464:	00812403          	lw	s0,8(sp)
40012468:	00c12083          	lw	ra,12(sp)
4001246c:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
40012470:	b4dfd06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>

40012474 <net_if_ipv6_prefix_add>:
{
40012474:	fb010113          	addi	sp,sp,-80
40012478:	03312e23          	sw	s3,60(sp)
4001247c:	03612823          	sw	s6,48(sp)
40012480:	00050993          	mv	s3,a0
40012484:	00058b13          	mv	s6,a1
	k_mutex_lock(&lock, K_FOREVER);
40012488:	fff00513          	li	a0,-1
4001248c:	fff00593          	li	a1,-1
{
40012490:	05212023          	sw	s2,64(sp)
40012494:	03712623          	sw	s7,44(sp)
40012498:	04112623          	sw	ra,76(sp)
4001249c:	04812423          	sw	s0,72(sp)
400124a0:	04912223          	sw	s1,68(sp)
400124a4:	03412c23          	sw	s4,56(sp)
400124a8:	03512a23          	sw	s5,52(sp)
400124ac:	00060b93          	mv	s7,a2
400124b0:	00068913          	mv	s2,a3
	k_mutex_lock(&lock, K_FOREVER);
400124b4:	af5fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
400124b8:	00c10593          	addi	a1,sp,12
400124bc:	00098513          	mv	a0,s3
400124c0:	951fe0ef          	jal	ra,40010e10 <net_if_config_ipv6_get>
400124c4:	02055e63          	bgez	a0,40012500 <net_if_ipv6_prefix_add+0x8c>
	struct net_if_ipv6_prefix *ifprefix = NULL;
400124c8:	00000493          	li	s1,0
	k_mutex_unlock(&lock);
400124cc:	af1fd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
400124d0:	04c12083          	lw	ra,76(sp)
400124d4:	04812403          	lw	s0,72(sp)
400124d8:	04012903          	lw	s2,64(sp)
400124dc:	03c12983          	lw	s3,60(sp)
400124e0:	03812a03          	lw	s4,56(sp)
400124e4:	03412a83          	lw	s5,52(sp)
400124e8:	03012b03          	lw	s6,48(sp)
400124ec:	02c12b83          	lw	s7,44(sp)
400124f0:	00048513          	mv	a0,s1
400124f4:	04412483          	lw	s1,68(sp)
400124f8:	05010113          	addi	sp,sp,80
400124fc:	00008067          	ret
	ifprefix = ipv6_prefix_find(iface, prefix, len);
40012500:	0bc9a483          	lw	s1,188(s3)
	if (!ipv6) {
40012504:	0a049863          	bnez	s1,400125b4 <net_if_ipv6_prefix_add+0x140>
	if (!ipv6) {
40012508:	00c12a03          	lw	s4,12(sp)
4001250c:	fa0a0ee3          	beqz	s4,400124c8 <net_if_ipv6_prefix_add+0x54>
		if (ipv6->prefix[i].is_used) {
40012510:	114a2783          	lw	a5,276(s4)
40012514:	0097d793          	srli	a5,a5,0x9
40012518:	0017f793          	andi	a5,a5,1
4001251c:	10078063          	beqz	a5,4001261c <net_if_ipv6_prefix_add+0x1a8>
40012520:	13ca2783          	lw	a5,316(s4)
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
40012524:	00100413          	li	s0,1
		if (ipv6->prefix[i].is_used) {
40012528:	0097d793          	srli	a5,a5,0x9
4001252c:	0017f793          	andi	a5,a5,1
40012530:	f8079ce3          	bnez	a5,400124c8 <net_if_ipv6_prefix_add+0x54>
		net_if_ipv6_prefix_init(iface, &ipv6->prefix[i], prefix,
40012534:	02800793          	li	a5,40
40012538:	02f40433          	mul	s0,s0,a5
	net_ipaddr_copy(&ifprefix->prefix, addr);
4001253c:	000b0593          	mv	a1,s6
40012540:	01000613          	li	a2,16
40012544:	01010513          	addi	a0,sp,16
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
40012548:	00190913          	addi	s2,s2,1
4001254c:	00193913          	seqz	s2,s2
	ifprefix->is_used = true;
40012550:	008a0ab3          	add	s5,s4,s0
40012554:	115ac783          	lbu	a5,277(s5)
		net_if_ipv6_prefix_init(iface, &ipv6->prefix[i], prefix,
40012558:	0f040493          	addi	s1,s0,240
	ifprefix->len = len;
4001255c:	117a8a23          	sb	s7,276(s5)
	ifprefix->is_used = true;
40012560:	0027e793          	ori	a5,a5,2
40012564:	10fa8aa3          	sb	a5,277(s5)
	ifprefix->iface = iface;
40012568:	113aa823          	sw	s3,272(s5)
	net_ipaddr_copy(&ifprefix->prefix, addr);
4001256c:	f8cfa0ef          	jal	ra,4000ccf8 <memcpy>
		net_if_ipv6_prefix_init(iface, &ipv6->prefix[i], prefix,
40012570:	009a04b3          	add	s1,s4,s1
	net_ipaddr_copy(&ifprefix->prefix, addr);
40012574:	01010593          	addi	a1,sp,16
40012578:	01000613          	li	a2,16
4001257c:	01048513          	addi	a0,s1,16
40012580:	f78fa0ef          	jal	ra,4000ccf8 <memcpy>
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
40012584:	115ac783          	lbu	a5,277(s5)
			&ipv6->prefix[i].prefix, sizeof(struct in6_addr));
40012588:	10040613          	addi	a2,s0,256
		net_mgmt_event_notify_with_info(
4001258c:	e0600537          	lui	a0,0xe0600
40012590:	ffe7f793          	andi	a5,a5,-2
40012594:	0127e7b3          	or	a5,a5,s2
40012598:	10fa8aa3          	sb	a5,277(s5)
4001259c:	01000693          	li	a3,16
400125a0:	00ca0633          	add	a2,s4,a2
400125a4:	00098593          	mv	a1,s3
400125a8:	00550513          	addi	a0,a0,5 # e0600005 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600006>
400125ac:	120030ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
		goto out;
400125b0:	f1dff06f          	j	400124cc <net_if_ipv6_prefix_add+0x58>
		if (!ipv6->prefix[i].is_used) {
400125b4:	1144a783          	lw	a5,276(s1)
400125b8:	0097d793          	srli	a5,a5,0x9
400125bc:	0017f793          	andi	a5,a5,1
400125c0:	00078e63          	beqz	a5,400125dc <net_if_ipv6_prefix_add+0x168>
		if (net_ipv6_addr_cmp(prefix, &ipv6->prefix[i].prefix) &&
400125c4:	10048593          	addi	a1,s1,256
400125c8:	000b0513          	mv	a0,s6
400125cc:	931fd0ef          	jal	ra,4000fefc <net_ipv6_addr_cmp>
400125d0:	00050663          	beqz	a0,400125dc <net_if_ipv6_prefix_add+0x168>
400125d4:	1144c783          	lbu	a5,276(s1)
400125d8:	03778e63          	beq	a5,s7,40012614 <net_if_ipv6_prefix_add+0x1a0>
		if (!ipv6->prefix[i].is_used) {
400125dc:	13c4a783          	lw	a5,316(s1)
400125e0:	0097d793          	srli	a5,a5,0x9
400125e4:	0017f793          	andi	a5,a5,1
400125e8:	f20780e3          	beqz	a5,40012508 <net_if_ipv6_prefix_add+0x94>
		if (net_ipv6_addr_cmp(prefix, &ipv6->prefix[i].prefix) &&
400125ec:	12848593          	addi	a1,s1,296
400125f0:	000b0513          	mv	a0,s6
400125f4:	909fd0ef          	jal	ra,4000fefc <net_ipv6_addr_cmp>
400125f8:	f00508e3          	beqz	a0,40012508 <net_if_ipv6_prefix_add+0x94>
400125fc:	13c4c783          	lbu	a5,316(s1)
40012600:	f17794e3          	bne	a5,s7,40012508 <net_if_ipv6_prefix_add+0x94>
40012604:	02800793          	li	a5,40
			return &ipv6->prefix[i];
40012608:	0f078793          	addi	a5,a5,240
4001260c:	00f484b3          	add	s1,s1,a5
	if (ifprefix) {
40012610:	ebdff06f          	j	400124cc <net_if_ipv6_prefix_add+0x58>
		if (net_ipv6_addr_cmp(prefix, &ipv6->prefix[i].prefix) &&
40012614:	00000793          	li	a5,0
40012618:	ff1ff06f          	j	40012608 <net_if_ipv6_prefix_add+0x194>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
4001261c:	00000413          	li	s0,0
40012620:	f15ff06f          	j	40012534 <net_if_ipv6_prefix_add+0xc0>

40012624 <net_if_ipv6_prefix_get>:
{
40012624:	ff010113          	addi	sp,sp,-16
40012628:	00812423          	sw	s0,8(sp)
4001262c:	01212023          	sw	s2,0(sp)
40012630:	00050413          	mv	s0,a0
40012634:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
40012638:	fff00513          	li	a0,-1
4001263c:	fff00593          	li	a1,-1
{
40012640:	00112623          	sw	ra,12(sp)
40012644:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012648:	961fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (!iface) {
4001264c:	00041663          	bnez	s0,40012658 <net_if_ipv6_prefix_get+0x34>
		iface = net_if_get_default();
40012650:	f00fe0ef          	jal	ra,40010d50 <net_if_get_default>
40012654:	00050413          	mv	s0,a0
	ipv6 = iface->config.ip.ipv6;
40012658:	0bc42403          	lw	s0,188(s0)
	if (!ipv6) {
4001265c:	04040a63          	beqz	s0,400126b0 <net_if_ipv6_prefix_get+0x8c>
		if (!ipv6->prefix[i].is_used) {
40012660:	11442783          	lw	a5,276(s0)
40012664:	0097d793          	srli	a5,a5,0x9
40012668:	0017f793          	andi	a5,a5,1
4001266c:	06079263          	bnez	a5,400126d0 <net_if_ipv6_prefix_get+0xac>
	struct net_if_ipv6_prefix *prefix = NULL;
40012670:	00000493          	li	s1,0
		if (!ipv6->prefix[i].is_used) {
40012674:	13c42783          	lw	a5,316(s0)
40012678:	0097d793          	srli	a5,a5,0x9
4001267c:	0017f793          	andi	a5,a5,1
40012680:	02078663          	beqz	a5,400126ac <net_if_ipv6_prefix_get+0x88>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
40012684:	13c44603          	lbu	a2,316(s0)
40012688:	00090593          	mv	a1,s2
4001268c:	12840513          	addi	a0,s0,296
40012690:	fc0fd0ef          	jal	ra,4000fe50 <net_ipv6_is_prefix>
40012694:	00050c63          	beqz	a0,400126ac <net_if_ipv6_prefix_get+0x88>
			if (!prefix || prefix->len > ipv6->prefix[i].len) {
40012698:	00048863          	beqz	s1,400126a8 <net_if_ipv6_prefix_get+0x84>
4001269c:	0244c703          	lbu	a4,36(s1)
400126a0:	13c44783          	lbu	a5,316(s0)
400126a4:	00e7f463          	bgeu	a5,a4,400126ac <net_if_ipv6_prefix_get+0x88>
				prefix = &ipv6->prefix[i];
400126a8:	11840493          	addi	s1,s0,280
	struct net_if_ipv6_prefix *prefix = NULL;
400126ac:	00048413          	mv	s0,s1
	k_mutex_unlock(&lock);
400126b0:	90dfd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
400126b4:	00c12083          	lw	ra,12(sp)
400126b8:	00040513          	mv	a0,s0
400126bc:	00812403          	lw	s0,8(sp)
400126c0:	00412483          	lw	s1,4(sp)
400126c4:	00012903          	lw	s2,0(sp)
400126c8:	01010113          	addi	sp,sp,16
400126cc:	00008067          	ret
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
400126d0:	11444603          	lbu	a2,276(s0)
400126d4:	00090593          	mv	a1,s2
400126d8:	10040513          	addi	a0,s0,256
400126dc:	f74fd0ef          	jal	ra,4000fe50 <net_ipv6_is_prefix>
400126e0:	f80508e3          	beqz	a0,40012670 <net_if_ipv6_prefix_get+0x4c>
				prefix = &ipv6->prefix[i];
400126e4:	0f040493          	addi	s1,s0,240
400126e8:	f8dff06f          	j	40012674 <net_if_ipv6_prefix_get+0x50>

400126ec <net_if_ipv6_prefix_lookup>:
{
400126ec:	ff010113          	addi	sp,sp,-16
400126f0:	00812423          	sw	s0,8(sp)
400126f4:	00912223          	sw	s1,4(sp)
400126f8:	00050413          	mv	s0,a0
400126fc:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
40012700:	fff00513          	li	a0,-1
40012704:	fff00593          	li	a1,-1
{
40012708:	01212023          	sw	s2,0(sp)
4001270c:	00112623          	sw	ra,12(sp)
40012710:	00060913          	mv	s2,a2
	k_mutex_lock(&lock, K_FOREVER);
40012714:	895fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
40012718:	0bc42403          	lw	s0,188(s0)
	if (!ipv6) {
4001271c:	02041463          	bnez	s0,40012744 <net_if_ipv6_prefix_lookup+0x58>
	struct net_if_ipv6_prefix *prefix = NULL;
40012720:	00000413          	li	s0,0
	k_mutex_unlock(&lock);
40012724:	899fd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40012728:	00c12083          	lw	ra,12(sp)
4001272c:	00040513          	mv	a0,s0
40012730:	00812403          	lw	s0,8(sp)
40012734:	00412483          	lw	s1,4(sp)
40012738:	00012903          	lw	s2,0(sp)
4001273c:	01010113          	addi	sp,sp,16
40012740:	00008067          	ret
		if (!ipv6->prefix[i].is_used) {
40012744:	11442783          	lw	a5,276(s0)
40012748:	0097d793          	srli	a5,a5,0x9
4001274c:	0017f793          	andi	a5,a5,1
40012750:	04079063          	bnez	a5,40012790 <net_if_ipv6_prefix_lookup+0xa4>
40012754:	13c42783          	lw	a5,316(s0)
40012758:	0097d793          	srli	a5,a5,0x9
4001275c:	0017f793          	andi	a5,a5,1
40012760:	fc0780e3          	beqz	a5,40012720 <net_if_ipv6_prefix_lookup+0x34>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
40012764:	00090613          	mv	a2,s2
40012768:	00048593          	mv	a1,s1
4001276c:	12840513          	addi	a0,s0,296
40012770:	ee0fd0ef          	jal	ra,4000fe50 <net_ipv6_is_prefix>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
40012774:	00100793          	li	a5,1
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
40012778:	fa0504e3          	beqz	a0,40012720 <net_if_ipv6_prefix_lookup+0x34>
			prefix = &ipv6->prefix[i];
4001277c:	02800713          	li	a4,40
40012780:	02e787b3          	mul	a5,a5,a4
40012784:	0f078793          	addi	a5,a5,240
40012788:	00f40433          	add	s0,s0,a5
			goto out;
4001278c:	f99ff06f          	j	40012724 <net_if_ipv6_prefix_lookup+0x38>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
40012790:	00090613          	mv	a2,s2
40012794:	00048593          	mv	a1,s1
40012798:	10040513          	addi	a0,s0,256
4001279c:	eb4fd0ef          	jal	ra,4000fe50 <net_ipv6_is_prefix>
400127a0:	fa050ae3          	beqz	a0,40012754 <net_if_ipv6_prefix_lookup+0x68>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
400127a4:	00000793          	li	a5,0
400127a8:	fd5ff06f          	j	4001277c <net_if_ipv6_prefix_lookup+0x90>

400127ac <net_if_ipv6_addr_onlink>:
{
400127ac:	fd010113          	addi	sp,sp,-48
400127b0:	02812423          	sw	s0,40(sp)
400127b4:	03212023          	sw	s2,32(sp)
400127b8:	01312e23          	sw	s3,28(sp)
400127bc:	01412c23          	sw	s4,24(sp)
400127c0:	00050913          	mv	s2,a0
400127c4:	00058a13          	mv	s4,a1
	k_mutex_lock(&lock, K_FOREVER);
400127c8:	fff00513          	li	a0,-1
400127cc:	fff00593          	li	a1,-1
	STRUCT_SECTION_FOREACH(net_if, tmp) {
400127d0:	40045437          	lui	s0,0x40045
400127d4:	400459b7          	lui	s3,0x40045
{
400127d8:	02112623          	sw	ra,44(sp)
400127dc:	02912223          	sw	s1,36(sp)
	STRUCT_SECTION_FOREACH(net_if, tmp) {
400127e0:	9d840413          	addi	s0,s0,-1576 # 400449d8 <__net_if_dts_ord_12_0>
	k_mutex_lock(&lock, K_FOREVER);
400127e4:	fc4fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, tmp) {
400127e8:	a9c98993          	addi	s3,s3,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
400127ec:	01346663          	bltu	s0,s3,400127f8 <net_if_ipv6_addr_onlink+0x4c>
	bool ret = false;
400127f0:	00000513          	li	a0,0
400127f4:	0880006f          	j	4001287c <net_if_ipv6_addr_onlink+0xd0>
		struct net_if_ipv6 *ipv6 = tmp->config.ip.ipv6;
400127f8:	0bc42483          	lw	s1,188(s0)
		if (iface && *iface && *iface != tmp) {
400127fc:	02090263          	beqz	s2,40012820 <net_if_ipv6_addr_onlink+0x74>
40012800:	00092783          	lw	a5,0(s2)
40012804:	00078e63          	beqz	a5,40012820 <net_if_ipv6_addr_onlink+0x74>
40012808:	00879463          	bne	a5,s0,40012810 <net_if_ipv6_addr_onlink+0x64>
		if (!ipv6) {
4001280c:	00049c63          	bnez	s1,40012824 <net_if_ipv6_addr_onlink+0x78>
	STRUCT_SECTION_FOREACH(net_if, tmp) {
40012810:	0c440413          	addi	s0,s0,196
40012814:	fd347ee3          	bgeu	s0,s3,400127f0 <net_if_ipv6_addr_onlink+0x44>
		struct net_if_ipv6 *ipv6 = tmp->config.ip.ipv6;
40012818:	0bc42483          	lw	s1,188(s0)
		if (iface && *iface && *iface != tmp) {
4001281c:	fe5ff06f          	j	40012800 <net_if_ipv6_addr_onlink+0x54>
		if (!ipv6) {
40012820:	02048c63          	beqz	s1,40012858 <net_if_ipv6_addr_onlink+0xac>
			if (ipv6->prefix[i].is_used &&
40012824:	1144a783          	lw	a5,276(s1)
40012828:	0097d793          	srli	a5,a5,0x9
4001282c:	0017f793          	andi	a5,a5,1
40012830:	02079863          	bnez	a5,40012860 <net_if_ipv6_addr_onlink+0xb4>
40012834:	13c4a783          	lw	a5,316(s1)
40012838:	0097d793          	srli	a5,a5,0x9
4001283c:	0017f793          	andi	a5,a5,1
40012840:	00078c63          	beqz	a5,40012858 <net_if_ipv6_addr_onlink+0xac>
			    net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
40012844:	13c4c603          	lbu	a2,316(s1)
40012848:	000a0593          	mv	a1,s4
4001284c:	12848513          	addi	a0,s1,296
40012850:	e00fd0ef          	jal	ra,4000fe50 <net_ipv6_is_prefix>
			if (ipv6->prefix[i].is_used &&
40012854:	02051063          	bnez	a0,40012874 <net_if_ipv6_addr_onlink+0xc8>
	STRUCT_SECTION_FOREACH(net_if, tmp) {
40012858:	0c440413          	addi	s0,s0,196
4001285c:	f91ff06f          	j	400127ec <net_if_ipv6_addr_onlink+0x40>
			    net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
40012860:	1144c603          	lbu	a2,276(s1)
40012864:	000a0593          	mv	a1,s4
40012868:	10048513          	addi	a0,s1,256
4001286c:	de4fd0ef          	jal	ra,4000fe50 <net_ipv6_is_prefix>
			if (ipv6->prefix[i].is_used &&
40012870:	fc0502e3          	beqz	a0,40012834 <net_if_ipv6_addr_onlink+0x88>
				if (iface) {
40012874:	02091a63          	bnez	s2,400128a8 <net_if_ipv6_addr_onlink+0xfc>
				ret = true;
40012878:	00100513          	li	a0,1
4001287c:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
40012880:	f3cfd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40012884:	02c12083          	lw	ra,44(sp)
40012888:	02812403          	lw	s0,40(sp)
4001288c:	00c12503          	lw	a0,12(sp)
40012890:	02412483          	lw	s1,36(sp)
40012894:	02012903          	lw	s2,32(sp)
40012898:	01c12983          	lw	s3,28(sp)
4001289c:	01812a03          	lw	s4,24(sp)
400128a0:	03010113          	addi	sp,sp,48
400128a4:	00008067          	ret
					*iface = tmp;
400128a8:	00892023          	sw	s0,0(s2)
400128ac:	fcdff06f          	j	40012878 <net_if_ipv6_addr_onlink+0xcc>

400128b0 <net_if_ipv6_prefix_set_timer>:
	if (lifetime == 0xffffffff) {
400128b0:	fff00793          	li	a5,-1
400128b4:	08f58463          	beq	a1,a5,4001293c <net_if_ipv6_prefix_set_timer+0x8c>
{
400128b8:	ff010113          	addi	sp,sp,-16
400128bc:	00812423          	sw	s0,8(sp)
400128c0:	00912223          	sw	s1,4(sp)
400128c4:	00050413          	mv	s0,a0
400128c8:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
400128cc:	fff00513          	li	a0,-1
400128d0:	fff00593          	li	a1,-1
{
400128d4:	00112623          	sw	ra,12(sp)
400128d8:	01212023          	sw	s2,0(sp)
	k_mutex_lock(&lock, K_FOREVER);
400128dc:	eccfd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	(void)sys_slist_find_and_remove(&active_prefix_lifetime_timers,
400128e0:	40039937          	lui	s2,0x40039
400128e4:	00040593          	mv	a1,s0
400128e8:	05890513          	addi	a0,s2,88 # 40039058 <active_prefix_lifetime_timers>
400128ec:	ad0fd0ef          	jal	ra,4000fbbc <sys_slist_find_and_remove>
	sys_slist_append(&active_prefix_lifetime_timers,
400128f0:	00040593          	mv	a1,s0
400128f4:	05890513          	addi	a0,s2,88
400128f8:	aa0fd0ef          	jal	ra,4000fb98 <sys_slist_append>
	net_timeout_set(&ifprefix->lifetime, lifetime, k_uptime_get_32());
400128fc:	e20fd0ef          	jal	ra,4000ff1c <k_uptime_get_32>
40012900:	00050613          	mv	a2,a0
40012904:	00048593          	mv	a1,s1
40012908:	00040513          	mv	a0,s0
4001290c:	11d010ef          	jal	ra,40014228 <net_timeout_set>
	k_work_reschedule(&prefix_lifetime_timer, K_NO_WAIT);
40012910:	4003a537          	lui	a0,0x4003a
40012914:	00000593          	li	a1,0
40012918:	00000613          	li	a2,0
4001291c:	9a050513          	addi	a0,a0,-1632 # 400399a0 <prefix_lifetime_timer>
40012920:	0351d0ef          	jal	ra,40030154 <k_work_reschedule>
}
40012924:	00812403          	lw	s0,8(sp)
40012928:	00c12083          	lw	ra,12(sp)
4001292c:	00412483          	lw	s1,4(sp)
40012930:	00012903          	lw	s2,0(sp)
40012934:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
40012938:	e84fd06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>
4001293c:	00008067          	ret

40012940 <net_if_ipv6_prefix_unset_timer>:
	if (!prefix->is_used) {
40012940:	02554783          	lbu	a5,37(a0)
40012944:	0027f793          	andi	a5,a5,2
40012948:	04078863          	beqz	a5,40012998 <net_if_ipv6_prefix_unset_timer+0x58>
{
4001294c:	ff010113          	addi	sp,sp,-16
40012950:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012954:	fff00593          	li	a1,-1
40012958:	00050413          	mv	s0,a0
4001295c:	fff00513          	li	a0,-1
{
40012960:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012964:	e44fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	sys_slist_find_and_remove(&active_prefix_lifetime_timers,
40012968:	40039537          	lui	a0,0x40039
4001296c:	00040593          	mv	a1,s0
40012970:	05850513          	addi	a0,a0,88 # 40039058 <active_prefix_lifetime_timers>
40012974:	a48fd0ef          	jal	ra,4000fbbc <sys_slist_find_and_remove>
	net_timeout_set(&ifprefix->lifetime, 0, 0);
40012978:	00040513          	mv	a0,s0
4001297c:	00000613          	li	a2,0
40012980:	00000593          	li	a1,0
40012984:	0a5010ef          	jal	ra,40014228 <net_timeout_set>
}
40012988:	00812403          	lw	s0,8(sp)
4001298c:	00c12083          	lw	ra,12(sp)
40012990:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
40012994:	e28fd06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>
40012998:	00008067          	ret

4001299c <net_if_ipv6_prefix_rm>:
{
4001299c:	fd010113          	addi	sp,sp,-48
400129a0:	03212023          	sw	s2,32(sp)
400129a4:	01312e23          	sw	s3,28(sp)
400129a8:	00050913          	mv	s2,a0
400129ac:	00058993          	mv	s3,a1
	k_mutex_lock(&lock, K_FOREVER);
400129b0:	fff00513          	li	a0,-1
400129b4:	fff00593          	li	a1,-1
{
400129b8:	02812423          	sw	s0,40(sp)
400129bc:	01412c23          	sw	s4,24(sp)
400129c0:	02112623          	sw	ra,44(sp)
400129c4:	02912223          	sw	s1,36(sp)
400129c8:	01512a23          	sw	s5,20(sp)
400129cc:	00060a13          	mv	s4,a2
	k_mutex_lock(&lock, K_FOREVER);
400129d0:	dd8fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
400129d4:	0bc92403          	lw	s0,188(s2)
	if (!ipv6) {
400129d8:	02041c63          	bnez	s0,40012a10 <net_if_ipv6_prefix_rm+0x74>
	bool ret = false;
400129dc:	00000513          	li	a0,0
400129e0:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
400129e4:	dd8fd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
400129e8:	02c12083          	lw	ra,44(sp)
400129ec:	02812403          	lw	s0,40(sp)
400129f0:	00c12503          	lw	a0,12(sp)
400129f4:	02412483          	lw	s1,36(sp)
400129f8:	02012903          	lw	s2,32(sp)
400129fc:	01c12983          	lw	s3,28(sp)
40012a00:	01812a03          	lw	s4,24(sp)
40012a04:	01412a83          	lw	s5,20(sp)
40012a08:	03010113          	addi	sp,sp,48
40012a0c:	00008067          	ret
		if (!ipv6->prefix[i].is_used) {
40012a10:	11442783          	lw	a5,276(s0)
40012a14:	0097d793          	srli	a5,a5,0x9
40012a18:	0017f793          	andi	a5,a5,1
40012a1c:	02078063          	beqz	a5,40012a3c <net_if_ipv6_prefix_rm+0xa0>
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
40012a20:	10040a93          	addi	s5,s0,256
40012a24:	00098593          	mv	a1,s3
40012a28:	000a8513          	mv	a0,s5
40012a2c:	cd0fd0ef          	jal	ra,4000fefc <net_ipv6_addr_cmp>
40012a30:	00050663          	beqz	a0,40012a3c <net_if_ipv6_prefix_rm+0xa0>
40012a34:	11444783          	lbu	a5,276(s0)
40012a38:	09478863          	beq	a5,s4,40012ac8 <net_if_ipv6_prefix_rm+0x12c>
		if (!ipv6->prefix[i].is_used) {
40012a3c:	13c42783          	lw	a5,316(s0)
40012a40:	0097d793          	srli	a5,a5,0x9
40012a44:	0017f793          	andi	a5,a5,1
40012a48:	f8078ae3          	beqz	a5,400129dc <net_if_ipv6_prefix_rm+0x40>
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
40012a4c:	12840a93          	addi	s5,s0,296
40012a50:	00098593          	mv	a1,s3
40012a54:	000a8513          	mv	a0,s5
40012a58:	ca4fd0ef          	jal	ra,4000fefc <net_ipv6_addr_cmp>
40012a5c:	f80500e3          	beqz	a0,400129dc <net_if_ipv6_prefix_rm+0x40>
40012a60:	13c44783          	lbu	a5,316(s0)
40012a64:	f7479ce3          	bne	a5,s4,400129dc <net_if_ipv6_prefix_rm+0x40>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
40012a68:	00100493          	li	s1,1
40012a6c:	02800513          	li	a0,40
		net_if_ipv6_prefix_unset_timer(&ipv6->prefix[i]);
40012a70:	0f050513          	addi	a0,a0,240
40012a74:	00a40533          	add	a0,s0,a0
40012a78:	ec9ff0ef          	jal	ra,40012940 <net_if_ipv6_prefix_unset_timer>
		ipv6->prefix[i].is_used = false;
40012a7c:	02800793          	li	a5,40
40012a80:	02f484b3          	mul	s1,s1,a5
		remove_prefix_addresses(iface, ipv6, addr, len);
40012a84:	000a0693          	mv	a3,s4
40012a88:	00098613          	mv	a2,s3
40012a8c:	00040593          	mv	a1,s0
40012a90:	00090513          	mv	a0,s2
		ipv6->prefix[i].is_used = false;
40012a94:	009404b3          	add	s1,s0,s1
40012a98:	1154c783          	lbu	a5,277(s1)
40012a9c:	ffd7f793          	andi	a5,a5,-3
40012aa0:	10f48aa3          	sb	a5,277(s1)
		remove_prefix_addresses(iface, ipv6, addr, len);
40012aa4:	ce8ff0ef          	jal	ra,40011f8c <remove_prefix_addresses>
		net_mgmt_event_notify_with_info(
40012aa8:	e0600537          	lui	a0,0xe0600
40012aac:	00650513          	addi	a0,a0,6 # e0600006 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600007>
40012ab0:	01000693          	li	a3,16
40012ab4:	000a8613          	mv	a2,s5
40012ab8:	00090593          	mv	a1,s2
40012abc:	411020ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
		ret = true;
40012ac0:	00100513          	li	a0,1
		goto out;
40012ac4:	f1dff06f          	j	400129e0 <net_if_ipv6_prefix_rm+0x44>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
40012ac8:	00000493          	li	s1,0
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
40012acc:	00000513          	li	a0,0
40012ad0:	fa1ff06f          	j	40012a70 <net_if_ipv6_prefix_rm+0xd4>

40012ad4 <net_if_ipv6_router_lookup>:
{
40012ad4:	00058613          	mv	a2,a1
	return iface_router_lookup(iface, AF_INET6, addr);
40012ad8:	00200593          	li	a1,2
40012adc:	d94fd06f          	j	40010070 <iface_router_lookup>

40012ae0 <net_if_ipv6_router_find_default>:
	return iface_router_find_default(iface, AF_INET6, addr);
40012ae0:	00200593          	li	a1,2
40012ae4:	aa1fd06f          	j	40010584 <iface_router_find_default.constprop.0>

40012ae8 <net_if_ipv6_router_update_lifetime>:
{
40012ae8:	ff010113          	addi	sp,sp,-16
40012aec:	00812423          	sw	s0,8(sp)
40012af0:	00912223          	sw	s1,4(sp)
40012af4:	00112623          	sw	ra,12(sp)
40012af8:	00050413          	mv	s0,a0
40012afc:	00058493          	mv	s1,a1
	router->life_start = k_uptime_get_32();
40012b00:	c1cfd0ef          	jal	ra,4000ff1c <k_uptime_get_32>
40012b04:	00a42e23          	sw	a0,28(s0)
	router->lifetime = lifetime;
40012b08:	02941023          	sh	s1,32(s0)
}
40012b0c:	00812403          	lw	s0,8(sp)
40012b10:	00c12083          	lw	ra,12(sp)
40012b14:	00412483          	lw	s1,4(sp)
40012b18:	01010113          	addi	sp,sp,16
	iface_router_update_timer(router->life_start);
40012b1c:	e64fd06f          	j	40010180 <iface_router_update_timer>

40012b20 <net_if_ipv6_router_add>:
{
40012b20:	00060713          	mv	a4,a2
	return iface_router_add(iface, AF_INET6, addr, false, lifetime);
40012b24:	00000693          	li	a3,0
40012b28:	00058613          	mv	a2,a1
40012b2c:	00200593          	li	a1,2
40012b30:	f18fd06f          	j	40010248 <iface_router_add>

40012b34 <net_if_ipv6_router_rm>:
	return iface_router_rm(router);
40012b34:	8c1fd06f          	j	400103f4 <iface_router_rm>

40012b38 <net_if_ipv6_get_hop_limit>:
{
40012b38:	fe010113          	addi	sp,sp,-32
40012b3c:	00812c23          	sw	s0,24(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012b40:	fff00593          	li	a1,-1
{
40012b44:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
40012b48:	fff00513          	li	a0,-1
{
40012b4c:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012b50:	c58fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (!iface->config.ip.ipv6) {
40012b54:	0bc42783          	lw	a5,188(s0)
	int ret = 0;
40012b58:	00000513          	li	a0,0
	if (!iface->config.ip.ipv6) {
40012b5c:	00078463          	beqz	a5,40012b64 <net_if_ipv6_get_hop_limit+0x2c>
	ret = iface->config.ip.ipv6->hop_limit;
40012b60:	1557c503          	lbu	a0,341(a5)
40012b64:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
40012b68:	c54fd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40012b6c:	01c12083          	lw	ra,28(sp)
40012b70:	01812403          	lw	s0,24(sp)
40012b74:	00c12503          	lw	a0,12(sp)
40012b78:	02010113          	addi	sp,sp,32
40012b7c:	00008067          	ret

40012b80 <net_ipv6_set_hop_limit>:
{
40012b80:	ff010113          	addi	sp,sp,-16
40012b84:	00812423          	sw	s0,8(sp)
40012b88:	00912223          	sw	s1,4(sp)
40012b8c:	00058413          	mv	s0,a1
40012b90:	00050493          	mv	s1,a0
	k_mutex_lock(&lock, K_FOREVER);
40012b94:	fff00593          	li	a1,-1
40012b98:	fff00513          	li	a0,-1
{
40012b9c:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012ba0:	c08fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (!iface->config.ip.ipv6) {
40012ba4:	0bc4a783          	lw	a5,188(s1)
40012ba8:	00078463          	beqz	a5,40012bb0 <net_ipv6_set_hop_limit+0x30>
	iface->config.ip.ipv6->hop_limit = hop_limit;
40012bac:	14878aa3          	sb	s0,341(a5)
}
40012bb0:	00812403          	lw	s0,8(sp)
40012bb4:	00c12083          	lw	ra,12(sp)
40012bb8:	00412483          	lw	s1,4(sp)
40012bbc:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
40012bc0:	bfcfd06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>

40012bc4 <net_if_ipv6_get_ll>:
{
40012bc4:	fe010113          	addi	sp,sp,-32
40012bc8:	00812c23          	sw	s0,24(sp)
40012bcc:	00912a23          	sw	s1,20(sp)
40012bd0:	00058413          	mv	s0,a1
40012bd4:	00050493          	mv	s1,a0
	k_mutex_lock(&lock, K_FOREVER);
40012bd8:	fff00593          	li	a1,-1
40012bdc:	fff00513          	li	a0,-1
{
40012be0:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012be4:	bc4fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
40012be8:	0bc4a503          	lw	a0,188(s1)
	if (!ipv6) {
40012bec:	06050a63          	beqz	a0,40012c60 <net_if_ipv6_get_ll+0x9c>
40012bf0:	00450793          	addi	a5,a0,4
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40012bf4:	00000693          	li	a3,0
		if (!ipv6->unicast[i].is_used ||
40012bf8:	03000813          	li	a6,48
40012bfc:	fff00893          	li	a7,-1
		     ipv6->unicast[i].addr_state != addr_state) ||
40012c00:	00200313          	li	t1,2
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40012c04:	00300593          	li	a1,3
		if (!ipv6->unicast[i].is_used ||
40012c08:	03068733          	mul	a4,a3,a6
40012c0c:	00e50733          	add	a4,a0,a4
40012c10:	02c72703          	lw	a4,44(a4)
40012c14:	01975713          	srli	a4,a4,0x19
40012c18:	00177713          	andi	a4,a4,1
40012c1c:	02070a63          	beqz	a4,40012c50 <net_if_ipv6_get_ll+0x8c>
40012c20:	01140663          	beq	s0,a7,40012c2c <net_if_ipv6_get_ll+0x68>
		    (addr_state != NET_ADDR_ANY_STATE &&
40012c24:	02978703          	lb	a4,41(a5)
40012c28:	02871463          	bne	a4,s0,40012c50 <net_if_ipv6_get_ll+0x8c>
		     ipv6->unicast[i].addr_state != addr_state) ||
40012c2c:	ffc7d703          	lhu	a4,-4(a5)
40012c30:	02671063          	bne	a4,t1,40012c50 <net_if_ipv6_get_ll+0x8c>
	return UNALIGNED_GET(&addr->s6_addr16[0]) == htons(0xFE80);
40012c34:	0017c703          	lbu	a4,1(a5)
40012c38:	0007c603          	lbu	a2,0(a5)
40012c3c:	00871713          	slli	a4,a4,0x8
		if (net_ipv6_is_ll_addr(&ipv6->unicast[i].address.in6_addr)) {
40012c40:	00c76733          	or	a4,a4,a2
40012c44:	00008637          	lui	a2,0x8
40012c48:	0fe60613          	addi	a2,a2,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
40012c4c:	02c70a63          	beq	a4,a2,40012c80 <net_if_ipv6_get_ll+0xbc>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40012c50:	00168693          	addi	a3,a3,1
40012c54:	03078793          	addi	a5,a5,48
40012c58:	fab698e3          	bne	a3,a1,40012c08 <net_if_ipv6_get_ll+0x44>
	struct in6_addr *addr = NULL;
40012c5c:	00000513          	li	a0,0
40012c60:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
40012c64:	b58fd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40012c68:	01c12083          	lw	ra,28(sp)
40012c6c:	01812403          	lw	s0,24(sp)
40012c70:	00c12503          	lw	a0,12(sp)
40012c74:	01412483          	lw	s1,20(sp)
40012c78:	02010113          	addi	sp,sp,32
40012c7c:	00008067          	ret
		if (net_ipv6_is_ll_addr(&ipv6->unicast[i].address.in6_addr)) {
40012c80:	00078513          	mv	a0,a5
40012c84:	fddff06f          	j	40012c60 <net_if_ipv6_get_ll+0x9c>

40012c88 <net_if_ipv6_select_src_addr>:
{
40012c88:	fd010113          	addi	sp,sp,-48
40012c8c:	02812423          	sw	s0,40(sp)
40012c90:	03212023          	sw	s2,32(sp)
40012c94:	00050413          	mv	s0,a0
40012c98:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
40012c9c:	fff00513          	li	a0,-1
40012ca0:	fff00593          	li	a1,-1
{
40012ca4:	02112623          	sw	ra,44(sp)
40012ca8:	02912223          	sw	s1,36(sp)
40012cac:	01312e23          	sw	s3,28(sp)
	uint8_t best_match = 0U;
40012cb0:	000107a3          	sb	zero,15(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012cb4:	af4fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
40012cb8:	00194683          	lbu	a3,1(s2)
40012cbc:	00094603          	lbu	a2,0(s2)
	if (!net_ipv6_is_ll_addr(dst) && !net_ipv6_is_addr_mcast_link(dst)) {
40012cc0:	000087b7          	lui	a5,0x8
40012cc4:	00869713          	slli	a4,a3,0x8
40012cc8:	00c76733          	or	a4,a4,a2
40012ccc:	0fe78793          	addi	a5,a5,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
40012cd0:	08f70663          	beq	a4,a5,40012d5c <net_if_ipv6_select_src_addr+0xd4>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
40012cd4:	0ff00793          	li	a5,255
40012cd8:	00f61663          	bne	a2,a5,40012ce4 <net_if_ipv6_select_src_addr+0x5c>
40012cdc:	00200793          	li	a5,2
40012ce0:	06f68e63          	beq	a3,a5,40012d5c <net_if_ipv6_select_src_addr+0xd4>
		if (dst_iface) {
40012ce4:	06040263          	beqz	s0,40012d48 <net_if_ipv6_select_src_addr+0xc0>
			src = net_if_ipv6_get_best_match(dst_iface, dst,
40012ce8:	0bc42503          	lw	a0,188(s0)
40012cec:	00f10613          	addi	a2,sp,15
40012cf0:	00090593          	mv	a1,s2
40012cf4:	af9fd0ef          	jal	ra,400107ec <net_if_ipv6_get_best_match.isra.0>
			src = net_if_ipv6_get_ll(dst_iface, NET_ADDR_PREFERRED);
40012cf8:	00050413          	mv	s0,a0
40012cfc:	0240006f          	j	40012d20 <net_if_ipv6_select_src_addr+0x98>
				addr = net_if_ipv6_get_best_match(iface, dst,
40012d00:	0bc4a503          	lw	a0,188(s1)
40012d04:	00f10613          	addi	a2,sp,15
40012d08:	00090593          	mv	a1,s2
40012d0c:	ae1fd0ef          	jal	ra,400107ec <net_if_ipv6_get_best_match.isra.0>
				if (addr) {
40012d10:	00050463          	beqz	a0,40012d18 <net_if_ipv6_select_src_addr+0x90>
40012d14:	00050413          	mv	s0,a0
			STRUCT_SECTION_FOREACH(net_if, iface) {
40012d18:	0c448493          	addi	s1,s1,196
40012d1c:	ff34e2e3          	bltu	s1,s3,40012d00 <net_if_ipv6_select_src_addr+0x78>
	if (!src) {
40012d20:	06040663          	beqz	s0,40012d8c <net_if_ipv6_select_src_addr+0x104>
	k_mutex_unlock(&lock);
40012d24:	a98fd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40012d28:	02c12083          	lw	ra,44(sp)
40012d2c:	00040513          	mv	a0,s0
40012d30:	02812403          	lw	s0,40(sp)
40012d34:	02412483          	lw	s1,36(sp)
40012d38:	02012903          	lw	s2,32(sp)
40012d3c:	01c12983          	lw	s3,28(sp)
40012d40:	03010113          	addi	sp,sp,48
40012d44:	00008067          	ret
			STRUCT_SECTION_FOREACH(net_if, iface) {
40012d48:	400454b7          	lui	s1,0x40045
40012d4c:	400459b7          	lui	s3,0x40045
40012d50:	9d848493          	addi	s1,s1,-1576 # 400449d8 <__net_if_dts_ord_12_0>
40012d54:	a9c98993          	addi	s3,s3,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
40012d58:	fc5ff06f          	j	40012d1c <net_if_ipv6_select_src_addr+0x94>
		if (dst_iface) {
40012d5c:	02040e63          	beqz	s0,40012d98 <net_if_ipv6_select_src_addr+0x110>
			src = net_if_ipv6_get_ll(dst_iface, NET_ADDR_PREFERRED);
40012d60:	00100593          	li	a1,1
40012d64:	00040513          	mv	a0,s0
40012d68:	e5dff0ef          	jal	ra,40012bc4 <net_if_ipv6_get_ll>
40012d6c:	f8dff06f          	j	40012cf8 <net_if_ipv6_select_src_addr+0x70>
				addr = net_if_ipv6_get_ll(iface,
40012d70:	00100593          	li	a1,1
40012d74:	00048513          	mv	a0,s1
40012d78:	e4dff0ef          	jal	ra,40012bc4 <net_if_ipv6_get_ll>
40012d7c:	00050413          	mv	s0,a0
				if (addr) {
40012d80:	fa0512e3          	bnez	a0,40012d24 <net_if_ipv6_select_src_addr+0x9c>
			STRUCT_SECTION_FOREACH(net_if, iface) {
40012d84:	0c448493          	addi	s1,s1,196
40012d88:	ff24e4e3          	bltu	s1,s2,40012d70 <net_if_ipv6_select_src_addr+0xe8>
		src = net_ipv6_unspecified_address();
40012d8c:	67c020ef          	jal	ra,40015408 <net_ipv6_unspecified_address>
40012d90:	00050413          	mv	s0,a0
		goto out;
40012d94:	f91ff06f          	j	40012d24 <net_if_ipv6_select_src_addr+0x9c>
			STRUCT_SECTION_FOREACH(net_if, iface) {
40012d98:	400454b7          	lui	s1,0x40045
40012d9c:	40045937          	lui	s2,0x40045
40012da0:	9d848493          	addi	s1,s1,-1576 # 400449d8 <__net_if_dts_ord_12_0>
40012da4:	a9c90913          	addi	s2,s2,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
40012da8:	fe1ff06f          	j	40012d88 <net_if_ipv6_select_src_addr+0x100>

40012dac <net_if_ipv6_select_src_iface>:
{
40012dac:	fe010113          	addi	sp,sp,-32
40012db0:	00812c23          	sw	s0,24(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012db4:	fff00593          	li	a1,-1
{
40012db8:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
40012dbc:	fff00513          	li	a0,-1
{
40012dc0:	00112e23          	sw	ra,28(sp)
	struct net_if *iface = NULL;
40012dc4:	00012623          	sw	zero,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012dc8:	9e0fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	src = net_if_ipv6_select_src_addr(NULL, dst);
40012dcc:	00040593          	mv	a1,s0
40012dd0:	00000513          	li	a0,0
40012dd4:	eb5ff0ef          	jal	ra,40012c88 <net_if_ipv6_select_src_addr>
40012dd8:	00050413          	mv	s0,a0
	if (src != net_ipv6_unspecified_address()) {
40012ddc:	62c020ef          	jal	ra,40015408 <net_ipv6_unspecified_address>
40012de0:	02a41263          	bne	s0,a0,40012e04 <net_if_ipv6_select_src_iface+0x58>
		iface = net_if_get_default();
40012de4:	f6dfd0ef          	jal	ra,40010d50 <net_if_get_default>
40012de8:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
40012dec:	9d0fd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40012df0:	01c12083          	lw	ra,28(sp)
40012df4:	01812403          	lw	s0,24(sp)
40012df8:	00c12503          	lw	a0,12(sp)
40012dfc:	02010113          	addi	sp,sp,32
40012e00:	00008067          	ret
		net_if_ipv6_addr_lookup(src, &iface);
40012e04:	00c10593          	addi	a1,sp,12
40012e08:	00040513          	mv	a0,s0
40012e0c:	aa4fe0ef          	jal	ra,400110b0 <net_if_ipv6_addr_lookup>
	if (iface == NULL) {
40012e10:	00c12783          	lw	a5,12(sp)
40012e14:	fc079ce3          	bnez	a5,40012dec <net_if_ipv6_select_src_iface+0x40>
40012e18:	fcdff06f          	j	40012de4 <net_if_ipv6_select_src_iface+0x38>

40012e1c <net_if_ipv6_calc_reachable_time>:
{
40012e1c:	ff010113          	addi	sp,sp,-16
40012e20:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012e24:	fff00593          	li	a1,-1
{
40012e28:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
40012e2c:	fff00513          	li	a0,-1
{
40012e30:	00112623          	sw	ra,12(sp)
40012e34:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012e38:	970fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	min_reachable = (MIN_RANDOM_NUMER * ipv6->base_reachable_time)
40012e3c:	14042403          	lw	s0,320(s0)
	k_mutex_unlock(&lock);
40012e40:	97cfd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
	min_reachable = (MIN_RANDOM_NUMER * ipv6->base_reachable_time)
40012e44:	00145493          	srli	s1,s0,0x1
	if (z_syscall_trap()) {
		return (uint32_t) arch_syscall_invoke0(K_SYSCALL_SYS_RAND32_GET);
	}
#endif
	compiler_barrier();
	return z_impl_sys_rand32_get();
40012e48:	bd8fa0ef          	jal	ra,4000d220 <z_impl_sys_rand32_get>
	max_reachable = (MAX_RANDOM_NUMER * ipv6->base_reachable_time)
40012e4c:	00300793          	li	a5,3
40012e50:	02f40433          	mul	s0,s0,a5
}
40012e54:	00c12083          	lw	ra,12(sp)
	max_reachable = (MAX_RANDOM_NUMER * ipv6->base_reachable_time)
40012e58:	00145413          	srli	s0,s0,0x1
	       sys_rand32_get() % (max_reachable - min_reachable);
40012e5c:	40940433          	sub	s0,s0,s1
40012e60:	02857533          	remu	a0,a0,s0
}
40012e64:	00812403          	lw	s0,8(sp)
40012e68:	00950533          	add	a0,a0,s1
40012e6c:	00412483          	lw	s1,4(sp)
40012e70:	01010113          	addi	sp,sp,16
40012e74:	00008067          	ret

40012e78 <net_if_config_ipv4_get>:
{
40012e78:	fe010113          	addi	sp,sp,-32
40012e7c:	00812c23          	sw	s0,24(sp)
40012e80:	00912a23          	sw	s1,20(sp)
40012e84:	00050413          	mv	s0,a0
40012e88:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
40012e8c:	fff00513          	li	a0,-1
40012e90:	fff00593          	li	a1,-1
{
40012e94:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012e98:	910fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (!net_if_flag_is_set(iface, NET_IF_IPV4)) {
40012e9c:	00600593          	li	a1,6
40012ea0:	00040513          	mv	a0,s0
40012ea4:	fb4fd0ef          	jal	ra,40010658 <net_if_flag_is_set>
40012ea8:	04050c63          	beqz	a0,40012f00 <net_if_config_ipv4_get+0x88>
	if (iface->config.ip.ipv4) {
40012eac:	0c042783          	lw	a5,192(s0)
40012eb0:	02078863          	beqz	a5,40012ee0 <net_if_config_ipv4_get+0x68>
		if (ipv4) {
40012eb4:	00048463          	beqz	s1,40012ebc <net_if_config_ipv4_get+0x44>
			*ipv4 = &ipv4_addresses[i].ipv4;
40012eb8:	00f4a023          	sw	a5,0(s1)
	int ret = 0;
40012ebc:	00000513          	li	a0,0
40012ec0:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
40012ec4:	8f8fd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40012ec8:	01c12083          	lw	ra,28(sp)
40012ecc:	01812403          	lw	s0,24(sp)
40012ed0:	00c12503          	lw	a0,12(sp)
40012ed4:	01412483          	lw	s1,20(sp)
40012ed8:	02010113          	addi	sp,sp,32
40012edc:	00008067          	ret
		if (ipv4_addresses[i].iface) {
40012ee0:	4003a7b7          	lui	a5,0x4003a
40012ee4:	4fc78793          	addi	a5,a5,1276 # 4003a4fc <ipv4_addresses>
40012ee8:	0547a703          	lw	a4,84(a5)
	ret = -ESRCH;
40012eec:	ffd00513          	li	a0,-3
		if (ipv4_addresses[i].iface) {
40012ef0:	fc0718e3          	bnez	a4,40012ec0 <net_if_config_ipv4_get+0x48>
		iface->config.ip.ipv4 = &ipv4_addresses[i].ipv4;
40012ef4:	0cf42023          	sw	a5,192(s0)
		ipv4_addresses[i].iface = iface;
40012ef8:	0487aa23          	sw	s0,84(a5)
40012efc:	fb9ff06f          	j	40012eb4 <net_if_config_ipv4_get+0x3c>
		ret = -ENOTSUP;
40012f00:	f7a00513          	li	a0,-134
40012f04:	fbdff06f          	j	40012ec0 <net_if_config_ipv4_get+0x48>

40012f08 <net_if_ipv4_get_ttl>:
{
40012f08:	fe010113          	addi	sp,sp,-32
40012f0c:	00812c23          	sw	s0,24(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012f10:	fff00593          	li	a1,-1
{
40012f14:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
40012f18:	fff00513          	li	a0,-1
{
40012f1c:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012f20:	888fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (!iface->config.ip.ipv4) {
40012f24:	0c042783          	lw	a5,192(s0)
	int ret = 0;
40012f28:	00000513          	li	a0,0
	if (!iface->config.ip.ipv4) {
40012f2c:	00078463          	beqz	a5,40012f34 <net_if_ipv4_get_ttl+0x2c>
	ret = iface->config.ip.ipv4->ttl;
40012f30:	0507c503          	lbu	a0,80(a5)
40012f34:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
40012f38:	884fd0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40012f3c:	01c12083          	lw	ra,28(sp)
40012f40:	01812403          	lw	s0,24(sp)
40012f44:	00c12503          	lw	a0,12(sp)
40012f48:	02010113          	addi	sp,sp,32
40012f4c:	00008067          	ret

40012f50 <net_if_ipv4_addr_mask_cmp>:
{
40012f50:	fe010113          	addi	sp,sp,-32
40012f54:	00812c23          	sw	s0,24(sp)
40012f58:	00912a23          	sw	s1,20(sp)
40012f5c:	00058413          	mv	s0,a1
40012f60:	00050493          	mv	s1,a0
	k_mutex_lock(&lock, K_FOREVER);
40012f64:	fff00593          	li	a1,-1
40012f68:	fff00513          	li	a0,-1
{
40012f6c:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
40012f70:	838fd0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	ipv4 = iface->config.ip.ipv4;
40012f74:	0c04a703          	lw	a4,192(s1)
	if (!ipv4) {
40012f78:	04070e63          	beqz	a4,40012fd4 <net_if_ipv4_addr_mask_cmp+0x84>
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
40012f7c:	00144783          	lbu	a5,1(s0)
40012f80:	00044683          	lbu	a3,0(s0)
		if (!ipv4->unicast[i].is_used ||
40012f84:	02c72503          	lw	a0,44(a4)
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
40012f88:	00879793          	slli	a5,a5,0x8
40012f8c:	00d7e7b3          	or	a5,a5,a3
40012f90:	00244683          	lbu	a3,2(s0)
		if (!ipv4->unicast[i].is_used ||
40012f94:	01955513          	srli	a0,a0,0x19
40012f98:	00157513          	andi	a0,a0,1
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
40012f9c:	01069693          	slli	a3,a3,0x10
40012fa0:	00f6e6b3          	or	a3,a3,a5
40012fa4:	00344783          	lbu	a5,3(s0)
		if (!ipv4->unicast[i].is_used ||
40012fa8:	00100613          	li	a2,1
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
40012fac:	01879793          	slli	a5,a5,0x18
40012fb0:	00d7e7b3          	or	a5,a5,a3
40012fb4:	04c72683          	lw	a3,76(a4)
		if (!ipv4->unicast[i].is_used ||
40012fb8:	02050063          	beqz	a0,40012fd8 <net_if_ipv4_addr_mask_cmp+0x88>
40012fbc:	00075583          	lhu	a1,0(a4)
40012fc0:	00c59a63          	bne	a1,a2,40012fd4 <net_if_ipv4_addr_mask_cmp+0x84>
		if ((ipv4->unicast[i].address.in_addr.s_addr &
40012fc4:	00472703          	lw	a4,4(a4)
40012fc8:	00e7c7b3          	xor	a5,a5,a4
40012fcc:	00d7f7b3          	and	a5,a5,a3
40012fd0:	00078463          	beqz	a5,40012fd8 <net_if_ipv4_addr_mask_cmp+0x88>
	bool ret = false;
40012fd4:	00000513          	li	a0,0
40012fd8:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
40012fdc:	fe1fc0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40012fe0:	01c12083          	lw	ra,28(sp)
40012fe4:	01812403          	lw	s0,24(sp)
40012fe8:	00c12503          	lw	a0,12(sp)
40012fec:	01412483          	lw	s1,20(sp)
40012ff0:	02010113          	addi	sp,sp,32
40012ff4:	00008067          	ret

40012ff8 <ipv4_is_broadcast_address>:
{
40012ff8:	ff010113          	addi	sp,sp,-16
40012ffc:	00112623          	sw	ra,12(sp)
40013000:	00812423          	sw	s0,8(sp)
40013004:	00912223          	sw	s1,4(sp)
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
40013008:	0c052483          	lw	s1,192(a0)
	if (!ipv4) {
4001300c:	00049e63          	bnez	s1,40013028 <ipv4_is_broadcast_address+0x30>
		return false;
40013010:	00000513          	li	a0,0
}
40013014:	00c12083          	lw	ra,12(sp)
40013018:	00812403          	lw	s0,8(sp)
4001301c:	00412483          	lw	s1,4(sp)
40013020:	01010113          	addi	sp,sp,16
40013024:	00008067          	ret
40013028:	00058413          	mv	s0,a1
	if (!net_if_ipv4_addr_mask_cmp(iface, addr)) {
4001302c:	f25ff0ef          	jal	ra,40012f50 <net_if_ipv4_addr_mask_cmp>
40013030:	fe0500e3          	beqz	a0,40013010 <ipv4_is_broadcast_address+0x18>
	if ((UNALIGNED_GET(&addr->s_addr) & ~ipv4->netmask.s_addr) ==
40013034:	00144703          	lbu	a4,1(s0)
40013038:	00044783          	lbu	a5,0(s0)
4001303c:	00344503          	lbu	a0,3(s0)
40013040:	00871713          	slli	a4,a4,0x8
40013044:	00f76733          	or	a4,a4,a5
40013048:	00244783          	lbu	a5,2(s0)
4001304c:	04c4a683          	lw	a3,76(s1)
40013050:	01851513          	slli	a0,a0,0x18
40013054:	01079793          	slli	a5,a5,0x10
40013058:	00e7e7b3          	or	a5,a5,a4
4001305c:	fff6c693          	not	a3,a3
40013060:	00f56533          	or	a0,a0,a5
40013064:	00d57533          	and	a0,a0,a3
40013068:	40d50533          	sub	a0,a0,a3
4001306c:	00153513          	seqz	a0,a0
40013070:	fa5ff06f          	j	40013014 <ipv4_is_broadcast_address+0x1c>

40013074 <net_if_ipv4_is_addr_bcast>:
{
40013074:	fe010113          	addi	sp,sp,-32
40013078:	00812c23          	sw	s0,24(sp)
4001307c:	00912a23          	sw	s1,20(sp)
40013080:	00050413          	mv	s0,a0
40013084:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
40013088:	fff00513          	li	a0,-1
4001308c:	fff00593          	li	a1,-1
{
40013090:	00112e23          	sw	ra,28(sp)
40013094:	01212823          	sw	s2,16(sp)
	k_mutex_lock(&lock, K_FOREVER);
40013098:	f11fc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (iface) {
4001309c:	04040a63          	beqz	s0,400130f0 <net_if_ipv4_is_addr_bcast+0x7c>
		ret = ipv4_is_broadcast_address(iface, addr);
400130a0:	00048593          	mv	a1,s1
400130a4:	00040513          	mv	a0,s0
400130a8:	f51ff0ef          	jal	ra,40012ff8 <ipv4_is_broadcast_address>
		goto out;
400130ac:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
400130b0:	f0dfc0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
400130b4:	01c12083          	lw	ra,28(sp)
400130b8:	01812403          	lw	s0,24(sp)
400130bc:	00c12503          	lw	a0,12(sp)
400130c0:	01412483          	lw	s1,20(sp)
400130c4:	01012903          	lw	s2,16(sp)
400130c8:	02010113          	addi	sp,sp,32
400130cc:	00008067          	ret
		ret = ipv4_is_broadcast_address(iface, addr);
400130d0:	00048593          	mv	a1,s1
400130d4:	00040513          	mv	a0,s0
400130d8:	f21ff0ef          	jal	ra,40012ff8 <ipv4_is_broadcast_address>
		if (ret) {
400130dc:	fc0518e3          	bnez	a0,400130ac <net_if_ipv4_is_addr_bcast+0x38>
	STRUCT_SECTION_FOREACH(net_if, iface) {
400130e0:	0c440413          	addi	s0,s0,196
400130e4:	ff2466e3          	bltu	s0,s2,400130d0 <net_if_ipv4_is_addr_bcast+0x5c>
out:
400130e8:	00000513          	li	a0,0
400130ec:	fc1ff06f          	j	400130ac <net_if_ipv4_is_addr_bcast+0x38>
	STRUCT_SECTION_FOREACH(net_if, iface) {
400130f0:	40045437          	lui	s0,0x40045
400130f4:	40045937          	lui	s2,0x40045
400130f8:	9d840413          	addi	s0,s0,-1576 # 400449d8 <__net_if_dts_ord_12_0>
400130fc:	a9c90913          	addi	s2,s2,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
40013100:	fe5ff06f          	j	400130e4 <net_if_ipv4_is_addr_bcast+0x70>

40013104 <net_if_ipv4_select_src_iface>:
{
40013104:	ff010113          	addi	sp,sp,-16
40013108:	00812423          	sw	s0,8(sp)
4001310c:	00912223          	sw	s1,4(sp)
40013110:	01212023          	sw	s2,0(sp)
	k_mutex_lock(&lock, K_FOREVER);
40013114:	fff00593          	li	a1,-1
{
40013118:	00050913          	mv	s2,a0
	STRUCT_SECTION_FOREACH(net_if, iface) {
4001311c:	40045437          	lui	s0,0x40045
	k_mutex_lock(&lock, K_FOREVER);
40013120:	fff00513          	li	a0,-1
	STRUCT_SECTION_FOREACH(net_if, iface) {
40013124:	400454b7          	lui	s1,0x40045
{
40013128:	00112623          	sw	ra,12(sp)
	STRUCT_SECTION_FOREACH(net_if, iface) {
4001312c:	9d840413          	addi	s0,s0,-1576 # 400449d8 <__net_if_dts_ord_12_0>
	k_mutex_lock(&lock, K_FOREVER);
40013130:	e79fc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
40013134:	a9c48493          	addi	s1,s1,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
40013138:	02946663          	bltu	s0,s1,40013164 <net_if_ipv4_select_src_iface+0x60>
		selected = net_if_get_default();
4001313c:	c15fd0ef          	jal	ra,40010d50 <net_if_get_default>
40013140:	00050413          	mv	s0,a0
	k_mutex_unlock(&lock);
40013144:	e79fc0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40013148:	00c12083          	lw	ra,12(sp)
4001314c:	00040513          	mv	a0,s0
40013150:	00812403          	lw	s0,8(sp)
40013154:	00412483          	lw	s1,4(sp)
40013158:	00012903          	lw	s2,0(sp)
4001315c:	01010113          	addi	sp,sp,16
40013160:	00008067          	ret
		ret = net_if_ipv4_addr_mask_cmp(iface, dst);
40013164:	00090593          	mv	a1,s2
40013168:	00040513          	mv	a0,s0
4001316c:	de5ff0ef          	jal	ra,40012f50 <net_if_ipv4_addr_mask_cmp>
		if (ret) {
40013170:	fc051ae3          	bnez	a0,40013144 <net_if_ipv4_select_src_iface+0x40>
	STRUCT_SECTION_FOREACH(net_if, iface) {
40013174:	0c440413          	addi	s0,s0,196
40013178:	fc1ff06f          	j	40013138 <net_if_ipv4_select_src_iface+0x34>

4001317c <net_if_ipv4_get_ll>:
	return if_ipv4_get_addr(iface, addr_state, true);
4001317c:	00100613          	li	a2,1
40013180:	e49fc06f          	j	4000ffc8 <if_ipv4_get_addr>

40013184 <net_if_ipv4_get_global_addr>:
	return if_ipv4_get_addr(iface, addr_state, false);
40013184:	00000613          	li	a2,0
40013188:	e41fc06f          	j	4000ffc8 <if_ipv4_get_addr>

4001318c <net_if_ipv4_select_src_addr>:
{
4001318c:	fd010113          	addi	sp,sp,-48
40013190:	02912223          	sw	s1,36(sp)
40013194:	01312e23          	sw	s3,28(sp)
40013198:	00050493          	mv	s1,a0
4001319c:	00058993          	mv	s3,a1
	k_mutex_lock(&lock, K_FOREVER);
400131a0:	fff00513          	li	a0,-1
400131a4:	fff00593          	li	a1,-1
{
400131a8:	02112623          	sw	ra,44(sp)
400131ac:	02812423          	sw	s0,40(sp)
400131b0:	03212023          	sw	s2,32(sp)
400131b4:	01412c23          	sw	s4,24(sp)
	uint8_t best_match = 0U;
400131b8:	000107a3          	sb	zero,15(sp)
	k_mutex_lock(&lock, K_FOREVER);
400131bc:	dedfc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (!net_ipv4_is_ll_addr(dst)) {
400131c0:	00098513          	mv	a0,s3
400131c4:	b4dfc0ef          	jal	ra,4000fd10 <net_ipv4_is_ll_addr>
400131c8:	08051263          	bnez	a0,4001324c <net_if_ipv4_select_src_addr+0xc0>
		if (dst_iface) {
400131cc:	06048463          	beqz	s1,40013234 <net_if_ipv4_select_src_addr+0xa8>
			src = net_if_ipv4_get_best_match(dst_iface, dst,
400131d0:	0c04a503          	lw	a0,192(s1)
400131d4:	00f10613          	addi	a2,sp,15
400131d8:	00098593          	mv	a1,s3
400131dc:	d70fd0ef          	jal	ra,4001074c <net_if_ipv4_get_best_match.isra.0>
			src = net_if_ipv4_get_ll(dst_iface, NET_ADDR_PREFERRED);
400131e0:	00050413          	mv	s0,a0
400131e4:	0240006f          	j	40013208 <net_if_ipv4_select_src_addr+0x7c>
				addr = net_if_ipv4_get_best_match(iface, dst,
400131e8:	0c092503          	lw	a0,192(s2)
400131ec:	00f10613          	addi	a2,sp,15
400131f0:	00098593          	mv	a1,s3
400131f4:	d58fd0ef          	jal	ra,4001074c <net_if_ipv4_get_best_match.isra.0>
				if (addr) {
400131f8:	00050463          	beqz	a0,40013200 <net_if_ipv4_select_src_addr+0x74>
400131fc:	00050413          	mv	s0,a0
			STRUCT_SECTION_FOREACH(net_if, iface) {
40013200:	0c490913          	addi	s2,s2,196
40013204:	ff4962e3          	bltu	s2,s4,400131e8 <net_if_ipv4_select_src_addr+0x5c>
	if (!src) {
40013208:	06040a63          	beqz	s0,4001327c <net_if_ipv4_select_src_addr+0xf0>
	k_mutex_unlock(&lock);
4001320c:	db1fc0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40013210:	02c12083          	lw	ra,44(sp)
40013214:	00040513          	mv	a0,s0
40013218:	02812403          	lw	s0,40(sp)
4001321c:	02412483          	lw	s1,36(sp)
40013220:	02012903          	lw	s2,32(sp)
40013224:	01c12983          	lw	s3,28(sp)
40013228:	01812a03          	lw	s4,24(sp)
4001322c:	03010113          	addi	sp,sp,48
40013230:	00008067          	ret
			STRUCT_SECTION_FOREACH(net_if, iface) {
40013234:	40045937          	lui	s2,0x40045
40013238:	40045a37          	lui	s4,0x40045
	const struct in_addr *src = NULL;
4001323c:	00000413          	li	s0,0
			STRUCT_SECTION_FOREACH(net_if, iface) {
40013240:	9d890913          	addi	s2,s2,-1576 # 400449d8 <__net_if_dts_ord_12_0>
40013244:	a9ca0a13          	addi	s4,s4,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
40013248:	fbdff06f          	j	40013204 <net_if_ipv4_select_src_addr+0x78>
		if (dst_iface) {
4001324c:	04048863          	beqz	s1,4001329c <net_if_ipv4_select_src_addr+0x110>
			src = net_if_ipv4_get_ll(dst_iface, NET_ADDR_PREFERRED);
40013250:	00100593          	li	a1,1
40013254:	00048513          	mv	a0,s1
40013258:	f25ff0ef          	jal	ra,4001317c <net_if_ipv4_get_ll>
4001325c:	f85ff06f          	j	400131e0 <net_if_ipv4_select_src_addr+0x54>
				addr = net_if_ipv4_get_ll(iface,
40013260:	00100593          	li	a1,1
40013264:	00090513          	mv	a0,s2
40013268:	f15ff0ef          	jal	ra,4001317c <net_if_ipv4_get_ll>
4001326c:	00050413          	mv	s0,a0
				if (addr) {
40013270:	f8051ee3          	bnez	a0,4001320c <net_if_ipv4_select_src_addr+0x80>
			STRUCT_SECTION_FOREACH(net_if, iface) {
40013274:	0c490913          	addi	s2,s2,196
40013278:	ff3964e3          	bltu	s2,s3,40013260 <net_if_ipv4_select_src_addr+0xd4>
		src = net_if_ipv4_get_global_addr(dst_iface,
4001327c:	00100593          	li	a1,1
40013280:	00048513          	mv	a0,s1
40013284:	f01ff0ef          	jal	ra,40013184 <net_if_ipv4_get_global_addr>
40013288:	00050413          	mv	s0,a0
		if (!src) {
4001328c:	f80510e3          	bnez	a0,4001320c <net_if_ipv4_select_src_addr+0x80>
			src = net_ipv4_unspecified_address();
40013290:	160020ef          	jal	ra,400153f0 <net_ipv4_unspecified_address>
40013294:	00050413          	mv	s0,a0
40013298:	f75ff06f          	j	4001320c <net_if_ipv4_select_src_addr+0x80>
			STRUCT_SECTION_FOREACH(net_if, iface) {
4001329c:	40045937          	lui	s2,0x40045
400132a0:	400459b7          	lui	s3,0x40045
400132a4:	9d890913          	addi	s2,s2,-1576 # 400449d8 <__net_if_dts_ord_12_0>
400132a8:	a9c98993          	addi	s3,s3,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
400132ac:	fcdff06f          	j	40013278 <net_if_ipv4_select_src_addr+0xec>

400132b0 <net_if_ipv4_addr_lookup>:
{
400132b0:	fe010113          	addi	sp,sp,-32
400132b4:	00812c23          	sw	s0,24(sp)
400132b8:	00912a23          	sw	s1,20(sp)
400132bc:	00050413          	mv	s0,a0
400132c0:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
400132c4:	fff00513          	li	a0,-1
400132c8:	fff00593          	li	a1,-1
{
400132cc:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
400132d0:	cd9fc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
400132d4:	400457b7          	lui	a5,0x40045
400132d8:	40045637          	lui	a2,0x40045
400132dc:	9d878793          	addi	a5,a5,-1576 # 400449d8 <__net_if_dts_ord_12_0>
400132e0:	a9c60613          	addi	a2,a2,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
			if (!ipv4->unicast[i].is_used ||
400132e4:	00100593          	li	a1,1
	STRUCT_SECTION_FOREACH(net_if, iface) {
400132e8:	00c7e663          	bltu	a5,a2,400132f4 <net_if_ipv4_addr_lookup+0x44>
	struct net_if_addr *ifaddr = NULL;
400132ec:	00000513          	li	a0,0
400132f0:	05c0006f          	j	4001334c <net_if_ipv4_addr_lookup+0x9c>
		struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
400132f4:	0c07a503          	lw	a0,192(a5)
		if (!ipv4) {
400132f8:	06050a63          	beqz	a0,4001336c <net_if_ipv4_addr_lookup+0xbc>
			if (!ipv4->unicast[i].is_used ||
400132fc:	02c52703          	lw	a4,44(a0)
40013300:	01975713          	srli	a4,a4,0x19
40013304:	00177713          	andi	a4,a4,1
40013308:	06070263          	beqz	a4,4001336c <net_if_ipv4_addr_lookup+0xbc>
4001330c:	00055703          	lhu	a4,0(a0)
40013310:	04b71e63          	bne	a4,a1,4001336c <net_if_ipv4_addr_lookup+0xbc>
			if (UNALIGNED_GET(&addr->s4_addr32[0]) ==
40013314:	00144703          	lbu	a4,1(s0)
40013318:	00044683          	lbu	a3,0(s0)
4001331c:	00871713          	slli	a4,a4,0x8
40013320:	00d76733          	or	a4,a4,a3
40013324:	00244683          	lbu	a3,2(s0)
40013328:	01069693          	slli	a3,a3,0x10
4001332c:	00e6e6b3          	or	a3,a3,a4
40013330:	00344703          	lbu	a4,3(s0)
40013334:	01871713          	slli	a4,a4,0x18
40013338:	00d76733          	or	a4,a4,a3
4001333c:	00452683          	lw	a3,4(a0)
40013340:	02e69663          	bne	a3,a4,4001336c <net_if_ipv4_addr_lookup+0xbc>
				if (ret) {
40013344:	00048463          	beqz	s1,4001334c <net_if_ipv4_addr_lookup+0x9c>
					*ret = iface;
40013348:	00f4a023          	sw	a5,0(s1)
				goto out;
4001334c:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
40013350:	c6dfc0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40013354:	01c12083          	lw	ra,28(sp)
40013358:	01812403          	lw	s0,24(sp)
4001335c:	00c12503          	lw	a0,12(sp)
40013360:	01412483          	lw	s1,20(sp)
40013364:	02010113          	addi	sp,sp,32
40013368:	00008067          	ret
	STRUCT_SECTION_FOREACH(net_if, iface) {
4001336c:	0c478793          	addi	a5,a5,196
40013370:	f79ff06f          	j	400132e8 <net_if_ipv4_addr_lookup+0x38>

40013374 <net_if_ipv4_set_netmask>:
{
40013374:	ff010113          	addi	sp,sp,-16
40013378:	00812423          	sw	s0,8(sp)
4001337c:	00912223          	sw	s1,4(sp)
40013380:	00058413          	mv	s0,a1
40013384:	00050493          	mv	s1,a0
	k_mutex_lock(&lock, K_FOREVER);
40013388:	fff00593          	li	a1,-1
4001338c:	fff00513          	li	a0,-1
{
40013390:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
40013394:	c15fc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv4_get(iface, NULL) < 0) {
40013398:	00000593          	li	a1,0
4001339c:	00048513          	mv	a0,s1
400133a0:	ad9ff0ef          	jal	ra,40012e78 <net_if_config_ipv4_get>
400133a4:	04054863          	bltz	a0,400133f4 <net_if_ipv4_set_netmask+0x80>
	if (!iface->config.ip.ipv4) {
400133a8:	0c04a683          	lw	a3,192(s1)
400133ac:	04068463          	beqz	a3,400133f4 <net_if_ipv4_set_netmask+0x80>
	net_ipaddr_copy(&iface->config.ip.ipv4->netmask, netmask);
400133b0:	00144783          	lbu	a5,1(s0)
400133b4:	00044703          	lbu	a4,0(s0)
400133b8:	00879793          	slli	a5,a5,0x8
400133bc:	00e7e7b3          	or	a5,a5,a4
400133c0:	00244703          	lbu	a4,2(s0)
400133c4:	01071713          	slli	a4,a4,0x10
400133c8:	00f76733          	or	a4,a4,a5
400133cc:	00344783          	lbu	a5,3(s0)
400133d0:	04e68623          	sb	a4,76(a3)
400133d4:	01879793          	slli	a5,a5,0x18
400133d8:	00e7e7b3          	or	a5,a5,a4
400133dc:	0087d713          	srli	a4,a5,0x8
400133e0:	04e686a3          	sb	a4,77(a3)
400133e4:	0107d713          	srli	a4,a5,0x10
400133e8:	0187d793          	srli	a5,a5,0x18
400133ec:	04e68723          	sb	a4,78(a3)
400133f0:	04f687a3          	sb	a5,79(a3)
}
400133f4:	00812403          	lw	s0,8(sp)
400133f8:	00c12083          	lw	ra,12(sp)
400133fc:	00412483          	lw	s1,4(sp)
40013400:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
40013404:	bb9fc06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>

40013408 <net_if_ipv4_addr_add>:
{
40013408:	fd010113          	addi	sp,sp,-48
4001340c:	02912223          	sw	s1,36(sp)
40013410:	03212023          	sw	s2,32(sp)
40013414:	00058493          	mv	s1,a1
40013418:	00050913          	mv	s2,a0
	k_mutex_lock(&lock, K_FOREVER);
4001341c:	fff00593          	li	a1,-1
40013420:	fff00513          	li	a0,-1
{
40013424:	02112623          	sw	ra,44(sp)
40013428:	02812423          	sw	s0,40(sp)
4001342c:	01312e23          	sw	s3,28(sp)
40013430:	01412c23          	sw	s4,24(sp)
40013434:	00068993          	mv	s3,a3
40013438:	00060a13          	mv	s4,a2
	k_mutex_lock(&lock, K_FOREVER);
4001343c:	b6dfc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
40013440:	00c10593          	addi	a1,sp,12
40013444:	00090513          	mv	a0,s2
40013448:	a31ff0ef          	jal	ra,40012e78 <net_if_config_ipv4_get>
	struct net_if_addr *ifaddr = NULL;
4001344c:	00000413          	li	s0,0
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
40013450:	0e054863          	bltz	a0,40013540 <net_if_ipv4_addr_add+0x138>
	ifaddr = ipv4_addr_find(iface, addr);
40013454:	0c092403          	lw	s0,192(s2)
		if (!ipv4->unicast[i].is_used) {
40013458:	02c42783          	lw	a5,44(s0)
4001345c:	0197d793          	srli	a5,a5,0x19
40013460:	0017f793          	andi	a5,a5,1
40013464:	04078c63          	beqz	a5,400134bc <net_if_ipv4_addr_add+0xb4>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40013468:	0014c703          	lbu	a4,1(s1)
4001346c:	0004c783          	lbu	a5,0(s1)
40013470:	00444683          	lbu	a3,4(s0)
40013474:	00871713          	slli	a4,a4,0x8
40013478:	00f76733          	or	a4,a4,a5
4001347c:	0024c783          	lbu	a5,2(s1)
40013480:	01079793          	slli	a5,a5,0x10
40013484:	00e7e7b3          	or	a5,a5,a4
40013488:	0034c703          	lbu	a4,3(s1)
4001348c:	01871713          	slli	a4,a4,0x18
40013490:	00f76733          	or	a4,a4,a5
40013494:	00544783          	lbu	a5,5(s0)
40013498:	00879793          	slli	a5,a5,0x8
4001349c:	00d7e7b3          	or	a5,a5,a3
400134a0:	00644683          	lbu	a3,6(s0)
400134a4:	01069693          	slli	a3,a3,0x10
400134a8:	00f6e6b3          	or	a3,a3,a5
400134ac:	00744783          	lbu	a5,7(s0)
400134b0:	01879793          	slli	a5,a5,0x18
400134b4:	00d7e7b3          	or	a5,a5,a3
		if (net_ipv4_addr_cmp(addr,
400134b8:	08f70463          	beq	a4,a5,40013540 <net_if_ipv4_addr_add+0x138>
		if (addr_type == NET_ADDR_DHCP
400134bc:	00200793          	li	a5,2
		struct net_if_addr *cur = &ipv4->unicast[i];
400134c0:	00c12703          	lw	a4,12(sp)
		if (addr_type == NET_ADDR_DHCP
400134c4:	00fa1863          	bne	s4,a5,400134d4 <net_if_ipv4_addr_add+0xcc>
		    && cur->addr_type == NET_ADDR_OVERRIDABLE) {
400134c8:	02c74683          	lbu	a3,44(a4)
400134cc:	00400793          	li	a5,4
400134d0:	00f68c63          	beq	a3,a5,400134e8 <net_if_ipv4_addr_add+0xe0>
		if (!ipv4->unicast[i].is_used) {
400134d4:	02c72783          	lw	a5,44(a4)
400134d8:	00000413          	li	s0,0
400134dc:	0197d793          	srli	a5,a5,0x19
400134e0:	0017f793          	andi	a5,a5,1
400134e4:	04079e63          	bnez	a5,40013540 <net_if_ipv4_addr_add+0x138>
		struct net_if_addr *cur = &ipv4->unicast[i];
400134e8:	00070413          	mv	s0,a4
	if (ifaddr) {
400134ec:	04070a63          	beqz	a4,40013540 <net_if_ipv4_addr_add+0x138>
		ifaddr->is_used = true;
400134f0:	02f74783          	lbu	a5,47(a4)
400134f4:	0019b993          	seqz	s3,s3
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ADDR_ADD, iface,
400134f8:	e0040537          	lui	a0,0xe0040
		ifaddr->is_used = true;
400134fc:	0027e793          	ori	a5,a5,2
40013500:	02f707a3          	sb	a5,47(a4)
		ifaddr->address.family = AF_INET;
40013504:	00100793          	li	a5,1
40013508:	00f71023          	sh	a5,0(a4)
		ifaddr->address.in_addr.s4_addr32[0] =
4001350c:	02f44683          	lbu	a3,47(s0)
						addr->s4_addr32[0];
40013510:	0004a703          	lw	a4,0(s1)
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ADDR_ADD, iface,
40013514:	00440613          	addi	a2,s0,4
40013518:	ffe6f693          	andi	a3,a3,-2
4001351c:	0136e6b3          	or	a3,a3,s3
40013520:	02d407a3          	sb	a3,47(s0)
		ifaddr->address.in_addr.s4_addr32[0] =
40013524:	00e42223          	sw	a4,4(s0)
		ifaddr->addr_type = addr_type;
40013528:	03440623          	sb	s4,44(s0)
		ifaddr->addr_state = NET_ADDR_PREFERRED;
4001352c:	02f406a3          	sb	a5,45(s0)
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ADDR_ADD, iface,
40013530:	00400693          	li	a3,4
40013534:	00090593          	mv	a1,s2
40013538:	00150513          	addi	a0,a0,1 # e0040001 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0040002>
4001353c:	190020ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
	k_mutex_unlock(&lock);
40013540:	a7dfc0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40013544:	02c12083          	lw	ra,44(sp)
40013548:	00040513          	mv	a0,s0
4001354c:	02812403          	lw	s0,40(sp)
40013550:	02412483          	lw	s1,36(sp)
40013554:	02012903          	lw	s2,32(sp)
40013558:	01c12983          	lw	s3,28(sp)
4001355c:	01812a03          	lw	s4,24(sp)
40013560:	03010113          	addi	sp,sp,48
40013564:	00008067          	ret

40013568 <net_if_ipv4_addr_rm>:
{
40013568:	ff010113          	addi	sp,sp,-16
4001356c:	00912223          	sw	s1,4(sp)
40013570:	01212023          	sw	s2,0(sp)
40013574:	00058493          	mv	s1,a1
40013578:	00050913          	mv	s2,a0
	k_mutex_lock(&lock, K_FOREVER);
4001357c:	fff00593          	li	a1,-1
40013580:	fff00513          	li	a0,-1
{
40013584:	00112623          	sw	ra,12(sp)
40013588:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001358c:	a1dfc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	ipv4 = iface->config.ip.ipv4;
40013590:	0c092603          	lw	a2,192(s2)
	if (!ipv4) {
40013594:	00061663          	bnez	a2,400135a0 <net_if_ipv4_addr_rm+0x38>
	bool ret = false;
40013598:	00000413          	li	s0,0
4001359c:	08c0006f          	j	40013628 <net_if_ipv4_addr_rm+0xc0>
		if (!ipv4->unicast[i].is_used) {
400135a0:	02c62403          	lw	s0,44(a2)
400135a4:	01945413          	srli	s0,s0,0x19
400135a8:	00147413          	andi	s0,s0,1
400135ac:	06040e63          	beqz	s0,40013628 <net_if_ipv4_addr_rm+0xc0>
400135b0:	0014c703          	lbu	a4,1(s1)
400135b4:	0004c783          	lbu	a5,0(s1)
400135b8:	00464683          	lbu	a3,4(a2)
400135bc:	00871713          	slli	a4,a4,0x8
400135c0:	00f76733          	or	a4,a4,a5
400135c4:	0024c783          	lbu	a5,2(s1)
400135c8:	01079793          	slli	a5,a5,0x10
400135cc:	00e7e7b3          	or	a5,a5,a4
400135d0:	0034c703          	lbu	a4,3(s1)
400135d4:	01871713          	slli	a4,a4,0x18
400135d8:	00f76733          	or	a4,a4,a5
400135dc:	00564783          	lbu	a5,5(a2)
400135e0:	00879793          	slli	a5,a5,0x8
400135e4:	00d7e7b3          	or	a5,a5,a3
400135e8:	00664683          	lbu	a3,6(a2)
400135ec:	01069693          	slli	a3,a3,0x10
400135f0:	00f6e6b3          	or	a3,a3,a5
400135f4:	00764783          	lbu	a5,7(a2)
400135f8:	01879793          	slli	a5,a5,0x18
400135fc:	00d7e7b3          	or	a5,a5,a3
		if (!net_ipv4_addr_cmp(&ipv4->unicast[i].address.in_addr,
40013600:	f8f71ce3          	bne	a4,a5,40013598 <net_if_ipv4_addr_rm+0x30>
		ipv4->unicast[i].is_used = false;
40013604:	02f64783          	lbu	a5,47(a2)
		net_mgmt_event_notify_with_info(
40013608:	e0040537          	lui	a0,0xe0040
4001360c:	00400693          	li	a3,4
		ipv4->unicast[i].is_used = false;
40013610:	ffd7f793          	andi	a5,a5,-3
40013614:	02f607a3          	sb	a5,47(a2)
		net_mgmt_event_notify_with_info(
40013618:	00090593          	mv	a1,s2
4001361c:	00460613          	addi	a2,a2,4
40013620:	00250513          	addi	a0,a0,2 # e0040002 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0040003>
40013624:	0a8020ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
	k_mutex_unlock(&lock);
40013628:	995fc0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
4001362c:	00c12083          	lw	ra,12(sp)
40013630:	00040513          	mv	a0,s0
40013634:	00812403          	lw	s0,8(sp)
40013638:	00412483          	lw	s1,4(sp)
4001363c:	00012903          	lw	s2,0(sp)
40013640:	01010113          	addi	sp,sp,16
40013644:	00008067          	ret

40013648 <net_if_ipv4_maddr_lookup>:
{
40013648:	ff010113          	addi	sp,sp,-16
4001364c:	00912223          	sw	s1,4(sp)
40013650:	01212023          	sw	s2,0(sp)
40013654:	00050493          	mv	s1,a0
40013658:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
4001365c:	fff00513          	li	a0,-1
40013660:	fff00593          	li	a1,-1
{
40013664:	00112623          	sw	ra,12(sp)
40013668:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001366c:	93dfc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
40013670:	400457b7          	lui	a5,0x40045
40013674:	40045737          	lui	a4,0x40045
40013678:	9d878793          	addi	a5,a5,-1576 # 400449d8 <__net_if_dts_ord_12_0>
4001367c:	a9c70713          	addi	a4,a4,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
40013680:	04e7fe63          	bgeu	a5,a4,400136dc <net_if_ipv4_maddr_lookup+0x94>
		if (ret && *ret && iface != *ret) {
40013684:	04090063          	beqz	s2,400136c4 <net_if_ipv4_maddr_lookup+0x7c>
40013688:	00092683          	lw	a3,0(s2)
4001368c:	02068c63          	beqz	a3,400136c4 <net_if_ipv4_maddr_lookup+0x7c>
40013690:	04f69263          	bne	a3,a5,400136d4 <net_if_ipv4_maddr_lookup+0x8c>
		addr = ipv4_maddr_find(iface, true, maddr);
40013694:	0c07a403          	lw	s0,192(a5)
	if (!ipv4) {
40013698:	04041663          	bnez	s0,400136e4 <net_if_ipv4_maddr_lookup+0x9c>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4001369c:	0c478793          	addi	a5,a5,196
400136a0:	fee7e4e3          	bltu	a5,a4,40013688 <net_if_ipv4_maddr_lookup+0x40>
	k_mutex_unlock(&lock);
400136a4:	919fc0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
400136a8:	00c12083          	lw	ra,12(sp)
400136ac:	00040513          	mv	a0,s0
400136b0:	00812403          	lw	s0,8(sp)
400136b4:	00412483          	lw	s1,4(sp)
400136b8:	00012903          	lw	s2,0(sp)
400136bc:	01010113          	addi	sp,sp,16
400136c0:	00008067          	ret
		addr = ipv4_maddr_find(iface, true, maddr);
400136c4:	0c07a403          	lw	s0,192(a5)
	if (!ipv4) {
400136c8:	00041e63          	bnez	s0,400136e4 <net_if_ipv4_maddr_lookup+0x9c>
	STRUCT_SECTION_FOREACH(net_if, iface) {
400136cc:	0c478793          	addi	a5,a5,196
400136d0:	fb1ff06f          	j	40013680 <net_if_ipv4_maddr_lookup+0x38>
400136d4:	0c478793          	addi	a5,a5,196
400136d8:	fae7e8e3          	bltu	a5,a4,40013688 <net_if_ipv4_maddr_lookup+0x40>
out:
400136dc:	00000413          	li	s0,0
400136e0:	fc5ff06f          	j	400136a4 <net_if_ipv4_maddr_lookup+0x5c>
		if ((is_used && !ipv4->mcast[i].is_used) ||
400136e4:	04442683          	lw	a3,68(s0)
400136e8:	0016f693          	andi	a3,a3,1
400136ec:	fe0680e3          	beqz	a3,400136cc <net_if_ipv4_maddr_lookup+0x84>
		if (addr) {
400136f0:	04048c63          	beqz	s1,40013748 <net_if_ipv4_maddr_lookup+0x100>
400136f4:	03544603          	lbu	a2,53(s0)
400136f8:	03444683          	lbu	a3,52(s0)
400136fc:	0004c583          	lbu	a1,0(s1)
40013700:	00861613          	slli	a2,a2,0x8
40013704:	00d66633          	or	a2,a2,a3
40013708:	03644683          	lbu	a3,54(s0)
4001370c:	01069693          	slli	a3,a3,0x10
40013710:	00c6e6b3          	or	a3,a3,a2
40013714:	03744603          	lbu	a2,55(s0)
40013718:	01861613          	slli	a2,a2,0x18
4001371c:	00d66633          	or	a2,a2,a3
40013720:	0014c683          	lbu	a3,1(s1)
40013724:	00869693          	slli	a3,a3,0x8
40013728:	00b6e6b3          	or	a3,a3,a1
4001372c:	0024c583          	lbu	a1,2(s1)
40013730:	01059593          	slli	a1,a1,0x10
40013734:	00d5e5b3          	or	a1,a1,a3
40013738:	0034c683          	lbu	a3,3(s1)
4001373c:	01869693          	slli	a3,a3,0x18
40013740:	00b6e6b3          	or	a3,a3,a1
			if (!net_ipv4_addr_cmp(&ipv4->mcast[i].address.in_addr,
40013744:	f8d614e3          	bne	a2,a3,400136cc <net_if_ipv4_maddr_lookup+0x84>
			if (ret) {
40013748:	00090463          	beqz	s2,40013750 <net_if_ipv4_maddr_lookup+0x108>
				*ret = iface;
4001374c:	00f92023          	sw	a5,0(s2)
		return &ipv4->mcast[i];
40013750:	03040413          	addi	s0,s0,48
40013754:	f51ff06f          	j	400136a4 <net_if_ipv4_maddr_lookup+0x5c>

40013758 <net_if_recv_data>:
{
40013758:	fe010113          	addi	sp,sp,-32
4001375c:	00812c23          	sw	s0,24(sp)
40013760:	00112e23          	sw	ra,28(sp)
40013764:	00050413          	mv	s0,a0
40013768:	00b12623          	sw	a1,12(sp)
	return net_if_l2(iface)->recv(iface, pkt);
4001376c:	e14fc0ef          	jal	ra,4000fd80 <net_if_l2>
40013770:	00052783          	lw	a5,0(a0)
40013774:	00040513          	mv	a0,s0
}
40013778:	01812403          	lw	s0,24(sp)
	return net_if_l2(iface)->recv(iface, pkt);
4001377c:	00c12583          	lw	a1,12(sp)
}
40013780:	01c12083          	lw	ra,28(sp)
40013784:	02010113          	addi	sp,sp,32
	return net_if_l2(iface)->recv(iface, pkt);
40013788:	00078067          	jr	a5

4001378c <net_if_call_link_cb>:
{
4001378c:	fe010113          	addi	sp,sp,-32
40013790:	00912a23          	sw	s1,20(sp)
40013794:	01212823          	sw	s2,16(sp)
40013798:	00050493          	mv	s1,a0
4001379c:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
400137a0:	fff00513          	li	a0,-1
400137a4:	fff00593          	li	a1,-1
{
400137a8:	01312623          	sw	s3,12(sp)
400137ac:	00112e23          	sw	ra,28(sp)
400137b0:	00812c23          	sw	s0,24(sp)
400137b4:	00060993          	mv	s3,a2
	k_mutex_lock(&lock, K_FOREVER);
400137b8:	ff0fc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
400137bc:	400397b7          	lui	a5,0x40039
400137c0:	0407a783          	lw	a5,64(a5) # 40039040 <link_callbacks>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
400137c4:	00078663          	beqz	a5,400137d0 <net_if_call_link_cb+0x44>
	return node->next;
400137c8:	0007a403          	lw	s0,0(a5)
400137cc:	02079063          	bnez	a5,400137ec <net_if_call_link_cb+0x60>
}
400137d0:	01812403          	lw	s0,24(sp)
400137d4:	01c12083          	lw	ra,28(sp)
400137d8:	01412483          	lw	s1,20(sp)
400137dc:	01012903          	lw	s2,16(sp)
400137e0:	00c12983          	lw	s3,12(sp)
400137e4:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
400137e8:	fd4fc06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>
		link->cb(iface, lladdr, status);
400137ec:	0047a783          	lw	a5,4(a5)
400137f0:	00098613          	mv	a2,s3
400137f4:	00090593          	mv	a1,s2
400137f8:	00048513          	mv	a0,s1
400137fc:	000780e7          	jalr	a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
40013800:	00000713          	li	a4,0
40013804:	00040463          	beqz	s0,4001380c <net_if_call_link_cb+0x80>
40013808:	00042703          	lw	a4,0(s0)
4001380c:	00040793          	mv	a5,s0
40013810:	00070413          	mv	s0,a4
40013814:	fb9ff06f          	j	400137cc <net_if_call_link_cb+0x40>

40013818 <net_if_tx.isra.0>:
static bool net_if_tx(struct net_if *iface, struct net_pkt *pkt)
40013818:	fd010113          	addi	sp,sp,-48
4001381c:	02812423          	sw	s0,40(sp)
40013820:	02112623          	sw	ra,44(sp)
40013824:	02912223          	sw	s1,36(sp)
40013828:	03212023          	sw	s2,32(sp)
4001382c:	01312e23          	sw	s3,28(sp)
40013830:	01412c23          	sw	s4,24(sp)
40013834:	03010413          	addi	s0,sp,48
	struct net_linkaddr ll_dst = {
40013838:	fc042823          	sw	zero,-48(s0)
4001383c:	fc042a23          	sw	zero,-44(s0)
	if (!pkt) {
40013840:	14058063          	beqz	a1,40013980 <net_if_tx.isra.0+0x168>
	if (!sys_slist_is_empty(&link_callbacks)) {
40013844:	400397b7          	lui	a5,0x40039
40013848:	0407a783          	lw	a5,64(a5) # 40039040 <link_callbacks>
4001384c:	00050913          	mv	s2,a0
40013850:	00058493          	mv	s1,a1
40013854:	02078e63          	beqz	a5,40013890 <net_if_tx.isra.0+0x78>
		if (net_linkaddr_set(&ll_dst_storage,
40013858:	02c5a583          	lw	a1,44(a1)
4001385c:	0304c603          	lbu	a2,48(s1)
 * This value should always be <= NET_LINK_ADDR_MAX_LENGTH.
 */
static inline int net_linkaddr_set(struct net_linkaddr_storage *lladdr_store,
				   uint8_t *new_addr, uint8_t new_len)
{
	if (!lladdr_store || !new_addr) {
40013860:	02058863          	beqz	a1,40013890 <net_if_tx.isra.0+0x78>
		return -EINVAL;
	}

	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
40013864:	00600793          	li	a5,6
40013868:	02c7e463          	bltu	a5,a2,40013890 <net_if_tx.isra.0+0x78>
		return -EMSGSIZE;
	}

	lladdr_store->len = new_len;
	memcpy(lladdr_store->addr, new_addr, new_len);
4001386c:	fda40993          	addi	s3,s0,-38
40013870:	00098513          	mv	a0,s3
	lladdr_store->len = new_len;
40013874:	fcc40ca3          	sb	a2,-39(s0)
	memcpy(lladdr_store->addr, new_addr, new_len);
40013878:	c80f90ef          	jal	ra,4000ccf8 <memcpy>
			ll_dst.len = ll_dst_storage.len;
4001387c:	fd944783          	lbu	a5,-39(s0)
			ll_dst.addr = ll_dst_storage.addr;
40013880:	fd342823          	sw	s3,-48(s0)
			ll_dst.len = ll_dst_storage.len;
40013884:	fcf40a23          	sb	a5,-44(s0)
			ll_dst.type = net_pkt_lladdr_dst(pkt)->type;
40013888:	0314c783          	lbu	a5,49(s1)
4001388c:	fcf40aa3          	sb	a5,-43(s0)
	if (net_if_flag_is_set(iface, NET_IF_LOWER_UP)) {
40013890:	00900593          	li	a1,9
40013894:	00090513          	mv	a0,s2
	return pkt->context;
40013898:	0144aa03          	lw	s4,20(s1)
4001389c:	dbdfc0ef          	jal	ra,40010658 <net_if_flag_is_set>
400138a0:	06050063          	beqz	a0,40013900 <net_if_tx.isra.0+0xe8>
	return pkt->family;
400138a4:	0344a783          	lw	a5,52(s1)
		if (IS_ENABLED(CONFIG_NET_TCP) &&
400138a8:	01d7d793          	srli	a5,a5,0x1d
400138ac:	00078863          	beqz	a5,400138bc <net_if_tx.isra.0+0xa4>
	pkt->pkt_queued = send;
400138b0:	0374c783          	lbu	a5,55(s1)
400138b4:	ffb7f793          	andi	a5,a5,-5
400138b8:	02f48ba3          	sb	a5,55(s1)
		status = net_if_l2(iface)->send(iface, pkt);
400138bc:	00090513          	mv	a0,s2
400138c0:	cc0fc0ef          	jal	ra,4000fd80 <net_if_l2>
400138c4:	00452783          	lw	a5,4(a0)
400138c8:	00048593          	mv	a1,s1
400138cc:	00090513          	mv	a0,s2
400138d0:	000780e7          	jalr	a5
400138d4:	00050993          	mv	s3,a0
	if (status < 0) {
400138d8:	06054c63          	bltz	a0,40013950 <net_if_tx.isra.0+0x138>
	UPDATE_STAT(iface, stats.bytes.sent += bytes);
400138dc:	4003b7b7          	lui	a5,0x4003b
400138e0:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
400138e4:	0047a703          	lw	a4,4(a5)
400138e8:	00a70733          	add	a4,a4,a0
400138ec:	00e7a223          	sw	a4,4(a5)
400138f0:	00892783          	lw	a5,8(s2)
400138f4:	00a787b3          	add	a5,a5,a0
400138f8:	00f92423          	sw	a5,8(s2)
}
400138fc:	05c0006f          	j	40013958 <net_if_tx.isra.0+0x140>
		NET_WARN("iface %p is down", iface);
40013900:	40044537          	lui	a0,0x40044
40013904:	77452783          	lw	a5,1908(a0) # 40044774 <log_dynamic_net_if>
40013908:	0067f793          	andi	a5,a5,6
4001390c:	04078063          	beqz	a5,4001394c <net_if_tx.isra.0+0x134>
40013910:	00010993          	mv	s3,sp
40013914:	fe010113          	addi	sp,sp,-32
40013918:	00010613          	mv	a2,sp
4001391c:	400357b7          	lui	a5,0x40035
40013920:	b0878793          	addi	a5,a5,-1272 # 40034b08 <net_buf_fixed_cb+0x1a8>
40013924:	00f62a23          	sw	a5,20(a2)
40013928:	000025b7          	lui	a1,0x2
4001392c:	00300793          	li	a5,3
40013930:	01262c23          	sw	s2,24(a2)
40013934:	00f62823          	sw	a5,16(a2)
40013938:	88058593          	addi	a1,a1,-1920 # 1880 <CONFIG_HEAP_MEM_POOL_SIZE+0x880>
4001393c:	01060613          	addi	a2,a2,16
40013940:	77450513          	addi	a0,a0,1908
40013944:	e5cfc0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
40013948:	00098113          	mv	sp,s3
		status = -ENETDOWN;
4001394c:	f8d00993          	li	s3,-115
		net_pkt_unref(pkt);
40013950:	00048513          	mv	a0,s1
40013954:	6c9030ef          	jal	ra,4001781c <net_pkt_unref>
	if (context) {
40013958:	000a0863          	beqz	s4,40013968 <net_if_tx.isra.0+0x150>
		net_context_send_cb(context, status);
4001395c:	00098593          	mv	a1,s3
40013960:	000a0513          	mv	a0,s4
40013964:	9fcfd0ef          	jal	ra,40010b60 <net_context_send_cb>
	if (ll_dst.addr) {
40013968:	fd042783          	lw	a5,-48(s0)
4001396c:	00078a63          	beqz	a5,40013980 <net_if_tx.isra.0+0x168>
		net_if_call_link_cb(iface, &ll_dst, status);
40013970:	00098613          	mv	a2,s3
40013974:	fd040593          	addi	a1,s0,-48
40013978:	00090513          	mv	a0,s2
4001397c:	e11ff0ef          	jal	ra,4001378c <net_if_call_link_cb>
}
40013980:	fd040113          	addi	sp,s0,-48
40013984:	02c12083          	lw	ra,44(sp)
40013988:	02812403          	lw	s0,40(sp)
4001398c:	02412483          	lw	s1,36(sp)
40013990:	02012903          	lw	s2,32(sp)
40013994:	01c12983          	lw	s3,28(sp)
40013998:	01812a03          	lw	s4,24(sp)
4001399c:	03010113          	addi	sp,sp,48
400139a0:	00008067          	ret

400139a4 <net_if_queue_tx>:
{
400139a4:	fe010113          	addi	sp,sp,-32
400139a8:	00112e23          	sw	ra,28(sp)
	uint8_t tc = net_tx_priority2tc(prio);
400139ac:	0415c503          	lbu	a0,65(a1)
400139b0:	00b12623          	sw	a1,12(sp)
400139b4:	05c050ef          	jal	ra,40018a10 <net_tx_priority2tc>
		net_if_tx(net_pkt_iface(pkt), pkt);
400139b8:	00c12583          	lw	a1,12(sp)
}
400139bc:	01c12083          	lw	ra,28(sp)
		net_if_tx(net_pkt_iface(pkt), pkt);
400139c0:	0185a503          	lw	a0,24(a1)
}
400139c4:	02010113          	addi	sp,sp,32
		net_if_tx(net_pkt_iface(pkt), pkt);
400139c8:	e51ff06f          	j	40013818 <net_if_tx.isra.0>

400139cc <net_if_send_data>:
{
400139cc:	fd010113          	addi	sp,sp,-48
400139d0:	02812423          	sw	s0,40(sp)
400139d4:	02912223          	sw	s1,36(sp)
400139d8:	03212023          	sw	s2,32(sp)
400139dc:	02112623          	sw	ra,44(sp)
400139e0:	01312e23          	sw	s3,28(sp)
400139e4:	01412c23          	sw	s4,24(sp)
400139e8:	03010413          	addi	s0,sp,48
	return pkt->context;
400139ec:	0145aa03          	lw	s4,20(a1)
400139f0:	00050913          	mv	s2,a0
400139f4:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
400139f8:	fff00513          	li	a0,-1
400139fc:	fff00593          	li	a1,-1
40013a00:	da8fc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	if (!net_if_flag_is_set(iface, NET_IF_LOWER_UP) ||
40013a04:	00900593          	li	a1,9
40013a08:	00090513          	mv	a0,s2
40013a0c:	c4dfc0ef          	jal	ra,40010658 <net_if_flag_is_set>
40013a10:	04051063          	bnez	a0,40013a50 <net_if_send_data+0x84>
		NET_WARN("iface %p is down", iface);
40013a14:	40044537          	lui	a0,0x40044
40013a18:	77452783          	lw	a5,1908(a0) # 40044774 <log_dynamic_net_if>
40013a1c:	0067f793          	andi	a5,a5,6
40013a20:	0c079263          	bnez	a5,40013ae4 <net_if_send_data+0x118>
		status = -ENETDOWN;
40013a24:	f8d00613          	li	a2,-115
		if (context) {
40013a28:	000a0c63          	beqz	s4,40013a40 <net_if_send_data+0x74>
			net_context_send_cb(context, status);
40013a2c:	00060593          	mv	a1,a2
40013a30:	000a0513          	mv	a0,s4
40013a34:	fcc42e23          	sw	a2,-36(s0)
40013a38:	928fd0ef          	jal	ra,40010b60 <net_context_send_cb>
40013a3c:	fdc42603          	lw	a2,-36(s0)
		if (dst->addr) {
40013a40:	02c4a783          	lw	a5,44(s1)
40013a44:	0e079a63          	bnez	a5,40013b38 <net_if_send_data+0x16c>
		status = -ENETDOWN;
40013a48:	00200513          	li	a0,2
40013a4c:	0680006f          	j	40013ab4 <net_if_send_data+0xe8>
	    net_if_flag_is_set(iface, NET_IF_SUSPENDED)) {
40013a50:	00400593          	li	a1,4
40013a54:	00090513          	mv	a0,s2
40013a58:	c01fc0ef          	jal	ra,40010658 <net_if_flag_is_set>
	if (!net_if_flag_is_set(iface, NET_IF_LOWER_UP) ||
40013a5c:	fa051ce3          	bnez	a0,40013a14 <net_if_send_data+0x48>
	if (!net_if_flag_is_set(iface, NET_IF_POINTOPOINT) &&
40013a60:	00100593          	li	a1,1
40013a64:	00090513          	mv	a0,s2
40013a68:	bf1fc0ef          	jal	ra,40010658 <net_if_flag_is_set>
40013a6c:	02051463          	bnez	a0,40013a94 <net_if_send_data+0xc8>
40013a70:	0244a783          	lw	a5,36(s1)
40013a74:	02079063          	bnez	a5,40013a94 <net_if_send_data+0xc8>
	return net_if_get_link_addr(pkt->iface);
40013a78:	0184a783          	lw	a5,24(s1)
		net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
40013a7c:	0007a703          	lw	a4,0(a5)
40013a80:	01072703          	lw	a4,16(a4)
40013a84:	02e4a223          	sw	a4,36(s1)
		net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
40013a88:	0007a783          	lw	a5,0(a5)
40013a8c:	0147c783          	lbu	a5,20(a5)
40013a90:	02f48423          	sb	a5,40(s1)
	return pkt->family;
40013a94:	0344a983          	lw	s3,52(s1)
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
40013a98:	00200793          	li	a5,2
40013a9c:	01d9d993          	srli	s3,s3,0x1d
40013aa0:	08f98263          	beq	s3,a5,40013b24 <net_if_send_data+0x158>
		net_if_queue_tx(iface, pkt);
40013aa4:	00090513          	mv	a0,s2
40013aa8:	00048593          	mv	a1,s1
40013aac:	ef9ff0ef          	jal	ra,400139a4 <net_if_queue_tx>
40013ab0:	00000513          	li	a0,0
40013ab4:	fca42e23          	sw	a0,-36(s0)
	k_mutex_unlock(&lock);
40013ab8:	d04fc0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40013abc:	fdc42503          	lw	a0,-36(s0)
40013ac0:	fd040113          	addi	sp,s0,-48
40013ac4:	02c12083          	lw	ra,44(sp)
40013ac8:	02812403          	lw	s0,40(sp)
40013acc:	02412483          	lw	s1,36(sp)
40013ad0:	02012903          	lw	s2,32(sp)
40013ad4:	01c12983          	lw	s3,28(sp)
40013ad8:	01812a03          	lw	s4,24(sp)
40013adc:	03010113          	addi	sp,sp,48
40013ae0:	00008067          	ret
		NET_WARN("iface %p is down", iface);
40013ae4:	00010993          	mv	s3,sp
40013ae8:	fe010113          	addi	sp,sp,-32
40013aec:	00010613          	mv	a2,sp
40013af0:	400357b7          	lui	a5,0x40035
40013af4:	b0878793          	addi	a5,a5,-1272 # 40034b08 <net_buf_fixed_cb+0x1a8>
40013af8:	00f62a23          	sw	a5,20(a2)
40013afc:	000025b7          	lui	a1,0x2
40013b00:	00300793          	li	a5,3
40013b04:	01262c23          	sw	s2,24(a2)
40013b08:	00f62823          	sw	a5,16(a2)
40013b0c:	88058593          	addi	a1,a1,-1920 # 1880 <CONFIG_HEAP_MEM_POOL_SIZE+0x880>
40013b10:	01060613          	addi	a2,a2,16
40013b14:	77450513          	addi	a0,a0,1908
40013b18:	c88fc0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
40013b1c:	00098113          	mv	sp,s3
40013b20:	f05ff06f          	j	40013a24 <net_if_send_data+0x58>
		verdict = net_ipv6_prepare_for_send(pkt);
40013b24:	00048513          	mv	a0,s1
40013b28:	4550a0ef          	jal	ra,4001e77c <net_ipv6_prepare_for_send>
	if (verdict == NET_DROP) {
40013b2c:	01351e63          	bne	a0,s3,40013b48 <net_if_send_data+0x17c>
	int status = -EIO;
40013b30:	ffb00613          	li	a2,-5
40013b34:	ef5ff06f          	j	40013a28 <net_if_send_data+0x5c>
			net_if_call_link_cb(iface, dst, status);
40013b38:	02c48593          	addi	a1,s1,44
40013b3c:	00090513          	mv	a0,s2
40013b40:	c4dff0ef          	jal	ra,4001378c <net_if_call_link_cb>
40013b44:	f05ff06f          	j	40013a48 <net_if_send_data+0x7c>
	} else if (verdict == NET_OK) {
40013b48:	f60516e3          	bnez	a0,40013ab4 <net_if_send_data+0xe8>
40013b4c:	f59ff06f          	j	40013aa4 <net_if_send_data+0xd8>

40013b50 <net_if_need_calc_tx_checksum>:
	return need_calc_checksum(iface, ETHERNET_HW_TX_CHKSUM_OFFLOAD);
40013b50:	00100593          	li	a1,1
40013b54:	de5fc06f          	j	40010938 <need_calc_checksum>

40013b58 <net_if_need_calc_rx_checksum>:
	return need_calc_checksum(iface, ETHERNET_HW_RX_CHKSUM_OFFLOAD);
40013b58:	00200593          	li	a1,2
40013b5c:	dddfc06f          	j	40010938 <need_calc_checksum>

40013b60 <net_if_get_by_iface>:
	if (!(iface >= _net_if_list_start && iface < _net_if_list_end)) {
40013b60:	40045737          	lui	a4,0x40045
40013b64:	9d870713          	addi	a4,a4,-1576 # 400449d8 <__net_if_dts_ord_12_0>
{
40013b68:	00050793          	mv	a5,a0
	if (!(iface >= _net_if_list_start && iface < _net_if_list_end)) {
40013b6c:	02e56863          	bltu	a0,a4,40013b9c <net_if_get_by_iface+0x3c>
40013b70:	400456b7          	lui	a3,0x40045
40013b74:	a9c68693          	addi	a3,a3,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
		return -1;
40013b78:	fff00513          	li	a0,-1
	if (!(iface >= _net_if_list_start && iface < _net_if_list_end)) {
40013b7c:	02d7f263          	bgeu	a5,a3,40013ba0 <net_if_get_by_iface+0x40>
	return (iface - _net_if_list_start) + 1;
40013b80:	40e78533          	sub	a0,a5,a4
40013b84:	1a1f67b7          	lui	a5,0x1a1f6
40013b88:	8d178793          	addi	a5,a5,-1839 # 1a1f58d1 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x142977d1>
40013b8c:	40255513          	srai	a0,a0,0x2
40013b90:	02f50533          	mul	a0,a0,a5
40013b94:	00150513          	addi	a0,a0,1
40013b98:	00008067          	ret
		return -1;
40013b9c:	fff00513          	li	a0,-1
}
40013ba0:	00008067          	ret

40013ba4 <net_if_foreach>:
{
40013ba4:	fe010113          	addi	sp,sp,-32
40013ba8:	00812c23          	sw	s0,24(sp)
40013bac:	00912a23          	sw	s1,20(sp)
	STRUCT_SECTION_FOREACH(net_if, iface) {
40013bb0:	40045437          	lui	s0,0x40045
40013bb4:	400454b7          	lui	s1,0x40045
{
40013bb8:	01212823          	sw	s2,16(sp)
40013bbc:	01312623          	sw	s3,12(sp)
40013bc0:	00112e23          	sw	ra,28(sp)
40013bc4:	00050913          	mv	s2,a0
40013bc8:	00058993          	mv	s3,a1
	STRUCT_SECTION_FOREACH(net_if, iface) {
40013bcc:	9d840413          	addi	s0,s0,-1576 # 400449d8 <__net_if_dts_ord_12_0>
40013bd0:	a9c48493          	addi	s1,s1,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
40013bd4:	02946063          	bltu	s0,s1,40013bf4 <net_if_foreach+0x50>
}
40013bd8:	01c12083          	lw	ra,28(sp)
40013bdc:	01812403          	lw	s0,24(sp)
40013be0:	01412483          	lw	s1,20(sp)
40013be4:	01012903          	lw	s2,16(sp)
40013be8:	00c12983          	lw	s3,12(sp)
40013bec:	02010113          	addi	sp,sp,32
40013bf0:	00008067          	ret
		cb(iface, user_data);
40013bf4:	00040513          	mv	a0,s0
40013bf8:	00098593          	mv	a1,s3
40013bfc:	000900e7          	jalr	s2
	STRUCT_SECTION_FOREACH(net_if, iface) {
40013c00:	0c440413          	addi	s0,s0,196
40013c04:	fd1ff06f          	j	40013bd4 <net_if_foreach+0x30>

40013c08 <net_if_up>:
	return;
#endif
}

int net_if_up(struct net_if *iface)
{
40013c08:	ff010113          	addi	sp,sp,-16
40013c0c:	00812423          	sw	s0,8(sp)
	int status = 0;

	NET_DBG("iface %p", iface);

	k_mutex_lock(&lock, K_FOREVER);
40013c10:	fff00593          	li	a1,-1
{
40013c14:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
40013c18:	fff00513          	li	a0,-1
{
40013c1c:	00112623          	sw	ra,12(sp)
40013c20:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
40013c24:	b84fc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>

	if (net_if_flag_is_set(iface, NET_IF_UP)) {
40013c28:	00000593          	li	a1,0
40013c2c:	00040513          	mv	a0,s0
40013c30:	a29fc0ef          	jal	ra,40010658 <net_if_flag_is_set>
		status = -EALREADY;
40013c34:	f8800493          	li	s1,-120
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
40013c38:	02051663          	bnez	a0,40013c64 <net_if_up+0x5c>
		goto out;
	}

	/* If the L2 does not support enable just set the flag */
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
40013c3c:	00040513          	mv	a0,s0
40013c40:	940fc0ef          	jal	ra,4000fd80 <net_if_l2>
40013c44:	02050e63          	beqz	a0,40013c80 <net_if_up+0x78>
40013c48:	00852783          	lw	a5,8(a0)
40013c4c:	02078a63          	beqz	a5,40013c80 <net_if_up+0x78>
		goto done;
	}

	/* Notify L2 to enable the interface */
	status = net_if_l2(iface)->enable(iface, true);
40013c50:	00100593          	li	a1,1
40013c54:	00040513          	mv	a0,s0
40013c58:	000780e7          	jalr	a5
40013c5c:	00050493          	mv	s1,a0
	if (status < 0) {
40013c60:	02055263          	bgez	a0,40013c84 <net_if_up+0x7c>
	net_if_flag_set(iface, NET_IF_UP);
	net_mgmt_event_notify(NET_EVENT_IF_ADMIN_UP, iface);
	update_operational_state(iface);

out:
	k_mutex_unlock(&lock);
40013c64:	b58fc0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>

	return status;
}
40013c68:	00c12083          	lw	ra,12(sp)
40013c6c:	00812403          	lw	s0,8(sp)
40013c70:	00048513          	mv	a0,s1
40013c74:	00412483          	lw	s1,4(sp)
40013c78:	01010113          	addi	sp,sp,16
40013c7c:	00008067          	ret
	int status = 0;
40013c80:	00000493          	li	s1,0
	net_if_flag_set(iface, NET_IF_UP);
40013c84:	00042503          	lw	a0,0(s0)
40013c88:	00000593          	li	a1,0
40013c8c:	d19fc0ef          	jal	ra,400109a4 <net_if_flag_set.isra.0>
40013c90:	d0010537          	lui	a0,0xd0010
40013c94:	00000693          	li	a3,0
40013c98:	00000613          	li	a2,0
40013c9c:	00040593          	mv	a1,s0
40013ca0:	00450513          	addi	a0,a0,4 # d0010004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd0010005>
40013ca4:	229010ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
	update_operational_state(iface);
40013ca8:	00040513          	mv	a0,s0
40013cac:	dc5fd0ef          	jal	ra,40011a70 <update_operational_state>
40013cb0:	fb5ff06f          	j	40013c64 <net_if_up+0x5c>

40013cb4 <net_if_down>:

int net_if_down(struct net_if *iface)
{
40013cb4:	fe010113          	addi	sp,sp,-32
40013cb8:	00812c23          	sw	s0,24(sp)
	int status = 0;

	NET_DBG("iface %p", iface);

	k_mutex_lock(&lock, K_FOREVER);
40013cbc:	fff00593          	li	a1,-1
{
40013cc0:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
40013cc4:	fff00513          	li	a0,-1
{
40013cc8:	00112e23          	sw	ra,28(sp)
40013ccc:	00912a23          	sw	s1,20(sp)
40013cd0:	01212823          	sw	s2,16(sp)
40013cd4:	01312623          	sw	s3,12(sp)
40013cd8:	01412423          	sw	s4,8(sp)
40013cdc:	01512223          	sw	s5,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
40013ce0:	ac8fc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>

	if (!net_if_flag_is_set(iface, NET_IF_UP)) {
40013ce4:	00000593          	li	a1,0
40013ce8:	00040513          	mv	a0,s0
40013cec:	96dfc0ef          	jal	ra,40010658 <net_if_flag_is_set>
		status = -EALREADY;
40013cf0:	f8800493          	li	s1,-120
	if (!net_if_flag_is_set(iface, NET_IF_UP)) {
40013cf4:	06050e63          	beqz	a0,40013d70 <net_if_down+0xbc>
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
40013cf8:	0bc42983          	lw	s3,188(s0)
	if (!ipv6) {
40013cfc:	04098663          	beqz	s3,40013d48 <net_if_down+0x94>
40013d00:	09498913          	addi	s2,s3,148
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
40013d04:	00000493          	li	s1,0
		if (!ipv6->mcast[i].is_used ||
40013d08:	01800a93          	li	s5,24
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
40013d0c:	00400a13          	li	s4,4
		if (!ipv6->mcast[i].is_used ||
40013d10:	035487b3          	mul	a5,s1,s5
40013d14:	00f987b3          	add	a5,s3,a5
40013d18:	0a47a783          	lw	a5,164(a5)
40013d1c:	0017f713          	andi	a4,a5,1
40013d20:	00070e63          	beqz	a4,40013d3c <net_if_down+0x88>
		    !ipv6->mcast[i].is_joined) {
40013d24:	0017d793          	srli	a5,a5,0x1
		if (!ipv6->mcast[i].is_used ||
40013d28:	0017f793          	andi	a5,a5,1
40013d2c:	00078863          	beqz	a5,40013d3c <net_if_down+0x88>
		net_ipv6_mld_leave(iface, &ipv6->mcast[i].address.in6_addr);
40013d30:	00090593          	mv	a1,s2
40013d34:	00040513          	mv	a0,s0
40013d38:	6e40b0ef          	jal	ra,4001f41c <net_ipv6_mld_leave>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
40013d3c:	00148493          	addi	s1,s1,1
40013d40:	01890913          	addi	s2,s2,24
40013d44:	fd4496e3          	bne	s1,s4,40013d10 <net_if_down+0x5c>

	leave_mcast_all(iface);
	leave_ipv4_mcast_all(iface);

	/* If the L2 does not support enable just clear the flag */
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
40013d48:	00040513          	mv	a0,s0
40013d4c:	834fc0ef          	jal	ra,4000fd80 <net_if_l2>
40013d50:	04050663          	beqz	a0,40013d9c <net_if_down+0xe8>
40013d54:	00852783          	lw	a5,8(a0)
40013d58:	04078263          	beqz	a5,40013d9c <net_if_down+0xe8>
		goto done;
	}

	/* Notify L2 to disable the interface */
	status = net_if_l2(iface)->enable(iface, false);
40013d5c:	00000593          	li	a1,0
40013d60:	00040513          	mv	a0,s0
40013d64:	000780e7          	jalr	a5
40013d68:	00050493          	mv	s1,a0
	if (status < 0) {
40013d6c:	02055a63          	bgez	a0,40013da0 <net_if_down+0xec>
	net_if_flag_clear(iface, NET_IF_UP);
	net_mgmt_event_notify(NET_EVENT_IF_ADMIN_DOWN, iface);
	update_operational_state(iface);

out:
	k_mutex_unlock(&lock);
40013d70:	a4cfc0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>

	return status;
}
40013d74:	01c12083          	lw	ra,28(sp)
40013d78:	01812403          	lw	s0,24(sp)
40013d7c:	01012903          	lw	s2,16(sp)
40013d80:	00c12983          	lw	s3,12(sp)
40013d84:	00812a03          	lw	s4,8(sp)
40013d88:	00412a83          	lw	s5,4(sp)
40013d8c:	00048513          	mv	a0,s1
40013d90:	01412483          	lw	s1,20(sp)
40013d94:	02010113          	addi	sp,sp,32
40013d98:	00008067          	ret
	int status = 0;
40013d9c:	00000493          	li	s1,0
	atomic_clear_bit(iface->if_dev->flags, value);
40013da0:	00042503          	lw	a0,0(s0)
40013da4:	00000593          	li	a1,0
40013da8:	00c50513          	addi	a0,a0,12
40013dac:	990fc0ef          	jal	ra,4000ff3c <atomic_clear_bit>
40013db0:	d0010537          	lui	a0,0xd0010
40013db4:	00000693          	li	a3,0
40013db8:	00000613          	li	a2,0
40013dbc:	00040593          	mv	a1,s0
40013dc0:	00350513          	addi	a0,a0,3 # d0010003 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd0010004>
40013dc4:	109010ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
	update_operational_state(iface);
40013dc8:	00040513          	mv	a0,s0
40013dcc:	ca5fd0ef          	jal	ra,40011a70 <update_operational_state>
40013dd0:	fa1ff06f          	j	40013d70 <net_if_down+0xbc>

40013dd4 <net_if_carrier_on>:

void net_if_carrier_on(struct net_if *iface)
{
40013dd4:	ff010113          	addi	sp,sp,-16
40013dd8:	00812423          	sw	s0,8(sp)
	NET_ASSERT(iface);

	k_mutex_lock(&lock, K_FOREVER);
40013ddc:	fff00593          	li	a1,-1
{
40013de0:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
40013de4:	fff00513          	li	a0,-1
{
40013de8:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
40013dec:	9bcfc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>

	if (!net_if_flag_test_and_set(iface, NET_IF_LOWER_UP)) {
40013df0:	00042503          	lw	a0,0(s0)
40013df4:	00900593          	li	a1,9
40013df8:	bbdfc0ef          	jal	ra,400109b4 <net_if_flag_test_and_set.isra.0>
40013dfc:	00051663          	bnez	a0,40013e08 <net_if_carrier_on+0x34>
		update_operational_state(iface);
40013e00:	00040513          	mv	a0,s0
40013e04:	c6dfd0ef          	jal	ra,40011a70 <update_operational_state>
	}

	k_mutex_unlock(&lock);
}
40013e08:	00812403          	lw	s0,8(sp)
40013e0c:	00c12083          	lw	ra,12(sp)
40013e10:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
40013e14:	9a8fc06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>

40013e18 <net_if_carrier_off>:

void net_if_carrier_off(struct net_if *iface)
{
40013e18:	ff010113          	addi	sp,sp,-16
40013e1c:	00812423          	sw	s0,8(sp)
	NET_ASSERT(iface);

	k_mutex_lock(&lock, K_FOREVER);
40013e20:	fff00593          	li	a1,-1
{
40013e24:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
40013e28:	fff00513          	li	a0,-1
{
40013e2c:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
40013e30:	978fc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	return atomic_test_and_clear_bit(iface->if_dev->flags, value);
40013e34:	00042503          	lw	a0,0(s0)
40013e38:	00900593          	li	a1,9
40013e3c:	00c50513          	addi	a0,a0,12
40013e40:	badfc0ef          	jal	ra,400109ec <atomic_test_and_clear_bit>

	if (net_if_flag_test_and_clear(iface, NET_IF_LOWER_UP)) {
40013e44:	00050663          	beqz	a0,40013e50 <net_if_carrier_off+0x38>
		update_operational_state(iface);
40013e48:	00040513          	mv	a0,s0
40013e4c:	c25fd0ef          	jal	ra,40011a70 <update_operational_state>
	}

	k_mutex_unlock(&lock);
}
40013e50:	00812403          	lw	s0,8(sp)
40013e54:	00c12083          	lw	ra,12(sp)
40013e58:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
40013e5c:	960fc06f          	j	4000ffbc <k_mutex_unlock.constprop.0.isra.0>

40013e60 <net_if_init>:
	k_fifo_put(&tx_ts_queue, pkt);
}
#endif /* CONFIG_NET_PKT_TIMESTAMP_THREAD */

void net_if_init(void)
{
40013e60:	fb010113          	addi	sp,sp,-80
40013e64:	04112623          	sw	ra,76(sp)
40013e68:	04812423          	sw	s0,72(sp)
40013e6c:	04912223          	sw	s1,68(sp)
40013e70:	05212023          	sw	s2,64(sp)
40013e74:	03312e23          	sw	s3,60(sp)
40013e78:	03412c23          	sw	s4,56(sp)
40013e7c:	03512a23          	sw	s5,52(sp)
40013e80:	03712623          	sw	s7,44(sp)
40013e84:	03812423          	sw	s8,40(sp)
40013e88:	05010413          	addi	s0,sp,80
40013e8c:	03612823          	sw	s6,48(sp)
	int if_count = 0;

	NET_DBG("");

	k_mutex_lock(&lock, K_FOREVER);
40013e90:	fff00513          	li	a0,-1
40013e94:	fff00593          	li	a1,-1

	net_tc_tx_init();

	STRUCT_SECTION_FOREACH(net_if, iface) {
40013e98:	400454b7          	lui	s1,0x40045
40013e9c:	400459b7          	lui	s3,0x40045
		NET_ERR("Iface %p driver API init NULL", iface);
40013ea0:	40035a37          	lui	s4,0x40035
40013ea4:	00002ab7          	lui	s5,0x2
	k_mutex_lock(&lock, K_FOREVER);
40013ea8:	900fc0ef          	jal	ra,4000ffa8 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
40013eac:	9d848493          	addi	s1,s1,-1576 # 400449d8 <__net_if_dts_ord_12_0>
	net_tc_tx_init();
40013eb0:	389040ef          	jal	ra,40018a38 <net_tc_tx_init>
	int if_count = 0;
40013eb4:	00000913          	li	s2,0
	STRUCT_SECTION_FOREACH(net_if, iface) {
40013eb8:	a9c98993          	addi	s3,s3,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
		NET_ERR("Iface %p driver API init NULL", iface);
40013ebc:	40044bb7          	lui	s7,0x40044
40013ec0:	b1ca0a13          	addi	s4,s4,-1252 # 40034b1c <net_buf_fixed_cb+0x1bc>
40013ec4:	00300c13          	li	s8,3
40013ec8:	840a8a93          	addi	s5,s5,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
	STRUCT_SECTION_FOREACH(net_if, iface) {
40013ecc:	0734ec63          	bltu	s1,s3,40013f44 <net_if_init+0xe4>
		init_iface(iface);
		if_count++;
	}

	if (if_count == 0) {
40013ed0:	10091063          	bnez	s2,40013fd0 <net_if_init+0x170>
		NET_ERR("There is no network interface to work with!");
40013ed4:	40044537          	lui	a0,0x40044
40013ed8:	77452783          	lw	a5,1908(a0) # 40044774 <log_dynamic_net_if>
40013edc:	0077f793          	andi	a5,a5,7
40013ee0:	02078663          	beqz	a5,40013f0c <net_if_init+0xac>
40013ee4:	400357b7          	lui	a5,0x40035
40013ee8:	b3c78793          	addi	a5,a5,-1220 # 40034b3c <net_buf_fixed_cb+0x1dc>
40013eec:	fcf42623          	sw	a5,-52(s0)
40013ef0:	000015b7          	lui	a1,0x1
40013ef4:	00200793          	li	a5,2
40013ef8:	fcf42423          	sw	a5,-56(s0)
40013efc:	fc840613          	addi	a2,s0,-56
40013f00:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
40013f04:	77450513          	addi	a0,a0,1908
40013f08:	898fc0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
			 CONFIG_NET_VLAN_COUNT, if_count);
	}
#endif

out:
	k_mutex_unlock(&lock);
40013f0c:	8b0fc0ef          	jal	ra,4000ffbc <k_mutex_unlock.constprop.0.isra.0>
}
40013f10:	fb040113          	addi	sp,s0,-80
40013f14:	04c12083          	lw	ra,76(sp)
40013f18:	04812403          	lw	s0,72(sp)
40013f1c:	04412483          	lw	s1,68(sp)
40013f20:	04012903          	lw	s2,64(sp)
40013f24:	03c12983          	lw	s3,60(sp)
40013f28:	03812a03          	lw	s4,56(sp)
40013f2c:	03412a83          	lw	s5,52(sp)
40013f30:	03012b03          	lw	s6,48(sp)
40013f34:	02c12b83          	lw	s7,44(sp)
40013f38:	02812c03          	lw	s8,40(sp)
40013f3c:	05010113          	addi	sp,sp,80
40013f40:	00008067          	ret
	return iface->if_dev->dev;
40013f44:	0004a503          	lw	a0,0(s1)
	const struct net_if_api *api = net_if_get_device(iface)->api;
40013f48:	00052783          	lw	a5,0(a0)
40013f4c:	0087ab03          	lw	s6,8(a5)
	if (!api || !api->init) {
40013f50:	000b0663          	beqz	s6,40013f5c <net_if_init+0xfc>
40013f54:	000b2783          	lw	a5,0(s6)
40013f58:	04079463          	bnez	a5,40013fa0 <net_if_init+0x140>
		NET_ERR("Iface %p driver API init NULL", iface);
40013f5c:	774ba783          	lw	a5,1908(s7) # 40044774 <log_dynamic_net_if>
40013f60:	0077f793          	andi	a5,a5,7
40013f64:	02078863          	beqz	a5,40013f94 <net_if_init+0x134>
40013f68:	00010b13          	mv	s6,sp
40013f6c:	fe010113          	addi	sp,sp,-32
40013f70:	00010613          	mv	a2,sp
40013f74:	01462a23          	sw	s4,20(a2)
40013f78:	00962c23          	sw	s1,24(a2)
40013f7c:	01862823          	sw	s8,16(a2)
40013f80:	000a8593          	mv	a1,s5
40013f84:	01060613          	addi	a2,a2,16
40013f88:	774b8513          	addi	a0,s7,1908
40013f8c:	814fc0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
40013f90:	000b0113          	mv	sp,s6
		if_count++;
40013f94:	00190913          	addi	s2,s2,1
	STRUCT_SECTION_FOREACH(net_if, iface) {
40013f98:	0c448493          	addi	s1,s1,196
40013f9c:	f31ff06f          	j	40013ecc <net_if_init+0x6c>
	net_if_flag_set(iface, NET_IF_IPV4);
40013fa0:	00600593          	li	a1,6
40013fa4:	a01fc0ef          	jal	ra,400109a4 <net_if_flag_set.isra.0>
	net_if_flag_set(iface, NET_IF_IPV6);
40013fa8:	0004a503          	lw	a0,0(s1)
40013fac:	00700593          	li	a1,7
40013fb0:	9f5fc0ef          	jal	ra,400109a4 <net_if_flag_set.isra.0>
	net_if_flag_test_and_set(iface, NET_IF_LOWER_UP);
40013fb4:	0004a503          	lw	a0,0(s1)
40013fb8:	00900593          	li	a1,9
40013fbc:	9f9fc0ef          	jal	ra,400109b4 <net_if_flag_test_and_set.isra.0>
	api->init(iface);
40013fc0:	000b2783          	lw	a5,0(s6)
40013fc4:	00048513          	mv	a0,s1
40013fc8:	000780e7          	jalr	a5
40013fcc:	fc9ff06f          	j	40013f94 <net_if_init+0x134>
	k_work_init_delayable(&dad_timer, dad_timeout);
40013fd0:	400115b7          	lui	a1,0x40011
40013fd4:	4003a537          	lui	a0,0x4003a
40013fd8:	1c858593          	addi	a1,a1,456 # 400111c8 <dad_timeout>
40013fdc:	97050513          	addi	a0,a0,-1680 # 40039970 <dad_timer>
40013fe0:	0241c0ef          	jal	ra,40030004 <k_work_init_delayable>
	list->head = NULL;
40013fe4:	400397b7          	lui	a5,0x40039
	k_work_init_delayable(&rs_timer, rs_timeout);
40013fe8:	400115b7          	lui	a1,0x40011
40013fec:	4003a537          	lui	a0,0x4003a
40013ff0:	05078793          	addi	a5,a5,80 # 40039050 <active_dad_timers>
40013ff4:	f3858593          	addi	a1,a1,-200 # 40010f38 <rs_timeout>
40013ff8:	94050513          	addi	a0,a0,-1728 # 40039940 <rs_timer>
40013ffc:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
40014000:	0007a223          	sw	zero,4(a5)
40014004:	0001c0ef          	jal	ra,40030004 <k_work_init_delayable>
	list->head = NULL;
40014008:	400397b7          	lui	a5,0x40039
	k_work_init_delayable(&address_lifetime_timer,
4001400c:	400105b7          	lui	a1,0x40010
40014010:	4003a537          	lui	a0,0x4003a
40014014:	04878793          	addi	a5,a5,72 # 40039048 <active_rs_timers>
40014018:	47058593          	addi	a1,a1,1136 # 40010470 <address_lifetime_timeout>
4001401c:	9d050513          	addi	a0,a0,-1584 # 400399d0 <address_lifetime_timer>
40014020:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
40014024:	0007a223          	sw	zero,4(a5)
40014028:	7dd1b0ef          	jal	ra,40030004 <k_work_init_delayable>
	k_work_init_delayable(&prefix_lifetime_timer, prefix_lifetime_timeout);
4001402c:	400125b7          	lui	a1,0x40012
40014030:	4003a537          	lui	a0,0x4003a
40014034:	06c58593          	addi	a1,a1,108 # 4001206c <prefix_lifetime_timeout>
40014038:	9a050513          	addi	a0,a0,-1632 # 400399a0 <prefix_lifetime_timer>
4001403c:	7c91b0ef          	jal	ra,40030004 <k_work_init_delayable>
	if (if_count > ARRAY_SIZE(ipv6_addresses)) {
40014040:	4003aa37          	lui	s4,0x4003a
40014044:	00100713          	li	a4,1
40014048:	554a0993          	addi	s3,s4,1364 # 4003a554 <ipv6_addresses>
4001404c:	04e91c63          	bne	s2,a4,400140a4 <net_if_init+0x244>
		ipv6_addresses[i].ipv6.hop_limit = CONFIG_NET_INITIAL_HOP_LIMIT;
40014050:	04000793          	li	a5,64
40014054:	14f98aa3          	sb	a5,341(s3)
		ipv6_addresses[i].ipv6.base_reachable_time = REACHABLE_TIME;
40014058:	000077b7          	lui	a5,0x7
4001405c:	53078793          	addi	a5,a5,1328 # 7530 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3530>
	ipv6->reachable_time = net_if_ipv6_calc_reachable_time(ipv6);
40014060:	554a0513          	addi	a0,s4,1364
40014064:	14f9a023          	sw	a5,320(s3)
40014068:	db5fe0ef          	jal	ra,40012e1c <net_if_ipv6_calc_reachable_time>
4001406c:	14a9a223          	sw	a0,324(s3)
	k_work_init_delayable(&router_timer, iface_router_expired);
40014070:	400115b7          	lui	a1,0x40011
40014074:	4003a537          	lui	a0,0x4003a
		ipv4_addresses[i].ipv4.ttl = CONFIG_NET_INITIAL_TTL;
40014078:	4003a7b7          	lui	a5,0x4003a
4001407c:	04000713          	li	a4,64
	k_work_init_delayable(&router_timer, iface_router_expired);
40014080:	a2c58593          	addi	a1,a1,-1492 # 40010a2c <iface_router_expired>
40014084:	a0050513          	addi	a0,a0,-1536 # 40039a00 <router_timer>
		ipv4_addresses[i].ipv4.ttl = CONFIG_NET_INITIAL_TTL;
40014088:	54e78623          	sb	a4,1356(a5) # 4003a54c <ipv4_addresses+0x50>
	k_work_init_delayable(&router_timer, iface_router_expired);
4001408c:	7791b0ef          	jal	ra,40030004 <k_work_init_delayable>
	list->head = NULL;
40014090:	400397b7          	lui	a5,0x40039
40014094:	06878793          	addi	a5,a5,104 # 40039068 <active_router_timers>
40014098:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
4001409c:	0007a223          	sw	zero,4(a5)
}
400140a0:	e6dff06f          	j	40013f0c <net_if_init+0xac>
		NET_WARN("You have %zu IPv6 net_if addresses but %d "
400140a4:	400444b7          	lui	s1,0x40044
400140a8:	7744a783          	lw	a5,1908(s1) # 40044774 <log_dynamic_net_if>
400140ac:	0067f793          	andi	a5,a5,6
400140b0:	06078c63          	beqz	a5,40014128 <net_if_init+0x2c8>
400140b4:	00010a93          	mv	s5,sp
400140b8:	fe010113          	addi	sp,sp,-32
400140bc:	00010613          	mv	a2,sp
400140c0:	400357b7          	lui	a5,0x40035
400140c4:	b6878793          	addi	a5,a5,-1176 # 40034b68 <net_buf_fixed_cb+0x208>
400140c8:	00f62a23          	sw	a5,20(a2)
400140cc:	000025b7          	lui	a1,0x2
400140d0:	00400793          	li	a5,4
400140d4:	00f62823          	sw	a5,16(a2)
400140d8:	00e62c23          	sw	a4,24(a2)
400140dc:	01262e23          	sw	s2,28(a2)
400140e0:	08058593          	addi	a1,a1,128 # 2080 <CONFIG_SRAM_SIZE+0x80>
400140e4:	01060613          	addi	a2,a2,16
400140e8:	77448513          	addi	a0,s1,1908
400140ec:	eb5fb0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
		NET_WARN("Consider increasing CONFIG_NET_IF_MAX_IPV6_COUNT "
400140f0:	7744a783          	lw	a5,1908(s1)
400140f4:	000a8113          	mv	sp,s5
400140f8:	0067f793          	andi	a5,a5,6
400140fc:	02078663          	beqz	a5,40014128 <net_if_init+0x2c8>
40014100:	400357b7          	lui	a5,0x40035
40014104:	ba878793          	addi	a5,a5,-1112 # 40034ba8 <net_buf_fixed_cb+0x248>
40014108:	fcf42623          	sw	a5,-52(s0)
4001410c:	000015b7          	lui	a1,0x1
40014110:	00200793          	li	a5,2
40014114:	fcf42423          	sw	a5,-56(s0)
40014118:	fc840613          	addi	a2,s0,-56
4001411c:	08058593          	addi	a1,a1,128 # 1080 <CONFIG_HEAP_MEM_POOL_SIZE+0x80>
40014120:	77448513          	addi	a0,s1,1908
40014124:	e7dfb0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
		ipv6_addresses[i].ipv6.hop_limit = CONFIG_NET_INITIAL_HOP_LIMIT;
40014128:	04000793          	li	a5,64
4001412c:	14f98aa3          	sb	a5,341(s3)
		ipv6_addresses[i].ipv6.base_reachable_time = REACHABLE_TIME;
40014130:	000077b7          	lui	a5,0x7
40014134:	53078793          	addi	a5,a5,1328 # 7530 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3530>
40014138:	554a0513          	addi	a0,s4,1364
4001413c:	14f9a023          	sw	a5,320(s3)
40014140:	cddfe0ef          	jal	ra,40012e1c <net_if_ipv6_calc_reachable_time>
		NET_WARN("You have %zu IPv4 net_if addresses but %d "
40014144:	7744a783          	lw	a5,1908(s1)
40014148:	14a9a223          	sw	a0,324(s3)
4001414c:	0067f793          	andi	a5,a5,6
40014150:	f20780e3          	beqz	a5,40014070 <net_if_init+0x210>
40014154:	00010993          	mv	s3,sp
40014158:	fe010113          	addi	sp,sp,-32
4001415c:	00010613          	mv	a2,sp
40014160:	400357b7          	lui	a5,0x40035
40014164:	be078793          	addi	a5,a5,-1056 # 40034be0 <net_buf_fixed_cb+0x280>
40014168:	00f62a23          	sw	a5,20(a2)
4001416c:	00100793          	li	a5,1
40014170:	00f62c23          	sw	a5,24(a2)
40014174:	000025b7          	lui	a1,0x2
40014178:	00400793          	li	a5,4
4001417c:	00f62823          	sw	a5,16(a2)
40014180:	01262e23          	sw	s2,28(a2)
40014184:	08058593          	addi	a1,a1,128 # 2080 <CONFIG_SRAM_SIZE+0x80>
40014188:	01060613          	addi	a2,a2,16
4001418c:	77448513          	addi	a0,s1,1908
40014190:	e11fb0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
		NET_WARN("Consider increasing CONFIG_NET_IF_MAX_IPV4_COUNT "
40014194:	7744a783          	lw	a5,1908(s1)
40014198:	00098113          	mv	sp,s3
4001419c:	0067f793          	andi	a5,a5,6
400141a0:	ec0788e3          	beqz	a5,40014070 <net_if_init+0x210>
400141a4:	400357b7          	lui	a5,0x40035
400141a8:	c2078793          	addi	a5,a5,-992 # 40034c20 <net_buf_fixed_cb+0x2c0>
400141ac:	fcf42623          	sw	a5,-52(s0)
400141b0:	000015b7          	lui	a1,0x1
400141b4:	00200793          	li	a5,2
400141b8:	fcf42423          	sw	a5,-56(s0)
400141bc:	fc840613          	addi	a2,s0,-56
400141c0:	08058593          	addi	a1,a1,128 # 1080 <CONFIG_HEAP_MEM_POOL_SIZE+0x80>
400141c4:	77448513          	addi	a0,s1,1908
400141c8:	dd9fb0ef          	jal	ra,4000ffa0 <z_log_msg_static_create.constprop.0>
400141cc:	ea5ff06f          	j	40014070 <net_if_init+0x210>

400141d0 <net_if_post_init>:

void net_if_post_init(void)
{
400141d0:	ff010113          	addi	sp,sp,-16
400141d4:	00812423          	sw	s0,8(sp)
400141d8:	00912223          	sw	s1,4(sp)
	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	STRUCT_SECTION_FOREACH(net_if, iface) {
400141dc:	40045437          	lui	s0,0x40045
400141e0:	400454b7          	lui	s1,0x40045
{
400141e4:	00112623          	sw	ra,12(sp)
	STRUCT_SECTION_FOREACH(net_if, iface) {
400141e8:	9d840413          	addi	s0,s0,-1576 # 400449d8 <__net_if_dts_ord_12_0>
400141ec:	a9c48493          	addi	s1,s1,-1380 # 40044a9c <__net_if_dev_dts_ord_12_0>
400141f0:	00946c63          	bltu	s0,s1,40014208 <net_if_post_init+0x38>
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
			net_if_up(iface);
		}
	}
}
400141f4:	00c12083          	lw	ra,12(sp)
400141f8:	00812403          	lw	s0,8(sp)
400141fc:	00412483          	lw	s1,4(sp)
40014200:	01010113          	addi	sp,sp,16
40014204:	00008067          	ret
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
40014208:	00300593          	li	a1,3
4001420c:	00040513          	mv	a0,s0
40014210:	c48fc0ef          	jal	ra,40010658 <net_if_flag_is_set>
40014214:	00051663          	bnez	a0,40014220 <net_if_post_init+0x50>
			net_if_up(iface);
40014218:	00040513          	mv	a0,s0
4001421c:	9edff0ef          	jal	ra,40013c08 <net_if_up>
	STRUCT_SECTION_FOREACH(net_if, iface) {
40014220:	0c440413          	addi	s0,s0,196
40014224:	fcdff06f          	j	400141f0 <net_if_post_init+0x20>

40014228 <net_timeout_set>:
#include <zephyr/sys_clock.h>

void net_timeout_set(struct net_timeout *timeout,
		     uint32_t lifetime,
		     uint32_t now)
{
40014228:	ff010113          	addi	sp,sp,-16
4001422c:	00812423          	sw	s0,8(sp)
40014230:	00112623          	sw	ra,12(sp)
40014234:	00912223          	sw	s1,4(sp)
	uint64_t expire_timeout;

	timeout->timer_start = now;
40014238:	00c52223          	sw	a2,4(a0)
{
4001423c:	00050413          	mv	s0,a0

	/* Highly unlikely, but a zero timeout isn't correctly handled by the
	 * standard calculation.
	 */
	if (lifetime == 0U) {
40014240:	02059063          	bnez	a1,40014260 <net_timeout_set+0x38>
		timeout->wrap_counter = 0;
40014244:	00052623          	sw	zero,12(a0)
		timeout->timer_timeout = 0;
40014248:	00052423          	sw	zero,8(a0)
	 */
	if (timeout->timer_timeout == 0U) {
		timeout->timer_timeout = NET_TIMEOUT_MAX_VALUE;
		timeout->wrap_counter -= 1;
	}
}
4001424c:	00c12083          	lw	ra,12(sp)
40014250:	00812403          	lw	s0,8(sp)
40014254:	00412483          	lw	s1,4(sp)
40014258:	01010113          	addi	sp,sp,16
4001425c:	00008067          	ret
	expire_timeout = (uint64_t)MSEC_PER_SEC * (uint64_t)lifetime;
40014260:	3e800793          	li	a5,1000
40014264:	02f584b3          	mul	s1,a1,a5
	timeout->wrap_counter = expire_timeout /
40014268:	80000637          	lui	a2,0x80000
4001426c:	00000693          	li	a3,0
40014270:	fff60613          	addi	a2,a2,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	expire_timeout = (uint64_t)MSEC_PER_SEC * (uint64_t)lifetime;
40014274:	02f5b5b3          	mulhu	a1,a1,a5
	timeout->wrap_counter = expire_timeout /
40014278:	00048513          	mv	a0,s1
4001427c:	83cec0ef          	jal	ra,400002b8 <__udivdi3>
		(uint64_t)NET_TIMEOUT_MAX_VALUE *
40014280:	800007b7          	lui	a5,0x80000
40014284:	fff78793          	addi	a5,a5,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
40014288:	02f50733          	mul	a4,a0,a5
	timeout->wrap_counter = expire_timeout /
4001428c:	00a42623          	sw	a0,12(s0)
	timeout->timer_timeout = expire_timeout -
40014290:	40e486b3          	sub	a3,s1,a4
	if (timeout->timer_timeout == 0U) {
40014294:	00e48663          	beq	s1,a4,400142a0 <net_timeout_set+0x78>
	timeout->timer_timeout = expire_timeout -
40014298:	00d42423          	sw	a3,8(s0)
4001429c:	fb1ff06f          	j	4001424c <net_timeout_set+0x24>
		timeout->wrap_counter -= 1;
400142a0:	fff50513          	addi	a0,a0,-1
		timeout->timer_timeout = NET_TIMEOUT_MAX_VALUE;
400142a4:	00f42423          	sw	a5,8(s0)
		timeout->wrap_counter -= 1;
400142a8:	00a42623          	sw	a0,12(s0)
400142ac:	fa1ff06f          	j	4001424c <net_timeout_set+0x24>

400142b0 <net_timeout_remaining>:
uint32_t net_timeout_remaining(const struct net_timeout *timeout,
			       uint32_t now)
{
	int64_t ret = timeout->timer_timeout;

	ret += timeout->wrap_counter * (uint64_t)NET_TIMEOUT_MAX_VALUE;
400142b0:	00c52783          	lw	a5,12(a0)
400142b4:	01f79713          	slli	a4,a5,0x1f
400142b8:	0017d693          	srli	a3,a5,0x1
400142bc:	40f707b3          	sub	a5,a4,a5
400142c0:	00f73733          	sltu	a4,a4,a5
400142c4:	40e686b3          	sub	a3,a3,a4
400142c8:	00852703          	lw	a4,8(a0)
400142cc:	00e78733          	add	a4,a5,a4
400142d0:	00f737b3          	sltu	a5,a4,a5
400142d4:	00d787b3          	add	a5,a5,a3
	ret -= (int64_t)(int32_t)(now - timeout->timer_start);
400142d8:	00452683          	lw	a3,4(a0)
400142dc:	40d58533          	sub	a0,a1,a3
400142e0:	41f55693          	srai	a3,a0,0x1f
400142e4:	40a70533          	sub	a0,a4,a0
400142e8:	00a73733          	sltu	a4,a4,a0
400142ec:	40d785b3          	sub	a1,a5,a3
400142f0:	40e585b3          	sub	a1,a1,a4
	if (ret <= 0) {
400142f4:	00b04663          	bgtz	a1,40014300 <net_timeout_remaining+0x50>
400142f8:	02059463          	bnez	a1,40014320 <net_timeout_remaining+0x70>
400142fc:	02050263          	beqz	a0,40014320 <net_timeout_remaining+0x70>
{
40014300:	ff010113          	addi	sp,sp,-16
		return 0;
	}

	return (uint32_t)((uint64_t)ret / MSEC_PER_SEC);
40014304:	3e800613          	li	a2,1000
40014308:	00000693          	li	a3,0
{
4001430c:	00112623          	sw	ra,12(sp)
	return (uint32_t)((uint64_t)ret / MSEC_PER_SEC);
40014310:	fa9eb0ef          	jal	ra,400002b8 <__udivdi3>
}
40014314:	00c12083          	lw	ra,12(sp)
40014318:	01010113          	addi	sp,sp,16
4001431c:	00008067          	ret
		return 0;
40014320:	00000513          	li	a0,0
}
40014324:	00008067          	ret

40014328 <net_timeout_evaluate>:

	/* Time since last evaluation or set. */
	elapsed = now - timeout->timer_start;

	/* The delay used the last time this was evaluated. */
	wraps = (timeout->wrap_counter > 0U);
40014328:	00c52603          	lw	a2,12(a0)
	elapsed = now - timeout->timer_start;
4001432c:	00452683          	lw	a3,4(a0)
{
40014330:	00050793          	mv	a5,a0
	last_delay = wraps
		? NET_TIMEOUT_MAX_VALUE
		: timeout->timer_timeout;
40014334:	00060e63          	beqz	a2,40014350 <net_timeout_evaluate+0x28>

	/* Time remaining until completion of the last delay. */
	remains = (int32_t)(last_delay - elapsed);
40014338:	80000837          	lui	a6,0x80000
4001433c:	fff80813          	addi	a6,a6,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
40014340:	40b80533          	sub	a0,a6,a1
40014344:	00d50533          	add	a0,a0,a3

	/* If the deadline for the next event hasn't been reached yet just
	 * return the remaining time.
	 */
	if (remains > 0) {
40014348:	02a05063          	blez	a0,40014368 <net_timeout_evaluate+0x40>
4001434c:	00008067          	ret
	remains = (int32_t)(last_delay - elapsed);
40014350:	00852783          	lw	a5,8(a0)
40014354:	00f686b3          	add	a3,a3,a5
40014358:	40b68533          	sub	a0,a3,a1
	if (remains > 0) {
4001435c:	06a04263          	bgtz	a0,400143c0 <net_timeout_evaluate+0x98>
	/* Deadline has been reached.  If we're not wrapping we've completed
	 * the last portion of the full timeout, so return zero to indicate
	 * the timeout has completed.
	 */
	if (!wraps) {
		return 0U;
40014360:	00000513          	li	a0,0
40014364:	00008067          	ret
	 * that's at least NET_TIMEOUT_MAX_VALUE, and can apply the
	 * reduction by decrementing the wrap count.
	 */
	timeout->timer_start = now;
	elapsed -= NET_TIMEOUT_MAX_VALUE;
	timeout->wrap_counter -= 1;
40014368:	fff60713          	addi	a4,a2,-1
4001436c:	00e7a623          	sw	a4,12(a5)
	 * NET_TIMEOUT_MAX_VALUE.  But if subtracting would reduce the
	 * counter to zero or go negative we need to reduce the the wrap
	 * counter once more and add the residual to the counter, so the
	 * counter remains positive.
	 */
	if (timeout->timer_timeout > elapsed) {
40014370:	0087a703          	lw	a4,8(a5)
40014374:	41058533          	sub	a0,a1,a6
	timeout->timer_start = now;
40014378:	00b7a223          	sw	a1,4(a5)
	if (timeout->timer_timeout > elapsed) {
4001437c:	40a685b3          	sub	a1,a3,a0
	elapsed -= NET_TIMEOUT_MAX_VALUE;
40014380:	40d50533          	sub	a0,a0,a3
	if (timeout->timer_timeout > elapsed) {
40014384:	00e57e63          	bgeu	a0,a4,400143a0 <net_timeout_evaluate+0x78>
		timeout->timer_timeout -= elapsed;
40014388:	00e585b3          	add	a1,a1,a4
4001438c:	00b7a423          	sw	a1,8(a5)
		timeout->wrap_counter -= 1U;
	}

	return (timeout->wrap_counter == 0U)
		? timeout->timer_timeout
		: NET_TIMEOUT_MAX_VALUE;
40014390:	00c7a703          	lw	a4,12(a5)
40014394:	02071263          	bnez	a4,400143b8 <net_timeout_evaluate+0x90>
40014398:	0087a503          	lw	a0,8(a5)
4001439c:	00008067          	ret
		timeout->timer_timeout += NET_TIMEOUT_MAX_VALUE - elapsed;
400143a0:	01070733          	add	a4,a4,a6
400143a4:	00b70733          	add	a4,a4,a1
		timeout->wrap_counter -= 1U;
400143a8:	ffe60613          	addi	a2,a2,-2
		timeout->timer_timeout += NET_TIMEOUT_MAX_VALUE - elapsed;
400143ac:	00e7a423          	sw	a4,8(a5)
		timeout->wrap_counter -= 1U;
400143b0:	00c7a623          	sw	a2,12(a5)
400143b4:	fddff06f          	j	40014390 <net_timeout_evaluate+0x68>
		: NET_TIMEOUT_MAX_VALUE;
400143b8:	80000537          	lui	a0,0x80000
400143bc:	fff50513          	addi	a0,a0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
}
400143c0:	00008067          	ret

400143c4 <convert_port>:
}
#endif /* CONFIG_NET_IPV4_IGMP */

#if defined(CONFIG_NET_IP)
static bool convert_port(const char *buf, uint16_t *port)
{
400143c4:	fe010113          	addi	sp,sp,-32
400143c8:	00912a23          	sw	s1,20(sp)
	unsigned long tmp;
	char *endptr;

	tmp = strtoul(buf, &endptr, 10);
400143cc:	00a00613          	li	a2,10
{
400143d0:	00058493          	mv	s1,a1
	tmp = strtoul(buf, &endptr, 10);
400143d4:	00c10593          	addi	a1,sp,12
{
400143d8:	00812c23          	sw	s0,24(sp)
400143dc:	00112e23          	sw	ra,28(sp)
400143e0:	00050413          	mv	s0,a0
	tmp = strtoul(buf, &endptr, 10);
400143e4:	d34f80ef          	jal	ra,4000c918 <strtoul>
	if ((endptr == buf && tmp == 0) ||
400143e8:	00c12703          	lw	a4,12(sp)
	tmp = strtoul(buf, &endptr, 10);
400143ec:	00050793          	mv	a5,a0
	if ((endptr == buf && tmp == 0) ||
400143f0:	00871663          	bne	a4,s0,400143fc <convert_port+0x38>
	    !(*buf != '\0' && *endptr == '\0') ||
	    ((unsigned long)(unsigned short)tmp != tmp)) {
		return false;
400143f4:	00000513          	li	a0,0
	if ((endptr == buf && tmp == 0) ||
400143f8:	02078463          	beqz	a5,40014420 <convert_port+0x5c>
400143fc:	00044683          	lbu	a3,0(s0)
		return false;
40014400:	00000513          	li	a0,0
	if ((endptr == buf && tmp == 0) ||
40014404:	00068e63          	beqz	a3,40014420 <convert_port+0x5c>
	    !(*buf != '\0' && *endptr == '\0') ||
40014408:	00074703          	lbu	a4,0(a4)
4001440c:	00071a63          	bnez	a4,40014420 <convert_port+0x5c>
40014410:	00010737          	lui	a4,0x10
40014414:	00e7f663          	bgeu	a5,a4,40014420 <convert_port+0x5c>
	    ((unsigned long)(unsigned short)tmp != tmp)) {
40014418:	00f49023          	sh	a5,0(s1)
	}

	*port = tmp;

	return true;
4001441c:	00100513          	li	a0,1
}
40014420:	01c12083          	lw	ra,28(sp)
40014424:	01812403          	lw	s0,24(sp)
40014428:	01412483          	lw	s1,20(sp)
4001442c:	02010113          	addi	sp,sp,32
40014430:	00008067          	ret

40014434 <net_byte_to_hex>:
{
40014434:	00050793          	mv	a5,a0
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
40014438:	0045d713          	srli	a4,a1,0x4
		if (i == 0 && !pad && !val) {
4001443c:	04068863          	beqz	a3,4001448c <net_byte_to_hex+0x58>
		if (val < 10) {
40014440:	00900513          	li	a0,9
			*ptr++ = (char) (val + '0');
40014444:	03070693          	addi	a3,a4,48 # 10030 <__kernel_ram_size+0x4528>
		if (val < 10) {
40014448:	00e57863          	bgeu	a0,a4,40014458 <net_byte_to_hex+0x24>
			*ptr++ = (char) (val - 10 + base);
4001444c:	ff660693          	addi	a3,a2,-10
40014450:	00d70733          	add	a4,a4,a3
40014454:	0ff77693          	zext.b	a3,a4
40014458:	00d78023          	sb	a3,0(a5)
4001445c:	00178793          	addi	a5,a5,1
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
40014460:	00f5f593          	andi	a1,a1,15
		if (val < 10) {
40014464:	00900693          	li	a3,9
			*ptr++ = (char) (val - 10 + base);
40014468:	00178513          	addi	a0,a5,1
			*ptr++ = (char) (val + '0');
4001446c:	03058713          	addi	a4,a1,48
		if (val < 10) {
40014470:	00b6f863          	bgeu	a3,a1,40014480 <net_byte_to_hex+0x4c>
			*ptr++ = (char) (val - 10 + base);
40014474:	ff660613          	addi	a2,a2,-10
40014478:	00c585b3          	add	a1,a1,a2
4001447c:	0ff5f713          	zext.b	a4,a1
40014480:	00e78023          	sb	a4,0(a5)
	*ptr = '\0';
40014484:	000780a3          	sb	zero,1(a5)
}
40014488:	00008067          	ret
		if (i == 0 && !pad && !val) {
4001448c:	fa071ae3          	bnez	a4,40014440 <net_byte_to_hex+0xc>
40014490:	fd1ff06f          	j	40014460 <net_byte_to_hex+0x2c>

40014494 <net_sprint_ll_addr_buf>:
	if (ll == NULL) {
40014494:	0c050a63          	beqz	a0,40014568 <net_sprint_ll_addr_buf+0xd4>
{
40014498:	fe010113          	addi	sp,sp,-32
4001449c:	00812c23          	sw	s0,24(sp)
400144a0:	01212823          	sw	s2,16(sp)
400144a4:	01312623          	sw	s3,12(sp)
400144a8:	01412423          	sw	s4,8(sp)
400144ac:	00112e23          	sw	ra,28(sp)
400144b0:	00912a23          	sw	s1,20(sp)
400144b4:	01512223          	sw	s5,4(sp)
400144b8:	01612023          	sw	s6,0(sp)
	switch (ll_len) {
400144bc:	00200793          	li	a5,2
400144c0:	00050a13          	mv	s4,a0
400144c4:	00058993          	mv	s3,a1
400144c8:	00060413          	mv	s0,a2
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
400144cc:	0ff6f913          	zext.b	s2,a3
	switch (ll_len) {
400144d0:	00f58863          	beq	a1,a5,400144e0 <net_sprint_ll_addr_buf+0x4c>
400144d4:	00800793          	li	a5,8
400144d8:	00f58463          	beq	a1,a5,400144e0 <net_sprint_ll_addr_buf+0x4c>
		len = 6U;
400144dc:	00600993          	li	s3,6
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
400144e0:	00040513          	mv	a0,s0
400144e4:	00000493          	li	s1,0
400144e8:	04090a63          	beqz	s2,4001453c <net_sprint_ll_addr_buf+0xa8>
		*ptr++ = ':';
400144ec:	03a00b13          	li	s6,58
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
400144f0:	00300a93          	li	s5,3
		ptr = net_byte_to_hex(ptr, (char)ll[i], 'A', true);
400144f4:	009a07b3          	add	a5,s4,s1
400144f8:	0007c583          	lbu	a1,0(a5)
400144fc:	00100693          	li	a3,1
40014500:	04100613          	li	a2,65
40014504:	f31ff0ef          	jal	ra,40014434 <net_byte_to_hex>
40014508:	00050793          	mv	a5,a0
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
4001450c:	00148493          	addi	s1,s1,1
		*ptr++ = ':';
40014510:	01678023          	sb	s6,0(a5)
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
40014514:	0ff4f713          	zext.b	a4,s1
		*ptr++ = ':';
40014518:	00150513          	addi	a0,a0,1
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
4001451c:	01377863          	bgeu	a4,s3,4001452c <net_sprint_ll_addr_buf+0x98>
40014520:	03548733          	mul	a4,s1,s5
40014524:	0ff77713          	zext.b	a4,a4
40014528:	fce916e3          	bne	s2,a4,400144f4 <net_sprint_ll_addr_buf+0x60>
	if (!(ptr - buf)) {
4001452c:	00a40863          	beq	s0,a0,4001453c <net_sprint_ll_addr_buf+0xa8>
	*(ptr - 1) = '\0';
40014530:	00078023          	sb	zero,0(a5)
	return buf;
40014534:	00040513          	mv	a0,s0
40014538:	0080006f          	j	40014540 <net_sprint_ll_addr_buf+0xac>
		return NULL;
4001453c:	00000513          	li	a0,0
}
40014540:	01c12083          	lw	ra,28(sp)
40014544:	01812403          	lw	s0,24(sp)
40014548:	01412483          	lw	s1,20(sp)
4001454c:	01012903          	lw	s2,16(sp)
40014550:	00c12983          	lw	s3,12(sp)
40014554:	00812a03          	lw	s4,8(sp)
40014558:	00412a83          	lw	s5,4(sp)
4001455c:	00012b03          	lw	s6,0(sp)
40014560:	02010113          	addi	sp,sp,32
40014564:	00008067          	ret
		return "<unknown>";
40014568:	40035537          	lui	a0,0x40035
4001456c:	c6050513          	addi	a0,a0,-928 # 40034c60 <net_buf_fixed_cb+0x300>
}
40014570:	00008067          	ret

40014574 <z_impl_net_addr_ntop>:
{
40014574:	fa010113          	addi	sp,sp,-96
40014578:	04812c23          	sw	s0,88(sp)
4001457c:	05212823          	sw	s2,80(sp)
40014580:	05312623          	sw	s3,76(sp)
40014584:	04112e23          	sw	ra,92(sp)
40014588:	04912a23          	sw	s1,84(sp)
4001458c:	05412423          	sw	s4,72(sp)
40014590:	05512223          	sw	s5,68(sp)
40014594:	05612023          	sw	s6,64(sp)
40014598:	03712e23          	sw	s7,60(sp)
4001459c:	03812c23          	sw	s8,56(sp)
400145a0:	03912a23          	sw	s9,52(sp)
400145a4:	03a12823          	sw	s10,48(sp)
400145a8:	03b12623          	sw	s11,44(sp)
	unsigned char zeros[8] = { 0 };
400145ac:	00012c23          	sw	zero,24(sp)
400145b0:	00012e23          	sw	zero,28(sp)
	if (family == AF_INET6) {
400145b4:	00200793          	li	a5,2
{
400145b8:	00050913          	mv	s2,a0
400145bc:	00058993          	mv	s3,a1
400145c0:	00060413          	mv	s0,a2
	if (family == AF_INET6) {
400145c4:	0af51463          	bne	a0,a5,4001466c <z_impl_net_addr_ntop+0xf8>
		w = (uint16_t *)addr6->s6_addr16;
400145c8:	01810793          	addi	a5,sp,24
400145cc:	00b12423          	sw	a1,8(sp)
400145d0:	00000613          	li	a2,0
400145d4:	00078513          	mv	a0,a5
			for (j = i; j < 8; j++) {
400145d8:	00800593          	li	a1,8
{
400145dc:	00060693          	mv	a3,a2
400145e0:	01c0006f          	j	400145fc <z_impl_net_addr_ntop+0x88>
				zeros[i]++;
400145e4:	0007c703          	lbu	a4,0(a5)
			for (j = i; j < 8; j++) {
400145e8:	00168693          	addi	a3,a3,1
				zeros[i]++;
400145ec:	00170713          	addi	a4,a4,1
400145f0:	00e78023          	sb	a4,0(a5)
			for (j = i; j < 8; j++) {
400145f4:	0ff6f713          	zext.b	a4,a3
400145f8:	02b70063          	beq	a4,a1,40014618 <z_impl_net_addr_ntop+0xa4>
				if (UNALIGNED_GET(&w[j]) != 0) {
400145fc:	00169713          	slli	a4,a3,0x1
40014600:	00e98733          	add	a4,s3,a4
40014604:	00074803          	lbu	a6,0(a4)
40014608:	00174703          	lbu	a4,1(a4)
4001460c:	00871713          	slli	a4,a4,0x8
40014610:	01076733          	or	a4,a4,a6
40014614:	fc0708e3          	beqz	a4,400145e4 <z_impl_net_addr_ntop+0x70>
		for (i = 0U; i < 8; i++) {
40014618:	00160613          	addi	a2,a2,1
4001461c:	00178793          	addi	a5,a5,1
40014620:	fab61ee3          	bne	a2,a1,400145dc <z_impl_net_addr_ntop+0x68>
40014624:	00000793          	li	a5,0
	int8_t pos = -1;
40014628:	fff00a93          	li	s5,-1
	uint8_t i, bl, bh, longest = 1U;
4001462c:	00100493          	li	s1,1
		for (i = 0U; i < 8; i++) {
40014630:	00800693          	li	a3,8
			if (zeros[i] > longest) {
40014634:	00f50733          	add	a4,a0,a5
40014638:	00074703          	lbu	a4,0(a4)
4001463c:	00e4f863          	bgeu	s1,a4,4001464c <z_impl_net_addr_ntop+0xd8>
				pos = i;
40014640:	01879a93          	slli	s5,a5,0x18
40014644:	418ada93          	srai	s5,s5,0x18
40014648:	00070493          	mv	s1,a4
		for (i = 0U; i < 8; i++) {
4001464c:	00178793          	addi	a5,a5,1
40014650:	fed792e3          	bne	a5,a3,40014634 <z_impl_net_addr_ntop+0xc0>
		if (longest == 1U) {
40014654:	00100793          	li	a5,1
40014658:	04f49e63          	bne	s1,a5,400146b4 <z_impl_net_addr_ntop+0x140>
		len = 8;
4001465c:	00800a13          	li	s4,8
	char delim = ':';
40014660:	03a00b13          	li	s6,58
			pos = -1;
40014664:	fff00a93          	li	s5,-1
40014668:	0540006f          	j	400146bc <z_impl_net_addr_ntop+0x148>
	} else if (family == AF_INET) {
4001466c:	00100793          	li	a5,1
40014670:	0af50e63          	beq	a0,a5,4001472c <z_impl_net_addr_ntop+0x1b8>
		return NULL;
40014674:	00000513          	li	a0,0
}
40014678:	05c12083          	lw	ra,92(sp)
4001467c:	05812403          	lw	s0,88(sp)
40014680:	05412483          	lw	s1,84(sp)
40014684:	05012903          	lw	s2,80(sp)
40014688:	04c12983          	lw	s3,76(sp)
4001468c:	04812a03          	lw	s4,72(sp)
40014690:	04412a83          	lw	s5,68(sp)
40014694:	04012b03          	lw	s6,64(sp)
40014698:	03c12b83          	lw	s7,60(sp)
4001469c:	03812c03          	lw	s8,56(sp)
400146a0:	03412c83          	lw	s9,52(sp)
400146a4:	03012d03          	lw	s10,48(sp)
400146a8:	02c12d83          	lw	s11,44(sp)
400146ac:	06010113          	addi	sp,sp,96
400146b0:	00008067          	ret
		len = 8;
400146b4:	00800a13          	li	s4,8
	char delim = ':';
400146b8:	03a00b13          	li	s6,58
400146bc:	00040513          	mv	a0,s0
	bool needcolon = false;
400146c0:	00000613          	li	a2,0
	for (i = 0U; i < len; i++) {
400146c4:	00000d13          	li	s10,0
400146c8:	00000793          	li	a5,0
		} else if (bl > 0x0f) {
400146cc:	00f00b93          	li	s7,15
			if (bl < 10) {
400146d0:	00900c13          	li	s8,9
			*ptr++ = ':';
400146d4:	03a00c93          	li	s9,58
			i += longest - 1U;
400146d8:	fff48493          	addi	s1,s1,-1
	for (i = 9; i >= 0; i--, divisor /= 10U) {
400146dc:	00a00d93          	li	s11,10
		if (len == 4) {
400146e0:	00400713          	li	a4,4
400146e4:	0cea1063          	bne	s4,a4,400147a4 <z_impl_net_addr_ntop+0x230>
			value = (uint32_t)addr->s4_addr[i];
400146e8:	00f987b3          	add	a5,s3,a5
400146ec:	0007c683          	lbu	a3,0(a5)
			if (value == 0U) {
400146f0:	04069863          	bnez	a3,40014740 <z_impl_net_addr_ntop+0x1cc>
				*ptr++ = '0';
400146f4:	03000793          	li	a5,48
400146f8:	00f50023          	sb	a5,0(a0)
				*ptr++ = delim;
400146fc:	016500a3          	sb	s6,1(a0)
40014700:	00250513          	addi	a0,a0,2
	for (i = 0U; i < len; i++) {
40014704:	001d0713          	addi	a4,s10,1
40014708:	0ff77d13          	zext.b	s10,a4
4001470c:	000d0793          	mv	a5,s10
40014710:	fd4d48e3          	blt	s10,s4,400146e0 <z_impl_net_addr_ntop+0x16c>
	if (!(ptr - dst)) {
40014714:	f68500e3          	beq	a0,s0,40014674 <z_impl_net_addr_ntop+0x100>
	if (family == AF_INET) {
40014718:	00100793          	li	a5,1
4001471c:	18f91863          	bne	s2,a5,400148ac <z_impl_net_addr_ntop+0x338>
		*(ptr - 1) = '\0';
40014720:	fe050fa3          	sb	zero,-1(a0)
		return NULL;
40014724:	00040513          	mv	a0,s0
40014728:	f51ff06f          	j	40014678 <z_impl_net_addr_ntop+0x104>
		len = 4;
4001472c:	00400a13          	li	s4,4
		delim = '.';
40014730:	02e00b13          	li	s6,46
	int8_t pos = -1;
40014734:	fff00a93          	li	s5,-1
	uint8_t i, bl, bh, longest = 1U;
40014738:	00100493          	li	s1,1
4001473c:	f81ff06f          	j	400146bc <z_impl_net_addr_ntop+0x148>
			l = net_value_to_udec(ptr, value, 0);
40014740:	3b9ad737          	lui	a4,0x3b9ad
40014744:	00050793          	mv	a5,a0
40014748:	00900593          	li	a1,9
4001474c:	00000313          	li	t1,0
40014750:	a0070813          	addi	a6,a4,-1536 # 3b9aca00 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x35a4e900>
	for (i = 9; i >= 0; i--, divisor /= 10U) {
40014754:	fff00e13          	li	t3,-1
		temp = value / divisor;
40014758:	0306d8b3          	divu	a7,a3,a6
		value = value % divisor;
4001475c:	00068e93          	mv	t4,a3
40014760:	0306f6b3          	remu	a3,a3,a6
		if ((precision > i) || (temp != 0)) {
40014764:	0065c463          	blt	a1,t1,4001476c <z_impl_net_addr_ntop+0x1f8>
40014768:	010eea63          	bltu	t4,a6,4001477c <z_impl_net_addr_ntop+0x208>
			*buf++ = (char) (temp + '0');
4001476c:	03088893          	addi	a7,a7,48 # 1000030 <__rom_region_size+0xfc7074>
40014770:	01178023          	sb	a7,0(a5)
40014774:	00058313          	mv	t1,a1
40014778:	00178793          	addi	a5,a5,1
	for (i = 9; i >= 0; i--, divisor /= 10U) {
4001477c:	fff58593          	addi	a1,a1,-1
40014780:	03b85833          	divu	a6,a6,s11
40014784:	fdc59ae3          	bne	a1,t3,40014758 <z_impl_net_addr_ntop+0x1e4>
	*buf = 0;
40014788:	00078023          	sb	zero,0(a5)
	return buf - start;
4001478c:	40a787b3          	sub	a5,a5,a0
			ptr += l;
40014790:	0ff7f793          	zext.b	a5,a5
40014794:	00f507b3          	add	a5,a0,a5
			*ptr++ = delim;
40014798:	00178513          	addi	a0,a5,1
4001479c:	01678023          	sb	s6,0(a5)
			continue;
400147a0:	f65ff06f          	j	40014704 <z_impl_net_addr_ntop+0x190>
		if (i == pos) {
400147a4:	02fa9863          	bne	s5,a5,400147d4 <z_impl_net_addr_ntop+0x260>
			if (needcolon || i == 0U) {
400147a8:	00061463          	bnez	a2,400147b0 <z_impl_net_addr_ntop+0x23c>
400147ac:	000d1863          	bnez	s10,400147bc <z_impl_net_addr_ntop+0x248>
				*ptr++ = ':';
400147b0:	03a00793          	li	a5,58
400147b4:	00f50023          	sb	a5,0(a0)
400147b8:	00150513          	addi	a0,a0,1
			i += longest - 1U;
400147bc:	009d0733          	add	a4,s10,s1
			*ptr++ = ':';
400147c0:	01950023          	sb	s9,0(a0)
			i += longest - 1U;
400147c4:	0ff77d13          	zext.b	s10,a4
			*ptr++ = ':';
400147c8:	00150513          	addi	a0,a0,1
			needcolon = false;
400147cc:	00000613          	li	a2,0
			continue;
400147d0:	f35ff06f          	j	40014704 <z_impl_net_addr_ntop+0x190>
		if (needcolon) {
400147d4:	00060663          	beqz	a2,400147e0 <z_impl_net_addr_ntop+0x26c>
			*ptr++ = ':';
400147d8:	01950023          	sb	s9,0(a0)
400147dc:	00150513          	addi	a0,a0,1
		value = (uint32_t)sys_be16_to_cpu(UNALIGNED_GET(&w[i]));
400147e0:	00812703          	lw	a4,8(sp)
400147e4:	001d1793          	slli	a5,s10,0x1
400147e8:	00f707b3          	add	a5,a4,a5
400147ec:	0017c683          	lbu	a3,1(a5)
400147f0:	0007c603          	lbu	a2,0(a5)
400147f4:	00869693          	slli	a3,a3,0x8
400147f8:	00c6e6b3          	or	a3,a3,a2
400147fc:	00869793          	slli	a5,a3,0x8
40014800:	0086d693          	srli	a3,a3,0x8
40014804:	00d7e7b3          	or	a5,a5,a3
40014808:	01079793          	slli	a5,a5,0x10
4001480c:	0107d793          	srli	a5,a5,0x10
		bh = value >> 8;
40014810:	0087d693          	srli	a3,a5,0x8
		bl = value & 0xff;
40014814:	0ff7f793          	zext.b	a5,a5
		if (bh) {
40014818:	06068063          	beqz	a3,40014878 <z_impl_net_addr_ntop+0x304>
		bh = value >> 8;
4001481c:	0ff6f593          	zext.b	a1,a3
			if (bh > 0x0f) {
40014820:	02dbfc63          	bgeu	s7,a3,40014858 <z_impl_net_addr_ntop+0x2e4>
				ptr = net_byte_to_hex(ptr, bh, 'a', false);
40014824:	00000693          	li	a3,0
40014828:	06100613          	li	a2,97
4001482c:	00f12623          	sw	a5,12(sp)
40014830:	c05ff0ef          	jal	ra,40014434 <net_byte_to_hex>
40014834:	00c12783          	lw	a5,12(sp)
40014838:	00050813          	mv	a6,a0
			ptr = net_byte_to_hex(ptr, bl, 'a', true);
4001483c:	00100693          	li	a3,1
40014840:	06100613          	li	a2,97
40014844:	00078593          	mv	a1,a5
40014848:	00080513          	mv	a0,a6
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
4001484c:	be9ff0ef          	jal	ra,40014434 <net_byte_to_hex>
		needcolon = true;
40014850:	00100613          	li	a2,1
40014854:	eb1ff06f          	j	40014704 <z_impl_net_addr_ntop+0x190>
				if (bh < 10) {
40014858:	00dc6c63          	bltu	s8,a3,40014870 <z_impl_net_addr_ntop+0x2fc>
					*ptr++ = (char)(bh + '0');
4001485c:	03058593          	addi	a1,a1,48
40014860:	0ff5f593          	zext.b	a1,a1
40014864:	00150813          	addi	a6,a0,1
40014868:	00b50023          	sb	a1,0(a0)
4001486c:	fd1ff06f          	j	4001483c <z_impl_net_addr_ntop+0x2c8>
					*ptr++ = (char) (bh - 10 + 'a');
40014870:	05758593          	addi	a1,a1,87
40014874:	fedff06f          	j	40014860 <z_impl_net_addr_ntop+0x2ec>
		} else if (bl > 0x0f) {
40014878:	00fbfa63          	bgeu	s7,a5,4001488c <z_impl_net_addr_ntop+0x318>
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
4001487c:	00000693          	li	a3,0
40014880:	06100613          	li	a2,97
40014884:	00078593          	mv	a1,a5
40014888:	fc5ff06f          	j	4001484c <z_impl_net_addr_ntop+0x2d8>
			if (bl < 10) {
4001488c:	00fc6c63          	bltu	s8,a5,400148a4 <z_impl_net_addr_ntop+0x330>
				*ptr++ = (char)(bl + '0');
40014890:	03078793          	addi	a5,a5,48
				*ptr++ = (char) (bl - 10 + 'a');
40014894:	0ff7f793          	zext.b	a5,a5
40014898:	00f50023          	sb	a5,0(a0)
4001489c:	00150513          	addi	a0,a0,1
400148a0:	fb1ff06f          	j	40014850 <z_impl_net_addr_ntop+0x2dc>
400148a4:	05778793          	addi	a5,a5,87
400148a8:	fedff06f          	j	40014894 <z_impl_net_addr_ntop+0x320>
		*ptr = '\0';
400148ac:	00050023          	sb	zero,0(a0)
400148b0:	e75ff06f          	j	40014724 <z_impl_net_addr_ntop+0x1b0>

400148b4 <net_sprint_addr>:
	char *s = buf[++i % NBUFS];
400148b4:	400397b7          	lui	a5,0x40039
400148b8:	0747a603          	lw	a2,116(a5) # 40039074 <i.3>
400148bc:	00160613          	addi	a2,a2,1
400148c0:	06c7aa23          	sw	a2,116(a5)
400148c4:	00300793          	li	a5,3
400148c8:	02f66633          	rem	a2,a2,a5
400148cc:	02800793          	li	a5,40
		union { uintptr_t x; size_t val; } parm3 = { .val = size };
		return (char *) arch_syscall_invoke4(parm0.x, parm1.x, parm2.x, parm3.x, K_SYSCALL_NET_ADDR_NTOP);
	}
#endif
	compiler_barrier();
	return z_impl_net_addr_ntop(family, src, dst, size);
400148d0:	02800693          	li	a3,40
400148d4:	02f60633          	mul	a2,a2,a5
400148d8:	4003a7b7          	lui	a5,0x4003a
400148dc:	6f878793          	addi	a5,a5,1784 # 4003a6f8 <buf.2>
400148e0:	00c78633          	add	a2,a5,a2
400148e4:	c91ff06f          	j	40014574 <z_impl_net_addr_ntop>

400148e8 <z_impl_net_addr_pton>:
{
400148e8:	fc010113          	addi	sp,sp,-64
400148ec:	02812c23          	sw	s0,56(sp)
400148f0:	03212823          	sw	s2,48(sp)
400148f4:	02112e23          	sw	ra,60(sp)
400148f8:	02912a23          	sw	s1,52(sp)
400148fc:	03312623          	sw	s3,44(sp)
40014900:	03412423          	sw	s4,40(sp)
40014904:	03512223          	sw	s5,36(sp)
40014908:	03612023          	sw	s6,32(sp)
4001490c:	01712e23          	sw	s7,28(sp)
	if (family == AF_INET) {
40014910:	00100793          	li	a5,1
{
40014914:	00058413          	mv	s0,a1
40014918:	00060913          	mv	s2,a2
	if (family == AF_INET) {
4001491c:	08f51263          	bne	a0,a5,400149a0 <z_impl_net_addr_pton+0xb8>
		len = strlen(src);
40014920:	00058513          	mv	a0,a1
40014924:	ab0f80ef          	jal	ra,4000cbd4 <strlen>
		for (i = 0; i < len; i++) {
40014928:	00000793          	li	a5,0
			if (!(src[i] >= '0' && src[i] <= '9') &&
4001492c:	00900613          	li	a2,9
40014930:	02e00593          	li	a1,46
		for (i = 0; i < len; i++) {
40014934:	04a79663          	bne	a5,a0,40014980 <z_impl_net_addr_pton+0x98>
		(void)memset(addr, 0, sizeof(struct in_addr));
40014938:	00400613          	li	a2,4
4001493c:	00000593          	li	a1,0
40014940:	00090513          	mv	a0,s2
40014944:	bd8f80ef          	jal	ra,4000cd1c <memset>
		for (i = 0; i < sizeof(struct in_addr); i++) {
40014948:	00000493          	li	s1,0
4001494c:	00400993          	li	s3,4
			addr->s4_addr[i] = strtol(src, &endptr, 10);
40014950:	00040513          	mv	a0,s0
40014954:	00a00613          	li	a2,10
40014958:	00c10593          	addi	a1,sp,12
4001495c:	e29f70ef          	jal	ra,4000c784 <strtol>
			src = ++endptr;
40014960:	00c12403          	lw	s0,12(sp)
			addr->s4_addr[i] = strtol(src, &endptr, 10);
40014964:	009907b3          	add	a5,s2,s1
40014968:	00a78023          	sb	a0,0(a5)
		for (i = 0; i < sizeof(struct in_addr); i++) {
4001496c:	00148493          	addi	s1,s1,1
			src = ++endptr;
40014970:	00140413          	addi	s0,s0,1
		for (i = 0; i < sizeof(struct in_addr); i++) {
40014974:	fd349ee3          	bne	s1,s3,40014950 <z_impl_net_addr_pton+0x68>
	return 0;
40014978:	00000513          	li	a0,0
4001497c:	1500006f          	j	40014acc <z_impl_net_addr_pton+0x1e4>
			if (!(src[i] >= '0' && src[i] <= '9') &&
40014980:	00f40733          	add	a4,s0,a5
40014984:	00074683          	lbu	a3,0(a4)
40014988:	fd068713          	addi	a4,a3,-48
4001498c:	0ff77713          	zext.b	a4,a4
40014990:	00e67463          	bgeu	a2,a4,40014998 <z_impl_net_addr_pton+0xb0>
40014994:	12b69a63          	bne	a3,a1,40014ac8 <z_impl_net_addr_pton+0x1e0>
		for (i = 0; i < len; i++) {
40014998:	00178793          	addi	a5,a5,1
4001499c:	f99ff06f          	j	40014934 <z_impl_net_addr_pton+0x4c>
	} else if (family == AF_INET6) {
400149a0:	00200793          	li	a5,2
400149a4:	12f51263          	bne	a0,a5,40014ac8 <z_impl_net_addr_pton+0x1e0>
		int expected_groups = strchr(src, '.') ? 6 : 8;
400149a8:	02e00593          	li	a1,46
400149ac:	00040513          	mv	a0,s0
400149b0:	9dcf80ef          	jal	ra,4000cb8c <strchr>
400149b4:	00800b13          	li	s6,8
400149b8:	00050463          	beqz	a0,400149c0 <z_impl_net_addr_pton+0xd8>
400149bc:	00600b13          	li	s6,6
		if (*src == ':') {
400149c0:	00044703          	lbu	a4,0(s0)
400149c4:	03a00793          	li	a5,58
400149c8:	00f71463          	bne	a4,a5,400149d0 <z_impl_net_addr_pton+0xe8>
			src++;
400149cc:	00140413          	addi	s0,s0,1
		len = strlen(src);
400149d0:	00040513          	mv	a0,s0
400149d4:	a00f80ef          	jal	ra,4000cbd4 <strlen>
		for (i = 0; i < len; i++) {
400149d8:	01f816b7          	lui	a3,0x1f81
400149dc:	00000713          	li	a4,0
			if (!(src[i] >= '0' && src[i] <= '9') &&
400149e0:	00900593          	li	a1,9
400149e4:	04600813          	li	a6,70
400149e8:	00500893          	li	a7,5
400149ec:	02d00313          	li	t1,45
400149f0:	00168693          	addi	a3,a3,1 # 1f81001 <__rom_region_size+0x1f48045>
		for (i = 0; i < len; i++) {
400149f4:	08a74a63          	blt	a4,a0,40014a88 <z_impl_net_addr_pton+0x1a0>
		for (i = 0; i < expected_groups; i++) {
400149f8:	00000493          	li	s1,0
			if (*src != ':') {
400149fc:	03a00a13          	li	s4,58
				if (i < 0) {
40014a00:	fff00a93          	li	s5,-1
			if (!src || *src == '\0') {
40014a04:	00044783          	lbu	a5,0(s0)
40014a08:	0c078063          	beqz	a5,40014ac8 <z_impl_net_addr_pton+0x1e0>
			if (*src != ':') {
40014a0c:	11478e63          	beq	a5,s4,40014b28 <z_impl_net_addr_pton+0x240>
				UNALIGNED_PUT(htons(strtol(src, NULL, 16)),
40014a10:	01000613          	li	a2,16
40014a14:	00000593          	li	a1,0
40014a18:	00040513          	mv	a0,s0
40014a1c:	d69f70ef          	jal	ra,4000c784 <strtol>
40014a20:	00050993          	mv	s3,a0
40014a24:	00000593          	li	a1,0
40014a28:	01000613          	li	a2,16
40014a2c:	00040513          	mv	a0,s0
40014a30:	d55f70ef          	jal	ra,4000c784 <strtol>
40014a34:	4089d793          	srai	a5,s3,0x8
40014a38:	00851513          	slli	a0,a0,0x8
40014a3c:	0ff7f793          	zext.b	a5,a5
40014a40:	00a7e7b3          	or	a5,a5,a0
40014a44:	01079713          	slli	a4,a5,0x10
40014a48:	00149b93          	slli	s7,s1,0x1
40014a4c:	01790bb3          	add	s7,s2,s7
40014a50:	01075713          	srli	a4,a4,0x10
40014a54:	00fb8023          	sb	a5,0(s7)
40014a58:	00875793          	srli	a5,a4,0x8
40014a5c:	00fb80a3          	sb	a5,1(s7)
				src = strchr(src, ':');
40014a60:	03a00593          	li	a1,58
40014a64:	00040513          	mv	a0,s0
40014a68:	924f80ef          	jal	ra,4000cb8c <strchr>
				if (src) {
40014a6c:	08050663          	beqz	a0,40014af8 <z_impl_net_addr_pton+0x210>
					src++;
40014a70:	00150413          	addi	s0,a0,1
		for (i = 0; i < expected_groups; i++) {
40014a74:	00148493          	addi	s1,s1,1
40014a78:	f964c6e3          	blt	s1,s6,40014a04 <z_impl_net_addr_pton+0x11c>
		if (expected_groups == 6) {
40014a7c:	00600793          	li	a5,6
40014a80:	eefb1ce3          	bne	s6,a5,40014978 <z_impl_net_addr_pton+0x90>
40014a84:	0f40006f          	j	40014b78 <z_impl_net_addr_pton+0x290>
			if (!(src[i] >= '0' && src[i] <= '9') &&
40014a88:	00e407b3          	add	a5,s0,a4
40014a8c:	0007c783          	lbu	a5,0(a5)
40014a90:	fd078613          	addi	a2,a5,-48
40014a94:	0ff67613          	zext.b	a2,a2
40014a98:	00c5fe63          	bgeu	a1,a2,40014ab4 <z_impl_net_addr_pton+0x1cc>
40014a9c:	02f86063          	bltu	a6,a5,40014abc <z_impl_net_addr_pton+0x1d4>
40014aa0:	02f37463          	bgeu	t1,a5,40014ac8 <z_impl_net_addr_pton+0x1e0>
40014aa4:	fd278793          	addi	a5,a5,-46
40014aa8:	00f6d7b3          	srl	a5,a3,a5
40014aac:	0017f793          	andi	a5,a5,1
40014ab0:	00078c63          	beqz	a5,40014ac8 <z_impl_net_addr_pton+0x1e0>
		for (i = 0; i < len; i++) {
40014ab4:	00170713          	addi	a4,a4,1
40014ab8:	f3dff06f          	j	400149f4 <z_impl_net_addr_pton+0x10c>
40014abc:	f9f78793          	addi	a5,a5,-97
40014ac0:	0ff7f793          	zext.b	a5,a5
40014ac4:	fef8f8e3          	bgeu	a7,a5,40014ab4 <z_impl_net_addr_pton+0x1cc>
				return -EINVAL;
40014ac8:	fea00513          	li	a0,-22
}
40014acc:	03c12083          	lw	ra,60(sp)
40014ad0:	03812403          	lw	s0,56(sp)
40014ad4:	03412483          	lw	s1,52(sp)
40014ad8:	03012903          	lw	s2,48(sp)
40014adc:	02c12983          	lw	s3,44(sp)
40014ae0:	02812a03          	lw	s4,40(sp)
40014ae4:	02412a83          	lw	s5,36(sp)
40014ae8:	02012b03          	lw	s6,32(sp)
40014aec:	01c12b83          	lw	s7,28(sp)
40014af0:	04010113          	addi	sp,sp,64
40014af4:	00008067          	ret
					if (i < expected_groups - 1) {
40014af8:	fffb0793          	addi	a5,s6,-1
40014afc:	fcf4c6e3          	blt	s1,a5,40014ac8 <z_impl_net_addr_pton+0x1e0>
		for (i = 0; i < expected_groups; i++) {
40014b00:	00148493          	addi	s1,s1,1
40014b04:	fd64c2e3          	blt	s1,s6,40014ac8 <z_impl_net_addr_pton+0x1e0>
		if (expected_groups == 6) {
40014b08:	00600793          	li	a5,6
40014b0c:	e6fb16e3          	bne	s6,a5,40014978 <z_impl_net_addr_pton+0x90>
40014b10:	fb9ff06f          	j	40014ac8 <z_impl_net_addr_pton+0x1e0>
				UNALIGNED_PUT(0, &addr->s6_addr16[i]);
40014b14:	00149793          	slli	a5,s1,0x1
40014b18:	00f907b3          	add	a5,s2,a5
40014b1c:	00078023          	sb	zero,0(a5)
40014b20:	000780a3          	sb	zero,1(a5)
			for (; i < expected_groups; i++) {
40014b24:	00148493          	addi	s1,s1,1
40014b28:	ff64c6e3          	blt	s1,s6,40014b14 <z_impl_net_addr_pton+0x22c>
			tmp = strrchr(src, ':');
40014b2c:	03a00593          	li	a1,58
40014b30:	00040513          	mv	a0,s0
40014b34:	87cf80ef          	jal	ra,4000cbb0 <strrchr>
			if (src == tmp && (expected_groups == 6 || !src[1])) {
40014b38:	00600793          	li	a5,6
40014b3c:	08851263          	bne	a0,s0,40014bc0 <z_impl_net_addr_pton+0x2d8>
40014b40:	02fb0a63          	beq	s6,a5,40014b74 <z_impl_net_addr_pton+0x28c>
40014b44:	00144783          	lbu	a5,1(s0)
40014b48:	e20788e3          	beqz	a5,40014978 <z_impl_net_addr_pton+0x90>
			i = expected_groups - 1;
40014b4c:	fffb0493          	addi	s1,s6,-1
				if (*tmp == ':') {
40014b50:	00054783          	lbu	a5,0(a0)
40014b54:	01479663          	bne	a5,s4,40014b60 <z_impl_net_addr_pton+0x278>
					i--;
40014b58:	fff48493          	addi	s1,s1,-1
				if (i < 0) {
40014b5c:	f75486e3          	beq	s1,s5,40014ac8 <z_impl_net_addr_pton+0x1e0>
			} while (tmp-- != src);
40014b60:	fff50513          	addi	a0,a0,-1
40014b64:	00150793          	addi	a5,a0,1
40014b68:	fef414e3          	bne	s0,a5,40014b50 <z_impl_net_addr_pton+0x268>
			src++;
40014b6c:	00250413          	addi	s0,a0,2
40014b70:	f05ff06f          	j	40014a74 <z_impl_net_addr_pton+0x18c>
				src++;
40014b74:	00140413          	addi	s0,s0,1
			for (i = 0; i < 4; i++) {
40014b78:	00000493          	li	s1,0
40014b7c:	00400993          	li	s3,4
				if (!src || !*src) {
40014b80:	00044783          	lbu	a5,0(s0)
40014b84:	f40782e3          	beqz	a5,40014ac8 <z_impl_net_addr_pton+0x1e0>
				addr->s6_addr[12 + i] = strtol(src, NULL, 10);
40014b88:	00000593          	li	a1,0
40014b8c:	00a00613          	li	a2,10
40014b90:	00040513          	mv	a0,s0
40014b94:	bf1f70ef          	jal	ra,4000c784 <strtol>
40014b98:	009907b3          	add	a5,s2,s1
40014b9c:	00a78623          	sb	a0,12(a5)
				src = strchr(src, '.');
40014ba0:	02e00593          	li	a1,46
40014ba4:	00040513          	mv	a0,s0
40014ba8:	fe5f70ef          	jal	ra,4000cb8c <strchr>
				if (src) {
40014bac:	02050063          	beqz	a0,40014bcc <z_impl_net_addr_pton+0x2e4>
			for (i = 0; i < 4; i++) {
40014bb0:	00148493          	addi	s1,s1,1
					src++;
40014bb4:	00150413          	addi	s0,a0,1
			for (i = 0; i < 4; i++) {
40014bb8:	fd3494e3          	bne	s1,s3,40014b80 <z_impl_net_addr_pton+0x298>
40014bbc:	dbdff06f          	j	40014978 <z_impl_net_addr_pton+0x90>
			if (expected_groups == 6) {
40014bc0:	f8fb16e3          	bne	s6,a5,40014b4c <z_impl_net_addr_pton+0x264>
				tmp--;
40014bc4:	fff50513          	addi	a0,a0,-1
40014bc8:	f85ff06f          	j	40014b4c <z_impl_net_addr_pton+0x264>
					if (i < 3) {
40014bcc:	00300793          	li	a5,3
40014bd0:	eef49ce3          	bne	s1,a5,40014ac8 <z_impl_net_addr_pton+0x1e0>
40014bd4:	da5ff06f          	j	40014978 <z_impl_net_addr_pton+0x90>

40014bd8 <parse_ipv4>:
#endif /* CONFIG_NET_IPV6 */

#if defined(CONFIG_NET_IPV4)
static bool parse_ipv4(const char *str, size_t str_len,
		       struct sockaddr *addr, bool has_port)
{
40014bd8:	fc010113          	addi	sp,sp,-64
40014bdc:	02912a23          	sw	s1,52(sp)
40014be0:	03312623          	sw	s3,44(sp)
40014be4:	03412423          	sw	s4,40(sp)
40014be8:	03512223          	sw	s5,36(sp)
40014bec:	02112e23          	sw	ra,60(sp)
40014bf0:	02812c23          	sw	s0,56(sp)
40014bf4:	03212823          	sw	s2,48(sp)
	char ipaddr[NET_IPV4_ADDR_LEN + 1];
	struct in_addr *addr4;
	int end, len, ret, i;
	uint16_t port;

	len = MIN(NET_IPV4_ADDR_LEN, str_len);
40014bf8:	01000713          	li	a4,16
{
40014bfc:	00050993          	mv	s3,a0
40014c00:	00058493          	mv	s1,a1
40014c04:	00060a13          	mv	s4,a2
40014c08:	00068a93          	mv	s5,a3
	len = MIN(NET_IPV4_ADDR_LEN, str_len);
40014c0c:	01000793          	li	a5,16
40014c10:	00b76463          	bltu	a4,a1,40014c18 <parse_ipv4+0x40>
40014c14:	00058793          	mv	a5,a1

	for (i = 0; i < len; i++) {
40014c18:	00000413          	li	s0,0
40014c1c:	04f44663          	blt	s0,a5,40014c68 <parse_ipv4+0x90>
40014c20:	00078413          	mv	s0,a5
			len = i;
			break;
		}
	}

	if (has_port) {
40014c24:	0e0a8663          	beqz	s5,40014d10 <parse_ipv4+0x138>
		/* IPv4 address with port number */
		ptr = memchr(str, ':', len);
40014c28:	00040613          	mv	a2,s0
40014c2c:	03a00593          	li	a1,58
40014c30:	00098513          	mv	a0,s3
40014c34:	908f80ef          	jal	ra,4000cd3c <memchr>
40014c38:	00050913          	mv	s2,a0
		if (!ptr) {
40014c3c:	04051063          	bnez	a0,40014c7c <parse_ipv4+0xa4>
			return false;
40014c40:	00000513          	li	a0,0

	NET_DBG("IPv4 host %s port %d",
		net_addr_ntop(AF_INET, addr4, ipaddr, sizeof(ipaddr) - 1),
		port);
	return true;
}
40014c44:	03c12083          	lw	ra,60(sp)
40014c48:	03812403          	lw	s0,56(sp)
40014c4c:	03412483          	lw	s1,52(sp)
40014c50:	03012903          	lw	s2,48(sp)
40014c54:	02c12983          	lw	s3,44(sp)
40014c58:	02812a03          	lw	s4,40(sp)
40014c5c:	02412a83          	lw	s5,36(sp)
40014c60:	04010113          	addi	sp,sp,64
40014c64:	00008067          	ret
		if (!str[i]) {
40014c68:	00898733          	add	a4,s3,s0
40014c6c:	00074703          	lbu	a4,0(a4)
40014c70:	fa070ae3          	beqz	a4,40014c24 <parse_ipv4+0x4c>
	for (i = 0; i < len; i++) {
40014c74:	00140413          	addi	s0,s0,1
40014c78:	fa5ff06f          	j	40014c1c <parse_ipv4+0x44>
		end = MIN(len, ptr - str);
40014c7c:	413507b3          	sub	a5,a0,s3
40014c80:	0087d463          	bge	a5,s0,40014c88 <parse_ipv4+0xb0>
40014c84:	00078413          	mv	s0,a5
	memcpy(ipaddr, str, end);
40014c88:	00040613          	mv	a2,s0
40014c8c:	00098593          	mv	a1,s3
40014c90:	00c10513          	addi	a0,sp,12
40014c94:	864f80ef          	jal	ra,4000ccf8 <memcpy>
	ipaddr[end] = '\0';
40014c98:	02040793          	addi	a5,s0,32
40014c9c:	002787b3          	add	a5,a5,sp
40014ca0:	fe078623          	sb	zero,-20(a5)
	return z_impl_net_addr_pton(family, src, dst);
40014ca4:	00100513          	li	a0,1
40014ca8:	004a0613          	addi	a2,s4,4
40014cac:	00c10593          	addi	a1,sp,12
40014cb0:	c39ff0ef          	jal	ra,400148e8 <z_impl_net_addr_pton>
	if (ret < 0) {
40014cb4:	f80546e3          	bltz	a0,40014c40 <parse_ipv4+0x68>
	net_sin(addr)->sin_family = AF_INET;
40014cb8:	00100793          	li	a5,1
40014cbc:	00fa1023          	sh	a5,0(s4)
	if (!has_port) {
40014cc0:	040a8463          	beqz	s5,40014d08 <parse_ipv4+0x130>
	memcpy(ipaddr, ptr + 1, str_len - end);
40014cc4:	408484b3          	sub	s1,s1,s0
40014cc8:	00048613          	mv	a2,s1
40014ccc:	00190593          	addi	a1,s2,1
40014cd0:	00c10513          	addi	a0,sp,12
40014cd4:	824f80ef          	jal	ra,4000ccf8 <memcpy>
	ipaddr[str_len - end] = '\0';
40014cd8:	02048793          	addi	a5,s1,32
40014cdc:	002784b3          	add	s1,a5,sp
	ret = convert_port(ipaddr, &port);
40014ce0:	00a10593          	addi	a1,sp,10
40014ce4:	00c10513          	addi	a0,sp,12
	ipaddr[str_len - end] = '\0';
40014ce8:	fe048623          	sb	zero,-20(s1)
	ret = convert_port(ipaddr, &port);
40014cec:	ed8ff0ef          	jal	ra,400143c4 <convert_port>
	if (!ret) {
40014cf0:	f40508e3          	beqz	a0,40014c40 <parse_ipv4+0x68>
	net_sin(addr)->sin_port = htons(port);
40014cf4:	00a15783          	lhu	a5,10(sp)
40014cf8:	00879713          	slli	a4,a5,0x8
40014cfc:	0087d793          	srli	a5,a5,0x8
40014d00:	00f767b3          	or	a5,a4,a5
40014d04:	00fa1123          	sh	a5,2(s4)
		return true;
40014d08:	00100513          	li	a0,1
40014d0c:	f39ff06f          	j	40014c44 <parse_ipv4+0x6c>
	char *ptr = NULL;
40014d10:	00000913          	li	s2,0
40014d14:	f75ff06f          	j	40014c88 <parse_ipv4+0xb0>

40014d18 <calc_chksum>:
	int odd_start = ((uintptr_t)data & 0x01);
40014d18:	0015f893          	andi	a7,a1,1
	if (odd_start == CHECKSUM_BIG_ENDIAN) {
40014d1c:	12089663          	bnez	a7,40014e48 <calc_chksum+0x130>
		sum = __bswap_16(sum_in);
40014d20:	00851793          	slli	a5,a0,0x8
40014d24:	00855513          	srli	a0,a0,0x8
40014d28:	00a7e7b3          	or	a5,a5,a0
40014d2c:	01079513          	slli	a0,a5,0x10
40014d30:	01055513          	srli	a0,a0,0x10
40014d34:	00000793          	li	a5,0
	if ((((uintptr_t)data & 0x02) != 0) && (pending >= sizeof(uint16_t))) {
40014d38:	0025f713          	andi	a4,a1,2
40014d3c:	02070463          	beqz	a4,40014d64 <calc_chksum+0x4c>
40014d40:	00100713          	li	a4,1
40014d44:	02c77063          	bgeu	a4,a2,40014d64 <calc_chksum+0x4c>
		sum = sum + *((uint16_t *)data);
40014d48:	0005d703          	lhu	a4,0(a1)
		pending -= sizeof(uint16_t);
40014d4c:	ffe60613          	addi	a2,a2,-2
		data += sizeof(uint16_t);
40014d50:	00258593          	addi	a1,a1,2
		sum = sum + *((uint16_t *)data);
40014d54:	00e50733          	add	a4,a0,a4
40014d58:	00a736b3          	sltu	a3,a4,a0
40014d5c:	00f687b3          	add	a5,a3,a5
40014d60:	00070513          	mv	a0,a4
	while (pending >= sizeof(uint32_t) * 4) {
40014d64:	00058693          	mv	a3,a1
40014d68:	00c58eb3          	add	t4,a1,a2
40014d6c:	00f00e13          	li	t3,15
40014d70:	40de8733          	sub	a4,t4,a3
40014d74:	0eee6e63          	bltu	t3,a4,40014e70 <calc_chksum+0x158>
40014d78:	00465693          	srli	a3,a2,0x4
40014d7c:	ff000713          	li	a4,-16
40014d80:	02e68733          	mul	a4,a3,a4
40014d84:	00469693          	slli	a3,a3,0x4
40014d88:	00d58333          	add	t1,a1,a3
	while (pending >= sizeof(uint32_t)) {
40014d8c:	00300e13          	li	t3,3
40014d90:	00c70633          	add	a2,a4,a2
	while (pending >= sizeof(uint32_t) * 4) {
40014d94:	00060813          	mv	a6,a2
	while (pending >= sizeof(uint32_t)) {
40014d98:	130e6063          	bltu	t3,a6,40014eb8 <calc_chksum+0x1a0>
40014d9c:	00265713          	srli	a4,a2,0x2
40014da0:	ffc00813          	li	a6,-4
40014da4:	03070733          	mul	a4,a4,a6
40014da8:	00e60733          	add	a4,a2,a4
		sum = sum + p[i++];
40014dac:	ffc67613          	andi	a2,a2,-4
40014db0:	00d60633          	add	a2,a2,a3
	if (pending >= 2) {
40014db4:	00100693          	li	a3,1
		sum = sum + p[i++];
40014db8:	00c585b3          	add	a1,a1,a2
	if (pending >= 2) {
40014dbc:	02e6f063          	bgeu	a3,a4,40014ddc <calc_chksum+0xc4>
		sum = sum + *((uint16_t *)data);
40014dc0:	0005d683          	lhu	a3,0(a1)
		pending -= sizeof(uint16_t);
40014dc4:	ffe70713          	addi	a4,a4,-2
		data += sizeof(uint16_t);
40014dc8:	00258593          	addi	a1,a1,2
		sum = sum + *((uint16_t *)data);
40014dcc:	00d506b3          	add	a3,a0,a3
40014dd0:	00a6b633          	sltu	a2,a3,a0
40014dd4:	00f607b3          	add	a5,a2,a5
40014dd8:	00068513          	mv	a0,a3
	if (pending == 1) {
40014ddc:	00100693          	li	a3,1
40014de0:	02d71263          	bne	a4,a3,40014e04 <calc_chksum+0xec>
	uint16_t data16 = (uint16_t)*data;
40014de4:	0005c703          	lbu	a4,0(a1)
	if (((uintptr_t)(data) & 1) == CHECKSUM_BIG_ENDIAN) {
40014de8:	0015f593          	andi	a1,a1,1
40014dec:	00058463          	beqz	a1,40014df4 <calc_chksum+0xdc>
		return data16 << 8;
40014df0:	00871713          	slli	a4,a4,0x8
		sum += offset_based_swap8(data);
40014df4:	00e50733          	add	a4,a0,a4
40014df8:	00a736b3          	sltu	a3,a4,a0
40014dfc:	00f687b3          	add	a5,a3,a5
40014e00:	00070513          	mv	a0,a4
		sum = (sum & 0xffff) + (sum >> 16);
40014e04:	00010637          	lui	a2,0x10
40014e08:	fff60613          	addi	a2,a2,-1 # ffff <__kernel_ram_size+0x44f7>
	while (sum >> 16) {
40014e0c:	01079693          	slli	a3,a5,0x10
40014e10:	01055713          	srli	a4,a0,0x10
40014e14:	00e6e733          	or	a4,a3,a4
40014e18:	0107d793          	srli	a5,a5,0x10
40014e1c:	00f766b3          	or	a3,a4,a5
40014e20:	0a069c63          	bnez	a3,40014ed8 <calc_chksum+0x1c0>
		return __bswap_16((uint16_t)sum);
40014e24:	01051513          	slli	a0,a0,0x10
40014e28:	01055513          	srli	a0,a0,0x10
	if (odd_start == CHECKSUM_BIG_ENDIAN) {
40014e2c:	00089c63          	bnez	a7,40014e44 <calc_chksum+0x12c>
		return __bswap_16((uint16_t)sum);
40014e30:	00851793          	slli	a5,a0,0x8
40014e34:	00855513          	srli	a0,a0,0x8
40014e38:	00a7e7b3          	or	a5,a5,a0
40014e3c:	01079513          	slli	a0,a5,0x10
40014e40:	01055513          	srli	a0,a0,0x10
}
40014e44:	00008067          	ret
		sum = sum_in;
40014e48:	00000793          	li	a5,0
	if ((((uintptr_t)data & 0x01) != 0) && (pending >= 1)) {
40014e4c:	f0060ce3          	beqz	a2,40014d64 <calc_chksum+0x4c>
		return data16 << 8;
40014e50:	0005c703          	lbu	a4,0(a1)
		pending--;
40014e54:	fff60613          	addi	a2,a2,-1
		data++;
40014e58:	00158593          	addi	a1,a1,1
		sum += offset_based_swap8(data);
40014e5c:	00871713          	slli	a4,a4,0x8
40014e60:	00e50733          	add	a4,a0,a4
40014e64:	00a737b3          	sltu	a5,a4,a0
40014e68:	00070513          	mv	a0,a4
		pending--;
40014e6c:	ecdff06f          	j	40014d38 <calc_chksum+0x20>
		uint64_t sum_a = p[i];
40014e70:	0006a803          	lw	a6,0(a3)
		uint64_t sum_b = p[i + 1];
40014e74:	0046a703          	lw	a4,4(a3)
40014e78:	01068693          	addi	a3,a3,16
40014e7c:	00e80733          	add	a4,a6,a4
40014e80:	01073333          	sltu	t1,a4,a6
40014e84:	00a70833          	add	a6,a4,a0
40014e88:	00e83733          	sltu	a4,a6,a4
40014e8c:	00f307b3          	add	a5,t1,a5
		sum_a += p[i + 2];
40014e90:	ff86a503          	lw	a0,-8(a3)
40014e94:	00f70733          	add	a4,a4,a5
		sum_b += p[i + 3];
40014e98:	ffc6a783          	lw	a5,-4(a3)
40014e9c:	00a80533          	add	a0,a6,a0
40014ea0:	01053833          	sltu	a6,a0,a6
		sum += sum_a + sum_b;
40014ea4:	00a78533          	add	a0,a5,a0
40014ea8:	00e80833          	add	a6,a6,a4
40014eac:	00f537b3          	sltu	a5,a0,a5
40014eb0:	010787b3          	add	a5,a5,a6
40014eb4:	ebdff06f          	j	40014d70 <calc_chksum+0x58>
		sum = sum + p[i++];
40014eb8:	00032703          	lw	a4,0(t1)
		pending -= sizeof(uint32_t);
40014ebc:	ffc80813          	addi	a6,a6,-4
		sum = sum + p[i++];
40014ec0:	00430313          	addi	t1,t1,4
40014ec4:	00e50733          	add	a4,a0,a4
40014ec8:	00a73eb3          	sltu	t4,a4,a0
40014ecc:	00fe87b3          	add	a5,t4,a5
40014ed0:	00070513          	mv	a0,a4
40014ed4:	ec5ff06f          	j	40014d98 <calc_chksum+0x80>
		sum = (sum & 0xffff) + (sum >> 16);
40014ed8:	00c576b3          	and	a3,a0,a2
40014edc:	00e68733          	add	a4,a3,a4
40014ee0:	00d736b3          	sltu	a3,a4,a3
40014ee4:	00070513          	mv	a0,a4
40014ee8:	00f687b3          	add	a5,a3,a5
40014eec:	f21ff06f          	j	40014e0c <calc_chksum+0xf4>

40014ef0 <net_calc_chksum>:
{
40014ef0:	fe010113          	addi	sp,sp,-32
40014ef4:	00812c23          	sw	s0,24(sp)
40014ef8:	00112e23          	sw	ra,28(sp)
40014efc:	00912a23          	sw	s1,20(sp)
40014f00:	01212823          	sw	s2,16(sp)
40014f04:	01312623          	sw	s3,12(sp)
40014f08:	01412423          	sw	s4,8(sp)
40014f0c:	01512223          	sw	s5,4(sp)
40014f10:	01612023          	sw	s6,0(sp)
40014f14:	03452783          	lw	a5,52(a0)
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
40014f18:	00100713          	li	a4,1
{
40014f1c:	00050413          	mv	s0,a0
40014f20:	01d7d793          	srli	a5,a5,0x1d
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
40014f24:	12e79463          	bne	a5,a4,4001504c <net_calc_chksum+0x15c>
		if (proto != IPPROTO_ICMP) {
40014f28:	16f58863          	beq	a1,a5,40015098 <net_calc_chksum+0x1a8>
			sum = net_pkt_get_len(pkt) -
40014f2c:	00852783          	lw	a5,8(a0)
	size_t bytes = 0;
40014f30:	00000713          	li	a4,0
	while (buf) {
40014f34:	10079463          	bnez	a5,4001503c <net_calc_chksum+0x14c>
				net_pkt_ip_hdr_len(pkt) -
40014f38:	03644783          	lbu	a5,54(s0)
				net_pkt_ipv4_opts_len(pkt) + proto;
40014f3c:	03a44683          	lbu	a3,58(s0)
			len = 2 * sizeof(struct in_addr);
40014f40:	00800a93          	li	s5,8
			sum = net_pkt_get_len(pkt) -
40014f44:	00d787b3          	add	a5,a5,a3
40014f48:	40f584b3          	sub	s1,a1,a5
40014f4c:	00e484b3          	add	s1,s1,a4
40014f50:	01049493          	slli	s1,s1,0x10
40014f54:	0104d493          	srli	s1,s1,0x10
	net_pkt_cursor_init(pkt);
40014f58:	00040513          	mv	a0,s0
 * @param backup The cursor where to backup net_pkt cursor
 */
static inline void net_pkt_cursor_backup(struct net_pkt *pkt,
					 struct net_pkt_cursor *backup)
{
	backup->buf = pkt->cursor.buf;
40014f5c:	00c42a03          	lw	s4,12(s0)
	backup->pos = pkt->cursor.pos;
40014f60:	01042983          	lw	s3,16(s0)
40014f64:	38d020ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	pkt->overwrite = overwrite;
40014f68:	03744783          	lbu	a5,55(s0)
	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);
40014f6c:	03644583          	lbu	a1,54(s0)
	return pkt->overwrite;
40014f70:	03744903          	lbu	s2,55(s0)
	pkt->overwrite = overwrite;
40014f74:	0017e793          	ori	a5,a5,1
40014f78:	02f40ba3          	sb	a5,55(s0)
40014f7c:	415585b3          	sub	a1,a1,s5
40014f80:	00040513          	mv	a0,s0
40014f84:	14c030ef          	jal	ra,400180d0 <net_pkt_skip>
	sum = calc_chksum(sum, pkt->cursor.pos, len);
40014f88:	01042583          	lw	a1,16(s0)
40014f8c:	000a8613          	mv	a2,s5
40014f90:	00048513          	mv	a0,s1
40014f94:	d85ff0ef          	jal	ra,40014d18 <calc_chksum>
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
40014f98:	03a45583          	lhu	a1,58(s0)
	sum = calc_chksum(sum, pkt->cursor.pos, len);
40014f9c:	00050493          	mv	s1,a0
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
40014fa0:	00040513          	mv	a0,s0
40014fa4:	015585b3          	add	a1,a1,s5
40014fa8:	128030ef          	jal	ra,400180d0 <net_pkt_skip>
	if (!cur->buf || !cur->pos) {
40014fac:	00c42703          	lw	a4,12(s0)
	return pkt->overwrite;
40014fb0:	00197913          	andi	s2,s2,1
40014fb4:	02070263          	beqz	a4,40014fd8 <net_calc_chksum+0xe8>
40014fb8:	01042783          	lw	a5,16(s0)
40014fbc:	00078e63          	beqz	a5,40014fd8 <net_calc_chksum+0xe8>
	len = cur->buf->len - (cur->pos - cur->buf->data);
40014fc0:	01075a83          	lhu	s5,16(a4)
40014fc4:	00c72703          	lw	a4,12(a4)
40014fc8:	40e787b3          	sub	a5,a5,a4
40014fcc:	40fa8ab3          	sub	s5,s5,a5
	while (cur->buf) {
40014fd0:	00c42b03          	lw	s6,12(s0)
40014fd4:	0c0b1863          	bnez	s6,400150a4 <net_calc_chksum+0x1b4>
	sum = (sum == 0U) ? 0xffff : htons(sum);
40014fd8:	14048063          	beqz	s1,40015118 <net_calc_chksum+0x228>
40014fdc:	00849513          	slli	a0,s1,0x8
40014fe0:	0084d493          	srli	s1,s1,0x8
40014fe4:	00956533          	or	a0,a0,s1
40014fe8:	01051513          	slli	a0,a0,0x10
40014fec:	01055513          	srli	a0,a0,0x10
	pkt->overwrite = overwrite;
40014ff0:	03744783          	lbu	a5,55(s0)
	return ~sum;
40014ff4:	fff54513          	not	a0,a0
40014ff8:	01051513          	slli	a0,a0,0x10
40014ffc:	ffe7f793          	andi	a5,a5,-2
40015000:	0127e7b3          	or	a5,a5,s2
 * @param backup The cursor from where to restore net_pkt cursor
 */
static inline void net_pkt_cursor_restore(struct net_pkt *pkt,
					  struct net_pkt_cursor *backup)
{
	pkt->cursor.buf = backup->buf;
40015004:	01442623          	sw	s4,12(s0)
	pkt->cursor.pos = backup->pos;
40015008:	01342823          	sw	s3,16(s0)
	pkt->overwrite = overwrite;
4001500c:	02f40ba3          	sb	a5,55(s0)
40015010:	01055513          	srli	a0,a0,0x10
}
40015014:	01c12083          	lw	ra,28(sp)
40015018:	01812403          	lw	s0,24(sp)
4001501c:	01412483          	lw	s1,20(sp)
40015020:	01012903          	lw	s2,16(sp)
40015024:	00c12983          	lw	s3,12(sp)
40015028:	00812a03          	lw	s4,8(sp)
4001502c:	00412a83          	lw	s5,4(sp)
40015030:	00012b03          	lw	s6,0(sp)
40015034:	02010113          	addi	sp,sp,32
40015038:	00008067          	ret
		bytes += buf->len;
4001503c:	0107d683          	lhu	a3,16(a5)
		buf = buf->frags;
40015040:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
40015044:	00d70733          	add	a4,a4,a3
		buf = buf->frags;
40015048:	eedff06f          	j	40014f34 <net_calc_chksum+0x44>
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
4001504c:	00200713          	li	a4,2
		return 0;
40015050:	00000513          	li	a0,0
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
40015054:	fce790e3          	bne	a5,a4,40015014 <net_calc_chksum+0x124>
		sum =  net_pkt_get_len(pkt) -
40015058:	00842783          	lw	a5,8(s0)
	size_t bytes = 0;
4001505c:	00000713          	li	a4,0
	while (buf) {
40015060:	02079463          	bnez	a5,40015088 <net_calc_chksum+0x198>
40015064:	03a45783          	lhu	a5,58(s0)
		len = 2 * sizeof(struct in6_addr);
40015068:	02000a93          	li	s5,32
		sum =  net_pkt_get_len(pkt) -
4001506c:	40f584b3          	sub	s1,a1,a5
			net_pkt_ip_hdr_len(pkt) -
40015070:	03644783          	lbu	a5,54(s0)
		sum =  net_pkt_get_len(pkt) -
40015074:	40f484b3          	sub	s1,s1,a5
40015078:	00e484b3          	add	s1,s1,a4
4001507c:	01049493          	slli	s1,s1,0x10
40015080:	0104d493          	srli	s1,s1,0x10
40015084:	ed5ff06f          	j	40014f58 <net_calc_chksum+0x68>
		bytes += buf->len;
40015088:	0107d683          	lhu	a3,16(a5)
		buf = buf->frags;
4001508c:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
40015090:	00d70733          	add	a4,a4,a3
		buf = buf->frags;
40015094:	fcdff06f          	j	40015060 <net_calc_chksum+0x170>
	uint16_t sum = 0U;
40015098:	00000493          	li	s1,0
	size_t len = 0U;
4001509c:	00000a93          	li	s5,0
400150a0:	eb9ff06f          	j	40014f58 <net_calc_chksum+0x68>
		sum = calc_chksum(sum, cur->pos, len);
400150a4:	01042583          	lw	a1,16(s0)
400150a8:	00048513          	mv	a0,s1
400150ac:	000a8613          	mv	a2,s5
400150b0:	c69ff0ef          	jal	ra,40014d18 <calc_chksum>
		cur->buf = cur->buf->frags;
400150b4:	004b2783          	lw	a5,4(s6)
		sum = calc_chksum(sum, cur->pos, len);
400150b8:	00050493          	mv	s1,a0
		cur->buf = cur->buf->frags;
400150bc:	00f42623          	sw	a5,12(s0)
		if (!cur->buf || !cur->buf->len) {
400150c0:	f0078ce3          	beqz	a5,40014fd8 <net_calc_chksum+0xe8>
400150c4:	0107d703          	lhu	a4,16(a5)
400150c8:	f00708e3          	beqz	a4,40014fd8 <net_calc_chksum+0xe8>
		cur->pos = cur->buf->data;
400150cc:	00c7a703          	lw	a4,12(a5)
		if (len % 2) {
400150d0:	001afa93          	andi	s5,s5,1
		cur->pos = cur->buf->data;
400150d4:	00e42823          	sw	a4,16(s0)
		if (len % 2) {
400150d8:	020a8c63          	beqz	s5,40015110 <net_calc_chksum+0x220>
			sum += *cur->pos;
400150dc:	00074683          	lbu	a3,0(a4)
400150e0:	00d504b3          	add	s1,a0,a3
400150e4:	01049493          	slli	s1,s1,0x10
400150e8:	0104d493          	srli	s1,s1,0x10
			if (sum < *cur->pos) {
400150ec:	00d4f863          	bgeu	s1,a3,400150fc <net_calc_chksum+0x20c>
				sum++;
400150f0:	00148493          	addi	s1,s1,1
400150f4:	01049493          	slli	s1,s1,0x10
400150f8:	0104d493          	srli	s1,s1,0x10
			cur->pos++;
400150fc:	00170713          	addi	a4,a4,1
40015100:	00e42823          	sw	a4,16(s0)
			len = cur->buf->len - 1;
40015104:	0107da83          	lhu	s5,16(a5)
40015108:	fffa8a93          	addi	s5,s5,-1
4001510c:	ec5ff06f          	j	40014fd0 <net_calc_chksum+0xe0>
			len = cur->buf->len;
40015110:	0107da83          	lhu	s5,16(a5)
40015114:	ebdff06f          	j	40014fd0 <net_calc_chksum+0xe0>
	sum = (sum == 0U) ? 0xffff : htons(sum);
40015118:	00010537          	lui	a0,0x10
4001511c:	fff50513          	addi	a0,a0,-1 # ffff <__kernel_ram_size+0x44f7>
40015120:	ed1ff06f          	j	40014ff0 <net_calc_chksum+0x100>

40015124 <net_calc_chksum_ipv4>:
{
40015124:	ff010113          	addi	sp,sp,-16
40015128:	00112623          	sw	ra,12(sp)
	sum = calc_chksum(0, pkt->buffer->data,
4001512c:	00852783          	lw	a5,8(a0)
			  net_pkt_ip_hdr_len(pkt) +
40015130:	03654603          	lbu	a2,54(a0)
			  net_pkt_ipv4_opts_len(pkt));
40015134:	03a54703          	lbu	a4,58(a0)
	sum = calc_chksum(0, pkt->buffer->data,
40015138:	00c7a583          	lw	a1,12(a5)
4001513c:	00000513          	li	a0,0
40015140:	00e60633          	add	a2,a2,a4
40015144:	bd5ff0ef          	jal	ra,40014d18 <calc_chksum>
	sum = (sum == 0U) ? 0xffff : htons(sum);
40015148:	02050863          	beqz	a0,40015178 <net_calc_chksum_ipv4+0x54>
4001514c:	00851793          	slli	a5,a0,0x8
40015150:	00855513          	srli	a0,a0,0x8
40015154:	00a7e533          	or	a0,a5,a0
40015158:	01051513          	slli	a0,a0,0x10
4001515c:	01055513          	srli	a0,a0,0x10
}
40015160:	00c12083          	lw	ra,12(sp)
	return ~sum;
40015164:	fff54513          	not	a0,a0
}
40015168:	01051513          	slli	a0,a0,0x10
4001516c:	01055513          	srli	a0,a0,0x10
40015170:	01010113          	addi	sp,sp,16
40015174:	00008067          	ret
	sum = (sum == 0U) ? 0xffff : htons(sum);
40015178:	00010537          	lui	a0,0x10
4001517c:	fff50513          	addi	a0,a0,-1 # ffff <__kernel_ram_size+0x44f7>
40015180:	fe1ff06f          	j	40015160 <net_calc_chksum_ipv4+0x3c>

40015184 <net_ipaddr_parse>:
	return false;
}
#endif /* CONFIG_NET_IPV4 */

bool net_ipaddr_parse(const char *str, size_t str_len, struct sockaddr *addr)
{
40015184:	fa010113          	addi	sp,sp,-96
40015188:	04112e23          	sw	ra,92(sp)
4001518c:	04812c23          	sw	s0,88(sp)
40015190:	04912a23          	sw	s1,84(sp)
40015194:	05212823          	sw	s2,80(sp)
40015198:	05312623          	sw	s3,76(sp)
4001519c:	05412423          	sw	s4,72(sp)
400151a0:	05512223          	sw	s5,68(sp)
	int i, count;

	if (!str || str_len == 0) {
400151a4:	0c050063          	beqz	a0,40015264 <net_ipaddr_parse+0xe0>
400151a8:	00058413          	mv	s0,a1
400151ac:	0a058c63          	beqz	a1,40015264 <net_ipaddr_parse+0xe0>
		return false;
	}

	/* We cannot accept empty string here */
	if (*str == '\0') {
400151b0:	00054783          	lbu	a5,0(a0)
400151b4:	00050a93          	mv	s5,a0
400151b8:	0a078663          	beqz	a5,40015264 <net_ipaddr_parse+0xe0>
		return false;
	}

	if (*str == '[') {
400151bc:	05b00713          	li	a4,91
400151c0:	00060913          	mv	s2,a2
400151c4:	04e78e63          	beq	a5,a4,40015220 <net_ipaddr_parse+0x9c>
		return parse_ipv6(str, str_len, addr, true);
	}

	for (count = i = 0; str[i] && i < str_len; i++) {
400151c8:	00000713          	li	a4,0
400151cc:	00000793          	li	a5,0
		if (str[i] == ':') {
400151d0:	03a00613          	li	a2,58
	for (count = i = 0; str[i] && i < str_len; i++) {
400151d4:	00fa86b3          	add	a3,s5,a5
400151d8:	0006c683          	lbu	a3,0(a3)
400151dc:	00068463          	beqz	a3,400151e4 <net_ipaddr_parse+0x60>
400151e0:	18879063          	bne	a5,s0,40015360 <net_ipaddr_parse+0x1dc>
			count++;
		}
	}

	if (count == 1) {
400151e4:	00100793          	li	a5,1
400151e8:	18f71463          	bne	a4,a5,40015370 <net_ipaddr_parse+0x1ec>
		return parse_ipv4(str, str_len, addr, true);
400151ec:	00040593          	mv	a1,s0

#if defined(CONFIG_NET_IPV6) && !defined(CONFIG_NET_IPV4)
	return parse_ipv6(str, str_len, addr, false);
#endif
	return false;
}
400151f0:	05812403          	lw	s0,88(sp)
400151f4:	05c12083          	lw	ra,92(sp)
400151f8:	05412483          	lw	s1,84(sp)
400151fc:	04c12983          	lw	s3,76(sp)
40015200:	04812a03          	lw	s4,72(sp)
		return parse_ipv4(str, str_len, addr, true);
40015204:	00090613          	mv	a2,s2
40015208:	000a8513          	mv	a0,s5
}
4001520c:	05012903          	lw	s2,80(sp)
40015210:	04412a83          	lw	s5,68(sp)
		return parse_ipv4(str, str_len, addr, true);
40015214:	00100693          	li	a3,1
}
40015218:	06010113          	addi	sp,sp,96
		return parse_ipv4(str, str_len, addr, true);
4001521c:	9bdff06f          	j	40014bd8 <parse_ipv4>
	len = MIN(INET6_ADDRSTRLEN, str_len);
40015220:	02e00713          	li	a4,46
40015224:	00058793          	mv	a5,a1
40015228:	00b77463          	bgeu	a4,a1,40015230 <net_ipaddr_parse+0xac>
4001522c:	02e00793          	li	a5,46
	for (i = 0; i < len; i++) {
40015230:	00000493          	li	s1,0
		if (!str[i]) {
40015234:	009a8733          	add	a4,s5,s1
40015238:	00074703          	lbu	a4,0(a4)
4001523c:	00070863          	beqz	a4,4001524c <net_ipaddr_parse+0xc8>
	for (i = 0; i < len; i++) {
40015240:	00148493          	addi	s1,s1,1
40015244:	fef4c8e3          	blt	s1,a5,40015234 <net_ipaddr_parse+0xb0>
	len = MIN(INET6_ADDRSTRLEN, str_len);
40015248:	00078493          	mv	s1,a5
		ptr = memchr(str, ']', len);
4001524c:	00048613          	mv	a2,s1
40015250:	05d00593          	li	a1,93
40015254:	000a8513          	mv	a0,s5
40015258:	ae5f70ef          	jal	ra,4000cd3c <memchr>
4001525c:	00050993          	mv	s3,a0
		if (!ptr) {
40015260:	00051663          	bnez	a0,4001526c <net_ipaddr_parse+0xe8>
		return false;
40015264:	00000493          	li	s1,0
40015268:	0640006f          	j	400152cc <net_ipaddr_parse+0x148>
		end = MIN(len, ptr - (str + 1));
4001526c:	001a8593          	addi	a1,s5,1
40015270:	40b50a33          	sub	s4,a0,a1
40015274:	0144d463          	bge	s1,s4,4001527c <net_ipaddr_parse+0xf8>
40015278:	00048a13          	mv	s4,s1
		memcpy(ipaddr, str + 1, end);
4001527c:	000a0613          	mv	a2,s4
40015280:	01010513          	addi	a0,sp,16
40015284:	a75f70ef          	jal	ra,4000ccf8 <memcpy>
	ipaddr[end] = '\0';
40015288:	040a0793          	addi	a5,s4,64
4001528c:	002787b3          	add	a5,a5,sp
40015290:	fc078823          	sb	zero,-48(a5)
40015294:	00200513          	li	a0,2
40015298:	00490613          	addi	a2,s2,4
4001529c:	01010593          	addi	a1,sp,16
400152a0:	e48ff0ef          	jal	ra,400148e8 <z_impl_net_addr_pton>
	if (ret < 0) {
400152a4:	fc0540e3          	bltz	a0,40015264 <net_ipaddr_parse+0xe0>
	net_sin6(addr)->sin6_family = AF_INET6;
400152a8:	00200793          	li	a5,2
400152ac:	00f91023          	sh	a5,0(s2)
	if ((ptr + 1) < (str + str_len) && *(ptr + 1) == ':') {
400152b0:	008a8ab3          	add	s5,s5,s0
400152b4:	00198793          	addi	a5,s3,1
400152b8:	0157f863          	bgeu	a5,s5,400152c8 <net_ipaddr_parse+0x144>
400152bc:	0019c703          	lbu	a4,1(s3)
400152c0:	03a00793          	li	a5,58
400152c4:	02f70863          	beq	a4,a5,400152f4 <net_ipaddr_parse+0x170>
		return true;
400152c8:	00100493          	li	s1,1
}
400152cc:	05c12083          	lw	ra,92(sp)
400152d0:	05812403          	lw	s0,88(sp)
400152d4:	05012903          	lw	s2,80(sp)
400152d8:	04c12983          	lw	s3,76(sp)
400152dc:	04812a03          	lw	s4,72(sp)
400152e0:	04412a83          	lw	s5,68(sp)
400152e4:	00048513          	mv	a0,s1
400152e8:	05412483          	lw	s1,84(sp)
400152ec:	06010113          	addi	sp,sp,96
400152f0:	00008067          	ret
		len = str_len - end - 1 - 2;
400152f4:	ffd40413          	addi	s0,s0,-3
400152f8:	41440433          	sub	s0,s0,s4
		ptr += 2;
400152fc:	00298593          	addi	a1,s3,2
		for (i = 0; i < len; i++) {
40015300:	00000493          	li	s1,0
40015304:	0484c463          	blt	s1,s0,4001534c <net_ipaddr_parse+0x1c8>
40015308:	00040493          	mv	s1,s0
		memcpy(ipaddr, ptr, len);
4001530c:	00048613          	mv	a2,s1
40015310:	01010513          	addi	a0,sp,16
40015314:	9e5f70ef          	jal	ra,4000ccf8 <memcpy>
		ipaddr[len] = '\0';
40015318:	04048793          	addi	a5,s1,64
4001531c:	002784b3          	add	s1,a5,sp
40015320:	fc048823          	sb	zero,-48(s1)
		ret = convert_port(ipaddr, &port);
40015324:	00e10593          	addi	a1,sp,14
40015328:	01010513          	addi	a0,sp,16
4001532c:	898ff0ef          	jal	ra,400143c4 <convert_port>
		if (!ret) {
40015330:	f2050ae3          	beqz	a0,40015264 <net_ipaddr_parse+0xe0>
		net_sin6(addr)->sin6_port = htons(port);
40015334:	00e15783          	lhu	a5,14(sp)
40015338:	00879713          	slli	a4,a5,0x8
4001533c:	0087d793          	srli	a5,a5,0x8
40015340:	00f767b3          	or	a5,a4,a5
40015344:	00f91123          	sh	a5,2(s2)
		NET_DBG("IPv6 host %s port %d",
40015348:	f81ff06f          	j	400152c8 <net_ipaddr_parse+0x144>
			if (!ptr[i]) {
4001534c:	009987b3          	add	a5,s3,s1
40015350:	0027c783          	lbu	a5,2(a5)
40015354:	fa078ce3          	beqz	a5,4001530c <net_ipaddr_parse+0x188>
		for (i = 0; i < len; i++) {
40015358:	00148493          	addi	s1,s1,1
4001535c:	fa9ff06f          	j	40015304 <net_ipaddr_parse+0x180>
		if (str[i] == ':') {
40015360:	00c69463          	bne	a3,a2,40015368 <net_ipaddr_parse+0x1e4>
			count++;
40015364:	00170713          	addi	a4,a4,1
	for (count = i = 0; str[i] && i < str_len; i++) {
40015368:	00178793          	addi	a5,a5,1
4001536c:	e69ff06f          	j	400151d4 <net_ipaddr_parse+0x50>
	if (!parse_ipv4(str, str_len, addr, false)) {
40015370:	00000693          	li	a3,0
40015374:	00090613          	mv	a2,s2
40015378:	00040593          	mv	a1,s0
4001537c:	000a8513          	mv	a0,s5
40015380:	859ff0ef          	jal	ra,40014bd8 <parse_ipv4>
40015384:	00050493          	mv	s1,a0
40015388:	f40512e3          	bnez	a0,400152cc <net_ipaddr_parse+0x148>
	len = MIN(INET6_ADDRSTRLEN, str_len);
4001538c:	02e00793          	li	a5,46
40015390:	0087f463          	bgeu	a5,s0,40015398 <net_ipaddr_parse+0x214>
40015394:	02e00413          	li	s0,46
	for (i = 0; i < len; i++) {
40015398:	00000993          	li	s3,0
		if (!str[i]) {
4001539c:	013a87b3          	add	a5,s5,s3
400153a0:	0007c783          	lbu	a5,0(a5)
400153a4:	00078863          	beqz	a5,400153b4 <net_ipaddr_parse+0x230>
	for (i = 0; i < len; i++) {
400153a8:	00198993          	addi	s3,s3,1
400153ac:	fe89c8e3          	blt	s3,s0,4001539c <net_ipaddr_parse+0x218>
	len = MIN(INET6_ADDRSTRLEN, str_len);
400153b0:	00040993          	mv	s3,s0
		memcpy(ipaddr, str, end);
400153b4:	00098613          	mv	a2,s3
400153b8:	000a8593          	mv	a1,s5
400153bc:	01010513          	addi	a0,sp,16
400153c0:	939f70ef          	jal	ra,4000ccf8 <memcpy>
	ipaddr[end] = '\0';
400153c4:	04098793          	addi	a5,s3,64
400153c8:	002789b3          	add	s3,a5,sp
400153cc:	fc098823          	sb	zero,-48(s3)
400153d0:	00200513          	li	a0,2
400153d4:	00490613          	addi	a2,s2,4
400153d8:	01010593          	addi	a1,sp,16
400153dc:	d0cff0ef          	jal	ra,400148e8 <z_impl_net_addr_pton>
	if (ret < 0) {
400153e0:	ee0546e3          	bltz	a0,400152cc <net_ipaddr_parse+0x148>
	net_sin6(addr)->sin6_family = AF_INET6;
400153e4:	00200793          	li	a5,2
400153e8:	00f91023          	sh	a5,0(s2)
400153ec:	eddff06f          	j	400152c8 <net_ipaddr_parse+0x144>

400153f0 <net_ipv4_unspecified_address>:

const struct in_addr *net_ipv4_unspecified_address(void)
{
	static const struct in_addr addr;

	return &addr;
400153f0:	40032537          	lui	a0,0x40032
}
400153f4:	60050513          	addi	a0,a0,1536 # 40032600 <addr.1>
400153f8:	00008067          	ret

400153fc <net_ipv4_broadcast_address>:

const struct in_addr *net_ipv4_broadcast_address(void)
{
	static const struct in_addr addr = { { { 255, 255, 255, 255 } } };

	return &addr;
400153fc:	40032537          	lui	a0,0x40032
}
40015400:	5fc50513          	addi	a0,a0,1532 # 400325fc <addr.0>
40015404:	00008067          	ret

40015408 <net_ipv6_unspecified_address>:
const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;

const struct in6_addr *net_ipv6_unspecified_address(void)
{
	return &in6addr_any;
40015408:	40035537          	lui	a0,0x40035
}
4001540c:	cac50513          	addi	a0,a0,-852 # 40034cac <in6addr_any>
40015410:	00008067          	ret

40015414 <k_mutex_unlock.isra.0>:
40015414:	1841a06f          	j	4002f598 <z_impl_k_mutex_unlock>

40015418 <mgmt_thread>:
	log_stack_usage(&mgmt_thread_data);
#endif
}

static void mgmt_thread(void)
{
40015418:	fc010113          	addi	sp,sp,-64
4001541c:	02912a23          	sw	s1,52(sp)
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
40015420:	000104b7          	lui	s1,0x10
{
40015424:	03212823          	sw	s2,48(sp)
40015428:	03312623          	sw	s3,44(sp)
4001542c:	03412423          	sw	s4,40(sp)
40015430:	02112e23          	sw	ra,60(sp)
40015434:	02812c23          	sw	s0,56(sp)
40015438:	03512223          	sw	s5,36(sp)
4001543c:	03612023          	sw	s6,32(sp)
40015440:	01712e23          	sw	s7,28(sp)
40015444:	01812c23          	sw	s8,24(sp)
	return z_impl_k_msgq_get(msgq, data, timeout);
40015448:	40045a37          	lui	s4,0x40045
	return z_impl_k_mutex_lock(mutex, timeout);
4001544c:	40045937          	lui	s2,0x40045
	return list->head;
40015450:	400399b7          	lui	s3,0x40039
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
40015454:	fff48493          	addi	s1,s1,-1 # ffff <__kernel_ram_size+0x44f7>
	return z_impl_k_msgq_get(msgq, data, timeout);
40015458:	fff00613          	li	a2,-1
4001545c:	fff00693          	li	a3,-1
40015460:	00810593          	addi	a1,sp,8
40015464:	898a0513          	addi	a0,s4,-1896 # 40044898 <event_msgq>
40015468:	661190ef          	jal	ra,4002f2c8 <z_impl_k_msgq_get>
	} while (k_msgq_get(&event_msgq, dst, K_FOREVER) != 0);
4001546c:	fe0516e3          	bnez	a0,40015458 <mgmt_thread+0x40>
	return z_impl_k_mutex_lock(mutex, timeout);
40015470:	fff00593          	li	a1,-1
40015474:	fff00613          	li	a2,-1
40015478:	85c90513          	addi	a0,s2,-1956 # 4004485c <net_mgmt_callback_lock>
4001547c:	7c1190ef          	jal	ra,4002f43c <z_impl_k_mutex_lock>
40015480:	0809a403          	lw	s0,128(s3) # 40039080 <event_callbacks>
40015484:	08098b13          	addi	s6,s3,128
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
40015488:	00040a63          	beqz	s0,4001549c <mgmt_thread+0x84>
	return node->next;
4001548c:	00042c03          	lw	s8,0(s0)
40015490:	00000b93          	li	s7,0
		if (NET_MGMT_EVENT_SYNCHRONOUS(cb->event_mask)) {
40015494:	08000ab7          	lui	s5,0x8000
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
40015498:	00041a63          	bnez	s0,400154ac <mgmt_thread+0x94>
		/* take the lock to prevent changes to the callback structure during use */
		(void)k_mutex_lock(&net_mgmt_callback_lock, K_FOREVER);

		mgmt_run_callbacks(&mgmt_event);

		(void)k_mutex_unlock(&net_mgmt_callback_lock);
4001549c:	85c90513          	addi	a0,s2,-1956
400154a0:	f75ff0ef          	jal	ra,40015414 <k_mutex_unlock.isra.0>
	z_impl_k_yield();
400154a4:	0a11b0ef          	jal	ra,40030d44 <z_impl_k_yield>
		mgmt_pop_event(&mgmt_event);
400154a8:	fb1ff06f          	j	40015458 <mgmt_thread+0x40>
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
400154ac:	00812583          	lw	a1,8(sp)
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
400154b0:	00842783          	lw	a5,8(s0)
400154b4:	00b7c733          	xor	a4,a5,a1
		      NET_MGMT_GET_LAYER_CODE(cb->event_mask)) ||
400154b8:	00b7c6b3          	xor	a3,a5,a1
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
400154bc:	01c75713          	srli	a4,a4,0x1c
		    !(NET_MGMT_GET_LAYER_CODE(mgmt_event->event) ==
400154c0:	0106d693          	srli	a3,a3,0x10
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
400154c4:	00377713          	andi	a4,a4,3
		    !(NET_MGMT_GET_LAYER_CODE(mgmt_event->event) ==
400154c8:	7ff6f693          	andi	a3,a3,2047
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
400154cc:	00d76733          	or	a4,a4,a3
400154d0:	06071463          	bnez	a4,40015538 <mgmt_thread+0x120>
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
400154d4:	0095f733          	and	a4,a1,s1
		      NET_MGMT_GET_LAYER_CODE(cb->event_mask)) ||
400154d8:	00070c63          	beqz	a4,400154f0 <mgmt_thread+0xd8>
		     NET_MGMT_GET_COMMAND(cb->event_mask) &&
400154dc:	0097f733          	and	a4,a5,s1
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
400154e0:	00070863          	beqz	a4,400154f0 <mgmt_thread+0xd8>
		     !(NET_MGMT_GET_COMMAND(mgmt_event->event) &
400154e4:	00f5f733          	and	a4,a1,a5
400154e8:	00977733          	and	a4,a4,s1
		     NET_MGMT_GET_COMMAND(cb->event_mask) &&
400154ec:	04070663          	beqz	a4,40015538 <mgmt_thread+0x120>
		if (NET_MGMT_EVENT_SYNCHRONOUS(cb->event_mask)) {
400154f0:	0157f7b3          	and	a5,a5,s5
			struct mgmt_event_wait *sync_data =
400154f4:	00442703          	lw	a4,4(s0)
			    sync_data->iface != mgmt_event->iface) {
400154f8:	00c12603          	lw	a2,12(sp)
		if (NET_MGMT_EVENT_SYNCHRONOUS(cb->event_mask)) {
400154fc:	06078463          	beqz	a5,40015564 <mgmt_thread+0x14c>
			if (sync_data->iface &&
40015500:	01872783          	lw	a5,24(a4)
40015504:	00078463          	beqz	a5,4001550c <mgmt_thread+0xf4>
40015508:	02c79863          	bne	a5,a2,40015538 <mgmt_thread+0x120>
			cb->raised_event = mgmt_event->event;
4001550c:	00b42423          	sw	a1,8(s0)
			sync_data->iface = mgmt_event->iface;
40015510:	00c72c23          	sw	a2,24(a4)
Z_GENLIST_REMOVE(slist, snode)
40015514:	00042783          	lw	a5,0(s0)
40015518:	020b9c63          	bnez	s7,40015550 <mgmt_thread+0x138>
4001551c:	004b2703          	lw	a4,4(s6)
	list->head = node;
40015520:	00fb2023          	sw	a5,0(s6)
Z_GENLIST_REMOVE(slist, snode)
40015524:	00e41463          	bne	s0,a4,4001552c <mgmt_thread+0x114>
	list->tail = node;
40015528:	00fb2223          	sw	a5,4(s6)
			k_sem_give(cb->sync_call);
4001552c:	00442503          	lw	a0,4(s0)
	parent->next = child;
40015530:	00042023          	sw	zero,0(s0)
	z_impl_k_sem_give(sem);
40015534:	4041a0ef          	jal	ra,4002f938 <z_impl_k_sem_give>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
40015538:	00000793          	li	a5,0
4001553c:	000c0463          	beqz	s8,40015544 <mgmt_thread+0x12c>
	return node->next;
40015540:	000c2783          	lw	a5,0(s8)
40015544:	000c0413          	mv	s0,s8
40015548:	00078c13          	mv	s8,a5
4001554c:	f4dff06f          	j	40015498 <mgmt_thread+0x80>
	parent->next = child;
40015550:	00fba023          	sw	a5,0(s7)
Z_GENLIST_REMOVE(slist, snode)
40015554:	004b2783          	lw	a5,4(s6)
40015558:	fcf41ae3          	bne	s0,a5,4001552c <mgmt_thread+0x114>
	list->tail = node;
4001555c:	017b2223          	sw	s7,4(s6)
}
40015560:	fcdff06f          	j	4001552c <mgmt_thread+0x114>
			cb->handler(cb, mgmt_event->event, mgmt_event->iface);
40015564:	00040513          	mv	a0,s0
40015568:	000700e7          	jalr	a4
			prev = &cb->node;
4001556c:	00040b93          	mv	s7,s0
40015570:	fc9ff06f          	j	40015538 <mgmt_thread+0x120>

40015574 <net_mgmt_add_event_callback>:

	return ret;
}

void net_mgmt_add_event_callback(struct net_mgmt_event_callback *cb)
{
40015574:	ff010113          	addi	sp,sp,-16
40015578:	00812423          	sw	s0,8(sp)
4001557c:	00112623          	sw	ra,12(sp)
40015580:	00912223          	sw	s1,4(sp)
40015584:	00050413          	mv	s0,a0
	return z_impl_k_mutex_lock(mutex, timeout);
40015588:	400454b7          	lui	s1,0x40045
4001558c:	fff00593          	li	a1,-1
40015590:	fff00613          	li	a2,-1
40015594:	85c48513          	addi	a0,s1,-1956 # 4004485c <net_mgmt_callback_lock>
40015598:	6a5190ef          	jal	ra,4002f43c <z_impl_k_mutex_lock>
	return list->head;
4001559c:	400397b7          	lui	a5,0x40039
400155a0:	08078793          	addi	a5,a5,128 # 40039080 <event_callbacks>
400155a4:	0007a703          	lw	a4,0(a5)
	parent->next = child;
400155a8:	00e42023          	sw	a4,0(s0)
Z_GENLIST_PREPEND(slist, snode)
400155ac:	0047a703          	lw	a4,4(a5)
	list->head = node;
400155b0:	0087a023          	sw	s0,0(a5)
Z_GENLIST_PREPEND(slist, snode)
400155b4:	00071463          	bnez	a4,400155bc <net_mgmt_add_event_callback+0x48>
	list->tail = node;
400155b8:	0087a223          	sw	s0,4(a5)
	global_event_mask |= event_mask;
400155bc:	40039737          	lui	a4,0x40039
400155c0:	00842783          	lw	a5,8(s0)
400155c4:	08872683          	lw	a3,136(a4) # 40039088 <global_event_mask>
	sys_slist_prepend(&event_callbacks, &cb->node);

	mgmt_add_event_mask(cb->event_mask);

	(void)k_mutex_unlock(&net_mgmt_callback_lock);
}
400155c8:	00812403          	lw	s0,8(sp)
400155cc:	00c12083          	lw	ra,12(sp)
	global_event_mask |= event_mask;
400155d0:	00d7e7b3          	or	a5,a5,a3
	(void)k_mutex_unlock(&net_mgmt_callback_lock);
400155d4:	85c48513          	addi	a0,s1,-1956
}
400155d8:	00412483          	lw	s1,4(sp)
	global_event_mask |= event_mask;
400155dc:	08f72423          	sw	a5,136(a4)
}
400155e0:	01010113          	addi	sp,sp,16
	(void)k_mutex_unlock(&net_mgmt_callback_lock);
400155e4:	e31ff06f          	j	40015414 <k_mutex_unlock.isra.0>

400155e8 <net_mgmt_del_event_callback>:

void net_mgmt_del_event_callback(struct net_mgmt_event_callback *cb)
{
400155e8:	ff010113          	addi	sp,sp,-16
400155ec:	00812423          	sw	s0,8(sp)
400155f0:	00112623          	sw	ra,12(sp)
400155f4:	00912223          	sw	s1,4(sp)
400155f8:	00050413          	mv	s0,a0
400155fc:	400454b7          	lui	s1,0x40045
40015600:	fff00593          	li	a1,-1
40015604:	fff00613          	li	a2,-1
40015608:	85c48513          	addi	a0,s1,-1956 # 4004485c <net_mgmt_callback_lock>
4001560c:	631190ef          	jal	ra,4002f43c <z_impl_k_mutex_lock>
	return list->head;
40015610:	400397b7          	lui	a5,0x40039
40015614:	0807a703          	lw	a4,128(a5) # 40039080 <event_callbacks>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40015618:	00000693          	li	a3,0
4001561c:	08078793          	addi	a5,a5,128
40015620:	02070263          	beqz	a4,40015644 <net_mgmt_del_event_callback+0x5c>
40015624:	06e41c63          	bne	s0,a4,4001569c <net_mgmt_del_event_callback+0xb4>
	return node->next;
40015628:	00042703          	lw	a4,0(s0)
Z_GENLIST_REMOVE(slist, snode)
4001562c:	04069e63          	bnez	a3,40015688 <net_mgmt_del_event_callback+0xa0>
40015630:	0047a683          	lw	a3,4(a5)
	list->head = node;
40015634:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_REMOVE(slist, snode)
40015638:	00d41463          	bne	s0,a3,40015640 <net_mgmt_del_event_callback+0x58>
	list->tail = node;
4001563c:	00e7a223          	sw	a4,4(a5)
	parent->next = child;
40015640:	00042023          	sw	zero,0(s0)
	return list->head;
40015644:	0007a783          	lw	a5,0(a5)
	global_event_mask = 0U;
40015648:	40039637          	lui	a2,0x40039
4001564c:	08062423          	sw	zero,136(a2) # 40039088 <global_event_mask>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
40015650:	00000713          	li	a4,0
40015654:	00078463          	beqz	a5,4001565c <net_mgmt_del_event_callback+0x74>
	return node->next;
40015658:	0007a703          	lw	a4,0(a5)
4001565c:	00000593          	li	a1,0
40015660:	00000693          	li	a3,0
40015664:	04079263          	bnez	a5,400156a8 <net_mgmt_del_event_callback+0xc0>
40015668:	00058463          	beqz	a1,40015670 <net_mgmt_del_event_callback+0x88>
4001566c:	08d62423          	sw	a3,136(a2)
	sys_slist_find_and_remove(&event_callbacks, &cb->node);

	mgmt_rebuild_global_event_mask();

	(void)k_mutex_unlock(&net_mgmt_callback_lock);
}
40015670:	00812403          	lw	s0,8(sp)
40015674:	00c12083          	lw	ra,12(sp)
	(void)k_mutex_unlock(&net_mgmt_callback_lock);
40015678:	85c48513          	addi	a0,s1,-1956
}
4001567c:	00412483          	lw	s1,4(sp)
40015680:	01010113          	addi	sp,sp,16
	(void)k_mutex_unlock(&net_mgmt_callback_lock);
40015684:	d91ff06f          	j	40015414 <k_mutex_unlock.isra.0>
	parent->next = child;
40015688:	00e6a023          	sw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
4001568c:	0047a703          	lw	a4,4(a5)
40015690:	fae418e3          	bne	s0,a4,40015640 <net_mgmt_del_event_callback+0x58>
	list->tail = node;
40015694:	00d7a223          	sw	a3,4(a5)
}
40015698:	fa9ff06f          	j	40015640 <net_mgmt_del_event_callback+0x58>
	return node->next;
4001569c:	00070693          	mv	a3,a4
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
400156a0:	00072703          	lw	a4,0(a4)
400156a4:	f7dff06f          	j	40015620 <net_mgmt_del_event_callback+0x38>
	global_event_mask |= event_mask;
400156a8:	0087a783          	lw	a5,8(a5)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
400156ac:	00000593          	li	a1,0
	global_event_mask |= event_mask;
400156b0:	00f6e6b3          	or	a3,a3,a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
400156b4:	00070463          	beqz	a4,400156bc <net_mgmt_del_event_callback+0xd4>
	return node->next;
400156b8:	00072583          	lw	a1,0(a4)
400156bc:	00070793          	mv	a5,a4
400156c0:	00058713          	mv	a4,a1
400156c4:	00100593          	li	a1,1
400156c8:	f9dff06f          	j	40015664 <net_mgmt_del_event_callback+0x7c>

400156cc <net_mgmt_event_notify_with_info>:
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
400156cc:	400397b7          	lui	a5,0x40039
400156d0:	0887a703          	lw	a4,136(a5) # 40039088 <global_event_mask>
	return (((NET_MGMT_GET_LAYER(mgmt_event) &
400156d4:	01c55693          	srli	a3,a0,0x1c
		((NET_MGMT_GET_LAYER_CODE(mgmt_event) &
400156d8:	01055613          	srli	a2,a0,0x10
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
400156dc:	01c75793          	srli	a5,a4,0x1c
400156e0:	fff7c793          	not	a5,a5
400156e4:	00d7f7b3          	and	a5,a5,a3
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
400156e8:	01075693          	srli	a3,a4,0x10
400156ec:	fff6c693          	not	a3,a3
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
400156f0:	fff74713          	not	a4,a4
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
400156f4:	00c6f6b3          	and	a3,a3,a2
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
400156f8:	00a77733          	and	a4,a4,a0
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
400156fc:	0037f793          	andi	a5,a5,3
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
40015700:	7ff6f693          	andi	a3,a3,2047
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
40015704:	01071713          	slli	a4,a4,0x10
		 NET_MGMT_GET_LAYER_CODE(mgmt_event)) &&
40015708:	00d7e7b3          	or	a5,a5,a3
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
4001570c:	01075713          	srli	a4,a4,0x10
		 NET_MGMT_GET_LAYER_CODE(mgmt_event)) &&
40015710:	00e7e7b3          	or	a5,a5,a4
40015714:	0e079c63          	bnez	a5,4001580c <net_mgmt_event_notify_with_info+0x140>

void net_mgmt_event_notify_with_info(uint32_t mgmt_event, struct net_if *iface,
				     const void *info, size_t length)
{
40015718:	fe010113          	addi	sp,sp,-32
4001571c:	00812c23          	sw	s0,24(sp)
40015720:	00912a23          	sw	s1,20(sp)
40015724:	01312623          	sw	s3,12(sp)
40015728:	00112e23          	sw	ra,28(sp)
4001572c:	01212823          	sw	s2,16(sp)
40015730:	01412423          	sw	s4,8(sp)
40015734:	02010413          	addi	s0,sp,32
40015738:	00050493          	mv	s1,a0
4001573c:	00058993          	mv	s3,a1
40015740:	40045a37          	lui	s4,0x40045
40015744:	fff00593          	li	a1,-1
40015748:	fff00613          	li	a2,-1
4001574c:	870a0513          	addi	a0,s4,-1936 # 40044870 <net_mgmt_event_lock>
40015750:	4ed190ef          	jal	ra,4002f43c <z_impl_k_mutex_lock>
	memset(&new_event, 0, sizeof(struct mgmt_event_entry));
40015754:	40039937          	lui	s2,0x40039
40015758:	00800613          	li	a2,8
4001575c:	00000593          	li	a1,0
40015760:	07890513          	addi	a0,s2,120 # 40039078 <new_event>
40015764:	db8f70ef          	jal	ra,4000cd1c <memset>
	new_event.event = mgmt_event;
40015768:	07890793          	addi	a5,s2,120
4001576c:	0097a023          	sw	s1,0(a5)
	new_event.iface = iface;
40015770:	0137a223          	sw	s3,4(a5)
	return z_impl_k_msgq_put(msgq, data, timeout);
40015774:	40045537          	lui	a0,0x40045
40015778:	00100613          	li	a2,1
4001577c:	00000693          	li	a3,0
40015780:	07890593          	addi	a1,s2,120
40015784:	89850513          	addi	a0,a0,-1896 # 40044898 <event_msgq>
40015788:	221190ef          	jal	ra,4002f1a8 <z_impl_k_msgq_put>
	if (k_msgq_put(&event_msgq, &new_event,
4001578c:	04050a63          	beqz	a0,400157e0 <net_mgmt_event_notify_with_info+0x114>
		NET_WARN("Failure to push event (%u), "
40015790:	40044537          	lui	a0,0x40044
40015794:	78052783          	lw	a5,1920(a0) # 40044780 <log_dynamic_net_mgmt>
40015798:	0067f793          	andi	a5,a5,6
4001579c:	04078263          	beqz	a5,400157e0 <net_mgmt_event_notify_with_info+0x114>
400157a0:	00010913          	mv	s2,sp
400157a4:	fe010113          	addi	sp,sp,-32
400157a8:	00010613          	mv	a2,sp
400157ac:	400357b7          	lui	a5,0x40035
400157b0:	cbc78793          	addi	a5,a5,-836 # 40034cbc <in6addr_any+0x10>
400157b4:	00f62a23          	sw	a5,20(a2)
400157b8:	00300793          	li	a5,3
400157bc:	00962c23          	sw	s1,24(a2)
400157c0:	00f62823          	sw	a5,16(a2)
400157c4:	000025b7          	lui	a1,0x2
400157c8:	00000693          	li	a3,0
400157cc:	01060613          	addi	a2,a2,16
400157d0:	88058593          	addi	a1,a1,-1920 # 1880 <CONFIG_HEAP_MEM_POOL_SIZE+0x880>
400157d4:	78050513          	addi	a0,a0,1920
400157d8:	fbcef0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
400157dc:	00090113          	mv	sp,s2
	(void)k_mutex_unlock(&net_mgmt_event_lock);
400157e0:	870a0513          	addi	a0,s4,-1936
400157e4:	c31ff0ef          	jal	ra,40015414 <k_mutex_unlock.isra.0>
			NET_MGMT_GET_LAYER_CODE(mgmt_event),
			NET_MGMT_GET_COMMAND(mgmt_event));

		mgmt_push_event(mgmt_event, iface, info, length);
	}
}
400157e8:	fe040113          	addi	sp,s0,-32
400157ec:	01c12083          	lw	ra,28(sp)
400157f0:	01812403          	lw	s0,24(sp)
400157f4:	01412483          	lw	s1,20(sp)
400157f8:	01012903          	lw	s2,16(sp)
400157fc:	00c12983          	lw	s3,12(sp)
40015800:	00812a03          	lw	s4,8(sp)
40015804:	02010113          	addi	sp,sp,32
40015808:	00008067          	ret
4001580c:	00008067          	ret

40015810 <net_mgmt_event_init>:
				    raised_event, NULL, info, info_length,
				    timeout);
}

void net_mgmt_event_init(void)
{
40015810:	fe010113          	addi	sp,sp,-32
40015814:	00112e23          	sw	ra,28(sp)
40015818:	00812c23          	sw	s0,24(sp)
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
4001581c:	00000793          	li	a5,0
40015820:	00000813          	li	a6,0
40015824:	4003a437          	lui	s0,0x4003a
40015828:	400156b7          	lui	a3,0x40015
4001582c:	4003c5b7          	lui	a1,0x4003c
40015830:	01012623          	sw	a6,12(sp)
40015834:	00f12423          	sw	a5,8(sp)
40015838:	00012023          	sw	zero,0(sp)
4001583c:	fff00893          	li	a7,-1
40015840:	00000813          	li	a6,0
40015844:	00000713          	li	a4,0
40015848:	41868693          	addi	a3,a3,1048 # 40015418 <mgmt_thread>
4001584c:	30000613          	li	a2,768
40015850:	cf058593          	addi	a1,a1,-784 # 4003bcf0 <mgmt_stack>
40015854:	a3040513          	addi	a0,s0,-1488 # 40039a30 <mgmt_thread_data>
40015858:	758190ef          	jal	ra,4002efb0 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
4001585c:	a3040513          	addi	a0,s0,-1488
	k_thread_name_set(&mgmt_thread_data, "net_mgmt");

	NET_DBG("Net MGMT initialized: queue of %u entries, stack size of %u",
		CONFIG_NET_MGMT_EVENT_QUEUE_SIZE,
		CONFIG_NET_MGMT_EVENT_STACK_SIZE);
}
40015860:	01812403          	lw	s0,24(sp)
40015864:	01c12083          	lw	ra,28(sp)
40015868:	400355b7          	lui	a1,0x40035
4001586c:	d4058593          	addi	a1,a1,-704 # 40034d40 <in6addr_any+0x94>
40015870:	02010113          	addi	sp,sp,32
40015874:	4701906f          	j	4002ece4 <z_impl_k_thread_name_set>

40015878 <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
40015878:	00054503          	lbu	a0,0(a0)
4001587c:	f00007b7          	lui	a5,0xf0000
40015880:	01851513          	slli	a0,a0,0x18
40015884:	00f57533          	and	a0,a0,a5
40015888:	200007b7          	lui	a5,0x20000
4001588c:	00f50533          	add	a0,a0,a5
}
40015890:	00153513          	seqz	a0,a0
40015894:	00008067          	ret

40015898 <net_ipv6_is_addr_unspecified>:
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40015898:	00154703          	lbu	a4,1(a0)
4001589c:	00054683          	lbu	a3,0(a0)
{
400158a0:	00050793          	mv	a5,a0
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
400158a4:	00871713          	slli	a4,a4,0x8
400158a8:	00d76733          	or	a4,a4,a3
400158ac:	00254683          	lbu	a3,2(a0)
400158b0:	01069693          	slli	a3,a3,0x10
400158b4:	00e6e6b3          	or	a3,a3,a4
400158b8:	00354703          	lbu	a4,3(a0)
400158bc:	01871713          	slli	a4,a4,0x18
400158c0:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
400158c4:	08071863          	bnez	a4,40015954 <net_ipv6_is_addr_unspecified+0xbc>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
400158c8:	00554703          	lbu	a4,5(a0)
400158cc:	00454683          	lbu	a3,4(a0)
400158d0:	00871713          	slli	a4,a4,0x8
400158d4:	00d76733          	or	a4,a4,a3
400158d8:	00654683          	lbu	a3,6(a0)
400158dc:	01069693          	slli	a3,a3,0x10
400158e0:	00e6e6b3          	or	a3,a3,a4
400158e4:	00754703          	lbu	a4,7(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
400158e8:	00000513          	li	a0,0
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
400158ec:	01871713          	slli	a4,a4,0x18
400158f0:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
400158f4:	06071263          	bnez	a4,40015958 <net_ipv6_is_addr_unspecified+0xc0>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
400158f8:	0097c703          	lbu	a4,9(a5) # 20000009 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1a0a1f09>
400158fc:	0087c683          	lbu	a3,8(a5)
40015900:	00871713          	slli	a4,a4,0x8
40015904:	00d76733          	or	a4,a4,a3
40015908:	00a7c683          	lbu	a3,10(a5)
4001590c:	01069693          	slli	a3,a3,0x10
40015910:	00e6e6b3          	or	a3,a3,a4
40015914:	00b7c703          	lbu	a4,11(a5)
40015918:	01871713          	slli	a4,a4,0x18
4001591c:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
40015920:	02071c63          	bnez	a4,40015958 <net_ipv6_is_addr_unspecified+0xc0>
		UNALIGNED_GET(&addr->s6_addr32[3]) == 0;
40015924:	00d7c683          	lbu	a3,13(a5)
40015928:	00c7c703          	lbu	a4,12(a5)
4001592c:	00f7c503          	lbu	a0,15(a5)
40015930:	00869693          	slli	a3,a3,0x8
40015934:	00e6e6b3          	or	a3,a3,a4
40015938:	00e7c703          	lbu	a4,14(a5)
4001593c:	01851513          	slli	a0,a0,0x18
40015940:	01071713          	slli	a4,a4,0x10
40015944:	00d76733          	or	a4,a4,a3
40015948:	00e56533          	or	a0,a0,a4
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001594c:	00153513          	seqz	a0,a0
40015950:	00008067          	ret
40015954:	00000513          	li	a0,0
}
40015958:	00008067          	ret

4001595c <check_used_port>:
#if defined(CONFIG_NET_UDP) || defined(CONFIG_NET_TCP)
static int check_used_port(enum net_ip_protocol proto,
			   uint16_t local_port,
			   const struct sockaddr *local_addr)

{
4001595c:	fe010113          	addi	sp,sp,-32
40015960:	00812c23          	sw	s0,24(sp)
40015964:	4003a437          	lui	s0,0x4003a
40015968:	78840413          	addi	s0,s0,1928 # 4003a788 <contexts>
4001596c:	00912a23          	sw	s1,20(sp)
40015970:	01212823          	sw	s2,16(sp)
40015974:	01312623          	sw	s3,12(sp)
40015978:	01412423          	sw	s4,8(sp)
4001597c:	01512223          	sw	s5,4(sp)
40015980:	01612023          	sw	s6,0(sp)
40015984:	00112e23          	sw	ra,28(sp)
40015988:	00050913          	mv	s2,a0
4001598c:	00058993          	mv	s3,a1
40015990:	00060493          	mv	s1,a2
40015994:	4b040a13          	addi	s4,s0,1200
		      net_sin((struct sockaddr *)&
			      contexts[i].local)->sin_port == local_port)) {
			continue;
		}

		if (IS_ENABLED(CONFIG_NET_IPV6) &&
40015998:	00200a93          	li	s5,2
							     sin6_addr,
				    &((struct sockaddr_in6 *)
				      local_addr)->sin6_addr)) {
				return -EEXIST;
			}
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
4001599c:	00100b13          	li	s6,1
	return context->flags & NET_CONTEXT_IN_USE;
400159a0:	07445783          	lhu	a5,116(s0)
		if (!net_context_is_used(&contexts[i])) {
400159a4:	0017f793          	andi	a5,a5,1
400159a8:	02079c63          	bnez	a5,400159e0 <check_used_port+0x84>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
400159ac:	07840413          	addi	s0,s0,120
400159b0:	fe8a18e3          	bne	s4,s0,400159a0 <check_used_port+0x44>
				return -EEXIST;
			}
		}
	}

	return 0;
400159b4:	00000513          	li	a0,0
}
400159b8:	01c12083          	lw	ra,28(sp)
400159bc:	01812403          	lw	s0,24(sp)
400159c0:	01412483          	lw	s1,20(sp)
400159c4:	01012903          	lw	s2,16(sp)
400159c8:	00c12983          	lw	s3,12(sp)
400159cc:	00812a03          	lw	s4,8(sp)
400159d0:	00412a83          	lw	s5,4(sp)
400159d4:	00012b03          	lw	s6,0(sp)
400159d8:	02010113          	addi	sp,sp,32
400159dc:	00008067          	ret
		if (!(net_context_get_proto(&contexts[i]) == proto &&
400159e0:	07245783          	lhu	a5,114(s0)
400159e4:	fd2794e3          	bne	a5,s2,400159ac <check_used_port+0x50>
400159e8:	02245783          	lhu	a5,34(s0)
400159ec:	fd3790e3          	bne	a5,s3,400159ac <check_used_port+0x50>
		    local_addr->sa_family == AF_INET6) {
400159f0:	0004d783          	lhu	a5,0(s1)
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
400159f4:	03579263          	bne	a5,s5,40015a18 <check_used_port+0xbc>
			if (net_sin6_ptr(&contexts[i].local)->sin6_addr == NULL) {
400159f8:	02442503          	lw	a0,36(s0)
400159fc:	fa0508e3          	beqz	a0,400159ac <check_used_port+0x50>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
40015a00:	01000613          	li	a2,16
40015a04:	00448593          	addi	a1,s1,4
40015a08:	a70f70ef          	jal	ra,4000cc78 <memcmp>
			if (net_ipv6_addr_cmp(
40015a0c:	fa0510e3          	bnez	a0,400159ac <check_used_port+0x50>
				return -EEXIST;
40015a10:	fef00513          	li	a0,-17
40015a14:	fa5ff06f          	j	400159b8 <check_used_port+0x5c>
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40015a18:	f9679ae3          	bne	a5,s6,400159ac <check_used_port+0x50>
			if (net_sin_ptr(&contexts[i].local)->sin_addr == NULL) {
40015a1c:	02442783          	lw	a5,36(s0)
40015a20:	f80786e3          	beqz	a5,400159ac <check_used_port+0x50>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40015a24:	0054c703          	lbu	a4,5(s1)
40015a28:	0044c683          	lbu	a3,4(s1)
40015a2c:	0017c603          	lbu	a2,1(a5)
40015a30:	00871713          	slli	a4,a4,0x8
40015a34:	00d76733          	or	a4,a4,a3
40015a38:	0064c683          	lbu	a3,6(s1)
40015a3c:	00861613          	slli	a2,a2,0x8
40015a40:	01069693          	slli	a3,a3,0x10
40015a44:	00e6e6b3          	or	a3,a3,a4
40015a48:	0074c703          	lbu	a4,7(s1)
40015a4c:	01871713          	slli	a4,a4,0x18
40015a50:	00d76733          	or	a4,a4,a3
40015a54:	0007c683          	lbu	a3,0(a5)
40015a58:	00d66633          	or	a2,a2,a3
40015a5c:	0027c683          	lbu	a3,2(a5)
40015a60:	0037c783          	lbu	a5,3(a5)
40015a64:	01069693          	slli	a3,a3,0x10
40015a68:	00c6e6b3          	or	a3,a3,a2
40015a6c:	01879793          	slli	a5,a5,0x18
40015a70:	00d7e7b3          	or	a5,a5,a3
			if (net_ipv4_addr_cmp(
40015a74:	f2f71ce3          	bne	a4,a5,400159ac <check_used_port+0x50>
40015a78:	f99ff06f          	j	40015a10 <check_used_port+0xb4>

40015a7c <find_available_port>:

static uint16_t find_available_port(struct net_context *context,
				    const struct sockaddr *addr)
{
40015a7c:	fe010113          	addi	sp,sp,-32
40015a80:	00912a23          	sw	s1,20(sp)
40015a84:	01212823          	sw	s2,16(sp)
40015a88:	01312623          	sw	s3,12(sp)
40015a8c:	01412423          	sw	s4,8(sp)
40015a90:	00112e23          	sw	ra,28(sp)
40015a94:	00812c23          	sw	s0,24(sp)
40015a98:	00050493          	mv	s1,a0
40015a9c:	00058913          	mv	s2,a1
	uint16_t local_port;

	do {
		local_port = sys_rand32_get() | 0x8000;
40015aa0:	ffff8a37          	lui	s4,0xffff8
	} while (check_used_port(net_context_get_proto(context),
				 htons(local_port), addr) == -EEXIST);
40015aa4:	fef00993          	li	s3,-17
40015aa8:	f78f70ef          	jal	ra,4000d220 <z_impl_sys_rand32_get>
		local_port = sys_rand32_get() | 0x8000;
40015aac:	014567b3          	or	a5,a0,s4
40015ab0:	00879413          	slli	s0,a5,0x8
40015ab4:	01079793          	slli	a5,a5,0x10
40015ab8:	0107d793          	srli	a5,a5,0x10
40015abc:	0087d793          	srli	a5,a5,0x8
40015ac0:	00f46433          	or	s0,s0,a5
40015ac4:	01041413          	slli	s0,s0,0x10
	} while (check_used_port(net_context_get_proto(context),
40015ac8:	0724d503          	lhu	a0,114(s1)
40015acc:	01045413          	srli	s0,s0,0x10
40015ad0:	00090613          	mv	a2,s2
40015ad4:	00040593          	mv	a1,s0
40015ad8:	e85ff0ef          	jal	ra,4001595c <check_used_port>
				 htons(local_port), addr) == -EEXIST);
40015adc:	fd3506e3          	beq	a0,s3,40015aa8 <find_available_port+0x2c>

	return htons(local_port);
}
40015ae0:	01c12083          	lw	ra,28(sp)
40015ae4:	00040513          	mv	a0,s0
40015ae8:	01812403          	lw	s0,24(sp)
40015aec:	01412483          	lw	s1,20(sp)
40015af0:	01012903          	lw	s2,16(sp)
40015af4:	00c12983          	lw	s3,12(sp)
40015af8:	00812a03          	lw	s4,8(sp)
40015afc:	02010113          	addi	sp,sp,32
40015b00:	00008067          	ret

40015b04 <context_write_data>:
static int context_write_data(struct net_pkt *pkt, const void *buf,
			      int buf_len, const struct msghdr *msghdr)
{
	int ret = 0;

	if (msghdr) {
40015b04:	06069463          	bnez	a3,40015b6c <context_write_data+0x68>
			if (buf_len == 0) {
				break;
			}
		}
	} else {
		ret = net_pkt_write(pkt, buf, buf_len);
40015b08:	57d0206f          	j	40018884 <net_pkt_write>
			int len = MIN(msghdr->msg_iov[i].iov_len, buf_len);
40015b0c:	0084a783          	lw	a5,8(s1)
40015b10:	00391713          	slli	a4,s2,0x3
40015b14:	00e787b3          	add	a5,a5,a4
40015b18:	0047a983          	lw	s3,4(a5)
40015b1c:	01347463          	bgeu	s0,s3,40015b24 <context_write_data+0x20>
40015b20:	00040993          	mv	s3,s0
			ret = net_pkt_write(pkt, msghdr->msg_iov[i].iov_base,
40015b24:	0007a583          	lw	a1,0(a5)
40015b28:	00098613          	mv	a2,s3
40015b2c:	000a0513          	mv	a0,s4
40015b30:	555020ef          	jal	ra,40018884 <net_pkt_write>
			if (ret < 0) {
40015b34:	00054c63          	bltz	a0,40015b4c <context_write_data+0x48>
			buf_len -= len;
40015b38:	41340433          	sub	s0,s0,s3
			if (buf_len == 0) {
40015b3c:	00040863          	beqz	s0,40015b4c <context_write_data+0x48>
		for (i = 0; i < msghdr->msg_iovlen; i++) {
40015b40:	00190913          	addi	s2,s2,1
40015b44:	00c4a783          	lw	a5,12(s1)
40015b48:	fcf962e3          	bltu	s2,a5,40015b0c <context_write_data+0x8>
	}

	return ret;
}
40015b4c:	01c12083          	lw	ra,28(sp)
40015b50:	01812403          	lw	s0,24(sp)
40015b54:	01412483          	lw	s1,20(sp)
40015b58:	01012903          	lw	s2,16(sp)
40015b5c:	00c12983          	lw	s3,12(sp)
40015b60:	00812a03          	lw	s4,8(sp)
40015b64:	02010113          	addi	sp,sp,32
40015b68:	00008067          	ret
{
40015b6c:	fe010113          	addi	sp,sp,-32
40015b70:	00812c23          	sw	s0,24(sp)
40015b74:	00912a23          	sw	s1,20(sp)
40015b78:	01212823          	sw	s2,16(sp)
40015b7c:	01412423          	sw	s4,8(sp)
40015b80:	00112e23          	sw	ra,28(sp)
40015b84:	00050a13          	mv	s4,a0
40015b88:	01312623          	sw	s3,12(sp)
40015b8c:	00060413          	mv	s0,a2
40015b90:	00068493          	mv	s1,a3
		for (i = 0; i < msghdr->msg_iovlen; i++) {
40015b94:	00000913          	li	s2,0
	int ret = 0;
40015b98:	00000513          	li	a0,0
40015b9c:	fa9ff06f          	j	40015b44 <context_write_data+0x40>

40015ba0 <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
40015ba0:	09d1906f          	j	4002f43c <z_impl_k_mutex_lock>

40015ba4 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
40015ba4:	1f51906f          	j	4002f598 <z_impl_k_mutex_unlock>

40015ba8 <net_context_packet_received>:
enum net_verdict net_context_packet_received(struct net_conn *conn,
					     struct net_pkt *pkt,
					     union net_ip_header *ip_hdr,
					     union net_proto_header *proto_hdr,
					     void *user_data)
{
40015ba8:	fd010113          	addi	sp,sp,-48
40015bac:	02812423          	sw	s0,40(sp)
40015bb0:	4003a437          	lui	s0,0x4003a
40015bb4:	02912223          	sw	s1,36(sp)
40015bb8:	01312e23          	sw	s3,28(sp)
40015bbc:	01512a23          	sw	s5,20(sp)
40015bc0:	01612823          	sw	s6,16(sp)
40015bc4:	01712623          	sw	s7,12(sp)
40015bc8:	00068b13          	mv	s6,a3
40015bcc:	78840793          	addi	a5,s0,1928 # 4003a788 <contexts>
40015bd0:	02112623          	sw	ra,44(sp)
40015bd4:	03212023          	sw	s2,32(sp)
40015bd8:	01412c23          	sw	s4,24(sp)
40015bdc:	01812423          	sw	s8,8(sp)
40015be0:	01912223          	sw	s9,4(sp)
40015be4:	00058993          	mv	s3,a1
40015be8:	00060a93          	mv	s5,a2
40015bec:	00070b93          	mv	s7,a4
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
40015bf0:	00000493          	li	s1,0
40015bf4:	78840413          	addi	s0,s0,1928
40015bf8:	00a00693          	li	a3,10
40015bfc:	0747d703          	lhu	a4,116(a5)
		if (!net_context_is_used(&contexts[i])) {
40015c00:	00177713          	andi	a4,a4,1
40015c04:	08070463          	beqz	a4,40015c8c <net_context_packet_received+0xe4>
		if (contexts[i].conn_handler == conn_handler) {
40015c08:	0447a703          	lw	a4,68(a5)
40015c0c:	08e51063          	bne	a0,a4,40015c8c <net_context_packet_received+0xe4>
			return &contexts[i];
40015c10:	07800913          	li	s2,120
40015c14:	03248933          	mul	s2,s1,s2
	enum net_verdict verdict = NET_DROP;

	NET_ASSERT(context);
	NET_ASSERT(net_pkt_iface(pkt));

	k_mutex_lock(&context->lock, K_FOREVER);
40015c18:	fff00593          	li	a1,-1
40015c1c:	fff00613          	li	a2,-1
40015c20:	00c90c13          	addi	s8,s2,12
40015c24:	01840c33          	add	s8,s0,s8
40015c28:	000c0513          	mv	a0,s8
40015c2c:	f75ff0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>
static inline void net_context_set_iface(struct net_context *context,
					 struct net_if *iface)
{
	NET_ASSERT(iface);

	context->iface = net_if_get_by_iface(iface);
40015c30:	0189a503          	lw	a0,24(s3)
			return &contexts[i];
40015c34:	01240a33          	add	s4,s0,s2
40015c38:	f29fd0ef          	jal	ra,40013b60 <net_if_get_by_iface>
40015c3c:	06aa0b23          	sb	a0,118(s4) # ffff8076 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8077>
	pkt->context = ctx;
40015c40:	0149aa23          	sw	s4,20(s3)
	net_pkt_set_context(pkt, context);

	/* If there is no callback registered, then we can only drop
	 * the packet.
	 */
	if (!context->recv_cb) {
40015c44:	048a2783          	lw	a5,72(s4)
40015c48:	06079863          	bnez	a5,40015cb8 <net_context_packet_received+0x110>
	verdict = NET_OK;

	return verdict;

unlock:
	k_mutex_unlock(&context->lock);
40015c4c:	000c0513          	mv	a0,s8
40015c50:	f55ff0ef          	jal	ra,40015ba4 <k_mutex_unlock.isra.0>

	return verdict;
40015c54:	00200513          	li	a0,2
}
40015c58:	02c12083          	lw	ra,44(sp)
40015c5c:	02812403          	lw	s0,40(sp)
40015c60:	02412483          	lw	s1,36(sp)
40015c64:	02012903          	lw	s2,32(sp)
40015c68:	01c12983          	lw	s3,28(sp)
40015c6c:	01812a03          	lw	s4,24(sp)
40015c70:	01412a83          	lw	s5,20(sp)
40015c74:	01012b03          	lw	s6,16(sp)
40015c78:	00c12b83          	lw	s7,12(sp)
40015c7c:	00812c03          	lw	s8,8(sp)
40015c80:	00412c83          	lw	s9,4(sp)
40015c84:	03010113          	addi	sp,sp,48
40015c88:	00008067          	ret
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
40015c8c:	00148493          	addi	s1,s1,1
40015c90:	07878793          	addi	a5,a5,120
40015c94:	f6d494e3          	bne	s1,a3,40015bfc <net_context_packet_received+0x54>
	k_mutex_lock(&context->lock, K_FOREVER);
40015c98:	fff00593          	li	a1,-1
40015c9c:	fff00613          	li	a2,-1
40015ca0:	00c00513          	li	a0,12
40015ca4:	efdff0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>
40015ca8:	0189a503          	lw	a0,24(s3)
40015cac:	eb5fd0ef          	jal	ra,40013b60 <net_if_get_by_iface>
40015cb0:	06000b23          	sb	zero,118(zero) # 76 <CONFIG_NET_TCP_PKT_ALLOC_TIMEOUT+0x12>
40015cb4:	00100073          	ebreak
	if (net_context_get_proto(context) == IPPROTO_TCP) {
40015cb8:	072a5703          	lhu	a4,114(s4)
40015cbc:	00600793          	li	a5,6
40015cc0:	02f71863          	bne	a4,a5,40015cf0 <net_context_packet_received+0x148>
		net_stats_update_tcp_recv(net_pkt_iface(pkt),
40015cc4:	00098513          	mv	a0,s3
	return pkt->iface;
40015cc8:	0189ac83          	lw	s9,24(s3)
40015ccc:	009020ef          	jal	ra,400184d4 <net_pkt_remaining_data>
	UPDATE_STAT(iface, stats.tcp.bytes.received += bytes);
40015cd0:	4003b7b7          	lui	a5,0x4003b
40015cd4:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40015cd8:	05c7a703          	lw	a4,92(a5)
40015cdc:	00a70733          	add	a4,a4,a0
40015ce0:	04e7ae23          	sw	a4,92(a5)
40015ce4:	060ca783          	lw	a5,96(s9)
40015ce8:	00a787b3          	add	a5,a5,a0
40015cec:	06fca023          	sw	a5,96(s9)
	k_sem_give(&context->recv_data_wait);
40015cf0:	05890513          	addi	a0,s2,88
	z_impl_k_sem_give(sem);
40015cf4:	00a40533          	add	a0,s0,a0
40015cf8:	441190ef          	jal	ra,4002f938 <z_impl_k_sem_give>
	k_mutex_unlock(&context->lock);
40015cfc:	000c0513          	mv	a0,s8
40015d00:	ea5ff0ef          	jal	ra,40015ba4 <k_mutex_unlock.isra.0>
	context->recv_cb(context, pkt, ip_hdr, proto_hdr, 0, user_data);
40015d04:	07800793          	li	a5,120
40015d08:	02f484b3          	mul	s1,s1,a5
40015d0c:	000a0513          	mv	a0,s4
40015d10:	000b8793          	mv	a5,s7
40015d14:	00000713          	li	a4,0
40015d18:	000b0693          	mv	a3,s6
40015d1c:	000a8613          	mv	a2,s5
40015d20:	00098593          	mv	a1,s3
40015d24:	00940433          	add	s0,s0,s1
40015d28:	04842803          	lw	a6,72(s0)
40015d2c:	000800e7          	jalr	a6
	return verdict;
40015d30:	00000513          	li	a0,0
40015d34:	f25ff06f          	j	40015c58 <net_context_packet_received+0xb0>

40015d38 <net_context_get>:
{
40015d38:	fd010113          	addi	sp,sp,-48
40015d3c:	03212023          	sw	s2,32(sp)
40015d40:	02112623          	sw	ra,44(sp)
40015d44:	02812423          	sw	s0,40(sp)
40015d48:	02912223          	sw	s1,36(sp)
40015d4c:	01312e23          	sw	s3,28(sp)
40015d50:	01412c23          	sw	s4,24(sp)
40015d54:	01512a23          	sw	s5,20(sp)
40015d58:	01612823          	sw	s6,16(sp)
40015d5c:	01712623          	sw	s7,12(sp)
40015d60:	01812423          	sw	s8,8(sp)
40015d64:	01912223          	sw	s9,4(sp)
	switch (family) {
40015d68:	00200793          	li	a5,2
{
40015d6c:	00050913          	mv	s2,a0
	switch (family) {
40015d70:	02a7ec63          	bltu	a5,a0,40015da8 <net_context_get+0x70>
		return -EAFNOSUPPORT;
40015d74:	f9600493          	li	s1,-106
	switch (family) {
40015d78:	04050663          	beqz	a0,40015dc4 <net_context_get+0x8c>
40015d7c:	00058413          	mv	s0,a1
40015d80:	00060a93          	mv	s5,a2
40015d84:	00068b13          	mv	s6,a3
		switch (type) {
40015d88:	06f58a63          	beq	a1,a5,40015dfc <net_context_get+0xc4>
40015d8c:	00300793          	li	a5,3
40015d90:	06f58c63          	beq	a1,a5,40015e08 <net_context_get+0xd0>
40015d94:	00100793          	li	a5,1
40015d98:	f9500493          	li	s1,-107
40015d9c:	02f59463          	bne	a1,a5,40015dc4 <net_context_get+0x8c>
			if (proto != IPPROTO_TCP) {
40015da0:	00600793          	li	a5,6
40015da4:	05c0006f          	j	40015e00 <net_context_get+0xc8>
	switch (family) {
40015da8:	ffd50913          	addi	s2,a0,-3
40015dac:	01091913          	slli	s2,s2,0x10
40015db0:	01095913          	srli	s2,s2,0x10
40015db4:	00100793          	li	a5,1
		return -EAFNOSUPPORT;
40015db8:	f9600493          	li	s1,-106
	switch (family) {
40015dbc:	0127e463          	bltu	a5,s2,40015dc4 <net_context_get+0x8c>
40015dc0:	fa000493          	li	s1,-96
}
40015dc4:	02c12083          	lw	ra,44(sp)
40015dc8:	02812403          	lw	s0,40(sp)
40015dcc:	02012903          	lw	s2,32(sp)
40015dd0:	01c12983          	lw	s3,28(sp)
40015dd4:	01812a03          	lw	s4,24(sp)
40015dd8:	01412a83          	lw	s5,20(sp)
40015ddc:	01012b03          	lw	s6,16(sp)
40015de0:	00c12b83          	lw	s7,12(sp)
40015de4:	00812c03          	lw	s8,8(sp)
40015de8:	00412c83          	lw	s9,4(sp)
40015dec:	00048513          	mv	a0,s1
40015df0:	02412483          	lw	s1,36(sp)
40015df4:	03010113          	addi	sp,sp,48
40015df8:	00008067          	ret
			if (proto != IPPROTO_UDP) {
40015dfc:	01100793          	li	a5,17
				return -EPROTONOSUPPORT;
40015e00:	f8500493          	li	s1,-123
			if (proto != IPPROTO_TCP) {
40015e04:	fcfa90e3          	bne	s5,a5,40015dc4 <net_context_get+0x8c>
		return -EINVAL;
40015e08:	fea00493          	li	s1,-22
	if (!context) {
40015e0c:	fa0b0ce3          	beqz	s6,40015dc4 <net_context_get+0x8c>
	return z_impl_k_sem_take(sem, timeout);
40015e10:	4003abb7          	lui	s7,0x4003a
40015e14:	fff00593          	li	a1,-1
40015e18:	fff00613          	li	a2,-1
40015e1c:	770b8513          	addi	a0,s7,1904 # 4003a770 <contexts_lock>
40015e20:	4003a4b7          	lui	s1,0x4003a
40015e24:	385190ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
40015e28:	78848793          	addi	a5,s1,1928 # 4003a788 <contexts>
40015e2c:	00000a13          	li	s4,0
40015e30:	78848493          	addi	s1,s1,1928
	return context->flags & NET_CONTEXT_IN_USE;
40015e34:	0747d703          	lhu	a4,116(a5)
		if (net_context_is_used(&contexts[i])) {
40015e38:	00177713          	andi	a4,a4,1
40015e3c:	02070263          	beqz	a4,40015e60 <net_context_get+0x128>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
40015e40:	001a0a13          	addi	s4,s4,1
40015e44:	00a00713          	li	a4,10
40015e48:	07878793          	addi	a5,a5,120
40015e4c:	feea14e3          	bne	s4,a4,40015e34 <net_context_get+0xfc>
	ret = -ENOENT;
40015e50:	ffe00493          	li	s1,-2
	z_impl_k_sem_give(sem);
40015e54:	770b8513          	addi	a0,s7,1904
40015e58:	2e1190ef          	jal	ra,4002f938 <z_impl_k_sem_give>
}
40015e5c:	f69ff06f          	j	40015dc4 <net_context_get+0x8c>
		memset(&contexts[i], 0, sizeof(contexts[i]));
40015e60:	07800993          	li	s3,120
40015e64:	033a09b3          	mul	s3,s4,s3
40015e68:	07800613          	li	a2,120
40015e6c:	00000593          	li	a1,0
40015e70:	01348c33          	add	s8,s1,s3
40015e74:	000c0513          	mv	a0,s8
40015e78:	ea5f60ef          	jal	ra,4000cd1c <memset>
		if (!net_if_is_ip_offloaded(net_if_get_default())
40015e7c:	ed5fa0ef          	jal	ra,40010d50 <net_if_get_default>
			&& proto == IPPROTO_TCP) {
40015e80:	00600793          	li	a5,6
40015e84:	0efa8463          	beq	s5,a5,40015f6c <net_context_get+0x234>
		contexts[i].iface = -1;
40015e88:	07800c93          	li	s9,120
40015e8c:	039a0cb3          	mul	s9,s4,s9
40015e90:	fff00793          	li	a5,-1
40015e94:	01948cb3          	add	s9,s1,s9
40015e98:	06fc8b23          	sb	a5,118(s9)
		contexts[i].flags = 0U;
40015e9c:	060c9a23          	sh	zero,116(s9)
		atomic_set(&contexts[i].refcount, 1);
40015ea0:	00898513          	addi	a0,s3,8
	return z_impl_atomic_set(target, value);
40015ea4:	00100593          	li	a1,1
40015ea8:	00a48533          	add	a0,s1,a0
40015eac:	3e51b0ef          	jal	ra,40031a90 <z_impl_atomic_set>
	context->flags |= flag;
40015eb0:	074cd703          	lhu	a4,116(s9)
		flag = family << 3;
40015eb4:	00391793          	slli	a5,s2,0x3
	context->flags |= flag;
40015eb8:	0f87f793          	andi	a5,a5,248
40015ebc:	00e7e7b3          	or	a5,a5,a4
	if (type == SOCK_DGRAM || type == SOCK_STREAM || type == SOCK_RAW) {
40015ec0:	00200693          	li	a3,2
40015ec4:	fff40713          	addi	a4,s0,-1
40015ec8:	0ae6fa63          	bgeu	a3,a4,40015f7c <net_context_get+0x244>
	uint16_t flag = 0U;
40015ecc:	00000413          	li	s0,0
	context->flags |= flag;
40015ed0:	07800713          	li	a4,120
40015ed4:	02ea0733          	mul	a4,s4,a4
40015ed8:	00f46433          	or	s0,s0,a5
			(void)memset(&contexts[i].remote, 0, sizeof(struct sockaddr));
40015edc:	02c98513          	addi	a0,s3,44
40015ee0:	01800613          	li	a2,24
40015ee4:	00000593          	li	a1,0
40015ee8:	00a48533          	add	a0,s1,a0
40015eec:	00e48733          	add	a4,s1,a4
40015ef0:	06871a23          	sh	s0,116(a4)
			(void)memset(&contexts[i].local, 0, sizeof(struct sockaddr_ptr));
40015ef4:	02098413          	addi	s0,s3,32
	context->proto = proto;
40015ef8:	07571923          	sh	s5,114(a4)
40015efc:	00848433          	add	s0,s1,s0
			(void)memset(&contexts[i].remote, 0, sizeof(struct sockaddr));
40015f00:	e1df60ef          	jal	ra,4000cd1c <memset>
			(void)memset(&contexts[i].local, 0, sizeof(struct sockaddr_ptr));
40015f04:	00c00613          	li	a2,12
40015f08:	00000593          	li	a1,0
40015f0c:	00040513          	mv	a0,s0
40015f10:	e0df60ef          	jal	ra,4000cd1c <memset>
					find_available_port(&contexts[i], (struct sockaddr *)addr6);
40015f14:	00040593          	mv	a1,s0
40015f18:	000c0513          	mv	a0,s8
40015f1c:	b61ff0ef          	jal	ra,40015a7c <find_available_port>
				addr6->sin6_port =
40015f20:	00a41123          	sh	a0,2(s0)
				if (!addr6->sin6_port) {
40015f24:	06050463          	beqz	a0,40015f8c <net_context_get+0x254>
			k_sem_init(&contexts[i].recv_data_wait, 1, K_SEM_MAX_LIMIT);
40015f28:	05898513          	addi	a0,s3,88
	return z_impl_k_sem_init(sem, initial_count, limit);
40015f2c:	fff00613          	li	a2,-1
40015f30:	00100593          	li	a1,1
40015f34:	00a48533          	add	a0,s1,a0
40015f38:	1c9190ef          	jal	ra,4002f900 <z_impl_k_sem_init>
		k_mutex_init(&contexts[i].lock);
40015f3c:	00c98513          	addi	a0,s3,12
	return z_impl_k_mutex_init(mutex);
40015f40:	00a48533          	add	a0,s1,a0
40015f44:	4e0190ef          	jal	ra,4002f424 <z_impl_k_mutex_init>
		contexts[i].flags |= NET_CONTEXT_IN_USE;
40015f48:	07800793          	li	a5,120
40015f4c:	02fa07b3          	mul	a5,s4,a5
40015f50:	00f487b3          	add	a5,s1,a5
40015f54:	0747d703          	lhu	a4,116(a5)
		ret = 0;
40015f58:	00000493          	li	s1,0
		contexts[i].flags |= NET_CONTEXT_IN_USE;
40015f5c:	00176713          	ori	a4,a4,1
40015f60:	06e79a23          	sh	a4,116(a5)
		*context = &contexts[i];
40015f64:	018b2023          	sw	s8,0(s6)
		break;
40015f68:	eedff06f          	j	40015e54 <net_context_get+0x11c>
			if (net_tcp_get(&contexts[i]) < 0) {
40015f6c:	000c0513          	mv	a0,s8
40015f70:	3c00b0ef          	jal	ra,40021330 <net_tcp_get>
40015f74:	f0055ae3          	bgez	a0,40015e88 <net_context_get+0x150>
40015f78:	ed9ff06f          	j	40015e50 <net_context_get+0x118>
		flag = type << 6;
40015f7c:	00641413          	slli	s0,s0,0x6
40015f80:	01041413          	slli	s0,s0,0x10
40015f84:	01045413          	srli	s0,s0,0x10
40015f88:	f49ff06f          	j	40015ed0 <net_context_get+0x198>
					ret = -EADDRINUSE;
40015f8c:	f9000493          	li	s1,-112
40015f90:	ec5ff06f          	j	40015e54 <net_context_get+0x11c>

40015f94 <net_context_unref>:
{
40015f94:	ff010113          	addi	sp,sp,-16
40015f98:	00812423          	sw	s0,8(sp)
40015f9c:	00112623          	sw	ra,12(sp)
40015fa0:	00912223          	sw	s1,4(sp)
40015fa4:	00050413          	mv	s0,a0
	return z_impl_atomic_sub(target, value);
40015fa8:	00100593          	li	a1,1
40015fac:	00850513          	addi	a0,a0,8
40015fb0:	2b91b0ef          	jal	ra,40031a68 <z_impl_atomic_sub>
	if (old_rc != 1) {
40015fb4:	00100793          	li	a5,1
40015fb8:	00f50e63          	beq	a0,a5,40015fd4 <net_context_unref+0x40>
		return old_rc - 1;
40015fbc:	fff50513          	addi	a0,a0,-1
}
40015fc0:	00c12083          	lw	ra,12(sp)
40015fc4:	00812403          	lw	s0,8(sp)
40015fc8:	00412483          	lw	s1,4(sp)
40015fcc:	01010113          	addi	sp,sp,16
40015fd0:	00008067          	ret
	k_mutex_lock(&context->lock, K_FOREVER);
40015fd4:	00c40493          	addi	s1,s0,12
40015fd8:	00048513          	mv	a0,s1
40015fdc:	fff00593          	li	a1,-1
40015fe0:	fff00613          	li	a2,-1
40015fe4:	bbdff0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>
	if (context->conn_handler) {
40015fe8:	04442503          	lw	a0,68(s0)
40015fec:	00050663          	beqz	a0,40015ff8 <net_context_unref+0x64>
			net_conn_unregister(context->conn_handler);
40015ff0:	328030ef          	jal	ra,40019318 <net_conn_unregister>
		context->conn_handler = NULL;
40015ff4:	04042223          	sw	zero,68(s0)
	context->flags &= ~NET_CONTEXT_IN_USE;
40015ff8:	07445783          	lhu	a5,116(s0)
	k_mutex_unlock(&context->lock);
40015ffc:	00048513          	mv	a0,s1
	context->flags &= ~NET_CONTEXT_IN_USE;
40016000:	ff87f793          	andi	a5,a5,-8
40016004:	06f41a23          	sh	a5,116(s0)
	k_mutex_unlock(&context->lock);
40016008:	b9dff0ef          	jal	ra,40015ba4 <k_mutex_unlock.isra.0>
	return 0;
4001600c:	00000513          	li	a0,0
40016010:	fb1ff06f          	j	40015fc0 <net_context_unref+0x2c>

40016014 <net_context_put>:
	if (!PART_OF_ARRAY(contexts, context)) {
40016014:	08050263          	beqz	a0,40016098 <net_context_put+0x84>
{
40016018:	ff010113          	addi	sp,sp,-16
	if (!PART_OF_ARRAY(contexts, context)) {
4001601c:	4003a7b7          	lui	a5,0x4003a
{
40016020:	00812423          	sw	s0,8(sp)
40016024:	00112623          	sw	ra,12(sp)
40016028:	00050413          	mv	s0,a0
4001602c:	00912223          	sw	s1,4(sp)
	if (!PART_OF_ARRAY(contexts, context)) {
40016030:	78878793          	addi	a5,a5,1928 # 4003a788 <contexts>
		return -EINVAL;
40016034:	fea00513          	li	a0,-22
	if (!PART_OF_ARRAY(contexts, context)) {
40016038:	04f46663          	bltu	s0,a5,40016084 <net_context_put+0x70>
4001603c:	4003b7b7          	lui	a5,0x4003b
40016040:	c3878793          	addi	a5,a5,-968 # 4003ac38 <conns>
40016044:	04f47063          	bgeu	s0,a5,40016084 <net_context_put+0x70>
	k_mutex_lock(&context->lock, K_FOREVER);
40016048:	00c40493          	addi	s1,s0,12
4001604c:	fff00593          	li	a1,-1
40016050:	fff00613          	li	a2,-1
40016054:	00048513          	mv	a0,s1
40016058:	b49ff0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>
	net_tcp_put(context);
4001605c:	00040513          	mv	a0,s0
	context->connect_cb = NULL;
40016060:	04042823          	sw	zero,80(s0)
	context->recv_cb = NULL;
40016064:	04042423          	sw	zero,72(s0)
	context->send_cb = NULL;
40016068:	04042623          	sw	zero,76(s0)
	net_tcp_put(context);
4001606c:	5d50b0ef          	jal	ra,40021e40 <net_tcp_put>
	net_context_unref(context);
40016070:	00040513          	mv	a0,s0
40016074:	f21ff0ef          	jal	ra,40015f94 <net_context_unref>
	k_mutex_unlock(&context->lock);
40016078:	00048513          	mv	a0,s1
4001607c:	b29ff0ef          	jal	ra,40015ba4 <k_mutex_unlock.isra.0>
	return ret;
40016080:	00000513          	li	a0,0
}
40016084:	00c12083          	lw	ra,12(sp)
40016088:	00812403          	lw	s0,8(sp)
4001608c:	00412483          	lw	s1,4(sp)
40016090:	01010113          	addi	sp,sp,16
40016094:	00008067          	ret
		return -EINVAL;
40016098:	fea00513          	li	a0,-22
}
4001609c:	00008067          	ret

400160a0 <net_context_bind>:
{
400160a0:	fd010113          	addi	sp,sp,-48
400160a4:	02812423          	sw	s0,40(sp)
400160a8:	03212023          	sw	s2,32(sp)
400160ac:	02112623          	sw	ra,44(sp)
400160b0:	02912223          	sw	s1,36(sp)
400160b4:	01312e23          	sw	s3,28(sp)
400160b8:	01412c23          	sw	s4,24(sp)
400160bc:	01512a23          	sw	s5,20(sp)
400160c0:	03010413          	addi	s0,sp,48
	if (context->conn_handler) {
400160c4:	04452a03          	lw	s4,68(a0)
		return -EISCONN;
400160c8:	f8100913          	li	s2,-127
	if (context->conn_handler) {
400160cc:	060a1663          	bnez	s4,40016138 <net_context_bind+0x98>
	if (IS_ENABLED(CONFIG_NET_IPV6) && addr->sa_family == AF_INET6) {
400160d0:	0005d783          	lhu	a5,0(a1)
400160d4:	00200713          	li	a4,2
400160d8:	00050493          	mv	s1,a0
400160dc:	00058993          	mv	s3,a1
400160e0:	1ae79063          	bne	a5,a4,40016280 <net_context_bind+0x1e0>
		struct net_if *iface = NULL;
400160e4:	fc042e23          	sw	zero,-36(s0)
		if (addrlen < sizeof(struct sockaddr_in6)) {
400160e8:	01700793          	li	a5,23
			return -EINVAL;
400160ec:	fea00913          	li	s2,-22
		if (addrlen < sizeof(struct sockaddr_in6)) {
400160f0:	04c7f463          	bgeu	a5,a2,40016138 <net_context_bind+0x98>
		if (net_context_is_bound_to_iface(context)) {
400160f4:	07455783          	lhu	a5,116(a0)
400160f8:	00b7d793          	srli	a5,a5,0xb
400160fc:	0017f793          	andi	a5,a5,1
40016100:	00078863          	beqz	a5,40016110 <net_context_bind+0x70>
	return net_if_get_by_index(context->iface);
40016104:	07650503          	lb	a0,118(a0)
40016108:	a25fa0ef          	jal	ra,40010b2c <z_impl_net_if_get_by_index>
			iface = net_context_get_iface(context);
4001610c:	fca42e23          	sw	a0,-36(s0)
		if (net_ipv6_is_addr_mcast(&addr6->sin6_addr)) {
40016110:	0049c703          	lbu	a4,4(s3)
40016114:	0ff00793          	li	a5,255
			maddr = net_if_ipv6_maddr_lookup(&addr6->sin6_addr,
40016118:	00498a93          	addi	s5,s3,4
		if (net_ipv6_is_addr_mcast(&addr6->sin6_addr)) {
4001611c:	04f71463          	bne	a4,a5,40016164 <net_context_bind+0xc4>
			maddr = net_if_ipv6_maddr_lookup(&addr6->sin6_addr,
40016120:	fdc40593          	addi	a1,s0,-36
40016124:	000a8513          	mv	a0,s5
40016128:	864fc0ef          	jal	ra,4001218c <net_if_ipv6_maddr_lookup>
			ptr = &maddr->address.in6_addr;
4001612c:	00450913          	addi	s2,a0,4
			if (!maddr) {
40016130:	04051e63          	bnez	a0,4001618c <net_context_bind+0xec>
				return -ENOENT;
40016134:	ffe00913          	li	s2,-2
}
40016138:	fd040113          	addi	sp,s0,-48
4001613c:	02c12083          	lw	ra,44(sp)
40016140:	00090513          	mv	a0,s2
40016144:	02812403          	lw	s0,40(sp)
40016148:	02412483          	lw	s1,36(sp)
4001614c:	02012903          	lw	s2,32(sp)
40016150:	01c12983          	lw	s3,28(sp)
40016154:	01812a03          	lw	s4,24(sp)
40016158:	01412a83          	lw	s5,20(sp)
4001615c:	03010113          	addi	sp,sp,48
40016160:	00008067          	ret
		} else if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
40016164:	000a8513          	mv	a0,s5
40016168:	f30ff0ef          	jal	ra,40015898 <net_ipv6_is_addr_unspecified>
			if (iface == NULL) {
4001616c:	fdc42783          	lw	a5,-36(s0)
		} else if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
40016170:	02050e63          	beqz	a0,400161ac <net_context_bind+0x10c>
			if (iface == NULL) {
40016174:	00079863          	bnez	a5,40016184 <net_context_bind+0xe4>
				iface = net_if_ipv6_select_src_iface(
40016178:	03048513          	addi	a0,s1,48
4001617c:	c31fc0ef          	jal	ra,40012dac <net_if_ipv6_select_src_iface>
40016180:	fca42e23          	sw	a0,-36(s0)
			ptr = (struct in6_addr *)net_ipv6_unspecified_address();
40016184:	a84ff0ef          	jal	ra,40015408 <net_ipv6_unspecified_address>
40016188:	00050913          	mv	s2,a0
		if (!iface) {
4001618c:	fdc42783          	lw	a5,-36(s0)
40016190:	08079c63          	bnez	a5,40016228 <net_context_bind+0x188>
			NET_ERR("Cannot bind to %s",
40016194:	400444b7          	lui	s1,0x40044
40016198:	75c4a783          	lw	a5,1884(s1) # 4004475c <log_dynamic_net_ctx>
4001619c:	0077f793          	andi	a5,a5,7
400161a0:	02079663          	bnez	a5,400161cc <net_context_bind+0x12c>
			return -EADDRNOTAVAIL;
400161a4:	f8300913          	li	s2,-125
400161a8:	f91ff06f          	j	40016138 <net_context_bind+0x98>
			ifaddr = net_if_ipv6_addr_lookup(
400161ac:	00079463          	bnez	a5,400161b4 <net_context_bind+0x114>
400161b0:	fdc40a13          	addi	s4,s0,-36
400161b4:	000a0593          	mv	a1,s4
400161b8:	000a8513          	mv	a0,s5
400161bc:	ef5fa0ef          	jal	ra,400110b0 <net_if_ipv6_addr_lookup>
			if (!ifaddr) {
400161c0:	f6050ae3          	beqz	a0,40016134 <net_context_bind+0x94>
			ptr = &ifaddr->address.in6_addr;
400161c4:	00450913          	addi	s2,a0,4
400161c8:	fc5ff06f          	j	4001618c <net_context_bind+0xec>
			NET_ERR("Cannot bind to %s",
400161cc:	000a8593          	mv	a1,s5
400161d0:	00200513          	li	a0,2
			NET_ERR("Cannot bind to %s",
400161d4:	ee0fe0ef          	jal	ra,400148b4 <net_sprint_addr>
400161d8:	00010913          	mv	s2,sp
400161dc:	fe010113          	addi	sp,sp,-32
400161e0:	00010613          	mv	a2,sp
400161e4:	400357b7          	lui	a5,0x40035
400161e8:	d4c78793          	addi	a5,a5,-692 # 40034d4c <in6addr_any+0xa0>
400161ec:	00f62a23          	sw	a5,20(a2)
400161f0:	20000793          	li	a5,512
400161f4:	00f61e23          	sh	a5,28(a2)
400161f8:	010007b7          	lui	a5,0x1000
400161fc:	00378793          	addi	a5,a5,3 # 1000003 <__rom_region_size+0xfc7047>
40016200:	00a62c23          	sw	a0,24(a2)
40016204:	00f62823          	sw	a5,16(a2)
40016208:	000025b7          	lui	a1,0x2
4001620c:	00000693          	li	a3,0
40016210:	01060613          	addi	a2,a2,16
40016214:	c4058593          	addi	a1,a1,-960 # 1c40 <CONFIG_HEAP_MEM_POOL_SIZE+0xc40>
40016218:	75c48513          	addi	a0,s1,1884
4001621c:	d79ee0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
40016220:	00090113          	mv	sp,s2
40016224:	f81ff06f          	j	400161a4 <net_context_bind+0x104>
		k_mutex_lock(&context->lock, K_FOREVER);
40016228:	00c48a13          	addi	s4,s1,12
4001622c:	fff00593          	li	a1,-1
40016230:	fff00613          	li	a2,-1
40016234:	000a0513          	mv	a0,s4
40016238:	969ff0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>
	context->iface = net_if_get_by_iface(iface);
4001623c:	fdc42503          	lw	a0,-36(s0)
40016240:	921fd0ef          	jal	ra,40013b60 <net_if_get_by_iface>
		net_sin6_ptr(&context->local)->sin6_family = AF_INET6;
40016244:	00200793          	li	a5,2
40016248:	06a48b23          	sb	a0,118(s1)
4001624c:	02f49023          	sh	a5,32(s1)
		net_sin6_ptr(&context->local)->sin6_addr = ptr;
40016250:	0324a223          	sw	s2,36(s1)
		if (addr6->sin6_port) {
40016254:	0029d583          	lhu	a1,2(s3)
40016258:	1a058063          	beqz	a1,400163f8 <net_context_bind+0x358>
			ret = check_used_port(AF_INET6, addr6->sin6_port,
4001625c:	00098613          	mv	a2,s3
40016260:	00200513          	li	a0,2
			ret = check_used_port(AF_INET, addr4->sin_port,
40016264:	ef8ff0ef          	jal	ra,4001595c <check_used_port>
40016268:	00050913          	mv	s2,a0
			if (!ret) {
4001626c:	10051c63          	bnez	a0,40016384 <net_context_bind+0x2e4>
					addr4->sin_port;
40016270:	0029d783          	lhu	a5,2(s3)
				net_sin_ptr(&context->local)->sin_port =
40016274:	02f49123          	sh	a5,34(s1)
			ifaddr = net_if_ipv4_addr_lookup(
40016278:	00000913          	li	s2,0
4001627c:	1700006f          	j	400163ec <net_context_bind+0x34c>
	if (IS_ENABLED(CONFIG_NET_IPV4) && addr->sa_family == AF_INET) {
40016280:	00100713          	li	a4,1
	return -EINVAL;
40016284:	fea00913          	li	s2,-22
	if (IS_ENABLED(CONFIG_NET_IPV4) && addr->sa_family == AF_INET) {
40016288:	eae798e3          	bne	a5,a4,40016138 <net_context_bind+0x98>
		struct net_if *iface = NULL;
4001628c:	fc042e23          	sw	zero,-36(s0)
		if (addrlen < sizeof(struct sockaddr_in)) {
40016290:	00700793          	li	a5,7
40016294:	eac7f2e3          	bgeu	a5,a2,40016138 <net_context_bind+0x98>
		if (net_context_is_bound_to_iface(context)) {
40016298:	07455783          	lhu	a5,116(a0)
4001629c:	00b7d793          	srli	a5,a5,0xb
400162a0:	0017f793          	andi	a5,a5,1
400162a4:	00078863          	beqz	a5,400162b4 <net_context_bind+0x214>
	return net_if_get_by_index(context->iface);
400162a8:	07650503          	lb	a0,118(a0)
400162ac:	881fa0ef          	jal	ra,40010b2c <z_impl_net_if_get_by_index>
			iface = net_context_get_iface(context);
400162b0:	fca42e23          	sw	a0,-36(s0)
		if (net_ipv4_is_addr_mcast(&addr4->sin_addr)) {
400162b4:	00498a93          	addi	s5,s3,4
400162b8:	000a8513          	mv	a0,s5
400162bc:	dbcff0ef          	jal	ra,40015878 <net_ipv4_is_addr_mcast>
400162c0:	02050e63          	beqz	a0,400162fc <net_context_bind+0x25c>
			maddr = net_if_ipv4_maddr_lookup(&addr4->sin_addr,
400162c4:	fdc40593          	addi	a1,s0,-36
400162c8:	000a8513          	mv	a0,s5
400162cc:	b7cfd0ef          	jal	ra,40013648 <net_if_ipv4_maddr_lookup>
			ptr = &maddr->address.in_addr;
400162d0:	00450913          	addi	s2,a0,4
			if (!maddr) {
400162d4:	e60500e3          	beqz	a0,40016134 <net_context_bind+0x94>
		if (!iface) {
400162d8:	fdc42783          	lw	a5,-36(s0)
400162dc:	06079463          	bnez	a5,40016344 <net_context_bind+0x2a4>
			NET_ERR("Cannot bind to %s",
400162e0:	400444b7          	lui	s1,0x40044
400162e4:	75c4a783          	lw	a5,1884(s1) # 4004475c <log_dynamic_net_ctx>
400162e8:	0077f793          	andi	a5,a5,7
400162ec:	ea078ce3          	beqz	a5,400161a4 <net_context_bind+0x104>
400162f0:	000a8593          	mv	a1,s5
400162f4:	00100513          	li	a0,1
400162f8:	eddff06f          	j	400161d4 <net_context_bind+0x134>
		} else if (addr4->sin_addr.s_addr == INADDR_ANY) {
400162fc:	0049a703          	lw	a4,4(s3)
			if (iface == NULL) {
40016300:	fdc42783          	lw	a5,-36(s0)
		} else if (addr4->sin_addr.s_addr == INADDR_ANY) {
40016304:	02071063          	bnez	a4,40016324 <net_context_bind+0x284>
			if (iface == NULL) {
40016308:	00079863          	bnez	a5,40016318 <net_context_bind+0x278>
				iface = net_if_ipv4_select_src_iface(
4001630c:	03048513          	addi	a0,s1,48
40016310:	df5fc0ef          	jal	ra,40013104 <net_if_ipv4_select_src_iface>
40016314:	fca42e23          	sw	a0,-36(s0)
			ptr = (struct in_addr *)net_ipv4_unspecified_address();
40016318:	8d8ff0ef          	jal	ra,400153f0 <net_ipv4_unspecified_address>
4001631c:	00050913          	mv	s2,a0
40016320:	fb9ff06f          	j	400162d8 <net_context_bind+0x238>
			ifaddr = net_if_ipv4_addr_lookup(
40016324:	00079463          	bnez	a5,4001632c <net_context_bind+0x28c>
40016328:	fdc40a13          	addi	s4,s0,-36
4001632c:	000a0593          	mv	a1,s4
40016330:	000a8513          	mv	a0,s5
40016334:	f7dfc0ef          	jal	ra,400132b0 <net_if_ipv4_addr_lookup>
			if (!ifaddr) {
40016338:	de050ee3          	beqz	a0,40016134 <net_context_bind+0x94>
			ptr = &ifaddr->address.in_addr;
4001633c:	00450913          	addi	s2,a0,4
40016340:	f99ff06f          	j	400162d8 <net_context_bind+0x238>
		k_mutex_lock(&context->lock, K_FOREVER);
40016344:	00c48a13          	addi	s4,s1,12
40016348:	fff00593          	li	a1,-1
4001634c:	fff00613          	li	a2,-1
40016350:	000a0513          	mv	a0,s4
40016354:	84dff0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>
	context->iface = net_if_get_by_iface(iface);
40016358:	fdc42503          	lw	a0,-36(s0)
4001635c:	805fd0ef          	jal	ra,40013b60 <net_if_get_by_iface>
		net_sin_ptr(&context->local)->sin_family = AF_INET;
40016360:	00100793          	li	a5,1
40016364:	06a48b23          	sb	a0,118(s1)
40016368:	02f49023          	sh	a5,32(s1)
		net_sin_ptr(&context->local)->sin_addr = ptr;
4001636c:	0324a223          	sw	s2,36(s1)
		if (addr4->sin_port) {
40016370:	0029d583          	lhu	a1,2(s3)
40016374:	08058263          	beqz	a1,400163f8 <net_context_bind+0x358>
			ret = check_used_port(AF_INET, addr4->sin_port,
40016378:	00098613          	mv	a2,s3
4001637c:	00100513          	li	a0,1
40016380:	ee5ff06f          	j	40016264 <net_context_bind+0x1c4>
				NET_ERR("Port %d is in use!",
40016384:	40044537          	lui	a0,0x40044
40016388:	75c52783          	lw	a5,1884(a0) # 4004475c <log_dynamic_net_ctx>
4001638c:	0077f793          	andi	a5,a5,7
40016390:	04078e63          	beqz	a5,400163ec <net_context_bind+0x34c>
40016394:	0029d703          	lhu	a4,2(s3)
40016398:	00010493          	mv	s1,sp
4001639c:	fe010113          	addi	sp,sp,-32
400163a0:	00871793          	slli	a5,a4,0x8
400163a4:	00875713          	srli	a4,a4,0x8
400163a8:	00e7e7b3          	or	a5,a5,a4
400163ac:	01079793          	slli	a5,a5,0x10
400163b0:	0107d793          	srli	a5,a5,0x10
400163b4:	00010613          	mv	a2,sp
400163b8:	40035737          	lui	a4,0x40035
400163bc:	d6070713          	addi	a4,a4,-672 # 40034d60 <in6addr_any+0xb4>
400163c0:	00f62c23          	sw	a5,24(a2)
400163c4:	00300793          	li	a5,3
400163c8:	00e62a23          	sw	a4,20(a2)
400163cc:	00f62823          	sw	a5,16(a2)
400163d0:	000025b7          	lui	a1,0x2
400163d4:	00000693          	li	a3,0
400163d8:	01060613          	addi	a2,a2,16
400163dc:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
400163e0:	75c50513          	addi	a0,a0,1884
400163e4:	bb1ee0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
400163e8:	00048113          	mv	sp,s1
		k_mutex_unlock(&context->lock);
400163ec:	000a0513          	mv	a0,s4
400163f0:	fb4ff0ef          	jal	ra,40015ba4 <k_mutex_unlock.isra.0>
		return ret;
400163f4:	d45ff06f          	j	40016138 <net_context_bind+0x98>
				net_sin_ptr(&context->local)->sin_port;
400163f8:	0224d783          	lhu	a5,34(s1)
			addr4->sin_port =
400163fc:	00f99123          	sh	a5,2(s3)
40016400:	e79ff06f          	j	40016278 <net_context_bind+0x1d8>

40016404 <bind_default>:
{
40016404:	fd010113          	addi	sp,sp,-48
40016408:	02812423          	sw	s0,40(sp)
4001640c:	02112623          	sw	ra,44(sp)
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40016410:	07455703          	lhu	a4,116(a0)
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40016414:	00200793          	li	a5,2
{
40016418:	00050413          	mv	s0,a0
4001641c:	00375713          	srli	a4,a4,0x3
40016420:	00777713          	andi	a4,a4,7
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40016424:	06f71063          	bne	a4,a5,40016484 <bind_default+0x80>
		if (net_sin6_ptr(&context->local)->sin6_addr) {
40016428:	02452683          	lw	a3,36(a0)
			return 0;
4001642c:	00000793          	li	a5,0
		if (net_sin6_ptr(&context->local)->sin6_addr) {
40016430:	04069063          	bnez	a3,40016470 <bind_default+0x6c>
		addr6.sin6_family = AF_INET6;
40016434:	00e11423          	sh	a4,8(sp)
		memcpy(&addr6.sin6_addr, net_ipv6_unspecified_address(),
40016438:	fd1fe0ef          	jal	ra,40015408 <net_ipv6_unspecified_address>
4001643c:	00050593          	mv	a1,a0
40016440:	01000613          	li	a2,16
40016444:	00c10513          	addi	a0,sp,12
40016448:	8b1f60ef          	jal	ra,4000ccf8 <memcpy>
			find_available_port(context,
4001644c:	00810593          	addi	a1,sp,8
40016450:	00040513          	mv	a0,s0
40016454:	e28ff0ef          	jal	ra,40015a7c <find_available_port>
		addr6.sin6_port =
40016458:	00a11523          	sh	a0,10(sp)
		return net_context_bind(context, (struct sockaddr *)&addr6,
4001645c:	01800613          	li	a2,24
		return net_context_bind(context, (struct sockaddr *)&addr4,
40016460:	00810593          	addi	a1,sp,8
40016464:	00040513          	mv	a0,s0
40016468:	c39ff0ef          	jal	ra,400160a0 <net_context_bind>
4001646c:	00050793          	mv	a5,a0
}
40016470:	02c12083          	lw	ra,44(sp)
40016474:	02812403          	lw	s0,40(sp)
40016478:	00078513          	mv	a0,a5
4001647c:	03010113          	addi	sp,sp,48
40016480:	00008067          	ret
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40016484:	00100693          	li	a3,1
	return -EINVAL;
40016488:	fea00793          	li	a5,-22
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
4001648c:	fed712e3          	bne	a4,a3,40016470 <bind_default+0x6c>
		if (net_sin_ptr(&context->local)->sin_addr) {
40016490:	02452683          	lw	a3,36(a0)
			return 0;
40016494:	00000793          	li	a5,0
		if (net_sin_ptr(&context->local)->sin_addr) {
40016498:	fc069ce3          	bnez	a3,40016470 <bind_default+0x6c>
			find_available_port(context,
4001649c:	00810593          	addi	a1,sp,8
		addr4.sin_family = AF_INET;
400164a0:	00e11423          	sh	a4,8(sp)
		addr4.sin_addr.s_addr = INADDR_ANY;
400164a4:	00012623          	sw	zero,12(sp)
			find_available_port(context,
400164a8:	dd4ff0ef          	jal	ra,40015a7c <find_available_port>
		addr4.sin_port =
400164ac:	00a11523          	sh	a0,10(sp)
		return net_context_bind(context, (struct sockaddr *)&addr4,
400164b0:	00800613          	li	a2,8
400164b4:	fadff06f          	j	40016460 <bind_default+0x5c>

400164b8 <net_context_create_ipv4_new>:
{
400164b8:	fe010113          	addi	sp,sp,-32
400164bc:	00812c23          	sw	s0,24(sp)
400164c0:	00912a23          	sw	s1,20(sp)
400164c4:	01212823          	sw	s2,16(sp)
400164c8:	01312623          	sw	s3,12(sp)
400164cc:	00112e23          	sw	ra,28(sp)
400164d0:	00050913          	mv	s2,a0
400164d4:	00058493          	mv	s1,a1
400164d8:	00068993          	mv	s3,a3
400164dc:	00060413          	mv	s0,a2
	if (!src) {
400164e0:	00061463          	bnez	a2,400164e8 <net_context_create_ipv4_new+0x30>
		src = ((struct sockaddr_in_ptr *)&context->local)->sin_addr;
400164e4:	02452403          	lw	s0,36(a0)
	return UNALIGNED_GET(&addr->s_addr) == 0;
400164e8:	00144783          	lbu	a5,1(s0)
400164ec:	00044703          	lbu	a4,0(s0)
400164f0:	00879793          	slli	a5,a5,0x8
400164f4:	00e7e7b3          	or	a5,a5,a4
400164f8:	00244703          	lbu	a4,2(s0)
400164fc:	01071713          	slli	a4,a4,0x10
40016500:	00f76733          	or	a4,a4,a5
40016504:	00344783          	lbu	a5,3(s0)
40016508:	01879793          	slli	a5,a5,0x18
4001650c:	00e7e7b3          	or	a5,a5,a4
	if (net_ipv4_is_addr_unspecified(src)
40016510:	00078863          	beqz	a5,40016520 <net_context_create_ipv4_new+0x68>
	    || net_ipv4_is_addr_mcast(src)) {
40016514:	00040513          	mv	a0,s0
40016518:	b60ff0ef          	jal	ra,40015878 <net_ipv4_is_addr_mcast>
4001651c:	04050063          	beqz	a0,4001655c <net_context_create_ipv4_new+0xa4>
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
40016520:	0184a503          	lw	a0,24(s1)
40016524:	00098593          	mv	a1,s3
40016528:	c65fc0ef          	jal	ra,4001318c <net_if_ipv4_select_src_addr>
4001652c:	00154783          	lbu	a5,1(a0)
40016530:	00054703          	lbu	a4,0(a0)
40016534:	00050413          	mv	s0,a0
40016538:	00879793          	slli	a5,a5,0x8
4001653c:	00e7e7b3          	or	a5,a5,a4
40016540:	00254703          	lbu	a4,2(a0)
40016544:	01071713          	slli	a4,a4,0x10
40016548:	00f76733          	or	a4,a4,a5
4001654c:	00354783          	lbu	a5,3(a0)
40016550:	01879793          	slli	a5,a5,0x18
40016554:	00e7e7b3          	or	a5,a5,a4
		if (net_ipv4_is_addr_unspecified(src)) {
40016558:	06078263          	beqz	a5,400165bc <net_context_create_ipv4_new+0x104>
}

static inline uint8_t net_context_get_ipv4_ttl(struct net_context *context)
{
	return context->ipv4_ttl;
4001655c:	07794783          	lbu	a5,119(s2)
	return net_ipv4_create(pkt, src, dst);
40016560:	00040593          	mv	a1,s0
40016564:	00098613          	mv	a2,s3
	pkt->ipv4_ttl = ttl;
40016568:	02f48ca3          	sb	a5,57(s1)
 *
 * @return Decoded DSCP value.
 */
static inline uint8_t net_ipv4_get_dscp(uint8_t tos)
{
	return (tos & NET_IPV4_DSCP_MASK) >> NET_IPV4_DSCP_OFFSET;
4001656c:	07094703          	lbu	a4,112(s2)
	pkt->ip_dscp = dscp;
40016570:	0404c783          	lbu	a5,64(s1)
40016574:	00048513          	mv	a0,s1
40016578:	00275713          	srli	a4,a4,0x2
4001657c:	fc07f793          	andi	a5,a5,-64
40016580:	00e7e7b3          	or	a5,a5,a4
40016584:	04f48023          	sb	a5,64(s1)
	pkt->ip_ecn = ecn;
40016588:	07094703          	lbu	a4,112(s2)
4001658c:	0ff7f793          	zext.b	a5,a5
40016590:	03f7f793          	andi	a5,a5,63
40016594:	00671713          	slli	a4,a4,0x6
40016598:	00e7e7b3          	or	a5,a5,a4
4001659c:	04f48023          	sb	a5,64(s1)
}
400165a0:	01812403          	lw	s0,24(sp)
400165a4:	01c12083          	lw	ra,28(sp)
400165a8:	01412483          	lw	s1,20(sp)
400165ac:	01012903          	lw	s2,16(sp)
400165b0:	00c12983          	lw	s3,12(sp)
400165b4:	02010113          	addi	sp,sp,32
	return net_ipv4_create(pkt, src, dst);
400165b8:	6dd0306f          	j	4001a494 <net_ipv4_create>
}
400165bc:	01c12083          	lw	ra,28(sp)
400165c0:	01812403          	lw	s0,24(sp)
400165c4:	01412483          	lw	s1,20(sp)
400165c8:	01012903          	lw	s2,16(sp)
400165cc:	00c12983          	lw	s3,12(sp)
400165d0:	fea00513          	li	a0,-22
400165d4:	02010113          	addi	sp,sp,32
400165d8:	00008067          	ret

400165dc <net_context_create_ipv6_new>:
{
400165dc:	fe010113          	addi	sp,sp,-32
400165e0:	00812c23          	sw	s0,24(sp)
400165e4:	00912a23          	sw	s1,20(sp)
400165e8:	01212823          	sw	s2,16(sp)
400165ec:	01312623          	sw	s3,12(sp)
400165f0:	00112e23          	sw	ra,28(sp)
400165f4:	00050913          	mv	s2,a0
400165f8:	00058493          	mv	s1,a1
400165fc:	00068993          	mv	s3,a3
40016600:	00060413          	mv	s0,a2
	if (!src) {
40016604:	00061463          	bnez	a2,4001660c <net_context_create_ipv6_new+0x30>
		src = ((struct sockaddr_in6_ptr *)&context->local)->sin6_addr;
40016608:	02452403          	lw	s0,36(a0)
	if (net_ipv6_is_addr_unspecified(src)
4001660c:	00040513          	mv	a0,s0
40016610:	a88ff0ef          	jal	ra,40015898 <net_ipv6_is_addr_unspecified>
40016614:	00051863          	bnez	a0,40016624 <net_context_create_ipv6_new+0x48>
	    || net_ipv6_is_addr_mcast(src)) {
40016618:	00044703          	lbu	a4,0(s0)
4001661c:	0ff00793          	li	a5,255
40016620:	00f71a63          	bne	a4,a5,40016634 <net_context_create_ipv6_new+0x58>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
40016624:	0184a503          	lw	a0,24(s1)
40016628:	00098593          	mv	a1,s3
4001662c:	e5cfc0ef          	jal	ra,40012c88 <net_if_ipv6_select_src_addr>
40016630:	00050413          	mv	s0,a0
	context->ipv4_ttl = ttl;
}

static inline uint8_t net_context_get_ipv6_hop_limit(struct net_context *context)
{
	return context->ipv6_hop_limit;
40016634:	07794783          	lbu	a5,119(s2)
	return net_ipv6_create(pkt, src, dst);
40016638:	00040593          	mv	a1,s0
4001663c:	00098613          	mv	a2,s3
	pkt->ipv6_hop_limit = hop_limit;
40016640:	02f48ca3          	sb	a5,57(s1)
 *
 * @return Decoded DSCP value.
 */
static inline uint8_t net_ipv6_get_dscp(uint8_t tc)
{
	return (tc & NET_IPV6_DSCP_MASK) >> NET_IPV6_DSCP_OFFSET;
40016644:	07094703          	lbu	a4,112(s2)
	pkt->ip_dscp = dscp;
40016648:	0404c783          	lbu	a5,64(s1)
4001664c:	00048513          	mv	a0,s1
40016650:	00275713          	srli	a4,a4,0x2
40016654:	fc07f793          	andi	a5,a5,-64
40016658:	00e7e7b3          	or	a5,a5,a4
4001665c:	04f48023          	sb	a5,64(s1)
	pkt->ip_ecn = ecn;
40016660:	07094703          	lbu	a4,112(s2)
40016664:	0ff7f793          	zext.b	a5,a5
40016668:	03f7f793          	andi	a5,a5,63
4001666c:	00671713          	slli	a4,a4,0x6
40016670:	00e7e7b3          	or	a5,a5,a4
40016674:	04f48023          	sb	a5,64(s1)
}
40016678:	01812403          	lw	s0,24(sp)
4001667c:	01c12083          	lw	ra,28(sp)
40016680:	01412483          	lw	s1,20(sp)
40016684:	01012903          	lw	s2,16(sp)
40016688:	00c12983          	lw	s3,12(sp)
4001668c:	02010113          	addi	sp,sp,32
	return net_ipv6_create(pkt, src, dst);
40016690:	0580506f          	j	4001b6e8 <net_ipv6_create>

40016694 <context_sendto.constprop.0>:
static int context_sendto(struct net_context *context,
40016694:	fb010113          	addi	sp,sp,-80
40016698:	04812423          	sw	s0,72(sp)
4001669c:	04912223          	sw	s1,68(sp)
400166a0:	03812423          	sw	s8,40(sp)
400166a4:	04112623          	sw	ra,76(sp)
400166a8:	05212023          	sw	s2,64(sp)
400166ac:	03312e23          	sw	s3,60(sp)
400166b0:	03412c23          	sw	s4,56(sp)
400166b4:	03512a23          	sw	s5,52(sp)
400166b8:	03612823          	sw	s6,48(sp)
400166bc:	03712623          	sw	s7,44(sp)
400166c0:	03912223          	sw	s9,36(sp)
400166c4:	03a12023          	sw	s10,32(sp)
400166c8:	05010413          	addi	s0,sp,80
	return context->flags & NET_CONTEXT_IN_USE;
400166cc:	07455903          	lhu	s2,116(a0)
400166d0:	00078c13          	mv	s8,a5
		return -EBADF;
400166d4:	ff700493          	li	s1,-9
	if (!net_context_is_used(context)) {
400166d8:	00197793          	andi	a5,s2,1
400166dc:	02078863          	beqz	a5,4001670c <context_sendto.constprop.0+0x78>
400166e0:	00050a13          	mv	s4,a0
400166e4:	00058b13          	mv	s6,a1
400166e8:	00060993          	mv	s3,a2
400166ec:	00068a93          	mv	s5,a3
400166f0:	00080c93          	mv	s9,a6
	if (sendto && addrlen == 0 && dst_addr == NULL && buf != NULL) {
400166f4:	04088c63          	beqz	a7,4001674c <context_sendto.constprop.0+0xb8>
400166f8:	04071a63          	bnez	a4,4001674c <context_sendto.constprop.0+0xb8>
			return -EINVAL;
400166fc:	fea00493          	li	s1,-22
	if (sendto && addrlen == 0 && dst_addr == NULL && buf != NULL) {
40016700:	00069663          	bnez	a3,4001670c <context_sendto.constprop.0+0x78>
40016704:	08059063          	bnez	a1,40016784 <context_sendto.constprop.0+0xf0>
		return -EDESTADDRREQ;
40016708:	f8700493          	li	s1,-121
}
4001670c:	fb040113          	addi	sp,s0,-80
40016710:	04c12083          	lw	ra,76(sp)
40016714:	00048513          	mv	a0,s1
40016718:	04812403          	lw	s0,72(sp)
4001671c:	04412483          	lw	s1,68(sp)
40016720:	04012903          	lw	s2,64(sp)
40016724:	03c12983          	lw	s3,60(sp)
40016728:	03812a03          	lw	s4,56(sp)
4001672c:	03412a83          	lw	s5,52(sp)
40016730:	03012b03          	lw	s6,48(sp)
40016734:	02c12b83          	lw	s7,44(sp)
40016738:	02812c03          	lw	s8,40(sp)
4001673c:	02412c83          	lw	s9,36(sp)
40016740:	02012d03          	lw	s10,32(sp)
40016744:	05010113          	addi	sp,sp,80
40016748:	00008067          	ret
		return -EDESTADDRREQ;
4001674c:	f8700493          	li	s1,-121
	if (!msghdr && !dst_addr) {
40016750:	fa0a8ee3          	beqz	s5,4001670c <context_sendto.constprop.0+0x78>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40016754:	00395793          	srli	a5,s2,0x3
40016758:	0077f793          	andi	a5,a5,7
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
4001675c:	00200693          	li	a3,2
40016760:	12d78063          	beq	a5,a3,40016880 <context_sendto.constprop.0+0x1ec>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40016764:	00100693          	li	a3,1
40016768:	00000b93          	li	s7,0
			return -EINVAL;
4001676c:	fea00493          	li	s1,-22
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40016770:	f8d79ee3          	bne	a5,a3,4001670c <context_sendto.constprop.0+0x78>
		if (addrlen < sizeof(struct sockaddr_in)) {
40016774:	00700793          	li	a5,7
			return -EINVAL;
40016778:	fea00493          	li	s1,-22
		if (addrlen < sizeof(struct sockaddr_in)) {
4001677c:	10e7ea63          	bltu	a5,a4,40016890 <context_sendto.constprop.0+0x1fc>
40016780:	f8dff06f          	j	4001670c <context_sendto.constprop.0+0x78>
40016784:	00395793          	srli	a5,s2,0x3
40016788:	0077f793          	andi	a5,a5,7
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
4001678c:	00200713          	li	a4,2
40016790:	02e78063          	beq	a5,a4,400167b0 <context_sendto.constprop.0+0x11c>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40016794:	00100713          	li	a4,1
40016798:	f6e79ae3          	bne	a5,a4,4001670c <context_sendto.constprop.0+0x78>
			addr4 = msghdr->msg_name;
4001679c:	0005aa83          	lw	s5,0(a1)
			if (!addr4) {
400167a0:	0e0a8463          	beqz	s5,40016888 <context_sendto.constprop.0+0x1f4>
			addrlen = msghdr->msg_namelen;
400167a4:	0045a703          	lw	a4,4(a1)
400167a8:	00058b93          	mv	s7,a1
400167ac:	fc9ff06f          	j	40016774 <context_sendto.constprop.0+0xe0>
			addr6 = msghdr->msg_name;
400167b0:	0005aa83          	lw	s5,0(a1)
			if (!addr6) {
400167b4:	000a8e63          	beqz	s5,400167d0 <context_sendto.constprop.0+0x13c>
			addrlen = msghdr->msg_namelen;
400167b8:	0045a703          	lw	a4,4(a1)
400167bc:	00058b93          	mv	s7,a1
		if (addrlen < sizeof(struct sockaddr_in6)) {
400167c0:	01700793          	li	a5,23
			return -EINVAL;
400167c4:	fea00493          	li	s1,-22
		if (addrlen < sizeof(struct sockaddr_in6)) {
400167c8:	00e7e863          	bltu	a5,a4,400167d8 <context_sendto.constprop.0+0x144>
400167cc:	f41ff06f          	j	4001670c <context_sendto.constprop.0+0x78>
				addr6 = net_sin6(&context->remote);
400167d0:	02c50a93          	addi	s5,a0,44
400167d4:	00058b93          	mv	s7,a1
		if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
400167d8:	004a8d13          	addi	s10,s5,4 # 8000004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x20a1f04>
400167dc:	000d0513          	mv	a0,s10
400167e0:	8b8ff0ef          	jal	ra,40015898 <net_ipv6_is_addr_unspecified>
		return -EDESTADDRREQ;
400167e4:	f8700493          	li	s1,-121
		if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
400167e8:	f20512e3          	bnez	a0,4001670c <context_sendto.constprop.0+0x78>
		if (net_ipv6_is_addr_unspecified(
400167ec:	030a0513          	addi	a0,s4,48
400167f0:	8a8ff0ef          	jal	ra,40015898 <net_ipv6_is_addr_unspecified>
400167f4:	02050063          	beqz	a0,40016814 <context_sendto.constprop.0+0x180>
				&net_sin6(&context->remote)->sin6_addr) &&
400167f8:	00b95913          	srli	s2,s2,0xb
400167fc:	00197913          	andi	s2,s2,1
40016800:	00091a63          	bnez	s2,40016814 <context_sendto.constprop.0+0x180>
			iface = net_if_ipv6_select_src_iface(&addr6->sin6_addr);
40016804:	000d0513          	mv	a0,s10
40016808:	da4fc0ef          	jal	ra,40012dac <net_if_ipv6_select_src_iface>
	context->iface = net_if_get_by_iface(iface);
4001680c:	b54fd0ef          	jal	ra,40013b60 <net_if_get_by_iface>
40016810:	06aa0b23          	sb	a0,118(s4)
	if (msghdr && len == 0) {
40016814:	000b8a63          	beqz	s7,40016828 <context_sendto.constprop.0+0x194>
40016818:	00099863          	bnez	s3,40016828 <context_sendto.constprop.0+0x194>
4001681c:	00cba683          	lw	a3,12(s7)
		for (i = 0; i < msghdr->msg_iovlen; i++) {
40016820:	00000793          	li	a5,0
40016824:	08d79c63          	bne	a5,a3,400168bc <context_sendto.constprop.0+0x228>
	return net_if_get_by_index(context->iface);
40016828:	076a0503          	lb	a0,118(s4)
4001682c:	b00fa0ef          	jal	ra,40010b2c <z_impl_net_if_get_by_index>
40016830:	00050493          	mv	s1,a0
	if (iface && !net_if_is_up(iface)) {
40016834:	0a051263          	bnez	a0,400168d8 <context_sendto.constprop.0+0x244>
40016838:	076a0503          	lb	a0,118(s4)
4001683c:	af0fa0ef          	jal	ra,40010b2c <z_impl_net_if_get_by_index>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40016840:	074a5603          	lhu	a2,116(s4)
	pkt = net_pkt_alloc_with_buffer(net_context_get_iface(context), len,
40016844:	072a5683          	lhu	a3,114(s4)
40016848:	06400713          	li	a4,100
4001684c:	00365613          	srli	a2,a2,0x3
40016850:	00000793          	li	a5,0
40016854:	00767613          	andi	a2,a2,7
40016858:	00098593          	mv	a1,s3
4001685c:	02d010ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
40016860:	00050913          	mv	s2,a0
	if (pkt) {
40016864:	0a051663          	bnez	a0,40016910 <context_sendto.constprop.0+0x27c>
		NET_ERR("Failed to allocate net_pkt");
40016868:	40044537          	lui	a0,0x40044
4001686c:	75c52783          	lw	a5,1884(a0) # 4004475c <log_dynamic_net_ctx>
40016870:	0077f793          	andi	a5,a5,7
40016874:	16079c63          	bnez	a5,400169ec <context_sendto.constprop.0+0x358>
		return -ENOBUFS;
40016878:	f9700493          	li	s1,-105
4001687c:	e91ff06f          	j	4001670c <context_sendto.constprop.0+0x78>
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40016880:	00000b93          	li	s7,0
40016884:	f3dff06f          	j	400167c0 <context_sendto.constprop.0+0x12c>
				addr4 = net_sin(&context->remote);
40016888:	02c50a93          	addi	s5,a0,44
4001688c:	00058b93          	mv	s7,a1
		if (!addr4->sin_addr.s_addr) {
40016890:	004aa783          	lw	a5,4(s5)
		return -EDESTADDRREQ;
40016894:	f8700493          	li	s1,-121
		if (!addr4->sin_addr.s_addr) {
40016898:	e6078ae3          	beqz	a5,4001670c <context_sendto.constprop.0+0x78>
		if (net_sin(&context->remote)->sin_addr.s_addr == 0U &&
4001689c:	030a2783          	lw	a5,48(s4)
400168a0:	f6079ae3          	bnez	a5,40016814 <context_sendto.constprop.0+0x180>
400168a4:	00b95913          	srli	s2,s2,0xb
400168a8:	00197913          	andi	s2,s2,1
400168ac:	f60914e3          	bnez	s2,40016814 <context_sendto.constprop.0+0x180>
			iface = net_if_ipv4_select_src_iface(&addr4->sin_addr);
400168b0:	004a8513          	addi	a0,s5,4
400168b4:	851fc0ef          	jal	ra,40013104 <net_if_ipv4_select_src_iface>
400168b8:	f55ff06f          	j	4001680c <context_sendto.constprop.0+0x178>
			len += msghdr->msg_iov[i].iov_len;
400168bc:	008ba703          	lw	a4,8(s7)
400168c0:	00379613          	slli	a2,a5,0x3
		for (i = 0; i < msghdr->msg_iovlen; i++) {
400168c4:	00178793          	addi	a5,a5,1
			len += msghdr->msg_iov[i].iov_len;
400168c8:	00c70733          	add	a4,a4,a2
400168cc:	00472703          	lw	a4,4(a4)
400168d0:	00e989b3          	add	s3,s3,a4
		for (i = 0; i < msghdr->msg_iovlen; i++) {
400168d4:	f51ff06f          	j	40016824 <context_sendto.constprop.0+0x190>
	return atomic_test_bit(iface->if_dev->flags, value);
400168d8:	00052503          	lw	a0,0(a0)
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
400168dc:	00c50513          	addi	a0,a0,12
400168e0:	1a81b0ef          	jal	ra,40031a88 <atomic_get>
	return net_if_flag_is_set(iface, NET_IF_UP) &&
400168e4:	00157513          	andi	a0,a0,1
400168e8:	00051663          	bnez	a0,400168f4 <context_sendto.constprop.0+0x260>
		return -ENETDOWN;
400168ec:	f8d00493          	li	s1,-115
400168f0:	e1dff06f          	j	4001670c <context_sendto.constprop.0+0x78>
	return atomic_test_bit(iface->if_dev->flags, value);
400168f4:	0004a503          	lw	a0,0(s1)
400168f8:	00c50513          	addi	a0,a0,12
400168fc:	18c1b0ef          	jal	ra,40031a88 <atomic_get>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
40016900:	40855513          	srai	a0,a0,0x8
	return net_if_flag_is_set(iface, NET_IF_UP) &&
40016904:	00157513          	andi	a0,a0,1
40016908:	f20518e3          	bnez	a0,40016838 <context_sendto.constprop.0+0x1a4>
4001690c:	fe1ff06f          	j	400168ec <context_sendto.constprop.0+0x258>
	pkt->context = ctx;
40016910:	01452a23          	sw	s4,20(a0)
	tmp_len = net_pkt_available_payload_buffer(
40016914:	072a5583          	lhu	a1,114(s4)
40016918:	068010ef          	jal	ra,40017980 <net_pkt_available_payload_buffer>
	if (tmp_len < len) {
4001691c:	11356063          	bltu	a0,s3,40016a1c <context_sendto.constprop.0+0x388>
	return context->proto;
40016920:	072a5783          	lhu	a5,114(s4)
	context->send_cb = cb;
40016924:	058a2623          	sw	s8,76(s4)
	context->user_data = user_data;
40016928:	019a2223          	sw	s9,4(s4)
	} else if (IS_ENABLED(CONFIG_NET_UDP) &&
4001692c:	01100713          	li	a4,17
40016930:	1ae79663          	bne	a5,a4,40016adc <context_sendto.constprop.0+0x448>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40016934:	074a5783          	lhu	a5,116(s4)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40016938:	00200713          	li	a4,2
4001693c:	0037d793          	srli	a5,a5,0x3
40016940:	0077f793          	andi	a5,a5,7
40016944:	14e79c63          	bne	a5,a4,40016a9c <context_sendto.constprop.0+0x408>
		ret = net_context_create_ipv6_new(context, pkt,
40016948:	004a8693          	addi	a3,s5,4
4001694c:	00000613          	li	a2,0
40016950:	00090593          	mv	a1,s2
40016954:	000a0513          	mv	a0,s4
		dst_port = addr6->sin6_port;
40016958:	002adc03          	lhu	s8,2(s5)
		ret = net_context_create_ipv6_new(context, pkt,
4001695c:	c81ff0ef          	jal	ra,400165dc <net_context_create_ipv6_new>
		ret = net_context_create_ipv4_new(context, pkt,
40016960:	00050493          	mv	s1,a0
	if (ret < 0) {
40016964:	12054263          	bltz	a0,40016a88 <context_sendto.constprop.0+0x3f4>
	ret = bind_default(context);
40016968:	000a0513          	mv	a0,s4
4001696c:	a99ff0ef          	jal	ra,40016404 <bind_default>
40016970:	00050493          	mv	s1,a0
	if (ret) {
40016974:	02051a63          	bnez	a0,400169a8 <context_sendto.constprop.0+0x314>
	ret = net_udp_create(pkt,
40016978:	022a5583          	lhu	a1,34(s4)
4001697c:	000c0613          	mv	a2,s8
40016980:	00090513          	mv	a0,s2
40016984:	2b00e0ef          	jal	ra,40024c34 <net_udp_create>
40016988:	00050493          	mv	s1,a0
	if (ret) {
4001698c:	00051e63          	bnez	a0,400169a8 <context_sendto.constprop.0+0x314>
	ret = context_write_data(pkt, buf, len, msg);
40016990:	000b8693          	mv	a3,s7
40016994:	00098613          	mv	a2,s3
40016998:	000b0593          	mv	a1,s6
4001699c:	00090513          	mv	a0,s2
400169a0:	964ff0ef          	jal	ra,40015b04 <context_write_data>
400169a4:	00050493          	mv	s1,a0
		if (ret < 0) {
400169a8:	0e04c063          	bltz	s1,40016a88 <context_sendto.constprop.0+0x3f4>
	net_pkt_cursor_init(pkt);
400169ac:	00090513          	mv	a0,s2
400169b0:	140010ef          	jal	ra,40017af0 <net_pkt_cursor_init>
400169b4:	074a5783          	lhu	a5,116(s4)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
400169b8:	00200713          	li	a4,2
400169bc:	0037d793          	srli	a5,a5,0x3
400169c0:	0077f793          	andi	a5,a5,7
400169c4:	10e79063          	bne	a5,a4,40016ac4 <context_sendto.constprop.0+0x430>
		net_ipv6_finalize(pkt, net_context_get_proto(context));
400169c8:	072a4583          	lbu	a1,114(s4)
400169cc:	00090513          	mv	a0,s2
400169d0:	60d040ef          	jal	ra,4001b7dc <net_ipv6_finalize>
		ret = net_send_data(pkt);
400169d4:	00090513          	mv	a0,s2
400169d8:	cd5f80ef          	jal	ra,4000f6ac <net_send_data>
		ret = net_tcp_send_data(context, cb, user_data);
400169dc:	00050493          	mv	s1,a0
	if (ret < 0) {
400169e0:	0a054463          	bltz	a0,40016a88 <context_sendto.constprop.0+0x3f4>
	return len;
400169e4:	00098493          	mv	s1,s3
400169e8:	d25ff06f          	j	4001670c <context_sendto.constprop.0+0x78>
		NET_ERR("Failed to allocate net_pkt");
400169ec:	400357b7          	lui	a5,0x40035
400169f0:	d7478793          	addi	a5,a5,-652 # 40034d74 <in6addr_any+0xc8>
400169f4:	fcf42623          	sw	a5,-52(s0)
400169f8:	00200793          	li	a5,2
400169fc:	fcf42423          	sw	a5,-56(s0)
40016a00:	000015b7          	lui	a1,0x1
40016a04:	00000693          	li	a3,0
40016a08:	fc840613          	addi	a2,s0,-56
40016a0c:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
40016a10:	75c50513          	addi	a0,a0,1884
40016a14:	d80ee0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
40016a18:	e61ff06f          	j	40016878 <context_sendto.constprop.0+0x1e4>
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
40016a1c:	074a5783          	lhu	a5,116(s4)
		if (net_context_get_type(context) == SOCK_DGRAM) {
40016a20:	00200713          	li	a4,2
40016a24:	0067d793          	srli	a5,a5,0x6
40016a28:	0037f793          	andi	a5,a5,3
40016a2c:	06e79463          	bne	a5,a4,40016a94 <context_sendto.constprop.0+0x400>
			NET_ERR("Available payload buffer (%zu) is not enough for requested DGRAM (%zu)",
40016a30:	40044737          	lui	a4,0x40044
40016a34:	75c72783          	lw	a5,1884(a4) # 4004475c <log_dynamic_net_ctx>
40016a38:	0077f793          	andi	a5,a5,7
40016a3c:	04078463          	beqz	a5,40016a84 <context_sendto.constprop.0+0x3f0>
40016a40:	00010493          	mv	s1,sp
40016a44:	fe010113          	addi	sp,sp,-32
40016a48:	00010613          	mv	a2,sp
40016a4c:	400357b7          	lui	a5,0x40035
40016a50:	d9078793          	addi	a5,a5,-624 # 40034d90 <in6addr_any+0xe4>
40016a54:	00f62a23          	sw	a5,20(a2)
40016a58:	00400793          	li	a5,4
40016a5c:	00a62c23          	sw	a0,24(a2)
40016a60:	01362e23          	sw	s3,28(a2)
40016a64:	00f62823          	sw	a5,16(a2)
40016a68:	000025b7          	lui	a1,0x2
40016a6c:	00000693          	li	a3,0
40016a70:	01060613          	addi	a2,a2,16
40016a74:	04058593          	addi	a1,a1,64 # 2040 <CONFIG_SRAM_SIZE+0x40>
40016a78:	75c70513          	addi	a0,a4,1884
40016a7c:	d18ee0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
40016a80:	00048113          	mv	sp,s1
			ret = -ENOMEM;
40016a84:	ff400493          	li	s1,-12
	net_pkt_unref(pkt);
40016a88:	00090513          	mv	a0,s2
40016a8c:	591000ef          	jal	ra,4001781c <net_pkt_unref>
	return ret;
40016a90:	c7dff06f          	j	4001670c <context_sendto.constprop.0+0x78>
40016a94:	00050993          	mv	s3,a0
40016a98:	e89ff06f          	j	40016920 <context_sendto.constprop.0+0x28c>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40016a9c:	00100713          	li	a4,1
	int ret = -EINVAL;
40016aa0:	fea00493          	li	s1,-22
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40016aa4:	fee792e3          	bne	a5,a4,40016a88 <context_sendto.constprop.0+0x3f4>
		ret = net_context_create_ipv4_new(context, pkt,
40016aa8:	004a8693          	addi	a3,s5,4
40016aac:	00000613          	li	a2,0
40016ab0:	00090593          	mv	a1,s2
40016ab4:	000a0513          	mv	a0,s4
		dst_port = addr4->sin_port;
40016ab8:	002adc03          	lhu	s8,2(s5)
		ret = net_context_create_ipv4_new(context, pkt,
40016abc:	9fdff0ef          	jal	ra,400164b8 <net_context_create_ipv4_new>
40016ac0:	ea1ff06f          	j	40016960 <context_sendto.constprop.0+0x2cc>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40016ac4:	00100713          	li	a4,1
40016ac8:	f0e796e3          	bne	a5,a4,400169d4 <context_sendto.constprop.0+0x340>
		net_ipv4_finalize(pkt, net_context_get_proto(context));
40016acc:	072a4583          	lbu	a1,114(s4)
40016ad0:	00090513          	mv	a0,s2
40016ad4:	1ed030ef          	jal	ra,4001a4c0 <net_ipv4_finalize>
40016ad8:	efdff06f          	j	400169d4 <context_sendto.constprop.0+0x340>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
40016adc:	00600713          	li	a4,6
		ret = -EPROTONOSUPPORT;
40016ae0:	f8500493          	li	s1,-123
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
40016ae4:	fae792e3          	bne	a5,a4,40016a88 <context_sendto.constprop.0+0x3f4>
		ret = context_write_data(pkt, buf, len, msghdr);
40016ae8:	000b8693          	mv	a3,s7
40016aec:	00098613          	mv	a2,s3
40016af0:	000b0593          	mv	a1,s6
40016af4:	00090513          	mv	a0,s2
40016af8:	80cff0ef          	jal	ra,40015b04 <context_write_data>
40016afc:	00050493          	mv	s1,a0
		if (ret < 0) {
40016b00:	f80544e3          	bltz	a0,40016a88 <context_sendto.constprop.0+0x3f4>
		net_pkt_cursor_init(pkt);
40016b04:	00090513          	mv	a0,s2
40016b08:	7e9000ef          	jal	ra,40017af0 <net_pkt_cursor_init>
		ret = net_tcp_queue_data(context, pkt);
40016b0c:	00090593          	mv	a1,s2
40016b10:	000a0513          	mv	a0,s4
40016b14:	6d50b0ef          	jal	ra,400229e8 <net_tcp_queue_data>
40016b18:	00050493          	mv	s1,a0
		if (ret < 0) {
40016b1c:	f60546e3          	bltz	a0,40016a88 <context_sendto.constprop.0+0x3f4>
		ret = net_tcp_send_data(context, cb, user_data);
40016b20:	000c8613          	mv	a2,s9
40016b24:	000c0593          	mv	a1,s8
40016b28:	000a0513          	mv	a0,s4
40016b2c:	3190a0ef          	jal	ra,40021644 <net_tcp_send_data>
40016b30:	eadff06f          	j	400169dc <context_sendto.constprop.0+0x348>

40016b34 <net_context_connect>:
{
40016b34:	f8010113          	addi	sp,sp,-128
40016b38:	05712e23          	sw	s7,92(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40016b3c:	00c50b93          	addi	s7,a0,12
{
40016b40:	06812c23          	sw	s0,120(sp)
40016b44:	07212823          	sw	s2,112(sp)
40016b48:	07412423          	sw	s4,104(sp)
40016b4c:	00050413          	mv	s0,a0
40016b50:	00058913          	mv	s2,a1
40016b54:	00060a13          	mv	s4,a2
	k_mutex_lock(&context->lock, K_FOREVER);
40016b58:	fff00593          	li	a1,-1
40016b5c:	fff00613          	li	a2,-1
40016b60:	000b8513          	mv	a0,s7
{
40016b64:	06912a23          	sw	s1,116(sp)
40016b68:	07312623          	sw	s3,108(sp)
40016b6c:	07512223          	sw	s5,100(sp)
40016b70:	07612023          	sw	s6,96(sp)
40016b74:	05812c23          	sw	s8,88(sp)
40016b78:	00078b13          	mv	s6,a5
40016b7c:	00070c13          	mv	s8,a4
40016b80:	06112e23          	sw	ra,124(sp)
40016b84:	05912a23          	sw	s9,84(sp)
40016b88:	00068993          	mv	s3,a3
40016b8c:	00080a93          	mv	s5,a6
	k_mutex_lock(&context->lock, K_FOREVER);
40016b90:	810ff0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
40016b94:	07445783          	lhu	a5,116(s0)
	if (net_context_get_state(context) == NET_CONTEXT_CONNECTING) {
40016b98:	00100613          	li	a2,1
		ret = -EALREADY;
40016b9c:	f8800493          	li	s1,-120
40016ba0:	0017d713          	srli	a4,a5,0x1
40016ba4:	00377713          	andi	a4,a4,3
	if (net_context_get_state(context) == NET_CONTEXT_CONNECTING) {
40016ba8:	10c70e63          	beq	a4,a2,40016cc4 <net_context_connect+0x190>
	if (!net_context_is_used(context)) {
40016bac:	0017f693          	andi	a3,a5,1
		ret = -EBADF;
40016bb0:	ff700493          	li	s1,-9
	if (!net_context_is_used(context)) {
40016bb4:	10068863          	beqz	a3,40016cc4 <net_context_connect+0x190>
	if (addr->sa_family != net_context_get_family(context)) {
40016bb8:	00095c83          	lhu	s9,0(s2)
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40016bbc:	0037d793          	srli	a5,a5,0x3
40016bc0:	0077f793          	andi	a5,a5,7
		ret = -EINVAL;
40016bc4:	fea00493          	li	s1,-22
	if (addr->sa_family != net_context_get_family(context)) {
40016bc8:	0efc9e63          	bne	s9,a5,40016cc4 <net_context_connect+0x190>
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
40016bcc:	00300793          	li	a5,3
		ret = -EOPNOTSUPP;
40016bd0:	fa100493          	li	s1,-95
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
40016bd4:	0ef70863          	beq	a4,a5,40016cc4 <net_context_connect+0x190>
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40016bd8:	00200793          	li	a5,2
40016bdc:	12fc9c63          	bne	s9,a5,40016d14 <net_context_connect+0x1e0>
		if (addrlen < sizeof(struct sockaddr_in6)) {
40016be0:	01700793          	li	a5,23
		ret = -EINVAL;
40016be4:	fea00493          	li	s1,-22
		if (addrlen < sizeof(struct sockaddr_in6)) {
40016be8:	0d47fe63          	bgeu	a5,s4,40016cc4 <net_context_connect+0x190>
		if (net_context_get_proto(context) == IPPROTO_TCP &&
40016bec:	07245703          	lhu	a4,114(s0)
40016bf0:	00600793          	li	a5,6
40016bf4:	00f71a63          	bne	a4,a5,40016c08 <net_context_connect+0xd4>
40016bf8:	03044703          	lbu	a4,48(s0)
40016bfc:	0ff00793          	li	a5,255
			ret = -EADDRNOTAVAIL;
40016c00:	f8300493          	li	s1,-125
		if (net_context_get_proto(context) == IPPROTO_TCP &&
40016c04:	0cf70063          	beq	a4,a5,40016cc4 <net_context_connect+0x190>
		memcpy(&addr6->sin6_addr, &net_sin6(addr)->sin6_addr,
40016c08:	03040493          	addi	s1,s0,48
40016c0c:	01000613          	li	a2,16
40016c10:	00490593          	addi	a1,s2,4
40016c14:	00048513          	mv	a0,s1
40016c18:	8e0f60ef          	jal	ra,4000ccf8 <memcpy>
		addr6->sin6_port = net_sin6(addr)->sin6_port;
40016c1c:	00295a03          	lhu	s4,2(s2)
		addr6->sin6_family = AF_INET6;
40016c20:	00200793          	li	a5,2
40016c24:	02f41623          	sh	a5,44(s0)
		addr6->sin6_port = net_sin6(addr)->sin6_port;
40016c28:	03441723          	sh	s4,46(s0)
		if (!net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
40016c2c:	00048513          	mv	a0,s1
40016c30:	c69fe0ef          	jal	ra,40015898 <net_ipv6_is_addr_unspecified>
40016c34:	07445783          	lhu	a5,116(s0)
40016c38:	0c051663          	bnez	a0,40016d04 <net_context_connect+0x1d0>
			context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
40016c3c:	1007e793          	ori	a5,a5,256
40016c40:	06f41a23          	sh	a5,116(s0)
		ret = bind_default(context);
40016c44:	00040513          	mv	a0,s0
40016c48:	fbcff0ef          	jal	ra,40016404 <bind_default>
40016c4c:	00050493          	mv	s1,a0
		if (ret) {
40016c50:	06051a63          	bnez	a0,40016cc4 <net_context_connect+0x190>
		net_sin6(&local_addr)->sin6_port = lport =
40016c54:	02245703          	lhu	a4,34(s0)
		if (net_sin6_ptr(&context->local)->sin6_addr) {
40016c58:	02442583          	lw	a1,36(s0)
		net_sin6_ptr(&context->local)->sin6_family = AF_INET6;
40016c5c:	00200793          	li	a5,2
40016c60:	02f41023          	sh	a5,32(s0)
		net_sin6(&local_addr)->sin6_family = AF_INET6;
40016c64:	02f11c23          	sh	a5,56(sp)
		net_sin6(&local_addr)->sin6_port = lport =
40016c68:	02e11d23          	sh	a4,58(sp)
		if (net_sin6_ptr(&context->local)->sin6_addr) {
40016c6c:	02058663          	beqz	a1,40016c98 <net_context_connect+0x164>
			net_ipaddr_copy(&net_sin6(&local_addr)->sin6_addr,
40016c70:	01000613          	li	a2,16
40016c74:	02810513          	addi	a0,sp,40
40016c78:	00e12e23          	sw	a4,28(sp)
40016c7c:	87cf60ef          	jal	ra,4000ccf8 <memcpy>
40016c80:	02810593          	addi	a1,sp,40
40016c84:	01000613          	li	a2,16
40016c88:	03c10513          	addi	a0,sp,60
40016c8c:	86cf60ef          	jal	ra,4000ccf8 <memcpy>
			laddr = &local_addr;
40016c90:	01c12703          	lw	a4,28(sp)
40016c94:	03810593          	addi	a1,sp,56
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
40016c98:	07445783          	lhu	a5,116(s0)
	if (IS_ENABLED(CONFIG_NET_UDP) &&
40016c9c:	00200693          	li	a3,2
40016ca0:	0067d793          	srli	a5,a5,0x6
40016ca4:	0037f793          	andi	a5,a5,3
40016ca8:	10d79e63          	bne	a5,a3,40016dc4 <net_context_connect+0x290>
		if (cb) {
40016cac:	00098a63          	beqz	s3,40016cc0 <net_context_connect+0x18c>
			cb(context, 0, user_data);
40016cb0:	000a8613          	mv	a2,s5
40016cb4:	00000593          	li	a1,0
40016cb8:	00040513          	mv	a0,s0
40016cbc:	000980e7          	jalr	s3
		ret = 0;
40016cc0:	00000493          	li	s1,0
	k_mutex_unlock(&context->lock);
40016cc4:	000b8513          	mv	a0,s7
40016cc8:	eddfe0ef          	jal	ra,40015ba4 <k_mutex_unlock.isra.0>
}
40016ccc:	07c12083          	lw	ra,124(sp)
40016cd0:	07812403          	lw	s0,120(sp)
40016cd4:	07012903          	lw	s2,112(sp)
40016cd8:	06c12983          	lw	s3,108(sp)
40016cdc:	06812a03          	lw	s4,104(sp)
40016ce0:	06412a83          	lw	s5,100(sp)
40016ce4:	06012b03          	lw	s6,96(sp)
40016ce8:	05c12b83          	lw	s7,92(sp)
40016cec:	05812c03          	lw	s8,88(sp)
40016cf0:	05412c83          	lw	s9,84(sp)
40016cf4:	00048513          	mv	a0,s1
40016cf8:	07412483          	lw	s1,116(sp)
40016cfc:	08010113          	addi	sp,sp,128
40016d00:	00008067          	ret
			context->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;
40016d04:	eff7f793          	andi	a5,a5,-257
40016d08:	01079793          	slli	a5,a5,0x10
40016d0c:	0107d793          	srli	a5,a5,0x10
40016d10:	f31ff06f          	j	40016c40 <net_context_connect+0x10c>
		ret = -EINVAL;
40016d14:	fea00493          	li	s1,-22
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40016d18:	facc96e3          	bne	s9,a2,40016cc4 <net_context_connect+0x190>
		if (addrlen < sizeof(struct sockaddr_in)) {
40016d1c:	00700793          	li	a5,7
40016d20:	fb47f2e3          	bgeu	a5,s4,40016cc4 <net_context_connect+0x190>
		memcpy(&addr4->sin_addr, &net_sin(addr)->sin_addr,
40016d24:	00400613          	li	a2,4
40016d28:	00490593          	addi	a1,s2,4
40016d2c:	03040513          	addi	a0,s0,48
40016d30:	fc9f50ef          	jal	ra,4000ccf8 <memcpy>
		addr4->sin_port = net_sin(addr)->sin_port;
40016d34:	00295a03          	lhu	s4,2(s2)
		if (addr4->sin_addr.s_addr) {
40016d38:	03042703          	lw	a4,48(s0)
		addr4->sin_family = AF_INET;
40016d3c:	03941623          	sh	s9,44(s0)
		addr4->sin_port = net_sin(addr)->sin_port;
40016d40:	03441723          	sh	s4,46(s0)
		if (addr4->sin_addr.s_addr) {
40016d44:	07445783          	lhu	a5,116(s0)
40016d48:	06070663          	beqz	a4,40016db4 <net_context_connect+0x280>
			context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
40016d4c:	1007e793          	ori	a5,a5,256
40016d50:	06f41a23          	sh	a5,116(s0)
		ret = bind_default(context);
40016d54:	00040513          	mv	a0,s0
40016d58:	eacff0ef          	jal	ra,40016404 <bind_default>
40016d5c:	00050493          	mv	s1,a0
		if (ret) {
40016d60:	f60512e3          	bnez	a0,40016cc4 <net_context_connect+0x190>
		net_sin(&local_addr)->sin_port = lport =
40016d64:	02245703          	lhu	a4,34(s0)
		if (net_sin_ptr(&context->local)->sin_addr) {
40016d68:	02442583          	lw	a1,36(s0)
		net_sin_ptr(&context->local)->sin_family = AF_INET;
40016d6c:	00100793          	li	a5,1
40016d70:	02f41023          	sh	a5,32(s0)
		net_sin(&local_addr)->sin_family = AF_INET;
40016d74:	02f11c23          	sh	a5,56(sp)
		net_sin(&local_addr)->sin_port = lport =
40016d78:	02e11d23          	sh	a4,58(sp)
		if (net_sin_ptr(&context->local)->sin_addr) {
40016d7c:	f0058ee3          	beqz	a1,40016c98 <net_context_connect+0x164>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
40016d80:	0015c783          	lbu	a5,1(a1)
40016d84:	0005c683          	lbu	a3,0(a1)
40016d88:	00879793          	slli	a5,a5,0x8
40016d8c:	00d7e7b3          	or	a5,a5,a3
40016d90:	0025c683          	lbu	a3,2(a1)
40016d94:	01069693          	slli	a3,a3,0x10
40016d98:	00f6e6b3          	or	a3,a3,a5
40016d9c:	0035c783          	lbu	a5,3(a1)
			laddr = &local_addr;
40016da0:	03810593          	addi	a1,sp,56
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
40016da4:	01879793          	slli	a5,a5,0x18
40016da8:	00d7e7b3          	or	a5,a5,a3
40016dac:	02f12e23          	sw	a5,60(sp)
			laddr = &local_addr;
40016db0:	ee9ff06f          	j	40016c98 <net_context_connect+0x164>
			context->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;
40016db4:	eff7f793          	andi	a5,a5,-257
40016db8:	01079793          	slli	a5,a5,0x10
40016dbc:	0107d793          	srli	a5,a5,0x10
40016dc0:	f91ff06f          	j	40016d50 <net_context_connect+0x21c>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
40016dc4:	00100693          	li	a3,1
		ret = -ENOTSUP;
40016dc8:	f7a00493          	li	s1,-134
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
40016dcc:	eed79ce3          	bne	a5,a3,40016cc4 <net_context_connect+0x190>
		ret = net_tcp_connect(context, addr, laddr, rport, lport,
40016dd0:	00058613          	mv	a2,a1
40016dd4:	01512023          	sw	s5,0(sp)
40016dd8:	00098893          	mv	a7,s3
40016ddc:	000c0793          	mv	a5,s8
40016de0:	000b0813          	mv	a6,s6
40016de4:	000a0693          	mv	a3,s4
40016de8:	00090593          	mv	a1,s2
40016dec:	00040513          	mv	a0,s0
40016df0:	6c00d0ef          	jal	ra,400244b0 <net_tcp_connect>
40016df4:	00050493          	mv	s1,a0
40016df8:	ecdff06f          	j	40016cc4 <net_context_connect+0x190>

40016dfc <net_context_send>:
{
40016dfc:	fd010113          	addi	sp,sp,-48
40016e00:	01412c23          	sw	s4,24(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40016e04:	00c50a13          	addi	s4,a0,12
{
40016e08:	02812423          	sw	s0,40(sp)
40016e0c:	03212023          	sw	s2,32(sp)
40016e10:	01312e23          	sw	s3,28(sp)
40016e14:	00050413          	mv	s0,a0
40016e18:	00058913          	mv	s2,a1
40016e1c:	00060993          	mv	s3,a2
	k_mutex_lock(&context->lock, K_FOREVER);
40016e20:	fff00593          	li	a1,-1
40016e24:	fff00613          	li	a2,-1
40016e28:	000a0513          	mv	a0,s4
{
40016e2c:	02912223          	sw	s1,36(sp)
40016e30:	02112623          	sw	ra,44(sp)
40016e34:	00d12623          	sw	a3,12(sp)
40016e38:	01012423          	sw	a6,8(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40016e3c:	d65fe0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>
	if (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||
40016e40:	07445883          	lhu	a7,116(s0)
		ret = -EDESTADDRREQ;
40016e44:	f8700493          	li	s1,-121
	if (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||
40016e48:	1008f713          	andi	a4,a7,256
40016e4c:	04070a63          	beqz	a4,40016ea0 <net_context_send+0xa4>
40016e50:	02e45703          	lhu	a4,46(s0)
		ret = -EDESTADDRREQ;
40016e54:	f8700493          	li	s1,-121
	if (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||
40016e58:	04070463          	beqz	a4,40016ea0 <net_context_send+0xa4>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40016e5c:	0038d893          	srli	a7,a7,0x3
40016e60:	0078f893          	andi	a7,a7,7
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40016e64:	00200693          	li	a3,2
40016e68:	00812803          	lw	a6,8(sp)
40016e6c:	00c12783          	lw	a5,12(sp)
		addrlen = sizeof(struct sockaddr_in6);
40016e70:	01800713          	li	a4,24
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40016e74:	00d88863          	beq	a7,a3,40016e84 <net_context_send+0x88>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40016e78:	fff88893          	addi	a7,a7,-1
40016e7c:	0018b893          	seqz	a7,a7
40016e80:	00389713          	slli	a4,a7,0x3
	ret = context_sendto(context, buf, len, &context->remote,
40016e84:	00000893          	li	a7,0
40016e88:	02c40693          	addi	a3,s0,44
40016e8c:	00098613          	mv	a2,s3
40016e90:	00090593          	mv	a1,s2
40016e94:	00040513          	mv	a0,s0
40016e98:	ffcff0ef          	jal	ra,40016694 <context_sendto.constprop.0>
40016e9c:	00050493          	mv	s1,a0
	k_mutex_unlock(&context->lock);
40016ea0:	000a0513          	mv	a0,s4
40016ea4:	d01fe0ef          	jal	ra,40015ba4 <k_mutex_unlock.isra.0>
}
40016ea8:	02c12083          	lw	ra,44(sp)
40016eac:	02812403          	lw	s0,40(sp)
40016eb0:	02012903          	lw	s2,32(sp)
40016eb4:	01c12983          	lw	s3,28(sp)
40016eb8:	01812a03          	lw	s4,24(sp)
40016ebc:	00048513          	mv	a0,s1
40016ec0:	02412483          	lw	s1,36(sp)
40016ec4:	03010113          	addi	sp,sp,48
40016ec8:	00008067          	ret

40016ecc <net_context_sendto>:
{
40016ecc:	fd010113          	addi	sp,sp,-48
40016ed0:	01312e23          	sw	s3,28(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40016ed4:	00c50993          	addi	s3,a0,12
{
40016ed8:	02812423          	sw	s0,40(sp)
40016edc:	02912223          	sw	s1,36(sp)
40016ee0:	03212023          	sw	s2,32(sp)
40016ee4:	00050413          	mv	s0,a0
40016ee8:	00058493          	mv	s1,a1
40016eec:	00060913          	mv	s2,a2
	k_mutex_lock(&context->lock, K_FOREVER);
40016ef0:	00098513          	mv	a0,s3
40016ef4:	fff00593          	li	a1,-1
40016ef8:	fff00613          	li	a2,-1
{
40016efc:	02112623          	sw	ra,44(sp)
40016f00:	00d12623          	sw	a3,12(sp)
40016f04:	00e12423          	sw	a4,8(sp)
40016f08:	00f12223          	sw	a5,4(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40016f0c:	c95fe0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>
	ret = context_sendto(context, buf, len, dst_addr, addrlen,
40016f10:	03012803          	lw	a6,48(sp)
40016f14:	00412783          	lw	a5,4(sp)
40016f18:	00812703          	lw	a4,8(sp)
40016f1c:	00c12683          	lw	a3,12(sp)
40016f20:	00090613          	mv	a2,s2
40016f24:	00048593          	mv	a1,s1
40016f28:	00100893          	li	a7,1
40016f2c:	00040513          	mv	a0,s0
40016f30:	f64ff0ef          	jal	ra,40016694 <context_sendto.constprop.0>
40016f34:	00050413          	mv	s0,a0
	k_mutex_unlock(&context->lock);
40016f38:	00098513          	mv	a0,s3
40016f3c:	c69fe0ef          	jal	ra,40015ba4 <k_mutex_unlock.isra.0>
}
40016f40:	02c12083          	lw	ra,44(sp)
40016f44:	00040513          	mv	a0,s0
40016f48:	02812403          	lw	s0,40(sp)
40016f4c:	02412483          	lw	s1,36(sp)
40016f50:	02012903          	lw	s2,32(sp)
40016f54:	01c12983          	lw	s3,28(sp)
40016f58:	03010113          	addi	sp,sp,48
40016f5c:	00008067          	ret

40016f60 <net_context_recv>:

int net_context_recv(struct net_context *context,
		     net_context_recv_cb_t cb,
		     k_timeout_t timeout,
		     void *user_data)
{
40016f60:	f9010113          	addi	sp,sp,-112
40016f64:	06912223          	sw	s1,100(sp)
40016f68:	06112623          	sw	ra,108(sp)
40016f6c:	06812423          	sw	s0,104(sp)
40016f70:	07212023          	sw	s2,96(sp)
40016f74:	05312e23          	sw	s3,92(sp)
40016f78:	05412c23          	sw	s4,88(sp)
40016f7c:	05512a23          	sw	s5,84(sp)
40016f80:	05612823          	sw	s6,80(sp)
40016f84:	05712623          	sw	s7,76(sp)
	return context->flags & NET_CONTEXT_IN_USE;
40016f88:	07455783          	lhu	a5,116(a0)
	int ret;
	NET_ASSERT(context);

	if (!net_context_is_used(context)) {
		return -EBADF;
40016f8c:	ff700493          	li	s1,-9
	if (!net_context_is_used(context)) {
40016f90:	0017f793          	andi	a5,a5,1
40016f94:	16078863          	beqz	a5,40017104 <net_context_recv+0x1a4>
	}

	k_mutex_lock(&context->lock, K_FOREVER);
40016f98:	00c50913          	addi	s2,a0,12
40016f9c:	00050413          	mv	s0,a0
40016fa0:	00058b13          	mv	s6,a1
40016fa4:	00060a13          	mv	s4,a2
40016fa8:	fff00593          	li	a1,-1
40016fac:	fff00613          	li	a2,-1
40016fb0:	00090513          	mv	a0,s2
40016fb4:	00070a93          	mv	s5,a4
40016fb8:	00068993          	mv	s3,a3
40016fbc:	be5fe0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>
	return context->proto;
40016fc0:	07245783          	lhu	a5,114(s0)
			net_context_get_iface(context),
			context, cb, timeout, user_data);
		goto unlock;
	}

	if (IS_ENABLED(CONFIG_NET_UDP) &&
40016fc4:	01100713          	li	a4,17
40016fc8:	1ce79063          	bne	a5,a4,40017188 <net_context_recv+0x228>
	struct sockaddr local_addr = {
40016fcc:	01600613          	li	a2,22
40016fd0:	00000593          	li	a1,0
40016fd4:	02a10513          	addi	a0,sp,42
40016fd8:	d45f50ef          	jal	ra,4000cd1c <memset>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40016fdc:	07445783          	lhu	a5,116(s0)
	if (context->conn_handler) {
40016fe0:	04442503          	lw	a0,68(s0)
40016fe4:	0037d793          	srli	a5,a5,0x3
40016fe8:	0077f793          	andi	a5,a5,7
	struct sockaddr local_addr = {
40016fec:	02f11423          	sh	a5,40(sp)
	if (context->conn_handler) {
40016ff0:	00050663          	beqz	a0,40016ffc <net_context_recv+0x9c>
		net_conn_unregister(context->conn_handler);
40016ff4:	324020ef          	jal	ra,40019318 <net_conn_unregister>
		context->conn_handler = NULL;
40016ff8:	04042223          	sw	zero,68(s0)
	ret = bind_default(context);
40016ffc:	00040513          	mv	a0,s0
40017000:	c04ff0ef          	jal	ra,40016404 <bind_default>
40017004:	00050493          	mv	s1,a0
	if (ret) {
40017008:	0a051a63          	bnez	a0,400170bc <net_context_recv+0x15c>
4001700c:	07445b83          	lhu	s7,116(s0)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40017010:	00200793          	li	a5,2
40017014:	003bd493          	srli	s1,s7,0x3
40017018:	0074f493          	andi	s1,s1,7
4001701c:	10f49c63          	bne	s1,a5,40017134 <net_context_recv+0x1d4>
		if (net_sin6_ptr(&context->local)->sin6_addr) {
40017020:	02442683          	lw	a3,36(s0)
40017024:	02068463          	beqz	a3,4001704c <net_context_recv+0xec>
			net_ipaddr_copy(&net_sin6(&local_addr)->sin6_addr,
40017028:	00068593          	mv	a1,a3
4001702c:	01000613          	li	a2,16
40017030:	01810513          	addi	a0,sp,24
40017034:	cc5f50ef          	jal	ra,4000ccf8 <memcpy>
40017038:	01000613          	li	a2,16
4001703c:	01810593          	addi	a1,sp,24
40017040:	02c10513          	addi	a0,sp,44
40017044:	cb5f50ef          	jal	ra,4000ccf8 <memcpy>
			laddr = &local_addr;
40017048:	02810693          	addi	a3,sp,40
			net_sin6((struct sockaddr *)&context->local)->sin6_port;
4001704c:	02245803          	lhu	a6,34(s0)
		net_sin6(&local_addr)->sin6_port =
40017050:	03011523          	sh	a6,42(sp)
	context->recv_cb = cb;
40017054:	05642423          	sw	s6,72(s0)
	ret = net_conn_register(net_context_get_proto(context),
40017058:	100bfb93          	andi	s7,s7,256
	return context->proto;
4001705c:	07245503          	lhu	a0,114(s0)
40017060:	0ff4f593          	zext.b	a1,s1
40017064:	00000613          	li	a2,0
40017068:	000b8463          	beqz	s7,40017070 <net_context_recv+0x110>
4001706c:	02c40613          	addi	a2,s0,44
40017070:	00881793          	slli	a5,a6,0x8
40017074:	00885813          	srli	a6,a6,0x8
40017078:	0107e7b3          	or	a5,a5,a6
4001707c:	02e45803          	lhu	a6,46(s0)
40017080:	400168b7          	lui	a7,0x40016
40017084:	01079793          	slli	a5,a5,0x10
40017088:	00881713          	slli	a4,a6,0x8
4001708c:	00885813          	srli	a6,a6,0x8
40017090:	01076733          	or	a4,a4,a6
40017094:	01071713          	slli	a4,a4,0x10
40017098:	04440813          	addi	a6,s0,68
4001709c:	01012223          	sw	a6,4(sp)
400170a0:	01512023          	sw	s5,0(sp)
400170a4:	ba888893          	addi	a7,a7,-1112 # 40015ba8 <net_context_packet_received>
400170a8:	00040813          	mv	a6,s0
400170ac:	0107d793          	srli	a5,a5,0x10
400170b0:	01075713          	srli	a4,a4,0x10
400170b4:	55d010ef          	jal	ra,40018e10 <net_conn_register>
	    net_context_get_proto(context) == IPPROTO_UDP) {
		ret = recv_udp(context, cb, timeout, user_data);
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
		   net_context_get_proto(context) == IPPROTO_TCP) {
		ret = net_tcp_recv(context, cb, user_data);
400170b8:	00050493          	mv	s1,a0
		} else {
			ret = -EPROTOTYPE;
		}
	}

	if (ret < 0) {
400170bc:	0404c063          	bltz	s1,400170fc <net_context_recv+0x19c>
		goto unlock;
	}

#if defined(CONFIG_NET_CONTEXT_SYNC_RECV)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
400170c0:	013a67b3          	or	a5,s4,s3
400170c4:	02078c63          	beqz	a5,400170fc <net_context_recv+0x19c>

		/* Make sure we have the lock, then the
		 * net_context_packet_received() callback will release the
		 * semaphore when data has been received.
		 */
		k_sem_reset(&context->recv_data_wait);
400170c8:	05840413          	addi	s0,s0,88
	z_impl_k_sem_reset(sem);
400170cc:	00040513          	mv	a0,s0
400170d0:	12d180ef          	jal	ra,4002f9fc <z_impl_k_sem_reset>

		k_mutex_unlock(&context->lock);
400170d4:	00090513          	mv	a0,s2
400170d8:	acdfe0ef          	jal	ra,40015ba4 <k_mutex_unlock.isra.0>
	return z_impl_k_sem_take(sem, timeout);
400170dc:	000a0593          	mv	a1,s4
400170e0:	00098613          	mv	a2,s3
400170e4:	00040513          	mv	a0,s0
400170e8:	0c1180ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>

		ret = k_sem_take(&context->recv_data_wait, timeout);

		k_mutex_lock(&context->lock, K_FOREVER);
400170ec:	fff00593          	li	a1,-1
400170f0:	fff00613          	li	a2,-1
400170f4:	00090513          	mv	a0,s2
400170f8:	aa9fe0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>
		}
	}
#endif /* CONFIG_NET_CONTEXT_SYNC_RECV */

unlock:
	k_mutex_unlock(&context->lock);
400170fc:	00090513          	mv	a0,s2
40017100:	aa5fe0ef          	jal	ra,40015ba4 <k_mutex_unlock.isra.0>

	return ret;
}
40017104:	06c12083          	lw	ra,108(sp)
40017108:	06812403          	lw	s0,104(sp)
4001710c:	06012903          	lw	s2,96(sp)
40017110:	05c12983          	lw	s3,92(sp)
40017114:	05812a03          	lw	s4,88(sp)
40017118:	05412a83          	lw	s5,84(sp)
4001711c:	05012b03          	lw	s6,80(sp)
40017120:	04c12b83          	lw	s7,76(sp)
40017124:	00048513          	mv	a0,s1
40017128:	06412483          	lw	s1,100(sp)
4001712c:	07010113          	addi	sp,sp,112
40017130:	00008067          	ret
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40017134:	00100793          	li	a5,1
40017138:	04f49263          	bne	s1,a5,4001717c <net_context_recv+0x21c>
		if (net_sin_ptr(&context->local)->sin_addr) {
4001713c:	02442683          	lw	a3,36(s0)
40017140:	02068a63          	beqz	a3,40017174 <net_context_recv+0x214>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
40017144:	0016c783          	lbu	a5,1(a3)
40017148:	0006c703          	lbu	a4,0(a3)
4001714c:	00879793          	slli	a5,a5,0x8
40017150:	00e7e7b3          	or	a5,a5,a4
40017154:	0026c703          	lbu	a4,2(a3)
40017158:	01071713          	slli	a4,a4,0x10
4001715c:	00f76733          	or	a4,a4,a5
40017160:	0036c783          	lbu	a5,3(a3)
			laddr = &local_addr;
40017164:	02810693          	addi	a3,sp,40
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
40017168:	01879793          	slli	a5,a5,0x18
4001716c:	00e7e7b3          	or	a5,a5,a4
40017170:	02f12623          	sw	a5,44(sp)
		lport = net_sin((struct sockaddr *)&context->local)->sin_port;
40017174:	02245803          	lhu	a6,34(s0)
40017178:	eddff06f          	j	40017054 <net_context_recv+0xf4>
	uint16_t lport = 0U;
4001717c:	00000813          	li	a6,0
	struct sockaddr *laddr = NULL;
40017180:	00000693          	li	a3,0
40017184:	ed1ff06f          	j	40017054 <net_context_recv+0xf4>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
40017188:	00600713          	li	a4,6
			ret = -EPROTOTYPE;
4001718c:	f9500493          	li	s1,-107
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
40017190:	f6e796e3          	bne	a5,a4,400170fc <net_context_recv+0x19c>
		ret = net_tcp_recv(context, cb, user_data);
40017194:	000a8613          	mv	a2,s5
40017198:	000b0593          	mv	a1,s6
4001719c:	00040513          	mv	a0,s0
400171a0:	4d40a0ef          	jal	ra,40021674 <net_tcp_recv>
400171a4:	f15ff06f          	j	400170b8 <net_context_recv+0x158>

400171a8 <net_context_update_recv_wnd>:

int net_context_update_recv_wnd(struct net_context *context,
				int32_t delta)
{
400171a8:	ff010113          	addi	sp,sp,-16
400171ac:	01212023          	sw	s2,0(sp)
	if (IS_ENABLED(CONFIG_NET_OFFLOAD) &&
		net_if_is_ip_offloaded(net_context_get_iface(context))) {
		return 0;
	}

	k_mutex_lock(&context->lock, K_FOREVER);
400171b0:	00c50913          	addi	s2,a0,12
{
400171b4:	00812423          	sw	s0,8(sp)
400171b8:	00912223          	sw	s1,4(sp)
400171bc:	00050413          	mv	s0,a0
400171c0:	00058493          	mv	s1,a1
	k_mutex_lock(&context->lock, K_FOREVER);
400171c4:	fff00613          	li	a2,-1
400171c8:	00090513          	mv	a0,s2
400171cc:	fff00593          	li	a1,-1
{
400171d0:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
400171d4:	9cdfe0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>

	ret = net_tcp_update_recv_wnd(context, delta);
400171d8:	00048593          	mv	a1,s1
400171dc:	00040513          	mv	a0,s0
400171e0:	4480b0ef          	jal	ra,40022628 <net_tcp_update_recv_wnd>
400171e4:	00050413          	mv	s0,a0

	k_mutex_unlock(&context->lock);
400171e8:	00090513          	mv	a0,s2
400171ec:	9b9fe0ef          	jal	ra,40015ba4 <k_mutex_unlock.isra.0>

	return ret;
}
400171f0:	00c12083          	lw	ra,12(sp)
400171f4:	00040513          	mv	a0,s0
400171f8:	00812403          	lw	s0,8(sp)
400171fc:	00412483          	lw	s1,4(sp)
40017200:	00012903          	lw	s2,0(sp)
40017204:	01010113          	addi	sp,sp,16
40017208:	00008067          	ret

4001720c <net_context_foreach>:

	return ret;
}

void net_context_foreach(net_context_cb_t cb, void *user_data)
{
4001720c:	fe010113          	addi	sp,sp,-32
40017210:	01212823          	sw	s2,16(sp)
40017214:	01312623          	sw	s3,12(sp)
40017218:	00112e23          	sw	ra,28(sp)
4001721c:	00812c23          	sw	s0,24(sp)
40017220:	00912a23          	sw	s1,20(sp)
40017224:	01412423          	sw	s4,8(sp)
40017228:	01512223          	sw	s5,4(sp)
4001722c:	00050913          	mv	s2,a0
40017230:	00058993          	mv	s3,a1
40017234:	4003aa37          	lui	s4,0x4003a
40017238:	4003a437          	lui	s0,0x4003a
4001723c:	fff00593          	li	a1,-1
40017240:	fff00613          	li	a2,-1
40017244:	770a0513          	addi	a0,s4,1904 # 4003a770 <contexts_lock>
40017248:	78840413          	addi	s0,s0,1928 # 4003a788 <contexts>
4001724c:	75c180ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
	int i;

	k_sem_take(&contexts_lock, K_FOREVER);

	for (i = 0; i < NET_MAX_CONTEXT; i++) {
40017250:	4b040a93          	addi	s5,s0,1200
	return context->flags & NET_CONTEXT_IN_USE;
40017254:	07445783          	lhu	a5,116(s0)
		if (!net_context_is_used(&contexts[i])) {
40017258:	0017f793          	andi	a5,a5,1
4001725c:	02078663          	beqz	a5,40017288 <net_context_foreach+0x7c>
			continue;
		}

		k_mutex_lock(&contexts[i].lock, K_FOREVER);
40017260:	00c40493          	addi	s1,s0,12
40017264:	fff00593          	li	a1,-1
40017268:	fff00613          	li	a2,-1
4001726c:	00048513          	mv	a0,s1
40017270:	931fe0ef          	jal	ra,40015ba0 <k_mutex_lock.constprop.0.isra.0>

		cb(&contexts[i], user_data);
40017274:	00040513          	mv	a0,s0
40017278:	00098593          	mv	a1,s3
4001727c:	000900e7          	jalr	s2

		k_mutex_unlock(&contexts[i].lock);
40017280:	00048513          	mv	a0,s1
40017284:	921fe0ef          	jal	ra,40015ba4 <k_mutex_unlock.isra.0>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
40017288:	07840413          	addi	s0,s0,120
4001728c:	fd5414e3          	bne	s0,s5,40017254 <net_context_foreach+0x48>
	}

	k_sem_give(&contexts_lock);
}
40017290:	01812403          	lw	s0,24(sp)
40017294:	01c12083          	lw	ra,28(sp)
40017298:	01412483          	lw	s1,20(sp)
4001729c:	01012903          	lw	s2,16(sp)
400172a0:	00c12983          	lw	s3,12(sp)
400172a4:	00412a83          	lw	s5,4(sp)
	z_impl_k_sem_give(sem);
400172a8:	770a0513          	addi	a0,s4,1904
400172ac:	00812a03          	lw	s4,8(sp)
400172b0:	02010113          	addi	sp,sp,32
400172b4:	6841806f          	j	4002f938 <z_impl_k_sem_give>

400172b8 <net_context_init>:
	return z_impl_k_sem_init(sem, initial_count, limit);
400172b8:	4003a537          	lui	a0,0x4003a
400172bc:	fff00613          	li	a2,-1
400172c0:	00100593          	li	a1,1
400172c4:	77050513          	addi	a0,a0,1904 # 4003a770 <contexts_lock>
400172c8:	6381806f          	j	4002f900 <z_impl_k_sem_init>

400172cc <pkt_cursor_jump>:
		pkt->cursor.pos = NULL;
	}
}

static void pkt_cursor_jump(struct net_pkt *pkt, bool write)
{
400172cc:	ff010113          	addi	sp,sp,-16
400172d0:	00812423          	sw	s0,8(sp)
400172d4:	00912223          	sw	s1,4(sp)
400172d8:	00112623          	sw	ra,12(sp)
	struct net_pkt_cursor *cursor = &pkt->cursor;

	cursor->buf = cursor->buf->frags;
400172dc:	00c52783          	lw	a5,12(a0)
{
400172e0:	00050413          	mv	s0,a0
400172e4:	00058493          	mv	s1,a1
	while (cursor->buf) {
		const size_t len =
			write ? net_buf_max_len(cursor->buf) : cursor->buf->len;

		if (!len) {
			cursor->buf = cursor->buf->frags;
400172e8:	0047a503          	lw	a0,4(a5)
	cursor->buf = cursor->buf->frags;
400172ec:	00a42623          	sw	a0,12(s0)
	while (cursor->buf) {
400172f0:	00050c63          	beqz	a0,40017308 <pkt_cursor_jump+0x3c>
			write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
400172f4:	02048a63          	beqz	s1,40017328 <pkt_cursor_jump+0x5c>
	return net_buf_simple_max_len(&buf->b);
400172f8:	00c50513          	addi	a0,a0,12
400172fc:	d48f60ef          	jal	ra,4000d844 <net_buf_simple_max_len>
			cursor->buf = cursor->buf->frags;
40017300:	00c42783          	lw	a5,12(s0)
		if (!len) {
40017304:	fe0502e3          	beqz	a0,400172e8 <pkt_cursor_jump+0x1c>
		} else {
			break;
		}
	}

	if (cursor->buf) {
40017308:	00c42783          	lw	a5,12(s0)
4001730c:	02079263          	bnez	a5,40017330 <pkt_cursor_jump+0x64>
40017310:	00f42823          	sw	a5,16(s0)
		cursor->pos = cursor->buf->data;
	} else {
		cursor->pos = NULL;
	}
}
40017314:	00c12083          	lw	ra,12(sp)
40017318:	00812403          	lw	s0,8(sp)
4001731c:	00412483          	lw	s1,4(sp)
40017320:	01010113          	addi	sp,sp,16
40017324:	00008067          	ret
			write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
40017328:	01055503          	lhu	a0,16(a0)
4001732c:	fd5ff06f          	j	40017300 <pkt_cursor_jump+0x34>
		cursor->pos = cursor->buf->data;
40017330:	00c7a783          	lw	a5,12(a5)
40017334:	fddff06f          	j	40017310 <pkt_cursor_jump+0x44>

40017338 <pkt_cursor_advance>:

static void pkt_cursor_advance(struct net_pkt *pkt, bool write)
{
40017338:	fe010113          	addi	sp,sp,-32
4001733c:	00812c23          	sw	s0,24(sp)
40017340:	00112e23          	sw	ra,28(sp)
40017344:	00050413          	mv	s0,a0
	struct net_pkt_cursor *cursor = &pkt->cursor;
	size_t len;

	if (!cursor->buf) {
40017348:	00c52503          	lw	a0,12(a0)
4001734c:	04050463          	beqz	a0,40017394 <pkt_cursor_advance+0x5c>
		return;
	}

	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
40017350:	02058e63          	beqz	a1,4001738c <pkt_cursor_advance+0x54>
40017354:	00c50513          	addi	a0,a0,12
40017358:	00b12623          	sw	a1,12(sp)
4001735c:	ce8f60ef          	jal	ra,4000d844 <net_buf_simple_max_len>
40017360:	00c12583          	lw	a1,12(sp)
	if ((cursor->pos - cursor->buf->data) == len) {
40017364:	00c42703          	lw	a4,12(s0)
40017368:	01042783          	lw	a5,16(s0)
4001736c:	00c72703          	lw	a4,12(a4)
40017370:	40e787b3          	sub	a5,a5,a4
40017374:	02a79063          	bne	a5,a0,40017394 <pkt_cursor_advance+0x5c>
		pkt_cursor_jump(pkt, write);
40017378:	00040513          	mv	a0,s0
	}
}
4001737c:	01812403          	lw	s0,24(sp)
40017380:	01c12083          	lw	ra,28(sp)
40017384:	02010113          	addi	sp,sp,32
		pkt_cursor_jump(pkt, write);
40017388:	f45ff06f          	j	400172cc <pkt_cursor_jump>
	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
4001738c:	01055503          	lhu	a0,16(a0)
40017390:	fd5ff06f          	j	40017364 <pkt_cursor_advance+0x2c>
}
40017394:	01c12083          	lw	ra,28(sp)
40017398:	01812403          	lw	s0,24(sp)
4001739c:	02010113          	addi	sp,sp,32
400173a0:	00008067          	ret

400173a4 <pkt_cursor_update>:

static void pkt_cursor_update(struct net_pkt *pkt,
			      size_t length, bool write)
{
400173a4:	fe010113          	addi	sp,sp,-32
400173a8:	00812c23          	sw	s0,24(sp)
400173ac:	01312623          	sw	s3,12(sp)
400173b0:	00112e23          	sw	ra,28(sp)
400173b4:	00912a23          	sw	s1,20(sp)
400173b8:	01212823          	sw	s2,16(sp)
400173bc:	00050413          	mv	s0,a0
	return pkt->overwrite;
400173c0:	03744783          	lbu	a5,55(s0)

	if (net_pkt_is_being_overwritten(pkt)) {
		write = false;
	}

	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
400173c4:	00c52503          	lw	a0,12(a0)
{
400173c8:	00058993          	mv	s3,a1
	if (net_pkt_is_being_overwritten(pkt)) {
400173cc:	0017f793          	andi	a5,a5,1
400173d0:	06079063          	bnez	a5,40017430 <pkt_cursor_update+0x8c>
400173d4:	00060913          	mv	s2,a2
	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
400173d8:	04060c63          	beqz	a2,40017430 <pkt_cursor_update+0x8c>
400173dc:	00c50513          	addi	a0,a0,12
400173e0:	c64f60ef          	jal	ra,4000d844 <net_buf_simple_max_len>
400173e4:	00050493          	mv	s1,a0
	if (length + (cursor->pos - cursor->buf->data) == len &&
400173e8:	00c42503          	lw	a0,12(s0)
400173ec:	01042783          	lw	a5,16(s0)
400173f0:	00c52703          	lw	a4,12(a0)
400173f4:	40e787b3          	sub	a5,a5,a4
400173f8:	013787b3          	add	a5,a5,s3
400173fc:	04979663          	bne	a5,s1,40017448 <pkt_cursor_update+0xa4>
40017400:	03744783          	lbu	a5,55(s0)
40017404:	0017f793          	andi	a5,a5,1
40017408:	02079a63          	bnez	a5,4001743c <pkt_cursor_update+0x98>
	    !(net_pkt_is_being_overwritten(pkt) &&
	      len < net_buf_max_len(cursor->buf))) {
		pkt_cursor_jump(pkt, write);
4001740c:	00040513          	mv	a0,s0
	} else {
		cursor->pos += length;
	}
}
40017410:	01812403          	lw	s0,24(sp)
40017414:	01c12083          	lw	ra,28(sp)
40017418:	01412483          	lw	s1,20(sp)
4001741c:	00c12983          	lw	s3,12(sp)
		pkt_cursor_jump(pkt, write);
40017420:	00090593          	mv	a1,s2
}
40017424:	01012903          	lw	s2,16(sp)
40017428:	02010113          	addi	sp,sp,32
		pkt_cursor_jump(pkt, write);
4001742c:	ea1ff06f          	j	400172cc <pkt_cursor_jump>
	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
40017430:	01055483          	lhu	s1,16(a0)
40017434:	00000913          	li	s2,0
40017438:	fb1ff06f          	j	400173e8 <pkt_cursor_update+0x44>
4001743c:	00c50513          	addi	a0,a0,12
40017440:	c04f60ef          	jal	ra,4000d844 <net_buf_simple_max_len>
	    !(net_pkt_is_being_overwritten(pkt) &&
40017444:	fca4f4e3          	bgeu	s1,a0,4001740c <pkt_cursor_update+0x68>
		cursor->pos += length;
40017448:	01042783          	lw	a5,16(s0)
4001744c:	013787b3          	add	a5,a5,s3
40017450:	00f42823          	sw	a5,16(s0)
}
40017454:	01c12083          	lw	ra,28(sp)
40017458:	01812403          	lw	s0,24(sp)
4001745c:	01412483          	lw	s1,20(sp)
40017460:	01012903          	lw	s2,16(sp)
40017464:	00c12983          	lw	s3,12(sp)
40017468:	02010113          	addi	sp,sp,32
4001746c:	00008067          	ret

40017470 <pkt_estimate_headers_length.part.0>:
static size_t pkt_estimate_headers_length(struct net_pkt *pkt,
40017470:	00050793          	mv	a5,a0
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40017474:	00200713          	li	a4,2
		hdr_len += NET_IPV6H_LEN;
40017478:	02800513          	li	a0,40
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
4001747c:	00e78a63          	beq	a5,a4,40017490 <pkt_estimate_headers_length.part.0+0x20>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40017480:	00100713          	li	a4,1
		hdr_len += NET_IPV4H_LEN;
40017484:	01400513          	li	a0,20
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40017488:	00e78463          	beq	a5,a4,40017490 <pkt_estimate_headers_length.part.0+0x20>
	size_t hdr_len = 0;
4001748c:	00000513          	li	a0,0
	if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
40017490:	00600793          	li	a5,6
40017494:	00f59663          	bne	a1,a5,400174a0 <pkt_estimate_headers_length.part.0+0x30>
		hdr_len += NET_TCPH_LEN + NET_TCP_MAX_OPT_SIZE;
40017498:	01c50513          	addi	a0,a0,28
4001749c:	00008067          	ret
	} else if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
400174a0:	01100793          	li	a5,17
400174a4:	00f59663          	bne	a1,a5,400174b0 <pkt_estimate_headers_length.part.0+0x40>
		hdr_len += NET_UDPH_LEN;
400174a8:	00850513          	addi	a0,a0,8
400174ac:	00008067          	ret
	} else if (proto == IPPROTO_ICMP || proto == IPPROTO_ICMPV6) {
400174b0:	00100793          	li	a5,1
400174b4:	00f58663          	beq	a1,a5,400174c0 <pkt_estimate_headers_length.part.0+0x50>
400174b8:	03a00793          	li	a5,58
400174bc:	00f59463          	bne	a1,a5,400174c4 <pkt_estimate_headers_length.part.0+0x54>
		hdr_len += NET_ICMPH_LEN;
400174c0:	00450513          	addi	a0,a0,4
}
400174c4:	00008067          	ret

400174c8 <net_pkt_get_len.isra.0>:
static inline size_t net_pkt_get_len(struct net_pkt *pkt)
400174c8:	00050793          	mv	a5,a0
	size_t bytes = 0;
400174cc:	00000513          	li	a0,0
	while (buf) {
400174d0:	00079463          	bnez	a5,400174d8 <net_pkt_get_len.isra.0+0x10>
}
400174d4:	00008067          	ret
		bytes += buf->len;
400174d8:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
400174dc:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
400174e0:	00e50533          	add	a0,a0,a4
		buf = buf->frags;
400174e4:	fedff06f          	j	400174d0 <net_pkt_get_len.isra.0+0x8>

400174e8 <net_pkt_cursor_operate>:

/* Internal function that does all operation (skip/read/write/memset) */
static int net_pkt_cursor_operate(struct net_pkt *pkt,
				  void *data, size_t length,
				  bool copy, bool write)
{
400174e8:	fe010113          	addi	sp,sp,-32
400174ec:	00912a23          	sw	s1,20(sp)
400174f0:	01212823          	sw	s2,16(sp)
400174f4:	01312623          	sw	s3,12(sp)
400174f8:	01412423          	sw	s4,8(sp)
400174fc:	01512223          	sw	s5,4(sp)
40017500:	00112e23          	sw	ra,28(sp)
40017504:	00812c23          	sw	s0,24(sp)
40017508:	00050493          	mv	s1,a0
4001750c:	00058913          	mv	s2,a1
40017510:	00060993          	mv	s3,a2
40017514:	00068a93          	mv	s5,a3
40017518:	00070a13          	mv	s4,a4
	/* We use such variable to avoid lengthy lines */
	struct net_pkt_cursor *c_op = &pkt->cursor;

	while (c_op->buf && length) {
4001751c:	00c4a783          	lw	a5,12(s1)
40017520:	16078463          	beqz	a5,40017688 <net_pkt_cursor_operate+0x1a0>
40017524:	02099663          	bnez	s3,40017550 <net_pkt_cursor_operate+0x68>
	if (length) {
		NET_DBG("Still some length to go %zu", length);
		return -ENOBUFS;
	}

	return 0;
40017528:	00000513          	li	a0,0
}
4001752c:	01c12083          	lw	ra,28(sp)
40017530:	01812403          	lw	s0,24(sp)
40017534:	01412483          	lw	s1,20(sp)
40017538:	01012903          	lw	s2,16(sp)
4001753c:	00c12983          	lw	s3,12(sp)
40017540:	00812a03          	lw	s4,8(sp)
40017544:	00412a83          	lw	s5,4(sp)
40017548:	02010113          	addi	sp,sp,32
4001754c:	00008067          	ret
	return pkt->overwrite;
40017550:	0374c783          	lbu	a5,55(s1)
		pkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?
40017554:	00000593          	li	a1,0
40017558:	0017f793          	andi	a5,a5,1
4001755c:	00079463          	bnez	a5,40017564 <net_pkt_cursor_operate+0x7c>
40017560:	000a0593          	mv	a1,s4
40017564:	00048513          	mv	a0,s1
40017568:	dd1ff0ef          	jal	ra,40017338 <pkt_cursor_advance>
		if (c_op->buf == NULL) {
4001756c:	00c4a783          	lw	a5,12(s1)
40017570:	12078063          	beqz	a5,40017690 <net_pkt_cursor_operate+0x1a8>
		if (write && !net_pkt_is_being_overwritten(pkt)) {
40017574:	040a0a63          	beqz	s4,400175c8 <net_pkt_cursor_operate+0xe0>
40017578:	0374c703          	lbu	a4,55(s1)
4001757c:	00177713          	andi	a4,a4,1
40017580:	04071463          	bnez	a4,400175c8 <net_pkt_cursor_operate+0xe0>
	return net_buf_simple_max_len(&buf->b);
40017584:	00c78513          	addi	a0,a5,12
40017588:	abcf60ef          	jal	ra,4000d844 <net_buf_simple_max_len>
				(c_op->pos - c_op->buf->data);
4001758c:	00c4a783          	lw	a5,12(s1)
40017590:	0104a703          	lw	a4,16(s1)
40017594:	00c7a783          	lw	a5,12(a5)
40017598:	40f707b3          	sub	a5,a4,a5
			d_len = net_buf_max_len(c_op->buf) -
4001759c:	40f50433          	sub	s0,a0,a5
		if (!d_len) {
400175a0:	0ef50863          	beq	a0,a5,40017690 <net_pkt_cursor_operate+0x1a8>
		if (length < d_len) {
400175a4:	0089f463          	bgeu	s3,s0,400175ac <net_pkt_cursor_operate+0xc4>
400175a8:	00098413          	mv	s0,s3
		if (copy) {
400175ac:	0a0a9663          	bnez	s5,40017658 <net_pkt_cursor_operate+0x170>
		} else if (data) {
400175b0:	06090a63          	beqz	s2,40017624 <net_pkt_cursor_operate+0x13c>
			memset(c_op->pos, *(int *)data, len);
400175b4:	00092583          	lw	a1,0(s2)
400175b8:	0104a503          	lw	a0,16(s1)
400175bc:	00040613          	mv	a2,s0
400175c0:	f5cf50ef          	jal	ra,4000cd1c <memset>
		if (write && !net_pkt_is_being_overwritten(pkt)) {
400175c4:	0a80006f          	j	4001766c <net_pkt_cursor_operate+0x184>
			d_len = c_op->buf->len - (c_op->pos - c_op->buf->data);
400175c8:	0107d703          	lhu	a4,16(a5)
400175cc:	0104a503          	lw	a0,16(s1)
400175d0:	00c7a783          	lw	a5,12(a5)
400175d4:	40f507b3          	sub	a5,a0,a5
400175d8:	40f70433          	sub	s0,a4,a5
		if (!d_len) {
400175dc:	0af70a63          	beq	a4,a5,40017690 <net_pkt_cursor_operate+0x1a8>
		if (length < d_len) {
400175e0:	0089f463          	bgeu	s3,s0,400175e8 <net_pkt_cursor_operate+0x100>
400175e4:	00098413          	mv	s0,s3
		if (copy) {
400175e8:	080a8063          	beqz	s5,40017668 <net_pkt_cursor_operate+0x180>
			memcpy(write ? c_op->pos : data,
400175ec:	00040613          	mv	a2,s0
400175f0:	020a1663          	bnez	s4,4001761c <net_pkt_cursor_operate+0x134>
400175f4:	00050593          	mv	a1,a0
400175f8:	00090513          	mv	a0,s2
400175fc:	efcf50ef          	jal	ra,4000ccf8 <memcpy>
		pkt_cursor_update(pkt, len, write);
40017600:	00000613          	li	a2,0
40017604:	00040593          	mv	a1,s0
40017608:	00048513          	mv	a0,s1
4001760c:	d99ff0ef          	jal	ra,400173a4 <pkt_cursor_update>
		if (copy && data) {
40017610:	06090863          	beqz	s2,40017680 <net_pkt_cursor_operate+0x198>
			data = (uint8_t *) data + len;
40017614:	00890933          	add	s2,s2,s0
40017618:	0680006f          	j	40017680 <net_pkt_cursor_operate+0x198>
			memcpy(write ? c_op->pos : data,
4001761c:	00090593          	mv	a1,s2
40017620:	ed8f50ef          	jal	ra,4000ccf8 <memcpy>
40017624:	0374c783          	lbu	a5,55(s1)
		if (write && !net_pkt_is_being_overwritten(pkt)) {
40017628:	0017f793          	andi	a5,a5,1
4001762c:	00079a63          	bnez	a5,40017640 <net_pkt_cursor_operate+0x158>
	return net_buf_simple_add(&buf->b, len);
40017630:	00c4a503          	lw	a0,12(s1)
40017634:	00040593          	mv	a1,s0
40017638:	00c50513          	addi	a0,a0,12
4001763c:	98cf60ef          	jal	ra,4000d7c8 <net_buf_simple_add>
		pkt_cursor_update(pkt, len, write);
40017640:	00100613          	li	a2,1
40017644:	00040593          	mv	a1,s0
40017648:	00048513          	mv	a0,s1
4001764c:	d59ff0ef          	jal	ra,400173a4 <pkt_cursor_update>
		if (copy && data) {
40017650:	020a8863          	beqz	s5,40017680 <net_pkt_cursor_operate+0x198>
40017654:	fbdff06f          	j	40017610 <net_pkt_cursor_operate+0x128>
			memcpy(write ? c_op->pos : data,
40017658:	00040613          	mv	a2,s0
4001765c:	00090593          	mv	a1,s2
40017660:	00070513          	mv	a0,a4
40017664:	fbdff06f          	j	40017620 <net_pkt_cursor_operate+0x138>
		} else if (data) {
40017668:	f40916e3          	bnez	s2,400175b4 <net_pkt_cursor_operate+0xcc>
		if (write && !net_pkt_is_being_overwritten(pkt)) {
4001766c:	fa0a1ce3          	bnez	s4,40017624 <net_pkt_cursor_operate+0x13c>
		pkt_cursor_update(pkt, len, write);
40017670:	00000613          	li	a2,0
40017674:	00040593          	mv	a1,s0
40017678:	00048513          	mv	a0,s1
4001767c:	d29ff0ef          	jal	ra,400173a4 <pkt_cursor_update>
		length -= len;
40017680:	408989b3          	sub	s3,s3,s0
40017684:	e99ff06f          	j	4001751c <net_pkt_cursor_operate+0x34>
	return 0;
40017688:	00000513          	li	a0,0
	if (length) {
4001768c:	ea0980e3          	beqz	s3,4001752c <net_pkt_cursor_operate+0x44>
		return -ENOBUFS;
40017690:	f9700513          	li	a0,-105
40017694:	e99ff06f          	j	4001752c <net_pkt_cursor_operate+0x44>

40017698 <net_pkt_get_reserve_data>:
{
40017698:	fc010113          	addi	sp,sp,-64
4001769c:	02812c23          	sw	s0,56(sp)
400176a0:	02912a23          	sw	s1,52(sp)
400176a4:	03212823          	sw	s2,48(sp)
400176a8:	03312623          	sw	s3,44(sp)
400176ac:	02112e23          	sw	ra,60(sp)
400176b0:	00050913          	mv	s2,a0
400176b4:	00058993          	mv	s3,a1
400176b8:	00060493          	mv	s1,a2
400176bc:	00068413          	mv	s0,a3
	if (k_is_in_isr()) {
400176c0:	5d0170ef          	jal	ra,4002ec90 <k_is_in_isr>
400176c4:	00050663          	beqz	a0,400176d0 <net_pkt_get_reserve_data+0x38>
		timeout = K_NO_WAIT;
400176c8:	00000493          	li	s1,0
400176cc:	00000413          	li	s0,0
	if (min_len > CONFIG_NET_BUF_DATA_SIZE) {
400176d0:	08000793          	li	a5,128
400176d4:	0737f063          	bgeu	a5,s3,40017734 <net_pkt_get_reserve_data+0x9c>
		NET_ERR("Requested too large fragment. Increase CONFIG_NET_BUF_DATA_SIZE.");
400176d8:	40044537          	lui	a0,0x40044
400176dc:	78c52783          	lw	a5,1932(a0) # 4004478c <log_dynamic_net_pkt>
400176e0:	0077f793          	andi	a5,a5,7
400176e4:	02078863          	beqz	a5,40017714 <net_pkt_get_reserve_data+0x7c>
400176e8:	400357b7          	lui	a5,0x40035
400176ec:	e0478793          	addi	a5,a5,-508 # 40034e04 <in6addr_any+0x158>
400176f0:	00f12e23          	sw	a5,28(sp)
400176f4:	00200793          	li	a5,2
400176f8:	00f12c23          	sw	a5,24(sp)
400176fc:	000015b7          	lui	a1,0x1
40017700:	00000693          	li	a3,0
40017704:	01810613          	addi	a2,sp,24
40017708:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4001770c:	78c50513          	addi	a0,a0,1932
40017710:	885ed0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
}
40017714:	03c12083          	lw	ra,60(sp)
40017718:	03812403          	lw	s0,56(sp)
4001771c:	03412483          	lw	s1,52(sp)
40017720:	03012903          	lw	s2,48(sp)
40017724:	02c12983          	lw	s3,44(sp)
40017728:	00000513          	li	a0,0
4001772c:	04010113          	addi	sp,sp,64
40017730:	00008067          	ret
	return net_buf_alloc_fixed(pool, timeout);
40017734:	00040613          	mv	a2,s0
40017738:	03812403          	lw	s0,56(sp)
4001773c:	03c12083          	lw	ra,60(sp)
40017740:	02c12983          	lw	s3,44(sp)
40017744:	00048593          	mv	a1,s1
40017748:	00090513          	mv	a0,s2
4001774c:	03412483          	lw	s1,52(sp)
40017750:	03012903          	lw	s2,48(sp)
40017754:	04010113          	addi	sp,sp,64
40017758:	e4df506f          	j	4000d5a4 <net_buf_alloc_fixed>

4001775c <net_pkt_get_reserve_rx_data>:
{
4001775c:	00060693          	mv	a3,a2
40017760:	00058613          	mv	a2,a1
	return net_pkt_get_reserve_data(&rx_bufs, min_len, timeout);
40017764:	00050593          	mv	a1,a0
40017768:	40045537          	lui	a0,0x40045
4001776c:	98050513          	addi	a0,a0,-1664 # 40044980 <rx_bufs>
40017770:	f29ff06f          	j	40017698 <net_pkt_get_reserve_data>

40017774 <net_pkt_get_reserve_tx_data>:
{
40017774:	00060693          	mv	a3,a2
40017778:	00058613          	mv	a2,a1
	return net_pkt_get_reserve_data(&tx_bufs, min_len, timeout);
4001777c:	00050593          	mv	a1,a0
40017780:	40045537          	lui	a0,0x40045
40017784:	9ac50513          	addi	a0,a0,-1620 # 400449ac <tx_bufs>
40017788:	f11ff06f          	j	40017698 <net_pkt_get_reserve_data>

4001778c <net_pkt_get_frag>:
{
4001778c:	00050793          	mv	a5,a0
	if (pkt->slab == &rx_pkts) {
40017790:	0047a703          	lw	a4,4(a5)
40017794:	400447b7          	lui	a5,0x40044
40017798:	7b878793          	addi	a5,a5,1976 # 400447b8 <rx_pkts>
{
4001779c:	00058513          	mv	a0,a1
400177a0:	00060593          	mv	a1,a2
400177a4:	00068613          	mv	a2,a3
	if (pkt->slab == &rx_pkts) {
400177a8:	00f71463          	bne	a4,a5,400177b0 <net_pkt_get_frag+0x24>
		return net_pkt_get_reserve_rx_data(min_len, timeout);
400177ac:	fb1ff06f          	j	4001775c <net_pkt_get_reserve_rx_data>
	return net_pkt_get_reserve_tx_data(min_len, timeout);
400177b0:	fc5ff06f          	j	40017774 <net_pkt_get_reserve_tx_data>

400177b4 <net_pkt_ref>:
{
400177b4:	ff010113          	addi	sp,sp,-16
400177b8:	00112623          	sw	ra,12(sp)
400177bc:	00812423          	sw	s0,8(sp)
400177c0:	00912223          	sw	s1,4(sp)
		ref = pkt ? atomic_get(&pkt->atomic_ref) : 0;
400177c4:	04050263          	beqz	a0,40017808 <net_pkt_ref+0x54>
400177c8:	00050413          	mv	s0,a0
400177cc:	02050493          	addi	s1,a0,32
400177d0:	00048513          	mv	a0,s1
400177d4:	2b41a0ef          	jal	ra,40031a88 <atomic_get>
400177d8:	00050593          	mv	a1,a0
		if (!ref) {
400177dc:	02050663          	beqz	a0,40017808 <net_pkt_ref+0x54>
	return z_impl_atomic_cas(target, old_value, new_value);
400177e0:	00150613          	addi	a2,a0,1
400177e4:	00048513          	mv	a0,s1
400177e8:	2381a0ef          	jal	ra,40031a20 <z_impl_atomic_cas>
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref + 1));
400177ec:	fe0502e3          	beqz	a0,400177d0 <net_pkt_ref+0x1c>
}
400177f0:	00c12083          	lw	ra,12(sp)
400177f4:	00040513          	mv	a0,s0
400177f8:	00812403          	lw	s0,8(sp)
400177fc:	00412483          	lw	s1,4(sp)
40017800:	01010113          	addi	sp,sp,16
40017804:	00008067          	ret
			return NULL;
40017808:	00000413          	li	s0,0
4001780c:	fe5ff06f          	j	400177f0 <net_pkt_ref+0x3c>

40017810 <net_pkt_frag_unref>:
	if (!frag) {
40017810:	00050463          	beqz	a0,40017818 <net_pkt_frag_unref+0x8>
	net_buf_unref(frag);
40017814:	da9f506f          	j	4000d5bc <net_buf_unref>
}
40017818:	00008067          	ret

4001781c <net_pkt_unref>:
{
4001781c:	fe010113          	addi	sp,sp,-32
40017820:	00112e23          	sw	ra,28(sp)
40017824:	00812c23          	sw	s0,24(sp)
40017828:	00a12623          	sw	a0,12(sp)
	if (!pkt) {
4001782c:	04050c63          	beqz	a0,40017884 <net_pkt_unref+0x68>
		ref = atomic_get(&pkt->atomic_ref);
40017830:	00c12503          	lw	a0,12(sp)
40017834:	02050513          	addi	a0,a0,32
40017838:	2501a0ef          	jal	ra,40031a88 <atomic_get>
4001783c:	00050413          	mv	s0,a0
		if (!ref) {
40017840:	04050263          	beqz	a0,40017884 <net_pkt_unref+0x68>
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref - 1));
40017844:	00c12503          	lw	a0,12(sp)
40017848:	02050513          	addi	a0,a0,32
4001784c:	fff40613          	addi	a2,s0,-1
40017850:	00040593          	mv	a1,s0
40017854:	1cc1a0ef          	jal	ra,40031a20 <z_impl_atomic_cas>
40017858:	fc050ce3          	beqz	a0,40017830 <net_pkt_unref+0x14>
	if (ref > 1) {
4001785c:	00100793          	li	a5,1
40017860:	0287c263          	blt	a5,s0,40017884 <net_pkt_unref+0x68>
	if (pkt->frags) {
40017864:	00c12783          	lw	a5,12(sp)
40017868:	0087a503          	lw	a0,8(a5)
4001786c:	00050463          	beqz	a0,40017874 <net_pkt_unref+0x58>
		net_pkt_frag_unref(pkt->frags);
40017870:	fa1ff0ef          	jal	ra,40017810 <net_pkt_frag_unref>
	k_mem_slab_free(pkt->slab, (void **)&pkt);
40017874:	00c12783          	lw	a5,12(sp)
40017878:	00c10593          	addi	a1,sp,12
4001787c:	0047a503          	lw	a0,4(a5)
40017880:	308170ef          	jal	ra,4002eb88 <k_mem_slab_free>
}
40017884:	01c12083          	lw	ra,28(sp)
40017888:	01812403          	lw	s0,24(sp)
4001788c:	02010113          	addi	sp,sp,32
40017890:	00008067          	ret

40017894 <net_pkt_frag_insert>:
{
40017894:	ff010113          	addi	sp,sp,-16
40017898:	00812423          	sw	s0,8(sp)
4001789c:	00050413          	mv	s0,a0
	net_buf_frag_last(frag)->frags = pkt->frags;
400178a0:	00058513          	mv	a0,a1
{
400178a4:	00912223          	sw	s1,4(sp)
400178a8:	00112623          	sw	ra,12(sp)
400178ac:	00058493          	mv	s1,a1
	net_buf_frag_last(frag)->frags = pkt->frags;
400178b0:	dddf50ef          	jal	ra,4000d68c <net_buf_frag_last>
400178b4:	00842783          	lw	a5,8(s0)
400178b8:	00f52223          	sw	a5,4(a0)
	pkt->frags = frag;
400178bc:	00942423          	sw	s1,8(s0)
}
400178c0:	00c12083          	lw	ra,12(sp)
400178c4:	00812403          	lw	s0,8(sp)
400178c8:	00412483          	lw	s1,4(sp)
400178cc:	01010113          	addi	sp,sp,16
400178d0:	00008067          	ret

400178d4 <net_pkt_get_info>:
	if (rx) {
400178d4:	00050863          	beqz	a0,400178e4 <net_pkt_get_info+0x10>
		*rx = &rx_pkts;
400178d8:	400447b7          	lui	a5,0x40044
400178dc:	7b878793          	addi	a5,a5,1976 # 400447b8 <rx_pkts>
400178e0:	00f52023          	sw	a5,0(a0)
	if (tx) {
400178e4:	00058863          	beqz	a1,400178f4 <net_pkt_get_info+0x20>
		*tx = &tx_pkts;
400178e8:	400447b7          	lui	a5,0x40044
400178ec:	7f078793          	addi	a5,a5,2032 # 400447f0 <tx_pkts>
400178f0:	00f5a023          	sw	a5,0(a1)
	if (rx_data) {
400178f4:	00060863          	beqz	a2,40017904 <net_pkt_get_info+0x30>
		*rx_data = &rx_bufs;
400178f8:	400457b7          	lui	a5,0x40045
400178fc:	98078793          	addi	a5,a5,-1664 # 40044980 <rx_bufs>
40017900:	00f62023          	sw	a5,0(a2)
	if (tx_data) {
40017904:	00068863          	beqz	a3,40017914 <net_pkt_get_info+0x40>
		*tx_data = &tx_bufs;
40017908:	400457b7          	lui	a5,0x40045
4001790c:	9ac78793          	addi	a5,a5,-1620 # 400449ac <tx_bufs>
40017910:	00f6a023          	sw	a5,0(a3)
}
40017914:	00008067          	ret

40017918 <net_pkt_available_buffer>:
	if (!pkt) {
40017918:	06050063          	beqz	a0,40017978 <net_pkt_available_buffer+0x60>
{
4001791c:	ff010113          	addi	sp,sp,-16
40017920:	00812423          	sw	s0,8(sp)
40017924:	00912223          	sw	s1,4(sp)
40017928:	00112623          	sw	ra,12(sp)
4001792c:	01212023          	sw	s2,0(sp)
40017930:	00852903          	lw	s2,8(a0)
40017934:	00050493          	mv	s1,a0
	size_t size = 0;
40017938:	00000413          	li	s0,0
	while (buf) {
4001793c:	02091463          	bnez	s2,40017964 <net_pkt_available_buffer+0x4c>
	return pkt_get_max_len(pkt) - net_pkt_get_len(pkt);
40017940:	0084a503          	lw	a0,8(s1)
40017944:	b85ff0ef          	jal	ra,400174c8 <net_pkt_get_len.isra.0>
}
40017948:	00c12083          	lw	ra,12(sp)
	return pkt_get_max_len(pkt) - net_pkt_get_len(pkt);
4001794c:	40a40533          	sub	a0,s0,a0
}
40017950:	00812403          	lw	s0,8(sp)
40017954:	00412483          	lw	s1,4(sp)
40017958:	00012903          	lw	s2,0(sp)
4001795c:	01010113          	addi	sp,sp,16
40017960:	00008067          	ret
	return net_buf_simple_max_len(&buf->b);
40017964:	00c90513          	addi	a0,s2,12
40017968:	eddf50ef          	jal	ra,4000d844 <net_buf_simple_max_len>
		size += net_buf_max_len(buf);
4001796c:	00a40433          	add	s0,s0,a0
		buf = buf->frags;
40017970:	00492903          	lw	s2,4(s2)
40017974:	fc9ff06f          	j	4001793c <net_pkt_available_buffer+0x24>
		return 0;
40017978:	00000513          	li	a0,0
}
4001797c:	00008067          	ret

40017980 <net_pkt_available_payload_buffer>:
	if (!pkt) {
40017980:	06050e63          	beqz	a0,400179fc <net_pkt_available_payload_buffer+0x7c>
{
40017984:	ff010113          	addi	sp,sp,-16
40017988:	00812423          	sw	s0,8(sp)
4001798c:	00112623          	sw	ra,12(sp)
40017990:	00912223          	sw	s1,4(sp)
40017994:	01212023          	sw	s2,0(sp)
40017998:	00050413          	mv	s0,a0
	return pkt->family;
4001799c:	03452503          	lw	a0,52(a0)
400179a0:	00842903          	lw	s2,8(s0)
	hdr_len = pkt_estimate_headers_length(pkt, net_pkt_family(pkt), proto);
400179a4:	01d55513          	srli	a0,a0,0x1d
	if (family == AF_UNSPEC) {
400179a8:	02051a63          	bnez	a0,400179dc <net_pkt_available_payload_buffer+0x5c>
	len = net_pkt_get_len(pkt);
400179ac:	00090513          	mv	a0,s2
400179b0:	b19ff0ef          	jal	ra,400174c8 <net_pkt_get_len.isra.0>
	hdr_len = hdr_len <= len ? 0 : hdr_len - len;
400179b4:	00000913          	li	s2,0
	len = net_pkt_available_buffer(pkt) - hdr_len;
400179b8:	00040513          	mv	a0,s0
400179bc:	f5dff0ef          	jal	ra,40017918 <net_pkt_available_buffer>
}
400179c0:	00c12083          	lw	ra,12(sp)
400179c4:	00812403          	lw	s0,8(sp)
400179c8:	00412483          	lw	s1,4(sp)
	len = net_pkt_available_buffer(pkt) - hdr_len;
400179cc:	41250533          	sub	a0,a0,s2
}
400179d0:	00012903          	lw	s2,0(sp)
400179d4:	01010113          	addi	sp,sp,16
400179d8:	00008067          	ret
400179dc:	a95ff0ef          	jal	ra,40017470 <pkt_estimate_headers_length.part.0>
400179e0:	00050493          	mv	s1,a0
	len = net_pkt_get_len(pkt);
400179e4:	00090513          	mv	a0,s2
400179e8:	ae1ff0ef          	jal	ra,400174c8 <net_pkt_get_len.isra.0>
	hdr_len = hdr_len <= len ? 0 : hdr_len - len;
400179ec:	00000913          	li	s2,0
400179f0:	fc9574e3          	bgeu	a0,s1,400179b8 <net_pkt_available_payload_buffer+0x38>
400179f4:	40a48933          	sub	s2,s1,a0
400179f8:	fc1ff06f          	j	400179b8 <net_pkt_available_payload_buffer+0x38>
		return 0;
400179fc:	00000513          	li	a0,0
}
40017a00:	00008067          	ret

40017a04 <net_pkt_trim_buffer>:
{
40017a04:	ff010113          	addi	sp,sp,-16
40017a08:	00812423          	sw	s0,8(sp)
40017a0c:	00912223          	sw	s1,4(sp)
40017a10:	00112623          	sw	ra,12(sp)
40017a14:	01212023          	sw	s2,0(sp)
40017a18:	00050413          	mv	s0,a0
	buf = pkt->buffer;
40017a1c:	00852503          	lw	a0,8(a0)
	prev = buf;
40017a20:	00050493          	mv	s1,a0
	while (buf) {
40017a24:	00051e63          	bnez	a0,40017a40 <net_pkt_trim_buffer+0x3c>
}
40017a28:	00c12083          	lw	ra,12(sp)
40017a2c:	00812403          	lw	s0,8(sp)
40017a30:	00412483          	lw	s1,4(sp)
40017a34:	00012903          	lw	s2,0(sp)
40017a38:	01010113          	addi	sp,sp,16
40017a3c:	00008067          	ret
		if (!buf->len) {
40017a40:	01055783          	lhu	a5,16(a0)
		struct net_buf *next = buf->frags;
40017a44:	00452903          	lw	s2,4(a0)
		if (!buf->len) {
40017a48:	00079e63          	bnez	a5,40017a64 <net_pkt_trim_buffer+0x60>
			if (buf == pkt->buffer) {
40017a4c:	00842783          	lw	a5,8(s0)
40017a50:	02a79063          	bne	a5,a0,40017a70 <net_pkt_trim_buffer+0x6c>
				pkt->buffer = next;
40017a54:	01242423          	sw	s2,8(s0)
			buf->frags = NULL;
40017a58:	00052223          	sw	zero,4(a0)
			net_buf_unref(buf);
40017a5c:	b61f50ef          	jal	ra,4000d5bc <net_buf_unref>
40017a60:	00048513          	mv	a0,s1
40017a64:	00050493          	mv	s1,a0
40017a68:	00090513          	mv	a0,s2
40017a6c:	fb9ff06f          	j	40017a24 <net_pkt_trim_buffer+0x20>
			} else if (buf == prev->frags) {
40017a70:	0044a783          	lw	a5,4(s1)
40017a74:	fea792e3          	bne	a5,a0,40017a58 <net_pkt_trim_buffer+0x54>
				prev->frags = next;
40017a78:	0124a223          	sw	s2,4(s1)
40017a7c:	fddff06f          	j	40017a58 <net_pkt_trim_buffer+0x54>

40017a80 <net_pkt_remove_tail>:
{
40017a80:	ff010113          	addi	sp,sp,-16
40017a84:	00912223          	sw	s1,4(sp)
40017a88:	00112623          	sw	ra,12(sp)
40017a8c:	00812423          	sw	s0,8(sp)
	struct net_buf *buf = pkt->buffer;
40017a90:	00852403          	lw	s0,8(a0)
{
40017a94:	00058493          	mv	s1,a1
	size_t remaining_len = net_pkt_get_len(pkt);
40017a98:	00040513          	mv	a0,s0
40017a9c:	a2dff0ef          	jal	ra,400174c8 <net_pkt_get_len.isra.0>
	remaining_len -= length;
40017aa0:	409505b3          	sub	a1,a0,s1
	if (remaining_len < length) {
40017aa4:	00957a63          	bgeu	a0,s1,40017ab8 <net_pkt_remove_tail+0x38>
		return -EINVAL;
40017aa8:	fea00513          	li	a0,-22
40017aac:	0300006f          	j	40017adc <net_pkt_remove_tail+0x5c>
		remaining_len -= buf->len;
40017ab0:	40f585b3          	sub	a1,a1,a5
			if (buf->frags) {
40017ab4:	00050413          	mv	s0,a0
	while (buf) {
40017ab8:	02040063          	beqz	s0,40017ad8 <net_pkt_remove_tail+0x58>
		if (buf->len >= remaining_len) {
40017abc:	01045783          	lhu	a5,16(s0)
			if (buf->frags) {
40017ac0:	00442503          	lw	a0,4(s0)
		if (buf->len >= remaining_len) {
40017ac4:	feb7e6e3          	bltu	a5,a1,40017ab0 <net_pkt_remove_tail+0x30>
			buf->len = remaining_len;
40017ac8:	00b41823          	sh	a1,16(s0)
			if (buf->frags) {
40017acc:	00050663          	beqz	a0,40017ad8 <net_pkt_remove_tail+0x58>
				net_pkt_frag_unref(buf->frags);
40017ad0:	d41ff0ef          	jal	ra,40017810 <net_pkt_frag_unref>
				buf->frags = NULL;
40017ad4:	00042223          	sw	zero,4(s0)
	return 0;
40017ad8:	00000513          	li	a0,0
}
40017adc:	00c12083          	lw	ra,12(sp)
40017ae0:	00812403          	lw	s0,8(sp)
40017ae4:	00412483          	lw	s1,4(sp)
40017ae8:	01010113          	addi	sp,sp,16
40017aec:	00008067          	ret

40017af0 <net_pkt_cursor_init>:
	pkt->cursor.buf = pkt->buffer;
40017af0:	00852783          	lw	a5,8(a0)
40017af4:	00f52623          	sw	a5,12(a0)
	if (pkt->cursor.buf) {
40017af8:	00078463          	beqz	a5,40017b00 <net_pkt_cursor_init+0x10>
		pkt->cursor.pos = pkt->cursor.buf->data;
40017afc:	00c7a783          	lw	a5,12(a5)
40017b00:	00f52823          	sw	a5,16(a0)
}
40017b04:	00008067          	ret

40017b08 <pkt_alloc>:
{
40017b08:	fd010113          	addi	sp,sp,-48
40017b0c:	02912223          	sw	s1,36(sp)
40017b10:	00c12423          	sw	a2,8(sp)
40017b14:	02112623          	sw	ra,44(sp)
40017b18:	02812423          	sw	s0,40(sp)
40017b1c:	00050493          	mv	s1,a0
40017b20:	00b12623          	sw	a1,12(sp)
	if (k_is_in_isr()) {
40017b24:	16c170ef          	jal	ra,4002ec90 <k_is_in_isr>
40017b28:	00812683          	lw	a3,8(sp)
40017b2c:	00c12603          	lw	a2,12(sp)
40017b30:	00050663          	beqz	a0,40017b3c <pkt_alloc+0x34>
		timeout = K_NO_WAIT;
40017b34:	00000613          	li	a2,0
40017b38:	00000693          	li	a3,0
	ret = k_mem_slab_alloc(slab, (void **)&pkt, timeout);
40017b3c:	01c10593          	addi	a1,sp,28
40017b40:	00048513          	mv	a0,s1
40017b44:	7b5160ef          	jal	ra,4002eaf8 <k_mem_slab_alloc>
		return NULL;
40017b48:	00000413          	li	s0,0
	if (ret) {
40017b4c:	04051263          	bnez	a0,40017b90 <pkt_alloc+0x88>
	memset(pkt, 0, sizeof(struct net_pkt));
40017b50:	01c12503          	lw	a0,28(sp)
40017b54:	04400613          	li	a2,68
40017b58:	00000593          	li	a1,0
40017b5c:	9c0f50ef          	jal	ra,4000cd1c <memset>
	pkt->atomic_ref = ATOMIC_INIT(1);
40017b60:	01c12403          	lw	s0,28(sp)
	pkt->ipv6_next_hdr = next_hdr;
40017b64:	fff00793          	li	a5,-1
40017b68:	00100713          	li	a4,1
40017b6c:	02f40fa3          	sb	a5,63(s0)
	if (&tx_pkts == slab) {
40017b70:	400447b7          	lui	a5,0x40044
	pkt->atomic_ref = ATOMIC_INIT(1);
40017b74:	02e42023          	sw	a4,32(s0)
	pkt->slab = slab;
40017b78:	00942223          	sw	s1,4(s0)
	if (&tx_pkts == slab) {
40017b7c:	7f078793          	addi	a5,a5,2032 # 400447f0 <tx_pkts>
40017b80:	02f49463          	bne	s1,a5,40017ba8 <pkt_alloc+0xa0>
	pkt->priority = priority;
40017b84:	04e400a3          	sb	a4,65(s0)
	net_pkt_cursor_init(pkt);
40017b88:	00040513          	mv	a0,s0
40017b8c:	f65ff0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
}
40017b90:	02c12083          	lw	ra,44(sp)
40017b94:	00040513          	mv	a0,s0
40017b98:	02812403          	lw	s0,40(sp)
40017b9c:	02412483          	lw	s1,36(sp)
40017ba0:	03010113          	addi	sp,sp,48
40017ba4:	00008067          	ret
	} else if (&rx_pkts == slab) {
40017ba8:	400447b7          	lui	a5,0x40044
40017bac:	7b878793          	addi	a5,a5,1976 # 400447b8 <rx_pkts>
40017bb0:	fcf49ce3          	bne	s1,a5,40017b88 <pkt_alloc+0x80>
40017bb4:	040400a3          	sb	zero,65(s0)
}
40017bb8:	fd1ff06f          	j	40017b88 <pkt_alloc+0x80>

40017bbc <net_pkt_alloc>:
	return pkt_alloc(&tx_pkts, timeout);
40017bbc:	00058613          	mv	a2,a1
40017bc0:	00050593          	mv	a1,a0
40017bc4:	40044537          	lui	a0,0x40044
40017bc8:	7f050513          	addi	a0,a0,2032 # 400447f0 <tx_pkts>
40017bcc:	f3dff06f          	j	40017b08 <pkt_alloc>

40017bd0 <net_pkt_rx_alloc>:
	return pkt_alloc(&rx_pkts, timeout);
40017bd0:	00058613          	mv	a2,a1
40017bd4:	00050593          	mv	a1,a0
40017bd8:	40044537          	lui	a0,0x40044
40017bdc:	7b850513          	addi	a0,a0,1976 # 400447b8 <rx_pkts>
40017be0:	f29ff06f          	j	40017b08 <pkt_alloc>

40017be4 <pkt_alloc_on_iface>:
{
40017be4:	ff010113          	addi	sp,sp,-16
40017be8:	00812423          	sw	s0,8(sp)
40017bec:	00058413          	mv	s0,a1
	pkt = pkt_alloc(slab, timeout);
40017bf0:	00060593          	mv	a1,a2
40017bf4:	00068613          	mv	a2,a3
{
40017bf8:	00112623          	sw	ra,12(sp)
	pkt = pkt_alloc(slab, timeout);
40017bfc:	f0dff0ef          	jal	ra,40017b08 <pkt_alloc>
	if (pkt) {
40017c00:	02050263          	beqz	a0,40017c24 <pkt_alloc_on_iface+0x40>
	pkt->iface = iface;
40017c04:	00852c23          	sw	s0,24(a0)
	if (iface) {
40017c08:	00040e63          	beqz	s0,40017c24 <pkt_alloc_on_iface+0x40>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
40017c0c:	00042783          	lw	a5,0(s0)
40017c10:	0157c783          	lbu	a5,21(a5)
40017c14:	02f504a3          	sb	a5,41(a0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
40017c18:	00042783          	lw	a5,0(s0)
40017c1c:	0157c783          	lbu	a5,21(a5)
40017c20:	02f508a3          	sb	a5,49(a0)
}
40017c24:	00c12083          	lw	ra,12(sp)
40017c28:	00812403          	lw	s0,8(sp)
40017c2c:	01010113          	addi	sp,sp,16
40017c30:	00008067          	ret

40017c34 <net_pkt_append_buffer>:
	if (!pkt->buffer) {
40017c34:	00852703          	lw	a4,8(a0)
40017c38:	00071663          	bnez	a4,40017c44 <net_pkt_append_buffer+0x10>
		pkt->buffer = buffer;
40017c3c:	00b52423          	sw	a1,8(a0)
		net_pkt_cursor_init(pkt);
40017c40:	eb1ff06f          	j	40017af0 <net_pkt_cursor_init>
{
40017c44:	fe010113          	addi	sp,sp,-32
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
40017c48:	00070513          	mv	a0,a4
{
40017c4c:	00112e23          	sw	ra,28(sp)
40017c50:	00b12623          	sw	a1,12(sp)
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
40017c54:	a39f50ef          	jal	ra,4000d68c <net_buf_frag_last>
40017c58:	00c12583          	lw	a1,12(sp)
}
40017c5c:	01c12083          	lw	ra,28(sp)
40017c60:	02010113          	addi	sp,sp,32
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
40017c64:	a3df506f          	j	4000d6a0 <net_buf_frag_insert>

40017c68 <net_pkt_alloc_buffer>:
{
40017c68:	fb010113          	addi	sp,sp,-80
40017c6c:	04812423          	sw	s0,72(sp)
40017c70:	04912223          	sw	s1,68(sp)
40017c74:	05212023          	sw	s2,64(sp)
40017c78:	03312e23          	sw	s3,60(sp)
40017c7c:	03512a23          	sw	s5,52(sp)
40017c80:	03612823          	sw	s6,48(sp)
40017c84:	03712623          	sw	s7,44(sp)
40017c88:	03912223          	sw	s9,36(sp)
40017c8c:	04112623          	sw	ra,76(sp)
40017c90:	03412c23          	sw	s4,56(sp)
40017c94:	03812423          	sw	s8,40(sp)
40017c98:	03a12023          	sw	s10,32(sp)
40017c9c:	01b12e23          	sw	s11,28(sp)
40017ca0:	05010413          	addi	s0,sp,80
40017ca4:	00058993          	mv	s3,a1
40017ca8:	00050a93          	mv	s5,a0
40017cac:	00070593          	mv	a1,a4
40017cb0:	00068513          	mv	a0,a3
40017cb4:	00060c93          	mv	s9,a2
40017cb8:	00068493          	mv	s1,a3
40017cbc:	00070913          	mv	s2,a4
	uint64_t end = sys_clock_timeout_end_calc(timeout);
40017cc0:	201190ef          	jal	ra,400316c0 <sys_clock_timeout_end_calc>
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
40017cc4:	0199e7b3          	or	a5,s3,s9
	uint64_t end = sys_clock_timeout_end_calc(timeout);
40017cc8:	00050b13          	mv	s6,a0
40017ccc:	00058b93          	mv	s7,a1
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
40017cd0:	00079863          	bnez	a5,40017ce0 <net_pkt_alloc_buffer+0x78>
	return pkt->family;
40017cd4:	034aa783          	lw	a5,52(s5)
40017cd8:	01d7d793          	srli	a5,a5,0x1d
40017cdc:	22078863          	beqz	a5,40017f0c <net_pkt_alloc_buffer+0x2a4>
	if (k_is_in_isr()) {
40017ce0:	7b1160ef          	jal	ra,4002ec90 <k_is_in_isr>
40017ce4:	00050663          	beqz	a0,40017cf0 <net_pkt_alloc_buffer+0x88>
		timeout = K_NO_WAIT;
40017ce8:	00000493          	li	s1,0
40017cec:	00000913          	li	s2,0
	alloc_len = net_pkt_available_buffer(pkt);
40017cf0:	000a8513          	mv	a0,s5
40017cf4:	c25ff0ef          	jal	ra,40017918 <net_pkt_available_buffer>
40017cf8:	00050c13          	mv	s8,a0
	if (!alloc_len) {
40017cfc:	034aaa03          	lw	s4,52(s5)
	size_t hdr_len = 0;
40017d00:	00000793          	li	a5,0
	if (!alloc_len) {
40017d04:	00051c63          	bnez	a0,40017d1c <net_pkt_alloc_buffer+0xb4>
		hdr_len = pkt_estimate_headers_length(pkt,
40017d08:	01da5513          	srli	a0,s4,0x1d
	if (family == AF_UNSPEC) {
40017d0c:	00050863          	beqz	a0,40017d1c <net_pkt_alloc_buffer+0xb4>
40017d10:	000c8593          	mv	a1,s9
40017d14:	f5cff0ef          	jal	ra,40017470 <pkt_estimate_headers_length.part.0>
40017d18:	00050793          	mv	a5,a0
	return pkt->iface;
40017d1c:	018aa683          	lw	a3,24(s5)
	alloc_len = pkt_buffer_length(pkt, size + hdr_len, proto, alloc_len);
40017d20:	00f98733          	add	a4,s3,a5
	sa_family_t family = net_pkt_family(pkt);
40017d24:	01da5793          	srli	a5,s4,0x1d
	if (net_pkt_iface(pkt)) {
40017d28:	10069663          	bnez	a3,40017e34 <net_pkt_alloc_buffer+0x1cc>
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40017d2c:	00200693          	li	a3,2
40017d30:	12d78863          	beq	a5,a3,40017e60 <net_pkt_alloc_buffer+0x1f8>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40017d34:	00100693          	li	a3,1
40017d38:	14d78063          	beq	a5,a3,40017e78 <net_pkt_alloc_buffer+0x210>
			max_len = size;
40017d3c:	00070793          	mv	a5,a4
	max_len -= existing;
40017d40:	41878a33          	sub	s4,a5,s8
	return MIN(size, max_len);
40017d44:	01477463          	bgeu	a4,s4,40017d4c <net_pkt_alloc_buffer+0xe4>
40017d48:	00070a13          	mv	s4,a4
		pool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;
40017d4c:	004aa703          	lw	a4,4(s5)
40017d50:	400447b7          	lui	a5,0x40044
40017d54:	7f078793          	addi	a5,a5,2032 # 400447f0 <tx_pkts>
40017d58:	14f71263          	bne	a4,a5,40017e9c <net_pkt_alloc_buffer+0x234>
40017d5c:	40045c37          	lui	s8,0x40045
40017d60:	9acc0c13          	addi	s8,s8,-1620 # 400449ac <tx_bufs>
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
40017d64:	0124e7b3          	or	a5,s1,s2
40017d68:	02078863          	beqz	a5,40017d98 <net_pkt_alloc_buffer+0x130>
40017d6c:	fff00793          	li	a5,-1
40017d70:	00f49463          	bne	s1,a5,40017d78 <net_pkt_alloc_buffer+0x110>
40017d74:	02990263          	beq	s2,s1,40017d98 <net_pkt_alloc_buffer+0x130>
		int64_t remaining = end - sys_clock_tick_get();
40017d78:	081190ef          	jal	ra,400315f8 <sys_clock_tick_get>
40017d7c:	40ab04b3          	sub	s1,s6,a0
40017d80:	009b3b33          	sltu	s6,s6,s1
40017d84:	40bb8bb3          	sub	s7,s7,a1
40017d88:	416b8933          	sub	s2,s7,s6
		if (remaining <= 0) {
40017d8c:	00095663          	bgez	s2,40017d98 <net_pkt_alloc_buffer+0x130>
40017d90:	00000493          	li	s1,0
40017d94:	00000913          	li	s2,0
	uint64_t end = sys_clock_timeout_end_calc(timeout);
40017d98:	00048513          	mv	a0,s1
40017d9c:	00090593          	mv	a1,s2
40017da0:	121190ef          	jal	ra,400316c0 <sys_clock_timeout_end_calc>
40017da4:	00050b93          	mv	s7,a0
40017da8:	00058c93          	mv	s9,a1
40017dac:	000a0d93          	mv	s11,s4
	struct net_buf *current = NULL;
40017db0:	00000993          	li	s3,0
	struct net_buf *first = NULL;
40017db4:	00000b13          	li	s6,0
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
40017db8:	fff00d13          	li	s10,-1
		new = net_buf_alloc_fixed(pool, timeout);
40017dbc:	00048593          	mv	a1,s1
40017dc0:	00090613          	mv	a2,s2
40017dc4:	000c0513          	mv	a0,s8
40017dc8:	fb342e23          	sw	s3,-68(s0)
40017dcc:	fd8f50ef          	jal	ra,4000d5a4 <net_buf_alloc_fixed>
		if (!new) {
40017dd0:	fbc42783          	lw	a5,-68(s0)
		new = net_buf_alloc_fixed(pool, timeout);
40017dd4:	00050993          	mv	s3,a0
		if (!new) {
40017dd8:	0c051863          	bnez	a0,40017ea8 <net_pkt_alloc_buffer+0x240>
	if (first) {
40017ddc:	140b1063          	bnez	s6,40017f1c <net_pkt_alloc_buffer+0x2b4>
		NET_ERR("Data buffer (%zd) allocation failed.", alloc_len);
40017de0:	40044537          	lui	a0,0x40044
40017de4:	78c52783          	lw	a5,1932(a0) # 4004478c <log_dynamic_net_pkt>
40017de8:	0077f793          	andi	a5,a5,7
40017dec:	12079e63          	bnez	a5,40017f28 <net_pkt_alloc_buffer+0x2c0>
		return -ENOMEM;
40017df0:	ff400513          	li	a0,-12
}
40017df4:	fb040113          	addi	sp,s0,-80
40017df8:	04c12083          	lw	ra,76(sp)
40017dfc:	04812403          	lw	s0,72(sp)
40017e00:	04412483          	lw	s1,68(sp)
40017e04:	04012903          	lw	s2,64(sp)
40017e08:	03c12983          	lw	s3,60(sp)
40017e0c:	03812a03          	lw	s4,56(sp)
40017e10:	03412a83          	lw	s5,52(sp)
40017e14:	03012b03          	lw	s6,48(sp)
40017e18:	02c12b83          	lw	s7,44(sp)
40017e1c:	02812c03          	lw	s8,40(sp)
40017e20:	02412c83          	lw	s9,36(sp)
40017e24:	02012d03          	lw	s10,32(sp)
40017e28:	01c12d83          	lw	s11,28(sp)
40017e2c:	05010113          	addi	sp,sp,80
40017e30:	00008067          	ret
	return iface->if_dev->mtu;
40017e34:	0006a603          	lw	a2,0(a3)
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40017e38:	00200593          	li	a1,2
		max_len = net_if_get_mtu(net_pkt_iface(pkt));
40017e3c:	01865683          	lhu	a3,24(a2)
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40017e40:	02b78263          	beq	a5,a1,40017e64 <net_pkt_alloc_buffer+0x1fc>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40017e44:	00100593          	li	a1,1
40017e48:	02b79c63          	bne	a5,a1,40017e80 <net_pkt_alloc_buffer+0x218>
		max_len = MAX(max_len, NET_IPV4_MTU);
40017e4c:	00068793          	mv	a5,a3
40017e50:	24000693          	li	a3,576
40017e54:	eed7f6e3          	bgeu	a5,a3,40017d40 <net_pkt_alloc_buffer+0xd8>
40017e58:	24000793          	li	a5,576
40017e5c:	ee5ff06f          	j	40017d40 <net_pkt_alloc_buffer+0xd8>
		max_len = 0;
40017e60:	00000693          	li	a3,0
		max_len = MAX(max_len, NET_IPV6_MTU);
40017e64:	00068793          	mv	a5,a3
40017e68:	50000693          	li	a3,1280
40017e6c:	ecd7fae3          	bgeu	a5,a3,40017d40 <net_pkt_alloc_buffer+0xd8>
40017e70:	50000793          	li	a5,1280
40017e74:	ecdff06f          	j	40017d40 <net_pkt_alloc_buffer+0xd8>
		max_len = 0;
40017e78:	00000693          	li	a3,0
40017e7c:	fd1ff06f          	j	40017e4c <net_pkt_alloc_buffer+0x1e4>
		if (net_if_l2(net_pkt_iface(pkt)) ==
40017e80:	00462583          	lw	a1,4(a2)
40017e84:	40045637          	lui	a2,0x40045
40017e88:	ab860613          	addi	a2,a2,-1352 # 40044ab8 <_net_l2_ETHERNET>
			max_len = size;
40017e8c:	00070793          	mv	a5,a4
		if (net_if_l2(net_pkt_iface(pkt)) ==
40017e90:	eac598e3          	bne	a1,a2,40017d40 <net_pkt_alloc_buffer+0xd8>
			max_len += NET_ETH_MAX_HDR_SIZE;
40017e94:	00e68793          	addi	a5,a3,14
40017e98:	ea9ff06f          	j	40017d40 <net_pkt_alloc_buffer+0xd8>
		pool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;
40017e9c:	40045c37          	lui	s8,0x40045
40017ea0:	980c0c13          	addi	s8,s8,-1664 # 40044980 <rx_bufs>
40017ea4:	ec1ff06f          	j	40017d64 <net_pkt_alloc_buffer+0xfc>
		if (!first && !current) {
40017ea8:	000b1463          	bnez	s6,40017eb0 <net_pkt_alloc_buffer+0x248>
40017eac:	06078463          	beqz	a5,40017f14 <net_pkt_alloc_buffer+0x2ac>
			current->frags = new;
40017eb0:	0137a223          	sw	s3,4(a5)
		if (current->size > size) {
40017eb4:	0129d783          	lhu	a5,18(s3)
40017eb8:	00fdf463          	bgeu	s11,a5,40017ec0 <net_pkt_alloc_buffer+0x258>
			current->size = size;
40017ebc:	01b99923          	sh	s11,18(s3)
		size -= current->size;
40017ec0:	0129d783          	lhu	a5,18(s3)
40017ec4:	40fd8db3          	sub	s11,s11,a5
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
40017ec8:	0124e7b3          	or	a5,s1,s2
40017ecc:	02078663          	beqz	a5,40017ef8 <net_pkt_alloc_buffer+0x290>
40017ed0:	01a49463          	bne	s1,s10,40017ed8 <net_pkt_alloc_buffer+0x270>
40017ed4:	02990263          	beq	s2,s1,40017ef8 <net_pkt_alloc_buffer+0x290>
			int64_t remaining = end - sys_clock_tick_get();
40017ed8:	720190ef          	jal	ra,400315f8 <sys_clock_tick_get>
40017edc:	40ab84b3          	sub	s1,s7,a0
40017ee0:	009bb7b3          	sltu	a5,s7,s1
40017ee4:	40bc85b3          	sub	a1,s9,a1
40017ee8:	40f58933          	sub	s2,a1,a5
			if (remaining <= 0) {
40017eec:	01204663          	bgtz	s2,40017ef8 <net_pkt_alloc_buffer+0x290>
40017ef0:	00091663          	bnez	s2,40017efc <net_pkt_alloc_buffer+0x294>
40017ef4:	00048463          	beqz	s1,40017efc <net_pkt_alloc_buffer+0x294>
	} while (size);
40017ef8:	ec0d92e3          	bnez	s11,40017dbc <net_pkt_alloc_buffer+0x154>
	if (!buf) {
40017efc:	ee0b02e3          	beqz	s6,40017de0 <net_pkt_alloc_buffer+0x178>
	net_pkt_append_buffer(pkt, buf);
40017f00:	000b0593          	mv	a1,s6
40017f04:	000a8513          	mv	a0,s5
40017f08:	d2dff0ef          	jal	ra,40017c34 <net_pkt_append_buffer>
		return 0;
40017f0c:	00000513          	li	a0,0
40017f10:	ee5ff06f          	j	40017df4 <net_pkt_alloc_buffer+0x18c>
40017f14:	00050b13          	mv	s6,a0
40017f18:	f9dff06f          	j	40017eb4 <net_pkt_alloc_buffer+0x24c>
		net_buf_unref(first);
40017f1c:	000b0513          	mv	a0,s6
40017f20:	e9cf50ef          	jal	ra,4000d5bc <net_buf_unref>
	if (!buf) {
40017f24:	ebdff06f          	j	40017de0 <net_pkt_alloc_buffer+0x178>
		NET_ERR("Data buffer (%zd) allocation failed.", alloc_len);
40017f28:	00010493          	mv	s1,sp
40017f2c:	fe010113          	addi	sp,sp,-32
40017f30:	00010613          	mv	a2,sp
40017f34:	400357b7          	lui	a5,0x40035
40017f38:	e4878793          	addi	a5,a5,-440 # 40034e48 <in6addr_any+0x19c>
40017f3c:	00f62a23          	sw	a5,20(a2)
40017f40:	00300793          	li	a5,3
40017f44:	01462c23          	sw	s4,24(a2)
40017f48:	00f62823          	sw	a5,16(a2)
40017f4c:	000025b7          	lui	a1,0x2
40017f50:	00000693          	li	a3,0
40017f54:	01060613          	addi	a2,a2,16
40017f58:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
40017f5c:	78c50513          	addi	a0,a0,1932
40017f60:	834ed0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
40017f64:	00048113          	mv	sp,s1
40017f68:	e89ff06f          	j	40017df0 <net_pkt_alloc_buffer+0x188>

40017f6c <pkt_alloc_with_buffer>:
{
40017f6c:	fd010113          	addi	sp,sp,-48
40017f70:	03212023          	sw	s2,32(sp)
40017f74:	01812423          	sw	s8,8(sp)
40017f78:	00050913          	mv	s2,a0
40017f7c:	00058c13          	mv	s8,a1
	uint64_t end = sys_clock_timeout_end_calc(timeout);
40017f80:	00078513          	mv	a0,a5
40017f84:	00080593          	mv	a1,a6
{
40017f88:	02812423          	sw	s0,40(sp)
40017f8c:	02912223          	sw	s1,36(sp)
40017f90:	01312e23          	sw	s3,28(sp)
40017f94:	01412c23          	sw	s4,24(sp)
40017f98:	01512a23          	sw	s5,20(sp)
40017f9c:	01612823          	sw	s6,16(sp)
40017fa0:	01712623          	sw	s7,12(sp)
40017fa4:	02112623          	sw	ra,44(sp)
40017fa8:	00060a93          	mv	s5,a2
40017fac:	00068b93          	mv	s7,a3
40017fb0:	00078413          	mv	s0,a5
40017fb4:	00080493          	mv	s1,a6
40017fb8:	00070b13          	mv	s6,a4
	uint64_t end = sys_clock_timeout_end_calc(timeout);
40017fbc:	704190ef          	jal	ra,400316c0 <sys_clock_timeout_end_calc>
40017fc0:	00050993          	mv	s3,a0
40017fc4:	00058a13          	mv	s4,a1
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
40017fc8:	00040613          	mv	a2,s0
40017fcc:	00048693          	mv	a3,s1
40017fd0:	000c0593          	mv	a1,s8
40017fd4:	00090513          	mv	a0,s2
40017fd8:	c0dff0ef          	jal	ra,40017be4 <pkt_alloc_on_iface>
	if (!pkt) {
40017fdc:	06050a63          	beqz	a0,40018050 <pkt_alloc_with_buffer+0xe4>
	pkt->family = family;
40017fe0:	03754783          	lbu	a5,55(a0)
40017fe4:	005b9b93          	slli	s7,s7,0x5
40017fe8:	00050913          	mv	s2,a0
40017fec:	01f7f793          	andi	a5,a5,31
40017ff0:	0177e7b3          	or	a5,a5,s7
40017ff4:	02f50ba3          	sb	a5,55(a0)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
40017ff8:	009467b3          	or	a5,s0,s1
40017ffc:	02078863          	beqz	a5,4001802c <pkt_alloc_with_buffer+0xc0>
40018000:	fff00793          	li	a5,-1
40018004:	00f41463          	bne	s0,a5,4001800c <pkt_alloc_with_buffer+0xa0>
40018008:	02848263          	beq	s1,s0,4001802c <pkt_alloc_with_buffer+0xc0>
		int64_t remaining = end - sys_clock_tick_get();
4001800c:	5ec190ef          	jal	ra,400315f8 <sys_clock_tick_get>
40018010:	40a98433          	sub	s0,s3,a0
40018014:	0089b9b3          	sltu	s3,s3,s0
40018018:	40ba0a33          	sub	s4,s4,a1
4001801c:	413a04b3          	sub	s1,s4,s3
		if (remaining <= 0) {
40018020:	0004d663          	bgez	s1,4001802c <pkt_alloc_with_buffer+0xc0>
40018024:	00000413          	li	s0,0
40018028:	00000493          	li	s1,0
	ret = net_pkt_alloc_buffer(pkt, size, proto, timeout);
4001802c:	00040693          	mv	a3,s0
40018030:	00048713          	mv	a4,s1
40018034:	000b0613          	mv	a2,s6
40018038:	000a8593          	mv	a1,s5
4001803c:	00090513          	mv	a0,s2
40018040:	c29ff0ef          	jal	ra,40017c68 <net_pkt_alloc_buffer>
	if (ret) {
40018044:	00050863          	beqz	a0,40018054 <pkt_alloc_with_buffer+0xe8>
		net_pkt_unref(pkt);
40018048:	00090513          	mv	a0,s2
4001804c:	fd0ff0ef          	jal	ra,4001781c <net_pkt_unref>
		return NULL;
40018050:	00000913          	li	s2,0
}
40018054:	02c12083          	lw	ra,44(sp)
40018058:	02812403          	lw	s0,40(sp)
4001805c:	02412483          	lw	s1,36(sp)
40018060:	01c12983          	lw	s3,28(sp)
40018064:	01812a03          	lw	s4,24(sp)
40018068:	01412a83          	lw	s5,20(sp)
4001806c:	01012b03          	lw	s6,16(sp)
40018070:	00c12b83          	lw	s7,12(sp)
40018074:	00812c03          	lw	s8,8(sp)
40018078:	00090513          	mv	a0,s2
4001807c:	02012903          	lw	s2,32(sp)
40018080:	03010113          	addi	sp,sp,48
40018084:	00008067          	ret

40018088 <net_pkt_alloc_with_buffer>:
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
40018088:	00078813          	mv	a6,a5
4001808c:	00070793          	mv	a5,a4
40018090:	00068713          	mv	a4,a3
40018094:	00060693          	mv	a3,a2
40018098:	00058613          	mv	a2,a1
4001809c:	00050593          	mv	a1,a0
400180a0:	40044537          	lui	a0,0x40044
400180a4:	7f050513          	addi	a0,a0,2032 # 400447f0 <tx_pkts>
400180a8:	ec5ff06f          	j	40017f6c <pkt_alloc_with_buffer>

400180ac <net_pkt_rx_alloc_with_buffer>:
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
400180ac:	00078813          	mv	a6,a5
400180b0:	00070793          	mv	a5,a4
400180b4:	00068713          	mv	a4,a3
400180b8:	00060693          	mv	a3,a2
400180bc:	00058613          	mv	a2,a1
400180c0:	00050593          	mv	a1,a0
400180c4:	40044537          	lui	a0,0x40044
400180c8:	7b850513          	addi	a0,a0,1976 # 400447b8 <rx_pkts>
400180cc:	ea1ff06f          	j	40017f6c <pkt_alloc_with_buffer>

400180d0 <net_pkt_skip>:

int net_pkt_skip(struct net_pkt *pkt, size_t skip)
{
400180d0:	00058613          	mv	a2,a1
	NET_DBG("pkt %p skip %zu", pkt, skip);

	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
400180d4:	00100713          	li	a4,1
400180d8:	00000693          	li	a3,0
400180dc:	00000593          	li	a1,0
400180e0:	c08ff06f          	j	400174e8 <net_pkt_cursor_operate>

400180e4 <clone_pkt_lladdr>:
static void clone_pkt_lladdr(struct net_pkt *pkt, struct net_pkt *clone_pkt,
			     struct net_linkaddr *lladdr)
{
	int32_t ll_addr_offset;

	if (!lladdr->addr)
400180e4:	00062783          	lw	a5,0(a2)
400180e8:	08078c63          	beqz	a5,40018180 <clone_pkt_lladdr+0x9c>
	if (!ptr || !pkt || !pkt->buffer) {
400180ec:	08050a63          	beqz	a0,40018180 <clone_pkt_lladdr+0x9c>
400180f0:	00852703          	lw	a4,8(a0)
400180f4:	08070663          	beqz	a4,40018180 <clone_pkt_lladdr+0x9c>
{
400180f8:	ff010113          	addi	sp,sp,-16
400180fc:	00912223          	sw	s1,4(sp)
40018100:	01212023          	sw	s2,0(sp)
40018104:	00112623          	sw	ra,12(sp)
40018108:	00812423          	sw	s0,8(sp)
4001810c:	00058493          	mv	s1,a1
40018110:	00060913          	mv	s2,a2
	offset = 0U;
40018114:	00000693          	li	a3,0
		if (buf->data <= ptr && ptr <= (buf->data + buf->len)) {
40018118:	00c72603          	lw	a2,12(a4)
4001811c:	01075583          	lhu	a1,16(a4)
40018120:	04c7e463          	bltu	a5,a2,40018168 <clone_pkt_lladdr+0x84>
40018124:	00b60533          	add	a0,a2,a1
40018128:	04f56063          	bltu	a0,a5,40018168 <clone_pkt_lladdr+0x84>
			ret = offset + (ptr - buf->data);
4001812c:	40c787b3          	sub	a5,a5,a2
		return;

	ll_addr_offset = net_pkt_find_offset(pkt, lladdr->addr);

	if (ll_addr_offset >= 0) {
		net_pkt_cursor_init(clone_pkt);
40018130:	00048513          	mv	a0,s1
			ret = offset + (ptr - buf->data);
40018134:	00d78433          	add	s0,a5,a3
		net_pkt_cursor_init(clone_pkt);
40018138:	9b9ff0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
		net_pkt_skip(clone_pkt, ll_addr_offset);
4001813c:	00040593          	mv	a1,s0
40018140:	00048513          	mv	a0,s1
40018144:	f8dff0ef          	jal	ra,400180d0 <net_pkt_skip>
 *
 * @return cursor's position
 */
static inline void *net_pkt_cursor_get_pos(struct net_pkt *pkt)
{
	return pkt->cursor.pos;
40018148:	0104a783          	lw	a5,16(s1)
		lladdr->addr = net_pkt_cursor_get_pos(clone_pkt);
4001814c:	00f92023          	sw	a5,0(s2)
	}
}
40018150:	00c12083          	lw	ra,12(sp)
40018154:	00812403          	lw	s0,8(sp)
40018158:	00412483          	lw	s1,4(sp)
4001815c:	00012903          	lw	s2,0(sp)
40018160:	01010113          	addi	sp,sp,16
40018164:	00008067          	ret
		buf = buf->frags;
40018168:	00472703          	lw	a4,4(a4)
		offset += buf->len;
4001816c:	00b686b3          	add	a3,a3,a1
40018170:	01069693          	slli	a3,a3,0x10
40018174:	0106d693          	srli	a3,a3,0x10
	while (buf) {
40018178:	fa0710e3          	bnez	a4,40018118 <clone_pkt_lladdr+0x34>
4001817c:	fd5ff06f          	j	40018150 <clone_pkt_lladdr+0x6c>
40018180:	00008067          	ret

40018184 <clone_pkt_attributes>:
	ARG_UNUSED(clone_pkt);
}
#endif

static void clone_pkt_attributes(struct net_pkt *pkt, struct net_pkt *clone_pkt)
{
40018184:	fe010113          	addi	sp,sp,-32
40018188:	00812c23          	sw	s0,24(sp)
4001818c:	00912a23          	sw	s1,20(sp)
40018190:	00112e23          	sw	ra,28(sp)
40018194:	01212823          	sw	s2,16(sp)
40018198:	01312623          	sw	s3,12(sp)
	return pkt->family;
4001819c:	03754703          	lbu	a4,55(a0)
	pkt->family = family;
400181a0:	0375c783          	lbu	a5,55(a1)
400181a4:	00050493          	mv	s1,a0
400181a8:	0e077713          	andi	a4,a4,224
400181ac:	01f7f793          	andi	a5,a5,31
400181b0:	00e7e7b3          	or	a5,a5,a4
400181b4:	02f58ba3          	sb	a5,55(a1)
	return pkt->context;
400181b8:	01452783          	lw	a5,20(a0)
400181bc:	00058413          	mv	s0,a1
	pkt->context = ctx;
400181c0:	00f5aa23          	sw	a5,20(a1)
	return pkt->ip_hdr_len;
400181c4:	03654783          	lbu	a5,54(a0)
	pkt->ip_hdr_len = len;
400181c8:	02f58b23          	sb	a5,54(a1)
	return pkt->ip_dscp;
400181cc:	04052703          	lw	a4,64(a0)
	pkt->ip_dscp = dscp;
400181d0:	0405c783          	lbu	a5,64(a1)
400181d4:	03f77713          	andi	a4,a4,63
400181d8:	fc07f793          	andi	a5,a5,-64
400181dc:	00e7e7b3          	or	a5,a5,a4
400181e0:	04f58023          	sb	a5,64(a1)
	return pkt->ip_ecn;
400181e4:	04052703          	lw	a4,64(a0)
	pkt->ip_ecn = ecn;
400181e8:	0ff7f793          	zext.b	a5,a5
400181ec:	03f7f793          	andi	a5,a5,63
400181f0:	0c077713          	andi	a4,a4,192
400181f4:	00e7e7b3          	or	a5,a5,a4
400181f8:	04f58023          	sb	a5,64(a1)
	return pkt->priority;
400181fc:	04154783          	lbu	a5,65(a0)
	pkt->priority = priority;
40018200:	04f580a3          	sb	a5,65(a1)
	return !!(pkt->captured);
40018204:	03854703          	lbu	a4,56(a0)
	pkt->captured = is_captured;
40018208:	0385c783          	lbu	a5,56(a1)
4001820c:	00477713          	andi	a4,a4,4
40018210:	ffb7f793          	andi	a5,a5,-5
40018214:	00e7e7b3          	or	a5,a5,a4
40018218:	02f58c23          	sb	a5,56(a1)
	return !!(pkt->l2_processed);
4001821c:	03854703          	lbu	a4,56(a0)
	pkt->l2_processed = is_l2_processed;
40018220:	0ff7f793          	zext.b	a5,a5
40018224:	fef7f793          	andi	a5,a5,-17
40018228:	01077713          	andi	a4,a4,16
4001822c:	00e7e7b3          	or	a5,a5,a4
40018230:	02f58c23          	sb	a5,56(a1)
	return pkt->ll_proto_type;
40018234:	03455783          	lhu	a5,52(a0)
	pkt->ll_proto_type = type;
40018238:	02f59a23          	sh	a5,52(a1)

	net_pkt_set_l2_bridged(clone_pkt, net_pkt_is_l2_bridged(pkt));
	net_pkt_set_l2_processed(clone_pkt, net_pkt_is_l2_processed(pkt));
	net_pkt_set_ll_proto_type(clone_pkt, net_pkt_ll_proto_type(pkt));

	if (pkt->buffer && clone_pkt->buffer) {
4001823c:	00852783          	lw	a5,8(a0)
40018240:	06078063          	beqz	a5,400182a0 <clone_pkt_attributes+0x11c>
40018244:	0085a783          	lw	a5,8(a1)
40018248:	04078c63          	beqz	a5,400182a0 <clone_pkt_attributes+0x11c>
	return &pkt->lladdr_src;
4001824c:	02458993          	addi	s3,a1,36
		memcpy(net_pkt_lladdr_src(clone_pkt), net_pkt_lladdr_src(pkt),
40018250:	00800613          	li	a2,8
40018254:	02450593          	addi	a1,a0,36
40018258:	00098513          	mv	a0,s3
4001825c:	a9df40ef          	jal	ra,4000ccf8 <memcpy>
	return &pkt->lladdr_dst;
40018260:	02c40913          	addi	s2,s0,44
		       sizeof(struct net_linkaddr));
		memcpy(net_pkt_lladdr_dst(clone_pkt), net_pkt_lladdr_dst(pkt),
40018264:	00800613          	li	a2,8
40018268:	02c48593          	addi	a1,s1,44
4001826c:	00090513          	mv	a0,s2
40018270:	a89f40ef          	jal	ra,4000ccf8 <memcpy>
		 * into the fragment memory of the buffer,
		 * otherwise we have to set the ll address pointer
		 * relative to the new buffer to avoid dangling
		 * pointers into the source packet.
		 */
		if (pkt->buffer != clone_pkt->buffer) {
40018274:	0084a703          	lw	a4,8(s1)
40018278:	00842783          	lw	a5,8(s0)
4001827c:	02f70263          	beq	a4,a5,400182a0 <clone_pkt_attributes+0x11c>
			clone_pkt_lladdr(pkt, clone_pkt, net_pkt_lladdr_src(clone_pkt));
40018280:	00098613          	mv	a2,s3
40018284:	00040593          	mv	a1,s0
40018288:	00048513          	mv	a0,s1
4001828c:	e59ff0ef          	jal	ra,400180e4 <clone_pkt_lladdr>
			clone_pkt_lladdr(pkt, clone_pkt, net_pkt_lladdr_dst(clone_pkt));
40018290:	00090613          	mv	a2,s2
40018294:	00040593          	mv	a1,s0
40018298:	00048513          	mv	a0,s1
4001829c:	e49ff0ef          	jal	ra,400180e4 <clone_pkt_lladdr>
	return pkt->family;
400182a0:	0344a783          	lw	a5,52(s1)
		}
	}

	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
400182a4:	00100713          	li	a4,1
400182a8:	01d7d793          	srli	a5,a5,0x1d
400182ac:	02e79863          	bne	a5,a4,400182dc <clone_pkt_attributes+0x158>
	return pkt->ipv4_ttl;
400182b0:	0394c783          	lbu	a5,57(s1)
	pkt->ipv4_ttl = ttl;
400182b4:	02f40ca3          	sb	a5,57(s0)
	return pkt->ipv4_opts_len;
400182b8:	03a4c783          	lbu	a5,58(s1)
	pkt->ipv4_opts_len = opts_len;
400182bc:	02f40d23          	sb	a5,58(s0)
		net_pkt_set_ipv6_next_hdr(clone_pkt,
					  net_pkt_ipv6_next_hdr(pkt));
	}

	clone_pkt_cb(pkt, clone_pkt);
}
400182c0:	01c12083          	lw	ra,28(sp)
400182c4:	01812403          	lw	s0,24(sp)
400182c8:	01412483          	lw	s1,20(sp)
400182cc:	01012903          	lw	s2,16(sp)
400182d0:	00c12983          	lw	s3,12(sp)
400182d4:	02010113          	addi	sp,sp,32
400182d8:	00008067          	ret
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
400182dc:	00200713          	li	a4,2
400182e0:	fee790e3          	bne	a5,a4,400182c0 <clone_pkt_attributes+0x13c>
	return pkt->ipv6_hop_limit;
400182e4:	0394c783          	lbu	a5,57(s1)
	pkt->ipv6_hop_limit = hop_limit;
400182e8:	02f40ca3          	sb	a5,57(s0)
	return pkt->ipv6_ext_len;
400182ec:	03a4d783          	lhu	a5,58(s1)
	pkt->ipv6_ext_len = len;
400182f0:	02f41d23          	sh	a5,58(s0)
	return pkt->ipv6_ext_opt_len;
400182f4:	03e4c783          	lbu	a5,62(s1)
	pkt->ipv6_ext_opt_len = len;
400182f8:	02f40f23          	sb	a5,62(s0)
	return pkt->ipv6_prev_hdr_start;
400182fc:	03c4d783          	lhu	a5,60(s1)
	pkt->ipv6_prev_hdr_start = offset;
40018300:	02f41e23          	sh	a5,60(s0)
	return pkt->ipv6_next_hdr;
40018304:	03f4c783          	lbu	a5,63(s1)
	pkt->ipv6_next_hdr = next_hdr;
40018308:	02f40fa3          	sb	a5,63(s0)
}
4001830c:	fb5ff06f          	j	400182c0 <clone_pkt_attributes+0x13c>

40018310 <net_pkt_memset>:
{
40018310:	fe010113          	addi	sp,sp,-32
40018314:	00b12623          	sw	a1,12(sp)
	return net_pkt_cursor_operate(pkt, &byte, amount, false, true);
40018318:	00100713          	li	a4,1
4001831c:	00c10593          	addi	a1,sp,12
40018320:	00000693          	li	a3,0
{
40018324:	00112e23          	sw	ra,28(sp)
	return net_pkt_cursor_operate(pkt, &byte, amount, false, true);
40018328:	9c0ff0ef          	jal	ra,400174e8 <net_pkt_cursor_operate>
}
4001832c:	01c12083          	lw	ra,28(sp)
40018330:	02010113          	addi	sp,sp,32
40018334:	00008067          	ret

40018338 <net_pkt_read>:
	return net_pkt_cursor_operate(pkt, data, length, true, false);
40018338:	00000713          	li	a4,0
4001833c:	00100693          	li	a3,1
40018340:	9a8ff06f          	j	400174e8 <net_pkt_cursor_operate>

40018344 <net_pkt_read_be32>:
{
40018344:	fe010113          	addi	sp,sp,-32
40018348:	00812c23          	sw	s0,24(sp)
	ret = net_pkt_read(pkt, d32, sizeof(uint32_t));
4001834c:	00400613          	li	a2,4
{
40018350:	00058413          	mv	s0,a1
	ret = net_pkt_read(pkt, d32, sizeof(uint32_t));
40018354:	00c10593          	addi	a1,sp,12
{
40018358:	00112e23          	sw	ra,28(sp)
	ret = net_pkt_read(pkt, d32, sizeof(uint32_t));
4001835c:	fddff0ef          	jal	ra,40018338 <net_pkt_read>
	*data = d32[0] << 24 | d32[1] << 16 | d32[2] << 8 | d32[3];
40018360:	00c14783          	lbu	a5,12(sp)
40018364:	00d14703          	lbu	a4,13(sp)
40018368:	01879793          	slli	a5,a5,0x18
4001836c:	01071713          	slli	a4,a4,0x10
40018370:	00e7e7b3          	or	a5,a5,a4
40018374:	00f14703          	lbu	a4,15(sp)
40018378:	00e7e7b3          	or	a5,a5,a4
4001837c:	00e14703          	lbu	a4,14(sp)
40018380:	00871713          	slli	a4,a4,0x8
40018384:	00e7e7b3          	or	a5,a5,a4
40018388:	00f42023          	sw	a5,0(s0)
}
4001838c:	01c12083          	lw	ra,28(sp)
40018390:	01812403          	lw	s0,24(sp)
40018394:	02010113          	addi	sp,sp,32
40018398:	00008067          	ret

4001839c <net_pkt_copy>:
{
4001839c:	fe010113          	addi	sp,sp,-32
400183a0:	00912a23          	sw	s1,20(sp)
400183a4:	01212823          	sw	s2,16(sp)
400183a8:	01312623          	sw	s3,12(sp)
400183ac:	00112e23          	sw	ra,28(sp)
400183b0:	00812c23          	sw	s0,24(sp)
400183b4:	01412423          	sw	s4,8(sp)
400183b8:	00050493          	mv	s1,a0
400183bc:	00058993          	mv	s3,a1
400183c0:	00060913          	mv	s2,a2
	while (c_dst->buf && c_src->buf && length) {
400183c4:	00c4a783          	lw	a5,12(s1)
400183c8:	10078063          	beqz	a5,400184c8 <net_pkt_copy+0x12c>
400183cc:	00c9a783          	lw	a5,12(s3)
400183d0:	0e078c63          	beqz	a5,400184c8 <net_pkt_copy+0x12c>
400183d4:	02091463          	bnez	s2,400183fc <net_pkt_copy+0x60>
	return 0;
400183d8:	00000513          	li	a0,0
}
400183dc:	01c12083          	lw	ra,28(sp)
400183e0:	01812403          	lw	s0,24(sp)
400183e4:	01412483          	lw	s1,20(sp)
400183e8:	01012903          	lw	s2,16(sp)
400183ec:	00c12983          	lw	s3,12(sp)
400183f0:	00812a03          	lw	s4,8(sp)
400183f4:	02010113          	addi	sp,sp,32
400183f8:	00008067          	ret
		pkt_cursor_advance(pkt_dst, true);
400183fc:	00100593          	li	a1,1
40018400:	00048513          	mv	a0,s1
40018404:	f35fe0ef          	jal	ra,40017338 <pkt_cursor_advance>
		pkt_cursor_advance(pkt_src, false);
40018408:	00098513          	mv	a0,s3
4001840c:	00000593          	li	a1,0
40018410:	f29fe0ef          	jal	ra,40017338 <pkt_cursor_advance>
		if (!c_dst->buf || !c_src->buf) {
40018414:	00c4a503          	lw	a0,12(s1)
40018418:	04050a63          	beqz	a0,4001846c <net_pkt_copy+0xd0>
4001841c:	00c9a703          	lw	a4,12(s3)
40018420:	04070663          	beqz	a4,4001846c <net_pkt_copy+0xd0>
		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
40018424:	01075a03          	lhu	s4,16(a4)
40018428:	0109a783          	lw	a5,16(s3)
4001842c:	00c72703          	lw	a4,12(a4)
40018430:	00c50513          	addi	a0,a0,12
40018434:	40e787b3          	sub	a5,a5,a4
40018438:	40fa0a33          	sub	s4,s4,a5
4001843c:	c08f50ef          	jal	ra,4000d844 <net_buf_simple_max_len>
		d_len = net_buf_max_len(c_dst->buf) - (c_dst->pos - c_dst->buf->data);
40018440:	00c4a783          	lw	a5,12(s1)
40018444:	00050413          	mv	s0,a0
40018448:	0104a503          	lw	a0,16(s1)
4001844c:	00c7a783          	lw	a5,12(a5)
40018450:	40f507b3          	sub	a5,a0,a5
40018454:	40f40433          	sub	s0,s0,a5
		if (length < s_len && length < d_len) {
40018458:	01497463          	bgeu	s2,s4,40018460 <net_pkt_copy+0xc4>
4001845c:	00896c63          	bltu	s2,s0,40018474 <net_pkt_copy+0xd8>
			if (d_len < s_len) {
40018460:	008a7463          	bgeu	s4,s0,40018468 <net_pkt_copy+0xcc>
40018464:	000a0413          	mv	s0,s4
		if (!len) {
40018468:	00041863          	bnez	s0,40018478 <net_pkt_copy+0xdc>
		return -ENOBUFS;
4001846c:	f9700513          	li	a0,-105
40018470:	f6dff06f          	j	400183dc <net_pkt_copy+0x40>
40018474:	00090413          	mv	s0,s2
		memcpy(c_dst->pos, c_src->pos, len);
40018478:	0109a583          	lw	a1,16(s3)
4001847c:	00040613          	mv	a2,s0
40018480:	879f40ef          	jal	ra,4000ccf8 <memcpy>
	return pkt->overwrite;
40018484:	0374c783          	lbu	a5,55(s1)
		if (!net_pkt_is_being_overwritten(pkt_dst)) {
40018488:	0017f793          	andi	a5,a5,1
4001848c:	00079a63          	bnez	a5,400184a0 <net_pkt_copy+0x104>
	return net_buf_simple_add(&buf->b, len);
40018490:	00c4a503          	lw	a0,12(s1)
40018494:	00040593          	mv	a1,s0
40018498:	00c50513          	addi	a0,a0,12
4001849c:	b2cf50ef          	jal	ra,4000d7c8 <net_buf_simple_add>
		pkt_cursor_update(pkt_dst, len, true);
400184a0:	00100613          	li	a2,1
400184a4:	00040593          	mv	a1,s0
400184a8:	00048513          	mv	a0,s1
400184ac:	ef9fe0ef          	jal	ra,400173a4 <pkt_cursor_update>
		pkt_cursor_update(pkt_src, len, false);
400184b0:	00000613          	li	a2,0
400184b4:	00040593          	mv	a1,s0
400184b8:	00098513          	mv	a0,s3
400184bc:	ee9fe0ef          	jal	ra,400173a4 <pkt_cursor_update>
		length -= len;
400184c0:	40890933          	sub	s2,s2,s0
400184c4:	f01ff06f          	j	400183c4 <net_pkt_copy+0x28>
	return 0;
400184c8:	00000513          	li	a0,0
	if (length) {
400184cc:	f00908e3          	beqz	s2,400183dc <net_pkt_copy+0x40>
400184d0:	f9dff06f          	j	4001846c <net_pkt_copy+0xd0>

400184d4 <net_pkt_remaining_data>:

	return clone_pkt;
}

size_t net_pkt_remaining_data(struct net_pkt *pkt)
{
400184d4:	00050793          	mv	a5,a0
	struct net_buf *buf;
	size_t data_length;

	if (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {
400184d8:	04050263          	beqz	a0,4001851c <net_pkt_remaining_data+0x48>
400184dc:	00c52703          	lw	a4,12(a0)
		return 0;
400184e0:	00000513          	li	a0,0
	if (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {
400184e4:	02070e63          	beqz	a4,40018520 <net_pkt_remaining_data+0x4c>
400184e8:	0107a783          	lw	a5,16(a5)
400184ec:	02078a63          	beqz	a5,40018520 <net_pkt_remaining_data+0x4c>
	}

	buf = pkt->cursor.buf;
	data_length = buf->len - (pkt->cursor.pos - buf->data);
400184f0:	00c72683          	lw	a3,12(a4)
400184f4:	01075503          	lhu	a0,16(a4)
400184f8:	40d787b3          	sub	a5,a5,a3
400184fc:	40f50533          	sub	a0,a0,a5

	buf = buf->frags;
40018500:	00472783          	lw	a5,4(a4)
	while (buf) {
40018504:	00079463          	bnez	a5,4001850c <net_pkt_remaining_data+0x38>
40018508:	00008067          	ret
		data_length += buf->len;
4001850c:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
40018510:	0047a783          	lw	a5,4(a5)
		data_length += buf->len;
40018514:	00e50533          	add	a0,a0,a4
		buf = buf->frags;
40018518:	fedff06f          	j	40018504 <net_pkt_remaining_data+0x30>
		return 0;
4001851c:	00000513          	li	a0,0
	}

	return data_length;
}
40018520:	00008067          	ret

40018524 <net_pkt_update_length>:

int net_pkt_update_length(struct net_pkt *pkt, size_t length)
{
	struct net_buf *buf;

	for (buf = pkt->buffer; buf; buf = buf->frags) {
40018524:	00852783          	lw	a5,8(a0)
40018528:	00079a63          	bnez	a5,4001853c <net_pkt_update_length+0x18>
			buf->len = length;
			length = 0;
		}
	}

	return !length ? 0 : -EINVAL;
4001852c:	fea00513          	li	a0,-22
40018530:	00059463          	bnez	a1,40018538 <net_pkt_update_length+0x14>
40018534:	00000513          	li	a0,0
}
40018538:	00008067          	ret
		if (buf->len < length) {
4001853c:	0107d703          	lhu	a4,16(a5)
40018540:	00b77863          	bgeu	a4,a1,40018550 <net_pkt_update_length+0x2c>
			length -= buf->len;
40018544:	40e585b3          	sub	a1,a1,a4
	for (buf = pkt->buffer; buf; buf = buf->frags) {
40018548:	0047a783          	lw	a5,4(a5)
4001854c:	fddff06f          	j	40018528 <net_pkt_update_length+0x4>
			buf->len = length;
40018550:	00b79823          	sh	a1,16(a5)
			length = 0;
40018554:	00000593          	li	a1,0
40018558:	ff1ff06f          	j	40018548 <net_pkt_update_length+0x24>

4001855c <net_pkt_pull>:

int net_pkt_pull(struct net_pkt *pkt, size_t length)
{
4001855c:	ff010113          	addi	sp,sp,-16
40018560:	00812423          	sw	s0,8(sp)
40018564:	00912223          	sw	s1,4(sp)
40018568:	00112623          	sw	ra,12(sp)
4001856c:	01212023          	sw	s2,0(sp)
40018570:	00050413          	mv	s0,a0
40018574:	00058493          	mv	s1,a1
	struct net_pkt_cursor *c_op = &pkt->cursor;

	while (length) {
40018578:	02049863          	bnez	s1,400185a8 <net_pkt_pull+0x4c>
		}

		length -= rem;
	}

	net_pkt_cursor_init(pkt);
4001857c:	00040513          	mv	a0,s0
40018580:	d70ff0ef          	jal	ra,40017af0 <net_pkt_cursor_init>

	if (length) {
		NET_DBG("Still some length to go %zu", length);
		return -ENOBUFS;
40018584:	f9700513          	li	a0,-105
	if (length) {
40018588:	00049463          	bnez	s1,40018590 <net_pkt_pull+0x34>
	}

	return 0;
4001858c:	00000513          	li	a0,0
}
40018590:	00c12083          	lw	ra,12(sp)
40018594:	00812403          	lw	s0,8(sp)
40018598:	00412483          	lw	s1,4(sp)
4001859c:	00012903          	lw	s2,0(sp)
400185a0:	01010113          	addi	sp,sp,16
400185a4:	00008067          	ret
		pkt_cursor_advance(pkt, false);
400185a8:	00000593          	li	a1,0
400185ac:	00040513          	mv	a0,s0
400185b0:	d89fe0ef          	jal	ra,40017338 <pkt_cursor_advance>
		if (!c_op->buf) {
400185b4:	00c42683          	lw	a3,12(s0)
400185b8:	fc0682e3          	beqz	a3,4001857c <net_pkt_pull+0x20>
		left = c_op->buf->len - (c_op->pos - c_op->buf->data);
400185bc:	00c6a703          	lw	a4,12(a3)
400185c0:	01042603          	lw	a2,16(s0)
400185c4:	0106d783          	lhu	a5,16(a3)
400185c8:	40e60633          	sub	a2,a2,a4
400185cc:	40c78733          	sub	a4,a5,a2
		if (!left) {
400185d0:	fac786e3          	beq	a5,a2,4001857c <net_pkt_pull+0x20>
		if (rem > length) {
400185d4:	00070913          	mv	s2,a4
400185d8:	00e4f463          	bgeu	s1,a4,400185e0 <net_pkt_pull+0x84>
400185dc:	00048913          	mv	s2,s1
		c_op->buf->len -= rem;
400185e0:	412787b3          	sub	a5,a5,s2
400185e4:	00f69823          	sh	a5,16(a3)
		left -= rem;
400185e8:	41270633          	sub	a2,a4,s2
		if (left) {
400185ec:	01270c63          	beq	a4,s2,40018604 <net_pkt_pull+0xa8>
			memmove(c_op->pos, c_op->pos+rem, left);
400185f0:	01042503          	lw	a0,16(s0)
400185f4:	012505b3          	add	a1,a0,s2
400185f8:	eb8f40ef          	jal	ra,4000ccb0 <memmove>
		length -= rem;
400185fc:	412484b3          	sub	s1,s1,s2
40018600:	f79ff06f          	j	40018578 <net_pkt_pull+0x1c>
			struct net_buf *buf = pkt->buffer;
40018604:	00842503          	lw	a0,8(s0)
			if (buf) {
40018608:	00050a63          	beqz	a0,4001861c <net_pkt_pull+0xc0>
				pkt->buffer = buf->frags;
4001860c:	00452783          	lw	a5,4(a0)
40018610:	00f42423          	sw	a5,8(s0)
				buf->frags = NULL;
40018614:	00052223          	sw	zero,4(a0)
				net_buf_unref(buf);
40018618:	fa5f40ef          	jal	ra,4000d5bc <net_buf_unref>
			net_pkt_cursor_init(pkt);
4001861c:	00040513          	mv	a0,s0
40018620:	cd0ff0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
40018624:	fd9ff06f          	j	400185fc <net_pkt_pull+0xa0>

40018628 <net_pkt_get_current_offset>:
uint16_t net_pkt_get_current_offset(struct net_pkt *pkt)
{
	struct net_buf *buf = pkt->buffer;
	uint16_t offset;

	if (!pkt->cursor.buf || !pkt->cursor.pos) {
40018628:	00c52683          	lw	a3,12(a0)
{
4001862c:	00050793          	mv	a5,a0
	if (!pkt->cursor.buf || !pkt->cursor.pos) {
40018630:	04068463          	beqz	a3,40018678 <net_pkt_get_current_offset+0x50>
40018634:	01052703          	lw	a4,16(a0)
		return 0;
40018638:	00000513          	li	a0,0
	if (!pkt->cursor.buf || !pkt->cursor.pos) {
4001863c:	04070063          	beqz	a4,4001867c <net_pkt_get_current_offset+0x54>
	struct net_buf *buf = pkt->buffer;
40018640:	0087a783          	lw	a5,8(a5)
	}

	offset = 0U;

	while (buf != pkt->cursor.buf) {
40018644:	00f69e63          	bne	a3,a5,40018660 <net_pkt_get_current_offset+0x38>
		offset += buf->len;
		buf = buf->frags;
	}

	offset += pkt->cursor.pos - buf->data;
40018648:	00c6a783          	lw	a5,12(a3)
4001864c:	40f70733          	sub	a4,a4,a5
40018650:	00e50533          	add	a0,a0,a4
40018654:	01051513          	slli	a0,a0,0x10
40018658:	01055513          	srli	a0,a0,0x10

	return offset;
4001865c:	00008067          	ret
		offset += buf->len;
40018660:	0107d603          	lhu	a2,16(a5)
		buf = buf->frags;
40018664:	0047a783          	lw	a5,4(a5)
		offset += buf->len;
40018668:	00c50533          	add	a0,a0,a2
4001866c:	01051513          	slli	a0,a0,0x10
40018670:	01055513          	srli	a0,a0,0x10
		buf = buf->frags;
40018674:	fd1ff06f          	j	40018644 <net_pkt_get_current_offset+0x1c>
		return 0;
40018678:	00000513          	li	a0,0
}
4001867c:	00008067          	ret

40018680 <net_pkt_clone_internal>:
{
40018680:	fd010113          	addi	sp,sp,-48
40018684:	02112623          	sw	ra,44(sp)
40018688:	02812423          	sw	s0,40(sp)
4001868c:	02912223          	sw	s1,36(sp)
40018690:	00050413          	mv	s0,a0
40018694:	03212023          	sw	s2,32(sp)
40018698:	01312e23          	sw	s3,28(sp)
4001869c:	00058493          	mv	s1,a1
400186a0:	00c12623          	sw	a2,12(sp)
400186a4:	00d12423          	sw	a3,8(sp)
400186a8:	01412c23          	sw	s4,24(sp)
400186ac:	01512a23          	sw	s5,20(sp)
	size_t cursor_offset = net_pkt_get_current_offset(pkt);
400186b0:	f79ff0ef          	jal	ra,40018628 <net_pkt_get_current_offset>
	return pkt->iface;
400186b4:	01842583          	lw	a1,24(s0)
400186b8:	00050993          	mv	s3,a0
	clone_pkt = pkt_alloc_with_buffer(slab, net_pkt_iface(pkt),
400186bc:	00842503          	lw	a0,8(s0)
400186c0:	00b12223          	sw	a1,4(sp)
	return pkt->overwrite;
400186c4:	03744903          	lbu	s2,55(s0)
400186c8:	e01fe0ef          	jal	ra,400174c8 <net_pkt_get_len.isra.0>
400186cc:	00c12783          	lw	a5,12(sp)
400186d0:	00812803          	lw	a6,8(sp)
400186d4:	00412583          	lw	a1,4(sp)
400186d8:	00050613          	mv	a2,a0
400186dc:	00000713          	li	a4,0
400186e0:	00000693          	li	a3,0
400186e4:	00048513          	mv	a0,s1
400186e8:	885ff0ef          	jal	ra,40017f6c <pkt_alloc_with_buffer>
	if (!clone_pkt) {
400186ec:	06050463          	beqz	a0,40018754 <net_pkt_clone_internal+0xd4>
	pkt->overwrite = overwrite;
400186f0:	03744783          	lbu	a5,55(s0)
400186f4:	00050493          	mv	s1,a0
	net_pkt_cursor_init(pkt);
400186f8:	00040513          	mv	a0,s0
400186fc:	0017e793          	ori	a5,a5,1
40018700:	02f40ba3          	sb	a5,55(s0)
	backup->buf = pkt->cursor.buf;
40018704:	00c42a83          	lw	s5,12(s0)
	backup->pos = pkt->cursor.pos;
40018708:	01042a03          	lw	s4,16(s0)
4001870c:	be4ff0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	if (net_pkt_copy(clone_pkt, pkt, net_pkt_get_len(pkt))) {
40018710:	00842503          	lw	a0,8(s0)
40018714:	00197913          	andi	s2,s2,1
40018718:	00197913          	andi	s2,s2,1
4001871c:	dadfe0ef          	jal	ra,400174c8 <net_pkt_get_len.isra.0>
40018720:	00050613          	mv	a2,a0
40018724:	00040593          	mv	a1,s0
40018728:	00048513          	mv	a0,s1
4001872c:	c71ff0ef          	jal	ra,4001839c <net_pkt_copy>
40018730:	04050863          	beqz	a0,40018780 <net_pkt_clone_internal+0x100>
		net_pkt_unref(clone_pkt);
40018734:	00048513          	mv	a0,s1
40018738:	8e4ff0ef          	jal	ra,4001781c <net_pkt_unref>
	pkt->overwrite = overwrite;
4001873c:	03744783          	lbu	a5,55(s0)
	pkt->cursor.buf = backup->buf;
40018740:	01542623          	sw	s5,12(s0)
	pkt->cursor.pos = backup->pos;
40018744:	01442823          	sw	s4,16(s0)
	pkt->overwrite = overwrite;
40018748:	ffe7f793          	andi	a5,a5,-2
4001874c:	0127e7b3          	or	a5,a5,s2
40018750:	02f40ba3          	sb	a5,55(s0)
		return NULL;
40018754:	00000493          	li	s1,0
}
40018758:	02c12083          	lw	ra,44(sp)
4001875c:	02812403          	lw	s0,40(sp)
40018760:	02012903          	lw	s2,32(sp)
40018764:	01c12983          	lw	s3,28(sp)
40018768:	01812a03          	lw	s4,24(sp)
4001876c:	01412a83          	lw	s5,20(sp)
40018770:	00048513          	mv	a0,s1
40018774:	02412483          	lw	s1,36(sp)
40018778:	03010113          	addi	sp,sp,48
4001877c:	00008067          	ret
40018780:	0374c783          	lbu	a5,55(s1)
	clone_pkt_attributes(pkt, clone_pkt);
40018784:	00040513          	mv	a0,s0
40018788:	00048593          	mv	a1,s1
4001878c:	0017e793          	ori	a5,a5,1
40018790:	02f48ba3          	sb	a5,55(s1)
40018794:	9f1ff0ef          	jal	ra,40018184 <clone_pkt_attributes>
	net_pkt_cursor_init(clone_pkt);
40018798:	00048513          	mv	a0,s1
4001879c:	b54ff0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	if (cursor_offset) {
400187a0:	00098863          	beqz	s3,400187b0 <net_pkt_clone_internal+0x130>
		net_pkt_skip(clone_pkt, cursor_offset);
400187a4:	00098593          	mv	a1,s3
400187a8:	00048513          	mv	a0,s1
400187ac:	925ff0ef          	jal	ra,400180d0 <net_pkt_skip>
400187b0:	0374c783          	lbu	a5,55(s1)
400187b4:	ffe7f793          	andi	a5,a5,-2
400187b8:	0127e7b3          	or	a5,a5,s2
400187bc:	02f48ba3          	sb	a5,55(s1)
400187c0:	03744783          	lbu	a5,55(s0)
	pkt->cursor.buf = backup->buf;
400187c4:	01542623          	sw	s5,12(s0)
	pkt->cursor.pos = backup->pos;
400187c8:	01442823          	sw	s4,16(s0)
	pkt->overwrite = overwrite;
400187cc:	ffe7f793          	andi	a5,a5,-2
400187d0:	00f96933          	or	s2,s2,a5
400187d4:	03240ba3          	sb	s2,55(s0)
	return clone_pkt;
400187d8:	f81ff06f          	j	40018758 <net_pkt_clone_internal+0xd8>

400187dc <net_pkt_clone>:
{
400187dc:	00060693          	mv	a3,a2
400187e0:	00058613          	mv	a2,a1
	return net_pkt_clone_internal(pkt, pkt->slab, timeout);
400187e4:	00452583          	lw	a1,4(a0)
400187e8:	e99ff06f          	j	40018680 <net_pkt_clone_internal>

400187ec <net_pkt_get_contiguous_len>:

	return len >= size;
}

size_t net_pkt_get_contiguous_len(struct net_pkt *pkt)
{
400187ec:	ff010113          	addi	sp,sp,-16
400187f0:	00812423          	sw	s0,8(sp)
400187f4:	00112623          	sw	ra,12(sp)
	return pkt->overwrite;
400187f8:	03754583          	lbu	a1,55(a0)
400187fc:	00050413          	mv	s0,a0
40018800:	0015f593          	andi	a1,a1,1
	pkt_cursor_advance(pkt, !net_pkt_is_being_overwritten(pkt));
40018804:	0015c593          	xori	a1,a1,1
40018808:	b31fe0ef          	jal	ra,40017338 <pkt_cursor_advance>

	if (pkt->cursor.buf && pkt->cursor.pos) {
4001880c:	00c42703          	lw	a4,12(s0)
			pkt->cursor.buf->len : pkt->cursor.buf->size;
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
		return len;
	}

	return 0;
40018810:	00000513          	li	a0,0
	if (pkt->cursor.buf && pkt->cursor.pos) {
40018814:	02070663          	beqz	a4,40018840 <net_pkt_get_contiguous_len+0x54>
40018818:	01042783          	lw	a5,16(s0)
	return 0;
4001881c:	00000513          	li	a0,0
	if (pkt->cursor.buf && pkt->cursor.pos) {
40018820:	02078063          	beqz	a5,40018840 <net_pkt_get_contiguous_len+0x54>
40018824:	03744683          	lbu	a3,55(s0)
			pkt->cursor.buf->len : pkt->cursor.buf->size;
40018828:	0016f693          	andi	a3,a3,1
4001882c:	02068263          	beqz	a3,40018850 <net_pkt_get_contiguous_len+0x64>
40018830:	01075503          	lhu	a0,16(a4)
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
40018834:	00c72703          	lw	a4,12(a4)
40018838:	40e787b3          	sub	a5,a5,a4
4001883c:	40f50533          	sub	a0,a0,a5
}
40018840:	00c12083          	lw	ra,12(sp)
40018844:	00812403          	lw	s0,8(sp)
40018848:	01010113          	addi	sp,sp,16
4001884c:	00008067          	ret
			pkt->cursor.buf->len : pkt->cursor.buf->size;
40018850:	01275503          	lhu	a0,18(a4)
40018854:	fe1ff06f          	j	40018834 <net_pkt_get_contiguous_len+0x48>

40018858 <net_pkt_is_contiguous>:
{
40018858:	ff010113          	addi	sp,sp,-16
4001885c:	00812423          	sw	s0,8(sp)
40018860:	00112623          	sw	ra,12(sp)
40018864:	00058413          	mv	s0,a1
	size_t len = net_pkt_get_contiguous_len(pkt);
40018868:	f85ff0ef          	jal	ra,400187ec <net_pkt_get_contiguous_len>
}
4001886c:	00c12083          	lw	ra,12(sp)
	return len >= size;
40018870:	00853533          	sltu	a0,a0,s0
}
40018874:	00812403          	lw	s0,8(sp)
40018878:	00154513          	xori	a0,a0,1
4001887c:	01010113          	addi	sp,sp,16
40018880:	00008067          	ret

40018884 <net_pkt_write>:
{
40018884:	fe010113          	addi	sp,sp,-32
40018888:	00812c23          	sw	s0,24(sp)
4001888c:	00112e23          	sw	ra,28(sp)
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
40018890:	01052783          	lw	a5,16(a0)
{
40018894:	00050413          	mv	s0,a0
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
40018898:	02f59a63          	bne	a1,a5,400188cc <net_pkt_write+0x48>
4001889c:	00c12623          	sw	a2,12(sp)
400188a0:	00b12423          	sw	a1,8(sp)
	size_t len = net_pkt_get_contiguous_len(pkt);
400188a4:	f49ff0ef          	jal	ra,400187ec <net_pkt_get_contiguous_len>
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
400188a8:	00c12603          	lw	a2,12(sp)
400188ac:	00812583          	lw	a1,8(sp)
400188b0:	00c56e63          	bltu	a0,a2,400188cc <net_pkt_write+0x48>
		return net_pkt_skip(pkt, length);
400188b4:	00040513          	mv	a0,s0
}
400188b8:	01812403          	lw	s0,24(sp)
400188bc:	01c12083          	lw	ra,28(sp)
		return net_pkt_skip(pkt, length);
400188c0:	00060593          	mv	a1,a2
}
400188c4:	02010113          	addi	sp,sp,32
		return net_pkt_skip(pkt, length);
400188c8:	809ff06f          	j	400180d0 <net_pkt_skip>
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
400188cc:	00040513          	mv	a0,s0
}
400188d0:	01812403          	lw	s0,24(sp)
400188d4:	01c12083          	lw	ra,28(sp)
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
400188d8:	00100713          	li	a4,1
400188dc:	00100693          	li	a3,1
}
400188e0:	02010113          	addi	sp,sp,32
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
400188e4:	c05fe06f          	j	400174e8 <net_pkt_cursor_operate>

400188e8 <net_pkt_get_data>:

void *net_pkt_get_data(struct net_pkt *pkt,
		       struct net_pkt_data_access *access)
{
400188e8:	fc010113          	addi	sp,sp,-64
400188ec:	02812c23          	sw	s0,56(sp)
400188f0:	02912a23          	sw	s1,52(sp)
400188f4:	02112e23          	sw	ra,60(sp)
400188f8:	03212823          	sw	s2,48(sp)
400188fc:	03312623          	sw	s3,44(sp)
			return NULL;
		}

		return pkt->cursor.pos;
	} else {
		if (net_pkt_is_contiguous(pkt, access->size)) {
40018900:	0045a903          	lw	s2,4(a1)
{
40018904:	00050413          	mv	s0,a0
40018908:	00058493          	mv	s1,a1
	size_t len = net_pkt_get_contiguous_len(pkt);
4001890c:	ee1ff0ef          	jal	ra,400187ec <net_pkt_get_contiguous_len>
		if (net_pkt_is_contiguous(pkt, access->size)) {
40018910:	01256a63          	bltu	a0,s2,40018924 <net_pkt_get_data+0x3c>
			access->data = pkt->cursor.pos;
40018914:	01042783          	lw	a5,16(s0)
40018918:	00f4a023          	sw	a5,0(s1)
			}

			net_pkt_cursor_restore(pkt, &backup);
		}

		return access->data;
4001891c:	0004a503          	lw	a0,0(s1)
40018920:	0580006f          	j	40018978 <net_pkt_get_data+0x90>
40018924:	03744783          	lbu	a5,55(s0)
			if (!access->data) {
40018928:	0004a583          	lw	a1,0(s1)
		} else if (net_pkt_is_being_overwritten(pkt)) {
4001892c:	0017f793          	andi	a5,a5,1
40018930:	fe0786e3          	beqz	a5,4001891c <net_pkt_get_data+0x34>
			if (!access->data) {
40018934:	06059063          	bnez	a1,40018994 <net_pkt_get_data+0xac>
				NET_ERR("Uncontiguous data"
40018938:	40044537          	lui	a0,0x40044
4001893c:	78c52783          	lw	a5,1932(a0) # 4004478c <log_dynamic_net_pkt>
40018940:	0077f793          	andi	a5,a5,7
40018944:	02078863          	beqz	a5,40018974 <net_pkt_get_data+0x8c>
40018948:	400357b7          	lui	a5,0x40035
4001894c:	e7078793          	addi	a5,a5,-400 # 40034e70 <in6addr_any+0x1c4>
40018950:	00f12e23          	sw	a5,28(sp)
40018954:	00200793          	li	a5,2
40018958:	00f12c23          	sw	a5,24(sp)
4001895c:	000015b7          	lui	a1,0x1
40018960:	00000693          	li	a3,0
40018964:	01810613          	addi	a2,sp,24
40018968:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4001896c:	78c50513          	addi	a0,a0,1932
40018970:	e24ec0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
{
40018974:	00000513          	li	a0,0
	}

	return NULL;
}
40018978:	03c12083          	lw	ra,60(sp)
4001897c:	03812403          	lw	s0,56(sp)
40018980:	03412483          	lw	s1,52(sp)
40018984:	03012903          	lw	s2,48(sp)
40018988:	02c12983          	lw	s3,44(sp)
4001898c:	04010113          	addi	sp,sp,64
40018990:	00008067          	ret
	backup->buf = pkt->cursor.buf;
40018994:	00c42983          	lw	s3,12(s0)
	backup->pos = pkt->cursor.pos;
40018998:	01042903          	lw	s2,16(s0)
			if (net_pkt_read(pkt, access->data, access->size)) {
4001899c:	0044a603          	lw	a2,4(s1)
400189a0:	00040513          	mv	a0,s0
400189a4:	995ff0ef          	jal	ra,40018338 <net_pkt_read>
	pkt->cursor.buf = backup->buf;
400189a8:	01342623          	sw	s3,12(s0)
	pkt->cursor.pos = backup->pos;
400189ac:	01242823          	sw	s2,16(s0)
400189b0:	f60506e3          	beqz	a0,4001891c <net_pkt_get_data+0x34>
400189b4:	fc1ff06f          	j	40018974 <net_pkt_get_data+0x8c>

400189b8 <net_pkt_set_data>:
{
	if (IS_ENABLED(CONFIG_NET_HEADERS_ALWAYS_CONTIGUOUS)) {
		return net_pkt_skip(pkt, access->size);
	}

	return net_pkt_write(pkt, access->data, access->size);
400189b8:	0045a603          	lw	a2,4(a1)
400189bc:	0005a583          	lw	a1,0(a1)
400189c0:	ec5ff06f          	j	40018884 <net_pkt_write>

400189c4 <net_pkt_init>:
		(size_t)(k_mem_slab_num_free_get(&tx_pkts) *
			 sizeof(struct net_pkt)),
		get_frees(&rx_bufs), get_size(&rx_bufs),
		get_frees(&tx_bufs), get_size(&tx_bufs));
#endif
}
400189c4:	00008067          	ret

400189c8 <net_tc_rx_stats_priority_setup>:
					   void *user_data)
{
	ARG_UNUSED(user_data);

	tc_rx_stats_priority_setup(iface);
}
400189c8:	00008067          	ret

400189cc <tc_rx_handler>:
#endif
#endif

#if NET_TC_RX_COUNT > 0
static void tc_rx_handler(struct k_fifo *fifo)
{
400189cc:	ff010113          	addi	sp,sp,-16
400189d0:	00812423          	sw	s0,8(sp)
400189d4:	00112623          	sw	ra,12(sp)
400189d8:	00050413          	mv	s0,a0
	return z_impl_k_queue_get(queue, timeout);
400189dc:	fff00593          	li	a1,-1
400189e0:	fff00613          	li	a2,-1
400189e4:	00040513          	mv	a0,s0
400189e8:	645160ef          	jal	ra,4002f82c <z_impl_k_queue_get>
	struct net_pkt *pkt;

	while (1) {
		pkt = k_fifo_get(fifo, K_FOREVER);
		if (pkt == NULL) {
400189ec:	fe0508e3          	beqz	a0,400189dc <tc_rx_handler+0x10>
			continue;
		}

		net_process_rx_packet(pkt);
400189f0:	8a4f70ef          	jal	ra,4000fa94 <net_process_rx_packet>
400189f4:	fe9ff06f          	j	400189dc <tc_rx_handler+0x10>

400189f8 <net_tc_submit_to_rx_queue>:
	k_fifo_put(queue, pkt);
400189f8:	0e800793          	li	a5,232
400189fc:	02f50533          	mul	a0,a0,a5
40018a00:	4003a7b7          	lui	a5,0x4003a
40018a04:	af878793          	addi	a5,a5,-1288 # 40039af8 <rx_classes>
40018a08:	00a78533          	add	a0,a5,a0
40018a0c:	5f91606f          	j	4002f804 <k_queue_append>

40018a10 <net_tx_priority2tc>:
}
40018a10:	00000513          	li	a0,0
40018a14:	00008067          	ret

40018a18 <net_rx_priority2tc>:
	if (prio > NET_PRIORITY_NC) {
40018a18:	00700793          	li	a5,7
40018a1c:	00a7f463          	bgeu	a5,a0,40018a24 <net_rx_priority2tc+0xc>
		prio = NET_PRIORITY_BE;
40018a20:	00000513          	li	a0,0
	return rx_prio2tc_map[prio];
40018a24:	400327b7          	lui	a5,0x40032
40018a28:	62478793          	addi	a5,a5,1572 # 40032624 <priority2tc_strict_1>
40018a2c:	00f50533          	add	a0,a0,a5
}
40018a30:	00054503          	lbu	a0,0(a0)
40018a34:	00008067          	ret

40018a38 <net_tc_tx_init>:
		}

		k_thread_start(tid);
	}
#endif
}
40018a38:	00008067          	ret

40018a3c <net_tc_rx_init>:

void net_tc_rx_init(void)
{
40018a3c:	fd010113          	addi	sp,sp,-48
40018a40:	02812423          	sw	s0,40(sp)
40018a44:	02112623          	sw	ra,44(sp)
40018a48:	02912223          	sw	s1,36(sp)
40018a4c:	03010413          	addi	s0,sp,48
	int i;

	BUILD_ASSERT(NET_TC_RX_COUNT >= 0);

#if defined(CONFIG_NET_STATISTICS)
	net_if_foreach(net_tc_rx_stats_priority_setup, NULL);
40018a50:	40019537          	lui	a0,0x40019
40018a54:	00000593          	li	a1,0
40018a58:	9c850513          	addi	a0,a0,-1592 # 400189c8 <net_tc_rx_stats_priority_setup>
40018a5c:	948fb0ef          	jal	ra,40013ba4 <net_if_foreach>
	z_impl_k_queue_init(queue);
40018a60:	4003a4b7          	lui	s1,0x4003a
40018a64:	af848513          	addi	a0,s1,-1288 # 40039af8 <rx_classes>
40018a68:	579160ef          	jal	ra,4002f7e0 <z_impl_k_queue_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
40018a6c:	fff00713          	li	a4,-1
40018a70:	fff00793          	li	a5,-1
40018a74:	400196b7          	lui	a3,0x40019
40018a78:	4003c5b7          	lui	a1,0x4003c
40018a7c:	4003a537          	lui	a0,0x4003a
40018a80:	00e12423          	sw	a4,8(sp)
40018a84:	00f12623          	sw	a5,12(sp)
40018a88:	00012023          	sw	zero,0(sp)
40018a8c:	fff00893          	li	a7,-1
40018a90:	00000813          	li	a6,0
40018a94:	00000793          	li	a5,0
40018a98:	af848713          	addi	a4,s1,-1288
40018a9c:	9cc68693          	addi	a3,a3,-1588 # 400189cc <tc_rx_handler>
40018aa0:	5e000613          	li	a2,1504
40018aa4:	ff058593          	addi	a1,a1,-16 # 4003bff0 <rx_stack>
40018aa8:	b1050513          	addi	a0,a0,-1264 # 40039b10 <rx_classes+0x18>
40018aac:	504160ef          	jal	ra,4002efb0 <z_impl_k_thread_create>
		tid = k_thread_create(&rx_classes[i].handler, rx_stack[i],
				      K_KERNEL_STACK_SIZEOF(rx_stack[i]),
				      (k_thread_entry_t)tc_rx_handler,
				      &rx_classes[i].fifo, NULL, NULL,
				      priority, 0, K_FOREVER);
		if (!tid) {
40018ab0:	06051663          	bnez	a0,40018b1c <net_tc_rx_init+0xe0>
			NET_ERR("Cannot create TC handler thread %d", i);
40018ab4:	40044537          	lui	a0,0x40044
40018ab8:	79c52783          	lw	a5,1948(a0) # 4004479c <log_dynamic_net_tc>
40018abc:	0077f793          	andi	a5,a5,7
40018ac0:	04078263          	beqz	a5,40018b04 <net_tc_rx_init+0xc8>
40018ac4:	00010493          	mv	s1,sp
40018ac8:	fe010113          	addi	sp,sp,-32
40018acc:	01010613          	addi	a2,sp,16
40018ad0:	400357b7          	lui	a5,0x40035
40018ad4:	ea078793          	addi	a5,a5,-352 # 40034ea0 <in6addr_any+0x1f4>
40018ad8:	00f62a23          	sw	a5,20(a2)
40018adc:	00300793          	li	a5,3
40018ae0:	00062c23          	sw	zero,24(a2)
40018ae4:	00f62823          	sw	a5,16(a2)
40018ae8:	000025b7          	lui	a1,0x2
40018aec:	00000693          	li	a3,0
40018af0:	00048613          	mv	a2,s1
40018af4:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
40018af8:	79c50513          	addi	a0,a0,1948
40018afc:	c98ec0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
40018b00:	00048113          	mv	sp,s1
		}

		k_thread_start(tid);
	}
#endif
}
40018b04:	fd040113          	addi	sp,s0,-48
40018b08:	02c12083          	lw	ra,44(sp)
40018b0c:	02812403          	lw	s0,40(sp)
40018b10:	02412483          	lw	s1,36(sp)
40018b14:	03010113          	addi	sp,sp,48
40018b18:	00008067          	ret
			snprintk(name, sizeof(name), "rx_q[%d]", i);
40018b1c:	40035637          	lui	a2,0x40035
40018b20:	00050493          	mv	s1,a0
40018b24:	00000693          	li	a3,0
40018b28:	ec460613          	addi	a2,a2,-316 # 40034ec4 <in6addr_any+0x218>
40018b2c:	00800593          	li	a1,8
40018b30:	fe840513          	addi	a0,s0,-24
40018b34:	9e8e90ef          	jal	ra,40001d1c <snprintk>
	return z_impl_k_thread_name_set(thread, str);
40018b38:	fe840593          	addi	a1,s0,-24
40018b3c:	00048513          	mv	a0,s1
40018b40:	1a4160ef          	jal	ra,4002ece4 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
40018b44:	00048513          	mv	a0,s1
40018b48:	314160ef          	jal	ra,4002ee5c <z_impl_k_thread_start>
}
40018b4c:	fb9ff06f          	j	40018b04 <net_tc_rx_init+0xc8>

40018b50 <net_ipv6_is_addr_unspecified>:
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40018b50:	00154703          	lbu	a4,1(a0)
40018b54:	00054683          	lbu	a3,0(a0)
{
40018b58:	00050793          	mv	a5,a0
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40018b5c:	00871713          	slli	a4,a4,0x8
40018b60:	00d76733          	or	a4,a4,a3
40018b64:	00254683          	lbu	a3,2(a0)
40018b68:	01069693          	slli	a3,a3,0x10
40018b6c:	00e6e6b3          	or	a3,a3,a4
40018b70:	00354703          	lbu	a4,3(a0)
40018b74:	01871713          	slli	a4,a4,0x18
40018b78:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40018b7c:	08071863          	bnez	a4,40018c0c <net_ipv6_is_addr_unspecified+0xbc>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
40018b80:	00554703          	lbu	a4,5(a0)
40018b84:	00454683          	lbu	a3,4(a0)
40018b88:	00871713          	slli	a4,a4,0x8
40018b8c:	00d76733          	or	a4,a4,a3
40018b90:	00654683          	lbu	a3,6(a0)
40018b94:	01069693          	slli	a3,a3,0x10
40018b98:	00e6e6b3          	or	a3,a3,a4
40018b9c:	00754703          	lbu	a4,7(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40018ba0:	00000513          	li	a0,0
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
40018ba4:	01871713          	slli	a4,a4,0x18
40018ba8:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40018bac:	06071263          	bnez	a4,40018c10 <net_ipv6_is_addr_unspecified+0xc0>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40018bb0:	0097c703          	lbu	a4,9(a5)
40018bb4:	0087c683          	lbu	a3,8(a5)
40018bb8:	00871713          	slli	a4,a4,0x8
40018bbc:	00d76733          	or	a4,a4,a3
40018bc0:	00a7c683          	lbu	a3,10(a5)
40018bc4:	01069693          	slli	a3,a3,0x10
40018bc8:	00e6e6b3          	or	a3,a3,a4
40018bcc:	00b7c703          	lbu	a4,11(a5)
40018bd0:	01871713          	slli	a4,a4,0x18
40018bd4:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
40018bd8:	02071c63          	bnez	a4,40018c10 <net_ipv6_is_addr_unspecified+0xc0>
		UNALIGNED_GET(&addr->s6_addr32[3]) == 0;
40018bdc:	00d7c683          	lbu	a3,13(a5)
40018be0:	00c7c703          	lbu	a4,12(a5)
40018be4:	00f7c503          	lbu	a0,15(a5)
40018be8:	00869693          	slli	a3,a3,0x8
40018bec:	00e6e6b3          	or	a3,a3,a4
40018bf0:	00e7c703          	lbu	a4,14(a5)
40018bf4:	01851513          	slli	a0,a0,0x18
40018bf8:	01071713          	slli	a4,a4,0x10
40018bfc:	00d76733          	or	a4,a4,a3
40018c00:	00e56533          	or	a0,a0,a4
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40018c04:	00153513          	seqz	a0,a0
40018c08:	00008067          	ret
40018c0c:	00000513          	li	a0,0
}
40018c10:	00008067          	ret

40018c14 <net_stats_update_per_proto_recv>:
{
	if (!IS_ENABLED(CONFIG_NET_NATIVE)) {
		return;
	}

	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
40018c14:	01100793          	li	a5,17
40018c18:	02f59463          	bne	a1,a5,40018c40 <net_stats_update_per_proto_recv+0x2c>
	UPDATE_STAT(iface, stats.udp.recv++);
40018c1c:	4003b7b7          	lui	a5,0x4003b
40018c20:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40018c24:	0947a703          	lw	a4,148(a5)
40018c28:	00170713          	addi	a4,a4,1
40018c2c:	08e7aa23          	sw	a4,148(a5)
40018c30:	09852783          	lw	a5,152(a0)
40018c34:	00178793          	addi	a5,a5,1
40018c38:	08f52c23          	sw	a5,152(a0)
}
40018c3c:	00008067          	ret
		net_stats_update_udp_recv(iface);
	} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
40018c40:	00600793          	li	a5,6
40018c44:	02f59263          	bne	a1,a5,40018c68 <net_stats_update_per_proto_recv+0x54>
	UPDATE_STAT(iface, stats.tcp.recv++);
40018c48:	4003b7b7          	lui	a5,0x4003b
40018c4c:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40018c50:	0687a703          	lw	a4,104(a5)
40018c54:	00170713          	addi	a4,a4,1
40018c58:	06e7a423          	sw	a4,104(a5)
40018c5c:	06c52783          	lw	a5,108(a0)
40018c60:	00178793          	addi	a5,a5,1
40018c64:	06f52623          	sw	a5,108(a0)
		net_stats_update_tcp_seg_recv(iface);
	}
}
40018c68:	00008067          	ret

40018c6c <net_stats_update_per_proto_drop>:
{
	if (!IS_ENABLED(CONFIG_NET_NATIVE)) {
		return;
	}

	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
40018c6c:	01100793          	li	a5,17
40018c70:	02f59463          	bne	a1,a5,40018c98 <net_stats_update_per_proto_drop+0x2c>
	UPDATE_STAT(iface, stats.udp.drop++);
40018c74:	4003b7b7          	lui	a5,0x4003b
40018c78:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40018c7c:	0907a703          	lw	a4,144(a5)
40018c80:	00170713          	addi	a4,a4,1
40018c84:	08e7a823          	sw	a4,144(a5)
40018c88:	09452783          	lw	a5,148(a0)
40018c8c:	00178793          	addi	a5,a5,1
40018c90:	08f52a23          	sw	a5,148(a0)
}
40018c94:	00008067          	ret
		net_stats_update_udp_drop(iface);
	} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
40018c98:	00600793          	li	a5,6
40018c9c:	02f59263          	bne	a1,a5,40018cc0 <net_stats_update_per_proto_drop+0x54>
	UPDATE_STAT(iface, stats.tcp.drop++);
40018ca0:	4003b7b7          	lui	a5,0x4003b
40018ca4:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40018ca8:	0647a703          	lw	a4,100(a5)
40018cac:	00170713          	addi	a4,a4,1
40018cb0:	06e7a223          	sw	a4,100(a5)
40018cb4:	06852783          	lw	a5,104(a0)
40018cb8:	00178793          	addi	a5,a5,1
40018cbc:	06f52423          	sw	a5,104(a0)
		net_stats_update_tcp_drop(iface);
	}
}
40018cc0:	00008067          	ret

40018cc4 <conn_addr_cmp>:
	return pkt->family;
40018cc4:	03452703          	lw	a4,52(a0)
static bool conn_addr_cmp(struct net_pkt *pkt,
			  union net_ip_header *ip_hdr,
			  struct sockaddr *addr,
			  bool is_remote)
{
	if (addr->sa_family != net_pkt_family(pkt)) {
40018cc8:	00065783          	lhu	a5,0(a2)
40018ccc:	01d75713          	srli	a4,a4,0x1d
40018cd0:	0ae79e63          	bne	a5,a4,40018d8c <conn_addr_cmp+0xc8>
		return false;
	}

	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40018cd4:	00200713          	li	a4,2
40018cd8:	04e79c63          	bne	a5,a4,40018d30 <conn_addr_cmp+0x6c>
{
40018cdc:	fe010113          	addi	sp,sp,-32
40018ce0:	00112e23          	sw	ra,28(sp)
40018ce4:	00812c23          	sw	s0,24(sp)
	    net_pkt_family(pkt) == AF_INET6 &&
	    addr->sa_family == AF_INET6) {
		uint8_t *addr6;

		if (is_remote) {
			addr6 = ip_hdr->ipv6->src;
40018ce8:	0005a783          	lw	a5,0(a1)
		} else {
			addr6 = ip_hdr->ipv6->dst;
40018cec:	01878593          	addi	a1,a5,24
		if (is_remote) {
40018cf0:	00068463          	beqz	a3,40018cf8 <conn_addr_cmp+0x34>
			addr6 = ip_hdr->ipv6->src;
40018cf4:	00878593          	addi	a1,a5,8
		}

		if (!net_ipv6_is_addr_unspecified(
			    &net_sin6(addr)->sin6_addr)) {
40018cf8:	00460413          	addi	s0,a2,4
		if (!net_ipv6_is_addr_unspecified(
40018cfc:	00040513          	mv	a0,s0
40018d00:	00b12623          	sw	a1,12(sp)
40018d04:	e4dff0ef          	jal	ra,40018b50 <net_ipv6_is_addr_unspecified>
40018d08:	00051c63          	bnez	a0,40018d20 <conn_addr_cmp+0x5c>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
40018d0c:	00c12583          	lw	a1,12(sp)
40018d10:	01000613          	li	a2,16
40018d14:	00040513          	mv	a0,s0
40018d18:	f61f30ef          	jal	ra,4000cc78 <memcmp>
			if (!net_ipv6_addr_cmp_raw((uint8_t *)&net_sin6(addr)->sin6_addr,
40018d1c:	00153513          	seqz	a0,a0
			}
		}
	}

	return true;
}
40018d20:	01c12083          	lw	ra,28(sp)
40018d24:	01812403          	lw	s0,24(sp)
40018d28:	02010113          	addi	sp,sp,32
40018d2c:	00008067          	ret
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40018d30:	00100713          	li	a4,1
		return true;
40018d34:	00100513          	li	a0,1
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40018d38:	04e79e63          	bne	a5,a4,40018d94 <conn_addr_cmp+0xd0>
			addr6 = ip_hdr->ipv6->src;
40018d3c:	0005a783          	lw	a5,0(a1)
			addr4 = ip_hdr->ipv4->dst;
40018d40:	01078713          	addi	a4,a5,16
		if (is_remote) {
40018d44:	00068463          	beqz	a3,40018d4c <conn_addr_cmp+0x88>
			addr4 = ip_hdr->ipv4->src;
40018d48:	00c78713          	addi	a4,a5,12
		if (net_sin(addr)->sin_addr.s_addr) {
40018d4c:	00462603          	lw	a2,4(a2)
		return true;
40018d50:	00100513          	li	a0,1
		if (net_sin(addr)->sin_addr.s_addr) {
40018d54:	04060063          	beqz	a2,40018d94 <conn_addr_cmp+0xd0>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40018d58:	00174683          	lbu	a3,1(a4)
40018d5c:	00074783          	lbu	a5,0(a4)
40018d60:	00374503          	lbu	a0,3(a4)
40018d64:	00869693          	slli	a3,a3,0x8
40018d68:	00f6e6b3          	or	a3,a3,a5
40018d6c:	00274783          	lbu	a5,2(a4)
40018d70:	01851513          	slli	a0,a0,0x18
40018d74:	01079793          	slli	a5,a5,0x10
40018d78:	00d7e7b3          	or	a5,a5,a3
40018d7c:	00f56533          	or	a0,a0,a5
			if (!net_ipv4_addr_cmp_raw((uint8_t *)&net_sin(addr)->sin_addr,
40018d80:	40c50533          	sub	a0,a0,a2
40018d84:	00153513          	seqz	a0,a0
40018d88:	00008067          	ret
		return false;
40018d8c:	00000513          	li	a0,0
40018d90:	00008067          	ret
}
40018d94:	00008067          	ret

40018d98 <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
40018d98:	00058613          	mv	a2,a1
40018d9c:	00050593          	mv	a1,a0
	return z_impl_k_mutex_lock(mutex, timeout);
40018da0:	40045537          	lui	a0,0x40045
40018da4:	82050513          	addi	a0,a0,-2016 # 40044820 <conn_lock>
40018da8:	6941606f          	j	4002f43c <z_impl_k_mutex_lock>

40018dac <k_mutex_unlock.constprop.0.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
40018dac:	40045537          	lui	a0,0x40045
40018db0:	82050513          	addi	a0,a0,-2016 # 40044820 <conn_lock>
40018db4:	7e41606f          	j	4002f598 <z_impl_k_mutex_unlock>

40018db8 <conn_set_unused>:
{
40018db8:	ff010113          	addi	sp,sp,-16
	(void)memset(conn, 0, sizeof(*conn));
40018dbc:	04400613          	li	a2,68
40018dc0:	00000593          	li	a1,0
{
40018dc4:	00112623          	sw	ra,12(sp)
40018dc8:	00812423          	sw	s0,8(sp)
40018dcc:	00050413          	mv	s0,a0
	(void)memset(conn, 0, sizeof(*conn));
40018dd0:	f4df30ef          	jal	ra,4000cd1c <memset>
	k_mutex_lock(&conn_lock, K_FOREVER);
40018dd4:	fff00513          	li	a0,-1
40018dd8:	fff00593          	li	a1,-1
40018ddc:	fbdff0ef          	jal	ra,40018d98 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
40018de0:	400397b7          	lui	a5,0x40039
40018de4:	09478793          	addi	a5,a5,148 # 40039094 <conn_unused>
40018de8:	0007a703          	lw	a4,0(a5)
	parent->next = child;
40018dec:	00e42023          	sw	a4,0(s0)
Z_GENLIST_PREPEND(slist, snode)
40018df0:	0047a703          	lw	a4,4(a5)
	list->head = node;
40018df4:	0087a023          	sw	s0,0(a5)
Z_GENLIST_PREPEND(slist, snode)
40018df8:	00071463          	bnez	a4,40018e00 <conn_set_unused+0x48>
	list->tail = node;
40018dfc:	0087a223          	sw	s0,4(a5)
}
40018e00:	00812403          	lw	s0,8(sp)
40018e04:	00c12083          	lw	ra,12(sp)
40018e08:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&conn_lock);
40018e0c:	fa1ff06f          	j	40018dac <k_mutex_unlock.constprop.0.isra.0>

40018e10 <net_conn_register>:
{
40018e10:	f9010113          	addi	sp,sp,-112
40018e14:	06812423          	sw	s0,104(sp)
40018e18:	06912223          	sw	s1,100(sp)
40018e1c:	07212023          	sw	s2,96(sp)
40018e20:	05312e23          	sw	s3,92(sp)
40018e24:	05412c23          	sw	s4,88(sp)
40018e28:	05512a23          	sw	s5,84(sp)
40018e2c:	05612823          	sw	s6,80(sp)
40018e30:	05712623          	sw	s7,76(sp)
40018e34:	05812423          	sw	s8,72(sp)
40018e38:	06112623          	sw	ra,108(sp)
40018e3c:	05912223          	sw	s9,68(sp)
40018e40:	05a12023          	sw	s10,64(sp)
40018e44:	03b12e23          	sw	s11,60(sp)
40018e48:	07010413          	addi	s0,sp,112
	return list->head;
40018e4c:	40039ab7          	lui	s5,0x40039
40018e50:	00050b93          	mv	s7,a0
40018e54:	00058b13          	mv	s6,a1
	k_mutex_lock(&conn_lock, K_FOREVER);
40018e58:	fff00513          	li	a0,-1
40018e5c:	fff00593          	li	a1,-1
{
40018e60:	00060493          	mv	s1,a2
40018e64:	00068913          	mv	s2,a3
40018e68:	00070a13          	mv	s4,a4
40018e6c:	00078993          	mv	s3,a5
40018e70:	f9042e23          	sw	a6,-100(s0)
40018e74:	f9142c23          	sw	a7,-104(s0)
	k_mutex_lock(&conn_lock, K_FOREVER);
40018e78:	f21ff0ef          	jal	ra,40018d98 <k_mutex_lock.constprop.0.isra.0>
40018e7c:	08caac03          	lw	s8,140(s5) # 4003908c <conn_used>
40018e80:	08ca8a93          	addi	s5,s5,140
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {
40018e84:	000c0a63          	beqz	s8,40018e98 <net_conn_register+0x88>
	return node->next;
40018e88:	000c2c83          	lw	s9,0(s8)
			if (IS_ENABLED(CONFIG_NET_IPV6) &&
40018e8c:	00200d13          	li	s10,2
			} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40018e90:	00100d93          	li	s11,1
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {
40018e94:	020c1863          	bnez	s8,40018ec4 <net_conn_register+0xb4>
	k_mutex_unlock(&conn_lock);
40018e98:	f15ff0ef          	jal	ra,40018dac <k_mutex_unlock.constprop.0.isra.0>
	k_mutex_lock(&conn_lock, K_FOREVER);
40018e9c:	fff00513          	li	a0,-1
40018ea0:	fff00593          	li	a1,-1
40018ea4:	ef5ff0ef          	jal	ra,40018d98 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
40018ea8:	400397b7          	lui	a5,0x40039
40018eac:	09478793          	addi	a5,a5,148 # 40039094 <conn_unused>
40018eb0:	0007ad83          	lw	s11,0(a5)
	if (!node) {
40018eb4:	240d9863          	bnez	s11,40019104 <net_conn_register+0x2f4>
		k_mutex_unlock(&conn_lock);
40018eb8:	ef5ff0ef          	jal	ra,40018dac <k_mutex_unlock.constprop.0.isra.0>
		return -ENOENT;
40018ebc:	ffe00513          	li	a0,-2
40018ec0:	1580006f          	j	40019018 <net_conn_register+0x208>
		if (conn->proto != proto) {
40018ec4:	040c5703          	lhu	a4,64(s8)
40018ec8:	0b771a63          	bne	a4,s7,40018f7c <net_conn_register+0x16c>
		if (conn->family != family) {
40018ecc:	042c4703          	lbu	a4,66(s8)
40018ed0:	0b671663          	bne	a4,s6,40018f7c <net_conn_register+0x16c>
		if (remote_addr) {
40018ed4:	043c4703          	lbu	a4,67(s8)
40018ed8:	00277713          	andi	a4,a4,2
40018edc:	0a048c63          	beqz	s1,40018f94 <net_conn_register+0x184>
			if (!(conn->flags & NET_CONN_REMOTE_ADDR_SET)) {
40018ee0:	08070e63          	beqz	a4,40018f7c <net_conn_register+0x16c>
			    remote_addr->sa_family == AF_INET6 &&
40018ee4:	0004d703          	lhu	a4,0(s1)
			if (IS_ENABLED(CONFIG_NET_IPV6) &&
40018ee8:	03a71a63          	bne	a4,s10,40018f1c <net_conn_register+0x10c>
			    remote_addr->sa_family == AF_INET6 &&
40018eec:	004c5703          	lhu	a4,4(s8)
40018ef0:	09a71663          	bne	a4,s10,40018f7c <net_conn_register+0x16c>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
40018ef4:	01000613          	li	a2,16
40018ef8:	008c0593          	addi	a1,s8,8
40018efc:	00448513          	addi	a0,s1,4
40018f00:	d79f30ef          	jal	ra,4000cc78 <memcmp>
				if (!net_ipv6_addr_cmp(
40018f04:	06051c63          	bnez	a0,40018f7c <net_conn_register+0x16c>
		if (local_addr) {
40018f08:	043c4703          	lbu	a4,67(s8)
40018f0c:	00477713          	andi	a4,a4,4
40018f10:	08091663          	bnez	s2,40018f9c <net_conn_register+0x18c>
		} else if (conn->flags & NET_CONN_LOCAL_ADDR_SET) {
40018f14:	0a070a63          	beqz	a4,40018fc8 <net_conn_register+0x1b8>
40018f18:	0640006f          	j	40018f7c <net_conn_register+0x16c>
			} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40018f1c:	07b71063          	bne	a4,s11,40018f7c <net_conn_register+0x16c>
				   remote_addr->sa_family == AF_INET &&
40018f20:	004c5703          	lhu	a4,4(s8)
40018f24:	05b71c63          	bne	a4,s11,40018f7c <net_conn_register+0x16c>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40018f28:	0054c603          	lbu	a2,5(s1)
40018f2c:	0044c703          	lbu	a4,4(s1)
40018f30:	008c4583          	lbu	a1,8(s8)
40018f34:	00861613          	slli	a2,a2,0x8
40018f38:	00e66633          	or	a2,a2,a4
40018f3c:	0064c703          	lbu	a4,6(s1)
40018f40:	01071713          	slli	a4,a4,0x10
40018f44:	00c76733          	or	a4,a4,a2
40018f48:	0074c603          	lbu	a2,7(s1)
40018f4c:	01861613          	slli	a2,a2,0x18
40018f50:	00e66633          	or	a2,a2,a4
40018f54:	009c4703          	lbu	a4,9(s8)
40018f58:	00871713          	slli	a4,a4,0x8
40018f5c:	00b76733          	or	a4,a4,a1
40018f60:	00ac4583          	lbu	a1,10(s8)
40018f64:	01059593          	slli	a1,a1,0x10
40018f68:	00e5e5b3          	or	a1,a1,a4
40018f6c:	00bc4703          	lbu	a4,11(s8)
40018f70:	01871713          	slli	a4,a4,0x18
40018f74:	00b76733          	or	a4,a4,a1
				if (!net_ipv4_addr_cmp(
40018f78:	f8e608e3          	beq	a2,a4,40018f08 <net_conn_register+0xf8>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {
40018f7c:	00000713          	li	a4,0
40018f80:	000c8463          	beqz	s9,40018f88 <net_conn_register+0x178>
	return node->next;
40018f84:	000ca703          	lw	a4,0(s9)
40018f88:	000c8c13          	mv	s8,s9
40018f8c:	00070c93          	mv	s9,a4
40018f90:	f05ff06f          	j	40018e94 <net_conn_register+0x84>
		} else if (conn->flags & NET_CONN_REMOTE_ADDR_SET) {
40018f94:	f6070ae3          	beqz	a4,40018f08 <net_conn_register+0xf8>
40018f98:	fe5ff06f          	j	40018f7c <net_conn_register+0x16c>
			if (!(conn->flags & NET_CONN_LOCAL_ADDR_SET)) {
40018f9c:	fe0700e3          	beqz	a4,40018f7c <net_conn_register+0x16c>
			    local_addr->sa_family == AF_INET6 &&
40018fa0:	00095703          	lhu	a4,0(s2)
			if (IS_ENABLED(CONFIG_NET_IPV6) &&
40018fa4:	00200613          	li	a2,2
40018fa8:	0ac71863          	bne	a4,a2,40019058 <net_conn_register+0x248>
			    local_addr->sa_family == AF_INET6 &&
40018fac:	01cc5603          	lhu	a2,28(s8)
40018fb0:	fce616e3          	bne	a2,a4,40018f7c <net_conn_register+0x16c>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
40018fb4:	01000613          	li	a2,16
40018fb8:	020c0593          	addi	a1,s8,32
40018fbc:	00490513          	addi	a0,s2,4
40018fc0:	cb9f30ef          	jal	ra,4000cc78 <memcmp>
				if (!net_ipv6_addr_cmp(
40018fc4:	fa051ce3          	bnez	a0,40018f7c <net_conn_register+0x16c>
		if (net_sin(&conn->remote_addr)->sin_port !=
40018fc8:	008a5613          	srli	a2,s4,0x8
40018fcc:	008a1713          	slli	a4,s4,0x8
40018fd0:	00c76733          	or	a4,a4,a2
40018fd4:	006c5603          	lhu	a2,6(s8)
40018fd8:	01071713          	slli	a4,a4,0x10
40018fdc:	01075713          	srli	a4,a4,0x10
40018fe0:	f8e61ee3          	bne	a2,a4,40018f7c <net_conn_register+0x16c>
		if (net_sin(&conn->local_addr)->sin_port !=
40018fe4:	0089d613          	srli	a2,s3,0x8
40018fe8:	00899713          	slli	a4,s3,0x8
40018fec:	00c76733          	or	a4,a4,a2
40018ff0:	01ec5603          	lhu	a2,30(s8)
40018ff4:	01071713          	slli	a4,a4,0x10
40018ff8:	01075713          	srli	a4,a4,0x10
40018ffc:	f8e610e3          	bne	a2,a4,40018f7c <net_conn_register+0x16c>
		k_mutex_unlock(&conn_lock);
40019000:	dadff0ef          	jal	ra,40018dac <k_mutex_unlock.constprop.0.isra.0>
		NET_ERR("Identical connection handler %p already found.", conn);
40019004:	40044537          	lui	a0,0x40044
40019008:	75452703          	lw	a4,1876(a0) # 40044754 <log_dynamic_net_conn>
4001900c:	00777713          	andi	a4,a4,7
40019010:	0a071863          	bnez	a4,400190c0 <net_conn_register+0x2b0>
		return -EALREADY;
40019014:	f8800513          	li	a0,-120
}
40019018:	f9040113          	addi	sp,s0,-112
4001901c:	06c12083          	lw	ra,108(sp)
40019020:	06812403          	lw	s0,104(sp)
40019024:	06412483          	lw	s1,100(sp)
40019028:	06012903          	lw	s2,96(sp)
4001902c:	05c12983          	lw	s3,92(sp)
40019030:	05812a03          	lw	s4,88(sp)
40019034:	05412a83          	lw	s5,84(sp)
40019038:	05012b03          	lw	s6,80(sp)
4001903c:	04c12b83          	lw	s7,76(sp)
40019040:	04812c03          	lw	s8,72(sp)
40019044:	04412c83          	lw	s9,68(sp)
40019048:	04012d03          	lw	s10,64(sp)
4001904c:	03c12d83          	lw	s11,60(sp)
40019050:	07010113          	addi	sp,sp,112
40019054:	00008067          	ret
			} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40019058:	00100613          	li	a2,1
4001905c:	f2c710e3          	bne	a4,a2,40018f7c <net_conn_register+0x16c>
				   local_addr->sa_family == AF_INET &&
40019060:	01cc5603          	lhu	a2,28(s8)
40019064:	f0e61ce3          	bne	a2,a4,40018f7c <net_conn_register+0x16c>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40019068:	00594603          	lbu	a2,5(s2)
4001906c:	00494703          	lbu	a4,4(s2)
40019070:	020c4583          	lbu	a1,32(s8)
40019074:	00861613          	slli	a2,a2,0x8
40019078:	00e66633          	or	a2,a2,a4
4001907c:	00694703          	lbu	a4,6(s2)
40019080:	01071713          	slli	a4,a4,0x10
40019084:	00c76733          	or	a4,a4,a2
40019088:	00794603          	lbu	a2,7(s2)
4001908c:	01861613          	slli	a2,a2,0x18
40019090:	00e66633          	or	a2,a2,a4
40019094:	021c4703          	lbu	a4,33(s8)
40019098:	00871713          	slli	a4,a4,0x8
4001909c:	00b76733          	or	a4,a4,a1
400190a0:	022c4583          	lbu	a1,34(s8)
400190a4:	01059593          	slli	a1,a1,0x10
400190a8:	00e5e5b3          	or	a1,a1,a4
400190ac:	023c4703          	lbu	a4,35(s8)
400190b0:	01871713          	slli	a4,a4,0x18
400190b4:	00b76733          	or	a4,a4,a1
				if (!net_ipv4_addr_cmp(
400190b8:	f0e608e3          	beq	a2,a4,40018fc8 <net_conn_register+0x1b8>
400190bc:	ec1ff06f          	j	40018f7c <net_conn_register+0x16c>
		NET_ERR("Identical connection handler %p already found.", conn);
400190c0:	00010493          	mv	s1,sp
400190c4:	fe010113          	addi	sp,sp,-32
400190c8:	00010613          	mv	a2,sp
400190cc:	40035737          	lui	a4,0x40035
400190d0:	ed870713          	addi	a4,a4,-296 # 40034ed8 <in6addr_any+0x22c>
400190d4:	00300793          	li	a5,3
400190d8:	00e62a23          	sw	a4,20(a2)
400190dc:	01862c23          	sw	s8,24(a2)
400190e0:	00f62823          	sw	a5,16(a2)
400190e4:	000025b7          	lui	a1,0x2
400190e8:	00000693          	li	a3,0
400190ec:	01060613          	addi	a2,a2,16
400190f0:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
400190f4:	75450513          	addi	a0,a0,1876
400190f8:	e9deb0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
400190fc:	00048113          	mv	sp,s1
40019100:	f15ff06f          	j	40019014 <net_conn_register+0x204>
40019104:	000da703          	lw	a4,0(s11)
Z_GENLIST_REMOVE(slist, snode)
40019108:	0047a683          	lw	a3,4(a5)
	list->head = node;
4001910c:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_REMOVE(slist, snode)
40019110:	00dd9463          	bne	s11,a3,40019118 <net_conn_register+0x308>
	list->tail = node;
40019114:	00e7a223          	sw	a4,4(a5)
	parent->next = child;
40019118:	000da023          	sw	zero,0(s11)
	k_mutex_unlock(&conn_lock);
4001911c:	c91ff0ef          	jal	ra,40018dac <k_mutex_unlock.constprop.0.isra.0>
	if (remote_addr) {
40019120:	0c048e63          	beqz	s1,400191fc <net_conn_register+0x3ec>
		    remote_addr->sa_family == AF_INET6) {
40019124:	0004d783          	lhu	a5,0(s1)
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
40019128:	00200713          	li	a4,2
4001912c:	06e79063          	bne	a5,a4,4001918c <net_conn_register+0x37c>
			memcpy(&conn->remote_addr, remote_addr,
40019130:	01800613          	li	a2,24
40019134:	00048593          	mv	a1,s1
40019138:	004d8513          	addi	a0,s11,4
4001913c:	bbdf30ef          	jal	ra,4000ccf8 <memcpy>
			if (!net_ipv6_is_addr_unspecified(
40019140:	00448513          	addi	a0,s1,4
40019144:	a0dff0ef          	jal	ra,40018b50 <net_ipv6_is_addr_unspecified>
40019148:	00154d13          	xori	s10,a0,1
4001914c:	005d1d13          	slli	s10,s10,0x5
40019150:	0ffd7d13          	zext.b	s10,s10
		flags |= NET_CONN_REMOTE_ADDR_SET;
40019154:	002d6d13          	ori	s10,s10,2
	if (local_addr) {
40019158:	12090263          	beqz	s2,4001927c <net_conn_register+0x46c>
		    local_addr->sa_family == AF_INET6) {
4001915c:	00095783          	lhu	a5,0(s2)
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
40019160:	00200713          	li	a4,2
40019164:	0ae79063          	bne	a5,a4,40019204 <net_conn_register+0x3f4>
			memcpy(&conn->local_addr, local_addr,
40019168:	01800613          	li	a2,24
4001916c:	00090593          	mv	a1,s2
40019170:	01cd8513          	addi	a0,s11,28
40019174:	b85f30ef          	jal	ra,4000ccf8 <memcpy>
			if (!net_ipv6_is_addr_unspecified(
40019178:	00490513          	addi	a0,s2,4
4001917c:	9d5ff0ef          	jal	ra,40018b50 <net_ipv6_is_addr_unspecified>
40019180:	0a051263          	bnez	a0,40019224 <net_conn_register+0x414>
				flags |= NET_CONN_LOCAL_ADDR_SPEC;
40019184:	040d6d13          	ori	s10,s10,64
40019188:	09c0006f          	j	40019224 <net_conn_register+0x414>
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
4001918c:	00100693          	li	a3,1
40019190:	02d79263          	bne	a5,a3,400191b4 <net_conn_register+0x3a4>
			memcpy(&conn->remote_addr, remote_addr,
40019194:	00800613          	li	a2,8
40019198:	00048593          	mv	a1,s1
4001919c:	004d8513          	addi	a0,s11,4
400191a0:	b59f30ef          	jal	ra,4000ccf8 <memcpy>
			if (net_sin(remote_addr)->sin_addr.s_addr) {
400191a4:	0044ad03          	lw	s10,4(s1)
400191a8:	01a03d33          	snez	s10,s10
400191ac:	005d1d13          	slli	s10,s10,0x5
400191b0:	fa5ff06f          	j	40019154 <net_conn_register+0x344>
			NET_ERR("Remote address family not set");
400191b4:	40044537          	lui	a0,0x40044
400191b8:	75452783          	lw	a5,1876(a0) # 40044754 <log_dynamic_net_conn>
400191bc:	0077f793          	andi	a5,a5,7
400191c0:	02078663          	beqz	a5,400191ec <net_conn_register+0x3dc>
400191c4:	400357b7          	lui	a5,0x40035
400191c8:	f0878793          	addi	a5,a5,-248 # 40034f08 <in6addr_any+0x25c>
			NET_ERR("Local address family not set");
400191cc:	faf42e23          	sw	a5,-68(s0)
400191d0:	fae42c23          	sw	a4,-72(s0)
400191d4:	000015b7          	lui	a1,0x1
400191d8:	00000693          	li	a3,0
400191dc:	fb840613          	addi	a2,s0,-72
400191e0:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
400191e4:	75450513          	addi	a0,a0,1876
400191e8:	dadeb0ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
	conn_set_unused(conn);
400191ec:	000d8513          	mv	a0,s11
400191f0:	bc9ff0ef          	jal	ra,40018db8 <conn_set_unused>
	return -EINVAL;
400191f4:	fea00513          	li	a0,-22
400191f8:	e21ff06f          	j	40019018 <net_conn_register+0x208>
	uint8_t flags = 0U;
400191fc:	00000d13          	li	s10,0
40019200:	f59ff06f          	j	40019158 <net_conn_register+0x348>
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40019204:	00100693          	li	a3,1
40019208:	04d79c63          	bne	a5,a3,40019260 <net_conn_register+0x450>
			memcpy(&conn->local_addr, local_addr,
4001920c:	00800613          	li	a2,8
40019210:	00090593          	mv	a1,s2
40019214:	01cd8513          	addi	a0,s11,28
40019218:	ae1f30ef          	jal	ra,4000ccf8 <memcpy>
			if (net_sin(local_addr)->sin_addr.s_addr) {
4001921c:	00492783          	lw	a5,4(s2)
40019220:	f60792e3          	bnez	a5,40019184 <net_conn_register+0x374>
		flags |= NET_CONN_LOCAL_ADDR_SET;
40019224:	004d6d13          	ori	s10,s10,4
	if (remote_addr && local_addr) {
40019228:	04048a63          	beqz	s1,4001927c <net_conn_register+0x46c>
		if (remote_addr->sa_family != local_addr->sa_family) {
4001922c:	0004d703          	lhu	a4,0(s1)
40019230:	00095783          	lhu	a5,0(s2)
40019234:	04f70463          	beq	a4,a5,4001927c <net_conn_register+0x46c>
			NET_ERR("Address families different");
40019238:	40044537          	lui	a0,0x40044
4001923c:	75452783          	lw	a5,1876(a0) # 40044754 <log_dynamic_net_conn>
40019240:	0077f793          	andi	a5,a5,7
40019244:	fa0784e3          	beqz	a5,400191ec <net_conn_register+0x3dc>
40019248:	400357b7          	lui	a5,0x40035
4001924c:	f4878793          	addi	a5,a5,-184 # 40034f48 <in6addr_any+0x29c>
40019250:	faf42e23          	sw	a5,-68(s0)
40019254:	00200793          	li	a5,2
40019258:	faf42c23          	sw	a5,-72(s0)
4001925c:	f79ff06f          	j	400191d4 <net_conn_register+0x3c4>
			NET_ERR("Local address family not set");
40019260:	40044537          	lui	a0,0x40044
40019264:	75452783          	lw	a5,1876(a0) # 40044754 <log_dynamic_net_conn>
40019268:	0077f793          	andi	a5,a5,7
4001926c:	f80780e3          	beqz	a5,400191ec <net_conn_register+0x3dc>
40019270:	400357b7          	lui	a5,0x40035
40019274:	f2878793          	addi	a5,a5,-216 # 40034f28 <in6addr_any+0x27c>
40019278:	f55ff06f          	j	400191cc <net_conn_register+0x3bc>
	if (remote_port) {
4001927c:	000a0c63          	beqz	s4,40019294 <net_conn_register+0x484>
		net_sin(&conn->remote_addr)->sin_port = htons(remote_port);
40019280:	008a1793          	slli	a5,s4,0x8
40019284:	008a5a13          	srli	s4,s4,0x8
40019288:	0147e7b3          	or	a5,a5,s4
		flags |= NET_CONN_REMOTE_PORT_SPEC;
4001928c:	008d6d13          	ori	s10,s10,8
		net_sin(&conn->remote_addr)->sin_port = htons(remote_port);
40019290:	00fd9323          	sh	a5,6(s11)
	if (local_port) {
40019294:	00098c63          	beqz	s3,400192ac <net_conn_register+0x49c>
		net_sin(&conn->local_addr)->sin_port = htons(local_port);
40019298:	00899793          	slli	a5,s3,0x8
4001929c:	0089d993          	srli	s3,s3,0x8
400192a0:	0137e7b3          	or	a5,a5,s3
		flags |= NET_CONN_LOCAL_PORT_SPEC;
400192a4:	010d6d13          	ori	s10,s10,16
		net_sin(&conn->local_addr)->sin_port = htons(local_port);
400192a8:	00fd9f23          	sh	a5,30(s11)
	conn->cb = cb;
400192ac:	f9842783          	lw	a5,-104(s0)
	conn->flags = flags;
400192b0:	05ad81a3          	sb	s10,67(s11)
	conn->proto = proto;
400192b4:	057d9023          	sh	s7,64(s11)
	conn->cb = cb;
400192b8:	02fdaa23          	sw	a5,52(s11)
	conn->user_data = user_data;
400192bc:	00042783          	lw	a5,0(s0)
	conn->family = family;
400192c0:	056d8123          	sb	s6,66(s11)
	conn->user_data = user_data;
400192c4:	02fdae23          	sw	a5,60(s11)
	conn->context = context;
400192c8:	f9c42783          	lw	a5,-100(s0)
400192cc:	02fdac23          	sw	a5,56(s11)
	if (handle) {
400192d0:	00442783          	lw	a5,4(s0)
400192d4:	00078463          	beqz	a5,400192dc <net_conn_register+0x4cc>
		*handle = (struct net_conn_handle *)conn;
400192d8:	01b7a023          	sw	s11,0(a5)
	conn->flags |= NET_CONN_IN_USE;
400192dc:	043dc783          	lbu	a5,67(s11)
	k_mutex_lock(&conn_lock, K_FOREVER);
400192e0:	fff00513          	li	a0,-1
400192e4:	fff00593          	li	a1,-1
	conn->flags |= NET_CONN_IN_USE;
400192e8:	0017e793          	ori	a5,a5,1
400192ec:	04fd81a3          	sb	a5,67(s11)
	k_mutex_lock(&conn_lock, K_FOREVER);
400192f0:	aa9ff0ef          	jal	ra,40018d98 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
400192f4:	000aa783          	lw	a5,0(s5)
	parent->next = child;
400192f8:	00fda023          	sw	a5,0(s11)
Z_GENLIST_PREPEND(slist, snode)
400192fc:	004aa783          	lw	a5,4(s5)
	list->head = node;
40019300:	01baa023          	sw	s11,0(s5)
Z_GENLIST_PREPEND(slist, snode)
40019304:	00079463          	bnez	a5,4001930c <net_conn_register+0x4fc>
	list->tail = node;
40019308:	01baa223          	sw	s11,4(s5)
	k_mutex_unlock(&conn_lock);
4001930c:	aa1ff0ef          	jal	ra,40018dac <k_mutex_unlock.constprop.0.isra.0>
	return 0;
40019310:	00000513          	li	a0,0
}
40019314:	d05ff06f          	j	40019018 <net_conn_register+0x208>

40019318 <net_conn_unregister>:
	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
40019318:	4003b7b7          	lui	a5,0x4003b
4001931c:	c3878793          	addi	a5,a5,-968 # 4003ac38 <conns>
40019320:	0af56a63          	bltu	a0,a5,400193d4 <net_conn_unregister+0xbc>
{
40019324:	ff010113          	addi	sp,sp,-16
	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
40019328:	4003b7b7          	lui	a5,0x4003b
{
4001932c:	00812423          	sw	s0,8(sp)
40019330:	00112623          	sw	ra,12(sp)
40019334:	00050413          	mv	s0,a0
	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
40019338:	e5878793          	addi	a5,a5,-424 # 4003ae58 <net_neighbor_lladdr>
		return -EINVAL;
4001933c:	fea00513          	li	a0,-22
	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
40019340:	0687e263          	bltu	a5,s0,400193a4 <net_conn_unregister+0x8c>
	if (!(conn->flags & NET_CONN_IN_USE)) {
40019344:	04344783          	lbu	a5,67(s0)
		return -ENOENT;
40019348:	ffe00513          	li	a0,-2
	if (!(conn->flags & NET_CONN_IN_USE)) {
4001934c:	0017f793          	andi	a5,a5,1
40019350:	04078a63          	beqz	a5,400193a4 <net_conn_unregister+0x8c>
	k_mutex_lock(&conn_lock, K_FOREVER);
40019354:	fff00513          	li	a0,-1
40019358:	fff00593          	li	a1,-1
4001935c:	a3dff0ef          	jal	ra,40018d98 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
40019360:	400397b7          	lui	a5,0x40039
40019364:	08c7a703          	lw	a4,140(a5) # 4003908c <conn_used>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40019368:	00000693          	li	a3,0
4001936c:	08c78793          	addi	a5,a5,140
40019370:	02070263          	beqz	a4,40019394 <net_conn_unregister+0x7c>
40019374:	04e41a63          	bne	s0,a4,400193c8 <net_conn_unregister+0xb0>
	return node->next;
40019378:	00042703          	lw	a4,0(s0)
Z_GENLIST_REMOVE(slist, snode)
4001937c:	02069c63          	bnez	a3,400193b4 <net_conn_unregister+0x9c>
40019380:	0047a683          	lw	a3,4(a5)
	list->head = node;
40019384:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_REMOVE(slist, snode)
40019388:	00d41463          	bne	s0,a3,40019390 <net_conn_unregister+0x78>
	list->tail = node;
4001938c:	00e7a223          	sw	a4,4(a5)
	parent->next = child;
40019390:	00042023          	sw	zero,0(s0)
	k_mutex_unlock(&conn_lock);
40019394:	a19ff0ef          	jal	ra,40018dac <k_mutex_unlock.constprop.0.isra.0>
	conn_set_unused(conn);
40019398:	00040513          	mv	a0,s0
4001939c:	a1dff0ef          	jal	ra,40018db8 <conn_set_unused>
	return 0;
400193a0:	00000513          	li	a0,0
}
400193a4:	00c12083          	lw	ra,12(sp)
400193a8:	00812403          	lw	s0,8(sp)
400193ac:	01010113          	addi	sp,sp,16
400193b0:	00008067          	ret
400193b4:	00e6a023          	sw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
400193b8:	0047a703          	lw	a4,4(a5)
400193bc:	fce41ae3          	bne	s0,a4,40019390 <net_conn_unregister+0x78>
	list->tail = node;
400193c0:	00d7a223          	sw	a3,4(a5)
}
400193c4:	fcdff06f          	j	40019390 <net_conn_unregister+0x78>
	return node->next;
400193c8:	00070693          	mv	a3,a4
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
400193cc:	00072703          	lw	a4,0(a4)
400193d0:	fa1ff06f          	j	40019370 <net_conn_unregister+0x58>
		return -EINVAL;
400193d4:	fea00513          	li	a0,-22
}
400193d8:	00008067          	ret

400193dc <net_conn_input>:

enum net_verdict net_conn_input(struct net_pkt *pkt,
				union net_ip_header *ip_hdr,
				uint8_t proto,
				union net_proto_header *proto_hdr)
{
400193dc:	fb010113          	addi	sp,sp,-80
400193e0:	04112623          	sw	ra,76(sp)
400193e4:	04812423          	sw	s0,72(sp)
400193e8:	04912223          	sw	s1,68(sp)
400193ec:	05212023          	sw	s2,64(sp)
400193f0:	03312e23          	sw	s3,60(sp)
400193f4:	03412c23          	sw	s4,56(sp)
400193f8:	03512a23          	sw	s5,52(sp)
400193fc:	03612823          	sw	s6,48(sp)
40019400:	03712623          	sw	s7,44(sp)
40019404:	03812423          	sw	s8,40(sp)
40019408:	03912223          	sw	s9,36(sp)
4001940c:	03a12023          	sw	s10,32(sp)
40019410:	01b12e23          	sw	s11,28(sp)
40019414:	03452c83          	lw	s9,52(a0)
	return pkt->iface;
40019418:	01852783          	lw	a5,24(a0)
	struct net_if *pkt_iface = net_pkt_iface(pkt);
	uint8_t pkt_family = net_pkt_family(pkt);
	uint16_t src_port = 0U, dst_port = 0U;

	if (IS_ENABLED(CONFIG_NET_IP) && (pkt_family == AF_INET || pkt_family == AF_INET6)) {
4001941c:	00100713          	li	a4,1
	return pkt->family;
40019420:	01dcdc93          	srli	s9,s9,0x1d
	return pkt->iface;
40019424:	00f12023          	sw	a5,0(sp)
40019428:	fffc8793          	addi	a5,s9,-1
4001942c:	0ff7f793          	zext.b	a5,a5
40019430:	12f76a63          	bltu	a4,a5,40019564 <net_conn_input+0x188>
		if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
40019434:	01100793          	li	a5,17
40019438:	00050913          	mv	s2,a0
4001943c:	00058993          	mv	s3,a1
40019440:	00060a13          	mv	s4,a2
40019444:	00068c13          	mv	s8,a3
40019448:	10f61663          	bne	a2,a5,40019554 <net_conn_input+0x178>
			src_port = proto_hdr->udp->src_port;
4001944c:	0006a783          	lw	a5,0(a3)
			dst_port = proto_hdr->udp->dst_port;
		} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
			if (proto_hdr->tcp == NULL) {
				return NET_DROP;
			}
			src_port = proto_hdr->tcp->src_port;
40019450:	0017c483          	lbu	s1,1(a5)
40019454:	0007c703          	lbu	a4,0(a5)
			dst_port = proto_hdr->tcp->dst_port;
40019458:	0037c403          	lbu	s0,3(a5)
			src_port = proto_hdr->tcp->src_port;
4001945c:	00849493          	slli	s1,s1,0x8
40019460:	00e4e4b3          	or	s1,s1,a4
			dst_port = proto_hdr->tcp->dst_port;
40019464:	0027c703          	lbu	a4,2(a5)
40019468:	00841413          	slli	s0,s0,0x8
4001946c:	00e46433          	or	s0,s0,a4
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40019470:	00100793          	li	a5,1
			(struct in_addr *)ip_hdr->ipv4->src);
40019474:	0009aa83          	lw	s5,0(s3)
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40019478:	10fc9063          	bne	s9,a5,40019578 <net_conn_input+0x19c>
			(struct in_addr *)ip_hdr->ipv4->src);
4001947c:	00ca8b13          	addi	s6,s5,12
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
40019480:	00000593          	li	a1,0
40019484:	000b0513          	mv	a0,s6
40019488:	e29f90ef          	jal	ra,400132b0 <net_if_ipv4_addr_lookup>
	if (!ret) {
4001948c:	0c051063          	bnez	a0,4001954c <net_conn_input+0x170>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
40019490:	f6dfb0ef          	jal	ra,400153fc <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40019494:	00dac703          	lbu	a4,13(s5)
40019498:	00cac783          	lbu	a5,12(s5)
4001949c:	00054683          	lbu	a3,0(a0)
400194a0:	00871713          	slli	a4,a4,0x8
400194a4:	00f76733          	or	a4,a4,a5
400194a8:	00eac783          	lbu	a5,14(s5)
400194ac:	01079793          	slli	a5,a5,0x10
400194b0:	00e7e7b3          	or	a5,a5,a4
400194b4:	00fac703          	lbu	a4,15(s5)
400194b8:	01871713          	slli	a4,a4,0x18
400194bc:	00f76733          	or	a4,a4,a5
400194c0:	00154783          	lbu	a5,1(a0)
400194c4:	00879793          	slli	a5,a5,0x8
400194c8:	00d7e7b3          	or	a5,a5,a3
400194cc:	00254683          	lbu	a3,2(a0)
400194d0:	01069693          	slli	a3,a3,0x10
400194d4:	00f6e6b3          	or	a3,a3,a5
400194d8:	00354783          	lbu	a5,3(a0)
400194dc:	01879793          	slli	a5,a5,0x18
400194e0:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
400194e4:	06f70463          	beq	a4,a5,4001954c <net_conn_input+0x170>
	return net_if_ipv4_is_addr_bcast(iface, addr);
400194e8:	000b0593          	mv	a1,s6
400194ec:	00000513          	li	a0,0
400194f0:	b85f90ef          	jal	ra,40013074 <net_if_ipv4_is_addr_bcast>
			ip_hdr->ipv4->src, ip_hdr->ipv4->dst);
400194f4:	0009a783          	lw	a5,0(s3)
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
400194f8:	00d7c703          	lbu	a4,13(a5)
400194fc:	00c7c683          	lbu	a3,12(a5)
40019500:	0117c603          	lbu	a2,17(a5)
40019504:	00871713          	slli	a4,a4,0x8
40019508:	00d76733          	or	a4,a4,a3
4001950c:	00e7c683          	lbu	a3,14(a5)
40019510:	00861613          	slli	a2,a2,0x8
40019514:	01069693          	slli	a3,a3,0x10
40019518:	00e6e6b3          	or	a3,a3,a4
4001951c:	00f7c703          	lbu	a4,15(a5)
40019520:	01871713          	slli	a4,a4,0x18
40019524:	00d76733          	or	a4,a4,a3
40019528:	0107c683          	lbu	a3,16(a5)
4001952c:	00d66633          	or	a2,a2,a3
40019530:	0127c683          	lbu	a3,18(a5)
40019534:	0137c783          	lbu	a5,19(a5)
40019538:	01069693          	slli	a3,a3,0x10
4001953c:	00c6e6b3          	or	a3,a3,a2
40019540:	01879793          	slli	a5,a5,0x18
40019544:	00d7e7b3          	or	a5,a5,a3
		(is_same_src_and_dst_addr || is_my_src_addr) && is_same_src_and_dst_port;
40019548:	06f71063          	bne	a4,a5,400195a8 <net_conn_input+0x1cc>
4001954c:	06849063          	bne	s1,s0,400195ac <net_conn_input+0x1d0>
40019550:	0140006f          	j	40019564 <net_conn_input+0x188>
		} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
40019554:	00600793          	li	a5,6
40019558:	00f61a63          	bne	a2,a5,4001956c <net_conn_input+0x190>
			if (proto_hdr->tcp == NULL) {
4001955c:	0006a783          	lw	a5,0(a3)
40019560:	ee0798e3          	bnez	a5,40019450 <net_conn_input+0x74>
				return NET_DROP;
40019564:	00200513          	li	a0,2
40019568:	0cc0006f          	j	40019634 <net_conn_input+0x258>
	uint16_t src_port = 0U, dst_port = 0U;
4001956c:	00000413          	li	s0,0
40019570:	00000493          	li	s1,0
40019574:	efdff06f          	j	40019470 <net_conn_input+0x94>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
40019578:	00000593          	li	a1,0
4001957c:	008a8513          	addi	a0,s5,8
40019580:	b31f70ef          	jal	ra,400110b0 <net_if_ipv6_addr_lookup>
40019584:	00050a93          	mv	s5,a0
			ip_hdr->ipv6->src, ip_hdr->ipv6->dst);
40019588:	0009a503          	lw	a0,0(s3)
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4001958c:	01000613          	li	a2,16
40019590:	01850593          	addi	a1,a0,24
40019594:	00850513          	addi	a0,a0,8
40019598:	ee0f30ef          	jal	ra,4000cc78 <memcmp>
		(is_same_src_and_dst_addr || is_my_src_addr) && is_same_src_and_dst_port;
4001959c:	04051263          	bnez	a0,400195e0 <net_conn_input+0x204>
400195a0:	04849263          	bne	s1,s0,400195e4 <net_conn_input+0x208>
400195a4:	fc1ff06f          	j	40019564 <net_conn_input+0x188>
400195a8:	fa0512e3          	bnez	a0,4001954c <net_conn_input+0x170>
	if (IS_ENABLED(CONFIG_NET_IP)) {
		/* If we receive a packet with multicast destination address, we might
		 * need to deliver the packet to multiple recipients.
		 */
		if (IS_ENABLED(CONFIG_NET_IPV4) && pkt_family == AF_INET) {
			if (net_ipv4_is_addr_mcast((struct in_addr *)ip_hdr->ipv4->dst)) {
400195ac:	0009a583          	lw	a1,0(s3)
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
400195b0:	f0000737          	lui	a4,0xf0000
400195b4:	0105c783          	lbu	a5,16(a1)
400195b8:	01879793          	slli	a5,a5,0x18
400195bc:	00e7f7b3          	and	a5,a5,a4
400195c0:	e0000737          	lui	a4,0xe0000
400195c4:	0ae78663          	beq	a5,a4,40019670 <net_conn_input+0x294>
				is_mcast_pkt = true;
			} else if (net_if_ipv4_is_addr_bcast(pkt_iface,
400195c8:	00012503          	lw	a0,0(sp)
400195cc:	01058593          	addi	a1,a1,16
	bool is_mcast_pkt = false;
400195d0:	00000a93          	li	s5,0
			} else if (net_if_ipv4_is_addr_bcast(pkt_iface,
400195d4:	aa1f90ef          	jal	ra,40013074 <net_if_ipv4_is_addr_bcast>
400195d8:	00050d13          	mv	s10,a0
400195dc:	01c0006f          	j	400195f8 <net_conn_input+0x21c>
		(is_same_src_and_dst_addr || is_my_src_addr) && is_same_src_and_dst_port;
400195e0:	fc0a90e3          	bnez	s5,400195a0 <net_conn_input+0x1c4>
							     (struct in_addr *)ip_hdr->ipv4->dst)) {
				is_bcast_pkt = true;
			}
		} else if (IS_ENABLED(CONFIG_NET_IPV6) && pkt_family == AF_INET6) {
			is_mcast_pkt = net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->ipv6->dst);
400195e4:	0009a783          	lw	a5,0(s3)
	bool is_bcast_pkt = false;
400195e8:	00000d13          	li	s10,0
	return addr->s6_addr[0] == 0xFF;
400195ec:	0187ca83          	lbu	s5,24(a5)
400195f0:	f01a8a93          	addi	s5,s5,-255
400195f4:	001aba93          	seqz	s5,s5
	return list->head;
400195f8:	400397b7          	lui	a5,0x40039
400195fc:	08c7ab83          	lw	s7,140(a5) # 4003908c <conn_used>
		}
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {
		/* Is the candidate connection matching the packet's interface? */
		if (conn->context != NULL &&
40019600:	00001737          	lui	a4,0x1
40019604:	fff00793          	li	a5,-1
40019608:	00f12223          	sw	a5,4(sp)
4001960c:	80070793          	addi	a5,a4,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
40019610:	00000d93          	li	s11,0
40019614:	00000b13          	li	s6,0
40019618:	00f12423          	sw	a5,8(sp)
	SYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {
4001961c:	060b9063          	bnez	s7,4001967c <net_conn_input+0x2a0>
			net_pkt_unref(pkt);
			return NET_OK;
		}
	}

	if (IS_ENABLED(CONFIG_NET_IP) && is_mcast_pkt && mcast_pkt_delivered) {
40019620:	1c0a8263          	beqz	s5,400197e4 <net_conn_input+0x408>
40019624:	1a0d8663          	beqz	s11,400197d0 <net_conn_input+0x3f4>
		/* As one or more multicast packets
		 * have already been delivered in the loop above,
		 * we shall not call the callback again here.
		 */
		net_pkt_unref(pkt);
40019628:	00090513          	mv	a0,s2
4001962c:	9f0fe0ef          	jal	ra,4001781c <net_pkt_unref>
			goto drop;
		}

		net_stats_update_per_proto_recv(pkt_iface, proto);

		return NET_OK;
40019630:	00000513          	li	a0,0

drop:
	net_stats_update_per_proto_drop(pkt_iface, proto);

	return NET_DROP;
}
40019634:	04c12083          	lw	ra,76(sp)
40019638:	04812403          	lw	s0,72(sp)
4001963c:	04412483          	lw	s1,68(sp)
40019640:	04012903          	lw	s2,64(sp)
40019644:	03c12983          	lw	s3,60(sp)
40019648:	03812a03          	lw	s4,56(sp)
4001964c:	03412a83          	lw	s5,52(sp)
40019650:	03012b03          	lw	s6,48(sp)
40019654:	02c12b83          	lw	s7,44(sp)
40019658:	02812c03          	lw	s8,40(sp)
4001965c:	02412c83          	lw	s9,36(sp)
40019660:	02012d03          	lw	s10,32(sp)
40019664:	01c12d83          	lw	s11,28(sp)
40019668:	05010113          	addi	sp,sp,80
4001966c:	00008067          	ret
	bool is_bcast_pkt = false;
40019670:	00000d13          	li	s10,0
				is_mcast_pkt = true;
40019674:	00100a93          	li	s5,1
40019678:	f81ff06f          	j	400195f8 <net_conn_input+0x21c>
		if (conn->context != NULL &&
4001967c:	038ba703          	lw	a4,56(s7)
40019680:	08071463          	bnez	a4,40019708 <net_conn_input+0x32c>
		if (conn->family != AF_UNSPEC &&
40019684:	042bc703          	lbu	a4,66(s7)
40019688:	0a071863          	bnez	a4,40019738 <net_conn_input+0x35c>
		if (conn->proto != proto) {
4001968c:	040bd703          	lhu	a4,64(s7)
40019690:	0b471063          	bne	a4,s4,40019730 <net_conn_input+0x354>
			if (net_sin(&conn->remote_addr)->sin_port &&
40019694:	006bd703          	lhu	a4,6(s7)
40019698:	00070463          	beqz	a4,400196a0 <net_conn_input+0x2c4>
4001969c:	08971a63          	bne	a4,s1,40019730 <net_conn_input+0x354>
			if (net_sin(&conn->local_addr)->sin_port &&
400196a0:	01ebd703          	lhu	a4,30(s7)
400196a4:	00070463          	beqz	a4,400196ac <net_conn_input+0x2d0>
400196a8:	08871463          	bne	a4,s0,40019730 <net_conn_input+0x354>
			if ((conn->flags & NET_CONN_REMOTE_ADDR_SET) &&
400196ac:	043bc703          	lbu	a4,67(s7)
400196b0:	00277713          	andi	a4,a4,2
400196b4:	08071663          	bnez	a4,40019740 <net_conn_input+0x364>
			if ((conn->flags & NET_CONN_LOCAL_ADDR_SET) &&
400196b8:	043bc703          	lbu	a4,67(s7)
400196bc:	00477713          	andi	a4,a4,4
400196c0:	00070e63          	beqz	a4,400196dc <net_conn_input+0x300>
			    !conn_addr_cmp(pkt, ip_hdr, &conn->local_addr, false)) {
400196c4:	00000693          	li	a3,0
400196c8:	01cb8613          	addi	a2,s7,28
400196cc:	00098593          	mv	a1,s3
400196d0:	00090513          	mv	a0,s2
400196d4:	df0ff0ef          	jal	ra,40018cc4 <conn_addr_cmp>
			if ((conn->flags & NET_CONN_LOCAL_ADDR_SET) &&
400196d8:	04050c63          	beqz	a0,40019730 <net_conn_input+0x354>
			if (best_match != NULL && best_match->flags & NET_CONN_REMOTE_PORT_SPEC) {
400196dc:	080b1063          	bnez	s6,4001975c <net_conn_input+0x380>
			if (best_rank < NET_CONN_RANK(conn->flags)) {
400196e0:	043bc703          	lbu	a4,67(s7)
400196e4:	00412783          	lw	a5,4(sp)
400196e8:	07877713          	andi	a4,a4,120
400196ec:	04e7d263          	bge	a5,a4,40019730 <net_conn_input+0x354>
				if (!is_mcast_pkt) {
400196f0:	060a9e63          	bnez	s5,4001976c <net_conn_input+0x390>
					best_rank = NET_CONN_RANK(conn->flags);
400196f4:	01071793          	slli	a5,a4,0x10
400196f8:	4107d793          	srai	a5,a5,0x10
400196fc:	00f12223          	sw	a5,4(sp)
					continue; /* found a match - but maybe not yet the best */
40019700:	000b8b13          	mv	s6,s7
40019704:	02c0006f          	j	40019730 <net_conn_input+0x354>
		if (conn->context != NULL &&
40019708:	07475683          	lhu	a3,116(a4)
4001970c:	00812783          	lw	a5,8(sp)
40019710:	00f6f6b3          	and	a3,a3,a5
40019714:	f60688e3          	beqz	a3,40019684 <net_conn_input+0x2a8>
40019718:	01892683          	lw	a3,24(s2)
	return net_if_get_by_index(context->iface);
4001971c:	07670503          	lb	a0,118(a4)
40019720:	00d12623          	sw	a3,12(sp)
40019724:	c08f70ef          	jal	ra,40010b2c <z_impl_net_if_get_by_index>
		    net_context_is_bound_to_iface(conn->context) &&
40019728:	00c12683          	lw	a3,12(sp)
4001972c:	f4a68ce3          	beq	a3,a0,40019684 <net_conn_input+0x2a8>
	return node->next;
40019730:	000bab83          	lw	s7,0(s7)
40019734:	ee9ff06f          	j	4001961c <net_conn_input+0x240>
		if (conn->family != AF_UNSPEC &&
40019738:	f5970ae3          	beq	a4,s9,4001968c <net_conn_input+0x2b0>
4001973c:	ff5ff06f          	j	40019730 <net_conn_input+0x354>
			    !conn_addr_cmp(pkt, ip_hdr, &conn->remote_addr, true)) {
40019740:	00100693          	li	a3,1
40019744:	004b8613          	addi	a2,s7,4
40019748:	00098593          	mv	a1,s3
4001974c:	00090513          	mv	a0,s2
40019750:	d74ff0ef          	jal	ra,40018cc4 <conn_addr_cmp>
			if ((conn->flags & NET_CONN_REMOTE_ADDR_SET) &&
40019754:	f60512e3          	bnez	a0,400196b8 <net_conn_input+0x2dc>
40019758:	fd9ff06f          	j	40019730 <net_conn_input+0x354>
			if (best_match != NULL && best_match->flags & NET_CONN_REMOTE_PORT_SPEC) {
4001975c:	043b4703          	lbu	a4,67(s6)
40019760:	00877713          	andi	a4,a4,8
40019764:	f6070ee3          	beqz	a4,400196e0 <net_conn_input+0x304>
40019768:	fc9ff06f          	j	40019730 <net_conn_input+0x354>
				mcast_pkt = net_pkt_clone(pkt, CLONE_TIMEOUT);
4001976c:	00a00593          	li	a1,10
40019770:	00000613          	li	a2,0
40019774:	00090513          	mv	a0,s2
40019778:	864ff0ef          	jal	ra,400187dc <net_pkt_clone>
4001977c:	00050d93          	mv	s11,a0
				if (!mcast_pkt) {
40019780:	04050a63          	beqz	a0,400197d4 <net_conn_input+0x3f8>
				if (conn->cb(conn, mcast_pkt, ip_hdr, proto_hdr, conn->user_data) ==
40019784:	03cba703          	lw	a4,60(s7)
40019788:	034ba803          	lw	a6,52(s7)
4001978c:	00050593          	mv	a1,a0
40019790:	000c0693          	mv	a3,s8
40019794:	00098613          	mv	a2,s3
40019798:	000b8513          	mv	a0,s7
4001979c:	000800e7          	jalr	a6
400197a0:	00200713          	li	a4,2
					net_stats_update_per_proto_drop(pkt_iface, proto);
400197a4:	000a0593          	mv	a1,s4
				if (conn->cb(conn, mcast_pkt, ip_hdr, proto_hdr, conn->user_data) ==
400197a8:	00e51e63          	bne	a0,a4,400197c4 <net_conn_input+0x3e8>
					net_stats_update_per_proto_drop(pkt_iface, proto);
400197ac:	00012503          	lw	a0,0(sp)
400197b0:	cbcff0ef          	jal	ra,40018c6c <net_stats_update_per_proto_drop>
					net_pkt_unref(mcast_pkt);
400197b4:	000d8513          	mv	a0,s11
400197b8:	864fe0ef          	jal	ra,4001781c <net_pkt_unref>
				mcast_pkt_delivered = true;
400197bc:	000a8d93          	mv	s11,s5
400197c0:	f71ff06f          	j	40019730 <net_conn_input+0x354>
					net_stats_update_per_proto_recv(pkt_iface, proto);
400197c4:	00012503          	lw	a0,0(sp)
400197c8:	c4cff0ef          	jal	ra,40018c14 <net_stats_update_per_proto_recv>
400197cc:	ff1ff06f          	j	400197bc <net_conn_input+0x3e0>
	if (best_match) {
400197d0:	000b1c63          	bnez	s6,400197e8 <net_conn_input+0x40c>
	net_stats_update_per_proto_drop(pkt_iface, proto);
400197d4:	00012503          	lw	a0,0(sp)
400197d8:	000a0593          	mv	a1,s4
400197dc:	c90ff0ef          	jal	ra,40018c6c <net_stats_update_per_proto_drop>
	return NET_DROP;
400197e0:	d85ff06f          	j	40019564 <net_conn_input+0x188>
	if (best_match) {
400197e4:	020b0c63          	beqz	s6,4001981c <net_conn_input+0x440>
		if (best_match->cb(best_match, pkt, ip_hdr, proto_hdr, best_match->user_data)
400197e8:	034b2783          	lw	a5,52(s6)
400197ec:	03cb2703          	lw	a4,60(s6)
400197f0:	000c0693          	mv	a3,s8
400197f4:	00098613          	mv	a2,s3
400197f8:	00090593          	mv	a1,s2
400197fc:	000b0513          	mv	a0,s6
40019800:	000780e7          	jalr	a5
40019804:	00200793          	li	a5,2
40019808:	fcf506e3          	beq	a0,a5,400197d4 <net_conn_input+0x3f8>
		net_stats_update_per_proto_recv(pkt_iface, proto);
4001980c:	00012503          	lw	a0,0(sp)
40019810:	000a0593          	mv	a1,s4
40019814:	c00ff0ef          	jal	ra,40018c14 <net_stats_update_per_proto_recv>
		return NET_OK;
40019818:	e19ff06f          	j	40019630 <net_conn_input+0x254>
	    !(is_mcast_pkt || is_bcast_pkt)) {
4001981c:	fa0d1ce3          	bnez	s10,400197d4 <net_conn_input+0x3f8>
	return pkt->family;
40019820:	03492783          	lw	a5,52(s2)
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
40019824:	00200713          	li	a4,2
40019828:	01d7d793          	srli	a5,a5,0x1d
4001982c:	04e79663          	bne	a5,a4,40019878 <net_conn_input+0x49c>
		net_icmpv6_send_error(pkt, NET_ICMPV6_DST_UNREACH,
40019830:	00000693          	li	a3,0
40019834:	00400613          	li	a2,4
40019838:	00100593          	li	a1,1
4001983c:	00090513          	mv	a0,s2
40019840:	414010ef          	jal	ra,4001ac54 <net_icmpv6_send_error>
		if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
40019844:	00600793          	li	a5,6
40019848:	f8fa16e3          	bne	s4,a5,400197d4 <net_conn_input+0x3f8>
	UPDATE_STAT(iface, stats.tcp.connrst++);
4001984c:	4003b7b7          	lui	a5,0x4003b
40019850:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40019854:	08c7a703          	lw	a4,140(a5)
40019858:	00170713          	addi	a4,a4,1
4001985c:	08e7a623          	sw	a4,140(a5)
40019860:	00012783          	lw	a5,0(sp)
40019864:	00012703          	lw	a4,0(sp)
40019868:	0907a783          	lw	a5,144(a5)
4001986c:	00178793          	addi	a5,a5,1
40019870:	08f72823          	sw	a5,144(a4)
}
40019874:	f61ff06f          	j	400197d4 <net_conn_input+0x3f8>
		net_icmpv4_send_error(pkt, NET_ICMPV4_DST_UNREACH,
40019878:	00300613          	li	a2,3
4001987c:	00300593          	li	a1,3
40019880:	00090513          	mv	a0,s2
40019884:	660000ef          	jal	ra,40019ee4 <net_icmpv4_send_error>
40019888:	fbdff06f          	j	40019844 <net_conn_input+0x468>

4001988c <net_conn_init>:
	list->head = NULL;
4001988c:	400397b7          	lui	a5,0x40039
40019890:	08c78793          	addi	a5,a5,140 # 4003908c <conn_used>
40019894:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
40019898:	0007a223          	sw	zero,4(a5)
	int i;

	sys_slist_init(&conn_unused);
	sys_slist_init(&conn_used);

	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
4001989c:	4003b7b7          	lui	a5,0x4003b
400198a0:	c3878713          	addi	a4,a5,-968 # 4003ac38 <conns>
		sys_slist_prepend(&conn_unused, &conns[i].node);
400198a4:	c3878693          	addi	a3,a5,-968
400198a8:	22070593          	addi	a1,a4,544
	return list->tail;
400198ac:	00000613          	li	a2,0
400198b0:	c3878793          	addi	a5,a5,-968
	parent->next = child;
400198b4:	00c6a023          	sw	a2,0(a3)
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
400198b8:	04470713          	addi	a4,a4,68
400198bc:	00b70863          	beq	a4,a1,400198cc <net_conn_init+0x40>
		sys_slist_prepend(&conn_unused, &conns[i].node);
400198c0:	00068613          	mv	a2,a3
400198c4:	00070693          	mv	a3,a4
400198c8:	fedff06f          	j	400198b4 <net_conn_init+0x28>
400198cc:	40039737          	lui	a4,0x40039
400198d0:	4003b6b7          	lui	a3,0x4003b
400198d4:	09470713          	addi	a4,a4,148 # 40039094 <conn_unused>
400198d8:	e1468693          	addi	a3,a3,-492 # 4003ae14 <conns+0x1dc>
400198dc:	00d72023          	sw	a3,0(a4)
400198e0:	00f72223          	sw	a5,4(a4)
	}
}
400198e4:	00008067          	ret

400198e8 <net_stats_update_icmp_drop>:
	UPDATE_STAT(iface, stats.icmp.drop++);
400198e8:	4003b7b7          	lui	a5,0x4003b
400198ec:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
400198f0:	04c7a703          	lw	a4,76(a5)
400198f4:	00170713          	addi	a4,a4,1
400198f8:	04e7a623          	sw	a4,76(a5)
400198fc:	05052783          	lw	a5,80(a0)
40019900:	00178793          	addi	a5,a5,1
40019904:	04f52823          	sw	a5,80(a0)
}
40019908:	00008067          	ret

4001990c <icmpv4_create>:
	struct net_pkt *reply;
	const struct in_addr *src;
};

static int icmpv4_create(struct net_pkt *pkt, uint8_t icmp_type, uint8_t icmp_code)
{
4001990c:	fe010113          	addi	sp,sp,-32
40019910:	01212823          	sw	s2,16(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
40019914:	00400793          	li	a5,4
{
40019918:	00058913          	mv	s2,a1
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
4001991c:	00810593          	addi	a1,sp,8
{
40019920:	00812c23          	sw	s0,24(sp)
40019924:	00912a23          	sw	s1,20(sp)
40019928:	00112e23          	sw	ra,28(sp)
4001992c:	00050413          	mv	s0,a0
40019930:	00060493          	mv	s1,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
40019934:	00012423          	sw	zero,8(sp)
40019938:	00f12623          	sw	a5,12(sp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
4001993c:	fadfe0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!icmp_hdr) {
40019940:	02050c63          	beqz	a0,40019978 <icmpv4_create+0x6c>
		return -ENOBUFS;
	}

	icmp_hdr->type   = icmp_type;
40019944:	01250023          	sb	s2,0(a0)
	icmp_hdr->code   = icmp_code;
40019948:	009500a3          	sb	s1,1(a0)
	icmp_hdr->chksum = 0U;
4001994c:	00050123          	sb	zero,2(a0)
40019950:	000501a3          	sb	zero,3(a0)

	return net_pkt_set_data(pkt, &icmpv4_access);
40019954:	00810593          	addi	a1,sp,8
40019958:	00040513          	mv	a0,s0
4001995c:	85cff0ef          	jal	ra,400189b8 <net_pkt_set_data>
}
40019960:	01c12083          	lw	ra,28(sp)
40019964:	01812403          	lw	s0,24(sp)
40019968:	01412483          	lw	s1,20(sp)
4001996c:	01012903          	lw	s2,16(sp)
40019970:	02010113          	addi	sp,sp,32
40019974:	00008067          	ret
		return -ENOBUFS;
40019978:	f9700513          	li	a0,-105
4001997c:	fe5ff06f          	j	40019960 <icmpv4_create+0x54>

40019980 <net_ipv4_is_addr_bcast>:
{
40019980:	fe010113          	addi	sp,sp,-32
40019984:	00812c23          	sw	s0,24(sp)
40019988:	00b12623          	sw	a1,12(sp)
4001998c:	00112e23          	sw	ra,28(sp)
40019990:	00050413          	mv	s0,a0
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
40019994:	a69fb0ef          	jal	ra,400153fc <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40019998:	00c12583          	lw	a1,12(sp)
4001999c:	00054683          	lbu	a3,0(a0)
400199a0:	0015c703          	lbu	a4,1(a1)
400199a4:	0005c783          	lbu	a5,0(a1)
400199a8:	00871713          	slli	a4,a4,0x8
400199ac:	00f76733          	or	a4,a4,a5
400199b0:	0025c783          	lbu	a5,2(a1)
400199b4:	01079793          	slli	a5,a5,0x10
400199b8:	00e7e7b3          	or	a5,a5,a4
400199bc:	0035c703          	lbu	a4,3(a1)
400199c0:	01871713          	slli	a4,a4,0x18
400199c4:	00f76733          	or	a4,a4,a5
400199c8:	00154783          	lbu	a5,1(a0)
400199cc:	00879793          	slli	a5,a5,0x8
400199d0:	00d7e7b3          	or	a5,a5,a3
400199d4:	00254683          	lbu	a3,2(a0)
400199d8:	01069693          	slli	a3,a3,0x10
400199dc:	00f6e6b3          	or	a3,a3,a5
400199e0:	00354783          	lbu	a5,3(a0)
400199e4:	01879793          	slli	a5,a5,0x18
400199e8:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
400199ec:	00f70c63          	beq	a4,a5,40019a04 <net_ipv4_is_addr_bcast+0x84>
	return net_if_ipv4_is_addr_bcast(iface, addr);
400199f0:	00040513          	mv	a0,s0
}
400199f4:	01812403          	lw	s0,24(sp)
400199f8:	01c12083          	lw	ra,28(sp)
400199fc:	02010113          	addi	sp,sp,32
	return net_if_ipv4_is_addr_bcast(iface, addr);
40019a00:	e74f906f          	j	40013074 <net_if_ipv4_is_addr_bcast>
}
40019a04:	01c12083          	lw	ra,28(sp)
40019a08:	01812403          	lw	s0,24(sp)
40019a0c:	00100513          	li	a0,1
40019a10:	02010113          	addi	sp,sp,32
40019a14:	00008067          	ret

40019a18 <icmpv4_handle_echo_request>:
#endif

static enum net_verdict icmpv4_handle_echo_request(struct net_pkt *pkt,
					   struct net_ipv4_hdr *ip_hdr,
					   struct net_icmp_hdr *icmp_hdr)
{
40019a18:	fd010113          	addi	sp,sp,-48
40019a1c:	02912223          	sw	s1,36(sp)
40019a20:	02112623          	sw	ra,44(sp)
40019a24:	02812423          	sw	s0,40(sp)
40019a28:	03212023          	sw	s2,32(sp)
40019a2c:	01312e23          	sw	s3,28(sp)
	return UNALIGNED_GET(&addr->s_addr) == 0;
40019a30:	00d5c783          	lbu	a5,13(a1)
40019a34:	00c5c703          	lbu	a4,12(a1)
40019a38:	00050493          	mv	s1,a0
40019a3c:	00879793          	slli	a5,a5,0x8
40019a40:	00e7e7b3          	or	a5,a5,a4
40019a44:	00e5c703          	lbu	a4,14(a1)
40019a48:	01071713          	slli	a4,a4,0x10
40019a4c:	00f76733          	or	a4,a4,a5
40019a50:	00f5c783          	lbu	a5,15(a1)
40019a54:	01879793          	slli	a5,a5,0x18
40019a58:	00e7e7b3          	or	a5,a5,a4
	int16_t payload_len;

	/* If interface can not select src address based on dst addr
	 * and src address is unspecified, drop the echo request.
	 */
	if (net_ipv4_is_addr_unspecified((struct in_addr *)ip_hdr->src)) {
40019a5c:	18078863          	beqz	a5,40019bec <icmpv4_handle_echo_request+0x1d4>
40019a60:	00852703          	lw	a4,8(a0)
40019a64:	00058913          	mv	s2,a1
	size_t bytes = 0;
40019a68:	00000793          	li	a5,0
	while (buf) {
40019a6c:	14071a63          	bnez	a4,40019bc0 <icmpv4_handle_echo_request+0x1a8>
	return pkt->ipv4_opts_len;
40019a70:	03a4c583          	lbu	a1,58(s1)
	NET_DBG("Received Echo Request from %s to %s",
		net_sprint_ipv4_addr(&ip_hdr->src),
		net_sprint_ipv4_addr(&ip_hdr->dst));

	payload_len = net_pkt_get_len(pkt) -
		      net_pkt_ip_hdr_len(pkt) -
40019a74:	0364c703          	lbu	a4,54(s1)
	return pkt->iface;
40019a78:	0184a503          	lw	a0,24(s1)
		      net_pkt_ipv4_opts_len(pkt) - NET_ICMPH_LEN;
40019a7c:	00e58733          	add	a4,a1,a4
40019a80:	40e787b3          	sub	a5,a5,a4
40019a84:	ffc78793          	addi	a5,a5,-4
40019a88:	01079993          	slli	s3,a5,0x10
	if (payload_len < NET_ICMPV4_UNUSED_LEN) {
40019a8c:	01079793          	slli	a5,a5,0x10
40019a90:	4107d793          	srai	a5,a5,0x10
40019a94:	00300713          	li	a4,3
		      net_pkt_ipv4_opts_len(pkt) - NET_ICMPH_LEN;
40019a98:	0109d993          	srli	s3,s3,0x10
	if (payload_len < NET_ICMPV4_UNUSED_LEN) {
40019a9c:	14f75863          	bge	a4,a5,40019bec <icmpv4_handle_echo_request+0x1d4>
		/* No identifier or sequence number present */
		goto drop;
	}

	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt),
40019aa0:	06400713          	li	a4,100
40019aa4:	00000793          	li	a5,0
40019aa8:	00100693          	li	a3,1
40019aac:	00100613          	li	a2,1
40019ab0:	013585b3          	add	a1,a1,s3
40019ab4:	dd4fe0ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
40019ab8:	00050413          	mv	s0,a0
					  net_pkt_ipv4_opts_len(pkt) +
					  payload_len,
					  AF_INET, IPPROTO_ICMP,
					  PKT_WAIT_TIME);
	if (!reply) {
40019abc:	12050863          	beqz	a0,40019bec <icmpv4_handle_echo_request+0x1d4>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
40019ac0:	01094783          	lbu	a5,16(s2)
40019ac4:	f0000737          	lui	a4,0xf0000
40019ac8:	0184a503          	lw	a0,24(s1)
40019acc:	01879793          	slli	a5,a5,0x18
40019ad0:	00e7f7b3          	and	a5,a5,a4
		NET_DBG("DROP: No buffer");
		goto drop;
	}

	if (net_ipv4_is_addr_mcast((struct in_addr *)ip_hdr->dst) ||
40019ad4:	e0000737          	lui	a4,0xe0000
40019ad8:	01090593          	addi	a1,s2,16
40019adc:	0ee79a63          	bne	a5,a4,40019bd0 <icmpv4_handle_echo_request+0x1b8>
	    net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
				   (struct in_addr *)ip_hdr->dst)) {
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
40019ae0:	0184a503          	lw	a0,24(s1)
40019ae4:	ea8f90ef          	jal	ra,4001318c <net_if_ipv4_select_src_addr>
40019ae8:	00050593          	mv	a1,a0
	return pkt->ip_dscp;
40019aec:	0404a703          	lw	a4,64(s1)
	pkt->ip_dscp = dscp;
40019af0:	04044783          	lbu	a5,64(s0)
	}

	net_pkt_set_ip_dscp(reply, net_pkt_ip_dscp(pkt));
	net_pkt_set_ip_ecn(reply, net_pkt_ip_ecn(pkt));

	if (net_ipv4_create(reply, src, (struct in_addr *)ip_hdr->src)) {
40019af4:	00c90613          	addi	a2,s2,12
40019af8:	03f77713          	andi	a4,a4,63
40019afc:	fc07f793          	andi	a5,a5,-64
40019b00:	00e7e7b3          	or	a5,a5,a4
40019b04:	04f40023          	sb	a5,64(s0)
	return pkt->ip_ecn;
40019b08:	0404a703          	lw	a4,64(s1)
	pkt->ip_ecn = ecn;
40019b0c:	0ff7f793          	zext.b	a5,a5
40019b10:	03f7f793          	andi	a5,a5,63
40019b14:	0c077713          	andi	a4,a4,192
40019b18:	00e7e7b3          	or	a5,a5,a4
40019b1c:	04f40023          	sb	a5,64(s0)
40019b20:	00040513          	mv	a0,s0
40019b24:	171000ef          	jal	ra,4001a494 <net_ipv4_create>
40019b28:	0a051e63          	bnez	a0,40019be4 <icmpv4_handle_echo_request+0x1cc>
		    icmpv4_handle_header_options(pkt, reply, src)) {
			goto drop;
		}
	}

	if (icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
40019b2c:	00000613          	li	a2,0
40019b30:	00000593          	li	a1,0
40019b34:	00040513          	mv	a0,s0
40019b38:	dd5ff0ef          	jal	ra,4001990c <icmpv4_create>
40019b3c:	0a051463          	bnez	a0,40019be4 <icmpv4_handle_echo_request+0x1cc>
	    net_pkt_copy(reply, pkt, payload_len)) {
40019b40:	00098613          	mv	a2,s3
40019b44:	00048593          	mv	a1,s1
40019b48:	00040513          	mv	a0,s0
40019b4c:	851fe0ef          	jal	ra,4001839c <net_pkt_copy>
	if (icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
40019b50:	08051a63          	bnez	a0,40019be4 <icmpv4_handle_echo_request+0x1cc>
		goto drop;
	}

	net_pkt_cursor_init(reply);
40019b54:	00040513          	mv	a0,s0
40019b58:	f99fd0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	net_ipv4_finalize(reply, IPPROTO_ICMP);
40019b5c:	00100593          	li	a1,1
40019b60:	00040513          	mv	a0,s0
40019b64:	15d000ef          	jal	ra,4001a4c0 <net_ipv4_finalize>

	NET_DBG("Sending Echo Reply from %s to %s",
		net_sprint_ipv4_addr(src),
		net_sprint_ipv4_addr(&ip_hdr->src));

	if (net_send_data(reply) < 0) {
40019b68:	00040513          	mv	a0,s0
40019b6c:	b41f50ef          	jal	ra,4000f6ac <net_send_data>
40019b70:	06054a63          	bltz	a0,40019be4 <icmpv4_handle_echo_request+0x1cc>
	UPDATE_STAT(iface, stats.icmp.sent++);
40019b74:	4003b7b7          	lui	a5,0x4003b
40019b78:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40019b7c:	0487a703          	lw	a4,72(a5)
	return pkt->iface;
40019b80:	01842683          	lw	a3,24(s0)
		goto drop;
	}

	net_stats_update_icmp_sent(net_pkt_iface(reply));

	net_pkt_unref(pkt);
40019b84:	00048513          	mv	a0,s1
40019b88:	00170713          	addi	a4,a4,1 # e0000001 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0000002>
40019b8c:	04e7a423          	sw	a4,72(a5)
40019b90:	04c6a783          	lw	a5,76(a3)
40019b94:	00178793          	addi	a5,a5,1
40019b98:	04f6a623          	sw	a5,76(a3)
40019b9c:	c81fd0ef          	jal	ra,4001781c <net_pkt_unref>

	return NET_OK;
40019ba0:	00000513          	li	a0,0
	}

	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
40019ba4:	02c12083          	lw	ra,44(sp)
40019ba8:	02812403          	lw	s0,40(sp)
40019bac:	02412483          	lw	s1,36(sp)
40019bb0:	02012903          	lw	s2,32(sp)
40019bb4:	01c12983          	lw	s3,28(sp)
40019bb8:	03010113          	addi	sp,sp,48
40019bbc:	00008067          	ret
		bytes += buf->len;
40019bc0:	01075683          	lhu	a3,16(a4)
		buf = buf->frags;
40019bc4:	00472703          	lw	a4,4(a4)
		bytes += buf->len;
40019bc8:	00d787b3          	add	a5,a5,a3
		buf = buf->frags;
40019bcc:	ea1ff06f          	j	40019a6c <icmpv4_handle_echo_request+0x54>
	    net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
40019bd0:	00b12623          	sw	a1,12(sp)
40019bd4:	dadff0ef          	jal	ra,40019980 <net_ipv4_is_addr_bcast>
	if (net_ipv4_is_addr_mcast((struct in_addr *)ip_hdr->dst) ||
40019bd8:	00c12583          	lw	a1,12(sp)
40019bdc:	f00512e3          	bnez	a0,40019ae0 <icmpv4_handle_echo_request+0xc8>
40019be0:	f0dff06f          	j	40019aec <icmpv4_handle_echo_request+0xd4>
		net_pkt_unref(reply);
40019be4:	00040513          	mv	a0,s0
40019be8:	c35fd0ef          	jal	ra,4001781c <net_pkt_unref>
	net_stats_update_icmp_drop(net_pkt_iface(pkt));
40019bec:	0184a503          	lw	a0,24(s1)
40019bf0:	cf9ff0ef          	jal	ra,400198e8 <net_stats_update_icmp_drop>
	return NET_DROP;
40019bf4:	00200513          	li	a0,2
40019bf8:	fadff06f          	j	40019ba4 <icmpv4_handle_echo_request+0x18c>

40019bfc <net_icmpv4_finalize>:
{
40019bfc:	fe010113          	addi	sp,sp,-32
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
40019c00:	00400793          	li	a5,4
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
40019c04:	00810593          	addi	a1,sp,8
{
40019c08:	00912a23          	sw	s1,20(sp)
40019c0c:	00112e23          	sw	ra,28(sp)
40019c10:	00812c23          	sw	s0,24(sp)
40019c14:	00050493          	mv	s1,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
40019c18:	00012423          	sw	zero,8(sp)
40019c1c:	00f12623          	sw	a5,12(sp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
40019c20:	cc9fe0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!icmp_hdr) {
40019c24:	04050a63          	beqz	a0,40019c78 <net_icmpv4_finalize+0x7c>
	icmp_hdr->chksum = 0U;
40019c28:	00050123          	sb	zero,2(a0)
40019c2c:	000501a3          	sb	zero,3(a0)
40019c30:	00050413          	mv	s0,a0
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
40019c34:	0184a503          	lw	a0,24(s1)
40019c38:	f19f90ef          	jal	ra,40013b50 <net_if_need_calc_tx_checksum>
40019c3c:	00050e63          	beqz	a0,40019c58 <net_icmpv4_finalize+0x5c>
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
}

static inline uint16_t net_calc_chksum_icmpv4(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_ICMP);
40019c40:	00100593          	li	a1,1
40019c44:	00048513          	mv	a0,s1
40019c48:	aa8fb0ef          	jal	ra,40014ef0 <net_calc_chksum>
		icmp_hdr->chksum = net_calc_chksum_icmpv4(pkt);
40019c4c:	00855793          	srli	a5,a0,0x8
40019c50:	00a40123          	sb	a0,2(s0)
40019c54:	00f401a3          	sb	a5,3(s0)
	return net_pkt_set_data(pkt, &icmpv4_access);
40019c58:	00810593          	addi	a1,sp,8
40019c5c:	00048513          	mv	a0,s1
40019c60:	d59fe0ef          	jal	ra,400189b8 <net_pkt_set_data>
}
40019c64:	01c12083          	lw	ra,28(sp)
40019c68:	01812403          	lw	s0,24(sp)
40019c6c:	01412483          	lw	s1,20(sp)
40019c70:	02010113          	addi	sp,sp,32
40019c74:	00008067          	ret
		return -ENOBUFS;
40019c78:	f9700513          	li	a0,-105
40019c7c:	fe9ff06f          	j	40019c64 <net_icmpv4_finalize+0x68>

40019c80 <net_icmpv4_send_echo_request>:
				 uint16_t identifier,
				 uint16_t sequence,
				 uint8_t tos,
				 const void *data,
				 size_t data_size)
{
40019c80:	fc010113          	addi	sp,sp,-64
40019c84:	03312623          	sw	s3,44(sp)
40019c88:	01712e23          	sw	s7,28(sp)
40019c8c:	02112e23          	sw	ra,60(sp)
40019c90:	02812c23          	sw	s0,56(sp)
40019c94:	02912a23          	sw	s1,52(sp)
40019c98:	03212823          	sw	s2,48(sp)
40019c9c:	03412423          	sw	s4,40(sp)
40019ca0:	03512223          	sw	s5,36(sp)
40019ca4:	03612023          	sw	s6,32(sp)
40019ca8:	01812c23          	sw	s8,24(sp)
40019cac:	01912a23          	sw	s9,20(sp)

	if (IS_ENABLED(CONFIG_NET_OFFLOAD) && net_if_is_ip_offloaded(iface)) {
		return -ENOTSUP;
	}

	if (!iface->config.ip.ipv4) {
40019cb0:	0c052c03          	lw	s8,192(a0)
{
40019cb4:	00078b93          	mv	s7,a5
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
40019cb8:	00400793          	li	a5,4
40019cbc:	00012423          	sw	zero,8(sp)
40019cc0:	00f12623          	sw	a5,12(sp)
		return -ENETUNREACH;
40019cc4:	f8e00993          	li	s3,-114
	if (!iface->config.ip.ipv4) {
40019cc8:	140c0063          	beqz	s8,40019e08 <net_icmpv4_send_echo_request+0x188>
40019ccc:	00058c93          	mv	s9,a1
40019cd0:	00060a13          	mv	s4,a2
40019cd4:	00068493          	mv	s1,a3
40019cd8:	00070b13          	mv	s6,a4
	}

	/* Take the first address of the network interface */
	src = &iface->config.ip.ipv4->unicast[0].address.in_addr;

	pkt = net_pkt_alloc_with_buffer(iface,
40019cdc:	00000793          	li	a5,0
40019ce0:	06400713          	li	a4,100
40019ce4:	00100693          	li	a3,1
40019ce8:	00100613          	li	a2,1
40019cec:	00480593          	addi	a1,a6,4
40019cf0:	00050a93          	mv	s5,a0
40019cf4:	00080913          	mv	s2,a6
40019cf8:	b90fe0ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
	src = &iface->config.ip.ipv4->unicast[0].address.in_addr;
40019cfc:	004c0c13          	addi	s8,s8,4
	pkt = net_pkt_alloc_with_buffer(iface,
40019d00:	00050413          	mv	s0,a0
					sizeof(struct net_icmpv4_echo_req)
					+ data_size,
					AF_INET, IPPROTO_ICMP,
					PKT_WAIT_TIME);
	if (!pkt) {
		return -ENOMEM;
40019d04:	ff400993          	li	s3,-12
	if (!pkt) {
40019d08:	10050063          	beqz	a0,40019e08 <net_icmpv4_send_echo_request+0x188>
	pkt->ip_dscp = dscp;
40019d0c:	006b1793          	slli	a5,s6,0x6
40019d10:	002b5b13          	srli	s6,s6,0x2
40019d14:	0167e7b3          	or	a5,a5,s6
40019d18:	04f50023          	sb	a5,64(a0)
	}

	net_pkt_set_ip_dscp(pkt, net_ipv4_get_dscp(tos));
	net_pkt_set_ip_ecn(pkt, net_ipv4_get_ecn(tos));

	if (net_ipv4_create(pkt, src, dst) ||
40019d1c:	000c8613          	mv	a2,s9
40019d20:	000c0593          	mv	a1,s8
40019d24:	770000ef          	jal	ra,4001a494 <net_ipv4_create>
40019d28:	00050a63          	beqz	a0,40019d3c <net_icmpv4_send_echo_request+0xbc>
	int ret = -ENOBUFS;
40019d2c:	f9700993          	li	s3,-105
	net_stats_update_icmp_drop(iface);

	ret = -EIO;

drop:
	net_pkt_unref(pkt);
40019d30:	00040513          	mv	a0,s0
40019d34:	ae9fd0ef          	jal	ra,4001781c <net_pkt_unref>

	return ret;
40019d38:	0d00006f          	j	40019e08 <net_icmpv4_send_echo_request+0x188>
	    icmpv4_create(pkt, NET_ICMPV4_ECHO_REQUEST, 0)) {
40019d3c:	00000613          	li	a2,0
40019d40:	00800593          	li	a1,8
40019d44:	00040513          	mv	a0,s0
40019d48:	bc5ff0ef          	jal	ra,4001990c <icmpv4_create>
40019d4c:	00050993          	mv	s3,a0
	if (net_ipv4_create(pkt, src, dst) ||
40019d50:	fc051ee3          	bnez	a0,40019d2c <net_icmpv4_send_echo_request+0xac>
	echo_req = (struct net_icmpv4_echo_req *)net_pkt_get_data(
40019d54:	00810593          	addi	a1,sp,8
40019d58:	00040513          	mv	a0,s0
40019d5c:	b8dfe0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!echo_req) {
40019d60:	fc0506e3          	beqz	a0,40019d2c <net_icmpv4_send_echo_request+0xac>
	echo_req->identifier = htons(identifier);
40019d64:	008a1793          	slli	a5,s4,0x8
40019d68:	008a5a13          	srli	s4,s4,0x8
40019d6c:	0147ea33          	or	s4,a5,s4
40019d70:	010a1793          	slli	a5,s4,0x10
40019d74:	0107d793          	srli	a5,a5,0x10
40019d78:	0087d793          	srli	a5,a5,0x8
40019d7c:	00f500a3          	sb	a5,1(a0)
	echo_req->sequence   = htons(sequence);
40019d80:	00849793          	slli	a5,s1,0x8
40019d84:	0084d493          	srli	s1,s1,0x8
40019d88:	0097e4b3          	or	s1,a5,s1
40019d8c:	01049793          	slli	a5,s1,0x10
40019d90:	0107d793          	srli	a5,a5,0x10
40019d94:	0087d793          	srli	a5,a5,0x8
	echo_req->identifier = htons(identifier);
40019d98:	01450023          	sb	s4,0(a0)
	echo_req->sequence   = htons(sequence);
40019d9c:	00950123          	sb	s1,2(a0)
40019da0:	00f501a3          	sb	a5,3(a0)
	net_pkt_set_data(pkt, &icmpv4_access);
40019da4:	00810593          	addi	a1,sp,8
40019da8:	00040513          	mv	a0,s0
40019dac:	c0dfe0ef          	jal	ra,400189b8 <net_pkt_set_data>
	if (data != NULL && data_size > 0) {
40019db0:	080b8863          	beqz	s7,40019e40 <net_icmpv4_send_echo_request+0x1c0>
40019db4:	00090a63          	beqz	s2,40019dc8 <net_icmpv4_send_echo_request+0x148>
		net_pkt_write(pkt, data, data_size);
40019db8:	00090613          	mv	a2,s2
40019dbc:	000b8593          	mv	a1,s7
40019dc0:	00040513          	mv	a0,s0
40019dc4:	ac1fe0ef          	jal	ra,40018884 <net_pkt_write>
	net_pkt_cursor_init(pkt);
40019dc8:	00040513          	mv	a0,s0
40019dcc:	d25fd0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	net_ipv4_finalize(pkt, IPPROTO_ICMP);
40019dd0:	00100593          	li	a1,1
40019dd4:	00040513          	mv	a0,s0
40019dd8:	6e8000ef          	jal	ra,4001a4c0 <net_ipv4_finalize>
	if (net_send_data(pkt) >= 0) {
40019ddc:	00040513          	mv	a0,s0
40019de0:	8cdf50ef          	jal	ra,4000f6ac <net_send_data>
40019de4:	0e054863          	bltz	a0,40019ed4 <net_icmpv4_send_echo_request+0x254>
40019de8:	4003b7b7          	lui	a5,0x4003b
40019dec:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40019df0:	0487a703          	lw	a4,72(a5)
40019df4:	00170713          	addi	a4,a4,1
40019df8:	04e7a423          	sw	a4,72(a5)
40019dfc:	04caa783          	lw	a5,76(s5)
40019e00:	00178793          	addi	a5,a5,1
40019e04:	04faa623          	sw	a5,76(s5)
}
40019e08:	03c12083          	lw	ra,60(sp)
40019e0c:	03812403          	lw	s0,56(sp)
40019e10:	03412483          	lw	s1,52(sp)
40019e14:	03012903          	lw	s2,48(sp)
40019e18:	02812a03          	lw	s4,40(sp)
40019e1c:	02412a83          	lw	s5,36(sp)
40019e20:	02012b03          	lw	s6,32(sp)
40019e24:	01c12b83          	lw	s7,28(sp)
40019e28:	01812c03          	lw	s8,24(sp)
40019e2c:	01412c83          	lw	s9,20(sp)
40019e30:	00098513          	mv	a0,s3
40019e34:	02c12983          	lw	s3,44(sp)
40019e38:	04010113          	addi	sp,sp,64
40019e3c:	00008067          	ret
	} else if (data == NULL && data_size > 0) {
40019e40:	f80904e3          	beqz	s2,40019dc8 <net_icmpv4_send_echo_request+0x148>
		if (data_size >= sizeof(uint32_t)) {
40019e44:	00300793          	li	a5,3
40019e48:	0727f463          	bgeu	a5,s2,40019eb0 <net_icmpv4_send_echo_request+0x230>
	return sys_clock_cycle_get_32();
40019e4c:	11c130ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
40019e50:	00050493          	mv	s1,a0
40019e54:	114130ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
40019e58:	00050b13          	mv	s6,a0
40019e5c:	10c130ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
40019e60:	00050a13          	mv	s4,a0
40019e64:	104130ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
			uint32_t time_stamp = htonl(k_cycle_get_32());
40019e68:	000107b7          	lui	a5,0x10
40019e6c:	01851513          	slli	a0,a0,0x18
40019e70:	f0078793          	addi	a5,a5,-256 # ff00 <__kernel_ram_size+0x43f8>
40019e74:	0184d493          	srli	s1,s1,0x18
40019e78:	008b5b13          	srli	s6,s6,0x8
40019e7c:	00a4e4b3          	or	s1,s1,a0
40019e80:	00fb7b33          	and	s6,s6,a5
40019e84:	008a1a13          	slli	s4,s4,0x8
40019e88:	00ff07b7          	lui	a5,0xff0
40019e8c:	00fa7a33          	and	s4,s4,a5
40019e90:	0164e4b3          	or	s1,s1,s6
40019e94:	0144e4b3          	or	s1,s1,s4
			net_pkt_write(pkt, &time_stamp, sizeof(time_stamp));
40019e98:	00400613          	li	a2,4
40019e9c:	00410593          	addi	a1,sp,4
40019ea0:	00040513          	mv	a0,s0
			uint32_t time_stamp = htonl(k_cycle_get_32());
40019ea4:	00912223          	sw	s1,4(sp)
			data_size -= sizeof(time_stamp);
40019ea8:	ffc90913          	addi	s2,s2,-4
			net_pkt_write(pkt, &time_stamp, sizeof(time_stamp));
40019eac:	9d9fe0ef          	jal	ra,40018884 <net_pkt_write>
		for (size_t i = 0; i < data_size; i++) {
40019eb0:	00000493          	li	s1,0
40019eb4:	f0990ae3          	beq	s2,s1,40019dc8 <net_icmpv4_send_echo_request+0x148>
int net_pkt_write(struct net_pkt *pkt, const void *data, size_t length);

/* Write uint8_t data into a net_pkt. */
static inline int net_pkt_write_u8(struct net_pkt *pkt, uint8_t data)
{
	return net_pkt_write(pkt, &data, sizeof(uint8_t));
40019eb8:	00100613          	li	a2,1
40019ebc:	00410593          	addi	a1,sp,4
40019ec0:	00040513          	mv	a0,s0
40019ec4:	00910223          	sb	s1,4(sp)
40019ec8:	9bdfe0ef          	jal	ra,40018884 <net_pkt_write>
40019ecc:	00148493          	addi	s1,s1,1
40019ed0:	fe5ff06f          	j	40019eb4 <net_icmpv4_send_echo_request+0x234>
	net_stats_update_icmp_drop(iface);
40019ed4:	000a8513          	mv	a0,s5
40019ed8:	a11ff0ef          	jal	ra,400198e8 <net_stats_update_icmp_drop>
	ret = -EIO;
40019edc:	ffb00993          	li	s3,-5
40019ee0:	e51ff06f          	j	40019d30 <net_icmpv4_send_echo_request+0xb0>

40019ee4 <net_icmpv4_send_error>:

int net_icmpv4_send_error(struct net_pkt *orig, uint8_t type, uint8_t code)
{
40019ee4:	fd010113          	addi	sp,sp,-48
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
40019ee8:	01400793          	li	a5,20
{
40019eec:	02912223          	sw	s1,36(sp)
40019ef0:	01412c23          	sw	s4,24(sp)
40019ef4:	01512a23          	sw	s5,20(sp)
40019ef8:	02112623          	sw	ra,44(sp)
40019efc:	02812423          	sw	s0,40(sp)
40019f00:	03212023          	sw	s2,32(sp)
40019f04:	01312e23          	sw	s3,28(sp)
40019f08:	01612823          	sw	s6,16(sp)
40019f0c:	00050493          	mv	s1,a0
40019f10:	00058a13          	mv	s4,a1
40019f14:	00060a93          	mv	s5,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
40019f18:	00012023          	sw	zero,0(sp)
40019f1c:	00f12223          	sw	a5,4(sp)
	int err = -EIO;
	struct net_ipv4_hdr *ip_hdr;
	struct net_pkt *pkt;
	size_t copy_len;

	net_pkt_cursor_init(orig);
40019f20:	bd1fd0ef          	jal	ra,40017af0 <net_pkt_cursor_init>

	ip_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(orig, &ipv4_access);
40019f24:	00010593          	mv	a1,sp
40019f28:	00048513          	mv	a0,s1
40019f2c:	9bdfe0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!ip_hdr) {
40019f30:	16050e63          	beqz	a0,4001a0ac <net_icmpv4_send_error+0x1c8>
		goto drop_no_pkt;
	}

	if (ip_hdr->proto == IPPROTO_ICMP) {
40019f34:	00954703          	lbu	a4,9(a0)
40019f38:	00100793          	li	a5,1
40019f3c:	00050913          	mv	s2,a0
40019f40:	02f71e63          	bne	a4,a5,40019f7c <net_icmpv4_send_error+0x98>
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
40019f44:	00400793          	li	a5,4
						      struct net_icmp_hdr);
		struct net_icmp_hdr *icmp_hdr;

		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
40019f48:	00810593          	addi	a1,sp,8
40019f4c:	00048513          	mv	a0,s1
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
40019f50:	00012423          	sw	zero,8(sp)
40019f54:	00f12623          	sw	a5,12(sp)
		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
40019f58:	991fe0ef          	jal	ra,400188e8 <net_pkt_get_data>
							orig, &icmpv4_access);
		if (!icmp_hdr || icmp_hdr->code < 8) {
40019f5c:	00050863          	beqz	a0,40019f6c <net_icmpv4_send_error+0x88>
40019f60:	00154703          	lbu	a4,1(a0)
40019f64:	00700793          	li	a5,7
40019f68:	00e7ea63          	bltu	a5,a4,40019f7c <net_icmpv4_send_error+0x98>
			/* We must not send ICMP errors back */
			err = -EINVAL;
40019f6c:	fea00913          	li	s2,-22

drop:
	net_pkt_unref(pkt);

drop_no_pkt:
	net_stats_update_icmp_drop(net_pkt_iface(orig));
40019f70:	0184a503          	lw	a0,24(s1)
40019f74:	975ff0ef          	jal	ra,400198e8 <net_stats_update_icmp_drop>

	return err;
40019f78:	1000006f          	j	4001a078 <net_icmpv4_send_error+0x194>
	if (net_ipv4_is_addr_bcast(net_pkt_iface(orig),
40019f7c:	0184a503          	lw	a0,24(s1)
				   (struct in_addr *)ip_hdr->dst)) {
40019f80:	01090b13          	addi	s6,s2,16
	if (net_ipv4_is_addr_bcast(net_pkt_iface(orig),
40019f84:	000b0593          	mv	a1,s6
40019f88:	9f9ff0ef          	jal	ra,40019980 <net_ipv4_is_addr_bcast>
40019f8c:	12051063          	bnez	a0,4001a0ac <net_icmpv4_send_error+0x1c8>
	if (ip_hdr->proto == IPPROTO_UDP) {
40019f90:	00994783          	lbu	a5,9(s2)
40019f94:	01100713          	li	a4,17
		copy_len = sizeof(struct net_ipv4_hdr) +
40019f98:	01c00993          	li	s3,28
	if (ip_hdr->proto == IPPROTO_UDP) {
40019f9c:	00e78a63          	beq	a5,a4,40019fb0 <net_icmpv4_send_error+0xcc>
	} else if (ip_hdr->proto == IPPROTO_TCP) {
40019fa0:	00600713          	li	a4,6
		copy_len = 0;
40019fa4:	00000993          	li	s3,0
	} else if (ip_hdr->proto == IPPROTO_TCP) {
40019fa8:	00e79463          	bne	a5,a4,40019fb0 <net_icmpv4_send_error+0xcc>
		copy_len = sizeof(struct net_ipv4_hdr) +
40019fac:	02800993          	li	s3,40
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
40019fb0:	0184a503          	lw	a0,24(s1)
40019fb4:	06400713          	li	a4,100
40019fb8:	00000793          	li	a5,0
40019fbc:	00100693          	li	a3,1
40019fc0:	00100613          	li	a2,1
40019fc4:	00498593          	addi	a1,s3,4
40019fc8:	8c0fe0ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
40019fcc:	00050413          	mv	s0,a0
	if (!pkt) {
40019fd0:	0e050263          	beqz	a0,4001a0b4 <net_icmpv4_send_error+0x1d0>
	if (net_ipv4_create(pkt, (struct in_addr *)ip_hdr->dst,
40019fd4:	00c90613          	addi	a2,s2,12
40019fd8:	000b0593          	mv	a1,s6
40019fdc:	4b8000ef          	jal	ra,4001a494 <net_ipv4_create>
40019fe0:	0c051263          	bnez	a0,4001a0a4 <net_icmpv4_send_error+0x1c0>
	    icmpv4_create(pkt, type, code) ||
40019fe4:	000a8613          	mv	a2,s5
40019fe8:	000a0593          	mv	a1,s4
40019fec:	00040513          	mv	a0,s0
40019ff0:	91dff0ef          	jal	ra,4001990c <icmpv4_create>
			    (struct in_addr *)ip_hdr->src) ||
40019ff4:	0a051863          	bnez	a0,4001a0a4 <net_icmpv4_send_error+0x1c0>
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
40019ff8:	00400613          	li	a2,4
40019ffc:	00000593          	li	a1,0
4001a000:	00040513          	mv	a0,s0
4001a004:	b0cfe0ef          	jal	ra,40018310 <net_pkt_memset>
	    icmpv4_create(pkt, type, code) ||
4001a008:	08051e63          	bnez	a0,4001a0a4 <net_icmpv4_send_error+0x1c0>
	    net_pkt_copy(pkt, orig, copy_len)) {
4001a00c:	00098613          	mv	a2,s3
4001a010:	00048593          	mv	a1,s1
4001a014:	00040513          	mv	a0,s0
4001a018:	b84fe0ef          	jal	ra,4001839c <net_pkt_copy>
4001a01c:	00050913          	mv	s2,a0
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
4001a020:	08051263          	bnez	a0,4001a0a4 <net_icmpv4_send_error+0x1c0>
	net_pkt_cursor_init(pkt);
4001a024:	00040513          	mv	a0,s0
4001a028:	ac9fd0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	net_ipv4_finalize(pkt, IPPROTO_ICMP);
4001a02c:	00100593          	li	a1,1
4001a030:	00040513          	mv	a0,s0
4001a034:	48c000ef          	jal	ra,4001a4c0 <net_ipv4_finalize>
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
4001a038:	0244a783          	lw	a5,36(s1)
	if (net_send_data(pkt) >= 0) {
4001a03c:	00040513          	mv	a0,s0
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
4001a040:	02f42623          	sw	a5,44(s0)
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;
4001a044:	0284c783          	lbu	a5,40(s1)
4001a048:	02f40823          	sb	a5,48(s0)
	if (net_send_data(pkt) >= 0) {
4001a04c:	e60f50ef          	jal	ra,4000f6ac <net_send_data>
4001a050:	04054a63          	bltz	a0,4001a0a4 <net_icmpv4_send_error+0x1c0>
4001a054:	4003b7b7          	lui	a5,0x4003b
4001a058:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001a05c:	0487a703          	lw	a4,72(a5)
	return pkt->iface;
4001a060:	0184a683          	lw	a3,24(s1)
4001a064:	00170713          	addi	a4,a4,1
4001a068:	04e7a423          	sw	a4,72(a5)
4001a06c:	04c6a783          	lw	a5,76(a3)
4001a070:	00178793          	addi	a5,a5,1
4001a074:	04f6a623          	sw	a5,76(a3)

}
4001a078:	02c12083          	lw	ra,44(sp)
4001a07c:	02812403          	lw	s0,40(sp)
4001a080:	02412483          	lw	s1,36(sp)
4001a084:	01c12983          	lw	s3,28(sp)
4001a088:	01812a03          	lw	s4,24(sp)
4001a08c:	01412a83          	lw	s5,20(sp)
4001a090:	01012b03          	lw	s6,16(sp)
4001a094:	00090513          	mv	a0,s2
4001a098:	02012903          	lw	s2,32(sp)
4001a09c:	03010113          	addi	sp,sp,48
4001a0a0:	00008067          	ret
	net_pkt_unref(pkt);
4001a0a4:	00040513          	mv	a0,s0
4001a0a8:	f74fd0ef          	jal	ra,4001781c <net_pkt_unref>
	int err = -EIO;
4001a0ac:	ffb00913          	li	s2,-5
4001a0b0:	ec1ff06f          	j	40019f70 <net_icmpv4_send_error+0x8c>
		err =  -ENOMEM;
4001a0b4:	ff400913          	li	s2,-12
4001a0b8:	eb9ff06f          	j	40019f70 <net_icmpv4_send_error+0x8c>

4001a0bc <net_icmpv4_register_handler>:
	return list->head;
4001a0bc:	400397b7          	lui	a5,0x40039
4001a0c0:	09c78793          	addi	a5,a5,156 # 4003909c <handlers>
4001a0c4:	0007a703          	lw	a4,0(a5)
	parent->next = child;
4001a0c8:	00e52023          	sw	a4,0(a0)
Z_GENLIST_PREPEND(slist, snode)
4001a0cc:	0047a703          	lw	a4,4(a5)
	list->head = node;
4001a0d0:	00a7a023          	sw	a0,0(a5)
Z_GENLIST_PREPEND(slist, snode)
4001a0d4:	00071463          	bnez	a4,4001a0dc <net_icmpv4_register_handler+0x20>
	list->tail = node;
4001a0d8:	00a7a223          	sw	a0,4(a5)

void net_icmpv4_register_handler(struct net_icmpv4_handler *handler)
{
	sys_slist_prepend(&handlers, &handler->node);
}
4001a0dc:	00008067          	ret

4001a0e0 <net_icmpv4_unregister_handler>:
	return list->head;
4001a0e0:	400397b7          	lui	a5,0x40039
4001a0e4:	09c7a703          	lw	a4,156(a5) # 4003909c <handlers>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4001a0e8:	00000693          	li	a3,0
4001a0ec:	09c78793          	addi	a5,a5,156
4001a0f0:	00071463          	bnez	a4,4001a0f8 <net_icmpv4_unregister_handler+0x18>

void net_icmpv4_unregister_handler(struct net_icmpv4_handler *handler)
{
	sys_slist_find_and_remove(&handlers, &handler->node);
}
4001a0f4:	00008067          	ret
4001a0f8:	02e51c63          	bne	a0,a4,4001a130 <net_icmpv4_unregister_handler+0x50>
	return node->next;
4001a0fc:	00052703          	lw	a4,0(a0)
Z_GENLIST_REMOVE(slist, snode)
4001a100:	00069e63          	bnez	a3,4001a11c <net_icmpv4_unregister_handler+0x3c>
4001a104:	0047a683          	lw	a3,4(a5)
	list->head = node;
4001a108:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_REMOVE(slist, snode)
4001a10c:	00d51463          	bne	a0,a3,4001a114 <net_icmpv4_unregister_handler+0x34>
	list->tail = node;
4001a110:	00e7a223          	sw	a4,4(a5)
	parent->next = child;
4001a114:	00052023          	sw	zero,0(a0)
Z_GENLIST_REMOVE(slist, snode)
4001a118:	00008067          	ret
	parent->next = child;
4001a11c:	00e6a023          	sw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
4001a120:	0047a703          	lw	a4,4(a5)
4001a124:	fee518e3          	bne	a0,a4,4001a114 <net_icmpv4_unregister_handler+0x34>
	list->tail = node;
4001a128:	00d7a223          	sw	a3,4(a5)
}
4001a12c:	fe9ff06f          	j	4001a114 <net_icmpv4_unregister_handler+0x34>
	return node->next;
4001a130:	00070693          	mv	a3,a4
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4001a134:	00072703          	lw	a4,0(a4)
4001a138:	fb9ff06f          	j	4001a0f0 <net_icmpv4_unregister_handler+0x10>

4001a13c <net_icmpv4_input>:

enum net_verdict net_icmpv4_input(struct net_pkt *pkt,
				  struct net_ipv4_hdr *ip_hdr)
{
4001a13c:	fe010113          	addi	sp,sp,-32
4001a140:	01212823          	sw	s2,16(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
4001a144:	00400793          	li	a5,4
{
4001a148:	00058913          	mv	s2,a1
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;
	struct net_icmpv4_handler *cb;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
4001a14c:	00810593          	addi	a1,sp,8
{
4001a150:	00812c23          	sw	s0,24(sp)
4001a154:	00112e23          	sw	ra,28(sp)
4001a158:	00912a23          	sw	s1,20(sp)
4001a15c:	00050413          	mv	s0,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
4001a160:	00012423          	sw	zero,8(sp)
4001a164:	00f12623          	sw	a5,12(sp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
4001a168:	f80fe0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!icmp_hdr) {
4001a16c:	02050663          	beqz	a0,4001a198 <net_icmpv4_input+0x5c>
4001a170:	00050493          	mv	s1,a0
		NET_DBG("DROP: NULL ICMPv4 header");
		return NET_DROP;
	}

	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
4001a174:	01842503          	lw	a0,24(s0)
4001a178:	9e1f90ef          	jal	ra,40013b58 <net_if_need_calc_rx_checksum>
4001a17c:	02051263          	bnez	a0,4001a1a0 <net_icmpv4_input+0x64>
			NET_DBG("DROP: Invalid checksum");
			goto drop;
		}
	}

	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
4001a180:	01842503          	lw	a0,24(s0)
4001a184:	01090593          	addi	a1,s2,16
4001a188:	ff8ff0ef          	jal	ra,40019980 <net_ipv4_is_addr_bcast>
4001a18c:	02050463          	beqz	a0,4001a1b4 <net_icmpv4_input+0x78>
			return cb->handler(pkt, ip_hdr, icmp_hdr);
		}
	}

drop:
	net_stats_update_icmp_drop(net_pkt_iface(pkt));
4001a190:	01842503          	lw	a0,24(s0)
4001a194:	f54ff0ef          	jal	ra,400198e8 <net_stats_update_icmp_drop>
		return NET_DROP;
4001a198:	00200513          	li	a0,2
4001a19c:	0840006f          	j	4001a220 <net_icmpv4_input+0xe4>
4001a1a0:	00100593          	li	a1,1
4001a1a4:	00040513          	mv	a0,s0
4001a1a8:	d49fa0ef          	jal	ra,40014ef0 <net_calc_chksum>
		if (net_calc_chksum_icmpv4(pkt) != 0U) {
4001a1ac:	fc050ae3          	beqz	a0,4001a180 <net_icmpv4_input+0x44>
4001a1b0:	fe1ff06f          	j	4001a190 <net_icmpv4_input+0x54>
 * Packet needs to be set to overwrite mode.
 */
static inline int net_pkt_acknowledge_data(struct net_pkt *pkt,
					   struct net_pkt_data_access *access)
{
	return net_pkt_skip(pkt, access->size);
4001a1b4:	00c12583          	lw	a1,12(sp)
4001a1b8:	00040513          	mv	a0,s0
4001a1bc:	f15fd0ef          	jal	ra,400180d0 <net_pkt_skip>
	UPDATE_STAT(iface, stats.icmp.recv++);
4001a1c0:	4003b7b7          	lui	a5,0x4003b
4001a1c4:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001a1c8:	0447a703          	lw	a4,68(a5)
	return pkt->iface;
4001a1cc:	01842683          	lw	a3,24(s0)
4001a1d0:	00170713          	addi	a4,a4,1
4001a1d4:	04e7a223          	sw	a4,68(a5)
4001a1d8:	0486a783          	lw	a5,72(a3)
4001a1dc:	00178793          	addi	a5,a5,1
4001a1e0:	04f6a423          	sw	a5,72(a3)
	return list->head;
4001a1e4:	400397b7          	lui	a5,0x40039
4001a1e8:	09c7a783          	lw	a5,156(a5) # 4003909c <handlers>
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
4001a1ec:	fa0782e3          	beqz	a5,4001a190 <net_icmpv4_input+0x54>
		if (cb->type == icmp_hdr->type &&
4001a1f0:	0087c683          	lbu	a3,8(a5)
4001a1f4:	0004c703          	lbu	a4,0(s1)
4001a1f8:	04e69063          	bne	a3,a4,4001a238 <net_icmpv4_input+0xfc>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
4001a1fc:	0097c703          	lbu	a4,9(a5)
		if (cb->type == icmp_hdr->type &&
4001a200:	0014c683          	lbu	a3,1(s1)
4001a204:	00e68463          	beq	a3,a4,4001a20c <net_icmpv4_input+0xd0>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
4001a208:	02071863          	bnez	a4,4001a238 <net_icmpv4_input+0xfc>
			return cb->handler(pkt, ip_hdr, icmp_hdr);
4001a20c:	0047a783          	lw	a5,4(a5)
4001a210:	00048613          	mv	a2,s1
4001a214:	00090593          	mv	a1,s2
4001a218:	00040513          	mv	a0,s0
4001a21c:	000780e7          	jalr	a5

	return NET_DROP;
}
4001a220:	01c12083          	lw	ra,28(sp)
4001a224:	01812403          	lw	s0,24(sp)
4001a228:	01412483          	lw	s1,20(sp)
4001a22c:	01012903          	lw	s2,16(sp)
4001a230:	02010113          	addi	sp,sp,32
4001a234:	00008067          	ret
	return node->next;
4001a238:	0007a783          	lw	a5,0(a5)
4001a23c:	fb1ff06f          	j	4001a1ec <net_icmpv4_input+0xb0>

4001a240 <net_icmpv4_init>:
	.handler = icmpv4_handle_echo_request,
};

void net_icmpv4_init(void)
{
	net_icmpv4_register_handler(&echo_request_handler);
4001a240:	40044537          	lui	a0,0x40044
4001a244:	05050513          	addi	a0,a0,80 # 40044050 <echo_request_handler>
4001a248:	e75ff06f          	j	4001a0bc <net_icmpv4_register_handler>

4001a24c <net_ipv4_is_addr_mcast>:
4001a24c:	00054503          	lbu	a0,0(a0)
4001a250:	f00007b7          	lui	a5,0xf0000
4001a254:	01851513          	slli	a0,a0,0x18
4001a258:	00f57533          	and	a0,a0,a5
4001a25c:	200007b7          	lui	a5,0x20000
4001a260:	00f50533          	add	a0,a0,a5
}
4001a264:	00153513          	seqz	a0,a0
4001a268:	00008067          	ret

4001a26c <net_ipv4_is_addr_bcast>:
{
4001a26c:	fe010113          	addi	sp,sp,-32
4001a270:	00812c23          	sw	s0,24(sp)
4001a274:	00b12623          	sw	a1,12(sp)
4001a278:	00112e23          	sw	ra,28(sp)
4001a27c:	00050413          	mv	s0,a0
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4001a280:	97cfb0ef          	jal	ra,400153fc <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4001a284:	00c12583          	lw	a1,12(sp)
4001a288:	00054683          	lbu	a3,0(a0)
4001a28c:	0015c703          	lbu	a4,1(a1)
4001a290:	0005c783          	lbu	a5,0(a1)
4001a294:	00871713          	slli	a4,a4,0x8
4001a298:	00f76733          	or	a4,a4,a5
4001a29c:	0025c783          	lbu	a5,2(a1)
4001a2a0:	01079793          	slli	a5,a5,0x10
4001a2a4:	00e7e7b3          	or	a5,a5,a4
4001a2a8:	0035c703          	lbu	a4,3(a1)
4001a2ac:	01871713          	slli	a4,a4,0x18
4001a2b0:	00f76733          	or	a4,a4,a5
4001a2b4:	00154783          	lbu	a5,1(a0)
4001a2b8:	00879793          	slli	a5,a5,0x8
4001a2bc:	00d7e7b3          	or	a5,a5,a3
4001a2c0:	00254683          	lbu	a3,2(a0)
4001a2c4:	01069693          	slli	a3,a3,0x10
4001a2c8:	00f6e6b3          	or	a3,a3,a5
4001a2cc:	00354783          	lbu	a5,3(a0)
4001a2d0:	01879793          	slli	a5,a5,0x18
4001a2d4:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4001a2d8:	00f70c63          	beq	a4,a5,4001a2f0 <net_ipv4_is_addr_bcast+0x84>
	return net_if_ipv4_is_addr_bcast(iface, addr);
4001a2dc:	00040513          	mv	a0,s0
}
4001a2e0:	01812403          	lw	s0,24(sp)
4001a2e4:	01c12083          	lw	ra,28(sp)
4001a2e8:	02010113          	addi	sp,sp,32
	return net_if_ipv4_is_addr_bcast(iface, addr);
4001a2ec:	d89f806f          	j	40013074 <net_if_ipv4_is_addr_bcast>
}
4001a2f0:	01c12083          	lw	ra,28(sp)
4001a2f4:	01812403          	lw	s0,24(sp)
4001a2f8:	00100513          	li	a0,1
4001a2fc:	02010113          	addi	sp,sp,32
4001a300:	00008067          	ret

4001a304 <net_ipv4_create_full>:
			 uint8_t tos,
			 uint16_t id,
			 uint8_t flags,
			 uint16_t offset,
			 uint8_t ttl)
{
4001a304:	fc010113          	addi	sp,sp,-64
4001a308:	03212823          	sw	s2,48(sp)
4001a30c:	03412423          	sw	s4,40(sp)
4001a310:	00058913          	mv	s2,a1
4001a314:	00078a13          	mv	s4,a5
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
	struct net_ipv4_hdr *ipv4_hdr;

	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
4001a318:	00810593          	addi	a1,sp,8
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
4001a31c:	01400793          	li	a5,20
{
4001a320:	02912a23          	sw	s1,52(sp)
4001a324:	03312623          	sw	s3,44(sp)
4001a328:	03512223          	sw	s5,36(sp)
4001a32c:	03612023          	sw	s6,32(sp)
4001a330:	01712e23          	sw	s7,28(sp)
4001a334:	01812c23          	sw	s8,24(sp)
4001a338:	02112e23          	sw	ra,60(sp)
4001a33c:	02812c23          	sw	s0,56(sp)
4001a340:	00050493          	mv	s1,a0
4001a344:	00060993          	mv	s3,a2
4001a348:	00068c13          	mv	s8,a3
4001a34c:	00070b93          	mv	s7,a4
4001a350:	00080b13          	mv	s6,a6
4001a354:	00088a93          	mv	s5,a7
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
4001a358:	00012423          	sw	zero,8(sp)
4001a35c:	00f12623          	sw	a5,12(sp)
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
4001a360:	d88fe0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!ipv4_hdr) {
4001a364:	12050463          	beqz	a0,4001a48c <net_ipv4_create_full+0x188>
		return -ENOBUFS;
	}

	ipv4_hdr->vhl       = 0x45;
4001a368:	04500793          	li	a5,69
4001a36c:	00f50023          	sb	a5,0(a0)
	ipv4_hdr->tos       = tos;
	ipv4_hdr->len       = 0U;
	ipv4_hdr->id[0]     = id >> 8;
4001a370:	008bd793          	srli	a5,s7,0x8
4001a374:	00f50223          	sb	a5,4(a0)
	ipv4_hdr->id[1]     = id;
	ipv4_hdr->offset[0] = (offset >> 8) | (flags << 5);
4001a378:	005a1a13          	slli	s4,s4,0x5
4001a37c:	008b5793          	srli	a5,s6,0x8
4001a380:	0147e7b3          	or	a5,a5,s4
	ipv4_hdr->tos       = tos;
4001a384:	018500a3          	sb	s8,1(a0)
	ipv4_hdr->len       = 0U;
4001a388:	00050123          	sb	zero,2(a0)
4001a38c:	000501a3          	sb	zero,3(a0)
	ipv4_hdr->id[1]     = id;
4001a390:	017502a3          	sb	s7,5(a0)
	ipv4_hdr->offset[0] = (offset >> 8) | (flags << 5);
4001a394:	00f50323          	sb	a5,6(a0)
	ipv4_hdr->offset[1] = offset;
4001a398:	016503a3          	sb	s6,7(a0)
	ipv4_hdr->ttl       = ttl;
4001a39c:	01550423          	sb	s5,8(a0)
4001a3a0:	00050413          	mv	s0,a0

	if (ttl == 0U) {
4001a3a4:	000a9863          	bnez	s5,4001a3b4 <net_ipv4_create_full+0xb0>
		ipv4_hdr->ttl = net_if_ipv4_get_ttl(net_pkt_iface(pkt));
4001a3a8:	0184a503          	lw	a0,24(s1)
4001a3ac:	b5df80ef          	jal	ra,40012f08 <net_if_ipv4_get_ttl>
4001a3b0:	00a40423          	sb	a0,8(s0)
	}

	ipv4_hdr->proto     = 0U;
4001a3b4:	000404a3          	sb	zero,9(s0)
	ipv4_hdr->chksum    = 0U;
4001a3b8:	00040523          	sb	zero,10(s0)
4001a3bc:	000405a3          	sb	zero,11(s0)
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
4001a3c0:	0019c783          	lbu	a5,1(s3)
4001a3c4:	0009c703          	lbu	a4,0(s3)
	net_ipv4_addr_copy_raw(ipv4_hdr->dst, (uint8_t *)dst);
	net_ipv4_addr_copy_raw(ipv4_hdr->src, (uint8_t *)src);

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv4_hdr));

	return net_pkt_set_data(pkt, &ipv4_access);
4001a3c8:	00810593          	addi	a1,sp,8
4001a3cc:	00879793          	slli	a5,a5,0x8
4001a3d0:	00e7e7b3          	or	a5,a5,a4
4001a3d4:	0029c703          	lbu	a4,2(s3)
4001a3d8:	00048513          	mv	a0,s1
4001a3dc:	01071713          	slli	a4,a4,0x10
4001a3e0:	00f76733          	or	a4,a4,a5
4001a3e4:	0039c783          	lbu	a5,3(s3)
4001a3e8:	00e40823          	sb	a4,16(s0)
4001a3ec:	01879793          	slli	a5,a5,0x18
4001a3f0:	00e7e7b3          	or	a5,a5,a4
4001a3f4:	0087d713          	srli	a4,a5,0x8
4001a3f8:	00e408a3          	sb	a4,17(s0)
4001a3fc:	0107d713          	srli	a4,a5,0x10
4001a400:	0187d793          	srli	a5,a5,0x18
4001a404:	00e40923          	sb	a4,18(s0)
4001a408:	00f409a3          	sb	a5,19(s0)
4001a40c:	00194783          	lbu	a5,1(s2)
4001a410:	00094703          	lbu	a4,0(s2)
4001a414:	00879793          	slli	a5,a5,0x8
4001a418:	00e7e7b3          	or	a5,a5,a4
4001a41c:	00294703          	lbu	a4,2(s2)
4001a420:	01071713          	slli	a4,a4,0x10
4001a424:	00f76733          	or	a4,a4,a5
4001a428:	00394783          	lbu	a5,3(s2)
4001a42c:	00e40623          	sb	a4,12(s0)
4001a430:	01879793          	slli	a5,a5,0x18
4001a434:	00e7e7b3          	or	a5,a5,a4
4001a438:	0087d713          	srli	a4,a5,0x8
4001a43c:	00e406a3          	sb	a4,13(s0)
4001a440:	0107d713          	srli	a4,a5,0x10
4001a444:	0187d793          	srli	a5,a5,0x18
4001a448:	00f407a3          	sb	a5,15(s0)
4001a44c:	00e40723          	sb	a4,14(s0)
	pkt->ip_hdr_len = len;
4001a450:	01400793          	li	a5,20
4001a454:	02f48b23          	sb	a5,54(s1)
4001a458:	d60fe0ef          	jal	ra,400189b8 <net_pkt_set_data>
}
4001a45c:	03c12083          	lw	ra,60(sp)
4001a460:	03812403          	lw	s0,56(sp)
4001a464:	03412483          	lw	s1,52(sp)
4001a468:	03012903          	lw	s2,48(sp)
4001a46c:	02c12983          	lw	s3,44(sp)
4001a470:	02812a03          	lw	s4,40(sp)
4001a474:	02412a83          	lw	s5,36(sp)
4001a478:	02012b03          	lw	s6,32(sp)
4001a47c:	01c12b83          	lw	s7,28(sp)
4001a480:	01812c03          	lw	s8,24(sp)
4001a484:	04010113          	addi	sp,sp,64
4001a488:	00008067          	ret
		return -ENOBUFS;
4001a48c:	f9700513          	li	a0,-105
4001a490:	fcdff06f          	j	4001a45c <net_ipv4_create_full+0x158>

4001a494 <net_ipv4_create>:
	return pkt->ip_dscp;
4001a494:	04052783          	lw	a5,64(a0)
	if (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {
		net_ipv4_set_dscp(&tos, net_pkt_ip_dscp(pkt));
		net_ipv4_set_ecn(&tos, net_pkt_ip_ecn(pkt));
	}

	return net_ipv4_create_full(pkt, src, dst, tos, 0U, 0U, 0U,
4001a498:	03954883          	lbu	a7,57(a0)
4001a49c:	00000813          	li	a6,0
 * @param dscp DSCP value to set.
 */
static inline void net_ipv4_set_dscp(uint8_t *tos, uint8_t dscp)
{
	*tos &= ~NET_IPV4_DSCP_MASK;
	*tos |= (dscp << NET_IPV4_DSCP_OFFSET) & NET_IPV4_DSCP_MASK;
4001a4a0:	03f7f313          	andi	t1,a5,63
	return pkt->ip_ecn;
4001a4a4:	0067d793          	srli	a5,a5,0x6
4001a4a8:	0037f693          	andi	a3,a5,3
4001a4ac:	00231313          	slli	t1,t1,0x2
4001a4b0:	00000793          	li	a5,0
4001a4b4:	00000713          	li	a4,0
4001a4b8:	00d366b3          	or	a3,t1,a3
4001a4bc:	e49ff06f          	j	4001a304 <net_ipv4_create_full>

4001a4c0 <net_ipv4_finalize>:
				    net_pkt_ipv4_ttl(pkt));
}

int net_ipv4_finalize(struct net_pkt *pkt, uint8_t next_header_proto)
{
4001a4c0:	fe010113          	addi	sp,sp,-32
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
4001a4c4:	01400793          	li	a5,20
{
4001a4c8:	00812c23          	sw	s0,24(sp)
4001a4cc:	01212823          	sw	s2,16(sp)
4001a4d0:	00112e23          	sw	ra,28(sp)
4001a4d4:	00912a23          	sw	s1,20(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
4001a4d8:	00012423          	sw	zero,8(sp)
4001a4dc:	00f12623          	sw	a5,12(sp)
	pkt->overwrite = overwrite;
4001a4e0:	03754783          	lbu	a5,55(a0)
{
4001a4e4:	00058913          	mv	s2,a1
	struct net_ipv4_hdr *ipv4_hdr;

	net_pkt_set_overwrite(pkt, true);

	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
4001a4e8:	00810593          	addi	a1,sp,8
4001a4ec:	0017e793          	ori	a5,a5,1
4001a4f0:	02f50ba3          	sb	a5,55(a0)
{
4001a4f4:	00050413          	mv	s0,a0
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
4001a4f8:	bf0fe0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!ipv4_hdr) {
4001a4fc:	0c050863          	beqz	a0,4001a5cc <net_ipv4_finalize+0x10c>
4001a500:	00842703          	lw	a4,8(s0)
4001a504:	00050493          	mv	s1,a0
	size_t bytes = 0;
4001a508:	00000793          	li	a5,0
	while (buf) {
4001a50c:	08071263          	bnez	a4,4001a590 <net_ipv4_finalize+0xd0>
					((net_pkt_ip_hdr_len(pkt) +
					  net_pkt_ipv4_opts_len(pkt)) / 4U));
		}
	}

	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
4001a510:	00879713          	slli	a4,a5,0x8
4001a514:	01079793          	slli	a5,a5,0x10
4001a518:	0107d793          	srli	a5,a5,0x10
4001a51c:	0087d793          	srli	a5,a5,0x8
4001a520:	00f767b3          	or	a5,a4,a5
4001a524:	01079713          	slli	a4,a5,0x10
4001a528:	01075713          	srli	a4,a4,0x10
4001a52c:	00f48123          	sb	a5,2(s1)
4001a530:	00875793          	srli	a5,a4,0x8
4001a534:	00f481a3          	sb	a5,3(s1)
	ipv4_hdr->proto = next_header_proto;
4001a538:	012484a3          	sb	s2,9(s1)

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
4001a53c:	01842503          	lw	a0,24(s0)
4001a540:	e10f90ef          	jal	ra,40013b50 <net_if_need_calc_tx_checksum>
4001a544:	00050c63          	beqz	a0,4001a55c <net_ipv4_finalize+0x9c>
		ipv4_hdr->chksum = net_calc_chksum_ipv4(pkt);
4001a548:	00040513          	mv	a0,s0
4001a54c:	bd9fa0ef          	jal	ra,40015124 <net_calc_chksum_ipv4>
4001a550:	00a48523          	sb	a0,10(s1)
4001a554:	00855513          	srli	a0,a0,0x8
4001a558:	00a485a3          	sb	a0,11(s1)
	}

	net_pkt_set_data(pkt, &ipv4_access);
4001a55c:	00810593          	addi	a1,sp,8
4001a560:	00040513          	mv	a0,s0
4001a564:	c54fe0ef          	jal	ra,400189b8 <net_pkt_set_data>

	if (IS_ENABLED(CONFIG_NET_UDP) &&
4001a568:	01100793          	li	a5,17
4001a56c:	02f91a63          	bne	s2,a5,4001a5a0 <net_ipv4_finalize+0xe0>
	    next_header_proto == IPPROTO_UDP) {
		return net_udp_finalize(pkt);
4001a570:	00040513          	mv	a0,s0
4001a574:	74c0a0ef          	jal	ra,40024cc0 <net_udp_finalize>
	} else if (next_header_proto == IPPROTO_ICMP) {
		return net_icmpv4_finalize(pkt);
	}

	return 0;
}
4001a578:	01c12083          	lw	ra,28(sp)
4001a57c:	01812403          	lw	s0,24(sp)
4001a580:	01412483          	lw	s1,20(sp)
4001a584:	01012903          	lw	s2,16(sp)
4001a588:	02010113          	addi	sp,sp,32
4001a58c:	00008067          	ret
		bytes += buf->len;
4001a590:	01075683          	lhu	a3,16(a4)
		buf = buf->frags;
4001a594:	00472703          	lw	a4,4(a4)
		bytes += buf->len;
4001a598:	00d787b3          	add	a5,a5,a3
		buf = buf->frags;
4001a59c:	f71ff06f          	j	4001a50c <net_ipv4_finalize+0x4c>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
4001a5a0:	00600793          	li	a5,6
4001a5a4:	00f91863          	bne	s2,a5,4001a5b4 <net_ipv4_finalize+0xf4>
		return net_tcp_finalize(pkt);
4001a5a8:	00040513          	mv	a0,s0
4001a5ac:	0e0070ef          	jal	ra,4002168c <net_tcp_finalize>
4001a5b0:	fc9ff06f          	j	4001a578 <net_ipv4_finalize+0xb8>
	} else if (next_header_proto == IPPROTO_ICMP) {
4001a5b4:	00100793          	li	a5,1
	return 0;
4001a5b8:	00000513          	li	a0,0
	} else if (next_header_proto == IPPROTO_ICMP) {
4001a5bc:	faf91ee3          	bne	s2,a5,4001a578 <net_ipv4_finalize+0xb8>
		return net_icmpv4_finalize(pkt);
4001a5c0:	00040513          	mv	a0,s0
4001a5c4:	e38ff0ef          	jal	ra,40019bfc <net_icmpv4_finalize>
4001a5c8:	fb1ff06f          	j	4001a578 <net_ipv4_finalize+0xb8>
		return -ENOBUFS;
4001a5cc:	f9700513          	li	a0,-105
4001a5d0:	fa9ff06f          	j	4001a578 <net_ipv4_finalize+0xb8>

4001a5d4 <net_ipv4_input>:
	return 0;
}
#endif

enum net_verdict net_ipv4_input(struct net_pkt *pkt)
{
4001a5d4:	f9010113          	addi	sp,sp,-112
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
4001a5d8:	01400793          	li	a5,20
{
4001a5dc:	06812423          	sw	s0,104(sp)
4001a5e0:	05412c23          	sw	s4,88(sp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
4001a5e4:	02410713          	addi	a4,sp,36
{
4001a5e8:	06112623          	sw	ra,108(sp)
4001a5ec:	06912223          	sw	s1,100(sp)
4001a5f0:	07212023          	sw	s2,96(sp)
4001a5f4:	05312e23          	sw	s3,92(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
4001a5f8:	02f12023          	sw	a5,32(sp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
4001a5fc:	02e12623          	sw	a4,44(sp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
4001a600:	02f12c23          	sw	a5,56(sp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
4001a604:	00800713          	li	a4,8
4001a608:	00852783          	lw	a5,8(a0)
4001a60c:	02e12823          	sw	a4,48(sp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
4001a610:	03c10713          	addi	a4,sp,60
{
4001a614:	00050413          	mv	s0,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
4001a618:	00012e23          	sw	zero,28(sp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
4001a61c:	02e12a23          	sw	a4,52(sp)
	size_t bytes = 0;
4001a620:	00000a13          	li	s4,0
	while (buf) {
4001a624:	26079663          	bnez	a5,4001a890 <net_ipv4_input+0x2bc>
	UPDATE_STAT(iface, stats.ipv4.recv++);
4001a628:	4003b9b7          	lui	s3,0x4003b
4001a62c:	ed098693          	addi	a3,s3,-304 # 4003aed0 <net_stats>
4001a630:	0346a783          	lw	a5,52(a3)
	return pkt->iface;
4001a634:	01842703          	lw	a4,24(s0)
	net_pkt_cursor_backup(pkt, &hdr_start);
#endif

	net_stats_update_ipv4_recv(net_pkt_iface(pkt));

	hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
4001a638:	01c10593          	addi	a1,sp,28
4001a63c:	00178793          	addi	a5,a5,1 # 20000001 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1a0a1f01>
4001a640:	02f6aa23          	sw	a5,52(a3)
4001a644:	03872783          	lw	a5,56(a4)
4001a648:	00040513          	mv	a0,s0
4001a64c:	ed098993          	addi	s3,s3,-304
4001a650:	00178793          	addi	a5,a5,1
4001a654:	02f72c23          	sw	a5,56(a4)
4001a658:	a90fe0ef          	jal	ra,400188e8 <net_pkt_get_data>
4001a65c:	00050493          	mv	s1,a0
	if (!hdr) {
4001a660:	24050663          	beqz	a0,4001a8ac <net_ipv4_input+0x2d8>
		NET_DBG("DROP: no buffer");
		goto drop;
	}

	hdr_len = (hdr->vhl & NET_IPV4_IHL_MASK) * 4U;
4001a664:	00054903          	lbu	s2,0(a0)
	if (hdr_len < sizeof(struct net_ipv4_hdr)) {
4001a668:	01300793          	li	a5,19
	hdr_len = (hdr->vhl & NET_IPV4_IHL_MASK) * 4U;
4001a66c:	00f97913          	andi	s2,s2,15
4001a670:	00291913          	slli	s2,s2,0x2
	if (hdr_len < sizeof(struct net_ipv4_hdr)) {
4001a674:	2327fc63          	bgeu	a5,s2,4001a8ac <net_ipv4_input+0x2d8>
	pkt->ip_hdr_len = len;
4001a678:	01400793          	li	a5,20
4001a67c:	02f40b23          	sb	a5,54(s0)
	return (tos & NET_IPV4_DSCP_MASK) >> NET_IPV4_DSCP_OFFSET;
4001a680:	00154703          	lbu	a4,1(a0)
	pkt->ip_dscp = dscp;
4001a684:	04044783          	lbu	a5,64(s0)
	if (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {
		net_pkt_set_ip_dscp(pkt, net_ipv4_get_dscp(hdr->tos));
		net_pkt_set_ip_ecn(pkt, net_ipv4_get_ecn(hdr->tos));
	}

	opts_len = hdr_len - sizeof(struct net_ipv4_hdr);
4001a688:	fec90913          	addi	s2,s2,-20
4001a68c:	00275713          	srli	a4,a4,0x2
4001a690:	fc07f793          	andi	a5,a5,-64
4001a694:	00e7e7b3          	or	a5,a5,a4
4001a698:	04f40023          	sb	a5,64(s0)
	pkt->ip_ecn = ecn;
4001a69c:	00154703          	lbu	a4,1(a0)
4001a6a0:	0ff7f793          	zext.b	a5,a5
4001a6a4:	03f7f793          	andi	a5,a5,63
4001a6a8:	00671713          	slli	a4,a4,0x6
4001a6ac:	00e7e7b3          	or	a5,a5,a4
4001a6b0:	04f40023          	sb	a5,64(s0)
	if (opts_len > NET_IPV4_HDR_OPTNS_MAX_LEN) {
		return -EINVAL;
	}

	if (hdr->ttl == 0) {
4001a6b4:	00854783          	lbu	a5,8(a0)
	opts_len = hdr_len - sizeof(struct net_ipv4_hdr);
4001a6b8:	0ff97913          	zext.b	s2,s2
	if (hdr->ttl == 0) {
4001a6bc:	1e078863          	beqz	a5,4001a8ac <net_ipv4_input+0x2d8>
	pkt->ipv4_opts_len = opts_len;
4001a6c0:	03240d23          	sb	s2,58(s0)
		goto drop;
	}

	net_pkt_set_ipv4_opts_len(pkt, opts_len);

	pkt_len = ntohs(hdr->len);
4001a6c4:	00354783          	lbu	a5,3(a0)
4001a6c8:	00254703          	lbu	a4,2(a0)
4001a6cc:	00879793          	slli	a5,a5,0x8
4001a6d0:	00e7e7b3          	or	a5,a5,a4
4001a6d4:	00879593          	slli	a1,a5,0x8
4001a6d8:	0087d793          	srli	a5,a5,0x8
4001a6dc:	00f5e5b3          	or	a1,a1,a5
4001a6e0:	01059593          	slli	a1,a1,0x10
4001a6e4:	0105d593          	srli	a1,a1,0x10
	if (real_len < pkt_len) {
4001a6e8:	1cba4263          	blt	s4,a1,4001a8ac <net_ipv4_input+0x2d8>
		NET_DBG("DROP: pkt len per hdr %d != pkt real len %d",
			pkt_len, real_len);
		goto drop;
	} else if (real_len > pkt_len) {
4001a6ec:	0145d663          	bge	a1,s4,4001a6f8 <net_ipv4_input+0x124>
		net_pkt_update_length(pkt, pkt_len);
4001a6f0:	00040513          	mv	a0,s0
4001a6f4:	e31fd0ef          	jal	ra,40018524 <net_pkt_update_length>
	}

	if (net_ipv4_is_addr_mcast((struct in_addr *)hdr->src)) {
4001a6f8:	00c48593          	addi	a1,s1,12
4001a6fc:	00058513          	mv	a0,a1
4001a700:	00b12623          	sw	a1,12(sp)
4001a704:	b49ff0ef          	jal	ra,4001a24c <net_ipv4_is_addr_mcast>
	return pkt->iface;
4001a708:	01842783          	lw	a5,24(s0)
4001a70c:	1a051063          	bnez	a0,4001a8ac <net_ipv4_input+0x2d8>
		NET_DBG("DROP: src addr is %s", "mcast");
		goto drop;
	}

	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt), (struct in_addr *)hdr->src)) {
4001a710:	00c12583          	lw	a1,12(sp)
4001a714:	00078513          	mv	a0,a5
4001a718:	b55ff0ef          	jal	ra,4001a26c <net_ipv4_is_addr_bcast>
4001a71c:	18051863          	bnez	a0,4001a8ac <net_ipv4_input+0x2d8>
	return UNALIGNED_GET(&addr->s_addr) == 0;
4001a720:	00d4c783          	lbu	a5,13(s1)
4001a724:	00c4c703          	lbu	a4,12(s1)
4001a728:	01842503          	lw	a0,24(s0)
4001a72c:	00879793          	slli	a5,a5,0x8
4001a730:	00e7e7b3          	or	a5,a5,a4
4001a734:	00e4c703          	lbu	a4,14(s1)
4001a738:	01071713          	slli	a4,a4,0x10
4001a73c:	00f76733          	or	a4,a4,a5
4001a740:	00f4c783          	lbu	a5,15(s1)
4001a744:	01879793          	slli	a5,a5,0x18
4001a748:	00e7e7b3          	or	a5,a5,a4
		NET_DBG("DROP: src addr is %s", "bcast");
		goto drop;
	}

	if (net_ipv4_is_addr_unspecified((struct in_addr *)hdr->src) &&
4001a74c:	14078a63          	beqz	a5,4001a8a0 <net_ipv4_input+0x2cc>
	    !net_ipv4_is_addr_bcast(net_pkt_iface(pkt), (struct in_addr *)hdr->dst)) {
		NET_DBG("DROP: src addr is %s", "unspecified");
		goto drop;
	}

	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
4001a750:	01842503          	lw	a0,24(s0)
4001a754:	c04f90ef          	jal	ra,40013b58 <net_if_need_calc_rx_checksum>
4001a758:	16051c63          	bnez	a0,4001a8d0 <net_ipv4_input+0x2fc>
	    net_calc_chksum_ipv4(pkt) != 0U) {
		NET_DBG("DROP: invalid chksum");
		goto drop;
	}

	if ((!net_ipv4_is_my_addr((struct in_addr *)hdr->dst) &&
4001a75c:	01048a13          	addi	s4,s1,16
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
4001a760:	00000593          	li	a1,0
4001a764:	000a0513          	mv	a0,s4
4001a768:	b49f80ef          	jal	ra,400132b0 <net_if_ipv4_addr_lookup>
	if (!ret) {
4001a76c:	08051063          	bnez	a0,4001a7ec <net_ipv4_input+0x218>
		ret = net_ipv4_is_addr_bcast(NULL, addr);
4001a770:	000a0593          	mv	a1,s4
4001a774:	af9ff0ef          	jal	ra,4001a26c <net_ipv4_is_addr_bcast>
4001a778:	06051a63          	bnez	a0,4001a7ec <net_ipv4_input+0x218>
	     !net_ipv4_is_addr_mcast((struct in_addr *)hdr->dst) &&
4001a77c:	000a0513          	mv	a0,s4
4001a780:	acdff0ef          	jal	ra,4001a24c <net_ipv4_is_addr_mcast>
	     !(hdr->proto == IPPROTO_UDP &&
4001a784:	0094c703          	lbu	a4,9(s1)
	if ((!net_ipv4_is_my_addr((struct in_addr *)hdr->dst) &&
4001a788:	06051263          	bnez	a0,4001a7ec <net_ipv4_input+0x218>
	     !net_ipv4_is_addr_mcast((struct in_addr *)hdr->dst) &&
4001a78c:	01100793          	li	a5,17
4001a790:	10f71e63          	bne	a4,a5,4001a8ac <net_ipv4_input+0x2d8>
	       (net_ipv4_addr_cmp((struct in_addr *)hdr->dst, net_ipv4_broadcast_address()) ||
4001a794:	c69fa0ef          	jal	ra,400153fc <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4001a798:	00154703          	lbu	a4,1(a0)
4001a79c:	00054783          	lbu	a5,0(a0)
4001a7a0:	0104c683          	lbu	a3,16(s1)
4001a7a4:	00871713          	slli	a4,a4,0x8
4001a7a8:	00f76733          	or	a4,a4,a5
4001a7ac:	00254783          	lbu	a5,2(a0)
4001a7b0:	01079793          	slli	a5,a5,0x10
4001a7b4:	00e7e7b3          	or	a5,a5,a4
4001a7b8:	00354703          	lbu	a4,3(a0)
4001a7bc:	01871713          	slli	a4,a4,0x18
4001a7c0:	00f76733          	or	a4,a4,a5
4001a7c4:	0114c783          	lbu	a5,17(s1)
4001a7c8:	00879793          	slli	a5,a5,0x8
4001a7cc:	00d7e7b3          	or	a5,a5,a3
4001a7d0:	0124c683          	lbu	a3,18(s1)
4001a7d4:	01069693          	slli	a3,a3,0x10
4001a7d8:	00f6e6b3          	or	a3,a3,a5
4001a7dc:	0134c783          	lbu	a5,19(s1)
4001a7e0:	01879793          	slli	a5,a5,0x18
4001a7e4:	00d7e7b3          	or	a5,a5,a3
	     !(hdr->proto == IPPROTO_UDP &&
4001a7e8:	0cf71263          	bne	a4,a5,4001a8ac <net_ipv4_input+0x2d8>
		/* RFC 1122 ch. 3.3.6 The 0.0.0.0 is non-standard bcast addr */
		(IS_ENABLED(CONFIG_NET_IPV4_ACCEPT_ZERO_BROADCAST) &&
		 net_ipv4_addr_cmp((struct in_addr *)hdr->dst,
				   net_ipv4_unspecified_address()))))) ||
4001a7ec:	0094c703          	lbu	a4,9(s1)
4001a7f0:	00600793          	li	a5,6
4001a7f4:	00f71a63          	bne	a4,a5,4001a808 <net_ipv4_input+0x234>
	    (hdr->proto == IPPROTO_TCP &&
	     net_ipv4_is_addr_bcast(net_pkt_iface(pkt), (struct in_addr *)hdr->dst))) {
4001a7f8:	01842503          	lw	a0,24(s0)
4001a7fc:	000a0593          	mv	a1,s4
4001a800:	a6dff0ef          	jal	ra,4001a26c <net_ipv4_is_addr_bcast>
	    (hdr->proto == IPPROTO_TCP &&
4001a804:	0a051463          	bnez	a0,4001a8ac <net_ipv4_input+0x2d8>
	return net_pkt_skip(pkt, access->size);
4001a808:	02012583          	lw	a1,32(sp)
4001a80c:	00040513          	mv	a0,s0
4001a810:	8c1fd0ef          	jal	ra,400180d0 <net_pkt_skip>
		goto drop;
	}

	net_pkt_acknowledge_data(pkt, &ipv4_access);

	if (opts_len) {
4001a814:	00090a63          	beqz	s2,4001a828 <net_ipv4_input+0x254>
		/* Only few options are handled in EchoRequest, rest skipped */
		if (net_pkt_skip(pkt, opts_len)) {
4001a818:	00090593          	mv	a1,s2
4001a81c:	00040513          	mv	a0,s0
4001a820:	8b1fd0ef          	jal	ra,400180d0 <net_pkt_skip>
4001a824:	08051463          	bnez	a0,4001a8ac <net_ipv4_input+0x2d8>
			NET_DBG("Header too big? %u", hdr_len);
			goto drop;
		}
	}

	net_pkt_set_ipv4_ttl(pkt, hdr->ttl);
4001a828:	0084c783          	lbu	a5,8(s1)

	NET_DBG("IPv4 packet received from %s to %s",
		net_sprint_ipv4_addr(&hdr->src),
		net_sprint_ipv4_addr(&hdr->dst));

	switch (hdr->proto) {
4001a82c:	00600713          	li	a4,6
	pkt->ipv4_ttl = ttl;
4001a830:	02f40ca3          	sb	a5,57(s0)
	pkt->family = family;
4001a834:	03744783          	lbu	a5,55(s0)
4001a838:	01f7f793          	andi	a5,a5,31
4001a83c:	0207e793          	ori	a5,a5,32
4001a840:	02f40ba3          	sb	a5,55(s0)
4001a844:	0094c783          	lbu	a5,9(s1)
4001a848:	08e78c63          	beq	a5,a4,4001a8e0 <net_ipv4_input+0x30c>
4001a84c:	01100713          	li	a4,17
4001a850:	0ce78063          	beq	a5,a4,4001a910 <net_ipv4_input+0x33c>
4001a854:	00100713          	li	a4,1
4001a858:	04e79a63          	bne	a5,a4,4001a8ac <net_ipv4_input+0x2d8>
	case IPPROTO_ICMP:
		verdict = net_icmpv4_input(pkt, hdr);
4001a85c:	00048593          	mv	a1,s1
4001a860:	00040513          	mv	a0,s0
4001a864:	8d9ff0ef          	jal	ra,4001a13c <net_icmpv4_input>
	}

	ip.ipv4 = hdr;

	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
	if (verdict != NET_DROP) {
4001a868:	00200793          	li	a5,2
4001a86c:	04f50063          	beq	a0,a5,4001a8ac <net_ipv4_input+0x2d8>
	}

drop:
	net_stats_update_ipv4_drop(net_pkt_iface(pkt));
	return NET_DROP;
}
4001a870:	06c12083          	lw	ra,108(sp)
4001a874:	06812403          	lw	s0,104(sp)
4001a878:	06412483          	lw	s1,100(sp)
4001a87c:	06012903          	lw	s2,96(sp)
4001a880:	05c12983          	lw	s3,92(sp)
4001a884:	05812a03          	lw	s4,88(sp)
4001a888:	07010113          	addi	sp,sp,112
4001a88c:	00008067          	ret
		bytes += buf->len;
4001a890:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
4001a894:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4001a898:	00ea0a33          	add	s4,s4,a4
		buf = buf->frags;
4001a89c:	d89ff06f          	j	4001a624 <net_ipv4_input+0x50>
	    !net_ipv4_is_addr_bcast(net_pkt_iface(pkt), (struct in_addr *)hdr->dst)) {
4001a8a0:	01048593          	addi	a1,s1,16
4001a8a4:	9c9ff0ef          	jal	ra,4001a26c <net_ipv4_is_addr_bcast>
	if (net_ipv4_is_addr_unspecified((struct in_addr *)hdr->src) &&
4001a8a8:	ea0514e3          	bnez	a0,4001a750 <net_ipv4_input+0x17c>
	UPDATE_STAT(iface, stats.ipv4.drop++);
4001a8ac:	0409a783          	lw	a5,64(s3)
	return pkt->iface;
4001a8b0:	01842703          	lw	a4,24(s0)
	return NET_DROP;
4001a8b4:	00200513          	li	a0,2
4001a8b8:	00178793          	addi	a5,a5,1
4001a8bc:	04f9a023          	sw	a5,64(s3)
4001a8c0:	04472783          	lw	a5,68(a4)
4001a8c4:	00178793          	addi	a5,a5,1
4001a8c8:	04f72223          	sw	a5,68(a4)
}
4001a8cc:	fa5ff06f          	j	4001a870 <net_ipv4_input+0x29c>
	    net_calc_chksum_ipv4(pkt) != 0U) {
4001a8d0:	00040513          	mv	a0,s0
4001a8d4:	851fa0ef          	jal	ra,40015124 <net_calc_chksum_ipv4>
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
4001a8d8:	e80502e3          	beqz	a0,4001a75c <net_ipv4_input+0x188>
4001a8dc:	fd1ff06f          	j	4001a8ac <net_ipv4_input+0x2d8>
		proto_hdr.tcp = net_tcp_input(pkt, &tcp_access);
4001a8e0:	03410593          	addi	a1,sp,52
4001a8e4:	00040513          	mv	a0,s0
4001a8e8:	62d060ef          	jal	ra,40021714 <net_tcp_input>
4001a8ec:	00a12a23          	sw	a0,20(sp)
		if (proto_hdr.tcp) {
4001a8f0:	fa050ee3          	beqz	a0,4001a8ac <net_ipv4_input+0x2d8>
	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
4001a8f4:	0094c603          	lbu	a2,9(s1)
4001a8f8:	01410693          	addi	a3,sp,20
4001a8fc:	01810593          	addi	a1,sp,24
4001a900:	00040513          	mv	a0,s0
	ip.ipv4 = hdr;
4001a904:	00912c23          	sw	s1,24(sp)
	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
4001a908:	ad5fe0ef          	jal	ra,400193dc <net_conn_input>
4001a90c:	f5dff06f          	j	4001a868 <net_ipv4_input+0x294>
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
4001a910:	02c10593          	addi	a1,sp,44
4001a914:	00040513          	mv	a0,s0
4001a918:	4840a0ef          	jal	ra,40024d9c <net_udp_input>
4001a91c:	fd1ff06f          	j	4001a8ec <net_ipv4_input+0x318>

4001a920 <net_ipv4_init>:
void net_ipv4_init(void)
{
	if (IS_ENABLED(CONFIG_NET_IPV4_FRAGMENT)) {
		net_ipv4_setup_fragment_buffers();
	}
}
4001a920:	00008067          	ret

4001a924 <net_stats_update_icmp_drop>:
	UPDATE_STAT(iface, stats.icmp.drop++);
4001a924:	4003b7b7          	lui	a5,0x4003b
4001a928:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001a92c:	04c7a703          	lw	a4,76(a5)
4001a930:	00170713          	addi	a4,a4,1
4001a934:	04e7a623          	sw	a4,76(a5)
4001a938:	05052783          	lw	a5,80(a0)
4001a93c:	00178793          	addi	a5,a5,1
4001a940:	04f52823          	sw	a5,80(a0)
}
4001a944:	00008067          	ret

4001a948 <net_icmpv6_register_handler>:
	return list->head;
4001a948:	400397b7          	lui	a5,0x40039
4001a94c:	0a478793          	addi	a5,a5,164 # 400390a4 <handlers>
4001a950:	0007a703          	lw	a4,0(a5)
	parent->next = child;
4001a954:	00e52023          	sw	a4,0(a0)
Z_GENLIST_PREPEND(slist, snode)
4001a958:	0047a703          	lw	a4,4(a5)
	list->head = node;
4001a95c:	00a7a023          	sw	a0,0(a5)
Z_GENLIST_PREPEND(slist, snode)
4001a960:	00071463          	bnez	a4,4001a968 <net_icmpv6_register_handler+0x20>
	list->tail = node;
4001a964:	00a7a223          	sw	a0,4(a5)
}

void net_icmpv6_register_handler(struct net_icmpv6_handler *handler)
{
	sys_slist_prepend(&handlers, &handler->node);
}
4001a968:	00008067          	ret

4001a96c <net_icmpv6_unregister_handler>:
	return list->head;
4001a96c:	400397b7          	lui	a5,0x40039
4001a970:	0a47a703          	lw	a4,164(a5) # 400390a4 <handlers>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4001a974:	00000693          	li	a3,0
4001a978:	0a478793          	addi	a5,a5,164
4001a97c:	00071463          	bnez	a4,4001a984 <net_icmpv6_unregister_handler+0x18>

void net_icmpv6_unregister_handler(struct net_icmpv6_handler *handler)
{
	sys_slist_find_and_remove(&handlers, &handler->node);
}
4001a980:	00008067          	ret
4001a984:	02e51c63          	bne	a0,a4,4001a9bc <net_icmpv6_unregister_handler+0x50>
	return node->next;
4001a988:	00052703          	lw	a4,0(a0)
Z_GENLIST_REMOVE(slist, snode)
4001a98c:	00069e63          	bnez	a3,4001a9a8 <net_icmpv6_unregister_handler+0x3c>
4001a990:	0047a683          	lw	a3,4(a5)
	list->head = node;
4001a994:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_REMOVE(slist, snode)
4001a998:	00d51463          	bne	a0,a3,4001a9a0 <net_icmpv6_unregister_handler+0x34>
	list->tail = node;
4001a99c:	00e7a223          	sw	a4,4(a5)
	parent->next = child;
4001a9a0:	00052023          	sw	zero,0(a0)
Z_GENLIST_REMOVE(slist, snode)
4001a9a4:	00008067          	ret
	parent->next = child;
4001a9a8:	00e6a023          	sw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
4001a9ac:	0047a703          	lw	a4,4(a5)
4001a9b0:	fee518e3          	bne	a0,a4,4001a9a0 <net_icmpv6_unregister_handler+0x34>
	list->tail = node;
4001a9b4:	00d7a223          	sw	a3,4(a5)
}
4001a9b8:	fe9ff06f          	j	4001a9a0 <net_icmpv6_unregister_handler+0x34>
	return node->next;
4001a9bc:	00070693          	mv	a3,a4
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4001a9c0:	00072703          	lw	a4,0(a4)
4001a9c4:	fb9ff06f          	j	4001a97c <net_icmpv6_unregister_handler+0x10>

4001a9c8 <net_icmpv6_finalize>:

int net_icmpv6_finalize(struct net_pkt *pkt)
{
4001a9c8:	fe010113          	addi	sp,sp,-32
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
4001a9cc:	00400793          	li	a5,4
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
4001a9d0:	00810593          	addi	a1,sp,8
{
4001a9d4:	00912a23          	sw	s1,20(sp)
4001a9d8:	00112e23          	sw	ra,28(sp)
4001a9dc:	00812c23          	sw	s0,24(sp)
4001a9e0:	00050493          	mv	s1,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
4001a9e4:	00012423          	sw	zero,8(sp)
4001a9e8:	00f12623          	sw	a5,12(sp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
4001a9ec:	efdfd0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!icmp_hdr) {
4001a9f0:	04050a63          	beqz	a0,4001aa44 <net_icmpv6_finalize+0x7c>
		return -ENOBUFS;
	}

	icmp_hdr->chksum = 0U;
4001a9f4:	00050123          	sb	zero,2(a0)
4001a9f8:	000501a3          	sb	zero,3(a0)
4001a9fc:	00050413          	mv	s0,a0
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
4001aa00:	0184a503          	lw	a0,24(s1)
4001aa04:	94cf90ef          	jal	ra,40013b50 <net_if_need_calc_tx_checksum>
4001aa08:	00050e63          	beqz	a0,4001aa24 <net_icmpv6_finalize+0x5c>
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
4001aa0c:	03a00593          	li	a1,58
4001aa10:	00048513          	mv	a0,s1
4001aa14:	cdcfa0ef          	jal	ra,40014ef0 <net_calc_chksum>
		icmp_hdr->chksum = net_calc_chksum_icmpv6(pkt);
4001aa18:	00855793          	srli	a5,a0,0x8
4001aa1c:	00a40123          	sb	a0,2(s0)
4001aa20:	00f401a3          	sb	a5,3(s0)
	}

	return net_pkt_set_data(pkt, &icmp_access);
4001aa24:	00810593          	addi	a1,sp,8
4001aa28:	00048513          	mv	a0,s1
4001aa2c:	f8dfd0ef          	jal	ra,400189b8 <net_pkt_set_data>
}
4001aa30:	01c12083          	lw	ra,28(sp)
4001aa34:	01812403          	lw	s0,24(sp)
4001aa38:	01412483          	lw	s1,20(sp)
4001aa3c:	02010113          	addi	sp,sp,32
4001aa40:	00008067          	ret
		return -ENOBUFS;
4001aa44:	f9700513          	li	a0,-105
4001aa48:	fe9ff06f          	j	4001aa30 <net_icmpv6_finalize+0x68>

4001aa4c <net_icmpv6_create>:

int net_icmpv6_create(struct net_pkt *pkt, uint8_t icmp_type, uint8_t icmp_code)
{
4001aa4c:	fe010113          	addi	sp,sp,-32
4001aa50:	01212823          	sw	s2,16(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
4001aa54:	00400793          	li	a5,4
{
4001aa58:	00058913          	mv	s2,a1
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
4001aa5c:	00810593          	addi	a1,sp,8
{
4001aa60:	00812c23          	sw	s0,24(sp)
4001aa64:	00912a23          	sw	s1,20(sp)
4001aa68:	00112e23          	sw	ra,28(sp)
4001aa6c:	00050413          	mv	s0,a0
4001aa70:	00060493          	mv	s1,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
4001aa74:	00012423          	sw	zero,8(sp)
4001aa78:	00f12623          	sw	a5,12(sp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
4001aa7c:	e6dfd0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!icmp_hdr) {
4001aa80:	02050c63          	beqz	a0,4001aab8 <net_icmpv6_create+0x6c>
		return -ENOBUFS;
	}

	icmp_hdr->type   = icmp_type;
4001aa84:	01250023          	sb	s2,0(a0)
	icmp_hdr->code   = icmp_code;
4001aa88:	009500a3          	sb	s1,1(a0)
	icmp_hdr->chksum = 0U;
4001aa8c:	00050123          	sb	zero,2(a0)
4001aa90:	000501a3          	sb	zero,3(a0)

	return net_pkt_set_data(pkt, &icmp_access);
4001aa94:	00810593          	addi	a1,sp,8
4001aa98:	00040513          	mv	a0,s0
4001aa9c:	f1dfd0ef          	jal	ra,400189b8 <net_pkt_set_data>
}
4001aaa0:	01c12083          	lw	ra,28(sp)
4001aaa4:	01812403          	lw	s0,24(sp)
4001aaa8:	01412483          	lw	s1,20(sp)
4001aaac:	01012903          	lw	s2,16(sp)
4001aab0:	02010113          	addi	sp,sp,32
4001aab4:	00008067          	ret
		return -ENOBUFS;
4001aab8:	f9700513          	li	a0,-105
4001aabc:	fe5ff06f          	j	4001aaa0 <net_icmpv6_create+0x54>

4001aac0 <icmpv6_handle_echo_request>:

static
enum net_verdict icmpv6_handle_echo_request(struct net_pkt *pkt,
					    struct net_ipv6_hdr *ip_hdr,
					    struct net_icmp_hdr *icmp_hdr)
{
4001aac0:	fe010113          	addi	sp,sp,-32
4001aac4:	00912a23          	sw	s1,20(sp)
4001aac8:	01312623          	sw	s3,12(sp)
4001aacc:	00112e23          	sw	ra,28(sp)
4001aad0:	00812c23          	sw	s0,24(sp)
4001aad4:	01212823          	sw	s2,16(sp)
	NET_DBG("Received Echo Request from %s to %s",
		net_sprint_ipv6_addr(&ip_hdr->src),
		net_sprint_ipv6_addr(&ip_hdr->dst));

	payload_len = ntohs(ip_hdr->len) -
		net_pkt_ipv6_ext_len(pkt) - NET_ICMPH_LEN;
4001aad8:	0055c703          	lbu	a4,5(a1)
4001aadc:	0045c783          	lbu	a5,4(a1)
{
4001aae0:	00050493          	mv	s1,a0
		net_pkt_ipv6_ext_len(pkt) - NET_ICMPH_LEN;
4001aae4:	00871713          	slli	a4,a4,0x8
4001aae8:	00f76733          	or	a4,a4,a5
4001aaec:	00871793          	slli	a5,a4,0x8
4001aaf0:	00875713          	srli	a4,a4,0x8
4001aaf4:	00e7e7b3          	or	a5,a5,a4
4001aaf8:	03a55703          	lhu	a4,58(a0)
4001aafc:	01852503          	lw	a0,24(a0)
4001ab00:	40e787b3          	sub	a5,a5,a4
4001ab04:	ffc78793          	addi	a5,a5,-4
4001ab08:	01079993          	slli	s3,a5,0x10
	if (payload_len < NET_ICMPV6_UNUSED_LEN) {
4001ab0c:	01079793          	slli	a5,a5,0x10
4001ab10:	4107d793          	srai	a5,a5,0x10
4001ab14:	00300713          	li	a4,3
4001ab18:	12f75663          	bge	a4,a5,4001ac44 <icmpv6_handle_echo_request+0x184>
4001ab1c:	0109d993          	srli	s3,s3,0x10
4001ab20:	00058913          	mv	s2,a1
		/* No identifier or sequence number present */
		goto drop;
	}

	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt), payload_len,
4001ab24:	06400713          	li	a4,100
4001ab28:	00000793          	li	a5,0
4001ab2c:	03a00693          	li	a3,58
4001ab30:	00200613          	li	a2,2
4001ab34:	00098593          	mv	a1,s3
4001ab38:	d50fd0ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
4001ab3c:	00050413          	mv	s0,a0
					  AF_INET6, IPPROTO_ICMPV6,
					  PKT_WAIT_TIME);
	if (!reply) {
4001ab40:	10050263          	beqz	a0,4001ac44 <icmpv6_handle_echo_request+0x184>
		NET_DBG("DROP: No buffer");
		goto drop;
	}

	if (net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst)) {
4001ab44:	01894703          	lbu	a4,24(s2)
4001ab48:	0ff00793          	li	a5,255
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
						  (struct in6_addr *)ip_hdr->dst);
4001ab4c:	01890593          	addi	a1,s2,24
	if (net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst)) {
4001ab50:	00f71863          	bne	a4,a5,4001ab60 <icmpv6_handle_echo_request+0xa0>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
4001ab54:	0184a503          	lw	a0,24(s1)
4001ab58:	930f80ef          	jal	ra,40012c88 <net_if_ipv6_select_src_addr>
4001ab5c:	00050593          	mv	a1,a0

	/* We must not set the destination ll address here but trust
	 * that it is set properly using a value from neighbor cache.
	 * Same for source as it points to original pkt ll src address.
	 */
	net_pkt_lladdr_dst(reply)->addr = NULL;
4001ab60:	02042623          	sw	zero,44(s0)
	net_pkt_lladdr_src(reply)->addr = NULL;
4001ab64:	02042223          	sw	zero,36(s0)
	return pkt->ip_dscp;
4001ab68:	0404a703          	lw	a4,64(s1)
	pkt->ip_dscp = dscp;
4001ab6c:	04044783          	lbu	a5,64(s0)

	net_pkt_set_ip_dscp(reply, net_pkt_ip_dscp(pkt));
	net_pkt_set_ip_ecn(reply, net_pkt_ip_ecn(pkt));

	if (net_ipv6_create(reply, src, (struct in6_addr *)ip_hdr->src)) {
4001ab70:	00890613          	addi	a2,s2,8
4001ab74:	03f77713          	andi	a4,a4,63
4001ab78:	fc07f793          	andi	a5,a5,-64
4001ab7c:	00e7e7b3          	or	a5,a5,a4
4001ab80:	04f40023          	sb	a5,64(s0)
	return pkt->ip_ecn;
4001ab84:	0404a703          	lw	a4,64(s1)
	pkt->ip_ecn = ecn;
4001ab88:	0ff7f793          	zext.b	a5,a5
4001ab8c:	03f7f793          	andi	a5,a5,63
4001ab90:	0c077713          	andi	a4,a4,192
4001ab94:	00e7e7b3          	or	a5,a5,a4
4001ab98:	04f40023          	sb	a5,64(s0)
4001ab9c:	00040513          	mv	a0,s0
4001aba0:	349000ef          	jal	ra,4001b6e8 <net_ipv6_create>
4001aba4:	08051c63          	bnez	a0,4001ac3c <icmpv6_handle_echo_request+0x17c>
		NET_DBG("DROP: wrong buffer");
		goto drop;
	}

	if (net_icmpv6_create(reply, NET_ICMPV6_ECHO_REPLY, 0) ||
4001aba8:	00000613          	li	a2,0
4001abac:	08100593          	li	a1,129
4001abb0:	00040513          	mv	a0,s0
4001abb4:	e99ff0ef          	jal	ra,4001aa4c <net_icmpv6_create>
4001abb8:	08051263          	bnez	a0,4001ac3c <icmpv6_handle_echo_request+0x17c>
	    net_pkt_copy(reply, pkt, payload_len)) {
4001abbc:	00098613          	mv	a2,s3
4001abc0:	00048593          	mv	a1,s1
4001abc4:	00040513          	mv	a0,s0
4001abc8:	fd4fd0ef          	jal	ra,4001839c <net_pkt_copy>
	if (net_icmpv6_create(reply, NET_ICMPV6_ECHO_REPLY, 0) ||
4001abcc:	06051863          	bnez	a0,4001ac3c <icmpv6_handle_echo_request+0x17c>
		NET_DBG("DROP: wrong buffer");
		goto drop;
	}

	net_pkt_cursor_init(reply);
4001abd0:	00040513          	mv	a0,s0
4001abd4:	f1dfc0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	net_ipv6_finalize(reply, IPPROTO_ICMPV6);
4001abd8:	03a00593          	li	a1,58
4001abdc:	00040513          	mv	a0,s0
4001abe0:	3fd000ef          	jal	ra,4001b7dc <net_ipv6_finalize>

	NET_DBG("Sending Echo Reply from %s to %s",
		net_sprint_ipv6_addr(src),
		net_sprint_ipv6_addr(&ip_hdr->src));

	if (net_send_data(reply) < 0) {
4001abe4:	00040513          	mv	a0,s0
4001abe8:	ac5f40ef          	jal	ra,4000f6ac <net_send_data>
4001abec:	04054863          	bltz	a0,4001ac3c <icmpv6_handle_echo_request+0x17c>
	UPDATE_STAT(iface, stats.icmp.sent++);
4001abf0:	4003b7b7          	lui	a5,0x4003b
4001abf4:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001abf8:	0487a703          	lw	a4,72(a5)
	return pkt->iface;
4001abfc:	01842683          	lw	a3,24(s0)
		goto drop;
	}

	net_stats_update_icmp_sent(net_pkt_iface(reply));

	net_pkt_unref(pkt);
4001ac00:	00048513          	mv	a0,s1
4001ac04:	00170713          	addi	a4,a4,1
4001ac08:	04e7a423          	sw	a4,72(a5)
4001ac0c:	04c6a783          	lw	a5,76(a3)
4001ac10:	00178793          	addi	a5,a5,1
4001ac14:	04f6a623          	sw	a5,76(a3)
4001ac18:	c05fc0ef          	jal	ra,4001781c <net_pkt_unref>

	return NET_OK;
4001ac1c:	00000513          	li	a0,0
	}

	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
4001ac20:	01c12083          	lw	ra,28(sp)
4001ac24:	01812403          	lw	s0,24(sp)
4001ac28:	01412483          	lw	s1,20(sp)
4001ac2c:	01012903          	lw	s2,16(sp)
4001ac30:	00c12983          	lw	s3,12(sp)
4001ac34:	02010113          	addi	sp,sp,32
4001ac38:	00008067          	ret
		net_pkt_unref(reply);
4001ac3c:	00040513          	mv	a0,s0
4001ac40:	bddfc0ef          	jal	ra,4001781c <net_pkt_unref>
	net_stats_update_icmp_drop(net_pkt_iface(pkt));
4001ac44:	0184a503          	lw	a0,24(s1)
4001ac48:	cddff0ef          	jal	ra,4001a924 <net_stats_update_icmp_drop>
	return NET_DROP;
4001ac4c:	00200513          	li	a0,2
4001ac50:	fd1ff06f          	j	4001ac20 <icmpv6_handle_echo_request+0x160>

4001ac54 <net_icmpv6_send_error>:

int net_icmpv6_send_error(struct net_pkt *orig, uint8_t type, uint8_t code,
			  uint32_t param)
{
4001ac54:	fd010113          	addi	sp,sp,-48
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
4001ac58:	02800793          	li	a5,40
{
4001ac5c:	02912223          	sw	s1,36(sp)
4001ac60:	01312e23          	sw	s3,28(sp)
4001ac64:	01512a23          	sw	s5,20(sp)
4001ac68:	01612823          	sw	s6,16(sp)
4001ac6c:	02112623          	sw	ra,44(sp)
4001ac70:	02812423          	sw	s0,40(sp)
4001ac74:	03212023          	sw	s2,32(sp)
4001ac78:	01412c23          	sw	s4,24(sp)
4001ac7c:	00050493          	mv	s1,a0
4001ac80:	00058a93          	mv	s5,a1
4001ac84:	00060b13          	mv	s6,a2
4001ac88:	00068993          	mv	s3,a3
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
4001ac8c:	00012023          	sw	zero,0(sp)
4001ac90:	00f12223          	sw	a5,4(sp)
	const struct in6_addr *src;
	struct net_pkt *pkt;
	size_t copy_len;
	int ret;

	net_pkt_cursor_init(orig);
4001ac94:	e5dfc0ef          	jal	ra,40017af0 <net_pkt_cursor_init>

	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);
4001ac98:	00010593          	mv	a1,sp
4001ac9c:	00048513          	mv	a0,s1
4001aca0:	c49fd0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!ip_hdr) {
4001aca4:	28050063          	beqz	a0,4001af24 <net_icmpv6_send_error+0x2d0>
		goto drop_no_pkt;
	}

	if (ip_hdr->nexthdr == IPPROTO_ICMPV6) {
4001aca8:	00654703          	lbu	a4,6(a0)
4001acac:	03a00793          	li	a5,58
4001acb0:	00050a13          	mv	s4,a0
4001acb4:	04f71663          	bne	a4,a5,4001ad00 <net_icmpv6_send_error+0xac>
	return net_pkt_skip(pkt, access->size);
4001acb8:	00412583          	lw	a1,4(sp)
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,
4001acbc:	00400793          	li	a5,4
4001acc0:	00048513          	mv	a0,s1
4001acc4:	00012423          	sw	zero,8(sp)
4001acc8:	00f12623          	sw	a5,12(sp)
4001accc:	c04fd0ef          	jal	ra,400180d0 <net_pkt_skip>
						      struct net_icmp_hdr);
		struct net_icmp_hdr *icmp_hdr;

		net_pkt_acknowledge_data(orig, &ipv6_access);

		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
4001acd0:	00810593          	addi	a1,sp,8
4001acd4:	00048513          	mv	a0,s1
4001acd8:	c11fd0ef          	jal	ra,400188e8 <net_pkt_get_data>
							orig, &icmpv6_access);
		if (!icmp_hdr || icmp_hdr->code < 128) {
4001acdc:	00050663          	beqz	a0,4001ace8 <net_icmpv6_send_error+0x94>
4001ace0:	00150783          	lb	a5,1(a0)
4001ace4:	0007ca63          	bltz	a5,4001acf8 <net_icmpv6_send_error+0xa4>
			/* We must not send ICMP errors back */
			err = -EINVAL;
4001ace8:	fea00993          	li	s3,-22

drop:
	net_pkt_unref(pkt);

drop_no_pkt:
	net_stats_update_icmp_drop(net_pkt_iface(orig));
4001acec:	0184a503          	lw	a0,24(s1)
4001acf0:	c35ff0ef          	jal	ra,4001a924 <net_stats_update_icmp_drop>

	return err;
4001acf4:	1f00006f          	j	4001aee4 <net_icmpv6_send_error+0x290>
		net_pkt_cursor_init(orig);
4001acf8:	00048513          	mv	a0,s1
4001acfc:	df5fc0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	if (ip_hdr->nexthdr == IPPROTO_UDP) {
4001ad00:	006a4783          	lbu	a5,6(s4)
4001ad04:	01100713          	li	a4,17
		copy_len = sizeof(struct net_ipv6_hdr) +
4001ad08:	03000513          	li	a0,48
	if (ip_hdr->nexthdr == IPPROTO_UDP) {
4001ad0c:	00e78e63          	beq	a5,a4,4001ad28 <net_icmpv6_send_error+0xd4>
	} else if (ip_hdr->nexthdr == IPPROTO_TCP) {
4001ad10:	00600713          	li	a4,6
		copy_len = sizeof(struct net_ipv6_hdr) +
4001ad14:	03c00513          	li	a0,60
	} else if (ip_hdr->nexthdr == IPPROTO_TCP) {
4001ad18:	00e78863          	beq	a5,a4,4001ad28 <net_icmpv6_send_error+0xd4>
		copy_len = net_pkt_get_len(orig);
4001ad1c:	0084a783          	lw	a5,8(s1)
	size_t bytes = 0;
4001ad20:	00000513          	li	a0,0
	while (buf) {
4001ad24:	0e079263          	bnez	a5,4001ae08 <net_icmpv6_send_error+0x1b4>
					net_pkt_lladdr_src(orig)->len * 2 +
4001ad28:	0284c583          	lbu	a1,40(s1)
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
4001ad2c:	06400713          	li	a4,100
4001ad30:	00000793          	li	a5,0
					net_pkt_lladdr_src(orig)->len * 2 +
4001ad34:	00159593          	slli	a1,a1,0x1
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
4001ad38:	00458593          	addi	a1,a1,4
4001ad3c:	00a585b3          	add	a1,a1,a0
4001ad40:	0184a503          	lw	a0,24(s1)
4001ad44:	03a00693          	li	a3,58
4001ad48:	00200613          	li	a2,2
4001ad4c:	b3cfd0ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
4001ad50:	00050413          	mv	s0,a0
	if (!pkt) {
4001ad54:	1c050c63          	beqz	a0,4001af2c <net_icmpv6_send_error+0x2d8>
	ret = net_pkt_write(pkt, net_pkt_lladdr_src(orig)->addr,
4001ad58:	0284c603          	lbu	a2,40(s1)
4001ad5c:	0244a583          	lw	a1,36(s1)
4001ad60:	b25fd0ef          	jal	ra,40018884 <net_pkt_write>
4001ad64:	00050913          	mv	s2,a0
	if (ret < 0) {
4001ad68:	08054863          	bltz	a0,4001adf8 <net_icmpv6_send_error+0x1a4>
	net_pkt_lladdr_dst(pkt)->addr = pkt->buffer->data;
4001ad6c:	00842783          	lw	a5,8(s0)
	ret = net_pkt_write(pkt, net_pkt_lladdr_dst(orig)->addr,
4001ad70:	00040513          	mv	a0,s0
	net_pkt_lladdr_dst(pkt)->addr = pkt->buffer->data;
4001ad74:	00c7a783          	lw	a5,12(a5)
4001ad78:	02f42623          	sw	a5,44(s0)
	ret = net_pkt_write(pkt, net_pkt_lladdr_dst(orig)->addr,
4001ad7c:	0304c603          	lbu	a2,48(s1)
4001ad80:	02c4a583          	lw	a1,44(s1)
4001ad84:	b01fd0ef          	jal	ra,40018884 <net_pkt_write>
4001ad88:	00050913          	mv	s2,a0
	if (ret < 0) {
4001ad8c:	06054663          	bltz	a0,4001adf8 <net_icmpv6_send_error+0x1a4>
	return net_buf_simple_pull_mem(&buf->b, len);
4001ad90:	00842503          	lw	a0,8(s0)
4001ad94:	0304c583          	lbu	a1,48(s1)
4001ad98:	00c50513          	addi	a0,a0,12
4001ad9c:	a89f20ef          	jal	ra,4000d824 <net_buf_simple_pull_mem>
	net_pkt_lladdr_src(pkt)->addr = pkt->buffer->data;
4001ada0:	00842503          	lw	a0,8(s0)
4001ada4:	00c52783          	lw	a5,12(a0)
4001ada8:	00c50513          	addi	a0,a0,12
4001adac:	02f42223          	sw	a5,36(s0)
4001adb0:	0284c583          	lbu	a1,40(s1)
4001adb4:	a71f20ef          	jal	ra,4000d824 <net_buf_simple_pull_mem>
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;
4001adb8:	0304c783          	lbu	a5,48(s1)
						  (struct in6_addr *)ip_hdr->dst);
4001adbc:	018a0593          	addi	a1,s4,24
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;
4001adc0:	02f40423          	sb	a5,40(s0)
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;
4001adc4:	0284c783          	lbu	a5,40(s1)
4001adc8:	02f40823          	sb	a5,48(s0)
	if (net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst)) {
4001adcc:	018a4703          	lbu	a4,24(s4)
4001add0:	0ff00793          	li	a5,255
4001add4:	00f71863          	bne	a4,a5,4001ade4 <net_icmpv6_send_error+0x190>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
4001add8:	01842503          	lw	a0,24(s0)
4001addc:	eadf70ef          	jal	ra,40012c88 <net_if_ipv6_select_src_addr>
4001ade0:	00050593          	mv	a1,a0
	if (net_ipv6_create(pkt, src, (struct in6_addr *)ip_hdr->src) ||
4001ade4:	008a0613          	addi	a2,s4,8
4001ade8:	00040513          	mv	a0,s0
4001adec:	0fd000ef          	jal	ra,4001b6e8 <net_ipv6_create>
4001adf0:	02050463          	beqz	a0,4001ae18 <net_icmpv6_send_error+0x1c4>
	int err = -EIO;
4001adf4:	ffb00913          	li	s2,-5
	net_pkt_unref(pkt);
4001adf8:	00040513          	mv	a0,s0
4001adfc:	a21fc0ef          	jal	ra,4001781c <net_pkt_unref>
4001ae00:	00090993          	mv	s3,s2
4001ae04:	ee9ff06f          	j	4001acec <net_icmpv6_send_error+0x98>
		bytes += buf->len;
4001ae08:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
4001ae0c:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4001ae10:	00e50533          	add	a0,a0,a4
		buf = buf->frags;
4001ae14:	f11ff06f          	j	4001ad24 <net_icmpv6_send_error+0xd0>
	    net_icmpv6_create(pkt, type, code)) {
4001ae18:	000b0613          	mv	a2,s6
4001ae1c:	000a8593          	mv	a1,s5
4001ae20:	00040513          	mv	a0,s0
4001ae24:	c29ff0ef          	jal	ra,4001aa4c <net_icmpv6_create>
	if (net_ipv6_create(pkt, src, (struct in6_addr *)ip_hdr->src) ||
4001ae28:	fc0516e3          	bnez	a0,4001adf4 <net_icmpv6_send_error+0x1a0>
	if (type == NET_ICMPV6_PARAM_PROBLEM) {
4001ae2c:	00400793          	li	a5,4
4001ae30:	0efa9063          	bne	s5,a5,4001af10 <net_icmpv6_send_error+0x2bc>
	uint32_t data_be32 = htonl(data);
4001ae34:	01899713          	slli	a4,s3,0x18
4001ae38:	0189d793          	srli	a5,s3,0x18
4001ae3c:	000106b7          	lui	a3,0x10
4001ae40:	00e7e7b3          	or	a5,a5,a4
4001ae44:	f0068693          	addi	a3,a3,-256 # ff00 <__kernel_ram_size+0x43f8>
4001ae48:	0089d713          	srli	a4,s3,0x8
4001ae4c:	00d77733          	and	a4,a4,a3
4001ae50:	00e7e7b3          	or	a5,a5,a4
4001ae54:	00899993          	slli	s3,s3,0x8
4001ae58:	00ff0737          	lui	a4,0xff0
4001ae5c:	00e9f9b3          	and	s3,s3,a4
4001ae60:	0137e7b3          	or	a5,a5,s3
	return net_pkt_write(pkt, &data_be32, sizeof(uint32_t));
4001ae64:	00400613          	li	a2,4
4001ae68:	00810593          	addi	a1,sp,8
4001ae6c:	00040513          	mv	a0,s0
	uint32_t data_be32 = htonl(data);
4001ae70:	00f12423          	sw	a5,8(sp)
	return net_pkt_write(pkt, &data_be32, sizeof(uint32_t));
4001ae74:	a11fd0ef          	jal	ra,40018884 <net_pkt_write>
		err = net_pkt_memset(pkt, 0, NET_ICMPV6_UNUSED_LEN);
4001ae78:	00050913          	mv	s2,a0
	copy_len = net_pkt_available_buffer(pkt);
4001ae7c:	00040513          	mv	a0,s0
4001ae80:	a99fc0ef          	jal	ra,40017918 <net_pkt_available_buffer>
4001ae84:	00050613          	mv	a2,a0
	if (err || net_pkt_copy(pkt, orig, copy_len)) {
4001ae88:	f60918e3          	bnez	s2,4001adf8 <net_icmpv6_send_error+0x1a4>
4001ae8c:	00048593          	mv	a1,s1
4001ae90:	00040513          	mv	a0,s0
4001ae94:	d08fd0ef          	jal	ra,4001839c <net_pkt_copy>
4001ae98:	00050993          	mv	s3,a0
4001ae9c:	f4051ee3          	bnez	a0,4001adf8 <net_icmpv6_send_error+0x1a4>
	net_pkt_cursor_init(pkt);
4001aea0:	00040513          	mv	a0,s0
4001aea4:	c4dfc0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
4001aea8:	03a00593          	li	a1,58
4001aeac:	00040513          	mv	a0,s0
4001aeb0:	12d000ef          	jal	ra,4001b7dc <net_ipv6_finalize>
	if (net_send_data(pkt) >= 0) {
4001aeb4:	00040513          	mv	a0,s0
4001aeb8:	ff4f40ef          	jal	ra,4000f6ac <net_send_data>
4001aebc:	f2054ee3          	bltz	a0,4001adf8 <net_icmpv6_send_error+0x1a4>
4001aec0:	4003b7b7          	lui	a5,0x4003b
4001aec4:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001aec8:	0487a703          	lw	a4,72(a5)
	return pkt->iface;
4001aecc:	01842683          	lw	a3,24(s0)
4001aed0:	00170713          	addi	a4,a4,1 # ff0001 <__rom_region_size+0xfb7045>
4001aed4:	04e7a423          	sw	a4,72(a5)
4001aed8:	04c6a783          	lw	a5,76(a3)
4001aedc:	00178793          	addi	a5,a5,1
4001aee0:	04f6a623          	sw	a5,76(a3)
}
4001aee4:	02c12083          	lw	ra,44(sp)
4001aee8:	02812403          	lw	s0,40(sp)
4001aeec:	02412483          	lw	s1,36(sp)
4001aef0:	02012903          	lw	s2,32(sp)
4001aef4:	01812a03          	lw	s4,24(sp)
4001aef8:	01412a83          	lw	s5,20(sp)
4001aefc:	01012b03          	lw	s6,16(sp)
4001af00:	00098513          	mv	a0,s3
4001af04:	01c12983          	lw	s3,28(sp)
4001af08:	03010113          	addi	sp,sp,48
4001af0c:	00008067          	ret
		err = net_pkt_memset(pkt, 0, NET_ICMPV6_UNUSED_LEN);
4001af10:	00400613          	li	a2,4
4001af14:	00000593          	li	a1,0
4001af18:	00040513          	mv	a0,s0
4001af1c:	bf4fd0ef          	jal	ra,40018310 <net_pkt_memset>
4001af20:	f59ff06f          	j	4001ae78 <net_icmpv6_send_error+0x224>
	int err = -EIO;
4001af24:	ffb00993          	li	s3,-5
4001af28:	dc5ff06f          	j	4001acec <net_icmpv6_send_error+0x98>
		err = -ENOMEM;
4001af2c:	ff400993          	li	s3,-12
4001af30:	dbdff06f          	j	4001acec <net_icmpv6_send_error+0x98>

4001af34 <net_icmpv6_send_echo_request>:
				 uint16_t identifier,
				 uint16_t sequence,
				 uint8_t tc,
				 const void *data,
				 size_t data_size)
{
4001af34:	fc010113          	addi	sp,sp,-64
4001af38:	03612023          	sw	s6,32(sp)
4001af3c:	00078b13          	mv	s6,a5
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,
4001af40:	00400793          	li	a5,4
{
4001af44:	02912a23          	sw	s1,52(sp)
4001af48:	03212823          	sw	s2,48(sp)
4001af4c:	03312623          	sw	s3,44(sp)
4001af50:	03412423          	sw	s4,40(sp)
4001af54:	03512223          	sw	s5,36(sp)
4001af58:	01712e23          	sw	s7,28(sp)
4001af5c:	01812c23          	sw	s8,24(sp)
4001af60:	02112e23          	sw	ra,60(sp)
4001af64:	02812c23          	sw	s0,56(sp)
4001af68:	00050a93          	mv	s5,a0
4001af6c:	00058c13          	mv	s8,a1
4001af70:	00060a13          	mv	s4,a2
4001af74:	00068493          	mv	s1,a3
4001af78:	00070993          	mv	s3,a4
4001af7c:	00080913          	mv	s2,a6
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,
4001af80:	00f12623          	sw	a5,12(sp)
4001af84:	00012423          	sw	zero,8(sp)
	int ret = -ENOBUFS;
	struct net_icmpv6_echo_req *echo_req;
	const struct in6_addr *src;
	struct net_pkt *pkt;

	src = net_if_ipv6_select_src_addr(iface, dst);
4001af88:	d01f70ef          	jal	ra,40012c88 <net_if_ipv6_select_src_addr>
4001af8c:	00050b93          	mv	s7,a0

	pkt = net_pkt_alloc_with_buffer(iface,
4001af90:	06400713          	li	a4,100
4001af94:	00000793          	li	a5,0
4001af98:	03a00693          	li	a3,58
4001af9c:	00200613          	li	a2,2
4001afa0:	00490593          	addi	a1,s2,4
4001afa4:	000a8513          	mv	a0,s5
4001afa8:	8e0fd0ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
					sizeof(struct net_icmpv6_echo_req)
					+ data_size,
					AF_INET6, IPPROTO_ICMPV6,
					PKT_WAIT_TIME);
	if (!pkt) {
4001afac:	1c050e63          	beqz	a0,4001b188 <net_icmpv6_send_echo_request+0x254>
	pkt->ip_dscp = dscp;
4001afb0:	00699793          	slli	a5,s3,0x6
4001afb4:	0029d993          	srli	s3,s3,0x2
4001afb8:	0137e7b3          	or	a5,a5,s3
4001afbc:	04f50023          	sb	a5,64(a0)
	}

	net_pkt_set_ip_dscp(pkt, net_ipv6_get_dscp(tc));
	net_pkt_set_ip_ecn(pkt, net_ipv6_get_ecn(tc));

	if (net_ipv6_create(pkt, src, dst) ||
4001afc0:	000c0613          	mv	a2,s8
4001afc4:	000b8593          	mv	a1,s7
4001afc8:	00050413          	mv	s0,a0
4001afcc:	71c000ef          	jal	ra,4001b6e8 <net_ipv6_create>
4001afd0:	00050a63          	beqz	a0,4001afe4 <net_icmpv6_send_echo_request+0xb0>
	int ret = -ENOBUFS;
4001afd4:	f9700993          	li	s3,-105
	net_stats_update_icmp_drop(iface);

	ret = -EIO;

drop:
	net_pkt_unref(pkt);
4001afd8:	00040513          	mv	a0,s0
4001afdc:	841fc0ef          	jal	ra,4001781c <net_pkt_unref>

	return ret;
4001afe0:	0d00006f          	j	4001b0b0 <net_icmpv6_send_echo_request+0x17c>
	    net_icmpv6_create(pkt, NET_ICMPV6_ECHO_REQUEST, 0)) {
4001afe4:	00000613          	li	a2,0
4001afe8:	08000593          	li	a1,128
4001afec:	00040513          	mv	a0,s0
4001aff0:	a5dff0ef          	jal	ra,4001aa4c <net_icmpv6_create>
4001aff4:	00050993          	mv	s3,a0
	if (net_ipv6_create(pkt, src, dst) ||
4001aff8:	fc051ee3          	bnez	a0,4001afd4 <net_icmpv6_send_echo_request+0xa0>
	echo_req = (struct net_icmpv6_echo_req *)net_pkt_get_data(
4001affc:	00810593          	addi	a1,sp,8
4001b000:	00040513          	mv	a0,s0
4001b004:	8e5fd0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!echo_req) {
4001b008:	fc0506e3          	beqz	a0,4001afd4 <net_icmpv6_send_echo_request+0xa0>
	echo_req->identifier = htons(identifier);
4001b00c:	008a1793          	slli	a5,s4,0x8
4001b010:	008a5a13          	srli	s4,s4,0x8
4001b014:	0147ea33          	or	s4,a5,s4
4001b018:	010a1793          	slli	a5,s4,0x10
4001b01c:	0107d793          	srli	a5,a5,0x10
4001b020:	0087d793          	srli	a5,a5,0x8
4001b024:	00f500a3          	sb	a5,1(a0)
	echo_req->sequence   = htons(sequence);
4001b028:	00849793          	slli	a5,s1,0x8
4001b02c:	0084d493          	srli	s1,s1,0x8
4001b030:	0097e4b3          	or	s1,a5,s1
4001b034:	01049793          	slli	a5,s1,0x10
4001b038:	0107d793          	srli	a5,a5,0x10
4001b03c:	0087d793          	srli	a5,a5,0x8
	echo_req->identifier = htons(identifier);
4001b040:	01450023          	sb	s4,0(a0)
	echo_req->sequence   = htons(sequence);
4001b044:	00950123          	sb	s1,2(a0)
4001b048:	00f501a3          	sb	a5,3(a0)
	net_pkt_set_data(pkt, &icmpv6_access);
4001b04c:	00810593          	addi	a1,sp,8
4001b050:	00040513          	mv	a0,s0
4001b054:	965fd0ef          	jal	ra,400189b8 <net_pkt_set_data>
	if (data != NULL && data_size > 0) {
4001b058:	080b0663          	beqz	s6,4001b0e4 <net_icmpv6_send_echo_request+0x1b0>
4001b05c:	00090a63          	beqz	s2,4001b070 <net_icmpv6_send_echo_request+0x13c>
		net_pkt_write(pkt, data, data_size);
4001b060:	00090613          	mv	a2,s2
4001b064:	000b0593          	mv	a1,s6
4001b068:	00040513          	mv	a0,s0
4001b06c:	819fd0ef          	jal	ra,40018884 <net_pkt_write>
	net_pkt_cursor_init(pkt);
4001b070:	00040513          	mv	a0,s0
4001b074:	a7dfc0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
4001b078:	03a00593          	li	a1,58
4001b07c:	00040513          	mv	a0,s0
4001b080:	75c000ef          	jal	ra,4001b7dc <net_ipv6_finalize>
	if (net_send_data(pkt) >= 0) {
4001b084:	00040513          	mv	a0,s0
4001b088:	e24f40ef          	jal	ra,4000f6ac <net_send_data>
4001b08c:	0e054663          	bltz	a0,4001b178 <net_icmpv6_send_echo_request+0x244>
4001b090:	4003b7b7          	lui	a5,0x4003b
4001b094:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001b098:	0487a703          	lw	a4,72(a5)
4001b09c:	00170713          	addi	a4,a4,1
4001b0a0:	04e7a423          	sw	a4,72(a5)
4001b0a4:	04caa783          	lw	a5,76(s5)
4001b0a8:	00178793          	addi	a5,a5,1
4001b0ac:	04faa623          	sw	a5,76(s5)
}
4001b0b0:	03c12083          	lw	ra,60(sp)
4001b0b4:	03812403          	lw	s0,56(sp)
4001b0b8:	03412483          	lw	s1,52(sp)
4001b0bc:	03012903          	lw	s2,48(sp)
4001b0c0:	02812a03          	lw	s4,40(sp)
4001b0c4:	02412a83          	lw	s5,36(sp)
4001b0c8:	02012b03          	lw	s6,32(sp)
4001b0cc:	01c12b83          	lw	s7,28(sp)
4001b0d0:	01812c03          	lw	s8,24(sp)
4001b0d4:	00098513          	mv	a0,s3
4001b0d8:	02c12983          	lw	s3,44(sp)
4001b0dc:	04010113          	addi	sp,sp,64
4001b0e0:	00008067          	ret
	} else if (data == NULL && data_size > 0) {
4001b0e4:	f80906e3          	beqz	s2,4001b070 <net_icmpv6_send_echo_request+0x13c>
		if (data_size >= sizeof(uint32_t)) {
4001b0e8:	00300793          	li	a5,3
4001b0ec:	0727f463          	bgeu	a5,s2,4001b154 <net_icmpv6_send_echo_request+0x220>
4001b0f0:	679110ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
4001b0f4:	00050493          	mv	s1,a0
4001b0f8:	671110ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
4001b0fc:	00050b13          	mv	s6,a0
4001b100:	669110ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
4001b104:	00050a13          	mv	s4,a0
4001b108:	661110ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
			uint32_t time_stamp = htonl(k_cycle_get_32());
4001b10c:	000107b7          	lui	a5,0x10
4001b110:	01851513          	slli	a0,a0,0x18
4001b114:	f0078793          	addi	a5,a5,-256 # ff00 <__kernel_ram_size+0x43f8>
4001b118:	0184d493          	srli	s1,s1,0x18
4001b11c:	008b5b13          	srli	s6,s6,0x8
4001b120:	00a4e4b3          	or	s1,s1,a0
4001b124:	00fb7b33          	and	s6,s6,a5
4001b128:	008a1a13          	slli	s4,s4,0x8
4001b12c:	00ff07b7          	lui	a5,0xff0
4001b130:	00fa7a33          	and	s4,s4,a5
4001b134:	0164e4b3          	or	s1,s1,s6
4001b138:	0144e4b3          	or	s1,s1,s4
			net_pkt_write(pkt, &time_stamp, sizeof(time_stamp));
4001b13c:	00400613          	li	a2,4
4001b140:	00410593          	addi	a1,sp,4
4001b144:	00040513          	mv	a0,s0
			uint32_t time_stamp = htonl(k_cycle_get_32());
4001b148:	00912223          	sw	s1,4(sp)
			data_size -= sizeof(time_stamp);
4001b14c:	ffc90913          	addi	s2,s2,-4
			net_pkt_write(pkt, &time_stamp, sizeof(time_stamp));
4001b150:	f34fd0ef          	jal	ra,40018884 <net_pkt_write>
		for (size_t i = 0; i < data_size; i++) {
4001b154:	00000493          	li	s1,0
4001b158:	f0990ce3          	beq	s2,s1,4001b070 <net_icmpv6_send_echo_request+0x13c>
	return net_pkt_write(pkt, &data, sizeof(uint8_t));
4001b15c:	00100613          	li	a2,1
4001b160:	00410593          	addi	a1,sp,4
4001b164:	00040513          	mv	a0,s0
4001b168:	00910223          	sb	s1,4(sp)
4001b16c:	f18fd0ef          	jal	ra,40018884 <net_pkt_write>
4001b170:	00148493          	addi	s1,s1,1
4001b174:	fe5ff06f          	j	4001b158 <net_icmpv6_send_echo_request+0x224>
	net_stats_update_icmp_drop(iface);
4001b178:	000a8513          	mv	a0,s5
4001b17c:	fa8ff0ef          	jal	ra,4001a924 <net_stats_update_icmp_drop>
	ret = -EIO;
4001b180:	ffb00993          	li	s3,-5
4001b184:	e55ff06f          	j	4001afd8 <net_icmpv6_send_echo_request+0xa4>
		return -ENOMEM;
4001b188:	ff400993          	li	s3,-12
4001b18c:	f25ff06f          	j	4001b0b0 <net_icmpv6_send_echo_request+0x17c>

4001b190 <net_icmpv6_input>:

enum net_verdict net_icmpv6_input(struct net_pkt *pkt,
				  struct net_ipv6_hdr *ip_hdr)
{
4001b190:	fe010113          	addi	sp,sp,-32
4001b194:	01212823          	sw	s2,16(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
4001b198:	00400793          	li	a5,4
{
4001b19c:	00058913          	mv	s2,a1
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;
	struct net_icmpv6_handler *cb;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
4001b1a0:	00810593          	addi	a1,sp,8
{
4001b1a4:	00812c23          	sw	s0,24(sp)
4001b1a8:	00112e23          	sw	ra,28(sp)
4001b1ac:	00912a23          	sw	s1,20(sp)
4001b1b0:	00050413          	mv	s0,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
4001b1b4:	00012423          	sw	zero,8(sp)
4001b1b8:	00f12623          	sw	a5,12(sp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
4001b1bc:	f2cfd0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!icmp_hdr) {
4001b1c0:	0a050863          	beqz	a0,4001b270 <net_icmpv6_input+0xe0>
4001b1c4:	00050493          	mv	s1,a0
		NET_DBG("DROP: NULL ICMPv6 header");
		return NET_DROP;
	}


	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
4001b1c8:	01842503          	lw	a0,24(s0)
4001b1cc:	98df80ef          	jal	ra,40013b58 <net_if_need_calc_rx_checksum>
4001b1d0:	08051463          	bnez	a0,4001b258 <net_icmpv6_input+0xc8>
	return net_pkt_skip(pkt, access->size);
4001b1d4:	00c12583          	lw	a1,12(sp)
4001b1d8:	00040513          	mv	a0,s0
4001b1dc:	ef5fc0ef          	jal	ra,400180d0 <net_pkt_skip>
	UPDATE_STAT(iface, stats.icmp.recv++);
4001b1e0:	4003b7b7          	lui	a5,0x4003b
4001b1e4:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001b1e8:	0447a703          	lw	a4,68(a5)
	return pkt->iface;
4001b1ec:	01842683          	lw	a3,24(s0)
4001b1f0:	00170713          	addi	a4,a4,1
4001b1f4:	04e7a223          	sw	a4,68(a5)
4001b1f8:	0486a783          	lw	a5,72(a3)
4001b1fc:	00178793          	addi	a5,a5,1
4001b200:	04f6a423          	sw	a5,72(a3)
	return list->head;
4001b204:	400397b7          	lui	a5,0x40039
4001b208:	0a47a783          	lw	a5,164(a5) # 400390a4 <handlers>
		net_icmpv6_type2str(icmp_hdr->type),
		icmp_hdr->type, icmp_hdr->code);

	net_stats_update_icmp_recv(net_pkt_iface(pkt));

	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
4001b20c:	04078e63          	beqz	a5,4001b268 <net_icmpv6_input+0xd8>
		if (cb->type == icmp_hdr->type &&
4001b210:	0087c683          	lbu	a3,8(a5)
4001b214:	0004c703          	lbu	a4,0(s1)
4001b218:	06e69063          	bne	a3,a4,4001b278 <net_icmpv6_input+0xe8>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
4001b21c:	0097c703          	lbu	a4,9(a5)
		if (cb->type == icmp_hdr->type &&
4001b220:	0014c683          	lbu	a3,1(s1)
4001b224:	00e68463          	beq	a3,a4,4001b22c <net_icmpv6_input+0x9c>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
4001b228:	04071863          	bnez	a4,4001b278 <net_icmpv6_input+0xe8>
			return cb->handler(pkt, ip_hdr, icmp_hdr);
4001b22c:	0047a783          	lw	a5,4(a5)
4001b230:	00048613          	mv	a2,s1
4001b234:	00090593          	mv	a1,s2
4001b238:	00040513          	mv	a0,s0
4001b23c:	000780e7          	jalr	a5
	}
drop:
	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
4001b240:	01c12083          	lw	ra,28(sp)
4001b244:	01812403          	lw	s0,24(sp)
4001b248:	01412483          	lw	s1,20(sp)
4001b24c:	01012903          	lw	s2,16(sp)
4001b250:	02010113          	addi	sp,sp,32
4001b254:	00008067          	ret
4001b258:	03a00593          	li	a1,58
4001b25c:	00040513          	mv	a0,s0
4001b260:	c91f90ef          	jal	ra,40014ef0 <net_calc_chksum>
		if (net_calc_chksum_icmpv6(pkt) != 0U) {
4001b264:	f60508e3          	beqz	a0,4001b1d4 <net_icmpv6_input+0x44>
	net_stats_update_icmp_drop(net_pkt_iface(pkt));
4001b268:	01842503          	lw	a0,24(s0)
4001b26c:	eb8ff0ef          	jal	ra,4001a924 <net_stats_update_icmp_drop>
		return NET_DROP;
4001b270:	00200513          	li	a0,2
4001b274:	fcdff06f          	j	4001b240 <net_icmpv6_input+0xb0>
	return node->next;
4001b278:	0007a783          	lw	a5,0(a5)
4001b27c:	f91ff06f          	j	4001b20c <net_icmpv6_input+0x7c>

4001b280 <net_icmpv6_init>:
	.handler = icmpv6_handle_echo_request,
};

void net_icmpv6_init(void)
{
	net_icmpv6_register_handler(&echo_request_handler);
4001b280:	40044537          	lui	a0,0x40044
4001b284:	05c50513          	addi	a0,a0,92 # 4004405c <echo_request_handler>
4001b288:	ec0ff06f          	j	4001a948 <net_icmpv6_register_handler>

4001b28c <net_nbr_unref>:
#if defined(CONFIG_NET_IPV6_NBR_CACHE_LOG_LEVEL_DBG)
	NET_DBG("nbr %p ref %u (%s():%d)", nbr, nbr->ref - 1, caller, line);
#else
	NET_DBG("nbr %p ref %u", nbr, nbr->ref - 1);
#endif
	if (--nbr->ref) {
4001b28c:	00054783          	lbu	a5,0(a0)
4001b290:	fff78793          	addi	a5,a5,-1
4001b294:	0ff7f793          	zext.b	a5,a5
4001b298:	00f50023          	sb	a5,0(a0)
4001b29c:	00079863          	bnez	a5,4001b2ac <net_nbr_unref+0x20>
		return;
	}

	if (nbr->remove) {
4001b2a0:	01052783          	lw	a5,16(a0)
4001b2a4:	00078463          	beqz	a5,4001b2ac <net_nbr_unref+0x20>
		nbr->remove(nbr);
4001b2a8:	00078067          	jr	a5
	}
}
4001b2ac:	00008067          	ret

4001b2b0 <net_nbr_ref>:
#if defined(CONFIG_NET_IPV6_NBR_CACHE_LOG_LEVEL_DBG)
	NET_DBG("nbr %p ref %u (%s():%d)", nbr, nbr->ref + 1, caller, line);
#else
	NET_DBG("nbr %p ref %u", nbr, nbr->ref + 1);
#endif
	nbr->ref++;
4001b2b0:	00054703          	lbu	a4,0(a0)
4001b2b4:	00170713          	addi	a4,a4,1
4001b2b8:	00e50023          	sb	a4,0(a0)

	return nbr;
}
4001b2bc:	00008067          	ret

4001b2c0 <net_nbr_get>:

struct net_nbr *net_nbr_get(struct net_nbr_table *table)
{
	int i;

	for (i = 0; i < table->nbr_count; i++) {
4001b2c0:	00855583          	lhu	a1,8(a0)
{
4001b2c4:	00050613          	mv	a2,a0
	for (i = 0; i < table->nbr_count; i++) {
4001b2c8:	00000693          	li	a3,0
4001b2cc:	00b6c663          	blt	a3,a1,4001b2d8 <net_nbr_get+0x18>

			return net_nbr_ref(nbr);
		}
	}

	return NULL;
4001b2d0:	00000513          	li	a0,0
}
4001b2d4:	00008067          	ret
		struct net_nbr *nbr = get_nbr(table->nbr, i);
4001b2d8:	00062783          	lw	a5,0(a2)
			  start->size + start->extra_data_size) * idx));
4001b2dc:	0047d503          	lhu	a0,4(a5)
4001b2e0:	0027d703          	lhu	a4,2(a5)
4001b2e4:	00a70733          	add	a4,a4,a0
4001b2e8:	01470713          	addi	a4,a4,20
4001b2ec:	02d70733          	mul	a4,a4,a3
	return (struct net_nbr *)((uint8_t *)start +
4001b2f0:	00e78533          	add	a0,a5,a4
		if (!nbr->ref) {
4001b2f4:	00054783          	lbu	a5,0(a0)
4001b2f8:	00079c63          	bnez	a5,4001b310 <net_nbr_get+0x50>
			nbr->data = nbr->__nbr;
4001b2fc:	01450793          	addi	a5,a0,20
4001b300:	00f52623          	sw	a5,12(a0)
	nbr->ref++;
4001b304:	00100793          	li	a5,1
4001b308:	00f50023          	sb	a5,0(a0)
			return net_nbr_ref(nbr);
4001b30c:	00008067          	ret
	for (i = 0; i < table->nbr_count; i++) {
4001b310:	00168693          	addi	a3,a3,1
4001b314:	fb9ff06f          	j	4001b2cc <net_nbr_get+0xc>

4001b318 <net_nbr_link>:
int net_nbr_link(struct net_nbr *nbr, struct net_if *iface,
		 const struct net_linkaddr *lladdr)
{
	int i, avail = -1;

	if (nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
4001b318:	00154703          	lbu	a4,1(a0)
4001b31c:	0ff00793          	li	a5,255
4001b320:	14f71863          	bne	a4,a5,4001b470 <net_nbr_link+0x158>
{
4001b324:	fd010113          	addi	sp,sp,-48
4001b328:	02812423          	sw	s0,40(sp)
4001b32c:	4003b437          	lui	s0,0x4003b
4001b330:	02912223          	sw	s1,36(sp)
4001b334:	03212023          	sw	s2,32(sp)
4001b338:	01312e23          	sw	s3,28(sp)
4001b33c:	01412c23          	sw	s4,24(sp)
4001b340:	01512a23          	sw	s5,20(sp)
4001b344:	01612823          	sw	s6,16(sp)
4001b348:	01712623          	sw	s7,12(sp)
4001b34c:	01812423          	sw	s8,8(sp)
4001b350:	e5840b13          	addi	s6,s0,-424 # 4003ae58 <net_neighbor_lladdr>
4001b354:	02112623          	sw	ra,44(sp)
4001b358:	00050993          	mv	s3,a0
4001b35c:	00058a93          	mv	s5,a1
4001b360:	00060493          	mv	s1,a2
	int i, avail = -1;
4001b364:	fff00913          	li	s2,-1
		return -EALREADY;
	}

	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001b368:	00000a13          	li	s4,0
4001b36c:	e5840413          	addi	s0,s0,-424
		if (avail < 0 && !net_neighbor_lladdr[i].ref) {
4001b370:	fff00c13          	li	s8,-1
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001b374:	00800b93          	li	s7,8
		if (avail < 0 && !net_neighbor_lladdr[i].ref) {
4001b378:	008b4783          	lbu	a5,8(s6)
4001b37c:	07891863          	bne	s2,s8,4001b3ec <net_nbr_link+0xd4>
4001b380:	0e078463          	beqz	a5,4001b468 <net_nbr_link+0x150>
			avail = i;
		}

		if (net_neighbor_lladdr[i].ref &&
		    !memcmp(lladdr->addr,
4001b384:	0044c603          	lbu	a2,4(s1)
4001b388:	0004a503          	lw	a0,0(s1)
4001b38c:	002b0593          	addi	a1,s6,2
4001b390:	8e9f10ef          	jal	ra,4000cc78 <memcmp>
		if (net_neighbor_lladdr[i].ref &&
4001b394:	04051e63          	bnez	a0,4001b3f0 <net_nbr_link+0xd8>
			    net_neighbor_lladdr[i].lladdr.addr,
			    lladdr->len)) {
			/* We found same lladdr in nbr cache so just
			 * increase the ref count.
			 */
			net_neighbor_lladdr[i].ref++;
4001b398:	00900793          	li	a5,9
4001b39c:	02fa07b3          	mul	a5,s4,a5
4001b3a0:	00f407b3          	add	a5,s0,a5
4001b3a4:	0087c703          	lbu	a4,8(a5)
4001b3a8:	00170713          	addi	a4,a4,1
4001b3ac:	00e78423          	sb	a4,8(a5)

			nbr->idx = i;
4001b3b0:	014980a3          	sb	s4,1(s3)
	net_linkaddr_set(&net_neighbor_lladdr[avail].lladdr, lladdr->addr,
			 lladdr->len);
	net_neighbor_lladdr[avail].lladdr.len = lladdr->len;
	net_neighbor_lladdr[avail].lladdr.type = lladdr->type;

	nbr->iface = iface;
4001b3b4:	0159a423          	sw	s5,8(s3)
			return 0;
4001b3b8:	00000513          	li	a0,0

	return 0;
}
4001b3bc:	02c12083          	lw	ra,44(sp)
4001b3c0:	02812403          	lw	s0,40(sp)
4001b3c4:	02412483          	lw	s1,36(sp)
4001b3c8:	02012903          	lw	s2,32(sp)
4001b3cc:	01c12983          	lw	s3,28(sp)
4001b3d0:	01812a03          	lw	s4,24(sp)
4001b3d4:	01412a83          	lw	s5,20(sp)
4001b3d8:	01012b03          	lw	s6,16(sp)
4001b3dc:	00c12b83          	lw	s7,12(sp)
4001b3e0:	00812c03          	lw	s8,8(sp)
4001b3e4:	03010113          	addi	sp,sp,48
4001b3e8:	00008067          	ret
		if (net_neighbor_lladdr[i].ref &&
4001b3ec:	f8079ce3          	bnez	a5,4001b384 <net_nbr_link+0x6c>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001b3f0:	001a0a13          	addi	s4,s4,1
4001b3f4:	009b0b13          	addi	s6,s6,9
4001b3f8:	f97a10e3          	bne	s4,s7,4001b378 <net_nbr_link+0x60>
	if (avail < 0) {
4001b3fc:	fff00793          	li	a5,-1
		return -ENOENT;
4001b400:	ffe00513          	li	a0,-2
	if (avail < 0) {
4001b404:	faf90ce3          	beq	s2,a5,4001b3bc <net_nbr_link+0xa4>
	net_neighbor_lladdr[avail].ref++;
4001b408:	00900513          	li	a0,9
4001b40c:	02a90533          	mul	a0,s2,a0
4001b410:	00a407b3          	add	a5,s0,a0
4001b414:	0087c703          	lbu	a4,8(a5)
4001b418:	00170713          	addi	a4,a4,1
4001b41c:	00e78423          	sb	a4,8(a5)
	nbr->idx = avail;
4001b420:	012980a3          	sb	s2,1(s3)
	net_linkaddr_set(&net_neighbor_lladdr[avail].lladdr, lladdr->addr,
4001b424:	0004a583          	lw	a1,0(s1)
			 lladdr->len);
4001b428:	0044c603          	lbu	a2,4(s1)
	if (!lladdr_store || !new_addr) {
4001b42c:	00058e63          	beqz	a1,4001b448 <net_nbr_link+0x130>
	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
4001b430:	00600713          	li	a4,6
4001b434:	00c76a63          	bltu	a4,a2,4001b448 <net_nbr_link+0x130>
	memcpy(lladdr_store->addr, new_addr, new_len);
4001b438:	00250513          	addi	a0,a0,2
4001b43c:	00a40533          	add	a0,s0,a0
	lladdr_store->len = new_len;
4001b440:	00c780a3          	sb	a2,1(a5)
	memcpy(lladdr_store->addr, new_addr, new_len);
4001b444:	8b5f10ef          	jal	ra,4000ccf8 <memcpy>
	net_neighbor_lladdr[avail].lladdr.len = lladdr->len;
4001b448:	00900713          	li	a4,9
4001b44c:	02e90933          	mul	s2,s2,a4
4001b450:	0044c783          	lbu	a5,4(s1)
4001b454:	01240433          	add	s0,s0,s2
4001b458:	00f400a3          	sb	a5,1(s0)
	net_neighbor_lladdr[avail].lladdr.type = lladdr->type;
4001b45c:	0054c783          	lbu	a5,5(s1)
4001b460:	00f40023          	sb	a5,0(s0)
	return 0;
4001b464:	f51ff06f          	j	4001b3b4 <net_nbr_link+0x9c>
4001b468:	000a0913          	mv	s2,s4
4001b46c:	f85ff06f          	j	4001b3f0 <net_nbr_link+0xd8>
		return -EALREADY;
4001b470:	f8800513          	li	a0,-120
}
4001b474:	00008067          	ret

4001b478 <net_nbr_unlink>:

int net_nbr_unlink(struct net_nbr *nbr, struct net_linkaddr *lladdr)
{
	ARG_UNUSED(lladdr);

	if (nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
4001b478:	00154783          	lbu	a5,1(a0)
4001b47c:	0ff00713          	li	a4,255
4001b480:	06e78e63          	beq	a5,a4,4001b4fc <net_nbr_unlink+0x84>
	}

	NET_ASSERT(nbr->idx < CONFIG_NET_IPV6_MAX_NEIGHBORS);
	NET_ASSERT(net_neighbor_lladdr[nbr->idx].ref > 0);

	net_neighbor_lladdr[nbr->idx].ref--;
4001b484:	00900693          	li	a3,9
4001b488:	02d787b3          	mul	a5,a5,a3
{
4001b48c:	ff010113          	addi	sp,sp,-16
4001b490:	00812423          	sw	s0,8(sp)
4001b494:	00050413          	mv	s0,a0
	net_neighbor_lladdr[nbr->idx].ref--;
4001b498:	4003b537          	lui	a0,0x4003b
4001b49c:	e5850513          	addi	a0,a0,-424 # 4003ae58 <net_neighbor_lladdr>
{
4001b4a0:	00112623          	sw	ra,12(sp)
	net_neighbor_lladdr[nbr->idx].ref--;
4001b4a4:	00f507b3          	add	a5,a0,a5
4001b4a8:	0087c703          	lbu	a4,8(a5)
4001b4ac:	fff70713          	addi	a4,a4,-1
4001b4b0:	00e78423          	sb	a4,8(a5)

	if (!net_neighbor_lladdr[nbr->idx].ref) {
4001b4b4:	00144783          	lbu	a5,1(s0)
4001b4b8:	02d787b3          	mul	a5,a5,a3
4001b4bc:	00f50733          	add	a4,a0,a5
4001b4c0:	00874703          	lbu	a4,8(a4)
4001b4c4:	00071c63          	bnez	a4,4001b4dc <net_nbr_unlink+0x64>
		(void)memset(net_neighbor_lladdr[nbr->idx].lladdr.addr, 0,
4001b4c8:	00278793          	addi	a5,a5,2
4001b4cc:	00600613          	li	a2,6
4001b4d0:	00000593          	li	a1,0
4001b4d4:	00f50533          	add	a0,a0,a5
4001b4d8:	845f10ef          	jal	ra,4000cd1c <memset>
			     sizeof(net_neighbor_lladdr[nbr->idx].lladdr.addr));
	}

	nbr->idx = NET_NBR_LLADDR_UNKNOWN;
4001b4dc:	fff00793          	li	a5,-1
4001b4e0:	00f400a3          	sb	a5,1(s0)
	nbr->iface = NULL;
4001b4e4:	00042423          	sw	zero,8(s0)

	return 0;
}
4001b4e8:	00c12083          	lw	ra,12(sp)
4001b4ec:	00812403          	lw	s0,8(sp)
	return 0;
4001b4f0:	00000513          	li	a0,0
}
4001b4f4:	01010113          	addi	sp,sp,16
4001b4f8:	00008067          	ret
		return -EALREADY;
4001b4fc:	f8800513          	li	a0,-120
}
4001b500:	00008067          	ret

4001b504 <net_nbr_get_lladdr>:
{
	NET_ASSERT(idx < CONFIG_NET_IPV6_MAX_NEIGHBORS,
		   "idx %d >= max %d", idx,
		   CONFIG_NET_IPV6_MAX_NEIGHBORS);

	return &net_neighbor_lladdr[idx].lladdr;
4001b504:	00900793          	li	a5,9
4001b508:	02f50533          	mul	a0,a0,a5
}
4001b50c:	4003b7b7          	lui	a5,0x4003b
4001b510:	e5878793          	addi	a5,a5,-424 # 4003ae58 <net_neighbor_lladdr>
4001b514:	00a78533          	add	a0,a5,a0
4001b518:	00008067          	ret

4001b51c <net_ipv6_is_addr_loopback>:
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001b51c:	00154703          	lbu	a4,1(a0)
4001b520:	00054683          	lbu	a3,0(a0)
{
4001b524:	00050793          	mv	a5,a0
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001b528:	00871713          	slli	a4,a4,0x8
4001b52c:	00d76733          	or	a4,a4,a3
4001b530:	00254683          	lbu	a3,2(a0)
4001b534:	01069693          	slli	a3,a3,0x10
4001b538:	00e6e6b3          	or	a3,a3,a4
4001b53c:	00354703          	lbu	a4,3(a0)
4001b540:	01871713          	slli	a4,a4,0x18
4001b544:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001b548:	0c071263          	bnez	a4,4001b60c <net_ipv6_is_addr_loopback+0xf0>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001b54c:	00554703          	lbu	a4,5(a0)
4001b550:	00454683          	lbu	a3,4(a0)
4001b554:	00871713          	slli	a4,a4,0x8
4001b558:	00d76733          	or	a4,a4,a3
4001b55c:	00654683          	lbu	a3,6(a0)
4001b560:	01069693          	slli	a3,a3,0x10
4001b564:	00e6e6b3          	or	a3,a3,a4
4001b568:	00754703          	lbu	a4,7(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001b56c:	00000513          	li	a0,0
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001b570:	01871713          	slli	a4,a4,0x18
4001b574:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001b578:	08071c63          	bnez	a4,4001b610 <net_ipv6_is_addr_loopback+0xf4>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001b57c:	0097c703          	lbu	a4,9(a5)
4001b580:	0087c683          	lbu	a3,8(a5)
4001b584:	00871713          	slli	a4,a4,0x8
4001b588:	00d76733          	or	a4,a4,a3
4001b58c:	00a7c683          	lbu	a3,10(a5)
4001b590:	01069693          	slli	a3,a3,0x10
4001b594:	00e6e6b3          	or	a3,a3,a4
4001b598:	00b7c703          	lbu	a4,11(a5)
4001b59c:	01871713          	slli	a4,a4,0x18
4001b5a0:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001b5a4:	06071663          	bnez	a4,4001b610 <net_ipv6_is_addr_loopback+0xf4>
		ntohl(UNALIGNED_GET(&addr->s6_addr32[3])) == 1;
4001b5a8:	00d7c683          	lbu	a3,13(a5)
4001b5ac:	00c7c703          	lbu	a4,12(a5)
4001b5b0:	00869693          	slli	a3,a3,0x8
4001b5b4:	00e6e6b3          	or	a3,a3,a4
4001b5b8:	00e7c703          	lbu	a4,14(a5)
4001b5bc:	00f7c783          	lbu	a5,15(a5)
4001b5c0:	01071713          	slli	a4,a4,0x10
4001b5c4:	01879793          	slli	a5,a5,0x18
4001b5c8:	00d76733          	or	a4,a4,a3
4001b5cc:	00e7e6b3          	or	a3,a5,a4
4001b5d0:	0187d513          	srli	a0,a5,0x18
4001b5d4:	01871713          	slli	a4,a4,0x18
4001b5d8:	00e56533          	or	a0,a0,a4
4001b5dc:	00010737          	lui	a4,0x10
4001b5e0:	0086d793          	srli	a5,a3,0x8
4001b5e4:	f0070713          	addi	a4,a4,-256 # ff00 <__kernel_ram_size+0x43f8>
4001b5e8:	00e7f7b3          	and	a5,a5,a4
4001b5ec:	00f56533          	or	a0,a0,a5
4001b5f0:	00869693          	slli	a3,a3,0x8
4001b5f4:	00ff07b7          	lui	a5,0xff0
4001b5f8:	00f6f6b3          	and	a3,a3,a5
4001b5fc:	00d56533          	or	a0,a0,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001b600:	fff50513          	addi	a0,a0,-1
4001b604:	00153513          	seqz	a0,a0
4001b608:	00008067          	ret
4001b60c:	00000513          	li	a0,0
}
4001b610:	00008067          	ret

4001b614 <net_ipv6_is_addr_mcast_group>:
	return UNALIGNED_GET(&addr->s6_addr16[1]) == group->s6_addr16[1] &&
4001b614:	00354703          	lbu	a4,3(a0)
4001b618:	00254603          	lbu	a2,2(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
4001b61c:	0025d683          	lhu	a3,2(a1)
	return UNALIGNED_GET(&addr->s6_addr16[1]) == group->s6_addr16[1] &&
4001b620:	00871713          	slli	a4,a4,0x8
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
4001b624:	00c76733          	or	a4,a4,a2
{
4001b628:	00050793          	mv	a5,a0
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
4001b62c:	00000513          	li	a0,0
4001b630:	0ae69a63          	bne	a3,a4,4001b6e4 <net_ipv6_is_addr_mcast_group+0xd0>
		UNALIGNED_GET(&addr->s6_addr16[2]) == group->s6_addr16[2] &&
4001b634:	0057c703          	lbu	a4,5(a5) # ff0005 <__rom_region_size+0xfb7049>
4001b638:	0047c683          	lbu	a3,4(a5)
	return UNALIGNED_GET(&addr->s6_addr16[1]) == group->s6_addr16[1] &&
4001b63c:	0045d603          	lhu	a2,4(a1)
		UNALIGNED_GET(&addr->s6_addr16[2]) == group->s6_addr16[2] &&
4001b640:	00871713          	slli	a4,a4,0x8
4001b644:	00d76833          	or	a6,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
4001b648:	00000513          	li	a0,0
	return UNALIGNED_GET(&addr->s6_addr16[1]) == group->s6_addr16[1] &&
4001b64c:	09061c63          	bne	a2,a6,4001b6e4 <net_ipv6_is_addr_mcast_group+0xd0>
		UNALIGNED_GET(&addr->s6_addr16[3]) == group->s6_addr16[3] &&
4001b650:	0077c703          	lbu	a4,7(a5)
4001b654:	0067c683          	lbu	a3,6(a5)
		UNALIGNED_GET(&addr->s6_addr16[2]) == group->s6_addr16[2] &&
4001b658:	0065d883          	lhu	a7,6(a1)
		UNALIGNED_GET(&addr->s6_addr16[3]) == group->s6_addr16[3] &&
4001b65c:	00871613          	slli	a2,a4,0x8
		UNALIGNED_GET(&addr->s6_addr16[2]) == group->s6_addr16[2] &&
4001b660:	00d66633          	or	a2,a2,a3
4001b664:	08c89063          	bne	a7,a2,4001b6e4 <net_ipv6_is_addr_mcast_group+0xd0>
		UNALIGNED_GET(&addr->s6_addr32[1]) == group->s6_addr32[1] &&
4001b668:	01069693          	slli	a3,a3,0x10
4001b66c:	0045a603          	lw	a2,4(a1)
4001b670:	0106e6b3          	or	a3,a3,a6
4001b674:	01871713          	slli	a4,a4,0x18
4001b678:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr16[3]) == group->s6_addr16[3] &&
4001b67c:	06e61463          	bne	a2,a4,4001b6e4 <net_ipv6_is_addr_mcast_group+0xd0>
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
4001b680:	0097c703          	lbu	a4,9(a5)
4001b684:	0087c683          	lbu	a3,8(a5)
4001b688:	00871713          	slli	a4,a4,0x8
4001b68c:	00d76733          	or	a4,a4,a3
4001b690:	00a7c683          	lbu	a3,10(a5)
4001b694:	01069693          	slli	a3,a3,0x10
4001b698:	00e6e6b3          	or	a3,a3,a4
4001b69c:	00b7c703          	lbu	a4,11(a5)
4001b6a0:	01871713          	slli	a4,a4,0x18
4001b6a4:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == group->s6_addr32[1] &&
4001b6a8:	02e61e63          	bne	a2,a4,4001b6e4 <net_ipv6_is_addr_mcast_group+0xd0>
		UNALIGNED_GET(&addr->s6_addr32[3]) == group->s6_addr32[3];
4001b6ac:	00d7c683          	lbu	a3,13(a5)
4001b6b0:	00c7c703          	lbu	a4,12(a5)
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
4001b6b4:	00c5a503          	lw	a0,12(a1)
		UNALIGNED_GET(&addr->s6_addr32[3]) == group->s6_addr32[3];
4001b6b8:	00869693          	slli	a3,a3,0x8
4001b6bc:	00e6e6b3          	or	a3,a3,a4
4001b6c0:	00e7c703          	lbu	a4,14(a5)
4001b6c4:	00f7c783          	lbu	a5,15(a5)
4001b6c8:	01071713          	slli	a4,a4,0x10
4001b6cc:	00d76733          	or	a4,a4,a3
4001b6d0:	01879793          	slli	a5,a5,0x18
4001b6d4:	00e7e7b3          	or	a5,a5,a4
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
4001b6d8:	40f50533          	sub	a0,a0,a5
4001b6dc:	00153513          	seqz	a0,a0
4001b6e0:	00008067          	ret
}
4001b6e4:	00008067          	ret

4001b6e8 <net_ipv6_create>:
#define MAX_REACHABLE_TIME 3600000

int net_ipv6_create(struct net_pkt *pkt,
		    const struct in6_addr *src,
		    const struct in6_addr *dst)
{
4001b6e8:	fd010113          	addi	sp,sp,-48
4001b6ec:	03212023          	sw	s2,32(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
4001b6f0:	02800793          	li	a5,40
{
4001b6f4:	00058913          	mv	s2,a1
	struct net_ipv6_hdr *ipv6_hdr;
	uint8_t tc = 0;

	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
4001b6f8:	00810593          	addi	a1,sp,8
{
4001b6fc:	02912223          	sw	s1,36(sp)
4001b700:	01312e23          	sw	s3,28(sp)
4001b704:	02112623          	sw	ra,44(sp)
4001b708:	02812423          	sw	s0,40(sp)
4001b70c:	00050493          	mv	s1,a0
4001b710:	00060993          	mv	s3,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
4001b714:	00012423          	sw	zero,8(sp)
4001b718:	00f12623          	sw	a5,12(sp)
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
4001b71c:	9ccfd0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!ipv6_hdr) {
4001b720:	0a050a63          	beqz	a0,4001b7d4 <net_ipv6_create+0xec>
	return pkt->ip_dscp;
4001b724:	0404a783          	lw	a5,64(s1)
		net_ipv6_set_ecn(&tc, net_pkt_ip_ecn(pkt));
	}

	ipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);
	ipv6_hdr->tcflow  = (tc << 4) & 0xF0;
	ipv6_hdr->flow    = 0U;
4001b728:	00050123          	sb	zero,2(a0)
4001b72c:	000501a3          	sb	zero,3(a0)
 * @param dscp DSCP value to set.
 */
static inline void net_ipv6_set_dscp(uint8_t *tc, uint8_t dscp)
{
	*tc &= ~NET_IPV6_DSCP_MASK;
	*tc |= (dscp << NET_IPV6_DSCP_OFFSET) & NET_IPV6_DSCP_MASK;
4001b730:	03f7f713          	andi	a4,a5,63
	return pkt->ip_ecn;
4001b734:	0067d793          	srli	a5,a5,0x6
4001b738:	00271713          	slli	a4,a4,0x2
4001b73c:	0037f793          	andi	a5,a5,3
4001b740:	00f767b3          	or	a5,a4,a5
	ipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);
4001b744:	00475713          	srli	a4,a4,0x4
	ipv6_hdr->tcflow  = (tc << 4) & 0xF0;
4001b748:	00479793          	slli	a5,a5,0x4
	ipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);
4001b74c:	06076713          	ori	a4,a4,96
4001b750:	00e50023          	sb	a4,0(a0)
	ipv6_hdr->tcflow  = (tc << 4) & 0xF0;
4001b754:	00f500a3          	sb	a5,1(a0)
	ipv6_hdr->len     = 0U;
4001b758:	00050223          	sb	zero,4(a0)
4001b75c:	000502a3          	sb	zero,5(a0)
	ipv6_hdr->nexthdr = 0U;
4001b760:	00050323          	sb	zero,6(a0)
	return pkt->ipv6_hop_limit;
4001b764:	0394c783          	lbu	a5,57(s1)
4001b768:	00050413          	mv	s0,a0

	/* User can tweak the default hop limit if needed */
	ipv6_hdr->hop_limit = net_pkt_ipv6_hop_limit(pkt);
4001b76c:	00f503a3          	sb	a5,7(a0)
	if (ipv6_hdr->hop_limit == 0U) {
4001b770:	00079863          	bnez	a5,4001b780 <net_ipv6_create+0x98>
		ipv6_hdr->hop_limit =
			net_if_ipv6_get_hop_limit(net_pkt_iface(pkt));
4001b774:	0184a503          	lw	a0,24(s1)
4001b778:	bc0f70ef          	jal	ra,40012b38 <net_if_ipv6_get_hop_limit>
		ipv6_hdr->hop_limit =
4001b77c:	00a403a3          	sb	a0,7(s0)
	memcpy(dest, src, sizeof(struct in6_addr));
4001b780:	01000613          	li	a2,16
4001b784:	00098593          	mv	a1,s3
4001b788:	01840513          	addi	a0,s0,24
4001b78c:	d6cf10ef          	jal	ra,4000ccf8 <memcpy>
4001b790:	00090593          	mv	a1,s2
4001b794:	01000613          	li	a2,16
4001b798:	00840513          	addi	a0,s0,8
4001b79c:	d5cf10ef          	jal	ra,4000ccf8 <memcpy>
	pkt->ip_hdr_len = len;
4001b7a0:	02800793          	li	a5,40
4001b7a4:	02f48b23          	sb	a5,54(s1)
	pkt->ipv6_ext_len = len;
4001b7a8:	02049d23          	sh	zero,58(s1)
	net_ipv6_addr_copy_raw(ipv6_hdr->src, (uint8_t *)src);

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));
	net_pkt_set_ipv6_ext_len(pkt, 0);

	return net_pkt_set_data(pkt, &ipv6_access);
4001b7ac:	00810593          	addi	a1,sp,8
4001b7b0:	00048513          	mv	a0,s1
4001b7b4:	a04fd0ef          	jal	ra,400189b8 <net_pkt_set_data>
}
4001b7b8:	02c12083          	lw	ra,44(sp)
4001b7bc:	02812403          	lw	s0,40(sp)
4001b7c0:	02412483          	lw	s1,36(sp)
4001b7c4:	02012903          	lw	s2,32(sp)
4001b7c8:	01c12983          	lw	s3,28(sp)
4001b7cc:	03010113          	addi	sp,sp,48
4001b7d0:	00008067          	ret
		return -ENOBUFS;
4001b7d4:	f9700513          	li	a0,-105
4001b7d8:	fe1ff06f          	j	4001b7b8 <net_ipv6_create+0xd0>

4001b7dc <net_ipv6_finalize>:

int net_ipv6_finalize(struct net_pkt *pkt, uint8_t next_header_proto)
{
4001b7dc:	fe010113          	addi	sp,sp,-32
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
4001b7e0:	02800793          	li	a5,40
{
4001b7e4:	00812c23          	sw	s0,24(sp)
4001b7e8:	00912a23          	sw	s1,20(sp)
4001b7ec:	00112e23          	sw	ra,28(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
4001b7f0:	00012423          	sw	zero,8(sp)
4001b7f4:	00f12623          	sw	a5,12(sp)
	pkt->overwrite = overwrite;
4001b7f8:	03754783          	lbu	a5,55(a0)
{
4001b7fc:	00058493          	mv	s1,a1
	struct net_ipv6_hdr *ipv6_hdr;

	net_pkt_set_overwrite(pkt, true);

	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
4001b800:	00810593          	addi	a1,sp,8
4001b804:	0017e793          	ori	a5,a5,1
4001b808:	02f50ba3          	sb	a5,55(a0)
{
4001b80c:	00050413          	mv	s0,a0
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
4001b810:	8d8fd0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!ipv6_hdr) {
4001b814:	00051e63          	bnez	a0,4001b830 <net_ipv6_finalize+0x54>
		return -ENOBUFS;
4001b818:	f9700513          	li	a0,-105
	} else if (next_header_proto == IPPROTO_ICMPV6) {
		return net_icmpv6_finalize(pkt);
	}

	return 0;
}
4001b81c:	01c12083          	lw	ra,28(sp)
4001b820:	01812403          	lw	s0,24(sp)
4001b824:	01412483          	lw	s1,20(sp)
4001b828:	02010113          	addi	sp,sp,32
4001b82c:	00008067          	ret
	ipv6_hdr->len = htons(net_pkt_get_len(pkt) -
4001b830:	00842703          	lw	a4,8(s0)
	size_t bytes = 0;
4001b834:	00000793          	li	a5,0
	while (buf) {
4001b838:	06071663          	bnez	a4,4001b8a4 <net_ipv6_finalize+0xc8>
4001b83c:	fd878793          	addi	a5,a5,-40
4001b840:	0087d713          	srli	a4,a5,0x8
4001b844:	0ff77713          	zext.b	a4,a4
4001b848:	00879793          	slli	a5,a5,0x8
4001b84c:	00f767b3          	or	a5,a4,a5
4001b850:	01079713          	slli	a4,a5,0x10
4001b854:	01075713          	srli	a4,a4,0x10
4001b858:	00f50223          	sb	a5,4(a0)
4001b85c:	00875793          	srli	a5,a4,0x8
4001b860:	00f502a3          	sb	a5,5(a0)
	return pkt->ipv6_next_hdr;
4001b864:	03f44783          	lbu	a5,63(s0)
	if (net_pkt_ipv6_next_hdr(pkt) != 255U) {
4001b868:	0ff00713          	li	a4,255
4001b86c:	00e79463          	bne	a5,a4,4001b874 <net_ipv6_finalize+0x98>
		ipv6_hdr->nexthdr = next_header_proto;
4001b870:	00048793          	mv	a5,s1
4001b874:	00f50323          	sb	a5,6(a0)
	net_pkt_set_data(pkt, &ipv6_access);
4001b878:	00810593          	addi	a1,sp,8
4001b87c:	00040513          	mv	a0,s0
4001b880:	938fd0ef          	jal	ra,400189b8 <net_pkt_set_data>
	if (net_pkt_ipv6_next_hdr(pkt) != 255U &&
4001b884:	03f44703          	lbu	a4,63(s0)
4001b888:	0ff00793          	li	a5,255
4001b88c:	02f71463          	bne	a4,a5,4001b8b4 <net_ipv6_finalize+0xd8>
	if (IS_ENABLED(CONFIG_NET_UDP) &&
4001b890:	01100793          	li	a5,17
4001b894:	02f49a63          	bne	s1,a5,4001b8c8 <net_ipv6_finalize+0xec>
		return net_udp_finalize(pkt);
4001b898:	00040513          	mv	a0,s0
4001b89c:	424090ef          	jal	ra,40024cc0 <net_udp_finalize>
4001b8a0:	f7dff06f          	j	4001b81c <net_ipv6_finalize+0x40>
		bytes += buf->len;
4001b8a4:	01075683          	lhu	a3,16(a4)
		buf = buf->frags;
4001b8a8:	00472703          	lw	a4,4(a4)
		bytes += buf->len;
4001b8ac:	00d787b3          	add	a5,a5,a3
		buf = buf->frags;
4001b8b0:	f89ff06f          	j	4001b838 <net_ipv6_finalize+0x5c>
	    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {
4001b8b4:	03a45583          	lhu	a1,58(s0)
4001b8b8:	00040513          	mv	a0,s0
4001b8bc:	815fc0ef          	jal	ra,400180d0 <net_pkt_skip>
	if (net_pkt_ipv6_next_hdr(pkt) != 255U &&
4001b8c0:	fc0508e3          	beqz	a0,4001b890 <net_ipv6_finalize+0xb4>
4001b8c4:	f55ff06f          	j	4001b818 <net_ipv6_finalize+0x3c>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
4001b8c8:	00600793          	li	a5,6
4001b8cc:	00f49863          	bne	s1,a5,4001b8dc <net_ipv6_finalize+0x100>
		return net_tcp_finalize(pkt);
4001b8d0:	00040513          	mv	a0,s0
4001b8d4:	5b9050ef          	jal	ra,4002168c <net_tcp_finalize>
4001b8d8:	f45ff06f          	j	4001b81c <net_ipv6_finalize+0x40>
	} else if (next_header_proto == IPPROTO_ICMPV6) {
4001b8dc:	03a00793          	li	a5,58
	return 0;
4001b8e0:	00000513          	li	a0,0
	} else if (next_header_proto == IPPROTO_ICMPV6) {
4001b8e4:	f2f49ce3          	bne	s1,a5,4001b81c <net_ipv6_finalize+0x40>
		return net_icmpv6_finalize(pkt);
4001b8e8:	00040513          	mv	a0,s0
4001b8ec:	8dcff0ef          	jal	ra,4001a9c8 <net_icmpv6_finalize>
4001b8f0:	f2dff06f          	j	4001b81c <net_ipv6_finalize+0x40>

4001b8f4 <net_ipv6_input>:
		return 0;
	}
}

enum net_verdict net_ipv6_input(struct net_pkt *pkt, bool is_loopback)
{
4001b8f4:	f6010113          	addi	sp,sp,-160
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
4001b8f8:	02800793          	li	a5,40
4001b8fc:	02f12823          	sw	a5,48(sp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
4001b900:	03410793          	addi	a5,sp,52
4001b904:	02f12e23          	sw	a5,60(sp)
4001b908:	00800793          	li	a5,8
{
4001b90c:	08812c23          	sw	s0,152(sp)
4001b910:	09212823          	sw	s2,144(sp)
4001b914:	09412423          	sw	s4,136(sp)
4001b918:	08112e23          	sw	ra,156(sp)
4001b91c:	08912a23          	sw	s1,148(sp)
4001b920:	09312623          	sw	s3,140(sp)
4001b924:	09512223          	sw	s5,132(sp)
4001b928:	09612023          	sw	s6,128(sp)
4001b92c:	07712e23          	sw	s7,124(sp)
4001b930:	07812c23          	sw	s8,120(sp)
4001b934:	07912a23          	sw	s9,116(sp)
4001b938:	07a12823          	sw	s10,112(sp)
4001b93c:	07b12623          	sw	s11,108(sp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
4001b940:	04f12023          	sw	a5,64(sp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
4001b944:	04c10793          	addi	a5,sp,76
	return pkt->iface;
4001b948:	01852703          	lw	a4,24(a0)
4001b94c:	04f12223          	sw	a5,68(sp)
4001b950:	01400793          	li	a5,20
4001b954:	04f12423          	sw	a5,72(sp)
4001b958:	00852783          	lw	a5,8(a0)
{
4001b95c:	00050413          	mv	s0,a0
4001b960:	00058a13          	mv	s4,a1
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
4001b964:	02012623          	sw	zero,44(sp)
	struct net_if *pkt_iface = net_pkt_iface(pkt);
4001b968:	00e12e23          	sw	a4,28(sp)
	size_t bytes = 0;
4001b96c:	00000913          	li	s2,0
	while (buf) {
4001b970:	24079c63          	bnez	a5,4001bbc8 <net_ipv6_input+0x2d4>
	UPDATE_STAT(iface, stats.ipv6.recv++);
4001b974:	4003b9b7          	lui	s3,0x4003b
4001b978:	ed098693          	addi	a3,s3,-304 # 4003aed0 <net_stats>
4001b97c:	0246a783          	lw	a5,36(a3)
	net_pkt_cursor_backup(pkt, &hdr_start);
#endif

	net_stats_update_ipv6_recv(pkt_iface);

	hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
4001b980:	02c10593          	addi	a1,sp,44
4001b984:	00040513          	mv	a0,s0
4001b988:	00178793          	addi	a5,a5,1
4001b98c:	02f6a223          	sw	a5,36(a3)
4001b990:	02872783          	lw	a5,40(a4)
4001b994:	ed098993          	addi	s3,s3,-304
4001b998:	00178793          	addi	a5,a5,1
4001b99c:	02f72423          	sw	a5,40(a4)
4001b9a0:	f49fc0ef          	jal	ra,400188e8 <net_pkt_get_data>
4001b9a4:	00050b93          	mv	s7,a0
	if (!hdr) {
4001b9a8:	28050863          	beqz	a0,4001bc38 <net_ipv6_input+0x344>
		NET_DBG("DROP: no buffer");
		goto drop;
	}

	pkt_len = ntohs(hdr->len) + sizeof(struct net_ipv6_hdr);
4001b9ac:	00554703          	lbu	a4,5(a0)
4001b9b0:	00454683          	lbu	a3,4(a0)
4001b9b4:	00871713          	slli	a4,a4,0x8
4001b9b8:	00d76733          	or	a4,a4,a3
4001b9bc:	00871493          	slli	s1,a4,0x8
4001b9c0:	00875713          	srli	a4,a4,0x8
4001b9c4:	00e4e4b3          	or	s1,s1,a4
4001b9c8:	01049493          	slli	s1,s1,0x10
4001b9cc:	0104d493          	srli	s1,s1,0x10
4001b9d0:	02848493          	addi	s1,s1,40
	if (real_len < pkt_len) {
4001b9d4:	26994263          	blt	s2,s1,4001bc38 <net_ipv6_input+0x344>
		NET_DBG("DROP: pkt len per hdr %d != pkt real len %d",
			pkt_len, real_len);
		goto drop;
	} else if (real_len > pkt_len) {
4001b9d8:	0124d863          	bge	s1,s2,4001b9e8 <net_ipv6_input+0xf4>
		net_pkt_update_length(pkt, pkt_len);
4001b9dc:	00048593          	mv	a1,s1
4001b9e0:	00040513          	mv	a0,s0
4001b9e4:	b41fc0ef          	jal	ra,40018524 <net_pkt_update_length>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001b9e8:	009bc703          	lbu	a4,9(s7)
4001b9ec:	008bc683          	lbu	a3,8(s7)
4001b9f0:	00871713          	slli	a4,a4,0x8
4001b9f4:	00d76733          	or	a4,a4,a3
4001b9f8:	00abc683          	lbu	a3,10(s7)
4001b9fc:	01069693          	slli	a3,a3,0x10
4001ba00:	00e6e6b3          	or	a3,a3,a4
4001ba04:	00bbc703          	lbu	a4,11(s7)
4001ba08:	01871713          	slli	a4,a4,0x18
4001ba0c:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001ba10:	08071463          	bnez	a4,4001ba98 <net_ipv6_input+0x1a4>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001ba14:	00dbc703          	lbu	a4,13(s7)
4001ba18:	00cbc683          	lbu	a3,12(s7)
4001ba1c:	00871713          	slli	a4,a4,0x8
4001ba20:	00d76733          	or	a4,a4,a3
4001ba24:	00ebc683          	lbu	a3,14(s7)
4001ba28:	01069693          	slli	a3,a3,0x10
4001ba2c:	00e6e6b3          	or	a3,a3,a4
4001ba30:	00fbc703          	lbu	a4,15(s7)
4001ba34:	01871713          	slli	a4,a4,0x18
4001ba38:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001ba3c:	04071e63          	bnez	a4,4001ba98 <net_ipv6_input+0x1a4>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001ba40:	011bc703          	lbu	a4,17(s7)
4001ba44:	010bc683          	lbu	a3,16(s7)
4001ba48:	00871713          	slli	a4,a4,0x8
4001ba4c:	00d76733          	or	a4,a4,a3
4001ba50:	012bc683          	lbu	a3,18(s7)
4001ba54:	01069693          	slli	a3,a3,0x10
4001ba58:	00e6e6b3          	or	a3,a3,a4
4001ba5c:	013bc703          	lbu	a4,19(s7)
4001ba60:	01871713          	slli	a4,a4,0x18
4001ba64:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001ba68:	02071863          	bnez	a4,4001ba98 <net_ipv6_input+0x1a4>
		UNALIGNED_GET(&addr->s6_addr32[3]) == 0;
4001ba6c:	015bc703          	lbu	a4,21(s7)
4001ba70:	014bc683          	lbu	a3,20(s7)
4001ba74:	00871713          	slli	a4,a4,0x8
4001ba78:	00d76733          	or	a4,a4,a3
4001ba7c:	016bc683          	lbu	a3,22(s7)
4001ba80:	01069693          	slli	a3,a3,0x10
4001ba84:	00e6e6b3          	or	a3,a3,a4
4001ba88:	017bc703          	lbu	a4,23(s7)
4001ba8c:	01871713          	slli	a4,a4,0x18
4001ba90:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001ba94:	1a070263          	beqz	a4,4001bc38 <net_ipv6_input+0x344>
	if (net_ipv6_is_addr_unspecified((struct in6_addr *)hdr->src)) {
		NET_DBG("DROP: src addr is %s", "unspecified");
		goto drop;
	}

	if (net_ipv6_is_addr_mcast((struct in6_addr *)hdr->src) ||
4001ba98:	008bc683          	lbu	a3,8(s7)
4001ba9c:	0ff00713          	li	a4,255
4001baa0:	18e68c63          	beq	a3,a4,4001bc38 <net_ipv6_input+0x344>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
4001baa4:	018bca83          	lbu	s5,24(s7)
	    net_ipv6_is_addr_mcast_scope((struct in6_addr *)hdr->dst, 0)) {
4001baa8:	018b8913          	addi	s2,s7,24
4001baac:	00ea9663          	bne	s5,a4,4001bab8 <net_ipv6_input+0x1c4>
4001bab0:	019bc703          	lbu	a4,25(s7)
4001bab4:	18070263          	beqz	a4,4001bc38 <net_ipv6_input+0x344>
		NET_DBG("DROP: multicast packet");
		goto drop;
	}

	if (!is_loopback) {
4001bab8:	120a0063          	beqz	s4,4001bbd8 <net_ipv6_input+0x2e4>
	}

	/* Reconstruct TC field. */

	if (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {
		uint8_t tc = ((hdr->vtc << 4) & 0xF0) | ((hdr->tcflow >> 4) & 0x0F);
4001babc:	000bc703          	lbu	a4,0(s7)
4001bac0:	001bc683          	lbu	a3,1(s7)
		if (ipv6_forward_mcast_packet(pkt, hdr) == NET_DROP) {
			goto drop;
		}
	}

	if (!net_ipv6_is_addr_mcast((struct in6_addr *)hdr->dst)) {
4001bac4:	0ff00a13          	li	s4,255
		uint8_t tc = ((hdr->vtc << 4) & 0xF0) | ((hdr->tcflow >> 4) & 0x0F);
4001bac8:	00471713          	slli	a4,a4,0x4
4001bacc:	0046d693          	srli	a3,a3,0x4
4001bad0:	00d76733          	or	a4,a4,a3
4001bad4:	0ff77713          	zext.b	a4,a4
	pkt->ip_dscp = dscp;
4001bad8:	00671693          	slli	a3,a4,0x6
	return (tc & NET_IPV6_DSCP_MASK) >> NET_IPV6_DSCP_OFFSET;
4001badc:	00275713          	srli	a4,a4,0x2
4001bae0:	00e6e733          	or	a4,a3,a4
4001bae4:	04e40023          	sb	a4,64(s0)
	net_pkt_set_ipv6_next_hdr(pkt, hdr->nexthdr);
4001bae8:	006bc703          	lbu	a4,6(s7)
	pkt->ipv6_ext_len = len;
4001baec:	02041d23          	sh	zero,58(s0)
	pkt->ipv6_next_hdr = next_hdr;
4001baf0:	02e40fa3          	sb	a4,63(s0)
	pkt->ip_hdr_len = len;
4001baf4:	02800713          	li	a4,40
4001baf8:	02e40b23          	sb	a4,54(s0)
	return pkt->frags->data;
4001bafc:	00842703          	lw	a4,8(s0)
	net_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_HDR(pkt)->hop_limit);
4001bb00:	00c72703          	lw	a4,12(a4)
4001bb04:	00774703          	lbu	a4,7(a4)
	pkt->ipv6_hop_limit = hop_limit;
4001bb08:	02e40ca3          	sb	a4,57(s0)
	pkt->family = family;
4001bb0c:	03744703          	lbu	a4,55(s0)
4001bb10:	01f77713          	andi	a4,a4,31
4001bb14:	04076713          	ori	a4,a4,64
4001bb18:	02e40ba3          	sb	a4,55(s0)
	if (!net_ipv6_is_addr_mcast((struct in6_addr *)hdr->dst)) {
4001bb1c:	018bc703          	lbu	a4,24(s7)
4001bb20:	17470263          	beq	a4,s4,4001bc84 <net_ipv6_input+0x390>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
4001bb24:	00000593          	li	a1,0
4001bb28:	00090513          	mv	a0,s2
4001bb2c:	d84f50ef          	jal	ra,400110b0 <net_if_ipv6_addr_lookup>
		if (!net_ipv6_is_my_addr((struct in6_addr *)hdr->dst)) {
4001bb30:	14051663          	bnez	a0,4001bc7c <net_ipv6_input+0x388>
		found = net_route_get_info(net_pkt_iface(pkt),
4001bb34:	01842503          	lw	a0,24(s0)
4001bb38:	02410693          	addi	a3,sp,36
4001bb3c:	02010613          	addi	a2,sp,32
4001bb40:	00090593          	mv	a1,s2
4001bb44:	44c040ef          	jal	ra,4001ff90 <net_route_get_info>
	if (found) {
4001bb48:	10050863          	beqz	a0,4001bc58 <net_ipv6_input+0x364>
		if (route) {
4001bb4c:	02012783          	lw	a5,32(sp)
4001bb50:	02078463          	beqz	a5,4001bb78 <net_ipv6_input+0x284>
			net_pkt_set_iface(pkt, route->iface);
4001bb54:	00c7a783          	lw	a5,12(a5)
	pkt->iface = iface;
4001bb58:	00f42c23          	sw	a5,24(s0)
	if (iface) {
4001bb5c:	00078e63          	beqz	a5,4001bb78 <net_ipv6_input+0x284>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
4001bb60:	0007a703          	lw	a4,0(a5)
4001bb64:	01574703          	lbu	a4,21(a4)
4001bb68:	02e404a3          	sb	a4,41(s0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
4001bb6c:	0007a783          	lw	a5,0(a5)
4001bb70:	0157c783          	lbu	a5,21(a5)
4001bb74:	02f408a3          	sb	a5,49(s0)
		ret = net_route_packet(pkt, nexthop);
4001bb78:	02412583          	lw	a1,36(sp)
4001bb7c:	00040513          	mv	a0,s0
4001bb80:	4c8040ef          	jal	ra,40020048 <net_route_packet>
			if (ret < 0) {
4001bb84:	0a054a63          	bltz	a0,4001bc38 <net_ipv6_input+0x344>
			if (ipv6_route_packet(pkt, hdr) == NET_OK) {
				return NET_OK;
4001bb88:	00000513          	li	a0,0

	NET_DBG("DROP: Unknown/wrong nexthdr type");
	net_stats_update_ip_errors_protoerr(pkt_iface);

	return NET_DROP;
}
4001bb8c:	09c12083          	lw	ra,156(sp)
4001bb90:	09812403          	lw	s0,152(sp)
4001bb94:	09412483          	lw	s1,148(sp)
4001bb98:	09012903          	lw	s2,144(sp)
4001bb9c:	08c12983          	lw	s3,140(sp)
4001bba0:	08812a03          	lw	s4,136(sp)
4001bba4:	08412a83          	lw	s5,132(sp)
4001bba8:	08012b03          	lw	s6,128(sp)
4001bbac:	07c12b83          	lw	s7,124(sp)
4001bbb0:	07812c03          	lw	s8,120(sp)
4001bbb4:	07412c83          	lw	s9,116(sp)
4001bbb8:	07012d03          	lw	s10,112(sp)
4001bbbc:	06c12d83          	lw	s11,108(sp)
4001bbc0:	0a010113          	addi	sp,sp,160
4001bbc4:	00008067          	ret
		bytes += buf->len;
4001bbc8:	0107d683          	lhu	a3,16(a5)
		buf = buf->frags;
4001bbcc:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4001bbd0:	00d90933          	add	s2,s2,a3
		buf = buf->frags;
4001bbd4:	d9dff06f          	j	4001b970 <net_ipv6_input+0x7c>
		if (net_ipv6_is_addr_loopback((struct in6_addr *)hdr->dst) ||
4001bbd8:	00090513          	mv	a0,s2
4001bbdc:	941ff0ef          	jal	ra,4001b51c <net_ipv6_is_addr_loopback>
4001bbe0:	04051c63          	bnez	a0,4001bc38 <net_ipv6_input+0x344>
		    net_ipv6_is_addr_loopback((struct in6_addr *)hdr->src)) {
4001bbe4:	008b8513          	addi	a0,s7,8
4001bbe8:	935ff0ef          	jal	ra,4001b51c <net_ipv6_is_addr_loopback>
		if (net_ipv6_is_addr_loopback((struct in6_addr *)hdr->dst) ||
4001bbec:	04051663          	bnez	a0,4001bc38 <net_ipv6_input+0x344>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
4001bbf0:	0ff00713          	li	a4,255
4001bbf4:	00ea9863          	bne	s5,a4,4001bc04 <net_ipv6_input+0x310>
4001bbf8:	019bc683          	lbu	a3,25(s7)
4001bbfc:	00100713          	li	a4,1
4001bc00:	02e68c63          	beq	a3,a4,4001bc38 <net_ipv6_input+0x344>
		    (net_ipv6_is_addr_mcast_group(
4001bc04:	805f90ef          	jal	ra,40015408 <net_ipv6_unspecified_address>
4001bc08:	00050593          	mv	a1,a0
4001bc0c:	00090513          	mv	a0,s2
4001bc10:	a05ff0ef          	jal	ra,4001b614 <net_ipv6_is_addr_mcast_group>
		if (net_ipv6_is_addr_mcast_iface((struct in6_addr *)hdr->dst) ||
4001bc14:	ea0504e3          	beqz	a0,4001babc <net_ipv6_input+0x1c8>
4001bc18:	018bc683          	lbu	a3,24(s7)
4001bc1c:	0ff00713          	li	a4,255
4001bc20:	e8e69ee3          	bne	a3,a4,4001babc <net_ipv6_input+0x1c8>
4001bc24:	019bc703          	lbu	a4,25(s7)
4001bc28:	00500693          	li	a3,5
4001bc2c:	00d70663          	beq	a4,a3,4001bc38 <net_ipv6_input+0x344>
4001bc30:	00800693          	li	a3,8
4001bc34:	e8d714e3          	bne	a4,a3,4001babc <net_ipv6_input+0x1c8>
	UPDATE_STAT(iface, stats.ipv6.drop++);
4001bc38:	0309a783          	lw	a5,48(s3)
	net_stats_update_ipv6_drop(pkt_iface);
4001bc3c:	01c12703          	lw	a4,28(sp)
4001bc40:	00178793          	addi	a5,a5,1
4001bc44:	02f9a823          	sw	a5,48(s3)
4001bc48:	03472783          	lw	a5,52(a4)
4001bc4c:	00178793          	addi	a5,a5,1
4001bc50:	02f72a23          	sw	a5,52(a4)
}
4001bc54:	0a00006f          	j	4001bcf4 <net_ipv6_input+0x400>
		if (net_if_ipv6_addr_onlink(&iface, (struct in6_addr *)hdr->dst)) {
4001bc58:	00090593          	mv	a1,s2
4001bc5c:	02810513          	addi	a0,sp,40
		struct net_if *iface = NULL;
4001bc60:	02012423          	sw	zero,40(sp)
		if (net_if_ipv6_addr_onlink(&iface, (struct in6_addr *)hdr->dst)) {
4001bc64:	b49f60ef          	jal	ra,400127ac <net_if_ipv6_addr_onlink>
4001bc68:	fc0508e3          	beqz	a0,4001bc38 <net_ipv6_input+0x344>
			ret = net_route_packet_if(pkt, iface);
4001bc6c:	02812583          	lw	a1,40(sp)
4001bc70:	00040513          	mv	a0,s0
4001bc74:	548040ef          	jal	ra,400201bc <net_route_packet_if>
4001bc78:	f0dff06f          	j	4001bb84 <net_ipv6_input+0x290>
	if (net_ipv6_is_addr_mcast((struct in6_addr *)hdr->dst) &&
4001bc7c:	018bc703          	lbu	a4,24(s7)
4001bc80:	01471863          	bne	a4,s4,4001bc90 <net_ipv6_input+0x39c>
4001bc84:	019bc703          	lbu	a4,25(s7)
4001bc88:	00100693          	li	a3,1
4001bc8c:	08d71063          	bne	a4,a3,4001bd0c <net_ipv6_input+0x418>
	return net_pkt_skip(pkt, access->size);
4001bc90:	03012583          	lw	a1,48(sp)
4001bc94:	00040513          	mv	a0,s0
		return NET_IPV6_EXT_HDR_BITMAP_FRAG;
4001bc98:	00800c13          	li	s8,8
4001bc9c:	c34fc0ef          	jal	ra,400180d0 <net_pkt_skip>
	current_hdr = hdr->nexthdr;
4001bca0:	006bc903          	lbu	s2,6(s7)
	switch (header) {
4001bca4:	02c00693          	li	a3,44
4001bca8:	00d90e63          	beq	s2,a3,4001bcc4 <net_ipv6_input+0x3d0>
4001bcac:	0526e863          	bltu	a3,s2,4001bcfc <net_ipv6_input+0x408>
4001bcb0:	00100c13          	li	s8,1
4001bcb4:	00090863          	beqz	s2,4001bcc4 <net_ipv6_input+0x3d0>
4001bcb8:	fd590713          	addi	a4,s2,-43
4001bcbc:	00173713          	seqz	a4,a4
4001bcc0:	00271c13          	slli	s8,a4,0x2
}
4001bcc4:	00600693          	li	a3,6
	uint16_t ext_len = 0U;
4001bcc8:	00000a13          	li	s4,0
		nexthdr == IPPROTO_TCP ||
4001bccc:	03a00a93          	li	s5,58
	switch (header) {
4001bcd0:	02c00b13          	li	s6,44
	pkt->ipv6_prev_hdr_start = offset;
4001bcd4:	02d41e23          	sh	a3,60(s0)
4001bcd8:	29590063          	beq	s2,s5,4001bf58 <net_ipv6_input+0x664>
	return (nexthdr == IPPROTO_ICMPV6 || nexthdr == IPPROTO_UDP ||
4001bcdc:	01100c93          	li	s9,17
4001bce0:	27990c63          	beq	s2,s9,4001bf58 <net_ipv6_input+0x664>
		nexthdr == IPPROTO_TCP ||
4001bce4:	00600693          	li	a3,6
4001bce8:	26d90863          	beq	s2,a3,4001bf58 <net_ipv6_input+0x664>
		if (current_hdr == NET_IPV6_NEXTHDR_NONE) {
4001bcec:	03b00793          	li	a5,59
4001bcf0:	04f91e63          	bne	s2,a5,4001bd4c <net_ipv6_input+0x458>
			return NET_DROP;
4001bcf4:	00200513          	li	a0,2
4001bcf8:	e95ff06f          	j	4001bb8c <net_ipv6_input+0x298>
	switch (header) {
4001bcfc:	fc490713          	addi	a4,s2,-60
4001bd00:	00173713          	seqz	a4,a4
4001bd04:	00171c13          	slli	s8,a4,0x1
4001bd08:	fbdff06f          	j	4001bcc4 <net_ipv6_input+0x3d0>
4001bd0c:	00200693          	li	a3,2
4001bd10:	00d71c63          	bne	a4,a3,4001bd28 <net_ipv6_input+0x434>
	return net_ipv6_is_addr_mcast_group(addr, &all_nodes_mcast_group);
4001bd14:	400355b7          	lui	a1,0x40035
4001bd18:	f9c58593          	addi	a1,a1,-100 # 40034f9c <all_nodes_mcast_group.0>
4001bd1c:	00090513          	mv	a0,s2
4001bd20:	8f5ff0ef          	jal	ra,4001b614 <net_ipv6_is_addr_mcast_group>
	return net_ipv6_is_addr_mcast_link(addr) &&
4001bd24:	f60516e3          	bnez	a0,4001bc90 <net_ipv6_input+0x39c>
		if_mcast_addr = net_if_ipv6_maddr_lookup(
4001bd28:	01c10593          	addi	a1,sp,28
4001bd2c:	00090513          	mv	a0,s2
4001bd30:	c5cf60ef          	jal	ra,4001218c <net_if_ipv6_maddr_lookup>
		if (!if_mcast_addr ||
4001bd34:	f00502e3          	beqz	a0,4001bc38 <net_ipv6_input+0x344>
	return addr->is_joined;
4001bd38:	01452703          	lw	a4,20(a0)
4001bd3c:	00175713          	srli	a4,a4,0x1
4001bd40:	00177713          	andi	a4,a4,1
4001bd44:	f40716e3          	bnez	a4,4001bc90 <net_ipv6_input+0x39c>
4001bd48:	ef1ff06f          	j	4001bc38 <net_ipv6_input+0x344>
		prev_hdr_offset = net_pkt_get_current_offset(pkt);
4001bd4c:	00040513          	mv	a0,s0
4001bd50:	8d9fc0ef          	jal	ra,40018628 <net_pkt_get_current_offset>
4001bd54:	00a12223          	sw	a0,4(sp)
	return net_pkt_read(pkt, data, 1);
4001bd58:	00100613          	li	a2,1
4001bd5c:	02010593          	addi	a1,sp,32
4001bd60:	00040513          	mv	a0,s0
4001bd64:	dd4fc0ef          	jal	ra,40018338 <net_pkt_read>
		if (net_pkt_read_u8(pkt, &nexthdr)) {
4001bd68:	ec0518e3          	bnez	a0,4001bc38 <net_ipv6_input+0x344>
		ext_bit = extension_to_bitmap(nexthdr, ext_bitmap);
4001bd6c:	02014683          	lbu	a3,32(sp)
	switch (header) {
4001bd70:	15668063          	beq	a3,s6,4001beb0 <net_ipv6_input+0x5bc>
4001bd74:	04db6c63          	bltu	s6,a3,4001bdcc <net_ipv6_input+0x4d8>
4001bd78:	00068c63          	beqz	a3,4001bd90 <net_ipv6_input+0x49c>
4001bd7c:	02b00613          	li	a2,43
4001bd80:	00c68863          	beq	a3,a2,4001bd90 <net_ipv6_input+0x49c>
	return (nexthdr == IPPROTO_ICMPV6 || nexthdr == IPPROTO_UDP ||
4001bd84:	05968e63          	beq	a3,s9,4001bde0 <net_ipv6_input+0x4ec>
		nexthdr == IPPROTO_TCP ||
4001bd88:	00600613          	li	a2,6
4001bd8c:	04c68a63          	beq	a3,a2,4001bde0 <net_ipv6_input+0x4ec>
			      net_pkt_get_current_offset(pkt) - 1);
4001bd90:	00040513          	mv	a0,s0
4001bd94:	895fc0ef          	jal	ra,40018628 <net_pkt_get_current_offset>
	net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
4001bd98:	fff50693          	addi	a3,a0,-1
4001bd9c:	00100613          	li	a2,1
4001bda0:	00400593          	li	a1,4
4001bda4:	00040513          	mv	a0,s0
4001bda8:	eadfe0ef          	jal	ra,4001ac54 <net_icmpv6_send_error>
	UPDATE_STAT(iface, stats.ip_errors.protoerr++);
4001bdac:	0209a783          	lw	a5,32(s3)
	net_stats_update_ip_errors_protoerr(pkt_iface);
4001bdb0:	01c12703          	lw	a4,28(sp)
4001bdb4:	00178793          	addi	a5,a5,1
4001bdb8:	02f9a023          	sw	a5,32(s3)
4001bdbc:	02472783          	lw	a5,36(a4)
4001bdc0:	00178793          	addi	a5,a5,1
4001bdc4:	02f72223          	sw	a5,36(a4)
}
4001bdc8:	f2dff06f          	j	4001bcf4 <net_ipv6_input+0x400>
	switch (header) {
4001bdcc:	03c00793          	li	a5,60
4001bdd0:	0ef69863          	bne	a3,a5,4001bec0 <net_ipv6_input+0x5cc>
		if (ext_bitmap & NET_IPV6_EXT_HDR_BITMAP_DESTO1) {
4001bdd4:	002c7693          	andi	a3,s8,2
4001bdd8:	0c069463          	bnez	a3,4001bea0 <net_ipv6_input+0x5ac>
		ext_bitmap |= ext_bit;
4001bddc:	002c6c13          	ori	s8,s8,2
		switch (current_hdr) {
4001bde0:	00090663          	beqz	s2,4001bdec <net_ipv6_input+0x4f8>
4001bde4:	03c00693          	li	a3,60
4001bde8:	fad914e3          	bne	s2,a3,4001bd90 <net_ipv6_input+0x49c>
		exthdr_len = ipv6_handle_ext_hdr_options(pkt, hdr, pkt_len);
4001bdec:	01049c93          	slli	s9,s1,0x10
4001bdf0:	00100613          	li	a2,1
4001bdf4:	02810593          	addi	a1,sp,40
4001bdf8:	00040513          	mv	a0,s0
4001bdfc:	010cdc93          	srli	s9,s9,0x10
		uint8_t val = 0U;
4001be00:	02010423          	sb	zero,40(sp)
4001be04:	d34fc0ef          	jal	ra,40018338 <net_pkt_read>
		if (net_pkt_read_u8(pkt, &val)) {
4001be08:	e20518e3          	bnez	a0,4001bc38 <net_ipv6_input+0x344>
		exthdr_len = val * 8U + 8;
4001be0c:	02814903          	lbu	s2,40(sp)
4001be10:	00190913          	addi	s2,s2,1
4001be14:	00391913          	slli	s2,s2,0x3
	if (exthdr_len > pkt_len) {
4001be18:	e32ce0e3          	bltu	s9,s2,4001bc38 <net_ipv6_input+0x344>
			if (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {
4001be1c:	ffd90793          	addi	a5,s2,-3
	length += 2U;
4001be20:	00200c93          	li	s9,2
			if (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {
4001be24:	00f12623          	sw	a5,12(sp)
	switch (opt_type & 0xc0) {
4001be28:	08000d13          	li	s10,128
4001be2c:	0c000d93          	li	s11,192
		opt_type_offset = net_pkt_get_current_offset(pkt);
4001be30:	00040513          	mv	a0,s0
4001be34:	ff4fc0ef          	jal	ra,40018628 <net_pkt_get_current_offset>
4001be38:	00a12423          	sw	a0,8(sp)
4001be3c:	00100613          	li	a2,1
4001be40:	02410593          	addi	a1,sp,36
4001be44:	00040513          	mv	a0,s0
4001be48:	cf0fc0ef          	jal	ra,40018338 <net_pkt_read>
		if (net_pkt_read_u8(pkt, &opt_type)) {
4001be4c:	de0516e3          	bnez	a0,4001bc38 <net_ipv6_input+0x344>
		if (opt_type != NET_IPV6_EXT_HDR_OPT_PAD1) {
4001be50:	02414603          	lbu	a2,36(sp)
4001be54:	08061263          	bnez	a2,4001bed8 <net_ipv6_input+0x5e4>
		switch (opt_type) {
4001be58:	02414603          	lbu	a2,36(sp)
4001be5c:	08060a63          	beqz	a2,4001bef0 <net_ipv6_input+0x5fc>
4001be60:	00100513          	li	a0,1
4001be64:	02814583          	lbu	a1,40(sp)
4001be68:	08a60c63          	beq	a2,a0,4001bf00 <net_ipv6_input+0x60c>
			if (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {
4001be6c:	00c12783          	lw	a5,12(sp)
4001be70:	dcf5d4e3          	bge	a1,a5,4001bc38 <net_ipv6_input+0x344>
	switch (opt_type & 0xc0) {
4001be74:	0c067613          	andi	a2,a2,192
4001be78:	0da60463          	beq	a2,s10,4001bf40 <net_ipv6_input+0x64c>
4001be7c:	0bb60c63          	beq	a2,s11,4001bf34 <net_ipv6_input+0x640>
4001be80:	da061ce3          	bnez	a2,4001bc38 <net_ipv6_input+0x344>
			if (net_pkt_skip(pkt, opt_len)) {
4001be84:	00040513          	mv	a0,s0
4001be88:	a48fc0ef          	jal	ra,400180d0 <net_pkt_skip>
4001be8c:	da0516e3          	bnez	a0,4001bc38 <net_ipv6_input+0x344>
			length += opt_len + 2;
4001be90:	02814603          	lbu	a2,40(sp)
4001be94:	00260613          	addi	a2,a2,2
4001be98:	00cc86b3          	add	a3,s9,a2
4001be9c:	0580006f          	j	4001bef4 <net_ipv6_input+0x600>
		if (ext_bit & ext_bitmap) {
4001bea0:	040c7693          	andi	a3,s8,64
4001bea4:	ee0696e3          	bnez	a3,4001bd90 <net_ipv6_input+0x49c>
		ext_bitmap |= ext_bit;
4001bea8:	040c6c13          	ori	s8,s8,64
		switch (nexthdr) {
4001beac:	f35ff06f          	j	4001bde0 <net_ipv6_input+0x4ec>
		if (ext_bit & ext_bitmap) {
4001beb0:	008c7693          	andi	a3,s8,8
4001beb4:	ec069ee3          	bnez	a3,4001bd90 <net_ipv6_input+0x49c>
		ext_bitmap |= ext_bit;
4001beb8:	008c6c13          	ori	s8,s8,8
		switch (nexthdr) {
4001bebc:	f25ff06f          	j	4001bde0 <net_ipv6_input+0x4ec>
4001bec0:	fc568613          	addi	a2,a3,-59
4001bec4:	0ff67613          	zext.b	a2,a2
4001bec8:	00100593          	li	a1,1
4001becc:	f0c5fae3          	bgeu	a1,a2,4001bde0 <net_ipv6_input+0x4ec>
4001bed0:	f15688e3          	beq	a3,s5,4001bde0 <net_ipv6_input+0x4ec>
4001bed4:	ebdff06f          	j	4001bd90 <net_ipv6_input+0x49c>
4001bed8:	00100613          	li	a2,1
4001bedc:	02810593          	addi	a1,sp,40
4001bee0:	00040513          	mv	a0,s0
4001bee4:	c54fc0ef          	jal	ra,40018338 <net_pkt_read>
			if (net_pkt_read_u8(pkt, &opt_len)) {
4001bee8:	f60508e3          	beqz	a0,4001be58 <net_ipv6_input+0x564>
4001beec:	d4dff06f          	j	4001bc38 <net_ipv6_input+0x344>
			length++;
4001bef0:	001c8693          	addi	a3,s9,1
			length += opt_len + 2;
4001bef4:	01069c93          	slli	s9,a3,0x10
4001bef8:	010cdc93          	srli	s9,s9,0x10
			break;
4001befc:	01c0006f          	j	4001bf18 <net_ipv6_input+0x624>
			length += opt_len + 2;
4001bf00:	00258613          	addi	a2,a1,2
4001bf04:	00cc86b3          	add	a3,s9,a2
4001bf08:	01069c93          	slli	s9,a3,0x10
			net_pkt_skip(pkt, opt_len);
4001bf0c:	00040513          	mv	a0,s0
			length += opt_len + 2;
4001bf10:	010cdc93          	srli	s9,s9,0x10
			net_pkt_skip(pkt, opt_len);
4001bf14:	9bcfc0ef          	jal	ra,400180d0 <net_pkt_skip>
	while (length < exthdr_len) {
4001bf18:	f12cece3          	bltu	s9,s2,4001be30 <net_ipv6_input+0x53c>
		ext_len += exthdr_len;
4001bf1c:	012a0933          	add	s2,s4,s2
4001bf20:	01091a13          	slli	s4,s2,0x10
4001bf24:	00414683          	lbu	a3,4(sp)
		current_hdr = nexthdr;
4001bf28:	02014903          	lbu	s2,32(sp)
		ext_len += exthdr_len;
4001bf2c:	010a5a13          	srli	s4,s4,0x10
}
4001bf30:	da5ff06f          	j	4001bcd4 <net_ipv6_input+0x3e0>
		if (net_ipv6_is_addr_mcast((struct in6_addr *)hdr->dst)) {
4001bf34:	018bc703          	lbu	a4,24(s7)
4001bf38:	0ff00793          	li	a5,255
4001bf3c:	cef70ee3          	beq	a4,a5,4001bc38 <net_ipv6_input+0x344>
		net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
4001bf40:	00812683          	lw	a3,8(sp)
4001bf44:	00200613          	li	a2,2
4001bf48:	00400593          	li	a1,4
4001bf4c:	00040513          	mv	a0,s0
4001bf50:	d05fe0ef          	jal	ra,4001ac54 <net_icmpv6_send_error>
		break;
4001bf54:	ce5ff06f          	j	4001bc38 <net_ipv6_input+0x344>
	pkt->ipv6_ext_len = len;
4001bf58:	03441d23          	sh	s4,58(s0)
	switch (current_hdr) {
4001bf5c:	01100713          	li	a4,17
4001bf60:	04e90a63          	beq	s2,a4,4001bfb4 <net_ipv6_input+0x6c0>
4001bf64:	03a00713          	li	a4,58
4001bf68:	00e91e63          	bne	s2,a4,4001bf84 <net_ipv6_input+0x690>
		verdict = net_icmpv6_input(pkt, hdr);
4001bf6c:	000b8593          	mv	a1,s7
4001bf70:	00040513          	mv	a0,s0
4001bf74:	a1cff0ef          	jal	ra,4001b190 <net_icmpv6_input>
	if (verdict != NET_DROP) {
4001bf78:	00200793          	li	a5,2
4001bf7c:	c0f518e3          	bne	a0,a5,4001bb8c <net_ipv6_input+0x298>
4001bf80:	cb9ff06f          	j	4001bc38 <net_ipv6_input+0x344>
		proto_hdr.tcp = net_tcp_input(pkt, &tcp_access);
4001bf84:	04410593          	addi	a1,sp,68
4001bf88:	00040513          	mv	a0,s0
4001bf8c:	788050ef          	jal	ra,40021714 <net_tcp_input>
4001bf90:	02a12223          	sw	a0,36(sp)
		if (proto_hdr.tcp) {
4001bf94:	ca0502e3          	beqz	a0,4001bc38 <net_ipv6_input+0x344>
	verdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);
4001bf98:	02410693          	addi	a3,sp,36
4001bf9c:	00090613          	mv	a2,s2
4001bfa0:	02810593          	addi	a1,sp,40
4001bfa4:	00040513          	mv	a0,s0
	ip.ipv6 = hdr;
4001bfa8:	03712423          	sw	s7,40(sp)
	verdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);
4001bfac:	c30fd0ef          	jal	ra,400193dc <net_conn_input>
4001bfb0:	fc9ff06f          	j	4001bf78 <net_ipv6_input+0x684>
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
4001bfb4:	03c10593          	addi	a1,sp,60
4001bfb8:	00040513          	mv	a0,s0
4001bfbc:	5e1080ef          	jal	ra,40024d9c <net_udp_input>
4001bfc0:	fd1ff06f          	j	4001bf90 <net_ipv6_input+0x69c>

4001bfc4 <net_ipv6_init>:

void net_ipv6_init(void)
{
4001bfc4:	ff010113          	addi	sp,sp,-16
4001bfc8:	00112623          	sw	ra,12(sp)
	net_ipv6_nbr_init();
4001bfcc:	4cd020ef          	jal	ra,4001ec98 <net_ipv6_nbr_init>

#if defined(CONFIG_NET_IPV6_MLD)
	net_ipv6_mld_init();
#endif
}
4001bfd0:	00c12083          	lw	ra,12(sp)
4001bfd4:	01010113          	addi	sp,sp,16
	net_ipv6_mld_init();
4001bfd8:	4fc0306f          	j	4001f4d4 <net_ipv6_mld_init>

4001bfdc <net_ipv6_is_addr_unspecified>:
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001bfdc:	00154703          	lbu	a4,1(a0)
4001bfe0:	00054683          	lbu	a3,0(a0)
{
4001bfe4:	00050793          	mv	a5,a0
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001bfe8:	00871713          	slli	a4,a4,0x8
4001bfec:	00d76733          	or	a4,a4,a3
4001bff0:	00254683          	lbu	a3,2(a0)
4001bff4:	01069693          	slli	a3,a3,0x10
4001bff8:	00e6e6b3          	or	a3,a3,a4
4001bffc:	00354703          	lbu	a4,3(a0)
4001c000:	01871713          	slli	a4,a4,0x18
4001c004:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001c008:	08071863          	bnez	a4,4001c098 <net_ipv6_is_addr_unspecified+0xbc>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001c00c:	00554703          	lbu	a4,5(a0)
4001c010:	00454683          	lbu	a3,4(a0)
4001c014:	00871713          	slli	a4,a4,0x8
4001c018:	00d76733          	or	a4,a4,a3
4001c01c:	00654683          	lbu	a3,6(a0)
4001c020:	01069693          	slli	a3,a3,0x10
4001c024:	00e6e6b3          	or	a3,a3,a4
4001c028:	00754703          	lbu	a4,7(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001c02c:	00000513          	li	a0,0
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001c030:	01871713          	slli	a4,a4,0x18
4001c034:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001c038:	06071263          	bnez	a4,4001c09c <net_ipv6_is_addr_unspecified+0xc0>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001c03c:	0097c703          	lbu	a4,9(a5)
4001c040:	0087c683          	lbu	a3,8(a5)
4001c044:	00871713          	slli	a4,a4,0x8
4001c048:	00d76733          	or	a4,a4,a3
4001c04c:	00a7c683          	lbu	a3,10(a5)
4001c050:	01069693          	slli	a3,a3,0x10
4001c054:	00e6e6b3          	or	a3,a3,a4
4001c058:	00b7c703          	lbu	a4,11(a5)
4001c05c:	01871713          	slli	a4,a4,0x18
4001c060:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001c064:	02071c63          	bnez	a4,4001c09c <net_ipv6_is_addr_unspecified+0xc0>
		UNALIGNED_GET(&addr->s6_addr32[3]) == 0;
4001c068:	00d7c683          	lbu	a3,13(a5)
4001c06c:	00c7c703          	lbu	a4,12(a5)
4001c070:	00f7c503          	lbu	a0,15(a5)
4001c074:	00869693          	slli	a3,a3,0x8
4001c078:	00e6e6b3          	or	a3,a3,a4
4001c07c:	00e7c703          	lbu	a4,14(a5)
4001c080:	01851513          	slli	a0,a0,0x18
4001c084:	01071713          	slli	a4,a4,0x10
4001c088:	00d76733          	or	a4,a4,a3
4001c08c:	00e56533          	or	a0,a0,a4
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001c090:	00153513          	seqz	a0,a0
4001c094:	00008067          	ret
4001c098:	00000513          	li	a0,0
}
4001c09c:	00008067          	ret

4001c0a0 <net_stats_update_ipv6_nd_drop>:
	UPDATE_STAT(iface, stats.ipv6_nd.drop++);
4001c0a0:	4003b7b7          	lui	a5,0x4003b
4001c0a4:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001c0a8:	0a07a703          	lw	a4,160(a5)
4001c0ac:	00170713          	addi	a4,a4,1
4001c0b0:	0ae7a023          	sw	a4,160(a5)
4001c0b4:	0a452783          	lw	a5,164(a0)
4001c0b8:	00178793          	addi	a5,a5,1
4001c0bc:	0af52223          	sw	a5,164(a0)
}
4001c0c0:	00008067          	ret

4001c0c4 <iface_cb>:
	net_nbr_cb_t cb;
	void *user_data;
};

static void iface_cb(struct net_if *iface, void *user_data)
{
4001c0c4:	fe010113          	addi	sp,sp,-32
4001c0c8:	00812c23          	sw	s0,24(sp)
4001c0cc:	40044437          	lui	s0,0x40044
4001c0d0:	09840413          	addi	s0,s0,152 # 40044098 <net_neighbor_pool>
4001c0d4:	00912a23          	sw	s1,20(sp)
4001c0d8:	01212823          	sw	s2,16(sp)
4001c0dc:	01312623          	sw	s3,12(sp)
4001c0e0:	00112e23          	sw	ra,28(sp)
4001c0e4:	00050913          	mv	s2,a0
4001c0e8:	00058493          	mv	s1,a1
	struct iface_cb_data *data = user_data;
	int i;

	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001c0ec:	2a040993          	addi	s3,s0,672
		struct net_nbr *nbr = get_nbr(i);

		if (!nbr->ref || nbr->iface != iface) {
4001c0f0:	00044783          	lbu	a5,0(s0)
4001c0f4:	00078e63          	beqz	a5,4001c110 <iface_cb+0x4c>
4001c0f8:	00842783          	lw	a5,8(s0)
4001c0fc:	01279a63          	bne	a5,s2,4001c110 <iface_cb+0x4c>
			continue;
		}

		data->cb(nbr, data->user_data);
4001c100:	0004a783          	lw	a5,0(s1)
4001c104:	0044a583          	lw	a1,4(s1)
4001c108:	00040513          	mv	a0,s0
4001c10c:	000780e7          	jalr	a5
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001c110:	05440413          	addi	s0,s0,84
4001c114:	fd341ee3          	bne	s0,s3,4001c0f0 <iface_cb+0x2c>
	}
}
4001c118:	01c12083          	lw	ra,28(sp)
4001c11c:	01812403          	lw	s0,24(sp)
4001c120:	01412483          	lw	s1,20(sp)
4001c124:	01012903          	lw	s2,16(sp)
4001c128:	00c12983          	lw	s3,12(sp)
4001c12c:	02010113          	addi	sp,sp,32
4001c130:	00008067          	ret

4001c134 <net_neighbor_data_remove>:
void net_neighbor_data_remove(struct net_nbr *nbr)
{
	NET_DBG("Neighbor %p removed", nbr);

	return;
}
4001c134:	00008067          	ret

4001c138 <nbr_clear_ns_pending>:
{
4001c138:	ff010113          	addi	sp,sp,-16
4001c13c:	00812423          	sw	s0,8(sp)
4001c140:	00112623          	sw	ra,12(sp)
	data->send_ns = 0;
4001c144:	00000793          	li	a5,0
4001c148:	00000813          	li	a6,0
{
4001c14c:	00050413          	mv	s0,a0
	data->send_ns = 0;
4001c150:	02f52423          	sw	a5,40(a0)
4001c154:	03052623          	sw	a6,44(a0)
	if (data->pending) {
4001c158:	00052503          	lw	a0,0(a0)
4001c15c:	00050663          	beqz	a0,4001c168 <nbr_clear_ns_pending+0x30>
		net_pkt_unref(data->pending);
4001c160:	ebcfb0ef          	jal	ra,4001781c <net_pkt_unref>
		data->pending = NULL;
4001c164:	00042023          	sw	zero,0(s0)
}
4001c168:	00c12083          	lw	ra,12(sp)
4001c16c:	00812403          	lw	s0,8(sp)
4001c170:	01010113          	addi	sp,sp,16
4001c174:	00008067          	ret

4001c178 <nbr_free>:
{
4001c178:	ff010113          	addi	sp,sp,-16
4001c17c:	00112623          	sw	ra,12(sp)
4001c180:	00812423          	sw	s0,8(sp)
4001c184:	00050413          	mv	s0,a0
	nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
4001c188:	00c52503          	lw	a0,12(a0)
4001c18c:	fadff0ef          	jal	ra,4001c138 <nbr_clear_ns_pending>
	return (struct net_ipv6_nbr_data *)nbr->data;
4001c190:	00c42783          	lw	a5,12(s0)
	net_ipv6_nbr_data(nbr)->reachable = 0;
4001c194:	00000693          	li	a3,0
4001c198:	00000713          	li	a4,0
4001c19c:	00d7ac23          	sw	a3,24(a5)
4001c1a0:	00e7ae23          	sw	a4,28(a5)
4001c1a4:	00c42783          	lw	a5,12(s0)
	net_nbr_unref(nbr);
4001c1a8:	00040513          	mv	a0,s0
	net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
4001c1ac:	0207a023          	sw	zero,32(a5)
	net_nbr_unref(nbr);
4001c1b0:	8dcff0ef          	jal	ra,4001b28c <net_nbr_unref>
	net_nbr_unlink(nbr, NULL);
4001c1b4:	00040513          	mv	a0,s0
}
4001c1b8:	00812403          	lw	s0,8(sp)
4001c1bc:	00c12083          	lw	ra,12(sp)
	net_nbr_unlink(nbr, NULL);
4001c1c0:	00000593          	li	a1,0
}
4001c1c4:	01010113          	addi	sp,sp,16
	net_nbr_unlink(nbr, NULL);
4001c1c8:	ab0ff06f          	j	4001b478 <net_nbr_unlink>

4001c1cc <k_uptime_get>:
{
4001c1cc:	ff010113          	addi	sp,sp,-16
4001c1d0:	00112623          	sw	ra,12(sp)
	return z_impl_k_uptime_ticks();
4001c1d4:	480150ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
			return t * ((uint64_t)to_hz / from_hz);
4001c1d8:	00a00793          	li	a5,10
4001c1dc:	02a7b733          	mulhu	a4,a5,a0
}
4001c1e0:	00c12083          	lw	ra,12(sp)
4001c1e4:	01010113          	addi	sp,sp,16
4001c1e8:	02b785b3          	mul	a1,a5,a1
4001c1ec:	02a78533          	mul	a0,a5,a0
4001c1f0:	00e585b3          	add	a1,a1,a4
4001c1f4:	00008067          	ret

4001c1f8 <ipv6_ns_reply_timeout>:
{
4001c1f8:	fe010113          	addi	sp,sp,-32
4001c1fc:	00912a23          	sw	s1,20(sp)
4001c200:	400444b7          	lui	s1,0x40044
4001c204:	01412423          	sw	s4,8(sp)
4001c208:	01512223          	sw	s5,4(sp)
4001c20c:	01612023          	sw	s6,0(sp)
4001c210:	00112e23          	sw	ra,28(sp)
4001c214:	00812c23          	sw	s0,24(sp)
4001c218:	01212823          	sw	s2,16(sp)
4001c21c:	01312623          	sw	s3,12(sp)
4001c220:	09848493          	addi	s1,s1,152 # 40044098 <net_neighbor_pool>
	int64_t current = k_uptime_get();
4001c224:	fa9ff0ef          	jal	ra,4001c1cc <k_uptime_get>
4001c228:	00050a13          	mv	s4,a0
4001c22c:	00058a93          	mv	s5,a1
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001c230:	2a048b13          	addi	s6,s1,672
		if (!nbr || !nbr->ref) {
4001c234:	0004c783          	lbu	a5,0(s1)
4001c238:	08078263          	beqz	a5,4001c2bc <ipv6_ns_reply_timeout+0xc4>
4001c23c:	00c4a903          	lw	s2,12(s1)
		if (!data) {
4001c240:	06090e63          	beqz	s2,4001c2bc <ipv6_ns_reply_timeout+0xc4>
		if (!data->send_ns) {
4001c244:	02892403          	lw	s0,40(s2)
4001c248:	02c92703          	lw	a4,44(s2)
4001c24c:	00e467b3          	or	a5,s0,a4
4001c250:	06078663          	beqz	a5,4001c2bc <ipv6_ns_reply_timeout+0xc4>
		remaining = data->send_ns + NS_REPLY_TIMEOUT - current;
4001c254:	3e840793          	addi	a5,s0,1000
4001c258:	0087b433          	sltu	s0,a5,s0
4001c25c:	00e40433          	add	s0,s0,a4
4001c260:	414789b3          	sub	s3,a5,s4
4001c264:	0137b7b3          	sltu	a5,a5,s3
4001c268:	41540433          	sub	s0,s0,s5
4001c26c:	40f40433          	sub	s0,s0,a5
		if (remaining > 0) {
4001c270:	00804663          	bgtz	s0,4001c27c <ipv6_ns_reply_timeout+0x84>
4001c274:	06041c63          	bnez	s0,4001c2ec <ipv6_ns_reply_timeout+0xf4>
4001c278:	06098a63          	beqz	s3,4001c2ec <ipv6_ns_reply_timeout+0xf4>
	return z_timeout_remaining(&dwork->timeout);
4001c27c:	4003a537          	lui	a0,0x4003a
4001c280:	bf050513          	addi	a0,a0,-1040 # 40039bf0 <ipv6_ns_reply_timer+0x10>
4001c284:	204150ef          	jal	ra,40031488 <z_timeout_remaining>
			if (!k_work_delayable_remaining_get(
4001c288:	00b56533          	or	a0,a0,a1
4001c28c:	02051863          	bnez	a0,4001c2bc <ipv6_ns_reply_timeout+0xc4>
		t += off;
4001c290:	00998513          	addi	a0,s3,9
4001c294:	013539b3          	sltu	s3,a0,s3
			return t / ((uint64_t)from_hz / to_hz);
4001c298:	00a00613          	li	a2,10
4001c29c:	00000693          	li	a3,0
4001c2a0:	008985b3          	add	a1,s3,s0
4001c2a4:	814e40ef          	jal	ra,400002b8 <__udivdi3>
				k_work_reschedule(&ipv6_ns_reply_timer,
4001c2a8:	00058613          	mv	a2,a1
4001c2ac:	00050593          	mv	a1,a0
4001c2b0:	4003a537          	lui	a0,0x4003a
4001c2b4:	be050513          	addi	a0,a0,-1056 # 40039be0 <ipv6_ns_reply_timer>
4001c2b8:	69d130ef          	jal	ra,40030154 <k_work_reschedule>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001c2bc:	05448493          	addi	s1,s1,84
4001c2c0:	f7649ae3          	bne	s1,s6,4001c234 <ipv6_ns_reply_timeout+0x3c>
}
4001c2c4:	01c12083          	lw	ra,28(sp)
4001c2c8:	01812403          	lw	s0,24(sp)
4001c2cc:	01412483          	lw	s1,20(sp)
4001c2d0:	01012903          	lw	s2,16(sp)
4001c2d4:	00c12983          	lw	s3,12(sp)
4001c2d8:	00812a03          	lw	s4,8(sp)
4001c2dc:	00412a83          	lw	s5,4(sp)
4001c2e0:	00012b03          	lw	s6,0(sp)
4001c2e4:	02010113          	addi	sp,sp,32
4001c2e8:	00008067          	ret
		if (!data->pending) {
4001c2ec:	00092503          	lw	a0,0(s2)
		data->send_ns = 0;
4001c2f0:	00000793          	li	a5,0
4001c2f4:	00000813          	li	a6,0
4001c2f8:	02f92423          	sw	a5,40(s2)
4001c2fc:	03092623          	sw	a6,44(s2)
		if (!data->pending) {
4001c300:	fa050ee3          	beqz	a0,4001c2bc <ipv6_ns_reply_timeout+0xc4>
		net_pkt_unref(data->pending);
4001c304:	d18fb0ef          	jal	ra,4001781c <net_pkt_unref>
		net_pkt_unref(data->pending);
4001c308:	00092503          	lw	a0,0(s2)
4001c30c:	d10fb0ef          	jal	ra,4001781c <net_pkt_unref>
		net_nbr_unref(nbr);
4001c310:	00048513          	mv	a0,s1
		data->pending = NULL;
4001c314:	00092023          	sw	zero,0(s2)
		net_nbr_unref(nbr);
4001c318:	f75fe0ef          	jal	ra,4001b28c <net_nbr_unref>
4001c31c:	fa1ff06f          	j	4001c2bc <ipv6_ns_reply_timeout+0xc4>

4001c320 <set_llao>:
}

static inline bool set_llao(struct net_pkt *pkt,
			    struct net_linkaddr *lladdr,
			    uint8_t llao_len, uint8_t type)
{
4001c320:	fe010113          	addi	sp,sp,-32
4001c324:	00812c23          	sw	s0,24(sp)
4001c328:	00912a23          	sw	s1,20(sp)
	struct net_icmpv6_nd_opt_hdr opt_hdr = {
4001c32c:	00365793          	srli	a5,a2,0x3
{
4001c330:	00058493          	mv	s1,a1
4001c334:	00060413          	mv	s0,a2
		.type = type,
		.len  = llao_len >> 3,
	};

	if (net_pkt_write(pkt, &opt_hdr,
4001c338:	00c10593          	addi	a1,sp,12
4001c33c:	00200613          	li	a2,2
{
4001c340:	01212823          	sw	s2,16(sp)
4001c344:	00112e23          	sw	ra,28(sp)
4001c348:	00050913          	mv	s2,a0
	struct net_icmpv6_nd_opt_hdr opt_hdr = {
4001c34c:	00d10623          	sb	a3,12(sp)
4001c350:	00f106a3          	sb	a5,13(sp)
	if (net_pkt_write(pkt, &opt_hdr,
4001c354:	d30fc0ef          	jal	ra,40018884 <net_pkt_write>
4001c358:	02050063          	beqz	a0,4001c378 <set_llao+0x58>
			  sizeof(struct net_icmpv6_nd_opt_hdr)) ||
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
	    net_pkt_memset(pkt, 0, llao_len - lladdr->len - 2)) {
		return false;
4001c35c:	00000513          	li	a0,0
	}

	return true;
}
4001c360:	01c12083          	lw	ra,28(sp)
4001c364:	01812403          	lw	s0,24(sp)
4001c368:	01412483          	lw	s1,20(sp)
4001c36c:	01012903          	lw	s2,16(sp)
4001c370:	02010113          	addi	sp,sp,32
4001c374:	00008067          	ret
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
4001c378:	0044c603          	lbu	a2,4(s1)
4001c37c:	0004a583          	lw	a1,0(s1)
4001c380:	00090513          	mv	a0,s2
4001c384:	d00fc0ef          	jal	ra,40018884 <net_pkt_write>
			  sizeof(struct net_icmpv6_nd_opt_hdr)) ||
4001c388:	fc051ae3          	bnez	a0,4001c35c <set_llao+0x3c>
	    net_pkt_memset(pkt, 0, llao_len - lladdr->len - 2)) {
4001c38c:	0044c783          	lbu	a5,4(s1)
4001c390:	00000593          	li	a1,0
4001c394:	00090513          	mv	a0,s2
4001c398:	40f40633          	sub	a2,s0,a5
4001c39c:	ffe60613          	addi	a2,a2,-2
4001c3a0:	f71fb0ef          	jal	ra,40018310 <net_pkt_memset>
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
4001c3a4:	00153513          	seqz	a0,a0
4001c3a8:	fb9ff06f          	j	4001c360 <set_llao+0x40>

4001c3ac <read_llao>:

static bool read_llao(struct net_pkt *pkt,
		      uint8_t len,
		      struct net_linkaddr_storage *llstorage)
{
4001c3ac:	ff010113          	addi	sp,sp,-16
4001c3b0:	00812423          	sw	s0,8(sp)
4001c3b4:	00912223          	sw	s1,4(sp)
4001c3b8:	01212023          	sw	s2,0(sp)
4001c3bc:	00112623          	sw	ra,12(sp)
	uint8_t padding;

	llstorage->len = NET_LINK_ADDR_MAX_LENGTH;
4001c3c0:	00600793          	li	a5,6
4001c3c4:	00f600a3          	sb	a5,1(a2)
	if (net_pkt_lladdr_src(pkt)->len < llstorage->len) {
4001c3c8:	02854703          	lbu	a4,40(a0)
{
4001c3cc:	00060493          	mv	s1,a2
4001c3d0:	00050913          	mv	s2,a0
4001c3d4:	00058413          	mv	s0,a1
	if (net_pkt_lladdr_src(pkt)->len < llstorage->len) {
4001c3d8:	00600613          	li	a2,6
4001c3dc:	00e7e463          	bltu	a5,a4,4001c3e4 <read_llao+0x38>
4001c3e0:	0ff77613          	zext.b	a2,a4
4001c3e4:	00c480a3          	sb	a2,1(s1)
		llstorage->len = net_pkt_lladdr_src(pkt)->len;
	}

	if (net_pkt_read(pkt, llstorage->addr, llstorage->len)) {
4001c3e8:	00248593          	addi	a1,s1,2
4001c3ec:	00090513          	mv	a0,s2
4001c3f0:	f49fb0ef          	jal	ra,40018338 <net_pkt_read>
		return false;
4001c3f4:	00000793          	li	a5,0
	if (net_pkt_read(pkt, llstorage->addr, llstorage->len)) {
4001c3f8:	02051663          	bnez	a0,4001c424 <read_llao+0x78>
	}

	padding = len * 8U - 2 - llstorage->len;
4001c3fc:	0014c783          	lbu	a5,1(s1)
4001c400:	00341593          	slli	a1,s0,0x3
4001c404:	ffe58593          	addi	a1,a1,-2
4001c408:	40f585b3          	sub	a1,a1,a5
4001c40c:	0ff5f593          	zext.b	a1,a1
		if (net_pkt_skip(pkt, padding)) {
			return false;
		}
	}

	return true;
4001c410:	00100793          	li	a5,1
	if (padding) {
4001c414:	00058863          	beqz	a1,4001c424 <read_llao+0x78>
		if (net_pkt_skip(pkt, padding)) {
4001c418:	00090513          	mv	a0,s2
4001c41c:	cb5fb0ef          	jal	ra,400180d0 <net_pkt_skip>
4001c420:	00153793          	seqz	a5,a0
}
4001c424:	00c12083          	lw	ra,12(sp)
4001c428:	00812403          	lw	s0,8(sp)
4001c42c:	00412483          	lw	s1,4(sp)
4001c430:	00012903          	lw	s2,0(sp)
4001c434:	00078513          	mv	a0,a5
4001c438:	01010113          	addi	sp,sp,16
4001c43c:	00008067          	ret

4001c440 <ipv6_nd_restart_reachable_timer>:
}
#endif /* CONFIG_NET_IPV6_NBR_CACHE */

#if defined(CONFIG_NET_IPV6_ND)
static void ipv6_nd_restart_reachable_timer(struct net_nbr *nbr, int64_t time)
{
4001c440:	fe010113          	addi	sp,sp,-32
4001c444:	00812c23          	sw	s0,24(sp)
4001c448:	00912a23          	sw	s1,20(sp)
4001c44c:	00112e23          	sw	ra,28(sp)
4001c450:	01212823          	sw	s2,16(sp)
4001c454:	01312623          	sw	s3,12(sp)
4001c458:	00058413          	mv	s0,a1
4001c45c:	00060493          	mv	s1,a2
	int64_t remaining;

	if (nbr) {
4001c460:	02050063          	beqz	a0,4001c480 <ipv6_nd_restart_reachable_timer+0x40>
4001c464:	00c52983          	lw	s3,12(a0)
4001c468:	00050913          	mv	s2,a0
		net_ipv6_nbr_data(nbr)->reachable = k_uptime_get();
4001c46c:	d61ff0ef          	jal	ra,4001c1cc <k_uptime_get>
4001c470:	00a9ac23          	sw	a0,24(s3)
4001c474:	00b9ae23          	sw	a1,28(s3)
4001c478:	00c92783          	lw	a5,12(s2)
		net_ipv6_nbr_data(nbr)->reachable_timeout = time;
4001c47c:	0287a023          	sw	s0,32(a5)
4001c480:	4003a537          	lui	a0,0x4003a
4001c484:	c2050513          	addi	a0,a0,-992 # 40039c20 <ipv6_nd_reachable_timer+0x10>
4001c488:	000150ef          	jal	ra,40031488 <z_timeout_remaining>
			return ((uint32_t)t) * (to_hz / from_hz);
4001c48c:	00a00793          	li	a5,10
4001c490:	02a78533          	mul	a0,a5,a0
	}

	remaining = k_ticks_to_ms_ceil32(
4001c494:	00000793          	li	a5,0
		k_work_delayable_remaining_get(&ipv6_nd_reachable_timer));
	if (!remaining || remaining > time) {
4001c498:	00050863          	beqz	a0,4001c4a8 <ipv6_nd_restart_reachable_timer+0x68>
4001c49c:	00f4c663          	blt	s1,a5,4001c4a8 <ipv6_nd_restart_reachable_timer+0x68>
4001c4a0:	04049c63          	bnez	s1,4001c4f8 <ipv6_nd_restart_reachable_timer+0xb8>
4001c4a4:	04a47a63          	bgeu	s0,a0,4001c4f8 <ipv6_nd_restart_reachable_timer+0xb8>
		k_work_reschedule(&ipv6_nd_reachable_timer, K_MSEC(time));
4001c4a8:	0004d663          	bgez	s1,4001c4b4 <ipv6_nd_restart_reachable_timer+0x74>
4001c4ac:	00000413          	li	s0,0
4001c4b0:	00000493          	li	s1,0
		t += off;
4001c4b4:	00940513          	addi	a0,s0,9
4001c4b8:	00853433          	sltu	s0,a0,s0
			return t / ((uint64_t)from_hz / to_hz);
4001c4bc:	009405b3          	add	a1,s0,s1
4001c4c0:	00a00613          	li	a2,10
4001c4c4:	00000693          	li	a3,0
4001c4c8:	df1e30ef          	jal	ra,400002b8 <__udivdi3>
	}
}
4001c4cc:	01812403          	lw	s0,24(sp)
4001c4d0:	01c12083          	lw	ra,28(sp)
4001c4d4:	01412483          	lw	s1,20(sp)
4001c4d8:	01012903          	lw	s2,16(sp)
4001c4dc:	00c12983          	lw	s3,12(sp)
		k_work_reschedule(&ipv6_nd_reachable_timer, K_MSEC(time));
4001c4e0:	00058613          	mv	a2,a1
4001c4e4:	00050593          	mv	a1,a0
4001c4e8:	4003a537          	lui	a0,0x4003a
4001c4ec:	c1050513          	addi	a0,a0,-1008 # 40039c10 <ipv6_nd_reachable_timer>
}
4001c4f0:	02010113          	addi	sp,sp,32
		k_work_reschedule(&ipv6_nd_reachable_timer, K_MSEC(time));
4001c4f4:	4611306f          	j	40030154 <k_work_reschedule>
}
4001c4f8:	01c12083          	lw	ra,28(sp)
4001c4fc:	01812403          	lw	s0,24(sp)
4001c500:	01412483          	lw	s1,20(sp)
4001c504:	01012903          	lw	s2,16(sp)
4001c508:	00c12983          	lw	s3,12(sp)
4001c50c:	02010113          	addi	sp,sp,32
4001c510:	00008067          	ret

4001c514 <nbr_lookup.constprop.0>:
static struct net_nbr *nbr_lookup(struct net_nbr_table *table,
4001c514:	fe010113          	addi	sp,sp,-32
4001c518:	400447b7          	lui	a5,0x40044
4001c51c:	00812c23          	sw	s0,24(sp)
4001c520:	00912a23          	sw	s1,20(sp)
4001c524:	01212823          	sw	s2,16(sp)
4001c528:	01312623          	sw	s3,12(sp)
4001c52c:	01412423          	sw	s4,8(sp)
4001c530:	01512223          	sw	s5,4(sp)
4001c534:	00112e23          	sw	ra,28(sp)
4001c538:	00050993          	mv	s3,a0
4001c53c:	00058a13          	mv	s4,a1
4001c540:	09878913          	addi	s2,a5,152 # 40044098 <net_neighbor_pool>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001c544:	00000493          	li	s1,0
4001c548:	09878413          	addi	s0,a5,152
4001c54c:	00800a93          	li	s5,8
		if (!nbr->ref) {
4001c550:	00094783          	lbu	a5,0(s2)
4001c554:	02079c63          	bnez	a5,4001c58c <nbr_lookup.constprop.0+0x78>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001c558:	00148493          	addi	s1,s1,1
4001c55c:	05490913          	addi	s2,s2,84
4001c560:	ff5498e3          	bne	s1,s5,4001c550 <nbr_lookup.constprop.0+0x3c>
	return NULL;
4001c564:	00000513          	li	a0,0
}
4001c568:	01c12083          	lw	ra,28(sp)
4001c56c:	01812403          	lw	s0,24(sp)
4001c570:	01412483          	lw	s1,20(sp)
4001c574:	01012903          	lw	s2,16(sp)
4001c578:	00c12983          	lw	s3,12(sp)
4001c57c:	00812a03          	lw	s4,8(sp)
4001c580:	00412a83          	lw	s5,4(sp)
4001c584:	02010113          	addi	sp,sp,32
4001c588:	00008067          	ret
		if (iface && nbr->iface != iface) {
4001c58c:	00098663          	beqz	s3,4001c598 <nbr_lookup.constprop.0+0x84>
4001c590:	00892783          	lw	a5,8(s2)
4001c594:	fcf992e3          	bne	s3,a5,4001c558 <nbr_lookup.constprop.0+0x44>
		if (net_ipv6_addr_cmp(&net_ipv6_nbr_data(nbr)->addr, addr)) {
4001c598:	00c92503          	lw	a0,12(s2)
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4001c59c:	01000613          	li	a2,16
4001c5a0:	000a0593          	mv	a1,s4
4001c5a4:	00450513          	addi	a0,a0,4
4001c5a8:	ed0f00ef          	jal	ra,4000cc78 <memcmp>
4001c5ac:	fa0516e3          	bnez	a0,4001c558 <nbr_lookup.constprop.0+0x44>
	return &net_neighbor_pool[idx].nbr;
4001c5b0:	05400793          	li	a5,84
4001c5b4:	02f484b3          	mul	s1,s1,a5
4001c5b8:	00940533          	add	a0,s0,s1
4001c5bc:	fadff06f          	j	4001c568 <nbr_lookup.constprop.0+0x54>

4001c5c0 <z_log_msg_static_create.constprop.0>:
4001c5c0:	00000693          	li	a3,0
4001c5c4:	9d1e806f          	j	40004f94 <z_impl_z_log_msg_static_create>

4001c5c8 <dad_failed.part.0.isra.0>:
		NET_ERR("DAD failed, no ll IPv6 address!");
4001c5c8:	40044537          	lui	a0,0x40044
4001c5cc:	77c52783          	lw	a5,1916(a0) # 4004477c <log_dynamic_net_ipv6>
4001c5d0:	0077f793          	andi	a5,a5,7
4001c5d4:	04078063          	beqz	a5,4001c614 <dad_failed.part.0.isra.0+0x4c>
static inline bool dad_failed(struct net_if *iface, struct in6_addr *addr)
4001c5d8:	fd010113          	addi	sp,sp,-48
4001c5dc:	02112623          	sw	ra,44(sp)
		NET_ERR("DAD failed, no ll IPv6 address!");
4001c5e0:	400357b7          	lui	a5,0x40035
4001c5e4:	fb878793          	addi	a5,a5,-72 # 40034fb8 <all_nodes_mcast_group.0+0x1c>
4001c5e8:	000015b7          	lui	a1,0x1
4001c5ec:	00f12e23          	sw	a5,28(sp)
4001c5f0:	01810613          	addi	a2,sp,24
4001c5f4:	00200793          	li	a5,2
4001c5f8:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4001c5fc:	77c50513          	addi	a0,a0,1916
4001c600:	00f12c23          	sw	a5,24(sp)
4001c604:	fbdff0ef          	jal	ra,4001c5c0 <z_log_msg_static_create.constprop.0>
}
4001c608:	02c12083          	lw	ra,44(sp)
4001c60c:	03010113          	addi	sp,sp,48
4001c610:	00008067          	ret
4001c614:	00008067          	ret

4001c618 <net_if_flag_is_set>:
	if (iface == NULL) {
4001c618:	02050c63          	beqz	a0,4001c650 <net_if_flag_is_set+0x38>
{
4001c61c:	ff010113          	addi	sp,sp,-16
4001c620:	00812423          	sw	s0,8(sp)
4001c624:	00112623          	sw	ra,12(sp)
	return atomic_test_bit(iface->if_dev->flags, value);
4001c628:	00052503          	lw	a0,0(a0)
4001c62c:	00058413          	mv	s0,a1
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
4001c630:	00c50513          	addi	a0,a0,12
4001c634:	454150ef          	jal	ra,40031a88 <atomic_get>
}
4001c638:	00c12083          	lw	ra,12(sp)
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
4001c63c:	40855533          	sra	a0,a0,s0
4001c640:	00812403          	lw	s0,8(sp)
4001c644:	00157513          	andi	a0,a0,1
4001c648:	01010113          	addi	sp,sp,16
4001c64c:	00008067          	ret
		return false;
4001c650:	00000513          	li	a0,0
}
4001c654:	00008067          	ret

4001c658 <net_pkt_acknowledge_data.isra.0>:
	return net_pkt_skip(pkt, access->size);
4001c658:	a79fb06f          	j	400180d0 <net_pkt_skip>

4001c65c <net_linkaddr_set.isra.0>:
	if (!lladdr_store || !new_addr) {
4001c65c:	00050e63          	beqz	a0,4001c678 <net_linkaddr_set.isra.0+0x1c>
4001c660:	00058c63          	beqz	a1,4001c678 <net_linkaddr_set.isra.0+0x1c>
	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
4001c664:	00600713          	li	a4,6
4001c668:	00c76863          	bltu	a4,a2,4001c678 <net_linkaddr_set.isra.0+0x1c>
	lladdr_store->len = new_len;
4001c66c:	00c500a3          	sb	a2,1(a0)
	memcpy(lladdr_store->addr, new_addr, new_len);
4001c670:	00250513          	addi	a0,a0,2
4001c674:	e84f006f          	j	4000ccf8 <memcpy>

	return 0;
}
4001c678:	00008067          	ret

4001c67c <net_neighbor_table_clear>:
void net_neighbor_table_clear(struct net_nbr_table *table)
4001c67c:	00008067          	ret

4001c680 <dbg_update_neighbor_lladdr.constprop.0>:
static void dbg_update_neighbor_lladdr(const struct net_linkaddr *new_lladdr,
4001c680:	fd010113          	addi	sp,sp,-48
4001c684:	02112623          	sw	ra,44(sp)

static inline char *net_sprint_ll_addr(const uint8_t *ll, uint8_t ll_len)
{
	static char buf[sizeof("xx:xx:xx:xx:xx:xx:xx:xx")];

	return net_sprint_ll_addr_buf(ll, ll_len, (char *)buf, sizeof(buf));
4001c688:	00154583          	lbu	a1,1(a0)
4001c68c:	4003b637          	lui	a2,0x4003b
4001c690:	01800693          	li	a3,24
4001c694:	ea060613          	addi	a2,a2,-352 # 4003aea0 <buf.0>
4001c698:	00250513          	addi	a0,a0,2
4001c69c:	df9f70ef          	jal	ra,40014494 <net_sprint_ll_addr_buf>
	snprintk(out, sizeof(out), "%s",
4001c6a0:	40033637          	lui	a2,0x40033
4001c6a4:	00050693          	mv	a3,a0
4001c6a8:	af860613          	addi	a2,a2,-1288 # 40032af8 <mpsc_config+0x9c>
4001c6ac:	00810513          	addi	a0,sp,8
4001c6b0:	01800593          	li	a1,24
4001c6b4:	e68e50ef          	jal	ra,40001d1c <snprintk>
}
4001c6b8:	02c12083          	lw	ra,44(sp)
4001c6bc:	03010113          	addi	sp,sp,48
4001c6c0:	00008067          	ret

4001c6c4 <ipv6_nbr_set_state>:
4001c6c4:	00c52783          	lw	a5,12(a0)
	if (new_state == net_ipv6_nbr_data(nbr)->state ||
4001c6c8:	0307a703          	lw	a4,48(a5)
4001c6cc:	0eb70663          	beq	a4,a1,4001c7b8 <ipv6_nbr_set_state+0xf4>
4001c6d0:	00500693          	li	a3,5
4001c6d4:	0ed70263          	beq	a4,a3,4001c7b8 <ipv6_nbr_set_state+0xf4>
{
4001c6d8:	ff010113          	addi	sp,sp,-16
4001c6dc:	00812423          	sw	s0,8(sp)
4001c6e0:	00112623          	sw	ra,12(sp)
4001c6e4:	00912223          	sw	s1,4(sp)
4001c6e8:	01212023          	sw	s2,0(sp)
	net_ipv6_nbr_data(nbr)->state = new_state;
4001c6ec:	02b7a823          	sw	a1,48(a5)
4001c6f0:	00c52703          	lw	a4,12(a0)
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_STALE) {
4001c6f4:	00200793          	li	a5,2
4001c6f8:	00050413          	mv	s0,a0
4001c6fc:	03072683          	lw	a3,48(a4)
4001c700:	02f69063          	bne	a3,a5,4001c720 <ipv6_nbr_set_state+0x5c>
		if (stale_counter + 1 != UINT32_MAX) {
4001c704:	400394b7          	lui	s1,0x40039
4001c708:	0ac4a783          	lw	a5,172(s1) # 400390ac <stale_counter>
4001c70c:	ffe00693          	li	a3,-2
4001c710:	02d78463          	beq	a5,a3,4001c738 <ipv6_nbr_set_state+0x74>
			net_ipv6_nbr_data(nbr)->stale_counter = stale_counter++;
4001c714:	00178693          	addi	a3,a5,1
4001c718:	0ad4a623          	sw	a3,172(s1)
4001c71c:	02f72c23          	sw	a5,56(a4)
}
4001c720:	00c12083          	lw	ra,12(sp)
4001c724:	00812403          	lw	s0,8(sp)
4001c728:	00412483          	lw	s1,4(sp)
4001c72c:	00012903          	lw	s2,0(sp)
4001c730:	01010113          	addi	sp,sp,16
4001c734:	00008067          	ret
	return z_impl_k_sem_take(sem, timeout);
4001c738:	4003b937          	lui	s2,0x4003b
4001c73c:	fff00593          	li	a1,-1
4001c740:	fff00613          	li	a2,-1
4001c744:	eb890513          	addi	a0,s2,-328 # 4003aeb8 <nbr_lock>
4001c748:	260130ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
			stale_counter = 0U;
4001c74c:	400447b7          	lui	a5,0x40044
4001c750:	09878793          	addi	a5,a5,152 # 40044098 <net_neighbor_pool>
4001c754:	0a04a623          	sw	zero,172(s1)
			for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001c758:	2a078593          	addi	a1,a5,672
			stale_counter = 0U;
4001c75c:	00000613          	li	a2,0
4001c760:	00000713          	li	a4,0
				if (data->state != NET_IPV6_NBR_STATE_STALE) {
4001c764:	00200513          	li	a0,2
				if (!n || !n->ref) {
4001c768:	0007c683          	lbu	a3,0(a5)
4001c76c:	02068063          	beqz	a3,4001c78c <ipv6_nbr_set_state+0xc8>
4001c770:	00c42683          	lw	a3,12(s0)
				if (!data) {
4001c774:	00068c63          	beqz	a3,4001c78c <ipv6_nbr_set_state+0xc8>
				if (data->state != NET_IPV6_NBR_STATE_STALE) {
4001c778:	0306a803          	lw	a6,48(a3)
4001c77c:	00a81863          	bne	a6,a0,4001c78c <ipv6_nbr_set_state+0xc8>
				data->stale_counter = stale_counter++;
4001c780:	02e6ac23          	sw	a4,56(a3)
4001c784:	00100613          	li	a2,1
4001c788:	00170713          	addi	a4,a4,1
			for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001c78c:	05478793          	addi	a5,a5,84
4001c790:	fcb79ce3          	bne	a5,a1,4001c768 <ipv6_nbr_set_state+0xa4>
4001c794:	00060463          	beqz	a2,4001c79c <ipv6_nbr_set_state+0xd8>
4001c798:	0ae4a623          	sw	a4,172(s1)
}
4001c79c:	00812403          	lw	s0,8(sp)
4001c7a0:	00c12083          	lw	ra,12(sp)
4001c7a4:	00412483          	lw	s1,4(sp)
	z_impl_k_sem_give(sem);
4001c7a8:	eb890513          	addi	a0,s2,-328
4001c7ac:	00012903          	lw	s2,0(sp)
4001c7b0:	01010113          	addi	sp,sp,16
4001c7b4:	1841306f          	j	4002f938 <z_impl_k_sem_give>
4001c7b8:	00008067          	ret

4001c7bc <nbr_new>:
{
4001c7bc:	fc010113          	addi	sp,sp,-64
4001c7c0:	03312623          	sw	s3,44(sp)
4001c7c4:	00050993          	mv	s3,a0
	struct net_nbr *nbr = net_nbr_get(&net_neighbor.table);
4001c7c8:	40044537          	lui	a0,0x40044
4001c7cc:	08c50513          	addi	a0,a0,140 # 4004408c <net_neighbor>
{
4001c7d0:	02812c23          	sw	s0,56(sp)
4001c7d4:	02912a23          	sw	s1,52(sp)
4001c7d8:	03212823          	sw	s2,48(sp)
4001c7dc:	02112e23          	sw	ra,60(sp)
4001c7e0:	00b12623          	sw	a1,12(sp)
4001c7e4:	00060493          	mv	s1,a2
4001c7e8:	00068913          	mv	s2,a3
	struct net_nbr *nbr = net_nbr_get(&net_neighbor.table);
4001c7ec:	ad5fe0ef          	jal	ra,4001b2c0 <net_nbr_get>
4001c7f0:	00050413          	mv	s0,a0
	if (!nbr) {
4001c7f4:	06050c63          	beqz	a0,4001c86c <nbr_new+0xb0>
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
4001c7f8:	00c12583          	lw	a1,12(sp)
	nbr->idx = NET_NBR_LLADDR_UNKNOWN;
4001c7fc:	fff00793          	li	a5,-1
	nbr->iface = iface;
4001c800:	01352423          	sw	s3,8(a0)
4001c804:	00c52983          	lw	s3,12(a0)
	nbr->idx = NET_NBR_LLADDR_UNKNOWN;
4001c808:	00f500a3          	sb	a5,1(a0)
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
4001c80c:	01000613          	li	a2,16
4001c810:	01010513          	addi	a0,sp,16
4001c814:	ce4f00ef          	jal	ra,4000ccf8 <memcpy>
4001c818:	01000613          	li	a2,16
4001c81c:	01010593          	addi	a1,sp,16
4001c820:	00498513          	addi	a0,s3,4
4001c824:	cd4f00ef          	jal	ra,4000ccf8 <memcpy>
	ipv6_nbr_set_state(nbr, state);
4001c828:	00090593          	mv	a1,s2
4001c82c:	00040513          	mv	a0,s0
4001c830:	e95ff0ef          	jal	ra,4001c6c4 <ipv6_nbr_set_state>
4001c834:	00c42783          	lw	a5,12(s0)
	net_ipv6_nbr_data(nbr)->send_ns = 0;
4001c838:	00000693          	li	a3,0
4001c83c:	00000713          	li	a4,0
	net_ipv6_nbr_data(nbr)->is_router = is_router;
4001c840:	02978ba3          	sb	s1,55(a5)
4001c844:	00c42783          	lw	a5,12(s0)
	net_ipv6_nbr_data(nbr)->pending = NULL;
4001c848:	0007a023          	sw	zero,0(a5)
4001c84c:	00c42783          	lw	a5,12(s0)
	net_ipv6_nbr_data(nbr)->send_ns = 0;
4001c850:	02d7a423          	sw	a3,40(a5)
4001c854:	02e7a623          	sw	a4,44(a5)
4001c858:	00c42783          	lw	a5,12(s0)
	net_ipv6_nbr_data(nbr)->reachable = 0;
4001c85c:	00d7ac23          	sw	a3,24(a5)
4001c860:	00e7ae23          	sw	a4,28(a5)
4001c864:	00c42783          	lw	a5,12(s0)
	net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
4001c868:	0207a023          	sw	zero,32(a5)
}
4001c86c:	03c12083          	lw	ra,60(sp)
4001c870:	00040513          	mv	a0,s0
4001c874:	03812403          	lw	s0,56(sp)
4001c878:	03412483          	lw	s1,52(sp)
4001c87c:	03012903          	lw	s2,48(sp)
4001c880:	02c12983          	lw	s3,44(sp)
4001c884:	04010113          	addi	sp,sp,64
4001c888:	00008067          	ret

4001c88c <net_ipv6_nbr_state2str>:
	switch (state) {
4001c88c:	00500793          	li	a5,5
4001c890:	00a7ee63          	bltu	a5,a0,4001c8ac <net_ipv6_nbr_state2str+0x20>
4001c894:	400357b7          	lui	a5,0x40035
4001c898:	00251513          	slli	a0,a0,0x2
4001c89c:	1f878793          	addi	a5,a5,504 # 400351f8 <CSWTCH.16862>
4001c8a0:	00a787b3          	add	a5,a5,a0
4001c8a4:	0007a503          	lw	a0,0(a5)
4001c8a8:	00008067          	ret
{
4001c8ac:	40035537          	lui	a0,0x40035
4001c8b0:	fd850513          	addi	a0,a0,-40 # 40034fd8 <all_nodes_mcast_group.0+0x3c>
}
4001c8b4:	00008067          	ret

4001c8b8 <net_ipv6_nbr_foreach>:
{
4001c8b8:	fe010113          	addi	sp,sp,-32
	struct iface_cb_data cb_data = {
4001c8bc:	00a12423          	sw	a0,8(sp)
	net_if_foreach(iface_cb, &cb_data);
4001c8c0:	4001c537          	lui	a0,0x4001c
	struct iface_cb_data cb_data = {
4001c8c4:	00b12623          	sw	a1,12(sp)
	net_if_foreach(iface_cb, &cb_data);
4001c8c8:	0c450513          	addi	a0,a0,196 # 4001c0c4 <iface_cb>
4001c8cc:	00810593          	addi	a1,sp,8
{
4001c8d0:	00112e23          	sw	ra,28(sp)
	net_if_foreach(iface_cb, &cb_data);
4001c8d4:	ad0f70ef          	jal	ra,40013ba4 <net_if_foreach>
}
4001c8d8:	01c12083          	lw	ra,28(sp)
4001c8dc:	02010113          	addi	sp,sp,32
4001c8e0:	00008067          	ret

4001c8e4 <net_ipv6_nbr_rm>:
{
4001c8e4:	ff010113          	addi	sp,sp,-16
4001c8e8:	00812423          	sw	s0,8(sp)
4001c8ec:	01212023          	sw	s2,0(sp)
4001c8f0:	00112623          	sw	ra,12(sp)
4001c8f4:	00912223          	sw	s1,4(sp)
4001c8f8:	00050413          	mv	s0,a0
4001c8fc:	00058913          	mv	s2,a1
	nbr = nbr_lookup(&net_neighbor.table, iface, addr);
4001c900:	c15ff0ef          	jal	ra,4001c514 <nbr_lookup.constprop.0>
	if (!nbr) {
4001c904:	04050863          	beqz	a0,4001c954 <net_ipv6_nbr_rm+0x70>
	net_route_del_by_nexthop(iface, addr);
4001c908:	00090593          	mv	a1,s2
4001c90c:	00050493          	mv	s1,a0
4001c910:	00040513          	mv	a0,s0
4001c914:	194030ef          	jal	ra,4001faa8 <net_route_del_by_nexthop>
	nbr_free(nbr);
4001c918:	00048513          	mv	a0,s1
4001c91c:	85dff0ef          	jal	ra,4001c178 <nbr_free>
4001c920:	e0600537          	lui	a0,0xe0600
4001c924:	01050513          	addi	a0,a0,16 # e0600010 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600011>
4001c928:	00000693          	li	a3,0
4001c92c:	00000613          	li	a2,0
4001c930:	00040593          	mv	a1,s0
4001c934:	d99f80ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
	return true;
4001c938:	00100513          	li	a0,1
}
4001c93c:	00c12083          	lw	ra,12(sp)
4001c940:	00812403          	lw	s0,8(sp)
4001c944:	00412483          	lw	s1,4(sp)
4001c948:	00012903          	lw	s2,0(sp)
4001c94c:	01010113          	addi	sp,sp,16
4001c950:	00008067          	ret
		return false;
4001c954:	00000513          	li	a0,0
4001c958:	fe5ff06f          	j	4001c93c <net_ipv6_nbr_rm+0x58>

4001c95c <add_nbr>:
{
4001c95c:	fe010113          	addi	sp,sp,-32
4001c960:	00812c23          	sw	s0,24(sp)
4001c964:	00912a23          	sw	s1,20(sp)
4001c968:	01212823          	sw	s2,16(sp)
4001c96c:	01312623          	sw	s3,12(sp)
4001c970:	00112e23          	sw	ra,28(sp)
4001c974:	01412423          	sw	s4,8(sp)
4001c978:	00050413          	mv	s0,a0
4001c97c:	00058493          	mv	s1,a1
4001c980:	00060913          	mv	s2,a2
4001c984:	00068993          	mv	s3,a3
	nbr = nbr_lookup(&net_neighbor.table, iface, addr);
4001c988:	b8dff0ef          	jal	ra,4001c514 <nbr_lookup.constprop.0>
	if (nbr) {
4001c98c:	0e051a63          	bnez	a0,4001ca80 <add_nbr+0x124>
	nbr = nbr_new(iface, addr, is_router, state);
4001c990:	00098693          	mv	a3,s3
4001c994:	00090613          	mv	a2,s2
4001c998:	00048593          	mv	a1,s1
4001c99c:	00040513          	mv	a0,s0
4001c9a0:	e1dff0ef          	jal	ra,4001c7bc <nbr_new>
	if (nbr) {
4001c9a4:	0c051e63          	bnez	a0,4001ca80 <add_nbr+0x124>
	return z_impl_k_sem_take(sem, timeout);
4001c9a8:	4003ba37          	lui	s4,0x4003b
4001c9ac:	fff00613          	li	a2,-1
4001c9b0:	fff00593          	li	a1,-1
4001c9b4:	eb8a0513          	addi	a0,s4,-328 # 4003aeb8 <nbr_lock>
4001c9b8:	7f1120ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001c9bc:	400447b7          	lui	a5,0x40044
4001c9c0:	09878613          	addi	a2,a5,152 # 40044098 <net_neighbor_pool>
	uint32_t oldest = UINT32_MAX;
4001c9c4:	fff00513          	li	a0,-1
	int nbr_idx = -1;
4001c9c8:	fff00713          	li	a4,-1
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001c9cc:	00000693          	li	a3,0
4001c9d0:	09878793          	addi	a5,a5,152
		if (!data || data->is_router ||
4001c9d4:	00200893          	li	a7,2
		if (nbr_idx == -1) {
4001c9d8:	fff00313          	li	t1,-1
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001c9dc:	00800813          	li	a6,8
		if (!nbr || !nbr->ref) {
4001c9e0:	00064583          	lbu	a1,0(a2)
4001c9e4:	02058a63          	beqz	a1,4001ca18 <add_nbr+0xbc>
4001c9e8:	00c62583          	lw	a1,12(a2)
		if (!data || data->is_router ||
4001c9ec:	02058663          	beqz	a1,4001ca18 <add_nbr+0xbc>
4001c9f0:	0375ce03          	lbu	t3,55(a1)
4001c9f4:	020e1263          	bnez	t3,4001ca18 <add_nbr+0xbc>
4001c9f8:	0305ae03          	lw	t3,48(a1)
4001c9fc:	011e1e63          	bne	t3,a7,4001ca18 <add_nbr+0xbc>
		if (nbr_idx == -1) {
4001ca00:	0385a583          	lw	a1,56(a1)
4001ca04:	00671863          	bne	a4,t1,4001ca14 <add_nbr+0xb8>
4001ca08:	00058513          	mv	a0,a1
4001ca0c:	00068713          	mv	a4,a3
4001ca10:	0080006f          	j	4001ca18 <add_nbr+0xbc>
		if (oldest == MIN(oldest, data->stale_counter)) {
4001ca14:	fea5eae3          	bltu	a1,a0,4001ca08 <add_nbr+0xac>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001ca18:	00168693          	addi	a3,a3,1
4001ca1c:	05460613          	addi	a2,a2,84
4001ca20:	fd0690e3          	bne	a3,a6,4001c9e0 <add_nbr+0x84>
	if (nbr_idx != -1) {
4001ca24:	fff00693          	li	a3,-1
4001ca28:	02d70063          	beq	a4,a3,4001ca48 <add_nbr+0xec>
4001ca2c:	05400693          	li	a3,84
4001ca30:	02d70733          	mul	a4,a4,a3
4001ca34:	00e787b3          	add	a5,a5,a4
		net_ipv6_nbr_rm(nbr->iface,
4001ca38:	00c7a583          	lw	a1,12(a5)
4001ca3c:	0087a503          	lw	a0,8(a5)
4001ca40:	00458593          	addi	a1,a1,4
4001ca44:	ea1ff0ef          	jal	ra,4001c8e4 <net_ipv6_nbr_rm>
	z_impl_k_sem_give(sem);
4001ca48:	eb8a0513          	addi	a0,s4,-328
4001ca4c:	6ed120ef          	jal	ra,4002f938 <z_impl_k_sem_give>
	nbr = nbr_new(iface, addr, is_router, state);
4001ca50:	00040513          	mv	a0,s0
}
4001ca54:	01812403          	lw	s0,24(sp)
4001ca58:	01c12083          	lw	ra,28(sp)
4001ca5c:	00812a03          	lw	s4,8(sp)
	nbr = nbr_new(iface, addr, is_router, state);
4001ca60:	00098693          	mv	a3,s3
4001ca64:	00090613          	mv	a2,s2
}
4001ca68:	00c12983          	lw	s3,12(sp)
4001ca6c:	01012903          	lw	s2,16(sp)
	nbr = nbr_new(iface, addr, is_router, state);
4001ca70:	00048593          	mv	a1,s1
}
4001ca74:	01412483          	lw	s1,20(sp)
4001ca78:	02010113          	addi	sp,sp,32
	nbr = nbr_new(iface, addr, is_router, state);
4001ca7c:	d41ff06f          	j	4001c7bc <nbr_new>
}
4001ca80:	01c12083          	lw	ra,28(sp)
4001ca84:	01812403          	lw	s0,24(sp)
4001ca88:	01412483          	lw	s1,20(sp)
4001ca8c:	01012903          	lw	s2,16(sp)
4001ca90:	00c12983          	lw	s3,12(sp)
4001ca94:	00812a03          	lw	s4,8(sp)
4001ca98:	02010113          	addi	sp,sp,32
4001ca9c:	00008067          	ret

4001caa0 <net_ipv6_nbr_lookup>:
	return nbr_lookup(&net_neighbor.table, iface, addr);
4001caa0:	a75ff06f          	j	4001c514 <nbr_lookup.constprop.0>

4001caa4 <net_ipv6_send_na>:
{
4001caa4:	fd010113          	addi	sp,sp,-48
4001caa8:	02912223          	sw	s1,36(sp)
4001caac:	03212023          	sw	s2,32(sp)
4001cab0:	01412c23          	sw	s4,24(sp)
4001cab4:	01512a23          	sw	s5,20(sp)
4001cab8:	01612823          	sw	s6,16(sp)
4001cabc:	02112623          	sw	ra,44(sp)
4001cac0:	02812423          	sw	s0,40(sp)
4001cac4:	01312e23          	sw	s3,28(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
4001cac8:	01400793          	li	a5,20
4001cacc:	00f12623          	sw	a5,12(sp)
	uint8_t total_len = net_if_get_link_addr(iface)->len +
4001cad0:	00052783          	lw	a5,0(a0)
{
4001cad4:	00058493          	mv	s1,a1
4001cad8:	00060b13          	mv	s6,a2
	return ROUND_UP(total_len, 8U);
4001cadc:	0147c983          	lbu	s3,20(a5)
{
4001cae0:	00068a13          	mv	s4,a3
4001cae4:	00070a93          	mv	s5,a4
	return ROUND_UP(total_len, 8U);
4001cae8:	00998993          	addi	s3,s3,9
4001caec:	0f89f993          	andi	s3,s3,248
	pkt = net_pkt_alloc_with_buffer(iface,
4001caf0:	00a00713          	li	a4,10
4001caf4:	00000793          	li	a5,0
4001caf8:	03a00693          	li	a3,58
4001cafc:	00200613          	li	a2,2
4001cb00:	01498593          	addi	a1,s3,20
{
4001cb04:	00050913          	mv	s2,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
4001cb08:	00012423          	sw	zero,8(sp)
	pkt = net_pkt_alloc_with_buffer(iface,
4001cb0c:	d7cfb0ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
	if (!pkt) {
4001cb10:	14050063          	beqz	a0,4001cc50 <net_ipv6_send_na+0x1ac>
	pkt->ipv6_hop_limit = hop_limit;
4001cb14:	fff00793          	li	a5,-1
4001cb18:	02f50ca3          	sb	a5,57(a0)
	if (net_ipv6_create(pkt, src, dst) ||
4001cb1c:	000b0613          	mv	a2,s6
4001cb20:	00048593          	mv	a1,s1
4001cb24:	00050413          	mv	s0,a0
4001cb28:	bc1fe0ef          	jal	ra,4001b6e8 <net_ipv6_create>
4001cb2c:	10051e63          	bnez	a0,4001cc48 <net_ipv6_send_na+0x1a4>
	    net_icmpv6_create(pkt, NET_ICMPV6_NA, 0)) {
4001cb30:	00000613          	li	a2,0
4001cb34:	08800593          	li	a1,136
4001cb38:	00040513          	mv	a0,s0
4001cb3c:	f11fd0ef          	jal	ra,4001aa4c <net_icmpv6_create>
	if (net_ipv6_create(pkt, src, dst) ||
4001cb40:	10051463          	bnez	a0,4001cc48 <net_ipv6_send_na+0x1a4>
	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
4001cb44:	00810593          	addi	a1,sp,8
4001cb48:	00040513          	mv	a0,s0
4001cb4c:	d9dfb0ef          	jal	ra,400188e8 <net_pkt_get_data>
4001cb50:	00050493          	mv	s1,a0
	if (!na_hdr) {
4001cb54:	0e050a63          	beqz	a0,4001cc48 <net_ipv6_send_na+0x1a4>
	memset(na_hdr, 0, sizeof(struct net_icmpv6_na_hdr));
4001cb58:	01400613          	li	a2,20
4001cb5c:	00000593          	li	a1,0
4001cb60:	9bcf00ef          	jal	ra,4000cd1c <memset>
	memcpy(dest, src, sizeof(struct in6_addr));
4001cb64:	01000613          	li	a2,16
	na_hdr->flags = flags;
4001cb68:	01548023          	sb	s5,0(s1)
4001cb6c:	000a0593          	mv	a1,s4
4001cb70:	00448513          	addi	a0,s1,4
4001cb74:	984f00ef          	jal	ra,4000ccf8 <memcpy>
	if (net_pkt_set_data(pkt, &na_access)) {
4001cb78:	00810593          	addi	a1,sp,8
4001cb7c:	00040513          	mv	a0,s0
4001cb80:	e39fb0ef          	jal	ra,400189b8 <net_pkt_set_data>
4001cb84:	00050493          	mv	s1,a0
4001cb88:	0c051063          	bnez	a0,4001cc48 <net_ipv6_send_na+0x1a4>
	return &iface->if_dev->link_addr;
4001cb8c:	00092583          	lw	a1,0(s2)
	if (!set_llao(pkt, net_if_get_link_addr(iface),
4001cb90:	00200693          	li	a3,2
4001cb94:	00098613          	mv	a2,s3
4001cb98:	01058593          	addi	a1,a1,16
4001cb9c:	00040513          	mv	a0,s0
4001cba0:	f80ff0ef          	jal	ra,4001c320 <set_llao>
4001cba4:	0a050263          	beqz	a0,4001cc48 <net_ipv6_send_na+0x1a4>
	net_pkt_cursor_init(pkt);
4001cba8:	00040513          	mv	a0,s0
4001cbac:	f45fa0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
4001cbb0:	03a00593          	li	a1,58
4001cbb4:	00040513          	mv	a0,s0
4001cbb8:	c25fe0ef          	jal	ra,4001b7dc <net_ipv6_finalize>
	if (net_send_data(pkt) < 0) {
4001cbbc:	00040513          	mv	a0,s0
4001cbc0:	aedf20ef          	jal	ra,4000f6ac <net_send_data>
4001cbc4:	00055e63          	bgez	a0,4001cbe0 <net_ipv6_send_na+0x13c>
		net_stats_update_ipv6_nd_drop(iface);
4001cbc8:	00090513          	mv	a0,s2
4001cbcc:	cd4ff0ef          	jal	ra,4001c0a0 <net_stats_update_ipv6_nd_drop>
		ret = -EINVAL;
4001cbd0:	fea00493          	li	s1,-22
	net_pkt_unref(pkt);
4001cbd4:	00040513          	mv	a0,s0
4001cbd8:	c45fa0ef          	jal	ra,4001781c <net_pkt_unref>
	return ret;
4001cbdc:	0400006f          	j	4001cc1c <net_ipv6_send_na+0x178>
	UPDATE_STAT(iface, stats.icmp.sent++);
4001cbe0:	4003b7b7          	lui	a5,0x4003b
4001cbe4:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001cbe8:	0487a703          	lw	a4,72(a5)
	return pkt->iface;
4001cbec:	01842683          	lw	a3,24(s0)
4001cbf0:	00170713          	addi	a4,a4,1
4001cbf4:	04e7a423          	sw	a4,72(a5)
4001cbf8:	04c6a703          	lw	a4,76(a3)
4001cbfc:	00170713          	addi	a4,a4,1
4001cc00:	04e6a623          	sw	a4,76(a3)
	UPDATE_STAT(iface, stats.ipv6_nd.sent++);
4001cc04:	0a87a703          	lw	a4,168(a5)
4001cc08:	00170713          	addi	a4,a4,1
4001cc0c:	0ae7a423          	sw	a4,168(a5)
4001cc10:	0ac92783          	lw	a5,172(s2)
4001cc14:	00178793          	addi	a5,a5,1
4001cc18:	0af92623          	sw	a5,172(s2)
}
4001cc1c:	02c12083          	lw	ra,44(sp)
4001cc20:	02812403          	lw	s0,40(sp)
4001cc24:	02012903          	lw	s2,32(sp)
4001cc28:	01c12983          	lw	s3,28(sp)
4001cc2c:	01812a03          	lw	s4,24(sp)
4001cc30:	01412a83          	lw	s5,20(sp)
4001cc34:	01012b03          	lw	s6,16(sp)
4001cc38:	00048513          	mv	a0,s1
4001cc3c:	02412483          	lw	s1,36(sp)
4001cc40:	03010113          	addi	sp,sp,48
4001cc44:	00008067          	ret
	int ret = -ENOBUFS;
4001cc48:	f9700493          	li	s1,-105
4001cc4c:	f89ff06f          	j	4001cbd4 <net_ipv6_send_na+0x130>
		return -ENOMEM;
4001cc50:	ff400493          	li	s1,-12
4001cc54:	fc9ff06f          	j	4001cc1c <net_ipv6_send_na+0x178>

4001cc58 <net_ipv6_nbr_set_reachable_timer>:
	}
}

void net_ipv6_nbr_set_reachable_timer(struct net_if *iface,
				      struct net_nbr *nbr)
{
4001cc58:	00050793          	mv	a5,a0
	uint32_t time;

	time = net_if_ipv6_get_reachable_time(iface);
4001cc5c:	0bc7a783          	lw	a5,188(a5)
{
4001cc60:	00058513          	mv	a0,a1
		return 0;
4001cc64:	00000593          	li	a1,0
	if (!iface->config.ip.ipv6) {
4001cc68:	00078463          	beqz	a5,4001cc70 <net_ipv6_nbr_set_reachable_timer+0x18>
	return iface->config.ip.ipv6->reachable_time;
4001cc6c:	1447a583          	lw	a1,324(a5)
	NET_ASSERT(time, "Zero reachable timeout!");

	NET_DBG("Starting reachable timer nbr %p data %p time %d ms",
		nbr, net_ipv6_nbr_data(nbr), time);

	ipv6_nd_restart_reachable_timer(nbr, time);
4001cc70:	00000613          	li	a2,0
4001cc74:	fccff06f          	j	4001c440 <ipv6_nd_restart_reachable_timer>

4001cc78 <handle_na_input>:
}

static enum net_verdict handle_na_input(struct net_pkt *pkt,
					struct net_ipv6_hdr *ip_hdr,
					struct net_icmp_hdr *icmp_hdr)
{
4001cc78:	f9010113          	addi	sp,sp,-112
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
4001cc7c:	01400793          	li	a5,20
4001cc80:	02f12223          	sw	a5,36(sp)
					      struct net_icmpv6_na_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
4001cc84:	01c10793          	addi	a5,sp,28
{
4001cc88:	06812423          	sw	s0,104(sp)
4001cc8c:	06912223          	sw	s1,100(sp)
4001cc90:	05312e23          	sw	s3,92(sp)
4001cc94:	05412c23          	sw	s4,88(sp)
4001cc98:	06112623          	sw	ra,108(sp)
4001cc9c:	07212023          	sw	s2,96(sp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
4001cca0:	02f12423          	sw	a5,40(sp)
4001cca4:	00200793          	li	a5,2
4001cca8:	02f12623          	sw	a5,44(sp)
	uint16_t length = net_pkt_get_len(pkt);
4001ccac:	00852783          	lw	a5,8(a0)
{
4001ccb0:	00050413          	mv	s0,a0
4001ccb4:	00058993          	mv	s3,a1
4001ccb8:	00060a13          	mv	s4,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
4001ccbc:	02012023          	sw	zero,32(sp)
	size_t bytes = 0;
4001ccc0:	00000493          	li	s1,0
	while (buf) {
4001ccc4:	06079863          	bnez	a5,4001cd34 <handle_na_input+0xbc>
	uint16_t tllao_offset = 0U;
	struct net_icmpv6_nd_opt_hdr *nd_opt_hdr;
	struct net_icmpv6_na_hdr *na_hdr;
	struct net_if_addr *ifaddr;

	if (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {
4001ccc8:	01842503          	lw	a0,24(s0)
4001cccc:	00b00593          	li	a1,11
4001ccd0:	949ff0ef          	jal	ra,4001c618 <net_if_flag_is_set>
4001ccd4:	04051863          	bnez	a0,4001cd24 <handle_na_input+0xac>
		goto drop;
	}

	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
4001ccd8:	02010593          	addi	a1,sp,32
4001ccdc:	00040513          	mv	a0,s0
4001cce0:	c09fb0ef          	jal	ra,400188e8 <net_pkt_get_data>
4001cce4:	00050913          	mv	s2,a0
	if (!na_hdr) {
4001cce8:	04051e63          	bnez	a0,4001cd44 <handle_na_input+0xcc>
		NET_ERR("DROP: NULL NA header");
4001ccec:	40044537          	lui	a0,0x40044
4001ccf0:	77c52783          	lw	a5,1916(a0) # 4004477c <log_dynamic_net_ipv6>
4001ccf4:	0077f793          	andi	a5,a5,7
4001ccf8:	02078663          	beqz	a5,4001cd24 <handle_na_input+0xac>
4001ccfc:	400357b7          	lui	a5,0x40035
4001cd00:	fe878793          	addi	a5,a5,-24 # 40034fe8 <all_nodes_mcast_group.0+0x4c>
		net_pkt_set_ipv6_ext_opt_len(pkt,
					     net_pkt_ipv6_ext_opt_len(pkt) +
					     (nd_opt_hdr->len << 3));

		if (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {
			NET_ERR("DROP: Corrupted NA message");
4001cd04:	000015b7          	lui	a1,0x1
4001cd08:	04f12623          	sw	a5,76(sp)
4001cd0c:	04810613          	addi	a2,sp,72
4001cd10:	00200793          	li	a5,2
4001cd14:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4001cd18:	77c50513          	addi	a0,a0,1916
4001cd1c:	04f12423          	sw	a5,72(sp)
4001cd20:	8a1ff0ef          	jal	ra,4001c5c0 <z_log_msg_static_create.constprop.0>
	net_pkt_unref(pkt);

	return NET_OK;

drop:
	net_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));
4001cd24:	01842503          	lw	a0,24(s0)
4001cd28:	b78ff0ef          	jal	ra,4001c0a0 <net_stats_update_ipv6_nd_drop>

	return NET_DROP;
4001cd2c:	00200513          	li	a0,2
4001cd30:	2100006f          	j	4001cf40 <handle_na_input+0x2c8>
		bytes += buf->len;
4001cd34:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
4001cd38:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4001cd3c:	00e484b3          	add	s1,s1,a4
		buf = buf->frags;
4001cd40:	f85ff06f          	j	4001ccc4 <handle_na_input+0x4c>
	UPDATE_STAT(iface, stats.ipv6_nd.recv++);
4001cd44:	4003b7b7          	lui	a5,0x4003b
4001cd48:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001cd4c:	0a47a703          	lw	a4,164(a5)
4001cd50:	01842683          	lw	a3,24(s0)
	uint16_t length = net_pkt_get_len(pkt);
4001cd54:	01049493          	slli	s1,s1,0x10
4001cd58:	00170713          	addi	a4,a4,1
4001cd5c:	0ae7a223          	sw	a4,164(a5)
4001cd60:	0a86a783          	lw	a5,168(a3)
4001cd64:	0104d493          	srli	s1,s1,0x10
4001cd68:	00178793          	addi	a5,a5,1
4001cd6c:	0af6a423          	sw	a5,168(a3)
	if (((length < (sizeof(struct net_ipv6_hdr) +
4001cd70:	04100793          	li	a5,65
4001cd74:	0297f663          	bgeu	a5,s1,4001cda0 <handle_na_input+0x128>
			sizeof(struct net_icmpv6_nd_opt_hdr))) ||
4001cd78:	0079c783          	lbu	a5,7(s3)
4001cd7c:	0ff00713          	li	a4,255
4001cd80:	02e79063          	bne	a5,a4,4001cda0 <handle_na_input+0x128>
	     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||
4001cd84:	00454703          	lbu	a4,4(a0)
4001cd88:	00f70c63          	beq	a4,a5,4001cda0 <handle_na_input+0x128>
	     net_ipv6_is_addr_mcast((struct in6_addr *)na_hdr->tgt) ||
4001cd8c:	00054703          	lbu	a4,0(a0)
4001cd90:	04077713          	andi	a4,a4,64
4001cd94:	00070a63          	beqz	a4,4001cda8 <handle_na_input+0x130>
	     (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED &&
4001cd98:	0189c703          	lbu	a4,24(s3)
4001cd9c:	00f71663          	bne	a4,a5,4001cda8 <handle_na_input+0x130>
	      net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst))) &&
4001cda0:	001a4783          	lbu	a5,1(s4)
4001cda4:	f80790e3          	bnez	a5,4001cd24 <handle_na_input+0xac>
	net_pkt_acknowledge_data(pkt, &na_access);
4001cda8:	02412583          	lw	a1,36(sp)
4001cdac:	00040513          	mv	a0,s0
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
4001cdb0:	fd448493          	addi	s1,s1,-44
	net_pkt_acknowledge_data(pkt, &na_access);
4001cdb4:	8a5ff0ef          	jal	ra,4001c658 <net_pkt_acknowledge_data.isra.0>
	pkt->ipv6_ext_opt_len = len;
4001cdb8:	01400793          	li	a5,20
4001cdbc:	02f40f23          	sb	a5,62(s0)
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
4001cdc0:	01049493          	slli	s1,s1,0x10
				net_pkt_get_data(pkt, &nd_access);
4001cdc4:	02810593          	addi	a1,sp,40
4001cdc8:	00040513          	mv	a0,s0
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
4001cdcc:	0104d493          	srli	s1,s1,0x10
				net_pkt_get_data(pkt, &nd_access);
4001cdd0:	b19fb0ef          	jal	ra,400188e8 <net_pkt_get_data>
	uint16_t tllao_offset = 0U;
4001cdd4:	00000993          	li	s3,0
		switch (nd_opt_hdr->type) {
4001cdd8:	00200a13          	li	s4,2
	while (nd_opt_hdr && nd_opt_hdr->len &&
4001cddc:	00050a63          	beqz	a0,4001cdf0 <handle_na_input+0x178>
4001cde0:	00154783          	lbu	a5,1(a0)
4001cde4:	00078663          	beqz	a5,4001cdf0 <handle_na_input+0x178>
	return pkt->ipv6_ext_opt_len;
4001cde8:	03e44703          	lbu	a4,62(s0)
4001cdec:	04976863          	bltu	a4,s1,4001ce3c <handle_na_input+0x1c4>
	ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
4001cdf0:	01842503          	lw	a0,24(s0)
						  (struct in6_addr *)na_hdr->tgt);
4001cdf4:	00490593          	addi	a1,s2,4
	ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
4001cdf8:	00b12623          	sw	a1,12(sp)
4001cdfc:	d18f40ef          	jal	ra,40011314 <net_if_ipv6_addr_lookup_by_iface>
4001ce00:	00050793          	mv	a5,a0
	if (ifaddr) {
4001ce04:	00c12583          	lw	a1,12(sp)
4001ce08:	01842503          	lw	a0,24(s0)
4001ce0c:	0a078463          	beqz	a5,4001ceb4 <handle_na_input+0x23c>
		if (ifaddr->addr_state == NET_ADDR_TENTATIVE) {
4001ce10:	02d78783          	lb	a5,45(a5)
4001ce14:	f00798e3          	bnez	a5,4001cd24 <handle_na_input+0xac>
	return UNALIGNED_GET(&addr->s6_addr16[0]) == htons(0xFE80);
4001ce18:	00594783          	lbu	a5,5(s2)
4001ce1c:	00494703          	lbu	a4,4(s2)
4001ce20:	00879793          	slli	a5,a5,0x8
	if (net_ipv6_is_ll_addr(addr)) {
4001ce24:	00e7e7b3          	or	a5,a5,a4
4001ce28:	00008737          	lui	a4,0x8
4001ce2c:	0fe70713          	addi	a4,a4,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
4001ce30:	06e79e63          	bne	a5,a4,4001ceac <handle_na_input+0x234>
4001ce34:	f94ff0ef          	jal	ra,4001c5c8 <dad_failed.part.0.isra.0>
4001ce38:	eedff06f          	j	4001cd24 <handle_na_input+0xac>
		switch (nd_opt_hdr->type) {
4001ce3c:	00054683          	lbu	a3,0(a0)
4001ce40:	03469063          	bne	a3,s4,4001ce60 <handle_na_input+0x1e8>
			tllao_offset = net_pkt_ip_hdr_len(pkt) +
4001ce44:	03a45983          	lhu	s3,58(s0)
4001ce48:	03644683          	lbu	a3,54(s0)
4001ce4c:	00698993          	addi	s3,s3,6
4001ce50:	013709b3          	add	s3,a4,s3
4001ce54:	00d989b3          	add	s3,s3,a3
4001ce58:	01099993          	slli	s3,s3,0x10
4001ce5c:	0109d993          	srli	s3,s3,0x10
					     (nd_opt_hdr->len << 3));
4001ce60:	00379793          	slli	a5,a5,0x3
		net_pkt_set_ipv6_ext_opt_len(pkt,
4001ce64:	00f707b3          	add	a5,a4,a5
4001ce68:	0ff7f793          	zext.b	a5,a5
	pkt->ipv6_ext_opt_len = len;
4001ce6c:	02f40f23          	sb	a5,62(s0)
		if (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {
4001ce70:	02f76063          	bltu	a4,a5,4001ce90 <handle_na_input+0x218>
			NET_ERR("DROP: Corrupted NA message");
4001ce74:	40044537          	lui	a0,0x40044
4001ce78:	77c52783          	lw	a5,1916(a0) # 4004477c <log_dynamic_net_ipv6>
4001ce7c:	0077f793          	andi	a5,a5,7
4001ce80:	ea0782e3          	beqz	a5,4001cd24 <handle_na_input+0xac>
4001ce84:	400357b7          	lui	a5,0x40035
4001ce88:	00078793          	mv	a5,a5
4001ce8c:	e79ff06f          	j	4001cd04 <handle_na_input+0x8c>
		net_pkt_acknowledge_data(pkt, &nd_access);
4001ce90:	02c12583          	lw	a1,44(sp)
4001ce94:	00040513          	mv	a0,s0
4001ce98:	fc0ff0ef          	jal	ra,4001c658 <net_pkt_acknowledge_data.isra.0>
					net_pkt_get_data(pkt, &nd_access);
4001ce9c:	02810593          	addi	a1,sp,40
4001cea0:	00040513          	mv	a0,s0
4001cea4:	a45fb0ef          	jal	ra,400188e8 <net_pkt_get_data>
4001cea8:	f35ff06f          	j	4001cddc <handle_na_input+0x164>
	net_if_ipv6_dad_failed(iface, addr);
4001ceac:	fd1f40ef          	jal	ra,40011e7c <net_if_ipv6_dad_failed>
	return true;
4001ceb0:	e75ff06f          	j	4001cd24 <handle_na_input+0xac>
	struct net_linkaddr_storage lladdr = { 0 };
4001ceb4:	02012823          	sw	zero,48(sp)
4001ceb8:	02012a23          	sw	zero,52(sp)
	nbr = nbr_lookup(&net_neighbor.table, net_pkt_iface(pkt),
4001cebc:	e58ff0ef          	jal	ra,4001c514 <nbr_lookup.constprop.0>
4001cec0:	00050493          	mv	s1,a0
	if (!nbr) {
4001cec4:	e60500e3          	beqz	a0,4001cd24 <handle_na_input+0xac>
	if (tllao_offset) {
4001cec8:	08099c63          	bnez	s3,4001cf60 <handle_na_input+0x2e8>
	if (nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
4001cecc:	00154503          	lbu	a0,1(a0)
4001ced0:	0ff00793          	li	a5,255
4001ced4:	e4f508e3          	beq	a0,a5,4001cd24 <handle_na_input+0xac>
	cached_lladdr = net_nbr_get_lladdr(nbr->idx);
4001ced8:	e2cfe0ef          	jal	ra,4001b504 <net_nbr_get_lladdr>
	if (!cached_lladdr) {
4001cedc:	e40504e3          	beqz	a0,4001cd24 <handle_na_input+0xac>
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_INCOMPLETE) {
4001cee0:	00c4a783          	lw	a5,12(s1)
4001cee4:	0307a783          	lw	a5,48(a5) # 40035030 <all_nodes_mcast_group.0+0x94>
4001cee8:	e2078ee3          	beqz	a5,4001cd24 <handle_na_input+0xac>
	if (!(na_hdr->flags & NET_ICMPV6_NA_FLAG_OVERRIDE) && lladdr_changed) {
4001ceec:	00094783          	lbu	a5,0(s2)
4001cef0:	0207f793          	andi	a5,a5,32
4001cef4:	1c079863          	bnez	a5,4001d0c4 <handle_na_input+0x44c>
		(na_hdr->flags & NET_ICMPV6_NA_FLAG_ROUTER);
4001cef8:	00094783          	lbu	a5,0(s2)
4001cefc:	00c4a703          	lw	a4,12(s1)
4001cf00:	0077d793          	srli	a5,a5,0x7
	net_ipv6_nbr_data(nbr)->is_router =
4001cf04:	02f70ba3          	sb	a5,55(a4)
	pending = net_ipv6_nbr_data(nbr)->pending;
4001cf08:	00c4a783          	lw	a5,12(s1)
4001cf0c:	0007a903          	lw	s2,0(a5)
	if (pending) {
4001cf10:	02090263          	beqz	s2,4001cf34 <handle_na_input+0x2bc>
		if (net_send_data(pending) < 0) {
4001cf14:	00090513          	mv	a0,s2
4001cf18:	f94f20ef          	jal	ra,4000f6ac <net_send_data>
4001cf1c:	00c4a783          	lw	a5,12(s1)
4001cf20:	1c055263          	bgez	a0,4001d0e4 <handle_na_input+0x46c>
			nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
4001cf24:	00078513          	mv	a0,a5
4001cf28:	a10ff0ef          	jal	ra,4001c138 <nbr_clear_ns_pending>
		net_pkt_unref(pending);
4001cf2c:	00090513          	mv	a0,s2
4001cf30:	8edfa0ef          	jal	ra,4001781c <net_pkt_unref>
	net_pkt_unref(pkt);
4001cf34:	00040513          	mv	a0,s0
4001cf38:	8e5fa0ef          	jal	ra,4001781c <net_pkt_unref>
	return NET_OK;
4001cf3c:	00000513          	li	a0,0
}
4001cf40:	06c12083          	lw	ra,108(sp)
4001cf44:	06812403          	lw	s0,104(sp)
4001cf48:	06412483          	lw	s1,100(sp)
4001cf4c:	06012903          	lw	s2,96(sp)
4001cf50:	05c12983          	lw	s3,92(sp)
4001cf54:	05812a03          	lw	s4,88(sp)
4001cf58:	07010113          	addi	sp,sp,112
4001cf5c:	00008067          	ret
		lladdr.len = net_pkt_lladdr_src(pkt)->len;
4001cf60:	02844783          	lbu	a5,40(s0)
		net_pkt_cursor_init(pkt);
4001cf64:	00040513          	mv	a0,s0
		lladdr.len = net_pkt_lladdr_src(pkt)->len;
4001cf68:	02f108a3          	sb	a5,49(sp)
		net_pkt_cursor_init(pkt);
4001cf6c:	b85fa0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
		if (net_pkt_skip(pkt, tllao_offset) ||
4001cf70:	00098593          	mv	a1,s3
4001cf74:	00040513          	mv	a0,s0
4001cf78:	958fb0ef          	jal	ra,400180d0 <net_pkt_skip>
4001cf7c:	da0514e3          	bnez	a0,4001cd24 <handle_na_input+0xac>
		    net_pkt_read(pkt, lladdr.addr, lladdr.len)) {
4001cf80:	03114603          	lbu	a2,49(sp)
4001cf84:	03210a13          	addi	s4,sp,50
4001cf88:	000a0593          	mv	a1,s4
4001cf8c:	00040513          	mv	a0,s0
4001cf90:	ba8fb0ef          	jal	ra,40018338 <net_pkt_read>
		if (net_pkt_skip(pkt, tllao_offset) ||
4001cf94:	d80518e3          	bnez	a0,4001cd24 <handle_na_input+0xac>
	if (nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
4001cf98:	0014c503          	lbu	a0,1(s1)
4001cf9c:	0ff00793          	li	a5,255
4001cfa0:	02f51a63          	bne	a0,a5,4001cfd4 <handle_na_input+0x35c>
		nbr_lladdr.len = lladdr.len;
4001cfa4:	03114783          	lbu	a5,49(sp)
		if (net_nbr_link(nbr, net_pkt_iface(pkt), &nbr_lladdr)) {
4001cfa8:	01842583          	lw	a1,24(s0)
4001cfac:	03810613          	addi	a2,sp,56
4001cfb0:	00048513          	mv	a0,s1
		nbr_lladdr.len = lladdr.len;
4001cfb4:	02f10e23          	sb	a5,60(sp)
		nbr_lladdr.addr = lladdr.addr;
4001cfb8:	03412c23          	sw	s4,56(sp)
		if (net_nbr_link(nbr, net_pkt_iface(pkt), &nbr_lladdr)) {
4001cfbc:	b5cfe0ef          	jal	ra,4001b318 <net_nbr_link>
4001cfc0:	00050863          	beqz	a0,4001cfd0 <handle_na_input+0x358>
			nbr_free(nbr);
4001cfc4:	00048513          	mv	a0,s1
4001cfc8:	9b0ff0ef          	jal	ra,4001c178 <nbr_free>
			return false;
4001cfcc:	d59ff06f          	j	4001cd24 <handle_na_input+0xac>
	cached_lladdr = net_nbr_get_lladdr(nbr->idx);
4001cfd0:	0014c503          	lbu	a0,1(s1)
4001cfd4:	d30fe0ef          	jal	ra,4001b504 <net_nbr_get_lladdr>
4001cfd8:	00050993          	mv	s3,a0
	if (!cached_lladdr) {
4001cfdc:	d40504e3          	beqz	a0,4001cd24 <handle_na_input+0xac>
		lladdr_changed = memcmp(lladdr.addr,
4001cfe0:	00154603          	lbu	a2,1(a0)
4001cfe4:	00250593          	addi	a1,a0,2
4001cfe8:	000a0513          	mv	a0,s4
4001cfec:	c8def0ef          	jal	ra,4000cc78 <memcmp>
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_INCOMPLETE) {
4001cff0:	00c4a783          	lw	a5,12(s1)
4001cff4:	0307a703          	lw	a4,48(a5)
4001cff8:	06071663          	bnez	a4,4001d064 <handle_na_input+0x3ec>
		if (lladdr_changed) {
4001cffc:	00050e63          	beqz	a0,4001d018 <handle_na_input+0x3a0>
	dbg_update_neighbor_lladdr(&lladdr, old_lladdr, addr);
4001d000:	00098513          	mv	a0,s3
4001d004:	e7cff0ef          	jal	ra,4001c680 <dbg_update_neighbor_lladdr.constprop.0>
			net_linkaddr_set(cached_lladdr, lladdr.addr,
4001d008:	0019c603          	lbu	a2,1(s3)
4001d00c:	000a0593          	mv	a1,s4
4001d010:	00098513          	mv	a0,s3
4001d014:	e48ff0ef          	jal	ra,4001c65c <net_linkaddr_set.isra.0>
		if (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED) {
4001d018:	00094783          	lbu	a5,0(s2)
4001d01c:	0407f793          	andi	a5,a5,64
4001d020:	0a078a63          	beqz	a5,4001d0d4 <handle_na_input+0x45c>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_REACHABLE);
4001d024:	00100593          	li	a1,1
4001d028:	00048513          	mv	a0,s1
4001d02c:	e98ff0ef          	jal	ra,4001c6c4 <ipv6_nbr_set_state>
4001d030:	00c4a783          	lw	a5,12(s1)
			net_ipv6_nbr_data(nbr)->ns_count = 0U;
4001d034:	02078b23          	sb	zero,54(a5)
4001d038:	00c4a783          	lw	a5,12(s1)
			net_ipv6_nbr_data(nbr)->reachable = 0;
4001d03c:	00000693          	li	a3,0
4001d040:	00000713          	li	a4,0
4001d044:	00d7ac23          	sw	a3,24(a5)
4001d048:	00e7ae23          	sw	a4,28(a5)
4001d04c:	00c4a783          	lw	a5,12(s1)
			net_ipv6_nbr_set_reachable_timer(net_pkt_iface(pkt),
4001d050:	00048593          	mv	a1,s1
			net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
4001d054:	0207a023          	sw	zero,32(a5)
			net_ipv6_nbr_set_reachable_timer(net_pkt_iface(pkt),
4001d058:	01842503          	lw	a0,24(s0)
4001d05c:	bfdff0ef          	jal	ra,4001cc58 <net_ipv6_nbr_set_reachable_timer>
4001d060:	e99ff06f          	j	4001cef8 <handle_na_input+0x280>
	if (!(na_hdr->flags & NET_ICMPV6_NA_FLAG_OVERRIDE) && lladdr_changed) {
4001d064:	00094783          	lbu	a5,0(s2)
4001d068:	0207f693          	andi	a3,a5,32
4001d06c:	02069063          	bnez	a3,4001d08c <handle_na_input+0x414>
4001d070:	04050c63          	beqz	a0,4001d0c8 <handle_na_input+0x450>
		if (net_ipv6_nbr_data(nbr)->state ==
4001d074:	00100793          	li	a5,1
4001d078:	caf716e3          	bne	a4,a5,4001cd24 <handle_na_input+0xac>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
4001d07c:	00200593          	li	a1,2
4001d080:	00048513          	mv	a0,s1
4001d084:	e40ff0ef          	jal	ra,4001c6c4 <ipv6_nbr_set_state>
4001d088:	c9dff06f          	j	4001cd24 <handle_na_input+0xac>
		if (lladdr_changed) {
4001d08c:	02050c63          	beqz	a0,4001d0c4 <handle_na_input+0x44c>
	dbg_update_neighbor_lladdr(&lladdr, old_lladdr, addr);
4001d090:	00098513          	mv	a0,s3
4001d094:	decff0ef          	jal	ra,4001c680 <dbg_update_neighbor_lladdr.constprop.0>
			net_linkaddr_set(cached_lladdr, lladdr.addr,
4001d098:	0019c603          	lbu	a2,1(s3)
4001d09c:	000a0593          	mv	a1,s4
4001d0a0:	00098513          	mv	a0,s3
4001d0a4:	db8ff0ef          	jal	ra,4001c65c <net_linkaddr_set.isra.0>
		if (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED) {
4001d0a8:	00094783          	lbu	a5,0(s2)
4001d0ac:	0407f793          	andi	a5,a5,64
4001d0b0:	02078263          	beqz	a5,4001d0d4 <handle_na_input+0x45c>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_REACHABLE);
4001d0b4:	00100593          	li	a1,1
4001d0b8:	00048513          	mv	a0,s1
4001d0bc:	e08ff0ef          	jal	ra,4001c6c4 <ipv6_nbr_set_state>
4001d0c0:	f79ff06f          	j	4001d038 <handle_na_input+0x3c0>
		if (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED) {
4001d0c4:	00094783          	lbu	a5,0(s2)
4001d0c8:	0407f793          	andi	a5,a5,64
4001d0cc:	e20786e3          	beqz	a5,4001cef8 <handle_na_input+0x280>
4001d0d0:	fe5ff06f          	j	4001d0b4 <handle_na_input+0x43c>
				ipv6_nbr_set_state(nbr,
4001d0d4:	00200593          	li	a1,2
4001d0d8:	00048513          	mv	a0,s1
4001d0dc:	de8ff0ef          	jal	ra,4001c6c4 <ipv6_nbr_set_state>
4001d0e0:	e19ff06f          	j	4001cef8 <handle_na_input+0x280>
			net_ipv6_nbr_data(nbr)->pending = NULL;
4001d0e4:	0007a023          	sw	zero,0(a5)
4001d0e8:	e45ff06f          	j	4001cf2c <handle_na_input+0x2b4>

4001d0ec <net_ipv6_send_ns>:
		     struct net_pkt *pending,
		     const struct in6_addr *src,
		     const struct in6_addr *dst,
		     const struct in6_addr *tgt,
		     bool is_my_address)
{
4001d0ec:	fb010113          	addi	sp,sp,-80
4001d0f0:	03712623          	sw	s7,44(sp)
4001d0f4:	00078b93          	mv	s7,a5
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
4001d0f8:	01400793          	li	a5,20
{
4001d0fc:	04912223          	sw	s1,68(sp)
4001d100:	05212023          	sw	s2,64(sp)
4001d104:	03312e23          	sw	s3,60(sp)
4001d108:	03412c23          	sw	s4,56(sp)
4001d10c:	03612823          	sw	s6,48(sp)
4001d110:	04112623          	sw	ra,76(sp)
4001d114:	04812423          	sw	s0,72(sp)
4001d118:	03512a23          	sw	s5,52(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
4001d11c:	00012423          	sw	zero,8(sp)
4001d120:	00f12623          	sw	a5,12(sp)
{
4001d124:	00050913          	mv	s2,a0
4001d128:	00058993          	mv	s3,a1
4001d12c:	00060493          	mv	s1,a2
4001d130:	00070a13          	mv	s4,a4
4001d134:	00068b13          	mv	s6,a3
	struct net_icmpv6_ns_hdr *ns_hdr;
	struct in6_addr node_dst;
	struct net_nbr *nbr;
	uint8_t llao_len;

	if (!dst) {
4001d138:	04069063          	bnez	a3,4001d178 <net_ipv6_send_ns+0x8c>
	dst->s6_addr[0]   = 0xFF;
4001d13c:	2ff00793          	li	a5,767
4001d140:	00f12823          	sw	a5,16(sp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
4001d144:	010007b7          	lui	a5,0x1000
4001d148:	00f12c23          	sw	a5,24(sp)
	dst->s6_addr[12]  = 0xFF;
4001d14c:	fff00793          	li	a5,-1
4001d150:	00f10e23          	sb	a5,28(sp)
	dst->s6_addr[13]  = src->s6_addr[13];
4001d154:	00d74783          	lbu	a5,13(a4)
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
4001d158:	00012a23          	sw	zero,20(sp)
		net_ipv6_addr_create_solicited_node(tgt, &node_dst);
		dst = &node_dst;
4001d15c:	01010b13          	addi	s6,sp,16
	dst->s6_addr[13]  = src->s6_addr[13];
4001d160:	00f10ea3          	sb	a5,29(sp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
4001d164:	00e74783          	lbu	a5,14(a4)
4001d168:	00f74703          	lbu	a4,15(a4)
4001d16c:	00871713          	slli	a4,a4,0x8
4001d170:	00f76733          	or	a4,a4,a5
4001d174:	00e11f23          	sh	a4,30(sp)
	uint8_t total_len = net_if_get_link_addr(iface)->len +
4001d178:	00092783          	lw	a5,0(s2)
4001d17c:	0147ca83          	lbu	s5,20(a5) # 1000014 <__rom_region_size+0xfc7058>
	}

	llao_len = get_llao_len(iface);

	if (is_my_address) {
4001d180:	0e0b8463          	beqz	s7,4001d268 <net_ipv6_send_ns+0x17c>
		src = net_ipv6_unspecified_address();
4001d184:	a84f80ef          	jal	ra,40015408 <net_ipv6_unspecified_address>
4001d188:	00050493          	mv	s1,a0
		llao_len = 0U;
4001d18c:	00000a93          	li	s5,0

			goto drop;
		}
	}

	pkt = net_pkt_alloc_with_buffer(iface,
4001d190:	00a00713          	li	a4,10
4001d194:	00000793          	li	a5,0
4001d198:	03a00693          	li	a3,58
4001d19c:	00200613          	li	a2,2
4001d1a0:	014a8593          	addi	a1,s5,20
4001d1a4:	00090513          	mv	a0,s2
4001d1a8:	ee1fa0ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
4001d1ac:	00050413          	mv	s0,a0
					sizeof(struct net_icmpv6_ns_hdr) +
					llao_len,
					AF_INET6, IPPROTO_ICMPV6,
					ND_NET_BUF_TIMEOUT);
	if (!pkt) {
4001d1b0:	1e050e63          	beqz	a0,4001d3ac <net_ipv6_send_ns+0x2c0>
	pkt->ipv6_hop_limit = hop_limit;
4001d1b4:	fff00793          	li	a5,-1
4001d1b8:	02f50ca3          	sb	a5,57(a0)
		net_pkt_set_captured(pkt, net_pkt_is_captured(pending));
	}

	net_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);

	if (net_ipv6_create(pkt, src, dst) ||
4001d1bc:	000b0613          	mv	a2,s6
4001d1c0:	00048593          	mv	a1,s1
4001d1c4:	d24fe0ef          	jal	ra,4001b6e8 <net_ipv6_create>
4001d1c8:	08051863          	bnez	a0,4001d258 <net_ipv6_send_ns+0x16c>
	    net_icmpv6_create(pkt, NET_ICMPV6_NS, 0)) {
4001d1cc:	00000613          	li	a2,0
4001d1d0:	08700593          	li	a1,135
4001d1d4:	00040513          	mv	a0,s0
4001d1d8:	875fd0ef          	jal	ra,4001aa4c <net_icmpv6_create>
	if (net_ipv6_create(pkt, src, dst) ||
4001d1dc:	06051e63          	bnez	a0,4001d258 <net_ipv6_send_ns+0x16c>
		goto drop;
	}

	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
4001d1e0:	00810593          	addi	a1,sp,8
4001d1e4:	00040513          	mv	a0,s0
4001d1e8:	f00fb0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!ns_hdr) {
4001d1ec:	06050663          	beqz	a0,4001d258 <net_ipv6_send_ns+0x16c>
		goto drop;
	}

	ns_hdr->reserved = 0U;
4001d1f0:	00050023          	sb	zero,0(a0)
4001d1f4:	000500a3          	sb	zero,1(a0)
4001d1f8:	00050123          	sb	zero,2(a0)
4001d1fc:	000501a3          	sb	zero,3(a0)
	memcpy(dest, src, sizeof(struct in6_addr));
4001d200:	01000613          	li	a2,16
4001d204:	000a0593          	mv	a1,s4
4001d208:	00450513          	addi	a0,a0,4
4001d20c:	aedef0ef          	jal	ra,4000ccf8 <memcpy>
	net_ipv6_addr_copy_raw(ns_hdr->tgt, (uint8_t *)tgt);

	if (net_pkt_set_data(pkt, &ns_access)) {
4001d210:	00810593          	addi	a1,sp,8
4001d214:	00040513          	mv	a0,s0
4001d218:	fa0fb0ef          	jal	ra,400189b8 <net_pkt_set_data>
4001d21c:	00050493          	mv	s1,a0
4001d220:	02051c63          	bnez	a0,4001d258 <net_ipv6_send_ns+0x16c>
		goto drop;
	}

	if (!is_my_address) {
4001d224:	060b8863          	beqz	s7,4001d294 <net_ipv6_send_ns+0x1a8>
			      llao_len, NET_ICMPV6_ND_OPT_SLLAO)) {
			goto drop;
		}
	}

	net_pkt_cursor_init(pkt);
4001d228:	00040513          	mv	a0,s0
4001d22c:	8c5fa0ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
4001d230:	03a00593          	li	a1,58
4001d234:	00040513          	mv	a0,s0
4001d238:	da4fe0ef          	jal	ra,4001b7dc <net_ipv6_finalize>

	nbr = add_nbr(iface, tgt, false,
4001d23c:	000a0593          	mv	a1,s4
4001d240:	00000693          	li	a3,0
4001d244:	00000613          	li	a2,0
4001d248:	00090513          	mv	a0,s2
4001d24c:	f10ff0ef          	jal	ra,4001c95c <add_nbr>
4001d250:	00050a13          	mv	s4,a0
		      NET_IPV6_NBR_STATE_INCOMPLETE);
	if (!nbr) {
4001d254:	06051063          	bnez	a0,4001d2b4 <net_ipv6_send_ns+0x1c8>
	net_stats_update_ipv6_nd_sent(iface);

	return 0;

drop:
	if (pending) {
4001d258:	0c098c63          	beqz	s3,4001d330 <net_ipv6_send_ns+0x244>
		net_pkt_unref(pending);
4001d25c:	00098513          	mv	a0,s3
4001d260:	dbcfa0ef          	jal	ra,4001781c <net_pkt_unref>
	}

	if (pkt) {
4001d264:	0cc0006f          	j	4001d330 <net_ipv6_send_ns+0x244>
		if (!src) {
4001d268:	00049a63          	bnez	s1,4001d27c <net_ipv6_send_ns+0x190>
			src = net_if_ipv6_select_src_addr(iface, tgt);
4001d26c:	000a0593          	mv	a1,s4
4001d270:	00090513          	mv	a0,s2
4001d274:	a15f50ef          	jal	ra,40012c88 <net_if_ipv6_select_src_addr>
4001d278:	00050493          	mv	s1,a0
		if (net_ipv6_is_addr_unspecified(src)) {
4001d27c:	00048513          	mv	a0,s1
4001d280:	d5dfe0ef          	jal	ra,4001bfdc <net_ipv6_is_addr_unspecified>
4001d284:	14051263          	bnez	a0,4001d3c8 <net_ipv6_send_ns+0x2dc>
	return ROUND_UP(total_len, 8U);
4001d288:	009a8a93          	addi	s5,s5,9
4001d28c:	0f8afa93          	andi	s5,s5,248
4001d290:	f01ff06f          	j	4001d190 <net_ipv6_send_ns+0xa4>
	return &iface->if_dev->link_addr;
4001d294:	00092583          	lw	a1,0(s2)
		if (!set_llao(pkt, net_if_get_link_addr(iface),
4001d298:	00100693          	li	a3,1
4001d29c:	000a8613          	mv	a2,s5
4001d2a0:	01058593          	addi	a1,a1,16
4001d2a4:	00040513          	mv	a0,s0
4001d2a8:	878ff0ef          	jal	ra,4001c320 <set_llao>
4001d2ac:	f6051ee3          	bnez	a0,4001d228 <net_ipv6_send_ns+0x13c>
4001d2b0:	fa9ff06f          	j	4001d258 <net_ipv6_send_ns+0x16c>
	if (pending) {
4001d2b4:	06098863          	beqz	s3,4001d324 <net_ipv6_send_ns+0x238>
4001d2b8:	00c52a83          	lw	s5,12(a0)
		if (!net_ipv6_nbr_data(nbr)->pending) {
4001d2bc:	000aa783          	lw	a5,0(s5)
4001d2c0:	f8079ee3          	bnez	a5,4001d25c <net_ipv6_send_ns+0x170>
			net_ipv6_nbr_data(nbr)->pending = net_pkt_ref(pending);
4001d2c4:	00098513          	mv	a0,s3
4001d2c8:	cecfa0ef          	jal	ra,400177b4 <net_pkt_ref>
4001d2cc:	00aaa023          	sw	a0,0(s5)
4001d2d0:	00ca2983          	lw	s3,12(s4)
		net_ipv6_nbr_data(nbr)->send_ns = k_uptime_get();
4001d2d4:	ef9fe0ef          	jal	ra,4001c1cc <k_uptime_get>
4001d2d8:	02a9a423          	sw	a0,40(s3)
4001d2dc:	4003a537          	lui	a0,0x4003a
4001d2e0:	02b9a623          	sw	a1,44(s3)
4001d2e4:	bf050513          	addi	a0,a0,-1040 # 40039bf0 <ipv6_ns_reply_timer+0x10>
4001d2e8:	1a0140ef          	jal	ra,40031488 <z_timeout_remaining>
		if (!k_work_delayable_remaining_get(&ipv6_ns_reply_timer)) {
4001d2ec:	00b565b3          	or	a1,a0,a1
4001d2f0:	00058e63          	beqz	a1,4001d30c <net_ipv6_send_ns+0x220>
	if (net_send_data(pkt) < 0) {
4001d2f4:	00040513          	mv	a0,s0
4001d2f8:	bb4f20ef          	jal	ra,4000f6ac <net_send_data>
4001d2fc:	04055263          	bgez	a0,4001d340 <net_ipv6_send_ns+0x254>
			nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
4001d300:	00ca2503          	lw	a0,12(s4)
4001d304:	e35fe0ef          	jal	ra,4001c138 <nbr_clear_ns_pending>
	if (pkt) {
4001d308:	0280006f          	j	4001d330 <net_ipv6_send_ns+0x244>
			k_work_reschedule(&ipv6_ns_reply_timer,
4001d30c:	4003a537          	lui	a0,0x4003a
4001d310:	06400593          	li	a1,100
4001d314:	00000613          	li	a2,0
4001d318:	be050513          	addi	a0,a0,-1056 # 40039be0 <ipv6_ns_reply_timer>
4001d31c:	639120ef          	jal	ra,40030154 <k_work_reschedule>
4001d320:	fd5ff06f          	j	4001d2f4 <net_ipv6_send_ns+0x208>
	if (net_send_data(pkt) < 0) {
4001d324:	00040513          	mv	a0,s0
4001d328:	b84f20ef          	jal	ra,4000f6ac <net_send_data>
4001d32c:	00055a63          	bgez	a0,4001d340 <net_ipv6_send_ns+0x254>
		net_pkt_unref(pkt);
4001d330:	00040513          	mv	a0,s0
4001d334:	ce8fa0ef          	jal	ra,4001781c <net_pkt_unref>
4001d338:	f9700493          	li	s1,-105
4001d33c:	0800006f          	j	4001d3bc <net_ipv6_send_ns+0x2d0>
	UPDATE_STAT(iface, stats.icmp.sent++);
4001d340:	4003b7b7          	lui	a5,0x4003b
4001d344:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001d348:	0487a703          	lw	a4,72(a5)
	return pkt->iface;
4001d34c:	01842683          	lw	a3,24(s0)
4001d350:	00170713          	addi	a4,a4,1
4001d354:	04e7a423          	sw	a4,72(a5)
4001d358:	04c6a703          	lw	a4,76(a3)
4001d35c:	00170713          	addi	a4,a4,1
4001d360:	04e6a623          	sw	a4,76(a3)
	UPDATE_STAT(iface, stats.ipv6_nd.sent++);
4001d364:	0a87a703          	lw	a4,168(a5)
4001d368:	00170713          	addi	a4,a4,1
4001d36c:	0ae7a423          	sw	a4,168(a5)
4001d370:	0ac92783          	lw	a5,172(s2)
4001d374:	00178793          	addi	a5,a5,1
4001d378:	0af92623          	sw	a5,172(s2)
	}

	net_stats_update_ipv6_nd_drop(iface);

	return ret;
}
4001d37c:	04c12083          	lw	ra,76(sp)
4001d380:	04812403          	lw	s0,72(sp)
4001d384:	04012903          	lw	s2,64(sp)
4001d388:	03c12983          	lw	s3,60(sp)
4001d38c:	03812a03          	lw	s4,56(sp)
4001d390:	03412a83          	lw	s5,52(sp)
4001d394:	03012b03          	lw	s6,48(sp)
4001d398:	02c12b83          	lw	s7,44(sp)
4001d39c:	00048513          	mv	a0,s1
4001d3a0:	04412483          	lw	s1,68(sp)
4001d3a4:	05010113          	addi	sp,sp,80
4001d3a8:	00008067          	ret
	if (pending) {
4001d3ac:	00098663          	beqz	s3,4001d3b8 <net_ipv6_send_ns+0x2cc>
		net_pkt_unref(pending);
4001d3b0:	00098513          	mv	a0,s3
4001d3b4:	c68fa0ef          	jal	ra,4001781c <net_pkt_unref>
		ret = -ENOMEM;
4001d3b8:	ff400493          	li	s1,-12
	net_stats_update_ipv6_nd_drop(iface);
4001d3bc:	00090513          	mv	a0,s2
4001d3c0:	ce1fe0ef          	jal	ra,4001c0a0 <net_stats_update_ipv6_nd_drop>
	return ret;
4001d3c4:	fb9ff06f          	j	4001d37c <net_ipv6_send_ns+0x290>
	if (pending) {
4001d3c8:	00099663          	bnez	s3,4001d3d4 <net_ipv6_send_ns+0x2e8>
			ret = -EINVAL;
4001d3cc:	fea00493          	li	s1,-22
4001d3d0:	fedff06f          	j	4001d3bc <net_ipv6_send_ns+0x2d0>
		net_pkt_unref(pending);
4001d3d4:	00098513          	mv	a0,s3
4001d3d8:	c44fa0ef          	jal	ra,4001781c <net_pkt_unref>
	if (pkt) {
4001d3dc:	ff1ff06f          	j	4001d3cc <net_ipv6_send_ns+0x2e0>

4001d3e0 <net_ipv6_nbr_add>:
{
4001d3e0:	fd010113          	addi	sp,sp,-48
4001d3e4:	02812423          	sw	s0,40(sp)
4001d3e8:	02912223          	sw	s1,36(sp)
4001d3ec:	03212023          	sw	s2,32(sp)
4001d3f0:	01312e23          	sw	s3,28(sp)
4001d3f4:	01512a23          	sw	s5,20(sp)
4001d3f8:	02112623          	sw	ra,44(sp)
4001d3fc:	01412c23          	sw	s4,24(sp)
4001d400:	03010413          	addi	s0,sp,48
4001d404:	00060493          	mv	s1,a2
4001d408:	00068613          	mv	a2,a3
	nbr = add_nbr(iface, addr, is_router, state);
4001d40c:	00070693          	mv	a3,a4
{
4001d410:	00050993          	mv	s3,a0
4001d414:	00058a93          	mv	s5,a1
	nbr = add_nbr(iface, addr, is_router, state);
4001d418:	d44ff0ef          	jal	ra,4001c95c <add_nbr>
4001d41c:	00050913          	mv	s2,a0
	if (!nbr) {
4001d420:	0e051663          	bnez	a0,4001d50c <net_ipv6_nbr_add+0x12c>
		NET_ERR("Could not add router neighbor %s [%s]",
4001d424:	40044a37          	lui	s4,0x40044
4001d428:	77ca2783          	lw	a5,1916(s4) # 4004477c <log_dynamic_net_ipv6>
4001d42c:	0077f793          	andi	a5,a5,7
4001d430:	0a078263          	beqz	a5,4001d4d4 <net_ipv6_nbr_add+0xf4>
4001d434:	000a8593          	mv	a1,s5
4001d438:	00200513          	li	a0,2
4001d43c:	c78f70ef          	jal	ra,400148b4 <net_sprint_addr>
4001d440:	00050993          	mv	s3,a0
4001d444:	0a048e63          	beqz	s1,4001d500 <net_ipv6_nbr_add+0x120>
4001d448:	0044c583          	lbu	a1,4(s1)
4001d44c:	0004a503          	lw	a0,0(s1)
4001d450:	4003b637          	lui	a2,0x4003b
4001d454:	01800693          	li	a3,24
4001d458:	ea060613          	addi	a2,a2,-352 # 4003aea0 <buf.0>
4001d45c:	838f70ef          	jal	ra,40014494 <net_sprint_ll_addr_buf>
4001d460:	00010493          	mv	s1,sp
4001d464:	fd010113          	addi	sp,sp,-48
4001d468:	00010793          	mv	a5,sp
4001d46c:	40035737          	lui	a4,0x40035
4001d470:	01c70713          	addi	a4,a4,28 # 4003501c <all_nodes_mcast_group.0+0x80>
4001d474:	00e7aa23          	sw	a4,20(a5)
4001d478:	03010737          	lui	a4,0x3010
4001d47c:	20070713          	addi	a4,a4,512 # 3010200 <__rom_region_size+0x2fd7244>
4001d480:	fce42e23          	sw	a4,-36(s0)
4001d484:	01078613          	addi	a2,a5,16
4001d488:	0137ac23          	sw	s3,24(a5)
4001d48c:	00a7ae23          	sw	a0,28(a5)
4001d490:	00000713          	li	a4,0
4001d494:	00400693          	li	a3,4
4001d498:	fdc40513          	addi	a0,s0,-36
4001d49c:	00e50533          	add	a0,a0,a4
4001d4a0:	00054503          	lbu	a0,0(a0)
4001d4a4:	00e785b3          	add	a1,a5,a4
4001d4a8:	00170713          	addi	a4,a4,1
4001d4ac:	02a58023          	sb	a0,32(a1)
4001d4b0:	fed714e3          	bne	a4,a3,4001d498 <net_ipv6_nbr_add+0xb8>
4001d4b4:	02000737          	lui	a4,0x2000
4001d4b8:	00470713          	addi	a4,a4,4 # 2000004 <__rom_region_size+0x1fc7048>
4001d4bc:	000035b7          	lui	a1,0x3
4001d4c0:	00e7a823          	sw	a4,16(a5)
4001d4c4:	84058593          	addi	a1,a1,-1984 # 2840 <CONFIG_SRAM_SIZE+0x840>
4001d4c8:	77ca0513          	addi	a0,s4,1916
4001d4cc:	8f4ff0ef          	jal	ra,4001c5c0 <z_log_msg_static_create.constprop.0>
4001d4d0:	00048113          	mv	sp,s1
}
4001d4d4:	fd040113          	addi	sp,s0,-48
4001d4d8:	02c12083          	lw	ra,44(sp)
4001d4dc:	00090513          	mv	a0,s2
4001d4e0:	02812403          	lw	s0,40(sp)
4001d4e4:	02412483          	lw	s1,36(sp)
4001d4e8:	02012903          	lw	s2,32(sp)
4001d4ec:	01c12983          	lw	s3,28(sp)
4001d4f0:	01812a03          	lw	s4,24(sp)
4001d4f4:	01412a83          	lw	s5,20(sp)
4001d4f8:	03010113          	addi	sp,sp,48
4001d4fc:	00008067          	ret
		NET_ERR("Could not add router neighbor %s [%s]",
4001d500:	400347b7          	lui	a5,0x40034
4001d504:	76c78513          	addi	a0,a5,1900 # 4003476c <shell_m_sub_colors+0x194>
4001d508:	f59ff06f          	j	4001d460 <net_ipv6_nbr_add+0x80>
	if (lladdr && net_nbr_link(nbr, iface, lladdr) == -EALREADY &&
4001d50c:	06048663          	beqz	s1,4001d578 <net_ipv6_nbr_add+0x198>
4001d510:	00048613          	mv	a2,s1
4001d514:	00098593          	mv	a1,s3
4001d518:	e01fd0ef          	jal	ra,4001b318 <net_nbr_link>
4001d51c:	f8800793          	li	a5,-120
4001d520:	04f51c63          	bne	a0,a5,4001d578 <net_ipv6_nbr_add+0x198>
	    net_ipv6_nbr_data(nbr)->state != NET_IPV6_NBR_STATE_STATIC) {
4001d524:	00c92783          	lw	a5,12(s2)
	if (lladdr && net_nbr_link(nbr, iface, lladdr) == -EALREADY &&
4001d528:	0307a703          	lw	a4,48(a5)
4001d52c:	00500793          	li	a5,5
4001d530:	06f70e63          	beq	a4,a5,4001d5ac <net_ipv6_nbr_add+0x1cc>
		cached_lladdr = net_nbr_get_lladdr(nbr->idx);
4001d534:	00194503          	lbu	a0,1(s2)
4001d538:	fcdfd0ef          	jal	ra,4001b504 <net_nbr_get_lladdr>
		if (memcmp(cached_lladdr->addr, lladdr->addr, lladdr->len)) {
4001d53c:	0044c603          	lbu	a2,4(s1)
4001d540:	0004a583          	lw	a1,0(s1)
		cached_lladdr = net_nbr_get_lladdr(nbr->idx);
4001d544:	00050a13          	mv	s4,a0
		if (memcmp(cached_lladdr->addr, lladdr->addr, lladdr->len)) {
4001d548:	00250513          	addi	a0,a0,2
4001d54c:	f2cef0ef          	jal	ra,4000cc78 <memcmp>
4001d550:	04050863          	beqz	a0,4001d5a0 <net_ipv6_nbr_add+0x1c0>
			dbg_update_neighbor_lladdr(lladdr, cached_lladdr, addr);
4001d554:	000a0513          	mv	a0,s4
4001d558:	928ff0ef          	jal	ra,4001c680 <dbg_update_neighbor_lladdr.constprop.0>
			net_linkaddr_set(cached_lladdr, lladdr->addr,
4001d55c:	0044c603          	lbu	a2,4(s1)
4001d560:	0004a583          	lw	a1,0(s1)
4001d564:	000a0513          	mv	a0,s4
4001d568:	8f4ff0ef          	jal	ra,4001c65c <net_linkaddr_set.isra.0>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
4001d56c:	00200593          	li	a1,2
4001d570:	00090513          	mv	a0,s2
4001d574:	950ff0ef          	jal	ra,4001c6c4 <ipv6_nbr_set_state>
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_INCOMPLETE) {
4001d578:	00c92783          	lw	a5,12(s2)
4001d57c:	0307a783          	lw	a5,48(a5)
4001d580:	02079663          	bnez	a5,4001d5ac <net_ipv6_nbr_add+0x1cc>
		ret = net_ipv6_send_ns(iface, NULL, NULL, NULL, addr, false);
4001d584:	000a8713          	mv	a4,s5
4001d588:	00000693          	li	a3,0
4001d58c:	00000613          	li	a2,0
4001d590:	00000593          	li	a1,0
4001d594:	00098513          	mv	a0,s3
4001d598:	b55ff0ef          	jal	ra,4001d0ec <net_ipv6_send_ns>
		if (ret < 0) {
4001d59c:	0100006f          	j	4001d5ac <net_ipv6_nbr_add+0x1cc>
		} else if (net_ipv6_nbr_data(nbr)->state ==
4001d5a0:	00c92783          	lw	a5,12(s2)
4001d5a4:	0307a783          	lw	a5,48(a5)
4001d5a8:	fc0782e3          	beqz	a5,4001d56c <net_ipv6_nbr_add+0x18c>
4001d5ac:	e0600537          	lui	a0,0xe0600
4001d5b0:	00000693          	li	a3,0
4001d5b4:	00000613          	li	a2,0
4001d5b8:	00098593          	mv	a1,s3
4001d5bc:	00f50513          	addi	a0,a0,15 # e060000f <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600010>
4001d5c0:	90cf80ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
}
4001d5c4:	f11ff06f          	j	4001d4d4 <net_ipv6_nbr_add+0xf4>

4001d5c8 <handle_ra_input>:
#endif

static enum net_verdict handle_ra_input(struct net_pkt *pkt,
					struct net_ipv6_hdr *ip_hdr,
					struct net_icmp_hdr *icmp_hdr)
{
4001d5c8:	f5010113          	addi	sp,sp,-176
4001d5cc:	0a812423          	sw	s0,168(sp)
4001d5d0:	0a912223          	sw	s1,164(sp)
4001d5d4:	09312e23          	sw	s3,156(sp)
4001d5d8:	09412c23          	sw	s4,152(sp)
4001d5dc:	09512a23          	sw	s5,148(sp)
4001d5e0:	0a112623          	sw	ra,172(sp)
4001d5e4:	0b212023          	sw	s2,160(sp)
4001d5e8:	09612823          	sw	s6,144(sp)
4001d5ec:	09712623          	sw	s7,140(sp)
4001d5f0:	09812423          	sw	s8,136(sp)
4001d5f4:	09912223          	sw	s9,132(sp)
4001d5f8:	09a12023          	sw	s10,128(sp)
4001d5fc:	07b12e23          	sw	s11,124(sp)
4001d600:	0b010413          	addi	s0,sp,176
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,
4001d604:	00c00793          	li	a5,12
4001d608:	f6f42e23          	sw	a5,-132(s0)
					      struct net_icmpv6_ra_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
4001d60c:	f6840793          	addi	a5,s0,-152
4001d610:	f8f42023          	sw	a5,-128(s0)
4001d614:	00200793          	li	a5,2
4001d618:	f8f42223          	sw	a5,-124(s0)
	uint16_t length = net_pkt_get_len(pkt);
4001d61c:	00852783          	lw	a5,8(a0)
{
4001d620:	00050493          	mv	s1,a0
4001d624:	00058a93          	mv	s5,a1
4001d628:	00060a13          	mv	s4,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,
4001d62c:	f6042c23          	sw	zero,-136(s0)
	size_t bytes = 0;
4001d630:	00000993          	li	s3,0
	while (buf) {
4001d634:	06079863          	bnez	a5,4001d6a4 <handle_ra_input+0xdc>
	struct net_icmpv6_ra_hdr *ra_hdr;
	struct net_if_router *router;
	uint32_t mtu, reachable_time, retrans_timer;
	uint16_t router_lifetime;

	if (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {
4001d638:	0184a503          	lw	a0,24(s1)
4001d63c:	00b00593          	li	a1,11
4001d640:	fd9fe0ef          	jal	ra,4001c618 <net_if_flag_is_set>
4001d644:	04051863          	bnez	a0,4001d694 <handle_ra_input+0xcc>
		goto drop;
	}

	ra_hdr = (struct net_icmpv6_ra_hdr *)net_pkt_get_data(pkt, &ra_access);
4001d648:	f7840593          	addi	a1,s0,-136
4001d64c:	00048513          	mv	a0,s1
4001d650:	a98fb0ef          	jal	ra,400188e8 <net_pkt_get_data>
4001d654:	00050913          	mv	s2,a0
	if (!ra_hdr) {
4001d658:	04051e63          	bnez	a0,4001d6b4 <handle_ra_input+0xec>
		NET_ERR("DROP: NULL RA header");
4001d65c:	40044537          	lui	a0,0x40044
4001d660:	77c52783          	lw	a5,1916(a0) # 4004477c <log_dynamic_net_ipv6>
4001d664:	0077f793          	andi	a5,a5,7
4001d668:	02078663          	beqz	a5,4001d694 <handle_ra_input+0xcc>
4001d66c:	400357b7          	lui	a5,0x40035
4001d670:	04478793          	addi	a5,a5,68 # 40035044 <all_nodes_mcast_group.0+0xa8>
4001d674:	faf42a23          	sw	a5,-76(s0)
4001d678:	000015b7          	lui	a1,0x1
4001d67c:	00200793          	li	a5,2
4001d680:	faf42823          	sw	a5,-80(s0)
4001d684:	fb040613          	addi	a2,s0,-80
4001d688:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4001d68c:	77c50513          	addi	a0,a0,1916
4001d690:	f31fe0ef          	jal	ra,4001c5c0 <z_log_msg_static_create.constprop.0>
	net_pkt_unref(pkt);

	return NET_OK;

drop:
	net_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));
4001d694:	0184a503          	lw	a0,24(s1)
4001d698:	a09fe0ef          	jal	ra,4001c0a0 <net_stats_update_ipv6_nd_drop>

	return NET_DROP;
4001d69c:	00200513          	li	a0,2
4001d6a0:	3490006f          	j	4001e1e8 <handle_ra_input+0xc20>
		bytes += buf->len;
4001d6a4:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
4001d6a8:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4001d6ac:	00e989b3          	add	s3,s3,a4
		buf = buf->frags;
4001d6b0:	f85ff06f          	j	4001d634 <handle_ra_input+0x6c>
	UPDATE_STAT(iface, stats.ipv6_nd.recv++);
4001d6b4:	4003b7b7          	lui	a5,0x4003b
4001d6b8:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001d6bc:	0a47a703          	lw	a4,164(a5)
4001d6c0:	0184a683          	lw	a3,24(s1)
	if (((length < (sizeof(struct net_ipv6_hdr) +
4001d6c4:	01099993          	slli	s3,s3,0x10
4001d6c8:	00170713          	addi	a4,a4,1
4001d6cc:	0ae7a223          	sw	a4,164(a5)
4001d6d0:	0a86a783          	lw	a5,168(a3)
4001d6d4:	0109d993          	srli	s3,s3,0x10
4001d6d8:	00178793          	addi	a5,a5,1
4001d6dc:	0af6a423          	sw	a5,168(a3)
4001d6e0:	03900793          	li	a5,57
4001d6e4:	0337f663          	bgeu	a5,s3,4001d710 <handle_ra_input+0x148>
			sizeof(struct net_icmpv6_nd_opt_hdr))) ||
4001d6e8:	007ac703          	lbu	a4,7(s5)
4001d6ec:	0ff00793          	li	a5,255
4001d6f0:	02f71063          	bne	a4,a5,4001d710 <handle_ra_input+0x148>
	return UNALIGNED_GET(&addr->s6_addr16[0]) == htons(0xFE80);
4001d6f4:	009ac783          	lbu	a5,9(s5)
4001d6f8:	008ac703          	lbu	a4,8(s5)
4001d6fc:	00879793          	slli	a5,a5,0x8
	     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||
4001d700:	00e7e7b3          	or	a5,a5,a4
4001d704:	00008737          	lui	a4,0x8
4001d708:	0fe70713          	addi	a4,a4,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
4001d70c:	00e78663          	beq	a5,a4,4001d718 <handle_ra_input+0x150>
	     !net_ipv6_is_ll_addr((struct in6_addr *)ip_hdr->src)) &&
4001d710:	001a4783          	lbu	a5,1(s4)
4001d714:	f80790e3          	bnez	a5,4001d694 <handle_ra_input+0xcc>
	net_pkt_acknowledge_data(pkt, &ra_access);
4001d718:	f7c42583          	lw	a1,-132(s0)
4001d71c:	00048513          	mv	a0,s1
4001d720:	f39fe0ef          	jal	ra,4001c658 <net_pkt_acknowledge_data.isra.0>
	router_lifetime = ntohs(ra_hdr->router_lifetime);
4001d724:	00394b03          	lbu	s6,3(s2)
4001d728:	00294783          	lbu	a5,2(s2)
	reachable_time = ntohl(ra_hdr->reachable_time);
4001d72c:	00594703          	lbu	a4,5(s2)
4001d730:	008b1b13          	slli	s6,s6,0x8
4001d734:	00fb6b33          	or	s6,s6,a5
4001d738:	00494783          	lbu	a5,4(s2)
4001d73c:	00871713          	slli	a4,a4,0x8
4001d740:	00794983          	lbu	s3,7(s2)
4001d744:	00f76733          	or	a4,a4,a5
4001d748:	00694783          	lbu	a5,6(s2)
4001d74c:	01899993          	slli	s3,s3,0x18
4001d750:	00010637          	lui	a2,0x10
4001d754:	01079793          	slli	a5,a5,0x10
4001d758:	00e7e7b3          	or	a5,a5,a4
4001d75c:	00f9e733          	or	a4,s3,a5
4001d760:	01879793          	slli	a5,a5,0x18
4001d764:	0189d993          	srli	s3,s3,0x18
4001d768:	00f9e9b3          	or	s3,s3,a5
4001d76c:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
4001d770:	00875793          	srli	a5,a4,0x8
4001d774:	00ff05b7          	lui	a1,0xff0
4001d778:	00c7f7b3          	and	a5,a5,a2
4001d77c:	00871713          	slli	a4,a4,0x8
4001d780:	00b77733          	and	a4,a4,a1
4001d784:	00f9e9b3          	or	s3,s3,a5
	retrans_timer = ntohl(ra_hdr->retrans_timer);
4001d788:	00994783          	lbu	a5,9(s2)
	reachable_time = ntohl(ra_hdr->reachable_time);
4001d78c:	00e9e9b3          	or	s3,s3,a4
	retrans_timer = ntohl(ra_hdr->retrans_timer);
4001d790:	00894703          	lbu	a4,8(s2)
4001d794:	00879793          	slli	a5,a5,0x8
4001d798:	00e7e7b3          	or	a5,a5,a4
4001d79c:	00a94703          	lbu	a4,10(s2)
4001d7a0:	01071713          	slli	a4,a4,0x10
4001d7a4:	00f76733          	or	a4,a4,a5
4001d7a8:	00b94783          	lbu	a5,11(s2)
4001d7ac:	01879793          	slli	a5,a5,0x18
4001d7b0:	00e7e6b3          	or	a3,a5,a4
4001d7b4:	0187da13          	srli	s4,a5,0x18
4001d7b8:	0086d793          	srli	a5,a3,0x8
4001d7bc:	00869693          	slli	a3,a3,0x8
4001d7c0:	00b6f6b3          	and	a3,a3,a1
4001d7c4:	01871713          	slli	a4,a4,0x18
	if (ra_hdr->cur_hop_limit) {
4001d7c8:	00094583          	lbu	a1,0(s2)
	retrans_timer = ntohl(ra_hdr->retrans_timer);
4001d7cc:	00ea6a33          	or	s4,s4,a4
4001d7d0:	00c7f7b3          	and	a5,a5,a2
4001d7d4:	00fa6a33          	or	s4,s4,a5
4001d7d8:	00da6a33          	or	s4,s4,a3
	if (ra_hdr->cur_hop_limit) {
4001d7dc:	00058663          	beqz	a1,4001d7e8 <handle_ra_input+0x220>
		net_ipv6_set_hop_limit(net_pkt_iface(pkt),
4001d7e0:	0184a503          	lw	a0,24(s1)
4001d7e4:	b9cf50ef          	jal	ra,40012b80 <net_ipv6_set_hop_limit>
	if (reachable_time && reachable_time <= MAX_REACHABLE_TIME &&
4001d7e8:	0036f7b7          	lui	a5,0x36f
4001d7ec:	fff98713          	addi	a4,s3,-1
4001d7f0:	e7f78793          	addi	a5,a5,-385 # 36ee7f <__rom_region_size+0x335ec3>
4001d7f4:	02e7ea63          	bltu	a5,a4,4001d828 <handle_ra_input+0x260>
4001d7f8:	0184a783          	lw	a5,24(s1)
4001d7fc:	0bc7a783          	lw	a5,188(a5)
	if (!iface->config.ip.ipv6) {
4001d800:	00078863          	beqz	a5,4001d810 <handle_ra_input+0x248>
4001d804:	1447a703          	lw	a4,324(a5)
4001d808:	02e98063          	beq	s3,a4,4001d828 <handle_ra_input+0x260>
	iface->config.ip.ipv6->base_reachable_time = reachable_time;
4001d80c:	1537a023          	sw	s3,320(a5)
		net_if_ipv6_set_reachable_time(
4001d810:	0184a783          	lw	a5,24(s1)
4001d814:	0bc7a983          	lw	s3,188(a5)
	if (ipv6 == NULL) {
4001d818:	00098863          	beqz	s3,4001d828 <handle_ra_input+0x260>
	ipv6->reachable_time = net_if_ipv6_calc_reachable_time(ipv6);
4001d81c:	00098513          	mv	a0,s3
4001d820:	dfcf50ef          	jal	ra,40012e1c <net_if_ipv6_calc_reachable_time>
4001d824:	14a9a223          	sw	a0,324(s3)
	if (retrans_timer) {
4001d828:	020a0e63          	beqz	s4,4001d864 <handle_ra_input+0x29c>
4001d82c:	0184a783          	lw	a5,24(s1)
4001d830:	0bc7a683          	lw	a3,188(a5)
	if (!iface->config.ip.ipv6) {
4001d834:	02068863          	beqz	a3,4001d864 <handle_ra_input+0x29c>
		net_if_ipv6_set_retrans_timer(net_pkt_iface(pkt),
4001d838:	00994783          	lbu	a5,9(s2)
4001d83c:	00894703          	lbu	a4,8(s2)
4001d840:	00879793          	slli	a5,a5,0x8
4001d844:	00e7e7b3          	or	a5,a5,a4
4001d848:	00a94703          	lbu	a4,10(s2)
4001d84c:	01071713          	slli	a4,a4,0x10
4001d850:	00f76733          	or	a4,a4,a5
4001d854:	00b94783          	lbu	a5,11(s2)
4001d858:	01879793          	slli	a5,a5,0x18
4001d85c:	00e7e7b3          	or	a5,a5,a4
	iface->config.ip.ipv6->retrans_timer = retrans_timer;
4001d860:	14f6a423          	sw	a5,328(a3)
	pkt->ipv6_ext_opt_len = len;
4001d864:	00c00793          	li	a5,12
4001d868:	02f48f23          	sb	a5,62(s1)
				net_pkt_get_data(pkt, &nd_access);
4001d86c:	f8040593          	addi	a1,s0,-128
4001d870:	00048513          	mv	a0,s1
4001d874:	874fb0ef          	jal	ra,400188e8 <net_pkt_get_data>
	return pkt->frags->data;
4001d878:	0084a783          	lw	a5,8(s1)
4001d87c:	00050913          	mv	s2,a0
	nbr = net_ipv6_nbr_add(net_pkt_iface(pkt), (struct in6_addr *)NET_IPV6_HDR(pkt)->src, NULL,
4001d880:	0184a503          	lw	a0,24(s1)
4001d884:	00c7a583          	lw	a1,12(a5)
4001d888:	00000713          	li	a4,0
4001d88c:	00100693          	li	a3,1
4001d890:	00000613          	li	a2,0
4001d894:	00858593          	addi	a1,a1,8 # ff0008 <__rom_region_size+0xfb704c>
4001d898:	b49ff0ef          	jal	ra,4001d3e0 <net_ipv6_nbr_add>
			if (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {
4001d89c:	00010bb7          	lui	s7,0x10
	rdnss_size = len * 8U - 2 - sizeof(struct net_icmpv6_nd_opt_rdnss);
4001d8a0:	20000cb7          	lui	s9,0x20000
	nbr = net_ipv6_nbr_add(net_pkt_iface(pkt), (struct in6_addr *)NET_IPV6_HDR(pkt)->src, NULL,
4001d8a4:	00050a13          	mv	s4,a0
			if (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {
4001d8a8:	affb8d13          	addi	s10,s7,-1281 # faff <__kernel_ram_size+0x3ff7>
	NET_PKT_DATA_ACCESS_DEFINE(routeinfo_access,
4001d8ac:	f8840c13          	addi	s8,s0,-120
	rdnss_size = len * 8U - 2 - sizeof(struct net_icmpv6_nd_opt_rdnss);
4001d8b0:	fffc8c93          	addi	s9,s9,-1 # 1fffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1a0a1eff>
	while (nd_opt_hdr) {
4001d8b4:	04091463          	bnez	s2,4001d8fc <handle_ra_input+0x334>
4001d8b8:	008b5793          	srli	a5,s6,0x8
4001d8bc:	008b1613          	slli	a2,s6,0x8
4001d8c0:	00f66633          	or	a2,a2,a5
	router = net_if_ipv6_router_lookup(net_pkt_iface(pkt),
4001d8c4:	0184a503          	lw	a0,24(s1)
4001d8c8:	01061613          	slli	a2,a2,0x10
4001d8cc:	01065613          	srli	a2,a2,0x10
					   (struct in6_addr *)ip_hdr->src);
4001d8d0:	008a8593          	addi	a1,s5,8
4001d8d4:	f4c42c23          	sw	a2,-168(s0)
	router = net_if_ipv6_router_lookup(net_pkt_iface(pkt),
4001d8d8:	f4b42e23          	sw	a1,-164(s0)
4001d8dc:	9f8f50ef          	jal	ra,40012ad4 <net_if_ipv6_router_lookup>
	if (router) {
4001d8e0:	f5c42583          	lw	a1,-164(s0)
4001d8e4:	f5842603          	lw	a2,-168(s0)
4001d8e8:	180500e3          	beqz	a0,4001e268 <handle_ra_input+0xca0>
		if (!router_lifetime) {
4001d8ec:	0c0b1ee3          	bnez	s6,4001e1c8 <handle_ra_input+0xc00>
			net_if_ipv6_router_rm(router);
4001d8f0:	a44f50ef          	jal	ra,40012b34 <net_if_ipv6_router_rm>
	if (nbr && net_ipv6_nbr_data(nbr)->pending) {
4001d8f4:	0e0a00e3          	beqz	s4,4001e1d4 <handle_ra_input+0xc0c>
4001d8f8:	1450006f          	j	4001e23c <handle_ra_input+0xc74>
		net_pkt_acknowledge_data(pkt, &nd_access);
4001d8fc:	f8442583          	lw	a1,-124(s0)
4001d900:	00048513          	mv	a0,s1
4001d904:	d55fe0ef          	jal	ra,4001c658 <net_pkt_acknowledge_data.isra.0>
		switch (nd_opt_hdr->type) {
4001d908:	00094983          	lbu	s3,0(s2)
4001d90c:	00500793          	li	a5,5
4001d910:	16f98063          	beq	s3,a5,4001da70 <handle_ra_input+0x4a8>
4001d914:	00194903          	lbu	s2,1(s2)
4001d918:	0337e663          	bltu	a5,s3,4001d944 <handle_ra_input+0x37c>
4001d91c:	00100793          	li	a5,1
4001d920:	0ef98863          	beq	s3,a5,4001da10 <handle_ra_input+0x448>
4001d924:	00300793          	li	a5,3
4001d928:	1ef98263          	beq	s3,a5,4001db0c <handle_ra_input+0x544>
			if (net_pkt_skip(pkt, nd_opt_hdr->len * 8U - 2)) {
4001d92c:	00391593          	slli	a1,s2,0x3
4001d930:	ffe58593          	addi	a1,a1,-2
4001d934:	00048513          	mv	a0,s1
4001d938:	f98fa0ef          	jal	ra,400180d0 <net_pkt_skip>
4001d93c:	12050063          	beqz	a0,4001da5c <handle_ra_input+0x494>
4001d940:	d55ff06f          	j	4001d694 <handle_ra_input+0xcc>
		switch (nd_opt_hdr->type) {
4001d944:	01800793          	li	a5,24
4001d948:	68f98e63          	beq	s3,a5,4001dfe4 <handle_ra_input+0xa1c>
4001d94c:	01900793          	li	a5,25
4001d950:	fcf99ee3          	bne	s3,a5,4001d92c <handle_ra_input+0x364>
	NET_PKT_DATA_ACCESS_DEFINE(rdnss_access, struct net_icmpv6_nd_opt_rdnss);
4001d954:	f7040793          	addi	a5,s0,-144
4001d958:	f8f42423          	sw	a5,-120(s0)
4001d95c:	00600793          	li	a5,6
4001d960:	f8f42623          	sw	a5,-116(s0)
	struct sockaddr_in6 dns = {
4001d964:	00000593          	li	a1,0
4001d968:	01600613          	li	a2,22
4001d96c:	fa240513          	addi	a0,s0,-94
4001d970:	bacef0ef          	jal	ra,4000cd1c <memset>
4001d974:	00200793          	li	a5,2
4001d978:	faf41023          	sh	a5,-96(s0)
	const struct sockaddr *dns_servers[] = {
4001d97c:	fa040793          	addi	a5,s0,-96
4001d980:	f8f42823          	sw	a5,-112(s0)
4001d984:	f8042a23          	sw	zero,-108(s0)
	rdnss = (struct net_icmpv6_nd_opt_rdnss *) net_pkt_get_data(pkt, &rdnss_access);
4001d988:	000c0593          	mv	a1,s8
4001d98c:	00048513          	mv	a0,s1
4001d990:	f59fa0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!rdnss) {
4001d994:	d00500e3          	beqz	a0,4001d694 <handle_ra_input+0xcc>
	ret = net_pkt_acknowledge_data(pkt, &rdnss_access);
4001d998:	f8c42583          	lw	a1,-116(s0)
4001d99c:	00048513          	mv	a0,s1
4001d9a0:	cb9fe0ef          	jal	ra,4001c658 <net_pkt_acknowledge_data.isra.0>
	if (ret < 0) {
4001d9a4:	ce0548e3          	bltz	a0,4001d694 <handle_ra_input+0xcc>
	rdnss_size = len * 8U - 2 - sizeof(struct net_icmpv6_nd_opt_rdnss);
4001d9a8:	01990933          	add	s2,s2,s9
4001d9ac:	00391913          	slli	s2,s2,0x3
	if ((rdnss_size % NET_IPV6_ADDR_SIZE) != 0) {
4001d9b0:	00f97793          	andi	a5,s2,15
4001d9b4:	ce0790e3          	bnez	a5,4001d694 <handle_ra_input+0xcc>
	ret = net_pkt_read(pkt, dns.sin6_addr.s6_addr, NET_IPV6_ADDR_SIZE);
4001d9b8:	01000613          	li	a2,16
4001d9bc:	fa440593          	addi	a1,s0,-92
4001d9c0:	00048513          	mv	a0,s1
4001d9c4:	975fa0ef          	jal	ra,40018338 <net_pkt_read>
4001d9c8:	00050993          	mv	s3,a0
	if (ret < 0) {
4001d9cc:	7a055863          	bgez	a0,4001e17c <handle_ra_input+0xbb4>
		NET_ERR("Failed to read RDNSS address, %d", ret);
4001d9d0:	40044537          	lui	a0,0x40044
4001d9d4:	77c52783          	lw	a5,1916(a0) # 4004477c <log_dynamic_net_ipv6>
4001d9d8:	0077f793          	andi	a5,a5,7
4001d9dc:	ca078ce3          	beqz	a5,4001d694 <handle_ra_input+0xcc>
4001d9e0:	00010913          	mv	s2,sp
4001d9e4:	fe010113          	addi	sp,sp,-32
4001d9e8:	00010613          	mv	a2,sp
4001d9ec:	400357b7          	lui	a5,0x40035
4001d9f0:	11478793          	addi	a5,a5,276 # 40035114 <all_nodes_mcast_group.0+0x178>
		NET_ERR("Failed to skip RDNSS address, %d", ret);
4001d9f4:	00f62a23          	sw	a5,20(a2)
4001d9f8:	00300793          	li	a5,3
4001d9fc:	01362c23          	sw	s3,24(a2)
4001da00:	00f62823          	sw	a5,16(a2)
4001da04:	000025b7          	lui	a1,0x2
4001da08:	01060613          	addi	a2,a2,16
4001da0c:	0d80006f          	j	4001dae4 <handle_ra_input+0x51c>
	if (!read_llao(pkt, len, &llstorage)) {
4001da10:	fa040613          	addi	a2,s0,-96
4001da14:	00090593          	mv	a1,s2
4001da18:	00048513          	mv	a0,s1
4001da1c:	991fe0ef          	jal	ra,4001c3ac <read_llao>
4001da20:	c6050ae3          	beqz	a0,4001d694 <handle_ra_input+0xcc>
	lladdr.len = llstorage.len;
4001da24:	fa144783          	lbu	a5,-95(s0)
	return net_ipv6_nbr_add(net_pkt_iface(pkt),
4001da28:	0184a503          	lw	a0,24(s1)
4001da2c:	00200713          	li	a4,2
	lladdr.len = llstorage.len;
4001da30:	f8f40a23          	sb	a5,-108(s0)
	lladdr.addr = llstorage.addr;
4001da34:	fa240793          	addi	a5,s0,-94
4001da38:	f8f42823          	sw	a5,-112(s0)
4001da3c:	0084a783          	lw	a5,8(s1)
	return net_ipv6_nbr_add(net_pkt_iface(pkt),
4001da40:	00100693          	li	a3,1
4001da44:	f9040613          	addi	a2,s0,-112
				(struct in6_addr *)NET_IPV6_HDR(pkt)->src,
4001da48:	00c7a583          	lw	a1,12(a5)
	return net_ipv6_nbr_add(net_pkt_iface(pkt),
4001da4c:	00858593          	addi	a1,a1,8 # 2008 <CONFIG_SRAM_SIZE+0x8>
4001da50:	991ff0ef          	jal	ra,4001d3e0 <net_ipv6_nbr_add>
4001da54:	00050a13          	mv	s4,a0
			if (!nbr) {
4001da58:	c2050ee3          	beqz	a0,4001d694 <handle_ra_input+0xcc>
					net_pkt_get_data(pkt, &nd_access);
4001da5c:	f8040593          	addi	a1,s0,-128
4001da60:	00048513          	mv	a0,s1
4001da64:	e85fa0ef          	jal	ra,400188e8 <net_pkt_get_data>
4001da68:	00050913          	mv	s2,a0
4001da6c:	e49ff06f          	j	4001d8b4 <handle_ra_input+0x2ec>
			if (net_pkt_skip(pkt, 2) ||
4001da70:	00200593          	li	a1,2
4001da74:	00048513          	mv	a0,s1
4001da78:	e58fa0ef          	jal	ra,400180d0 <net_pkt_skip>
4001da7c:	c0051ce3          	bnez	a0,4001d694 <handle_ra_input+0xcc>
			    net_pkt_read_be32(pkt, &mtu)) {
4001da80:	f6c40593          	addi	a1,s0,-148
4001da84:	00048513          	mv	a0,s1
4001da88:	8bdfa0ef          	jal	ra,40018344 <net_pkt_read_be32>
			if (net_pkt_skip(pkt, 2) ||
4001da8c:	c00514e3          	bnez	a0,4001d694 <handle_ra_input+0xcc>
			if (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {
4001da90:	f6c42783          	lw	a5,-148(s0)
4001da94:	b0078713          	addi	a4,a5,-1280
4001da98:	04ed7c63          	bgeu	s10,a4,4001daf0 <handle_ra_input+0x528>
				NET_ERR("DROP: Unsupported MTU %u, min is %u, "
4001da9c:	40044537          	lui	a0,0x40044
4001daa0:	77c52703          	lw	a4,1916(a0) # 4004477c <log_dynamic_net_ipv6>
4001daa4:	00777713          	andi	a4,a4,7
4001daa8:	be0706e3          	beqz	a4,4001d694 <handle_ra_input+0xcc>
4001daac:	00010913          	mv	s2,sp
4001dab0:	fd010113          	addi	sp,sp,-48
4001dab4:	00010613          	mv	a2,sp
4001dab8:	40035737          	lui	a4,0x40035
4001dabc:	00f62c23          	sw	a5,24(a2)
4001dac0:	05c70713          	addi	a4,a4,92 # 4003505c <all_nodes_mcast_group.0+0xc0>
4001dac4:	50000793          	li	a5,1280
4001dac8:	fffb8b93          	addi	s7,s7,-1
4001dacc:	00e62a23          	sw	a4,20(a2)
4001dad0:	00f62e23          	sw	a5,28(a2)
4001dad4:	03762023          	sw	s7,32(a2)
4001dad8:	01362823          	sw	s3,16(a2)
4001dadc:	000035b7          	lui	a1,0x3
4001dae0:	01060613          	addi	a2,a2,16
		NET_ERR("Failed to skip RDNSS address, %d", ret);
4001dae4:	84058593          	addi	a1,a1,-1984 # 2840 <CONFIG_SRAM_SIZE+0x840>
4001dae8:	77c50513          	addi	a0,a0,1916
4001daec:	61c0006f          	j	4001e108 <handle_ra_input+0xb40>
	return pkt->iface;
4001daf0:	0184a703          	lw	a4,24(s1)
			net_if_set_mtu(net_pkt_iface(pkt), mtu);
4001daf4:	01079793          	slli	a5,a5,0x10
4001daf8:	0107d793          	srli	a5,a5,0x10
	if (iface == NULL) {
4001dafc:	f60700e3          	beqz	a4,4001da5c <handle_ra_input+0x494>
	iface->if_dev->mtu = mtu;
4001db00:	00072703          	lw	a4,0(a4)
4001db04:	00f71c23          	sh	a5,24(a4)
4001db08:	f55ff06f          	j	4001da5c <handle_ra_input+0x494>
			if (nd_opt_hdr->len != 4) {
4001db0c:	00400793          	li	a5,4
4001db10:	06f90663          	beq	s2,a5,4001db7c <handle_ra_input+0x5b4>
				NET_ERR("DROP: Invalid %s length (%d)",
4001db14:	40044537          	lui	a0,0x40044
4001db18:	77c52783          	lw	a5,1916(a0) # 4004477c <log_dynamic_net_ipv6>
4001db1c:	0077f793          	andi	a5,a5,7
4001db20:	b6078ae3          	beqz	a5,4001d694 <handle_ra_input+0xcc>
4001db24:	00010993          	mv	s3,sp
4001db28:	fd010113          	addi	sp,sp,-48
4001db2c:	00010613          	mv	a2,sp
4001db30:	400357b7          	lui	a5,0x40035
4001db34:	08c78793          	addi	a5,a5,140 # 4003508c <all_nodes_mcast_group.0+0xf0>
4001db38:	00f62a23          	sw	a5,20(a2)
4001db3c:	400357b7          	lui	a5,0x40035
4001db40:	0ac78793          	addi	a5,a5,172 # 400350ac <all_nodes_mcast_group.0+0x110>
				NET_ERR("DROP: Invalid %s length (%d)",
4001db44:	00f62c23          	sw	a5,24(a2)
4001db48:	20000793          	li	a5,512
4001db4c:	02f61023          	sh	a5,32(a2)
4001db50:	010007b7          	lui	a5,0x1000
4001db54:	00478793          	addi	a5,a5,4 # 1000004 <__rom_region_size+0xfc7048>
4001db58:	000025b7          	lui	a1,0x2
4001db5c:	01262e23          	sw	s2,28(a2)
4001db60:	00f62823          	sw	a5,16(a2)
4001db64:	44058593          	addi	a1,a1,1088 # 2440 <CONFIG_SRAM_SIZE+0x440>
4001db68:	01060613          	addi	a2,a2,16
4001db6c:	77c50513          	addi	a0,a0,1916
4001db70:	a51fe0ef          	jal	ra,4001c5c0 <z_log_msg_static_create.constprop.0>
4001db74:	00098113          	mv	sp,s3
4001db78:	b1dff06f          	j	4001d694 <handle_ra_input+0xcc>
	NET_PKT_DATA_ACCESS_DEFINE(rapfx_access,
4001db7c:	fa040793          	addi	a5,s0,-96
4001db80:	f8f42423          	sw	a5,-120(s0)
4001db84:	01e00793          	li	a5,30
4001db88:	f8f42623          	sw	a5,-116(s0)
				net_pkt_get_data(pkt, &rapfx_access);
4001db8c:	000c0593          	mv	a1,s8
4001db90:	00048513          	mv	a0,s1
4001db94:	d55fa0ef          	jal	ra,400188e8 <net_pkt_get_data>
4001db98:	00050913          	mv	s2,a0
	if (!pfx_info) {
4001db9c:	ae050ce3          	beqz	a0,4001d694 <handle_ra_input+0xcc>
	net_pkt_acknowledge_data(pkt, &rapfx_access);
4001dba0:	f8c42583          	lw	a1,-116(s0)
4001dba4:	00048513          	mv	a0,s1
4001dba8:	ab1fe0ef          	jal	ra,4001c658 <net_pkt_acknowledge_data.isra.0>
	valid_lifetime = ntohl(pfx_info->valid_lifetime);
4001dbac:	00394703          	lbu	a4,3(s2)
4001dbb0:	00294783          	lbu	a5,2(s2)
4001dbb4:	00594983          	lbu	s3,5(s2)
4001dbb8:	00871713          	slli	a4,a4,0x8
4001dbbc:	00f76733          	or	a4,a4,a5
4001dbc0:	00494783          	lbu	a5,4(s2)
4001dbc4:	01899993          	slli	s3,s3,0x18
4001dbc8:	f00b8593          	addi	a1,s7,-256
4001dbcc:	01079793          	slli	a5,a5,0x10
4001dbd0:	00e7e7b3          	or	a5,a5,a4
4001dbd4:	00f9e733          	or	a4,s3,a5
4001dbd8:	01879793          	slli	a5,a5,0x18
4001dbdc:	0189d993          	srli	s3,s3,0x18
4001dbe0:	00f9e9b3          	or	s3,s3,a5
4001dbe4:	00875793          	srli	a5,a4,0x8
4001dbe8:	00b7f7b3          	and	a5,a5,a1
4001dbec:	00ff0637          	lui	a2,0xff0
4001dbf0:	00871713          	slli	a4,a4,0x8
4001dbf4:	00f9e9b3          	or	s3,s3,a5
4001dbf8:	00c77733          	and	a4,a4,a2
	preferred_lifetime = ntohl(pfx_info->preferred_lifetime);
4001dbfc:	00794783          	lbu	a5,7(s2)
	valid_lifetime = ntohl(pfx_info->valid_lifetime);
4001dc00:	00e9e9b3          	or	s3,s3,a4
	preferred_lifetime = ntohl(pfx_info->preferred_lifetime);
4001dc04:	00694703          	lbu	a4,6(s2)
4001dc08:	00879793          	slli	a5,a5,0x8
4001dc0c:	00e7e7b3          	or	a5,a5,a4
4001dc10:	00894703          	lbu	a4,8(s2)
4001dc14:	01071713          	slli	a4,a4,0x10
4001dc18:	00f76733          	or	a4,a4,a5
4001dc1c:	00994783          	lbu	a5,9(s2)
4001dc20:	01879793          	slli	a5,a5,0x18
4001dc24:	00e7e6b3          	or	a3,a5,a4
4001dc28:	01871713          	slli	a4,a4,0x18
4001dc2c:	0187d793          	srli	a5,a5,0x18
4001dc30:	00e7e7b3          	or	a5,a5,a4
4001dc34:	0086d713          	srli	a4,a3,0x8
4001dc38:	00b77733          	and	a4,a4,a1
4001dc3c:	00869693          	slli	a3,a3,0x8
4001dc40:	00e7e7b3          	or	a5,a5,a4
4001dc44:	00c6f6b3          	and	a3,a3,a2
4001dc48:	00d7e7b3          	or	a5,a5,a3
	if (valid_lifetime >= preferred_lifetime &&
4001dc4c:	e0f9e8e3          	bltu	s3,a5,4001da5c <handle_ra_input+0x494>
4001dc50:	00f94783          	lbu	a5,15(s2)
4001dc54:	00e94703          	lbu	a4,14(s2)
4001dc58:	00879793          	slli	a5,a5,0x8
4001dc5c:	00e7e7b3          	or	a5,a5,a4
4001dc60:	00008737          	lui	a4,0x8
4001dc64:	0fe70713          	addi	a4,a4,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
4001dc68:	dee78ae3          	beq	a5,a4,4001da5c <handle_ra_input+0x494>
		if (pfx_info->flags & NET_ICMPV6_RA_FLAG_ONLINK) {
4001dc6c:	00190783          	lb	a5,1(s2)
4001dc70:	0e07da63          	bgez	a5,4001dd64 <handle_ra_input+0x79c>
	prefix = net_if_ipv6_prefix_lookup(net_pkt_iface(pkt),
4001dc74:	00094603          	lbu	a2,0(s2)
4001dc78:	0184a503          	lw	a0,24(s1)
					   (struct in6_addr *)prefix_info->prefix,
4001dc7c:	00e90593          	addi	a1,s2,14
	prefix = net_if_ipv6_prefix_lookup(net_pkt_iface(pkt),
4001dc80:	f4b42e23          	sw	a1,-164(s0)
4001dc84:	a69f40ef          	jal	ra,400126ec <net_if_ipv6_prefix_lookup>
	if (!prefix) {
4001dc88:	f5c42583          	lw	a1,-164(s0)
4001dc8c:	1c051a63          	bnez	a0,4001de60 <handle_ra_input+0x898>
		if (!prefix_info->valid_lifetime) {
4001dc90:	00394703          	lbu	a4,3(s2)
4001dc94:	00294783          	lbu	a5,2(s2)
4001dc98:	00594683          	lbu	a3,5(s2)
4001dc9c:	00871713          	slli	a4,a4,0x8
4001dca0:	00f76733          	or	a4,a4,a5
4001dca4:	00494783          	lbu	a5,4(s2)
4001dca8:	01869693          	slli	a3,a3,0x18
4001dcac:	01079793          	slli	a5,a5,0x10
4001dcb0:	00e7e7b3          	or	a5,a5,a4
4001dcb4:	00f6e6b3          	or	a3,a3,a5
4001dcb8:	0a068663          	beqz	a3,4001dd64 <handle_ra_input+0x79c>
		prefix = net_if_ipv6_prefix_add(net_pkt_iface(pkt),
4001dcbc:	00094603          	lbu	a2,0(s2)
4001dcc0:	0184a503          	lw	a0,24(s1)
4001dcc4:	fb0f40ef          	jal	ra,40012474 <net_if_ipv6_prefix_add>
		if (prefix) {
4001dcc8:	f5c42583          	lw	a1,-164(s0)
4001dccc:	18051a63          	bnez	a0,4001de60 <handle_ra_input+0x898>
			NET_ERR("Prefix %s/%d could not be added to "
4001dcd0:	40044db7          	lui	s11,0x40044
4001dcd4:	77cda783          	lw	a5,1916(s11) # 4004477c <log_dynamic_net_ipv6>
4001dcd8:	0077f793          	andi	a5,a5,7
4001dcdc:	08078463          	beqz	a5,4001dd64 <handle_ra_input+0x79c>
4001dce0:	00200513          	li	a0,2
4001dce4:	bd1f60ef          	jal	ra,400148b4 <net_sprint_addr>
4001dce8:	0184a583          	lw	a1,24(s1)
4001dcec:	00094803          	lbu	a6,0(s2)
4001dcf0:	f4a42823          	sw	a0,-176(s0)
4001dcf4:	00058513          	mv	a0,a1
4001dcf8:	f5042a23          	sw	a6,-172(s0)
4001dcfc:	f4b42c23          	sw	a1,-168(s0)
4001dd00:	e61f50ef          	jal	ra,40013b60 <net_if_get_by_iface>
4001dd04:	f4242e23          	sw	sp,-164(s0)
4001dd08:	fd010113          	addi	sp,sp,-48
4001dd0c:	00010613          	mv	a2,sp
4001dd10:	f5042783          	lw	a5,-176(s0)
4001dd14:	f5842583          	lw	a1,-168(s0)
4001dd18:	f5442803          	lw	a6,-172(s0)
4001dd1c:	00f62c23          	sw	a5,24(a2) # ff0018 <__rom_region_size+0xfb705c>
4001dd20:	20000793          	li	a5,512
4001dd24:	02f61423          	sh	a5,40(a2)
4001dd28:	40035737          	lui	a4,0x40035
4001dd2c:	010007b7          	lui	a5,0x1000
4001dd30:	02b62023          	sw	a1,32(a2)
4001dd34:	0b870713          	addi	a4,a4,184 # 400350b8 <all_nodes_mcast_group.0+0x11c>
4001dd38:	00678793          	addi	a5,a5,6 # 1000006 <__rom_region_size+0xfc704a>
4001dd3c:	000035b7          	lui	a1,0x3
4001dd40:	02a62223          	sw	a0,36(a2)
4001dd44:	00e62a23          	sw	a4,20(a2)
4001dd48:	01062e23          	sw	a6,28(a2)
4001dd4c:	00f62823          	sw	a5,16(a2)
4001dd50:	44058593          	addi	a1,a1,1088 # 3440 <CONFIG_SRAM_SIZE+0x1440>
4001dd54:	01060613          	addi	a2,a2,16
4001dd58:	77cd8513          	addi	a0,s11,1916
4001dd5c:	865fe0ef          	jal	ra,4001c5c0 <z_log_msg_static_create.constprop.0>
4001dd60:	f5c42103          	lw	sp,-164(s0)
		if ((pfx_info->flags & NET_ICMPV6_RA_FLAG_AUTONOMOUS) &&
4001dd64:	00194783          	lbu	a5,1(s2)
4001dd68:	0407f793          	andi	a5,a5,64
4001dd6c:	ce0788e3          	beqz	a5,4001da5c <handle_ra_input+0x494>
4001dd70:	ce0986e3          	beqz	s3,4001da5c <handle_ra_input+0x494>
		    valid_lifetime &&
4001dd74:	00094703          	lbu	a4,0(s2)
4001dd78:	04000793          	li	a5,64
4001dd7c:	cef710e3          	bne	a4,a5,4001da5c <handle_ra_input+0x494>
	return &iface->if_dev->link_addr;
4001dd80:	0184a783          	lw	a5,24(s1)
	struct in6_addr addr = { };
4001dd84:	f8042823          	sw	zero,-112(s0)
4001dd88:	f8042a23          	sw	zero,-108(s0)
4001dd8c:	f8042c23          	sw	zero,-104(s0)
4001dd90:	f8042e23          	sw	zero,-100(s0)
4001dd94:	0007a983          	lw	s3,0(a5)
	UNALIGNED_PUT(htonl(0xfe800000), &addr->s6_addr32[0]);
4001dd98:	000087b7          	lui	a5,0x8
4001dd9c:	0fe78793          	addi	a5,a5,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
4001dda0:	f8f42823          	sw	a5,-112(s0)
	switch (lladdr->len) {
4001dda4:	0149c783          	lbu	a5,20(s3)
4001dda8:	00600713          	li	a4,6
4001ddac:	14e78263          	beq	a5,a4,4001def0 <handle_ra_input+0x928>
4001ddb0:	00800713          	li	a4,8
4001ddb4:	18e78663          	beq	a5,a4,4001df40 <handle_ra_input+0x978>
4001ddb8:	00200713          	li	a4,2
4001ddbc:	02e79a63          	bne	a5,a4,4001ddf0 <handle_ra_input+0x828>
		if (lladdr->type == NET_LINK_IEEE802154) {
4001ddc0:	0159c703          	lbu	a4,21(s3)
4001ddc4:	00100793          	li	a5,1
4001ddc8:	02f71463          	bne	a4,a5,4001ddf0 <handle_ra_input+0x828>
			addr->s6_addr[11] = 0xff;
4001ddcc:	fff00793          	li	a5,-1
4001ddd0:	f8f40da3          	sb	a5,-101(s0)
			addr->s6_addr[12] = 0xfe;
4001ddd4:	ffe00793          	li	a5,-2
4001ddd8:	f8f40e23          	sb	a5,-100(s0)
			addr->s6_addr[14] = lladdr->addr[0];
4001dddc:	0109a783          	lw	a5,16(s3)
4001dde0:	0007c703          	lbu	a4,0(a5)
4001dde4:	f8e40f23          	sb	a4,-98(s0)
			addr->s6_addr[15] = lladdr->addr[1];
4001dde8:	0017c783          	lbu	a5,1(a5)
4001ddec:	f8f40fa3          	sb	a5,-97(s0)
	memcpy(&addr, prefix_info->prefix, sizeof(prefix_info->prefix) / 2);
4001ddf0:	00800613          	li	a2,8
4001ddf4:	00e90593          	addi	a1,s2,14
4001ddf8:	f9040513          	addi	a0,s0,-112
4001ddfc:	efdee0ef          	jal	ra,4000ccf8 <memcpy>
	ifaddr = net_if_ipv6_addr_lookup(&addr, NULL);
4001de00:	00000593          	li	a1,0
4001de04:	f9040513          	addi	a0,s0,-112
4001de08:	aa8f30ef          	jal	ra,400110b0 <net_if_ipv6_addr_lookup>
4001de0c:	00394703          	lbu	a4,3(s2)
4001de10:	00294603          	lbu	a2,2(s2)
4001de14:	00494783          	lbu	a5,4(s2)
4001de18:	00594683          	lbu	a3,5(s2)
		if (prefix_info->valid_lifetime ==
4001de1c:	00871713          	slli	a4,a4,0x8
4001de20:	00c76733          	or	a4,a4,a2
4001de24:	01079793          	slli	a5,a5,0x10
	ifaddr = net_if_ipv6_addr_lookup(&addr, NULL);
4001de28:	00050d93          	mv	s11,a0
		if (prefix_info->valid_lifetime ==
4001de2c:	00e7e7b3          	or	a5,a5,a4
4001de30:	01869693          	slli	a3,a3,0x18
	if (ifaddr && ifaddr->addr_type == NET_ADDR_AUTOCONF) {
4001de34:	18050663          	beqz	a0,4001dfc0 <handle_ra_input+0x9f8>
4001de38:	02c54503          	lbu	a0,44(a0)
4001de3c:	00100593          	li	a1,1
4001de40:	18b51063          	bne	a0,a1,4001dfc0 <handle_ra_input+0x9f8>
		if (prefix_info->valid_lifetime ==
4001de44:	00f6e9b3          	or	s3,a3,a5
4001de48:	fff00793          	li	a5,-1
4001de4c:	10f99463          	bne	s3,a5,4001df54 <handle_ra_input+0x98c>
	ifaddr->is_infinite = is_infinite;
4001de50:	02fdc783          	lbu	a5,47(s11)
4001de54:	0017e793          	ori	a5,a5,1
4001de58:	02fd87a3          	sb	a5,47(s11)
}
4001de5c:	c01ff06f          	j	4001da5c <handle_ra_input+0x494>
	switch (prefix_info->valid_lifetime) {
4001de60:	00394703          	lbu	a4,3(s2)
4001de64:	00294783          	lbu	a5,2(s2)
4001de68:	00871713          	slli	a4,a4,0x8
4001de6c:	00f76733          	or	a4,a4,a5
4001de70:	00494783          	lbu	a5,4(s2)
4001de74:	01079793          	slli	a5,a5,0x10
4001de78:	00e7e7b3          	or	a5,a5,a4
4001de7c:	00594703          	lbu	a4,5(s2)
4001de80:	01871713          	slli	a4,a4,0x18
4001de84:	00f76733          	or	a4,a4,a5
4001de88:	04070463          	beqz	a4,4001ded0 <handle_ra_input+0x908>
4001de8c:	fff00693          	li	a3,-1
4001de90:	02554783          	lbu	a5,37(a0)
4001de94:	04d70863          	beq	a4,a3,4001dee4 <handle_ra_input+0x91c>
	prefix->is_infinite = is_infinite;
4001de98:	ffe7f793          	andi	a5,a5,-2
4001de9c:	02f502a3          	sb	a5,37(a0)
		net_if_ipv6_prefix_set_timer(prefix,
4001dea0:	00394703          	lbu	a4,3(s2)
4001dea4:	00294783          	lbu	a5,2(s2)
4001dea8:	00594583          	lbu	a1,5(s2)
4001deac:	00871713          	slli	a4,a4,0x8
4001deb0:	00f76733          	or	a4,a4,a5
4001deb4:	00494783          	lbu	a5,4(s2)
4001deb8:	01859593          	slli	a1,a1,0x18
4001debc:	01079793          	slli	a5,a5,0x10
4001dec0:	00e7e7b3          	or	a5,a5,a4
4001dec4:	00f5e5b3          	or	a1,a1,a5
4001dec8:	9e9f40ef          	jal	ra,400128b0 <net_if_ipv6_prefix_set_timer>
		break;
4001decc:	e99ff06f          	j	4001dd64 <handle_ra_input+0x79c>
		net_if_ipv6_prefix_rm(net_pkt_iface(pkt),
4001ded0:	02454603          	lbu	a2,36(a0)
4001ded4:	01050593          	addi	a1,a0,16
4001ded8:	0184a503          	lw	a0,24(s1)
4001dedc:	ac1f40ef          	jal	ra,4001299c <net_if_ipv6_prefix_rm>
		break;
4001dee0:	e85ff06f          	j	4001dd64 <handle_ra_input+0x79c>
4001dee4:	0017e793          	ori	a5,a5,1
4001dee8:	02f502a3          	sb	a5,37(a0)
}
4001deec:	e79ff06f          	j	4001dd64 <handle_ra_input+0x79c>
		memcpy(&addr->s6_addr[8], lladdr->addr, 3);
4001def0:	0109a583          	lw	a1,16(s3)
4001def4:	00300613          	li	a2,3
4001def8:	f9840513          	addi	a0,s0,-104
4001defc:	dfdee0ef          	jal	ra,4000ccf8 <memcpy>
		addr->s6_addr[11] = 0xff;
4001df00:	fff00793          	li	a5,-1
4001df04:	f8f40da3          	sb	a5,-101(s0)
		addr->s6_addr[12] = 0xfe;
4001df08:	ffe00793          	li	a5,-2
4001df0c:	f8f40e23          	sb	a5,-100(s0)
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
4001df10:	0109a583          	lw	a1,16(s3)
4001df14:	00300613          	li	a2,3
4001df18:	f9d40513          	addi	a0,s0,-99
4001df1c:	00358593          	addi	a1,a1,3
4001df20:	dd9ee0ef          	jal	ra,4000ccf8 <memcpy>
		if (lladdr->type == NET_LINK_ETHERNET) {
4001df24:	0159c703          	lbu	a4,21(s3)
4001df28:	00300793          	li	a5,3
4001df2c:	ecf712e3          	bne	a4,a5,4001ddf0 <handle_ra_input+0x828>
		addr->s6_addr[8] ^= 0x02;
4001df30:	f9844783          	lbu	a5,-104(s0)
4001df34:	0027c793          	xori	a5,a5,2
4001df38:	f8f40c23          	sb	a5,-104(s0)
		break;
4001df3c:	eb5ff06f          	j	4001ddf0 <handle_ra_input+0x828>
		memcpy(&addr->s6_addr[8], lladdr->addr, lladdr->len);
4001df40:	0109a583          	lw	a1,16(s3)
4001df44:	00800613          	li	a2,8
4001df48:	f9840513          	addi	a0,s0,-104
4001df4c:	dadee0ef          	jal	ra,4000ccf8 <memcpy>
4001df50:	fe1ff06f          	j	4001df30 <handle_ra_input+0x968>
		if ((prefix_info->valid_lifetime > TWO_HOURS) ||
4001df54:	000027b7          	lui	a5,0x2
4001df58:	c2078793          	addi	a5,a5,-992 # 1c20 <CONFIG_HEAP_MEM_POOL_SIZE+0xc20>
4001df5c:	0537f063          	bgeu	a5,s3,4001df9c <handle_ra_input+0x9d4>
			net_if_ipv6_addr_update_lifetime(
4001df60:	00394703          	lbu	a4,3(s2)
4001df64:	00294783          	lbu	a5,2(s2)
4001df68:	00594583          	lbu	a1,5(s2)
4001df6c:	00871713          	slli	a4,a4,0x8
4001df70:	00f76733          	or	a4,a4,a5
4001df74:	00494783          	lbu	a5,4(s2)
4001df78:	01859593          	slli	a1,a1,0x18
4001df7c:	01079793          	slli	a5,a5,0x10
4001df80:	00e7e7b3          	or	a5,a5,a4
4001df84:	00f5e5b3          	or	a1,a1,a5
			net_if_ipv6_addr_update_lifetime(ifaddr, TWO_HOURS);
4001df88:	000d8513          	mv	a0,s11
4001df8c:	c58f30ef          	jal	ra,400113e4 <net_if_ipv6_addr_update_lifetime>
	ifaddr->is_infinite = is_infinite;
4001df90:	02fdc783          	lbu	a5,47(s11)
4001df94:	ffe7f793          	andi	a5,a5,-2
4001df98:	ec1ff06f          	j	4001de58 <handle_ra_input+0x890>
	return (uint32_t)k_uptime_get();
4001df9c:	a30fe0ef          	jal	ra,4001c1cc <k_uptime_get>
4001dfa0:	00050593          	mv	a1,a0
	return net_timeout_remaining(&ifaddr->lifetime, k_uptime_get_32());
4001dfa4:	014d8513          	addi	a0,s11,20
4001dfa8:	b08f60ef          	jal	ra,400142b0 <net_timeout_remaining>
		if ((prefix_info->valid_lifetime > TWO_HOURS) ||
4001dfac:	000027b7          	lui	a5,0x2
4001dfb0:	c2078793          	addi	a5,a5,-992 # 1c20 <CONFIG_HEAP_MEM_POOL_SIZE+0xc20>
4001dfb4:	fb3566e3          	bltu	a0,s3,4001df60 <handle_ra_input+0x998>
			net_if_ipv6_addr_update_lifetime(ifaddr, TWO_HOURS);
4001dfb8:	00078593          	mv	a1,a5
4001dfbc:	fcdff06f          	j	4001df88 <handle_ra_input+0x9c0>
		if (prefix_info->valid_lifetime ==
4001dfc0:	00f6e6b3          	or	a3,a3,a5
4001dfc4:	fff00793          	li	a5,-1
4001dfc8:	0184a503          	lw	a0,24(s1)
4001dfcc:	00f69463          	bne	a3,a5,4001dfd4 <handle_ra_input+0xa0c>
			net_if_ipv6_addr_add(net_pkt_iface(pkt),
4001dfd0:	00000693          	li	a3,0
			net_if_ipv6_addr_add(net_pkt_iface(pkt),
4001dfd4:	00100613          	li	a2,1
4001dfd8:	f9040593          	addi	a1,s0,-112
4001dfdc:	c84f30ef          	jal	ra,40011460 <net_if_ipv6_addr_add>
4001dfe0:	a7dff06f          	j	4001da5c <handle_ra_input+0x494>
			if (nd_opt_hdr->len == 0U || nd_opt_hdr->len > 3U) {
4001dfe4:	fff90993          	addi	s3,s2,-1
4001dfe8:	0ff9f993          	zext.b	s3,s3
4001dfec:	00200793          	li	a5,2
4001dff0:	0337fc63          	bgeu	a5,s3,4001e028 <handle_ra_input+0xa60>
				NET_ERR("DROP: Invalid %s length (%d)",
4001dff4:	40044537          	lui	a0,0x40044
4001dff8:	77c52783          	lw	a5,1916(a0) # 4004477c <log_dynamic_net_ipv6>
4001dffc:	0077f793          	andi	a5,a5,7
4001e000:	e8078a63          	beqz	a5,4001d694 <handle_ra_input+0xcc>
4001e004:	00010993          	mv	s3,sp
4001e008:	fd010113          	addi	sp,sp,-48
4001e00c:	00010613          	mv	a2,sp
4001e010:	400357b7          	lui	a5,0x40035
4001e014:	08c78793          	addi	a5,a5,140 # 4003508c <all_nodes_mcast_group.0+0xf0>
4001e018:	00f62a23          	sw	a5,20(a2)
4001e01c:	400357b7          	lui	a5,0x40035
4001e020:	0e878793          	addi	a5,a5,232 # 400350e8 <all_nodes_mcast_group.0+0x14c>
4001e024:	b21ff06f          	j	4001db44 <handle_ra_input+0x57c>
	NET_PKT_DATA_ACCESS_DEFINE(routeinfo_access,
4001e028:	00600793          	li	a5,6
4001e02c:	f9842823          	sw	s8,-112(s0)
4001e030:	f8f42a23          	sw	a5,-108(s0)
	struct in6_addr prefix_buf = { 0 };
4001e034:	fa042023          	sw	zero,-96(s0)
4001e038:	fa042223          	sw	zero,-92(s0)
4001e03c:	fa042423          	sw	zero,-88(s0)
4001e040:	fa042623          	sw	zero,-84(s0)
				net_pkt_get_data(pkt, &routeinfo_access);
4001e044:	f9040593          	addi	a1,s0,-112
4001e048:	00048513          	mv	a0,s1
4001e04c:	89dfa0ef          	jal	ra,400188e8 <net_pkt_get_data>
4001e050:	00050913          	mv	s2,a0
	if (!route_info) {
4001e054:	e4050063          	beqz	a0,4001d694 <handle_ra_input+0xcc>
	ret = net_pkt_acknowledge_data(pkt, &routeinfo_access);
4001e058:	f9442583          	lw	a1,-108(s0)
4001e05c:	00048513          	mv	a0,s1
4001e060:	df8fe0ef          	jal	ra,4001c658 <net_pkt_acknowledge_data.isra.0>
	if (ret < 0) {
4001e064:	e2054863          	bltz	a0,4001d694 <handle_ra_input+0xcc>
	prefix_len = route_info->prefix_len;
4001e068:	00094783          	lbu	a5,0(s2)
	route_lifetime = ntohl(route_info->route_lifetime);
4001e06c:	00394703          	lbu	a4,3(s2)
	uint8_t prefix_field_len = (len - 1) * 8;
4001e070:	00399613          	slli	a2,s3,0x3
	prefix_len = route_info->prefix_len;
4001e074:	f4f42e23          	sw	a5,-164(s0)
	route_lifetime = ntohl(route_info->route_lifetime);
4001e078:	00294783          	lbu	a5,2(s2)
4001e07c:	00871713          	slli	a4,a4,0x8
4001e080:	00594683          	lbu	a3,5(s2)
4001e084:	00f76733          	or	a4,a4,a5
4001e088:	00494783          	lbu	a5,4(s2)
4001e08c:	01869693          	slli	a3,a3,0x18
	ret = net_pkt_read(pkt, &prefix_buf, prefix_field_len);
4001e090:	0f867613          	andi	a2,a2,248
	route_lifetime = ntohl(route_info->route_lifetime);
4001e094:	01079793          	slli	a5,a5,0x10
4001e098:	00e7e7b3          	or	a5,a5,a4
4001e09c:	00f6edb3          	or	s11,a3,a5
	preference = route_info->flags.prf;
4001e0a0:	00194783          	lbu	a5,1(s2)
	ret = net_pkt_read(pkt, &prefix_buf, prefix_field_len);
4001e0a4:	fa040593          	addi	a1,s0,-96
4001e0a8:	00048513          	mv	a0,s1
	preference = route_info->flags.prf;
4001e0ac:	0037d793          	srli	a5,a5,0x3
4001e0b0:	0037f793          	andi	a5,a5,3
4001e0b4:	f4f42c23          	sw	a5,-168(s0)
	ret = net_pkt_read(pkt, &prefix_buf, prefix_field_len);
4001e0b8:	a80fa0ef          	jal	ra,40018338 <net_pkt_read>
	if (ret < 0) {
4001e0bc:	f5842783          	lw	a5,-168(s0)
4001e0c0:	04055a63          	bgez	a0,4001e114 <handle_ra_input+0xb4c>
		NET_ERR("Error reading prefix, %d", ret);
4001e0c4:	40044737          	lui	a4,0x40044
4001e0c8:	77c72783          	lw	a5,1916(a4) # 4004477c <log_dynamic_net_ipv6>
4001e0cc:	0077f793          	andi	a5,a5,7
4001e0d0:	dc078263          	beqz	a5,4001d694 <handle_ra_input+0xcc>
4001e0d4:	00010913          	mv	s2,sp
4001e0d8:	fe010113          	addi	sp,sp,-32
4001e0dc:	00010613          	mv	a2,sp
4001e0e0:	400357b7          	lui	a5,0x40035
4001e0e4:	0f878793          	addi	a5,a5,248 # 400350f8 <all_nodes_mcast_group.0+0x15c>
4001e0e8:	00f62a23          	sw	a5,20(a2)
4001e0ec:	000025b7          	lui	a1,0x2
4001e0f0:	00300793          	li	a5,3
4001e0f4:	00a62c23          	sw	a0,24(a2)
4001e0f8:	00f62823          	sw	a5,16(a2)
4001e0fc:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
4001e100:	01060613          	addi	a2,a2,16
4001e104:	77c70513          	addi	a0,a4,1916
		NET_ERR("Failed to skip RDNSS address, %d", ret);
4001e108:	cb8fe0ef          	jal	ra,4001c5c0 <z_log_msg_static_create.constprop.0>
4001e10c:	00090113          	mv	sp,s2
4001e110:	d84ff06f          	j	4001d694 <handle_ra_input+0xcc>
	route_lifetime = ntohl(route_info->route_lifetime);
4001e114:	018d9613          	slli	a2,s11,0x18
4001e118:	018dd713          	srli	a4,s11,0x18
4001e11c:	000105b7          	lui	a1,0x10
4001e120:	00c76733          	or	a4,a4,a2
4001e124:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x43f8>
4001e128:	008dd613          	srli	a2,s11,0x8
4001e12c:	00b67633          	and	a2,a2,a1
4001e130:	00c76733          	or	a4,a4,a2
4001e134:	008d9693          	slli	a3,s11,0x8
4001e138:	00ff0637          	lui	a2,0xff0
4001e13c:	00c6f6b3          	and	a3,a3,a2
4001e140:	00d76733          	or	a4,a4,a3
	return pkt->iface;
4001e144:	0184a503          	lw	a0,24(s1)
	if (route_lifetime == 0) {
4001e148:	00071c63          	bnez	a4,4001e160 <handle_ra_input+0xb98>
		route = net_route_lookup(net_pkt_orig_iface(pkt), &prefix_buf);
4001e14c:	fa040593          	addi	a1,s0,-96
4001e150:	510010ef          	jal	ra,4001f660 <net_route_lookup>
		if (route != NULL) {
4001e154:	900504e3          	beqz	a0,4001da5c <handle_ra_input+0x494>
			ret = net_route_del(route);
4001e158:	764010ef          	jal	ra,4001f8bc <net_route_del>
			if (ret < 0) {
4001e15c:	901ff06f          	j	4001da5c <handle_ra_input+0x494>
	return pkt->frags->data;
4001e160:	0084a683          	lw	a3,8(s1)
		route = net_route_add(net_pkt_orig_iface(pkt),
4001e164:	f5c42603          	lw	a2,-164(s0)
4001e168:	fa040593          	addi	a1,s0,-96
				      (struct in6_addr *)NET_IPV6_HDR(pkt)->src,
4001e16c:	00c6a683          	lw	a3,12(a3)
		route = net_route_add(net_pkt_orig_iface(pkt),
4001e170:	00868693          	addi	a3,a3,8
4001e174:	2cd010ef          	jal	ra,4001fc40 <net_route_add>
		if (route == NULL) {
4001e178:	8e5ff06f          	j	4001da5c <handle_ra_input+0x494>
	if (net_pkt_skip(pkt, rdnss_size - NET_IPV6_ADDR_SIZE)) {
4001e17c:	ff090593          	addi	a1,s2,-16
4001e180:	00048513          	mv	a0,s1
4001e184:	f4df90ef          	jal	ra,400180d0 <net_pkt_skip>
4001e188:	02050663          	beqz	a0,4001e1b4 <handle_ra_input+0xbec>
		NET_ERR("Failed to skip RDNSS address, %d", ret);
4001e18c:	40044537          	lui	a0,0x40044
4001e190:	77c52783          	lw	a5,1916(a0) # 4004477c <log_dynamic_net_ipv6>
4001e194:	0077f793          	andi	a5,a5,7
4001e198:	ce078e63          	beqz	a5,4001d694 <handle_ra_input+0xcc>
4001e19c:	00010913          	mv	s2,sp
4001e1a0:	fe010113          	addi	sp,sp,-32
4001e1a4:	00010613          	mv	a2,sp
4001e1a8:	400357b7          	lui	a5,0x40035
4001e1ac:	13878793          	addi	a5,a5,312 # 40035138 <all_nodes_mcast_group.0+0x19c>
4001e1b0:	845ff06f          	j	4001d9f4 <handle_ra_input+0x42c>
	ctx = dns_resolve_get_default();
4001e1b4:	7110d0ef          	jal	ra,4002c0c4 <dns_resolve_get_default>
	ret = dns_resolve_reconfigure(ctx, NULL, dns_servers);
4001e1b8:	f9040613          	addi	a2,s0,-112
4001e1bc:	00000593          	li	a1,0
4001e1c0:	5d50d0ef          	jal	ra,4002bf94 <dns_resolve_reconfigure>
	if (ret < 0) {
4001e1c4:	899ff06f          	j	4001da5c <handle_ra_input+0x494>
			if (nbr) {
4001e1c8:	060a1063          	bnez	s4,4001e228 <handle_ra_input+0xc60>
			net_if_ipv6_router_update_lifetime(
4001e1cc:	00060593          	mv	a1,a2
4001e1d0:	919f40ef          	jal	ra,40012ae8 <net_if_ipv6_router_update_lifetime>
	net_if_stop_rs(net_pkt_iface(pkt));
4001e1d4:	0184a503          	lw	a0,24(s1)
4001e1d8:	e95f20ef          	jal	ra,4001106c <net_if_stop_rs>
	net_pkt_unref(pkt);
4001e1dc:	00048513          	mv	a0,s1
4001e1e0:	e3cf90ef          	jal	ra,4001781c <net_pkt_unref>
	return NET_OK;
4001e1e4:	00000513          	li	a0,0
}
4001e1e8:	f5040113          	addi	sp,s0,-176
4001e1ec:	0ac12083          	lw	ra,172(sp)
4001e1f0:	0a812403          	lw	s0,168(sp)
4001e1f4:	0a412483          	lw	s1,164(sp)
4001e1f8:	0a012903          	lw	s2,160(sp)
4001e1fc:	09c12983          	lw	s3,156(sp)
4001e200:	09812a03          	lw	s4,152(sp)
4001e204:	09412a83          	lw	s5,148(sp)
4001e208:	09012b03          	lw	s6,144(sp)
4001e20c:	08c12b83          	lw	s7,140(sp)
4001e210:	08812c03          	lw	s8,136(sp)
4001e214:	08412c83          	lw	s9,132(sp)
4001e218:	08012d03          	lw	s10,128(sp)
4001e21c:	07c12d83          	lw	s11,124(sp)
4001e220:	0b010113          	addi	sp,sp,176
4001e224:	00008067          	ret
4001e228:	00ca2783          	lw	a5,12(s4)
				net_ipv6_nbr_data(nbr)->is_router = true;
4001e22c:	00100713          	li	a4,1
			net_if_ipv6_router_update_lifetime(
4001e230:	00060593          	mv	a1,a2
				net_ipv6_nbr_data(nbr)->is_router = true;
4001e234:	02e78ba3          	sb	a4,55(a5)
			net_if_ipv6_router_update_lifetime(
4001e238:	8b1f40ef          	jal	ra,40012ae8 <net_if_ipv6_router_update_lifetime>
	if (nbr && net_ipv6_nbr_data(nbr)->pending) {
4001e23c:	00ca2783          	lw	a5,12(s4)
4001e240:	0007a503          	lw	a0,0(a5)
4001e244:	f80508e3          	beqz	a0,4001e1d4 <handle_ra_input+0xc0c>
		if (net_send_data(net_ipv6_nbr_data(nbr)->pending) < 0) {
4001e248:	c64f10ef          	jal	ra,4000f6ac <net_send_data>
4001e24c:	00055863          	bgez	a0,4001e25c <handle_ra_input+0xc94>
			net_pkt_unref(net_ipv6_nbr_data(nbr)->pending);
4001e250:	00ca2783          	lw	a5,12(s4)
4001e254:	0007a503          	lw	a0,0(a5)
4001e258:	dc4f90ef          	jal	ra,4001781c <net_pkt_unref>
		nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
4001e25c:	00ca2503          	lw	a0,12(s4)
4001e260:	ed9fd0ef          	jal	ra,4001c138 <nbr_clear_ns_pending>
4001e264:	f71ff06f          	j	4001e1d4 <handle_ra_input+0xc0c>
		net_if_ipv6_router_add(net_pkt_iface(pkt),
4001e268:	0184a503          	lw	a0,24(s1)
4001e26c:	8b5f40ef          	jal	ra,40012b20 <net_if_ipv6_router_add>
4001e270:	e84ff06f          	j	4001d8f4 <handle_ra_input+0x32c>

4001e274 <handle_ns_input>:
{
4001e274:	f9010113          	addi	sp,sp,-112
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
4001e278:	01400793          	li	a5,20
4001e27c:	00f12623          	sw	a5,12(sp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
4001e280:	00410793          	addi	a5,sp,4
{
4001e284:	06812423          	sw	s0,104(sp)
4001e288:	06912223          	sw	s1,100(sp)
4001e28c:	07212023          	sw	s2,96(sp)
4001e290:	05312e23          	sw	s3,92(sp)
4001e294:	06112623          	sw	ra,108(sp)
4001e298:	05412c23          	sw	s4,88(sp)
4001e29c:	05512a23          	sw	s5,84(sp)
4001e2a0:	05612823          	sw	s6,80(sp)
4001e2a4:	05712623          	sw	s7,76(sp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
4001e2a8:	00f12823          	sw	a5,16(sp)
4001e2ac:	00200793          	li	a5,2
4001e2b0:	00f12a23          	sw	a5,20(sp)
4001e2b4:	00852783          	lw	a5,8(a0)
{
4001e2b8:	00050493          	mv	s1,a0
4001e2bc:	00058413          	mv	s0,a1
4001e2c0:	00060993          	mv	s3,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
4001e2c4:	00012423          	sw	zero,8(sp)
	size_t bytes = 0;
4001e2c8:	00000913          	li	s2,0
	while (buf) {
4001e2cc:	06079a63          	bnez	a5,4001e340 <handle_ns_input+0xcc>
	if (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {
4001e2d0:	0184a503          	lw	a0,24(s1)
4001e2d4:	00b00593          	li	a1,11
	src_lladdr.len = 0;
4001e2d8:	02010223          	sb	zero,36(sp)
	if (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {
4001e2dc:	b3cfe0ef          	jal	ra,4001c618 <net_if_flag_is_set>
4001e2e0:	04051863          	bnez	a0,4001e330 <handle_ns_input+0xbc>
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
4001e2e4:	00810593          	addi	a1,sp,8
4001e2e8:	00048513          	mv	a0,s1
4001e2ec:	dfcfa0ef          	jal	ra,400188e8 <net_pkt_get_data>
4001e2f0:	00050a13          	mv	s4,a0
	if (!ns_hdr) {
4001e2f4:	04051e63          	bnez	a0,4001e350 <handle_ns_input+0xdc>
		NET_ERR("DROP: NULL NS header");
4001e2f8:	40044537          	lui	a0,0x40044
4001e2fc:	77c52783          	lw	a5,1916(a0) # 4004477c <log_dynamic_net_ipv6>
4001e300:	0077f793          	andi	a5,a5,7
4001e304:	02078663          	beqz	a5,4001e330 <handle_ns_input+0xbc>
4001e308:	400357b7          	lui	a5,0x40035
4001e30c:	15c78793          	addi	a5,a5,348 # 4003515c <all_nodes_mcast_group.0+0x1c0>
			NET_ERR("DROP: Corrupted NS message");
4001e310:	000015b7          	lui	a1,0x1
4001e314:	02f12e23          	sw	a5,60(sp)
4001e318:	03810613          	addi	a2,sp,56
4001e31c:	00200793          	li	a5,2
4001e320:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4001e324:	77c50513          	addi	a0,a0,1916
4001e328:	02f12c23          	sw	a5,56(sp)
4001e32c:	a94fe0ef          	jal	ra,4001c5c0 <z_log_msg_static_create.constprop.0>
	net_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));
4001e330:	0184a503          	lw	a0,24(s1)
4001e334:	d6dfd0ef          	jal	ra,4001c0a0 <net_stats_update_ipv6_nd_drop>
	return NET_DROP;
4001e338:	00200513          	li	a0,2
4001e33c:	3180006f          	j	4001e654 <handle_ns_input+0x3e0>
		bytes += buf->len;
4001e340:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
4001e344:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4001e348:	00e90933          	add	s2,s2,a4
		buf = buf->frags;
4001e34c:	f81ff06f          	j	4001e2cc <handle_ns_input+0x58>
4001e350:	4003b7b7          	lui	a5,0x4003b
4001e354:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001e358:	0a47a703          	lw	a4,164(a5)
	return pkt->iface;
4001e35c:	0184a683          	lw	a3,24(s1)
	uint16_t length = net_pkt_get_len(pkt);
4001e360:	01091913          	slli	s2,s2,0x10
4001e364:	00170713          	addi	a4,a4,1
4001e368:	0ae7a223          	sw	a4,164(a5)
4001e36c:	0a86a783          	lw	a5,168(a3)
4001e370:	01095913          	srli	s2,s2,0x10
4001e374:	00178793          	addi	a5,a5,1
4001e378:	0af6a423          	sw	a5,168(a3)
	if (((length < (sizeof(struct net_ipv6_hdr) +
4001e37c:	03f00793          	li	a5,63
4001e380:	0127f863          	bgeu	a5,s2,4001e390 <handle_ns_input+0x11c>
			  sizeof(struct net_icmpv6_ns_hdr))) ||
4001e384:	00744703          	lbu	a4,7(s0)
4001e388:	0ff00793          	li	a5,255
4001e38c:	00f70c63          	beq	a4,a5,4001e3a4 <handle_ns_input+0x130>
	    (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT)) &&
4001e390:	004a4703          	lbu	a4,4(s4)
4001e394:	0ff00793          	li	a5,255
4001e398:	00f71663          	bne	a4,a5,4001e3a4 <handle_ns_input+0x130>
	    (net_ipv6_is_addr_mcast((struct in6_addr *)ns_hdr->tgt) &&
4001e39c:	0019c783          	lbu	a5,1(s3)
4001e3a0:	f80798e3          	bnez	a5,4001e330 <handle_ns_input+0xbc>
	net_pkt_acknowledge_data(pkt, &ns_access);
4001e3a4:	00c12583          	lw	a1,12(sp)
4001e3a8:	00048513          	mv	a0,s1
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
4001e3ac:	fd490913          	addi	s2,s2,-44
	net_pkt_acknowledge_data(pkt, &ns_access);
4001e3b0:	aa8fe0ef          	jal	ra,4001c658 <net_pkt_acknowledge_data.isra.0>
	pkt->ipv6_ext_opt_len = len;
4001e3b4:	01400793          	li	a5,20
4001e3b8:	02f48f23          	sb	a5,62(s1)
				net_pkt_get_data(pkt, &nd_access);
4001e3bc:	01010593          	addi	a1,sp,16
4001e3c0:	00048513          	mv	a0,s1
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
4001e3c4:	01091913          	slli	s2,s2,0x10
				net_pkt_get_data(pkt, &nd_access);
4001e3c8:	d20fa0ef          	jal	ra,400188e8 <net_pkt_get_data>
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
4001e3cc:	01095913          	srli	s2,s2,0x10
				net_pkt_get_data(pkt, &nd_access);
4001e3d0:	00050993          	mv	s3,a0
		switch (nd_opt_hdr->type) {
4001e3d4:	00100a93          	li	s5,1
					(struct in6_addr *)ip_hdr->src)) {
4001e3d8:	00840b13          	addi	s6,s0,8
			src_lladdr.addr = src_lladdr_s.addr;
4001e3dc:	01a10b93          	addi	s7,sp,26
	while (nd_opt_hdr && nd_opt_hdr->len > 0 &&
4001e3e0:	00098a63          	beqz	s3,4001e3f4 <handle_ns_input+0x180>
4001e3e4:	0019c783          	lbu	a5,1(s3)
4001e3e8:	00078663          	beqz	a5,4001e3f4 <handle_ns_input+0x180>
4001e3ec:	03e4c783          	lbu	a5,62(s1)
4001e3f0:	0f27ee63          	bltu	a5,s2,4001e4ec <handle_ns_input+0x278>
		ifaddr = net_if_ipv6_addr_lookup_by_iface(
4001e3f4:	0184a503          	lw	a0,24(s1)
			    net_pkt_iface(pkt), (struct in6_addr *)ns_hdr->tgt);
4001e3f8:	004a0a13          	addi	s4,s4,4
		ifaddr = net_if_ipv6_addr_lookup_by_iface(
4001e3fc:	000a0593          	mv	a1,s4
4001e400:	f15f20ef          	jal	ra,40011314 <net_if_ipv6_addr_lookup_by_iface>
4001e404:	00050a93          	mv	s5,a0
	if (!ifaddr) {
4001e408:	f20504e3          	beqz	a0,4001e330 <handle_ns_input+0xbc>
	if (net_ipv6_is_addr_unspecified((struct in6_addr *)ip_hdr->src)) {
4001e40c:	00840993          	addi	s3,s0,8
		tgt = &ifaddr->address.in6_addr;
4001e410:	00450913          	addi	s2,a0,4
	if (net_ipv6_is_addr_unspecified((struct in6_addr *)ip_hdr->src)) {
4001e414:	00098513          	mv	a0,s3
		na_src = (struct in6_addr *)ip_hdr->dst;
4001e418:	01840b13          	addi	s6,s0,24
	if (net_ipv6_is_addr_unspecified((struct in6_addr *)ip_hdr->src)) {
4001e41c:	bc1fd0ef          	jal	ra,4001bfdc <net_ipv6_is_addr_unspecified>
4001e420:	26050063          	beqz	a0,4001e680 <handle_ns_input+0x40c>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
4001e424:	01944783          	lbu	a5,25(s0)
4001e428:	01844703          	lbu	a4,24(s0)
4001e42c:	00879793          	slli	a5,a5,0x8
4001e430:	00e7e7b3          	or	a5,a5,a4
4001e434:	01a44703          	lbu	a4,26(s0)
4001e438:	01071713          	slli	a4,a4,0x10
4001e43c:	00f76733          	or	a4,a4,a5
4001e440:	01b44783          	lbu	a5,27(s0)
4001e444:	01879793          	slli	a5,a5,0x18
4001e448:	00e7e7b3          	or	a5,a5,a4
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
4001e44c:	2ff00713          	li	a4,767
4001e450:	eee790e3          	bne	a5,a4,4001e330 <handle_ns_input+0xbc>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
4001e454:	01d44783          	lbu	a5,29(s0)
4001e458:	01c44703          	lbu	a4,28(s0)
4001e45c:	00879793          	slli	a5,a5,0x8
4001e460:	00e7e7b3          	or	a5,a5,a4
4001e464:	01e44703          	lbu	a4,30(s0)
4001e468:	01071713          	slli	a4,a4,0x10
4001e46c:	00f76733          	or	a4,a4,a5
4001e470:	01f44783          	lbu	a5,31(s0)
4001e474:	01879793          	slli	a5,a5,0x18
4001e478:	00e7e7b3          	or	a5,a5,a4
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
4001e47c:	ea079ae3          	bnez	a5,4001e330 <handle_ns_input+0xbc>
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
4001e480:	02144783          	lbu	a5,33(s0)
4001e484:	02044703          	lbu	a4,32(s0)
4001e488:	00879793          	slli	a5,a5,0x8
4001e48c:	00e7e7b3          	or	a5,a5,a4
4001e490:	02244703          	lbu	a4,34(s0)
4001e494:	01071713          	slli	a4,a4,0x10
4001e498:	00f76733          	or	a4,a4,a5
4001e49c:	02344783          	lbu	a5,35(s0)
4001e4a0:	01879793          	slli	a5,a5,0x18
4001e4a4:	00e7e7b3          	or	a5,a5,a4
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
4001e4a8:	01000737          	lui	a4,0x1000
4001e4ac:	e8e792e3          	bne	a5,a4,4001e330 <handle_ns_input+0xbc>
		((UNALIGNED_GET(&addr->s6_addr32[3]) & htonl(0xff000000)) ==
4001e4b0:	02444703          	lbu	a4,36(s0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
4001e4b4:	0ff00793          	li	a5,255
4001e4b8:	e6f71ce3          	bne	a4,a5,4001e330 <handle_ns_input+0xbc>
		if (ifaddr->addr_state == NET_ADDR_TENTATIVE) {
4001e4bc:	02da8783          	lb	a5,45(s5)
4001e4c0:	0e079063          	bnez	a5,4001e5a0 <handle_ns_input+0x32c>
	return UNALIGNED_GET(&addr->s6_addr16[0]) == htons(0xFE80);
4001e4c4:	005ac783          	lbu	a5,5(s5)
4001e4c8:	004ac703          	lbu	a4,4(s5)
	return pkt->iface;
4001e4cc:	0184a503          	lw	a0,24(s1)
4001e4d0:	00879793          	slli	a5,a5,0x8
	if (net_ipv6_is_ll_addr(addr)) {
4001e4d4:	00e7e7b3          	or	a5,a5,a4
4001e4d8:	00008737          	lui	a4,0x8
4001e4dc:	0fe70713          	addi	a4,a4,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
4001e4e0:	0ae79a63          	bne	a5,a4,4001e594 <handle_ns_input+0x320>
4001e4e4:	8e4fe0ef          	jal	ra,4001c5c8 <dad_failed.part.0.isra.0>
4001e4e8:	e49ff06f          	j	4001e330 <handle_ns_input+0xbc>
		net_pkt_acknowledge_data(pkt, &nd_access);
4001e4ec:	01412583          	lw	a1,20(sp)
4001e4f0:	00048513          	mv	a0,s1
4001e4f4:	964fe0ef          	jal	ra,4001c658 <net_pkt_acknowledge_data.isra.0>
		switch (nd_opt_hdr->type) {
4001e4f8:	0009c783          	lbu	a5,0(s3)
4001e4fc:	05579663          	bne	a5,s5,4001e548 <handle_ns_input+0x2d4>
			if (net_ipv6_is_addr_unspecified(
4001e500:	000b0513          	mv	a0,s6
4001e504:	ad9fd0ef          	jal	ra,4001bfdc <net_ipv6_is_addr_unspecified>
4001e508:	e20514e3          	bnez	a0,4001e330 <handle_ns_input+0xbc>
			if (!read_llao(pkt, nd_opt_hdr->len, &src_lladdr_s)) {
4001e50c:	0019c583          	lbu	a1,1(s3)
4001e510:	01810613          	addi	a2,sp,24
4001e514:	00048513          	mv	a0,s1
4001e518:	e95fd0ef          	jal	ra,4001c3ac <read_llao>
4001e51c:	02051063          	bnez	a0,4001e53c <handle_ns_input+0x2c8>
				NET_ERR("DROP: failed to read LLAO");
4001e520:	40044537          	lui	a0,0x40044
4001e524:	77c52783          	lw	a5,1916(a0) # 4004477c <log_dynamic_net_ipv6>
4001e528:	0077f793          	andi	a5,a5,7
4001e52c:	e00782e3          	beqz	a5,4001e330 <handle_ns_input+0xbc>
4001e530:	400357b7          	lui	a5,0x40035
4001e534:	17478793          	addi	a5,a5,372 # 40035174 <all_nodes_mcast_group.0+0x1d8>
4001e538:	dd9ff06f          	j	4001e310 <handle_ns_input+0x9c>
			src_lladdr.len = src_lladdr_s.len;
4001e53c:	01914783          	lbu	a5,25(sp)
			src_lladdr.addr = src_lladdr_s.addr;
4001e540:	03712023          	sw	s7,32(sp)
			src_lladdr.len = src_lladdr_s.len;
4001e544:	02f10223          	sb	a5,36(sp)
					     (nd_opt_hdr->len << 3));
4001e548:	0019c783          	lbu	a5,1(s3)
	return pkt->ipv6_ext_opt_len;
4001e54c:	03e4c703          	lbu	a4,62(s1)
4001e550:	00379793          	slli	a5,a5,0x3
		net_pkt_set_ipv6_ext_opt_len(pkt,
4001e554:	00f707b3          	add	a5,a4,a5
4001e558:	0ff7f793          	zext.b	a5,a5
	pkt->ipv6_ext_opt_len = len;
4001e55c:	02f48f23          	sb	a5,62(s1)
		if (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {
4001e560:	02f76063          	bltu	a4,a5,4001e580 <handle_ns_input+0x30c>
			NET_ERR("DROP: Corrupted NS message");
4001e564:	40044537          	lui	a0,0x40044
4001e568:	77c52783          	lw	a5,1916(a0) # 4004477c <log_dynamic_net_ipv6>
4001e56c:	0077f793          	andi	a5,a5,7
4001e570:	dc0780e3          	beqz	a5,4001e330 <handle_ns_input+0xbc>
4001e574:	400357b7          	lui	a5,0x40035
4001e578:	19078793          	addi	a5,a5,400 # 40035190 <all_nodes_mcast_group.0+0x1f4>
4001e57c:	d95ff06f          	j	4001e310 <handle_ns_input+0x9c>
					net_pkt_get_data(pkt, &nd_access);
4001e580:	01010593          	addi	a1,sp,16
4001e584:	00048513          	mv	a0,s1
4001e588:	b60fa0ef          	jal	ra,400188e8 <net_pkt_get_data>
4001e58c:	00050993          	mv	s3,a0
4001e590:	e51ff06f          	j	4001e3e0 <handle_ns_input+0x16c>
	net_if_ipv6_dad_failed(iface, addr);
4001e594:	00090593          	mv	a1,s2
4001e598:	8e5f30ef          	jal	ra,40011e7c <net_if_ipv6_dad_failed>
	return true;
4001e59c:	d95ff06f          	j	4001e330 <handle_ns_input+0xbc>
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
4001e5a0:	fff00793          	li	a5,-1
4001e5a4:	00f40c23          	sb	a5,24(s0)
4001e5a8:	00200793          	li	a5,2
4001e5ac:	00f40ca3          	sb	a5,25(s0)
	UNALIGNED_PUT(htons(addr7), &addr->s6_addr16[7]);
4001e5b0:	00100793          	li	a5,1
4001e5b4:	02f403a3          	sb	a5,39(s0)
	UNALIGNED_PUT(htons(addr1), &addr->s6_addr16[1]);
4001e5b8:	00040d23          	sb	zero,26(s0)
4001e5bc:	00040da3          	sb	zero,27(s0)
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
4001e5c0:	00040e23          	sb	zero,28(s0)
4001e5c4:	00040ea3          	sb	zero,29(s0)
	UNALIGNED_PUT(htons(addr3), &addr->s6_addr16[3]);
4001e5c8:	00040f23          	sb	zero,30(s0)
4001e5cc:	00040fa3          	sb	zero,31(s0)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
4001e5d0:	02040023          	sb	zero,32(s0)
4001e5d4:	020400a3          	sb	zero,33(s0)
	UNALIGNED_PUT(htons(addr5), &addr->s6_addr16[5]);
4001e5d8:	02040123          	sb	zero,34(s0)
4001e5dc:	020401a3          	sb	zero,35(s0)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
4001e5e0:	02040223          	sb	zero,36(s0)
4001e5e4:	020402a3          	sb	zero,37(s0)
	UNALIGNED_PUT(htons(addr7), &addr->s6_addr16[7]);
4001e5e8:	02040323          	sb	zero,38(s0)
		net_ipaddr_copy((struct in6_addr *)ip_hdr->src,
4001e5ec:	0184a503          	lw	a0,24(s1)
4001e5f0:	000b0593          	mv	a1,s6
		na_src = (struct in6_addr *)ip_hdr->src;
4001e5f4:	00098a13          	mv	s4,s3
		net_ipaddr_copy((struct in6_addr *)ip_hdr->src,
4001e5f8:	e90f40ef          	jal	ra,40012c88 <net_if_ipv6_select_src_addr>
4001e5fc:	00050593          	mv	a1,a0
4001e600:	01000613          	li	a2,16
4001e604:	02810513          	addi	a0,sp,40
4001e608:	ef0ee0ef          	jal	ra,4000ccf8 <memcpy>
4001e60c:	01000613          	li	a2,16
4001e610:	02810593          	addi	a1,sp,40
4001e614:	00098513          	mv	a0,s3
4001e618:	ee0ee0ef          	jal	ra,4000ccf8 <memcpy>
		flags = NET_ICMPV6_NA_FLAG_OVERRIDE;
4001e61c:	02000413          	li	s0,32
	if (src_lladdr.len) {
4001e620:	02414783          	lbu	a5,36(sp)
	return pkt->iface;
4001e624:	0184a503          	lw	a0,24(s1)
4001e628:	12079063          	bnez	a5,4001e748 <handle_ns_input+0x4d4>
	if (!net_ipv6_send_na(net_pkt_iface(pkt), na_src,
4001e62c:	0184a503          	lw	a0,24(s1)
4001e630:	00040713          	mv	a4,s0
4001e634:	00090693          	mv	a3,s2
4001e638:	000b0613          	mv	a2,s6
4001e63c:	000a0593          	mv	a1,s4
4001e640:	c64fe0ef          	jal	ra,4001caa4 <net_ipv6_send_na>
4001e644:	ce051ae3          	bnez	a0,4001e338 <handle_ns_input+0xc4>
		net_pkt_unref(pkt);
4001e648:	00048513          	mv	a0,s1
4001e64c:	9d0f90ef          	jal	ra,4001781c <net_pkt_unref>
		return NET_OK;
4001e650:	00000513          	li	a0,0
}
4001e654:	06c12083          	lw	ra,108(sp)
4001e658:	06812403          	lw	s0,104(sp)
4001e65c:	06412483          	lw	s1,100(sp)
4001e660:	06012903          	lw	s2,96(sp)
4001e664:	05c12983          	lw	s3,92(sp)
4001e668:	05812a03          	lw	s4,88(sp)
4001e66c:	05412a83          	lw	s5,84(sp)
4001e670:	05012b03          	lw	s6,80(sp)
4001e674:	04c12b83          	lw	s7,76(sp)
4001e678:	07010113          	addi	sp,sp,112
4001e67c:	00008067          	ret
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
4001e680:	00000593          	li	a1,0
4001e684:	00098513          	mv	a0,s3
4001e688:	a29f20ef          	jal	ra,400110b0 <net_if_ipv6_addr_lookup>
	if (net_ipv6_is_my_addr((struct in6_addr *)ip_hdr->src)) {
4001e68c:	ca0512e3          	bnez	a0,4001e330 <handle_ns_input+0xbc>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
4001e690:	01944783          	lbu	a5,25(s0)
4001e694:	01844703          	lbu	a4,24(s0)
4001e698:	00879793          	slli	a5,a5,0x8
4001e69c:	00e7e7b3          	or	a5,a5,a4
4001e6a0:	01a44703          	lbu	a4,26(s0)
4001e6a4:	01071713          	slli	a4,a4,0x10
4001e6a8:	00f76733          	or	a4,a4,a5
4001e6ac:	01b44783          	lbu	a5,27(s0)
4001e6b0:	01879793          	slli	a5,a5,0x18
4001e6b4:	00e7e7b3          	or	a5,a5,a4
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
4001e6b8:	2ff00713          	li	a4,767
4001e6bc:	06e79663          	bne	a5,a4,4001e728 <handle_ns_input+0x4b4>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
4001e6c0:	01d44783          	lbu	a5,29(s0)
4001e6c4:	01c44703          	lbu	a4,28(s0)
4001e6c8:	00879793          	slli	a5,a5,0x8
4001e6cc:	00e7e7b3          	or	a5,a5,a4
4001e6d0:	01e44703          	lbu	a4,30(s0)
4001e6d4:	01071713          	slli	a4,a4,0x10
4001e6d8:	00f76733          	or	a4,a4,a5
4001e6dc:	01f44783          	lbu	a5,31(s0)
4001e6e0:	01879793          	slli	a5,a5,0x18
4001e6e4:	00e7e7b3          	or	a5,a5,a4
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
4001e6e8:	04079063          	bnez	a5,4001e728 <handle_ns_input+0x4b4>
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
4001e6ec:	02144783          	lbu	a5,33(s0)
4001e6f0:	02044703          	lbu	a4,32(s0)
4001e6f4:	00879793          	slli	a5,a5,0x8
4001e6f8:	00e7e7b3          	or	a5,a5,a4
4001e6fc:	02244703          	lbu	a4,34(s0)
4001e700:	01071713          	slli	a4,a4,0x10
4001e704:	00f76733          	or	a4,a4,a5
4001e708:	02344783          	lbu	a5,35(s0)
4001e70c:	01879793          	slli	a5,a5,0x18
4001e710:	00e7e7b3          	or	a5,a5,a4
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
4001e714:	01000737          	lui	a4,0x1000
4001e718:	00e79863          	bne	a5,a4,4001e728 <handle_ns_input+0x4b4>
		((UNALIGNED_GET(&addr->s6_addr32[3]) & htonl(0xff000000)) ==
4001e71c:	02444703          	lbu	a4,36(s0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
4001e720:	0ff00793          	li	a5,255
4001e724:	00f70c63          	beq	a4,a5,4001e73c <handle_ns_input+0x4c8>
		ifaddr = net_if_ipv6_addr_lookup_by_iface(
4001e728:	0184a503          	lw	a0,24(s1)
4001e72c:	000b0593          	mv	a1,s6
4001e730:	be5f20ef          	jal	ra,40011314 <net_if_ipv6_addr_lookup_by_iface>
	if (ifaddr) {
4001e734:	be050ee3          	beqz	a0,4001e330 <handle_ns_input+0xbc>
		tgt = &ifaddr->address.in6_addr;
4001e738:	00450913          	addi	s2,a0,4
		na_dst = (struct in6_addr *)ip_hdr->src;
4001e73c:	00098b13          	mv	s6,s3
		flags = NET_ICMPV6_NA_FLAG_SOLICITED |
4001e740:	06000413          	li	s0,96
4001e744:	eddff06f          	j	4001e620 <handle_ns_input+0x3ac>
		if (!net_ipv6_nbr_add(net_pkt_iface(pkt),
4001e748:	00000713          	li	a4,0
4001e74c:	00000693          	li	a3,0
4001e750:	02010613          	addi	a2,sp,32
4001e754:	00098593          	mv	a1,s3
4001e758:	c89fe0ef          	jal	ra,4001d3e0 <net_ipv6_nbr_add>
4001e75c:	ec0518e3          	bnez	a0,4001e62c <handle_ns_input+0x3b8>
4001e760:	bd1ff06f          	j	4001e330 <handle_ns_input+0xbc>

4001e764 <net_ipv6_start_dad>:
	return net_ipv6_send_ns(iface, NULL, NULL, NULL,
4001e764:	00458713          	addi	a4,a1,4
4001e768:	00100793          	li	a5,1
4001e76c:	00000693          	li	a3,0
4001e770:	00000613          	li	a2,0
4001e774:	00000593          	li	a1,0
4001e778:	975fe06f          	j	4001d0ec <net_ipv6_send_ns>

4001e77c <net_ipv6_prepare_for_send>:
{
4001e77c:	fd010113          	addi	sp,sp,-48
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
4001e780:	02800793          	li	a5,40
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
4001e784:	00810593          	addi	a1,sp,8
{
4001e788:	02812423          	sw	s0,40(sp)
4001e78c:	02112623          	sw	ra,44(sp)
4001e790:	02912223          	sw	s1,36(sp)
4001e794:	03212023          	sw	s2,32(sp)
4001e798:	01312e23          	sw	s3,28(sp)
4001e79c:	00050413          	mv	s0,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
4001e7a0:	00012423          	sw	zero,8(sp)
4001e7a4:	00f12623          	sw	a5,12(sp)
	struct net_if *iface = NULL;
4001e7a8:	00012223          	sw	zero,4(sp)
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
4001e7ac:	93cfa0ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!ip_hdr) {
4001e7b0:	14050063          	beqz	a0,4001e8f0 <net_ipv6_prepare_for_send+0x174>
	if ((net_pkt_lladdr_dst(pkt)->addr &&
4001e7b4:	02c42783          	lw	a5,44(s0)
4001e7b8:	10079663          	bnez	a5,4001e8c4 <net_ipv6_prepare_for_send+0x148>
	      !IS_ENABLED(CONFIG_NET_ROUTING))) ||
4001e7bc:	01854703          	lbu	a4,24(a0)
4001e7c0:	0ff00793          	li	a5,255
4001e7c4:	00050993          	mv	s3,a0
4001e7c8:	0ef70e63          	beq	a4,a5,4001e8c4 <net_ipv6_prepare_for_send+0x148>
	    net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_POINTOPOINT) ||
4001e7cc:	01842503          	lw	a0,24(s0)
4001e7d0:	00100593          	li	a1,1
4001e7d4:	e45fd0ef          	jal	ra,4001c618 <net_if_flag_is_set>
	    net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst) ||
4001e7d8:	0e051663          	bnez	a0,4001e8c4 <net_ipv6_prepare_for_send+0x148>
	    net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {
4001e7dc:	01842503          	lw	a0,24(s0)
4001e7e0:	00b00593          	li	a1,11
4001e7e4:	e35fd0ef          	jal	ra,4001c618 <net_if_flag_is_set>
	    net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_POINTOPOINT) ||
4001e7e8:	0c051e63          	bnez	a0,4001e8c4 <net_ipv6_prepare_for_send+0x148>
	if (net_if_ipv6_addr_onlink(&iface, (struct in6_addr *)ip_hdr->dst)) {
4001e7ec:	01898493          	addi	s1,s3,24
4001e7f0:	00048593          	mv	a1,s1
4001e7f4:	00410513          	addi	a0,sp,4
4001e7f8:	fb5f30ef          	jal	ra,400127ac <net_if_ipv6_addr_onlink>
4001e7fc:	0c050863          	beqz	a0,4001e8cc <net_ipv6_prepare_for_send+0x150>
		net_pkt_set_iface(pkt, iface);
4001e800:	00412783          	lw	a5,4(sp)
	pkt->iface = iface;
4001e804:	00f42c23          	sw	a5,24(s0)
	if (iface) {
4001e808:	00078e63          	beqz	a5,4001e824 <net_ipv6_prepare_for_send+0xa8>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
4001e80c:	0007a703          	lw	a4,0(a5)
4001e810:	01574703          	lbu	a4,21(a4) # 1000015 <__rom_region_size+0xfc7059>
4001e814:	02e404a3          	sb	a4,41(s0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
4001e818:	0007a783          	lw	a5,0(a5)
4001e81c:	0157c783          	lbu	a5,21(a5)
4001e820:	02f408a3          	sb	a5,49(s0)
	if (!iface) {
4001e824:	00412783          	lw	a5,4(sp)
4001e828:	02079c63          	bnez	a5,4001e860 <net_ipv6_prepare_for_send+0xe4>
		if (net_if_ipv6_addr_onlink(&iface, nexthop)) {
4001e82c:	00048593          	mv	a1,s1
4001e830:	00410513          	addi	a0,sp,4
4001e834:	f79f30ef          	jal	ra,400127ac <net_if_ipv6_addr_onlink>
4001e838:	0e050663          	beqz	a0,4001e924 <net_ipv6_prepare_for_send+0x1a8>
			net_pkt_set_iface(pkt, iface);
4001e83c:	00412783          	lw	a5,4(sp)
	pkt->iface = iface;
4001e840:	00f42c23          	sw	a5,24(s0)
	if (iface) {
4001e844:	00078e63          	beqz	a5,4001e860 <net_ipv6_prepare_for_send+0xe4>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
4001e848:	0007a703          	lw	a4,0(a5)
4001e84c:	01574703          	lbu	a4,21(a4)
4001e850:	02e404a3          	sb	a4,41(s0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
4001e854:	0007a783          	lw	a5,0(a5)
4001e858:	0157c783          	lbu	a5,21(a5)
4001e85c:	02f408a3          	sb	a5,49(s0)
	nbr = nbr_lookup(&net_neighbor.table, iface, nexthop);
4001e860:	00412503          	lw	a0,4(sp)
4001e864:	00048593          	mv	a1,s1
4001e868:	cadfd0ef          	jal	ra,4001c514 <nbr_lookup.constprop.0>
4001e86c:	00050913          	mv	s2,a0
	if (nbr && nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
4001e870:	0c050c63          	beqz	a0,4001e948 <net_ipv6_prepare_for_send+0x1cc>
4001e874:	00154503          	lbu	a0,1(a0)
4001e878:	0ff00793          	li	a5,255
4001e87c:	0cf50663          	beq	a0,a5,4001e948 <net_ipv6_prepare_for_send+0x1cc>
		lladdr = net_nbr_get_lladdr(nbr->idx);
4001e880:	c85fc0ef          	jal	ra,4001b504 <net_nbr_get_lladdr>
		net_pkt_lladdr_dst(pkt)->addr = lladdr->addr;
4001e884:	00250793          	addi	a5,a0,2
4001e888:	02f42623          	sw	a5,44(s0)
		net_pkt_lladdr_dst(pkt)->len = lladdr->len;
4001e88c:	00154783          	lbu	a5,1(a0)
4001e890:	02f40823          	sb	a5,48(s0)
		if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_STALE) {
4001e894:	00c92783          	lw	a5,12(s2)
4001e898:	0307a703          	lw	a4,48(a5)
4001e89c:	00200793          	li	a5,2
4001e8a0:	02f71263          	bne	a4,a5,4001e8c4 <net_ipv6_prepare_for_send+0x148>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_DELAY);
4001e8a4:	00300593          	li	a1,3
4001e8a8:	00090513          	mv	a0,s2
4001e8ac:	e19fd0ef          	jal	ra,4001c6c4 <ipv6_nbr_set_state>
			ipv6_nd_restart_reachable_timer(nbr,
4001e8b0:	000015b7          	lui	a1,0x1
4001e8b4:	38858593          	addi	a1,a1,904 # 1388 <CONFIG_HEAP_MEM_POOL_SIZE+0x388>
4001e8b8:	00000613          	li	a2,0
4001e8bc:	00090513          	mv	a0,s2
4001e8c0:	b81fd0ef          	jal	ra,4001c440 <ipv6_nd_restart_reachable_timer>
		return NET_OK;
4001e8c4:	00000513          	li	a0,0
4001e8c8:	02c0006f          	j	4001e8f4 <net_ipv6_prepare_for_send+0x178>
	route = net_route_lookup(iface, dst);
4001e8cc:	00048593          	mv	a1,s1
4001e8d0:	591000ef          	jal	ra,4001f660 <net_route_lookup>
4001e8d4:	00050913          	mv	s2,a0
	if (route) {
4001e8d8:	02050c63          	beqz	a0,4001e910 <net_ipv6_prepare_for_send+0x194>
		nexthop = net_route_get_nexthop(route);
4001e8dc:	294010ef          	jal	ra,4001fb70 <net_route_get_nexthop>
4001e8e0:	00050493          	mv	s1,a0
		if (!nexthop) {
4001e8e4:	f40510e3          	bnez	a0,4001e824 <net_ipv6_prepare_for_send+0xa8>
			net_route_del(route);
4001e8e8:	00090513          	mv	a0,s2
4001e8ec:	7d1000ef          	jal	ra,4001f8bc <net_route_del>
		return NET_DROP;
4001e8f0:	00200513          	li	a0,2
}
4001e8f4:	02c12083          	lw	ra,44(sp)
4001e8f8:	02812403          	lw	s0,40(sp)
4001e8fc:	02412483          	lw	s1,36(sp)
4001e900:	02012903          	lw	s2,32(sp)
4001e904:	01c12983          	lw	s3,28(sp)
4001e908:	03010113          	addi	sp,sp,48
4001e90c:	00008067          	ret
		router = net_if_ipv6_router_find_default(NULL, dst);
4001e910:	00048593          	mv	a1,s1
4001e914:	9ccf40ef          	jal	ra,40012ae0 <net_if_ipv6_router_find_default>
		if (!router) {
4001e918:	f40504e3          	beqz	a0,4001e860 <net_ipv6_prepare_for_send+0xe4>
		nexthop = &router->address.in6_addr;
4001e91c:	00850493          	addi	s1,a0,8
		if (!nexthop) {
4001e920:	f05ff06f          	j	4001e824 <net_ipv6_prepare_for_send+0xa8>
			nbr = net_ipv6_nbr_lookup(NULL, nexthop);
4001e924:	00048593          	mv	a1,s1
4001e928:	978fe0ef          	jal	ra,4001caa0 <net_ipv6_nbr_lookup>
			if (nbr) {
4001e92c:	00050863          	beqz	a0,4001e93c <net_ipv6_prepare_for_send+0x1c0>
				iface = nbr->iface;
4001e930:	00852783          	lw	a5,8(a0)
4001e934:	00f12223          	sw	a5,4(sp)
4001e938:	f09ff06f          	j	4001e840 <net_ipv6_prepare_for_send+0xc4>
				iface = net_pkt_iface(pkt);
4001e93c:	01842783          	lw	a5,24(s0)
4001e940:	00f12223          	sw	a5,4(sp)
4001e944:	f1dff06f          	j	4001e860 <net_ipv6_prepare_for_send+0xe4>
	ret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,
4001e948:	01842503          	lw	a0,24(s0)
4001e94c:	00000793          	li	a5,0
4001e950:	00048713          	mv	a4,s1
4001e954:	00000693          	li	a3,0
4001e958:	00898613          	addi	a2,s3,8
4001e95c:	00040593          	mv	a1,s0
4001e960:	f8cfe0ef          	jal	ra,4001d0ec <net_ipv6_send_ns>
	return NET_CONTINUE;
4001e964:	00100513          	li	a0,1
4001e968:	f8dff06f          	j	4001e8f4 <net_ipv6_prepare_for_send+0x178>

4001e96c <ipv6_nd_reachable_timeout>:
{
4001e96c:	fe010113          	addi	sp,sp,-32
4001e970:	00812c23          	sw	s0,24(sp)
4001e974:	40044437          	lui	s0,0x40044
4001e978:	00912a23          	sw	s1,20(sp)
4001e97c:	01212823          	sw	s2,16(sp)
4001e980:	01312623          	sw	s3,12(sp)
4001e984:	01412423          	sw	s4,8(sp)
4001e988:	01512223          	sw	s5,4(sp)
4001e98c:	00112e23          	sw	ra,28(sp)
4001e990:	09840413          	addi	s0,s0,152 # 40044098 <net_neighbor_pool>
	int64_t current = k_uptime_get();
4001e994:	839fd0ef          	jal	ra,4001c1cc <k_uptime_get>
		switch (data->state) {
4001e998:	400359b7          	lui	s3,0x40035
	int64_t current = k_uptime_get();
4001e99c:	00050493          	mv	s1,a0
4001e9a0:	00058913          	mv	s2,a1
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001e9a4:	2a040a13          	addi	s4,s0,672
		switch (data->state) {
4001e9a8:	00400a93          	li	s5,4
4001e9ac:	1ac98993          	addi	s3,s3,428 # 400351ac <all_nodes_mcast_group.0+0x210>
		if (!nbr || !nbr->ref) {
4001e9b0:	00044783          	lbu	a5,0(s0)
4001e9b4:	0a078e63          	beqz	a5,4001ea70 <ipv6_nd_reachable_timeout+0x104>
4001e9b8:	00c42783          	lw	a5,12(s0)
		if (!data) {
4001e9bc:	0a078a63          	beqz	a5,4001ea70 <ipv6_nd_reachable_timeout+0x104>
		if (!data->reachable) {
4001e9c0:	0187a703          	lw	a4,24(a5)
4001e9c4:	01c7a583          	lw	a1,28(a5)
4001e9c8:	00b766b3          	or	a3,a4,a1
4001e9cc:	0a068263          	beqz	a3,4001ea70 <ipv6_nd_reachable_timeout+0x104>
		remaining = data->reachable + data->reachable_timeout - current;
4001e9d0:	0207a603          	lw	a2,32(a5)
4001e9d4:	00e60733          	add	a4,a2,a4
4001e9d8:	41f65693          	srai	a3,a2,0x1f
4001e9dc:	00b686b3          	add	a3,a3,a1
4001e9e0:	00c73633          	sltu	a2,a4,a2
4001e9e4:	00d60633          	add	a2,a2,a3
4001e9e8:	409705b3          	sub	a1,a4,s1
4001e9ec:	00b73733          	sltu	a4,a4,a1
4001e9f0:	41260633          	sub	a2,a2,s2
4001e9f4:	40e60633          	sub	a2,a2,a4
		if (remaining > 0) {
4001e9f8:	00c04663          	bgtz	a2,4001ea04 <ipv6_nd_reachable_timeout+0x98>
4001e9fc:	00061a63          	bnez	a2,4001ea10 <ipv6_nd_reachable_timeout+0xa4>
4001ea00:	00058863          	beqz	a1,4001ea10 <ipv6_nd_reachable_timeout+0xa4>
			ipv6_nd_restart_reachable_timer(NULL, remaining);
4001ea04:	00000513          	li	a0,0
				ipv6_nd_restart_reachable_timer(nbr,
4001ea08:	a39fd0ef          	jal	ra,4001c440 <ipv6_nd_restart_reachable_timer>
4001ea0c:	0640006f          	j	4001ea70 <ipv6_nd_reachable_timeout+0x104>
		data->reachable = 0;
4001ea10:	00000713          	li	a4,0
4001ea14:	00e7ae23          	sw	a4,28(a5)
		switch (data->state) {
4001ea18:	0307a703          	lw	a4,48(a5)
		data->reachable = 0;
4001ea1c:	00000693          	li	a3,0
4001ea20:	00d7ac23          	sw	a3,24(a5)
		switch (data->state) {
4001ea24:	04eae663          	bltu	s5,a4,4001ea70 <ipv6_nd_reachable_timeout+0x104>
4001ea28:	00271713          	slli	a4,a4,0x2
4001ea2c:	01370733          	add	a4,a4,s3
4001ea30:	00072703          	lw	a4,0(a4)
4001ea34:	00070067          	jr	a4
			if (data->ns_count >= MAX_MULTICAST_SOLICIT) {
4001ea38:	0367c683          	lbu	a3,54(a5)
4001ea3c:	00200613          	li	a2,2
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
4001ea40:	00478713          	addi	a4,a5,4
			if (data->ns_count >= MAX_MULTICAST_SOLICIT) {
4001ea44:	00d67663          	bgeu	a2,a3,4001ea50 <ipv6_nd_reachable_timeout+0xe4>
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
4001ea48:	00070593          	mv	a1,a4
4001ea4c:	0600006f          	j	4001eaac <ipv6_nd_reachable_timeout+0x140>
				data->ns_count++;
4001ea50:	00168693          	addi	a3,a3,1
4001ea54:	02d78b23          	sb	a3,54(a5)
				ret = net_ipv6_send_ns(nbr->iface, NULL, NULL,
4001ea58:	00842503          	lw	a0,8(s0)
4001ea5c:	00000793          	li	a5,0
4001ea60:	00000693          	li	a3,0
4001ea64:	00000613          	li	a2,0
4001ea68:	00000593          	li	a1,0
4001ea6c:	e80fe0ef          	jal	ra,4001d0ec <net_ipv6_send_ns>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001ea70:	05440413          	addi	s0,s0,84
4001ea74:	f3441ee3          	bne	s0,s4,4001e9b0 <ipv6_nd_reachable_timeout+0x44>
}
4001ea78:	01c12083          	lw	ra,28(sp)
4001ea7c:	01812403          	lw	s0,24(sp)
4001ea80:	01412483          	lw	s1,20(sp)
4001ea84:	01012903          	lw	s2,16(sp)
4001ea88:	00c12983          	lw	s3,12(sp)
4001ea8c:	00812a03          	lw	s4,8(sp)
4001ea90:	00412a83          	lw	s5,4(sp)
4001ea94:	02010113          	addi	sp,sp,32
4001ea98:	00008067          	ret
			data->state = NET_IPV6_NBR_STATE_STALE;
4001ea9c:	00200713          	li	a4,2
4001eaa0:	02e7a823          	sw	a4,48(a5)
			NET_DBG("nbr %p moving %s state to STALE (%d)",
4001eaa4:	fcdff06f          	j	4001ea70 <ipv6_nd_reachable_timeout+0x104>
			net_ipv6_nbr_rm(nbr->iface, &data->addr);
4001eaa8:	00478593          	addi	a1,a5,4
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
4001eaac:	00842503          	lw	a0,8(s0)
4001eab0:	e35fd0ef          	jal	ra,4001c8e4 <net_ipv6_nbr_rm>
4001eab4:	fbdff06f          	j	4001ea70 <ipv6_nd_reachable_timeout+0x104>
			data->state = NET_IPV6_NBR_STATE_PROBE;
4001eab8:	00400713          	li	a4,4
4001eabc:	02e7a823          	sw	a4,48(a5)
			data->ns_count = 0U;
4001eac0:	02078b23          	sb	zero,54(a5)
			if (data->ns_count >= MAX_UNICAST_SOLICIT) {
4001eac4:	0367c683          	lbu	a3,54(a5)
4001eac8:	00200613          	li	a2,2
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
4001eacc:	00478713          	addi	a4,a5,4
			if (data->ns_count >= MAX_UNICAST_SOLICIT) {
4001ead0:	f6d66ce3          	bltu	a2,a3,4001ea48 <ipv6_nd_reachable_timeout+0xdc>
				data->ns_count++;
4001ead4:	00168693          	addi	a3,a3,1
4001ead8:	02d78b23          	sb	a3,54(a5)
				ret = net_ipv6_send_ns(nbr->iface, NULL, NULL,
4001eadc:	00842503          	lw	a0,8(s0)
4001eae0:	00000613          	li	a2,0
4001eae4:	00000593          	li	a1,0
4001eae8:	00000793          	li	a5,0
4001eaec:	00000693          	li	a3,0
4001eaf0:	dfcfe0ef          	jal	ra,4001d0ec <net_ipv6_send_ns>
				ipv6_nd_restart_reachable_timer(nbr,
4001eaf4:	3e800593          	li	a1,1000
4001eaf8:	00000613          	li	a2,0
4001eafc:	00040513          	mv	a0,s0
4001eb00:	f09ff06f          	j	4001ea08 <ipv6_nd_reachable_timeout+0x9c>

4001eb04 <net_ipv6_send_rs>:
{
4001eb04:	fd010113          	addi	sp,sp,-48
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
4001eb08:	2ff00793          	li	a5,767
4001eb0c:	00f12023          	sw	a5,0(sp)
	src = net_if_ipv6_select_src_addr(iface, &dst);
4001eb10:	00010593          	mv	a1,sp
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
4001eb14:	020007b7          	lui	a5,0x2000
{
4001eb18:	02112623          	sw	ra,44(sp)
4001eb1c:	02912223          	sw	s1,36(sp)
4001eb20:	03212023          	sw	s2,32(sp)
4001eb24:	01412c23          	sw	s4,24(sp)
4001eb28:	00f12623          	sw	a5,12(sp)
4001eb2c:	02812423          	sw	s0,40(sp)
4001eb30:	01312e23          	sw	s3,28(sp)
4001eb34:	00050493          	mv	s1,a0
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
4001eb38:	00012223          	sw	zero,4(sp)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
4001eb3c:	00012423          	sw	zero,8(sp)
	src = net_if_ipv6_select_src_addr(iface, &dst);
4001eb40:	948f40ef          	jal	ra,40012c88 <net_if_ipv6_select_src_addr>
4001eb44:	00050a13          	mv	s4,a0
	if (!net_ipv6_is_addr_unspecified(src)) {
4001eb48:	c94fd0ef          	jal	ra,4001bfdc <net_ipv6_is_addr_unspecified>
4001eb4c:	00000913          	li	s2,0
4001eb50:	00051a63          	bnez	a0,4001eb64 <net_ipv6_send_rs+0x60>
	uint8_t total_len = net_if_get_link_addr(iface)->len +
4001eb54:	0004a783          	lw	a5,0(s1)
	return ROUND_UP(total_len, 8U);
4001eb58:	0147c903          	lbu	s2,20(a5) # 2000014 <__rom_region_size+0x1fc7058>
4001eb5c:	00990913          	addi	s2,s2,9
4001eb60:	0f897913          	andi	s2,s2,248
	pkt = net_pkt_alloc_with_buffer(iface,
4001eb64:	00490593          	addi	a1,s2,4
4001eb68:	00a00713          	li	a4,10
4001eb6c:	00000793          	li	a5,0
4001eb70:	03a00693          	li	a3,58
4001eb74:	00200613          	li	a2,2
4001eb78:	0fc5f593          	andi	a1,a1,252
4001eb7c:	00048513          	mv	a0,s1
4001eb80:	d08f90ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
4001eb84:	00050413          	mv	s0,a0
		return -ENOMEM;
4001eb88:	ff400993          	li	s3,-12
	if (!pkt) {
4001eb8c:	0e050263          	beqz	a0,4001ec70 <net_ipv6_send_rs+0x16c>
	pkt->ipv6_hop_limit = hop_limit;
4001eb90:	fff00793          	li	a5,-1
4001eb94:	02f50ca3          	sb	a5,57(a0)
	if (net_ipv6_create(pkt, src, &dst) ||
4001eb98:	00010613          	mv	a2,sp
4001eb9c:	000a0593          	mv	a1,s4
4001eba0:	b49fc0ef          	jal	ra,4001b6e8 <net_ipv6_create>
4001eba4:	08051463          	bnez	a0,4001ec2c <net_ipv6_send_rs+0x128>
	    net_icmpv6_create(pkt, NET_ICMPV6_RS, 0) ||
4001eba8:	00000613          	li	a2,0
4001ebac:	08500593          	li	a1,133
4001ebb0:	00040513          	mv	a0,s0
4001ebb4:	e99fb0ef          	jal	ra,4001aa4c <net_icmpv6_create>
	if (net_ipv6_create(pkt, src, &dst) ||
4001ebb8:	06051a63          	bnez	a0,4001ec2c <net_ipv6_send_rs+0x128>
	    net_pkt_memset(pkt, 0, sizeof(struct net_icmpv6_rs_hdr))) {
4001ebbc:	00400613          	li	a2,4
4001ebc0:	00000593          	li	a1,0
4001ebc4:	00040513          	mv	a0,s0
4001ebc8:	f48f90ef          	jal	ra,40018310 <net_pkt_memset>
4001ebcc:	00050993          	mv	s3,a0
	    net_icmpv6_create(pkt, NET_ICMPV6_RS, 0) ||
4001ebd0:	04051e63          	bnez	a0,4001ec2c <net_ipv6_send_rs+0x128>
	if (llao_len > 0) {
4001ebd4:	02091e63          	bnez	s2,4001ec10 <net_ipv6_send_rs+0x10c>
	net_pkt_cursor_init(pkt);
4001ebd8:	00040513          	mv	a0,s0
4001ebdc:	f15f80ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
4001ebe0:	03a00593          	li	a1,58
4001ebe4:	00040513          	mv	a0,s0
4001ebe8:	bf5fc0ef          	jal	ra,4001b7dc <net_ipv6_finalize>
	if (net_send_data(pkt) < 0) {
4001ebec:	00040513          	mv	a0,s0
4001ebf0:	abdf00ef          	jal	ra,4000f6ac <net_send_data>
4001ebf4:	04055063          	bgez	a0,4001ec34 <net_ipv6_send_rs+0x130>
		net_stats_update_ipv6_nd_drop(iface);
4001ebf8:	00048513          	mv	a0,s1
4001ebfc:	ca4fd0ef          	jal	ra,4001c0a0 <net_stats_update_ipv6_nd_drop>
		ret = -EINVAL;
4001ec00:	fea00993          	li	s3,-22
	net_pkt_unref(pkt);
4001ec04:	00040513          	mv	a0,s0
4001ec08:	c15f80ef          	jal	ra,4001781c <net_pkt_unref>
	return ret;
4001ec0c:	0640006f          	j	4001ec70 <net_ipv6_send_rs+0x16c>
	return &iface->if_dev->link_addr;
4001ec10:	0004a583          	lw	a1,0(s1)
		if (!set_llao(pkt, net_if_get_link_addr(iface),
4001ec14:	00100693          	li	a3,1
4001ec18:	00090613          	mv	a2,s2
4001ec1c:	01058593          	addi	a1,a1,16
4001ec20:	00040513          	mv	a0,s0
4001ec24:	efcfd0ef          	jal	ra,4001c320 <set_llao>
4001ec28:	fa0518e3          	bnez	a0,4001ebd8 <net_ipv6_send_rs+0xd4>
	int ret = -ENOBUFS;
4001ec2c:	f9700993          	li	s3,-105
4001ec30:	fd5ff06f          	j	4001ec04 <net_ipv6_send_rs+0x100>
	UPDATE_STAT(iface, stats.icmp.sent++);
4001ec34:	4003b7b7          	lui	a5,0x4003b
4001ec38:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001ec3c:	0487a703          	lw	a4,72(a5)
	return pkt->iface;
4001ec40:	01842683          	lw	a3,24(s0)
4001ec44:	00170713          	addi	a4,a4,1
4001ec48:	04e7a423          	sw	a4,72(a5)
4001ec4c:	04c6a703          	lw	a4,76(a3)
4001ec50:	00170713          	addi	a4,a4,1
4001ec54:	04e6a623          	sw	a4,76(a3)
	UPDATE_STAT(iface, stats.ipv6_nd.sent++);
4001ec58:	0a87a703          	lw	a4,168(a5)
4001ec5c:	00170713          	addi	a4,a4,1
4001ec60:	0ae7a423          	sw	a4,168(a5)
4001ec64:	0ac4a783          	lw	a5,172(s1)
4001ec68:	00178793          	addi	a5,a5,1
4001ec6c:	0af4a623          	sw	a5,172(s1)
}
4001ec70:	02c12083          	lw	ra,44(sp)
4001ec74:	02812403          	lw	s0,40(sp)
4001ec78:	02412483          	lw	s1,36(sp)
4001ec7c:	02012903          	lw	s2,32(sp)
4001ec80:	01812a03          	lw	s4,24(sp)
4001ec84:	00098513          	mv	a0,s3
4001ec88:	01c12983          	lw	s3,28(sp)
4001ec8c:	03010113          	addi	sp,sp,48
4001ec90:	00008067          	ret

4001ec94 <net_ipv6_start_rs>:
	return net_ipv6_send_rs(iface);
4001ec94:	e71ff06f          	j	4001eb04 <net_ipv6_send_rs>

4001ec98 <net_ipv6_nbr_init>:
#endif /* CONFIG_NET_IPV6_ND */

void net_ipv6_nbr_init(void)
{
#if defined(CONFIG_NET_IPV6_NBR_CACHE)
	net_icmpv6_register_handler(&ns_input_handler);
4001ec98:	40044537          	lui	a0,0x40044
{
4001ec9c:	ff010113          	addi	sp,sp,-16
	net_icmpv6_register_handler(&ns_input_handler);
4001eca0:	08050513          	addi	a0,a0,128 # 40044080 <ns_input_handler>
{
4001eca4:	00112623          	sw	ra,12(sp)
	net_icmpv6_register_handler(&ns_input_handler);
4001eca8:	ca1fb0ef          	jal	ra,4001a948 <net_icmpv6_register_handler>
	net_icmpv6_register_handler(&na_input_handler);
4001ecac:	40044537          	lui	a0,0x40044
4001ecb0:	07450513          	addi	a0,a0,116 # 40044074 <na_input_handler>
4001ecb4:	c95fb0ef          	jal	ra,4001a948 <net_icmpv6_register_handler>
	k_work_init_delayable(&ipv6_ns_reply_timer, ipv6_ns_reply_timeout);
4001ecb8:	4001c5b7          	lui	a1,0x4001c
4001ecbc:	4003a537          	lui	a0,0x4003a
4001ecc0:	1f858593          	addi	a1,a1,504 # 4001c1f8 <ipv6_ns_reply_timeout>
4001ecc4:	be050513          	addi	a0,a0,-1056 # 40039be0 <ipv6_ns_reply_timer>
4001ecc8:	33c110ef          	jal	ra,40030004 <k_work_init_delayable>
	return z_impl_k_sem_init(sem, initial_count, limit);
4001eccc:	4003b537          	lui	a0,0x4003b
4001ecd0:	00100593          	li	a1,1
4001ecd4:	fff00613          	li	a2,-1
4001ecd8:	eb850513          	addi	a0,a0,-328 # 4003aeb8 <nbr_lock>
4001ecdc:	425100ef          	jal	ra,4002f900 <z_impl_k_sem_init>
	k_sem_init(&nbr_lock, 1, K_SEM_MAX_LIMIT);
#endif
#if defined(CONFIG_NET_IPV6_ND)
	net_icmpv6_register_handler(&ra_input_handler);
4001ece0:	40044537          	lui	a0,0x40044
4001ece4:	06850513          	addi	a0,a0,104 # 40044068 <ra_input_handler>
4001ece8:	c61fb0ef          	jal	ra,4001a948 <net_icmpv6_register_handler>
	k_work_init_delayable(&ipv6_nd_reachable_timer,
			      ipv6_nd_reachable_timeout);
#endif
}
4001ecec:	00c12083          	lw	ra,12(sp)
	k_work_init_delayable(&ipv6_nd_reachable_timer,
4001ecf0:	4001f5b7          	lui	a1,0x4001f
4001ecf4:	4003a537          	lui	a0,0x4003a
4001ecf8:	96c58593          	addi	a1,a1,-1684 # 4001e96c <ipv6_nd_reachable_timeout>
4001ecfc:	c1050513          	addi	a0,a0,-1008 # 40039c10 <ipv6_nd_reachable_timer>
}
4001ed00:	01010113          	addi	sp,sp,16
	k_work_init_delayable(&ipv6_nd_reachable_timer,
4001ed04:	3001106f          	j	40030004 <k_work_init_delayable>

4001ed08 <net_pkt_write_be16>:
{
4001ed08:	fe010113          	addi	sp,sp,-32
	uint16_t data_be16 = htons(data);
4001ed0c:	00859793          	slli	a5,a1,0x8
4001ed10:	0085d593          	srli	a1,a1,0x8
4001ed14:	00b7e7b3          	or	a5,a5,a1
	return net_pkt_write(pkt, &data_be16, sizeof(uint16_t));
4001ed18:	00200613          	li	a2,2
4001ed1c:	00e10593          	addi	a1,sp,14
{
4001ed20:	00112e23          	sw	ra,28(sp)
	uint16_t data_be16 = htons(data);
4001ed24:	00f11723          	sh	a5,14(sp)
	return net_pkt_write(pkt, &data_be16, sizeof(uint16_t));
4001ed28:	b5df90ef          	jal	ra,40018884 <net_pkt_write>
}
4001ed2c:	01c12083          	lw	ra,28(sp)
4001ed30:	02010113          	addi	sp,sp,32
4001ed34:	00008067          	ret

4001ed38 <mld_create>:

static int mld_create(struct net_pkt *pkt,
		      const struct in6_addr *addr,
		      uint8_t record_type,
		      uint16_t num_sources)
{
4001ed38:	fc010113          	addi	sp,sp,-64
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
4001ed3c:	00c10793          	addi	a5,sp,12
{
4001ed40:	02812c23          	sw	s0,56(sp)
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
4001ed44:	00f12223          	sw	a5,4(sp)
{
4001ed48:	00058413          	mv	s0,a1
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
4001ed4c:	01400793          	li	a5,20
				   struct net_icmpv6_mld_mcast_record);
	struct net_icmpv6_mld_mcast_record *mld;

	mld = (struct net_icmpv6_mld_mcast_record *)
				net_pkt_get_data(pkt, &mld_access);
4001ed50:	00410593          	addi	a1,sp,4
{
4001ed54:	02912a23          	sw	s1,52(sp)
4001ed58:	03212823          	sw	s2,48(sp)
4001ed5c:	03312623          	sw	s3,44(sp)
4001ed60:	02112e23          	sw	ra,60(sp)
4001ed64:	00050493          	mv	s1,a0
4001ed68:	00060993          	mv	s3,a2
4001ed6c:	00068913          	mv	s2,a3
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
4001ed70:	00f12423          	sw	a5,8(sp)
				net_pkt_get_data(pkt, &mld_access);
4001ed74:	b75f90ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!mld) {
4001ed78:	02051463          	bnez	a0,4001eda0 <mld_create+0x68>
		return -ENOBUFS;
4001ed7c:	f9700413          	li	s0,-105
			return -ENOBUFS;
		}
	}

	return 0;
}
4001ed80:	03c12083          	lw	ra,60(sp)
4001ed84:	00040513          	mv	a0,s0
4001ed88:	03812403          	lw	s0,56(sp)
4001ed8c:	03412483          	lw	s1,52(sp)
4001ed90:	03012903          	lw	s2,48(sp)
4001ed94:	02c12983          	lw	s3,44(sp)
4001ed98:	04010113          	addi	sp,sp,64
4001ed9c:	00008067          	ret
	memcpy(dest, src, sizeof(struct in6_addr));
4001eda0:	00040593          	mv	a1,s0
	mld->record_type = record_type;
4001eda4:	01350023          	sb	s3,0(a0)
	mld->aux_data_len = 0U;
4001eda8:	000500a3          	sb	zero,1(a0)
	mld->num_sources = htons(num_sources);
4001edac:	00050123          	sb	zero,2(a0)
4001edb0:	012501a3          	sb	s2,3(a0)
4001edb4:	01000613          	li	a2,16
4001edb8:	00450513          	addi	a0,a0,4
4001edbc:	f3ded0ef          	jal	ra,4000ccf8 <memcpy>
	if (net_pkt_set_data(pkt, &mld_access)) {
4001edc0:	00410593          	addi	a1,sp,4
4001edc4:	00048513          	mv	a0,s1
4001edc8:	bf1f90ef          	jal	ra,400189b8 <net_pkt_set_data>
4001edcc:	00050413          	mv	s0,a0
4001edd0:	fa0516e3          	bnez	a0,4001ed7c <mld_create+0x44>
	if (num_sources > 0) {
4001edd4:	fa0906e3          	beqz	s2,4001ed80 <mld_create+0x48>
				  net_ipv6_unspecified_address()->s6_addr,
4001edd8:	e30f60ef          	jal	ra,40015408 <net_ipv6_unspecified_address>
4001eddc:	00050593          	mv	a1,a0
		if (net_pkt_write(pkt,
4001ede0:	01000613          	li	a2,16
4001ede4:	00048513          	mv	a0,s1
4001ede8:	a9df90ef          	jal	ra,40018884 <net_pkt_write>
4001edec:	f8050ae3          	beqz	a0,4001ed80 <mld_create+0x48>
4001edf0:	f8dff06f          	j	4001ed7c <mld_create+0x44>

4001edf4 <net_if_flag_is_set>:
	if (iface == NULL) {
4001edf4:	02050c63          	beqz	a0,4001ee2c <net_if_flag_is_set+0x38>
{
4001edf8:	ff010113          	addi	sp,sp,-16
4001edfc:	00812423          	sw	s0,8(sp)
4001ee00:	00112623          	sw	ra,12(sp)
	return atomic_test_bit(iface->if_dev->flags, value);
4001ee04:	00052503          	lw	a0,0(a0)
4001ee08:	00058413          	mv	s0,a1
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
4001ee0c:	00c50513          	addi	a0,a0,12
4001ee10:	479120ef          	jal	ra,40031a88 <atomic_get>
}
4001ee14:	00c12083          	lw	ra,12(sp)
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
4001ee18:	40855533          	sra	a0,a0,s0
4001ee1c:	00812403          	lw	s0,8(sp)
4001ee20:	00157513          	andi	a0,a0,1
4001ee24:	01010113          	addi	sp,sp,16
4001ee28:	00008067          	ret
		return false;
4001ee2c:	00000513          	li	a0,0
}
4001ee30:	00008067          	ret

4001ee34 <mld_send>:

	return 0;
}

static int mld_send(struct net_pkt *pkt)
{
4001ee34:	ff010113          	addi	sp,sp,-16
4001ee38:	00112623          	sw	ra,12(sp)
4001ee3c:	00812423          	sw	s0,8(sp)
4001ee40:	00050413          	mv	s0,a0
	net_pkt_cursor_init(pkt);
4001ee44:	cadf80ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
4001ee48:	03a00593          	li	a1,58
4001ee4c:	00040513          	mv	a0,s0
4001ee50:	98dfc0ef          	jal	ra,4001b7dc <net_ipv6_finalize>

	if (net_send_data(pkt) < 0) {
4001ee54:	00040513          	mv	a0,s0
4001ee58:	855f00ef          	jal	ra,4000f6ac <net_send_data>
4001ee5c:	4003b7b7          	lui	a5,0x4003b
4001ee60:	01842703          	lw	a4,24(s0)
4001ee64:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4001ee68:	04055a63          	bgez	a0,4001eebc <mld_send+0x88>
	UPDATE_STAT(iface, stats.icmp.drop++);
4001ee6c:	04c7a683          	lw	a3,76(a5)
		net_stats_update_icmp_drop(net_pkt_iface(pkt));
		net_stats_update_ipv6_mld_drop(net_pkt_iface(pkt));

		net_pkt_unref(pkt);
4001ee70:	00040513          	mv	a0,s0
4001ee74:	00168693          	addi	a3,a3,1
4001ee78:	04d7a623          	sw	a3,76(a5)
4001ee7c:	05072683          	lw	a3,80(a4)
4001ee80:	00168693          	addi	a3,a3,1
4001ee84:	04d72823          	sw	a3,80(a4)
	UPDATE_STAT(iface, stats.ipv6_mld.sent++);
}

static inline void net_stats_update_ipv6_mld_drop(struct net_if *iface)
{
	UPDATE_STAT(iface, stats.ipv6_mld.drop++);
4001ee88:	0b47a703          	lw	a4,180(a5)
	return pkt->iface;
4001ee8c:	01842683          	lw	a3,24(s0)
4001ee90:	00170713          	addi	a4,a4,1
4001ee94:	0ae7aa23          	sw	a4,180(a5)
4001ee98:	0b86a783          	lw	a5,184(a3)
4001ee9c:	00178793          	addi	a5,a5,1
4001eea0:	0af6ac23          	sw	a5,184(a3)
4001eea4:	979f80ef          	jal	ra,4001781c <net_pkt_unref>
4001eea8:	fff00513          	li	a0,-1

	net_stats_update_icmp_sent(net_pkt_iface(pkt));
	net_stats_update_ipv6_mld_sent(net_pkt_iface(pkt));

	return 0;
}
4001eeac:	00c12083          	lw	ra,12(sp)
4001eeb0:	00812403          	lw	s0,8(sp)
4001eeb4:	01010113          	addi	sp,sp,16
4001eeb8:	00008067          	ret
	UPDATE_STAT(iface, stats.icmp.sent++);
4001eebc:	0487a683          	lw	a3,72(a5)
	return 0;
4001eec0:	00000513          	li	a0,0
4001eec4:	00168693          	addi	a3,a3,1
4001eec8:	04d7a423          	sw	a3,72(a5)
4001eecc:	04c72683          	lw	a3,76(a4)
4001eed0:	00168693          	addi	a3,a3,1
4001eed4:	04d72623          	sw	a3,76(a4)
	UPDATE_STAT(iface, stats.ipv6_mld.sent++);
4001eed8:	0b07a703          	lw	a4,176(a5)
4001eedc:	01842683          	lw	a3,24(s0)
4001eee0:	00170713          	addi	a4,a4,1
4001eee4:	0ae7a823          	sw	a4,176(a5)
4001eee8:	0b46a783          	lw	a5,180(a3)
4001eeec:	00178793          	addi	a5,a5,1
4001eef0:	0af6aa23          	sw	a5,180(a3)
}
4001eef4:	fb9ff06f          	j	4001eeac <mld_send+0x78>

4001eef8 <mld_create_packet>:
{
4001eef8:	fd010113          	addi	sp,sp,-48
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
4001eefc:	2ff00793          	li	a5,767
4001ef00:	00f12823          	sw	a5,16(sp)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
4001ef04:	160007b7          	lui	a5,0x16000
4001ef08:	02812423          	sw	s0,40(sp)
4001ef0c:	02912223          	sw	s1,36(sp)
4001ef10:	02112623          	sw	ra,44(sp)
4001ef14:	00f12e23          	sw	a5,28(sp)
	pkt->ipv6_hop_limit = hop_limit;
4001ef18:	00100793          	li	a5,1
4001ef1c:	00050413          	mv	s0,a0
4001ef20:	02f50ca3          	sb	a5,57(a0)
	if (net_ipv6_create(pkt, net_if_ipv6_select_src_addr(
4001ef24:	01852503          	lw	a0,24(a0)
{
4001ef28:	00058493          	mv	s1,a1
	if (net_ipv6_create(pkt, net_if_ipv6_select_src_addr(
4001ef2c:	01010593          	addi	a1,sp,16
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
4001ef30:	00012a23          	sw	zero,20(sp)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
4001ef34:	00012c23          	sw	zero,24(sp)
4001ef38:	d51f30ef          	jal	ra,40012c88 <net_if_ipv6_select_src_addr>
4001ef3c:	00050593          	mv	a1,a0
4001ef40:	01010613          	addi	a2,sp,16
4001ef44:	00040513          	mv	a0,s0
4001ef48:	fa0fc0ef          	jal	ra,4001b6e8 <net_ipv6_create>
4001ef4c:	00050e63          	beqz	a0,4001ef68 <mld_create_packet+0x70>
		return -ENOBUFS;
4001ef50:	f9700513          	li	a0,-105
}
4001ef54:	02c12083          	lw	ra,44(sp)
4001ef58:	02812403          	lw	s0,40(sp)
4001ef5c:	02412483          	lw	s1,36(sp)
4001ef60:	03010113          	addi	sp,sp,48
4001ef64:	00008067          	ret
	if (net_pkt_write_u8(pkt, IPPROTO_ICMPV6) ||
4001ef68:	03a00793          	li	a5,58
	return net_pkt_write(pkt, &data, sizeof(uint8_t));
4001ef6c:	00100613          	li	a2,1
4001ef70:	00f10593          	addi	a1,sp,15
4001ef74:	00040513          	mv	a0,s0
4001ef78:	00f107a3          	sb	a5,15(sp)
4001ef7c:	909f90ef          	jal	ra,40018884 <net_pkt_write>
4001ef80:	fc0518e3          	bnez	a0,4001ef50 <mld_create_packet+0x58>
4001ef84:	00100613          	li	a2,1
4001ef88:	00f10593          	addi	a1,sp,15
4001ef8c:	00040513          	mv	a0,s0
4001ef90:	000107a3          	sb	zero,15(sp)
4001ef94:	8f1f90ef          	jal	ra,40018884 <net_pkt_write>
4001ef98:	fa051ce3          	bnez	a0,4001ef50 <mld_create_packet+0x58>
	if (net_pkt_write_be16(pkt, 0x0502) ||
4001ef9c:	50200593          	li	a1,1282
4001efa0:	00040513          	mv	a0,s0
4001efa4:	d65ff0ef          	jal	ra,4001ed08 <net_pkt_write_be16>
4001efa8:	fa0514e3          	bnez	a0,4001ef50 <mld_create_packet+0x58>
	    net_pkt_write_be16(pkt, 0) ||
4001efac:	00000593          	li	a1,0
4001efb0:	00040513          	mv	a0,s0
4001efb4:	d55ff0ef          	jal	ra,4001ed08 <net_pkt_write_be16>
	if (net_pkt_write_be16(pkt, 0x0502) ||
4001efb8:	f8051ce3          	bnez	a0,4001ef50 <mld_create_packet+0x58>
	    net_pkt_write_be16(pkt, 0)) {
4001efbc:	00000593          	li	a1,0
4001efc0:	00040513          	mv	a0,s0
4001efc4:	d45ff0ef          	jal	ra,4001ed08 <net_pkt_write_be16>
	    net_pkt_write_be16(pkt, 0) ||
4001efc8:	f80514e3          	bnez	a0,4001ef50 <mld_create_packet+0x58>
	pkt->ipv6_ext_len = len;
4001efcc:	00800793          	li	a5,8
4001efd0:	02f41d23          	sh	a5,58(s0)
	if (net_icmpv6_create(pkt, NET_ICMPV6_MLDv2, 0) ||
4001efd4:	00000613          	li	a2,0
4001efd8:	08f00593          	li	a1,143
4001efdc:	00040513          	mv	a0,s0
4001efe0:	a6dfb0ef          	jal	ra,4001aa4c <net_icmpv6_create>
4001efe4:	f60516e3          	bnez	a0,4001ef50 <mld_create_packet+0x58>
	    net_pkt_write_be16(pkt, 0) ||
4001efe8:	00000593          	li	a1,0
4001efec:	00040513          	mv	a0,s0
4001eff0:	d19ff0ef          	jal	ra,4001ed08 <net_pkt_write_be16>
	if (net_icmpv6_create(pkt, NET_ICMPV6_MLDv2, 0) ||
4001eff4:	f4051ee3          	bnez	a0,4001ef50 <mld_create_packet+0x58>
	    net_pkt_write_be16(pkt, count)) {
4001eff8:	00048593          	mv	a1,s1
4001effc:	00040513          	mv	a0,s0
4001f000:	d09ff0ef          	jal	ra,4001ed08 <net_pkt_write_be16>
	    net_pkt_write_be16(pkt, 0) ||
4001f004:	f40516e3          	bnez	a0,4001ef50 <mld_create_packet+0x58>
	pkt->ipv6_next_hdr = next_hdr;
4001f008:	02040fa3          	sb	zero,63(s0)
	return 0;
4001f00c:	f49ff06f          	j	4001ef54 <mld_create_packet+0x5c>

4001f010 <mld_send_generic>:

static int mld_send_generic(struct net_if *iface,
			    const struct in6_addr *addr,
			    uint8_t mode)
{
4001f010:	ff010113          	addi	sp,sp,-16
4001f014:	00812423          	sw	s0,8(sp)
4001f018:	01212023          	sw	s2,0(sp)
4001f01c:	00058413          	mv	s0,a1
4001f020:	00060913          	mv	s2,a2
	struct net_pkt *pkt;
	int ret;

	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
4001f024:	00500713          	li	a4,5
4001f028:	00000793          	li	a5,0
4001f02c:	03a00693          	li	a3,58
4001f030:	00200613          	li	a2,2
4001f034:	03000593          	li	a1,48
{
4001f038:	00112623          	sw	ra,12(sp)
4001f03c:	00912223          	sw	s1,4(sp)
	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
4001f040:	848f90ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
					NET_ICMPV6_UNUSED_LEN +
					MLDv2_MCAST_RECORD_LEN +
					sizeof(struct in6_addr),
					AF_INET6, IPPROTO_ICMPV6,
					PKT_WAIT_TIME);
	if (!pkt) {
4001f044:	06050463          	beqz	a0,4001f0ac <mld_send_generic+0x9c>
		return -ENOMEM;
	}

	if (mld_create_packet(pkt, 1) ||
4001f048:	00100593          	li	a1,1
4001f04c:	00050493          	mv	s1,a0
4001f050:	ea9ff0ef          	jal	ra,4001eef8 <mld_create_packet>
4001f054:	00050a63          	beqz	a0,4001f068 <mld_send_generic+0x58>
	    mld_create(pkt, addr, mode, 1)) {
		ret = -ENOBUFS;
4001f058:	f9700413          	li	s0,-105
	}

	return 0;

drop:
	net_pkt_unref(pkt);
4001f05c:	00048513          	mv	a0,s1
4001f060:	fbcf80ef          	jal	ra,4001781c <net_pkt_unref>

	return ret;
4001f064:	02c0006f          	j	4001f090 <mld_send_generic+0x80>
	    mld_create(pkt, addr, mode, 1)) {
4001f068:	00100693          	li	a3,1
4001f06c:	00090613          	mv	a2,s2
4001f070:	00040593          	mv	a1,s0
4001f074:	00048513          	mv	a0,s1
4001f078:	cc1ff0ef          	jal	ra,4001ed38 <mld_create>
	if (mld_create_packet(pkt, 1) ||
4001f07c:	fc051ee3          	bnez	a0,4001f058 <mld_send_generic+0x48>
	ret = mld_send(pkt);
4001f080:	00048513          	mv	a0,s1
4001f084:	db1ff0ef          	jal	ra,4001ee34 <mld_send>
4001f088:	00050413          	mv	s0,a0
	if (ret) {
4001f08c:	fc0518e3          	bnez	a0,4001f05c <mld_send_generic+0x4c>
}
4001f090:	00c12083          	lw	ra,12(sp)
4001f094:	00040513          	mv	a0,s0
4001f098:	00812403          	lw	s0,8(sp)
4001f09c:	00412483          	lw	s1,4(sp)
4001f0a0:	00012903          	lw	s2,0(sp)
4001f0a4:	01010113          	addi	sp,sp,16
4001f0a8:	00008067          	ret
		return -ENOMEM;
4001f0ac:	ff400413          	li	s0,-12
4001f0b0:	fe1ff06f          	j	4001f090 <mld_send_generic+0x80>

4001f0b4 <handle_mld_query>:
	dbg_addr("Received", pkt_str, src, dst)

static enum net_verdict handle_mld_query(struct net_pkt *pkt,
					 struct net_ipv6_hdr *ip_hdr,
					 struct net_icmp_hdr *icmp_hdr)
{
4001f0b4:	fd010113          	addi	sp,sp,-48
4001f0b8:	02812423          	sw	s0,40(sp)
4001f0bc:	03212023          	sw	s2,32(sp)
4001f0c0:	01312e23          	sw	s3,28(sp)
4001f0c4:	01412c23          	sw	s4,24(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(mld_access,
4001f0c8:	01800793          	li	a5,24
{
4001f0cc:	02112623          	sw	ra,44(sp)
4001f0d0:	02912223          	sw	s1,36(sp)
4001f0d4:	01512a23          	sw	s5,20(sp)
4001f0d8:	01612823          	sw	s6,16(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(mld_access,
4001f0dc:	00f12623          	sw	a5,12(sp)
					      struct net_icmpv6_mld_query);
	uint16_t length = net_pkt_get_len(pkt);
4001f0e0:	00852783          	lw	a5,8(a0)
{
4001f0e4:	00050413          	mv	s0,a0
4001f0e8:	00058a13          	mv	s4,a1
4001f0ec:	00060993          	mv	s3,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(mld_access,
4001f0f0:	00012423          	sw	zero,8(sp)
	size_t bytes = 0;
4001f0f4:	00000913          	li	s2,0
	while (buf) {
4001f0f8:	18079663          	bnez	a5,4001f284 <handle_mld_query+0x1d0>
	struct net_icmpv6_mld_query *mld_query;
	uint16_t pkt_len;

	mld_query = (struct net_icmpv6_mld_query *)
				net_pkt_get_data(pkt, &mld_access);
4001f0fc:	00810593          	addi	a1,sp,8
4001f100:	00040513          	mv	a0,s0
	uint16_t length = net_pkt_get_len(pkt);
4001f104:	01091913          	slli	s2,s2,0x10
				net_pkt_get_data(pkt, &mld_access);
4001f108:	fe0f90ef          	jal	ra,400188e8 <net_pkt_get_data>
4001f10c:	4003bab7          	lui	s5,0x4003b
	uint16_t length = net_pkt_get_len(pkt);
4001f110:	01095913          	srli	s2,s2,0x10
				net_pkt_get_data(pkt, &mld_access);
4001f114:	00050493          	mv	s1,a0
	if (!mld_query) {
4001f118:	ed0a8a93          	addi	s5,s5,-304 # 4003aed0 <net_stats>
4001f11c:	1c050c63          	beqz	a0,4001f2f4 <handle_mld_query+0x240>
	return net_pkt_skip(pkt, access->size);
4001f120:	00c12583          	lw	a1,12(sp)
4001f124:	00040513          	mv	a0,s0
4001f128:	fa9f80ef          	jal	ra,400180d0 <net_pkt_skip>
	UPDATE_STAT(iface, stats.ipv6_mld.recv++);
4001f12c:	0acaa783          	lw	a5,172(s5)
	return pkt->iface;
4001f130:	01842703          	lw	a4,24(s0)
4001f134:	00178793          	addi	a5,a5,1 # 16000001 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x100a1f01>
4001f138:	0afaa623          	sw	a5,172(s5)
4001f13c:	0b072783          	lw	a5,176(a4)
4001f140:	00178793          	addi	a5,a5,1
4001f144:	0af72823          	sw	a5,176(a4)

	dbg_addr_recv("Multicast Listener Query", &ip_hdr->src, &ip_hdr->dst);

	net_stats_update_ipv6_mld_recv(net_pkt_iface(pkt));

	mld_query->num_sources = ntohs(mld_query->num_sources);
4001f148:	0174c783          	lbu	a5,23(s1)
4001f14c:	0164c703          	lbu	a4,22(s1)
4001f150:	00879793          	slli	a5,a5,0x8
4001f154:	00e7e7b3          	or	a5,a5,a4
4001f158:	00879713          	slli	a4,a5,0x8
4001f15c:	0087d793          	srli	a5,a5,0x8
4001f160:	00f767b3          	or	a5,a4,a5
4001f164:	01079713          	slli	a4,a5,0x10
4001f168:	01075713          	srli	a4,a4,0x10
4001f16c:	00f48b23          	sb	a5,22(s1)
4001f170:	00875793          	srli	a5,a4,0x8
4001f174:	00f48ba3          	sb	a5,23(s1)

	pkt_len = sizeof(struct net_ipv6_hdr) +	net_pkt_ipv6_ext_len(pkt) +
4001f178:	03a45783          	lhu	a5,58(s0)
		sizeof(struct net_icmp_hdr) +
		sizeof(struct net_icmpv6_mld_query) +
		sizeof(struct in6_addr) * mld_query->num_sources;
4001f17c:	00471713          	slli	a4,a4,0x4
	pkt_len = sizeof(struct net_ipv6_hdr) +	net_pkt_ipv6_ext_len(pkt) +
4001f180:	04478793          	addi	a5,a5,68
4001f184:	00e787b3          	add	a5,a5,a4
4001f188:	01079793          	slli	a5,a5,0x10
4001f18c:	0107d793          	srli	a5,a5,0x10

	if (length < pkt_len || pkt_len > NET_IPV6_MTU ||
4001f190:	16f96263          	bltu	s2,a5,4001f2f4 <handle_mld_query+0x240>
4001f194:	50000713          	li	a4,1280
4001f198:	14f76e63          	bltu	a4,a5,4001f2f4 <handle_mld_query+0x240>
4001f19c:	007a4703          	lbu	a4,7(s4)
4001f1a0:	00100793          	li	a5,1
4001f1a4:	14f71863          	bne	a4,a5,4001f2f4 <handle_mld_query+0x240>
	    ip_hdr->hop_limit != 1U || icmp_hdr->code != 0U) {
4001f1a8:	0019c783          	lbu	a5,1(s3)
4001f1ac:	14079463          	bnez	a5,4001f2f4 <handle_mld_query+0x240>
		goto drop;
	}

	/* Currently we only support an unspecified address query. */
	if (!net_ipv6_addr_cmp_raw(mld_query->mcast_address,
				   (uint8_t *)net_ipv6_unspecified_address())) {
4001f1b0:	a58f60ef          	jal	ra,40015408 <net_ipv6_unspecified_address>
4001f1b4:	00050593          	mv	a1,a0
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4001f1b8:	01000613          	li	a2,16
4001f1bc:	00448513          	addi	a0,s1,4
4001f1c0:	ab9ed0ef          	jal	ra,4000cc78 <memcmp>
4001f1c4:	00050493          	mv	s1,a0
	if (!net_ipv6_addr_cmp_raw(mld_query->mcast_address,
4001f1c8:	12051663          	bnez	a0,4001f2f4 <handle_mld_query+0x240>
4001f1cc:	01842503          	lw	a0,24(s0)
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
4001f1d0:	00000713          	li	a4,0
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
4001f1d4:	01800613          	li	a2,24
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
4001f1d8:	0bc52983          	lw	s3,188(a0)
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
4001f1dc:	00400693          	li	a3,4
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
4001f1e0:	02c707b3          	mul	a5,a4,a2
4001f1e4:	00f987b3          	add	a5,s3,a5
4001f1e8:	0a47a783          	lw	a5,164(a5)
4001f1ec:	0017f593          	andi	a1,a5,1
4001f1f0:	00058a63          	beqz	a1,4001f204 <handle_mld_query+0x150>
4001f1f4:	0017d793          	srli	a5,a5,0x1
4001f1f8:	0017f793          	andi	a5,a5,1
4001f1fc:	00078463          	beqz	a5,4001f204 <handle_mld_query+0x150>
		count++;
4001f200:	00148493          	addi	s1,s1,1
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
4001f204:	00170713          	addi	a4,a4,1
4001f208:	fcd71ce3          	bne	a4,a3,4001f1e0 <handle_mld_query+0x12c>
					count * MLDv2_MCAST_RECORD_LEN,
4001f20c:	01400593          	li	a1,20
4001f210:	02b485b3          	mul	a1,s1,a1
	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
4001f214:	00500713          	li	a4,5
4001f218:	00000793          	li	a5,0
4001f21c:	03a00693          	li	a3,58
4001f220:	00200613          	li	a2,2
4001f224:	00c58593          	addi	a1,a1,12
4001f228:	e61f80ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
4001f22c:	00050913          	mv	s2,a0
	if (!pkt) {
4001f230:	08050863          	beqz	a0,4001f2c0 <handle_mld_query+0x20c>
	if (mld_create_packet(pkt, count)) {
4001f234:	01049593          	slli	a1,s1,0x10
4001f238:	0105d593          	srli	a1,a1,0x10
4001f23c:	cbdff0ef          	jal	ra,4001eef8 <mld_create_packet>
4001f240:	00050493          	mv	s1,a0
4001f244:	09498a13          	addi	s4,s3,148
4001f248:	06051863          	bnez	a0,4001f2b8 <handle_mld_query+0x204>
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
4001f24c:	01800a93          	li	s5,24
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
4001f250:	00400b13          	li	s6,4
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
4001f254:	035487b3          	mul	a5,s1,s5
4001f258:	00f987b3          	add	a5,s3,a5
4001f25c:	0a47a783          	lw	a5,164(a5)
4001f260:	0017f713          	andi	a4,a5,1
4001f264:	02071863          	bnez	a4,4001f294 <handle_mld_query+0x1e0>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
4001f268:	00148493          	addi	s1,s1,1
4001f26c:	018a0a13          	addi	s4,s4,24
4001f270:	ff6492e3          	bne	s1,s6,4001f254 <handle_mld_query+0x1a0>
	if (!mld_send(pkt)) {
4001f274:	00090513          	mv	a0,s2
4001f278:	bbdff0ef          	jal	ra,4001ee34 <mld_send>
4001f27c:	02051e63          	bnez	a0,4001f2b8 <handle_mld_query+0x204>
4001f280:	0400006f          	j	4001f2c0 <handle_mld_query+0x20c>
		bytes += buf->len;
4001f284:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
4001f288:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4001f28c:	00e90933          	add	s2,s2,a4
		buf = buf->frags;
4001f290:	e69ff06f          	j	4001f0f8 <handle_mld_query+0x44>
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
4001f294:	0017d793          	srli	a5,a5,0x1
4001f298:	0017f793          	andi	a5,a5,1
4001f29c:	fc0786e3          	beqz	a5,4001f268 <handle_mld_query+0x1b4>
		if (!mld_create(pkt, &ipv6->mcast[i].address.in6_addr,
4001f2a0:	00000693          	li	a3,0
4001f2a4:	00200613          	li	a2,2
4001f2a8:	000a0593          	mv	a1,s4
4001f2ac:	00090513          	mv	a0,s2
4001f2b0:	a89ff0ef          	jal	ra,4001ed38 <mld_create>
4001f2b4:	fa051ae3          	bnez	a0,4001f268 <handle_mld_query+0x1b4>
	net_pkt_unref(pkt);
4001f2b8:	00090513          	mv	a0,s2
4001f2bc:	d60f80ef          	jal	ra,4001781c <net_pkt_unref>
		goto drop;
	}

	send_mld_report(net_pkt_iface(pkt));

	net_pkt_unref(pkt);
4001f2c0:	00040513          	mv	a0,s0
4001f2c4:	d58f80ef          	jal	ra,4001781c <net_pkt_unref>

	return NET_OK;
4001f2c8:	00000513          	li	a0,0

drop:
	net_stats_update_ipv6_mld_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
4001f2cc:	02c12083          	lw	ra,44(sp)
4001f2d0:	02812403          	lw	s0,40(sp)
4001f2d4:	02412483          	lw	s1,36(sp)
4001f2d8:	02012903          	lw	s2,32(sp)
4001f2dc:	01c12983          	lw	s3,28(sp)
4001f2e0:	01812a03          	lw	s4,24(sp)
4001f2e4:	01412a83          	lw	s5,20(sp)
4001f2e8:	01012b03          	lw	s6,16(sp)
4001f2ec:	03010113          	addi	sp,sp,48
4001f2f0:	00008067          	ret
	UPDATE_STAT(iface, stats.ipv6_mld.drop++);
4001f2f4:	0b4aa783          	lw	a5,180(s5)
4001f2f8:	01842703          	lw	a4,24(s0)
	return NET_DROP;
4001f2fc:	00200513          	li	a0,2
4001f300:	00178793          	addi	a5,a5,1
4001f304:	0afaaa23          	sw	a5,180(s5)
4001f308:	0b872783          	lw	a5,184(a4)
4001f30c:	00178793          	addi	a5,a5,1
4001f310:	0af72c23          	sw	a5,184(a4)
}
4001f314:	fb9ff06f          	j	4001f2cc <handle_mld_query+0x218>

4001f318 <net_ipv6_mld_join>:
{
4001f318:	fe010113          	addi	sp,sp,-32
4001f31c:	01212823          	sw	s2,16(sp)
4001f320:	00058913          	mv	s2,a1
4001f324:	00a12623          	sw	a0,12(sp)
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
4001f328:	00c10593          	addi	a1,sp,12
4001f32c:	00090513          	mv	a0,s2
{
4001f330:	00112e23          	sw	ra,28(sp)
4001f334:	00812c23          	sw	s0,24(sp)
4001f338:	00912a23          	sw	s1,20(sp)
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
4001f33c:	e51f20ef          	jal	ra,4001218c <net_if_ipv6_maddr_lookup>
	if (maddr && net_if_ipv6_maddr_is_joined(maddr)) {
4001f340:	02050c63          	beqz	a0,4001f378 <net_ipv6_mld_join+0x60>
	return addr->is_joined;
4001f344:	01452783          	lw	a5,20(a0)
4001f348:	00050413          	mv	s0,a0
		return -EALREADY;
4001f34c:	f8800493          	li	s1,-120
4001f350:	0017d793          	srli	a5,a5,0x1
	if (maddr && net_if_ipv6_maddr_is_joined(maddr)) {
4001f354:	0017f793          	andi	a5,a5,1
4001f358:	02078c63          	beqz	a5,4001f390 <net_ipv6_mld_join+0x78>
}
4001f35c:	01c12083          	lw	ra,28(sp)
4001f360:	01812403          	lw	s0,24(sp)
4001f364:	01012903          	lw	s2,16(sp)
4001f368:	00048513          	mv	a0,s1
4001f36c:	01412483          	lw	s1,20(sp)
4001f370:	02010113          	addi	sp,sp,32
4001f374:	00008067          	ret
		maddr = net_if_ipv6_maddr_add(iface, addr);
4001f378:	00c12503          	lw	a0,12(sp)
4001f37c:	00090593          	mv	a1,s2
			return -ENOMEM;
4001f380:	ff400493          	li	s1,-12
		maddr = net_if_ipv6_maddr_add(iface, addr);
4001f384:	f45f20ef          	jal	ra,400122c8 <net_if_ipv6_maddr_add>
4001f388:	00050413          	mv	s0,a0
		if (!maddr) {
4001f38c:	fc0508e3          	beqz	a0,4001f35c <net_ipv6_mld_join+0x44>
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_MLD)) {
4001f390:	00c12503          	lw	a0,12(sp)
4001f394:	00c00593          	li	a1,12
		return 0;
4001f398:	00000493          	li	s1,0
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_MLD)) {
4001f39c:	a59ff0ef          	jal	ra,4001edf4 <net_if_flag_is_set>
4001f3a0:	fa051ee3          	bnez	a0,4001f35c <net_ipv6_mld_join+0x44>
	if (!net_if_is_up(iface)) {
4001f3a4:	00c12483          	lw	s1,12(sp)
	return net_if_flag_is_set(iface, NET_IF_UP) &&
4001f3a8:	00000593          	li	a1,0
4001f3ac:	00048513          	mv	a0,s1
4001f3b0:	a45ff0ef          	jal	ra,4001edf4 <net_if_flag_is_set>
4001f3b4:	00051663          	bnez	a0,4001f3c0 <net_ipv6_mld_join+0xa8>
		return -ENETDOWN;
4001f3b8:	f8d00493          	li	s1,-115
4001f3bc:	fa1ff06f          	j	4001f35c <net_ipv6_mld_join+0x44>
	       net_if_flag_is_set(iface, NET_IF_RUNNING);
4001f3c0:	00800593          	li	a1,8
4001f3c4:	00048513          	mv	a0,s1
4001f3c8:	a2dff0ef          	jal	ra,4001edf4 <net_if_flag_is_set>
	return net_if_flag_is_set(iface, NET_IF_UP) &&
4001f3cc:	fe0506e3          	beqz	a0,4001f3b8 <net_ipv6_mld_join+0xa0>
	ret = mld_send_generic(iface, addr, NET_IPV6_MLDv2_MODE_IS_EXCLUDE);
4001f3d0:	00c12503          	lw	a0,12(sp)
4001f3d4:	00200613          	li	a2,2
4001f3d8:	00090593          	mv	a1,s2
4001f3dc:	c35ff0ef          	jal	ra,4001f010 <mld_send_generic>
4001f3e0:	00050493          	mv	s1,a0
	if (ret < 0) {
4001f3e4:	f6054ce3          	bltz	a0,4001f35c <net_ipv6_mld_join+0x44>
	net_if_ipv6_maddr_join(maddr);
4001f3e8:	00040513          	mv	a0,s0
4001f3ec:	850f30ef          	jal	ra,4001243c <net_if_ipv6_maddr_join>
	net_if_mcast_monitor(iface, &maddr->address, true);
4001f3f0:	00c12503          	lw	a0,12(sp)
4001f3f4:	00040593          	mv	a1,s0
4001f3f8:	00100613          	li	a2,1
4001f3fc:	981f10ef          	jal	ra,40010d7c <net_if_mcast_monitor>
	net_mgmt_event_notify_with_info(NET_EVENT_IPV6_MCAST_JOIN, iface,
4001f400:	00c12583          	lw	a1,12(sp)
4001f404:	e0600537          	lui	a0,0xe0600
4001f408:	01000693          	li	a3,16
4001f40c:	00440613          	addi	a2,s0,4
4001f410:	00750513          	addi	a0,a0,7 # e0600007 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600008>
4001f414:	ab8f60ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
	return ret;
4001f418:	f45ff06f          	j	4001f35c <net_ipv6_mld_join+0x44>

4001f41c <net_ipv6_mld_leave>:
{
4001f41c:	fe010113          	addi	sp,sp,-32
4001f420:	01212823          	sw	s2,16(sp)
4001f424:	00058913          	mv	s2,a1
4001f428:	00a12623          	sw	a0,12(sp)
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
4001f42c:	00c10593          	addi	a1,sp,12
4001f430:	00090513          	mv	a0,s2
{
4001f434:	00812c23          	sw	s0,24(sp)
4001f438:	00112e23          	sw	ra,28(sp)
4001f43c:	00912a23          	sw	s1,20(sp)
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
4001f440:	d4df20ef          	jal	ra,4001218c <net_if_ipv6_maddr_lookup>
		return -ENOENT;
4001f444:	ffe00413          	li	s0,-2
	if (!maddr) {
4001f448:	06050863          	beqz	a0,4001f4b8 <net_ipv6_mld_leave+0x9c>
4001f44c:	00050493          	mv	s1,a0
	if (!net_if_ipv6_maddr_rm(iface, addr)) {
4001f450:	00c12503          	lw	a0,12(sp)
4001f454:	00090593          	mv	a1,s2
		return -EINVAL;
4001f458:	fea00413          	li	s0,-22
	if (!net_if_ipv6_maddr_rm(iface, addr)) {
4001f45c:	fb0f20ef          	jal	ra,40011c0c <net_if_ipv6_maddr_rm>
4001f460:	04050c63          	beqz	a0,4001f4b8 <net_ipv6_mld_leave+0x9c>
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_MLD)) {
4001f464:	00c12503          	lw	a0,12(sp)
4001f468:	00c00593          	li	a1,12
		return 0;
4001f46c:	00000413          	li	s0,0
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_MLD)) {
4001f470:	985ff0ef          	jal	ra,4001edf4 <net_if_flag_is_set>
4001f474:	04051263          	bnez	a0,4001f4b8 <net_ipv6_mld_leave+0x9c>
	ret = mld_send_generic(iface, addr, NET_IPV6_MLDv2_MODE_IS_INCLUDE);
4001f478:	00c12503          	lw	a0,12(sp)
4001f47c:	00100613          	li	a2,1
4001f480:	00090593          	mv	a1,s2
4001f484:	b8dff0ef          	jal	ra,4001f010 <mld_send_generic>
4001f488:	00050413          	mv	s0,a0
	if (ret < 0) {
4001f48c:	02054663          	bltz	a0,4001f4b8 <net_ipv6_mld_leave+0x9c>
	net_if_mcast_monitor(iface, &maddr->address, false);
4001f490:	00c12503          	lw	a0,12(sp)
4001f494:	00000613          	li	a2,0
4001f498:	00048593          	mv	a1,s1
4001f49c:	8e1f10ef          	jal	ra,40010d7c <net_if_mcast_monitor>
	net_mgmt_event_notify_with_info(NET_EVENT_IPV6_MCAST_LEAVE, iface,
4001f4a0:	00c12583          	lw	a1,12(sp)
4001f4a4:	e0600537          	lui	a0,0xe0600
4001f4a8:	01000693          	li	a3,16
4001f4ac:	00448613          	addi	a2,s1,4
4001f4b0:	00850513          	addi	a0,a0,8 # e0600008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600009>
4001f4b4:	a18f60ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
}
4001f4b8:	01c12083          	lw	ra,28(sp)
4001f4bc:	00040513          	mv	a0,s0
4001f4c0:	01812403          	lw	s0,24(sp)
4001f4c4:	01412483          	lw	s1,20(sp)
4001f4c8:	01012903          	lw	s2,16(sp)
4001f4cc:	02010113          	addi	sp,sp,32
4001f4d0:	00008067          	ret

4001f4d4 <net_ipv6_mld_init>:
	.handler = handle_mld_query,
};

void net_ipv6_mld_init(void)
{
	net_icmpv6_register_handler(&mld_query_input_handler);
4001f4d4:	40044537          	lui	a0,0x40044
4001f4d8:	33850513          	addi	a0,a0,824 # 40044338 <mld_query_input_handler>
4001f4dc:	c6cfb06f          	j	4001a948 <net_icmpv6_register_handler>

4001f4e0 <net_route_nexthop_remove>:
static K_MUTEX_DEFINE(lock);

static void net_route_nexthop_remove(struct net_nbr *nbr)
{
	NET_DBG("Nexthop %p removed", nbr);
}
4001f4e0:	00008067          	ret

4001f4e4 <nbr_new>:
}

static struct net_nbr *nbr_new(struct net_if *iface,
			       struct in6_addr *addr,
			       uint8_t prefix_len)
{
4001f4e4:	fd010113          	addi	sp,sp,-48
4001f4e8:	03212023          	sw	s2,32(sp)
4001f4ec:	00050913          	mv	s2,a0
	struct net_nbr *nbr = net_nbr_get(&net_nbr_routes.table);
4001f4f0:	40044537          	lui	a0,0x40044
4001f4f4:	34450513          	addi	a0,a0,836 # 40044344 <net_nbr_routes>
{
4001f4f8:	02812423          	sw	s0,40(sp)
4001f4fc:	02912223          	sw	s1,36(sp)
4001f500:	02112623          	sw	ra,44(sp)
4001f504:	00b12623          	sw	a1,12(sp)
4001f508:	00060493          	mv	s1,a2
	struct net_nbr *nbr = net_nbr_get(&net_nbr_routes.table);
4001f50c:	db5fb0ef          	jal	ra,4001b2c0 <net_nbr_get>
4001f510:	00050413          	mv	s0,a0

	if (!nbr) {
4001f514:	02050a63          	beqz	a0,4001f548 <nbr_new+0x64>
		return NULL;
	}

	nbr->iface = iface;

	net_ipaddr_copy(&net_route_data(nbr)->addr, addr);
4001f518:	00c12583          	lw	a1,12(sp)
	nbr->iface = iface;
4001f51c:	01252423          	sw	s2,8(a0)
	return (struct net_route_entry *)nbr->data;
4001f520:	00c52903          	lw	s2,12(a0)
	net_ipaddr_copy(&net_route_data(nbr)->addr, addr);
4001f524:	01000613          	li	a2,16
4001f528:	01010513          	addi	a0,sp,16
4001f52c:	fcced0ef          	jal	ra,4000ccf8 <memcpy>
4001f530:	01000613          	li	a2,16
4001f534:	01010593          	addi	a1,sp,16
4001f538:	02090513          	addi	a0,s2,32
4001f53c:	fbced0ef          	jal	ra,4000ccf8 <memcpy>
	return (struct net_route_entry *)nbr->data;
4001f540:	00c42783          	lw	a5,12(s0)
	net_route_data(nbr)->prefix_len = prefix_len;
4001f544:	02978823          	sb	s1,48(a5)
		nbr->idx, nbr, iface,
		net_sprint_ipv6_addr(&net_route_data(nbr)->addr),
		prefix_len);

	return nbr;
}
4001f548:	02c12083          	lw	ra,44(sp)
4001f54c:	00040513          	mv	a0,s0
4001f550:	02812403          	lw	s0,40(sp)
4001f554:	02412483          	lw	s1,36(sp)
4001f558:	02012903          	lw	s2,32(sp)
4001f55c:	03010113          	addi	sp,sp,48
4001f560:	00008067          	ret

4001f564 <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
4001f564:	00058613          	mv	a2,a1
4001f568:	00050593          	mv	a1,a0
	return z_impl_k_mutex_lock(mutex, timeout);
4001f56c:	40045537          	lui	a0,0x40045
4001f570:	84850513          	addi	a0,a0,-1976 # 40044848 <lock>
4001f574:	6c90f06f          	j	4002f43c <z_impl_k_mutex_lock>

4001f578 <k_mutex_unlock.constprop.0.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
4001f578:	40045537          	lui	a0,0x40045
4001f57c:	84850513          	addi	a0,a0,-1976 # 40044848 <lock>
4001f580:	0181006f          	j	4002f598 <z_impl_k_mutex_unlock>

4001f584 <sys_slist_find_and_remove.isra.0>:
	return list->head;
4001f584:	00052783          	lw	a5,0(a0)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4001f588:	00000713          	li	a4,0
4001f58c:	00079463          	bnez	a5,4001f594 <sys_slist_find_and_remove.isra.0+0x10>
4001f590:	00008067          	ret
4001f594:	02b79c63          	bne	a5,a1,4001f5cc <sys_slist_find_and_remove.isra.0+0x48>
	return node->next;
4001f598:	0005a783          	lw	a5,0(a1)
Z_GENLIST_REMOVE(slist, snode)
4001f59c:	00071e63          	bnez	a4,4001f5b8 <sys_slist_find_and_remove.isra.0+0x34>
4001f5a0:	00452703          	lw	a4,4(a0)
	list->head = node;
4001f5a4:	00f52023          	sw	a5,0(a0)
Z_GENLIST_REMOVE(slist, snode)
4001f5a8:	00e59463          	bne	a1,a4,4001f5b0 <sys_slist_find_and_remove.isra.0+0x2c>
	list->tail = node;
4001f5ac:	00f52223          	sw	a5,4(a0)
	parent->next = child;
4001f5b0:	0005a023          	sw	zero,0(a1)
Z_GENLIST_REMOVE(slist, snode)
4001f5b4:	00008067          	ret
	parent->next = child;
4001f5b8:	00f72023          	sw	a5,0(a4)
Z_GENLIST_REMOVE(slist, snode)
4001f5bc:	00452783          	lw	a5,4(a0)
4001f5c0:	fef598e3          	bne	a1,a5,4001f5b0 <sys_slist_find_and_remove.isra.0+0x2c>
	list->tail = node;
4001f5c4:	00e52223          	sw	a4,4(a0)
}
4001f5c8:	fe9ff06f          	j	4001f5b0 <sys_slist_find_and_remove.isra.0+0x2c>
	return node->next;
4001f5cc:	00078713          	mv	a4,a5
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4001f5d0:	0007a783          	lw	a5,0(a5)
4001f5d4:	fb9ff06f          	j	4001f58c <sys_slist_find_and_remove.isra.0+0x8>

4001f5d8 <net_route_entries_table_clear>:
static void net_route_entries_table_clear(struct net_nbr_table *table)
4001f5d8:	00008067          	ret

4001f5dc <net_route_entry_remove>:
static void net_route_entry_remove(struct net_nbr *nbr)
4001f5dc:	00008067          	ret

4001f5e0 <net_route_get_nbr>:
{
4001f5e0:	fe010113          	addi	sp,sp,-32
4001f5e4:	00812c23          	sw	s0,24(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001f5e8:	fff00593          	li	a1,-1
{
4001f5ec:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4001f5f0:	fff00513          	li	a0,-1
{
4001f5f4:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001f5f8:	f6dff0ef          	jal	ra,4001f564 <k_mutex_lock.constprop.0.isra.0>
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
4001f5fc:	400447b7          	lui	a5,0x40044
4001f600:	35078693          	addi	a3,a5,848 # 40044350 <net_route_entries_pool>
4001f604:	00000713          	li	a4,0
4001f608:	35078793          	addi	a5,a5,848
4001f60c:	00800613          	li	a2,8
		if (!nbr->ref) {
4001f610:	0006c583          	lbu	a1,0(a3)
4001f614:	02058a63          	beqz	a1,4001f648 <net_route_get_nbr+0x68>
		if (nbr->data == (uint8_t *)route) {
4001f618:	00c6a583          	lw	a1,12(a3)
4001f61c:	02859663          	bne	a1,s0,4001f648 <net_route_get_nbr+0x68>
	return &net_route_entries_pool[idx].nbr;
4001f620:	04800693          	li	a3,72
4001f624:	02d70733          	mul	a4,a4,a3
4001f628:	00e78533          	add	a0,a5,a4
4001f62c:	00a12623          	sw	a0,12(sp)
			k_mutex_unlock(&lock);
4001f630:	f49ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>
			return nbr;
4001f634:	00c12503          	lw	a0,12(sp)
}
4001f638:	01c12083          	lw	ra,28(sp)
4001f63c:	01812403          	lw	s0,24(sp)
4001f640:	02010113          	addi	sp,sp,32
4001f644:	00008067          	ret
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
4001f648:	00170713          	addi	a4,a4,1
4001f64c:	04868693          	addi	a3,a3,72
4001f650:	fcc710e3          	bne	a4,a2,4001f610 <net_route_get_nbr+0x30>
	k_mutex_unlock(&lock);
4001f654:	f25ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>
	return NULL;
4001f658:	00000513          	li	a0,0
4001f65c:	fddff06f          	j	4001f638 <net_route_get_nbr+0x58>

4001f660 <net_route_lookup>:
	sys_slist_prepend(&routes, &route->node);
}

struct net_route_entry *net_route_lookup(struct net_if *iface,
					 struct in6_addr *dst)
{
4001f660:	fd010113          	addi	sp,sp,-48
4001f664:	02912223          	sw	s1,36(sp)
4001f668:	400444b7          	lui	s1,0x40044
4001f66c:	01312e23          	sw	s3,28(sp)
4001f670:	01412c23          	sw	s4,24(sp)
4001f674:	00050993          	mv	s3,a0
4001f678:	00058a13          	mv	s4,a1
	struct net_route_entry *route, *found = NULL;
	uint8_t longest_match = 0U;
	int i;

	k_mutex_lock(&lock, K_FOREVER);
4001f67c:	fff00513          	li	a0,-1
4001f680:	fff00593          	li	a1,-1
4001f684:	35048493          	addi	s1,s1,848 # 40044350 <net_route_entries_pool>
{
4001f688:	01612823          	sw	s6,16(sp)
4001f68c:	01712623          	sw	s7,12(sp)
4001f690:	01912223          	sw	s9,4(sp)
4001f694:	02112623          	sw	ra,44(sp)
4001f698:	02812423          	sw	s0,40(sp)
4001f69c:	03212023          	sw	s2,32(sp)
4001f6a0:	01512a23          	sw	s5,20(sp)
4001f6a4:	01812423          	sw	s8,8(sp)
4001f6a8:	1f848c93          	addi	s9,s1,504
	k_mutex_lock(&lock, K_FOREVER);
4001f6ac:	eb9ff0ef          	jal	ra,4001f564 <k_mutex_lock.constprop.0.isra.0>
	uint8_t longest_match = 0U;
4001f6b0:	00000b93          	li	s7,0
	struct net_route_entry *route, *found = NULL;
4001f6b4:	00000b13          	li	s6,0

	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
		struct net_nbr *nbr = get_nbr(i);

		if (!nbr->ref) {
4001f6b8:	0004c783          	lbu	a5,0(s1)
4001f6bc:	00078863          	beqz	a5,4001f6cc <net_route_lookup+0x6c>
			continue;
		}

		if (iface && nbr->iface != iface) {
4001f6c0:	02098063          	beqz	s3,4001f6e0 <net_route_lookup+0x80>
4001f6c4:	0084a783          	lw	a5,8(s1)
4001f6c8:	01378c63          	beq	a5,s3,4001f6e0 <net_route_lookup+0x80>
	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
4001f6cc:	11948463          	beq	s1,s9,4001f7d4 <net_route_lookup+0x174>
4001f6d0:	04848493          	addi	s1,s1,72
4001f6d4:	000b0413          	mv	s0,s6
{
4001f6d8:	00040b13          	mv	s6,s0
4001f6dc:	fddff06f          	j	4001f6b8 <net_route_lookup+0x58>
	return (struct net_route_entry *)nbr->data;
4001f6e0:	00c4a403          	lw	s0,12(s1)
			continue;
		}

		route = net_route_data(nbr);

		if (route->prefix_len >= longest_match &&
4001f6e4:	03044903          	lbu	s2,48(s0)
4001f6e8:	ff7962e3          	bltu	s2,s7,4001f6cc <net_route_lookup+0x6c>
	if (length > 128) {
4001f6ec:	08000793          	li	a5,128
4001f6f0:	fd27eee3          	bltu	a5,s2,4001f6cc <net_route_lookup+0x6c>
		    net_ipv6_is_prefix(dst->s6_addr,
				       route->addr.s6_addr,
4001f6f4:	02040a93          	addi	s5,s0,32
	if (memcmp(addr1, addr2, bytes)) {
4001f6f8:	00395c13          	srli	s8,s2,0x3
4001f6fc:	000c0613          	mv	a2,s8
4001f700:	000a8593          	mv	a1,s5
4001f704:	000a0513          	mv	a0,s4
4001f708:	d70ed0ef          	jal	ra,4000cc78 <memcmp>
4001f70c:	fc0510e3          	bnez	a0,4001f6cc <net_route_lookup+0x6c>
4001f710:	41200933          	neg	s2,s2
4001f714:	00797913          	andi	s2,s2,7
	if (!remain) {
4001f718:	02090c63          	beqz	s2,4001f750 <net_route_lookup+0xf0>
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
4001f71c:	018a07b3          	add	a5,s4,s8
4001f720:	018a8ab3          	add	s5,s5,s8
4001f724:	0007c783          	lbu	a5,0(a5)
4001f728:	000ac703          	lbu	a4,0(s5)
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
4001f72c:	00800693          	li	a3,8
4001f730:	412686b3          	sub	a3,a3,s2
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
4001f734:	00e7c733          	xor	a4,a5,a4
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
4001f738:	0ff00793          	li	a5,255
4001f73c:	00d797b3          	sll	a5,a5,a3
4001f740:	0ff7c793          	xori	a5,a5,255
4001f744:	012797b3          	sll	a5,a5,s2
		if (route->prefix_len >= longest_match &&
4001f748:	00f777b3          	and	a5,a4,a5
4001f74c:	f80790e3          	bnez	a5,4001f6cc <net_route_lookup+0x6c>
				       route->prefix_len)) {
			found = route;
			longest_match = route->prefix_len;
4001f750:	03044b83          	lbu	s7,48(s0)
	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
4001f754:	01948a63          	beq	s1,s9,4001f768 <net_route_lookup+0x108>
4001f758:	018b9793          	slli	a5,s7,0x18
4001f75c:	4187d793          	srai	a5,a5,0x18
4001f760:	04848493          	addi	s1,s1,72
4001f764:	f607dae3          	bgez	a5,4001f6d8 <net_route_lookup+0x78>
		}
	}

	if (found) {
4001f768:	02040863          	beqz	s0,4001f798 <net_route_lookup+0x138>
	sys_slist_find_and_remove(&routes, &route->node);
4001f76c:	400394b7          	lui	s1,0x40039
4001f770:	00040593          	mv	a1,s0
4001f774:	0b848513          	addi	a0,s1,184 # 400390b8 <routes>
4001f778:	e0dff0ef          	jal	ra,4001f584 <sys_slist_find_and_remove.isra.0>
	return list->head;
4001f77c:	0b848793          	addi	a5,s1,184
4001f780:	0007a703          	lw	a4,0(a5)
	parent->next = child;
4001f784:	00e42023          	sw	a4,0(s0)
Z_GENLIST_PREPEND(slist, snode)
4001f788:	0047a703          	lw	a4,4(a5)
	list->head = node;
4001f78c:	0087a023          	sw	s0,0(a5)
Z_GENLIST_PREPEND(slist, snode)
4001f790:	00071463          	bnez	a4,4001f798 <net_route_lookup+0x138>
	list->tail = node;
4001f794:	0087a223          	sw	s0,4(a5)
		net_route_info("Found", found, dst);

		update_route_access(found);
	}

	k_mutex_unlock(&lock);
4001f798:	de1ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>
	return found;
}
4001f79c:	02c12083          	lw	ra,44(sp)
4001f7a0:	00040513          	mv	a0,s0
4001f7a4:	02812403          	lw	s0,40(sp)
4001f7a8:	02412483          	lw	s1,36(sp)
4001f7ac:	02012903          	lw	s2,32(sp)
4001f7b0:	01c12983          	lw	s3,28(sp)
4001f7b4:	01812a03          	lw	s4,24(sp)
4001f7b8:	01412a83          	lw	s5,20(sp)
4001f7bc:	01012b03          	lw	s6,16(sp)
4001f7c0:	00c12b83          	lw	s7,12(sp)
4001f7c4:	00812c03          	lw	s8,8(sp)
4001f7c8:	00412c83          	lw	s9,4(sp)
4001f7cc:	03010113          	addi	sp,sp,48
4001f7d0:	00008067          	ret
	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
4001f7d4:	000b0413          	mv	s0,s6
4001f7d8:	f91ff06f          	j	4001f768 <net_route_lookup+0x108>

4001f7dc <net_route_update_lifetime>:
{
	NET_DBG("Updating route lifetime of %s to %u secs",
		net_sprint_ipv6_addr(&route->addr),
		lifetime);

	if (!route) {
4001f7dc:	0c050e63          	beqz	a0,4001f8b8 <net_route_update_lifetime+0xdc>
{
4001f7e0:	fe010113          	addi	sp,sp,-32
4001f7e4:	00912a23          	sw	s1,20(sp)
4001f7e8:	01312623          	sw	s3,12(sp)
4001f7ec:	00050493          	mv	s1,a0
4001f7f0:	00058993          	mv	s3,a1
		return;
	}

	k_mutex_lock(&lock, K_FOREVER);
4001f7f4:	fff00513          	li	a0,-1
4001f7f8:	fff00593          	li	a1,-1
{
4001f7fc:	00812c23          	sw	s0,24(sp)
4001f800:	01212823          	sw	s2,16(sp)
4001f804:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001f808:	d5dff0ef          	jal	ra,4001f564 <k_mutex_lock.constprop.0.isra.0>

	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
4001f80c:	fff00713          	li	a4,-1
4001f810:	0314c783          	lbu	a5,49(s1)
		route->is_infinite = true;

		(void)sys_slist_find_and_remove(&active_route_lifetime_timers,
4001f814:	01048913          	addi	s2,s1,16
4001f818:	40039437          	lui	s0,0x40039
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
4001f81c:	02e99a63          	bne	s3,a4,4001f850 <net_route_update_lifetime+0x74>
		route->is_infinite = true;
4001f820:	0047e793          	ori	a5,a5,4
4001f824:	02f488a3          	sb	a5,49(s1)
		(void)sys_slist_find_and_remove(&active_route_lifetime_timers,
4001f828:	00090593          	mv	a1,s2
4001f82c:	0b040513          	addi	a0,s0,176 # 400390b0 <active_route_lifetime_timers>
4001f830:	d55ff0ef          	jal	ra,4001f584 <sys_slist_find_and_remove.isra.0>
				 &route->lifetime.node);
		k_work_reschedule(&route_lifetime_timer, K_NO_WAIT);
	}

	k_mutex_unlock(&lock);
}
4001f834:	01812403          	lw	s0,24(sp)
4001f838:	01c12083          	lw	ra,28(sp)
4001f83c:	01412483          	lw	s1,20(sp)
4001f840:	01012903          	lw	s2,16(sp)
4001f844:	00c12983          	lw	s3,12(sp)
4001f848:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
4001f84c:	d2dff06f          	j	4001f578 <k_mutex_unlock.constprop.0.isra.0>
		route->is_infinite = false;
4001f850:	ffb7f793          	andi	a5,a5,-5
4001f854:	02f488a3          	sb	a5,49(s1)
	return z_impl_k_uptime_ticks();
4001f858:	5fd110ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
		net_timeout_set(&route->lifetime, lifetime, k_uptime_get_32());
4001f85c:	00a00613          	li	a2,10
4001f860:	02a60633          	mul	a2,a2,a0
4001f864:	00098593          	mv	a1,s3
4001f868:	00090513          	mv	a0,s2
4001f86c:	9bdf40ef          	jal	ra,40014228 <net_timeout_set>
		(void)sys_slist_find_and_remove(&active_route_lifetime_timers,
4001f870:	0b040513          	addi	a0,s0,176
4001f874:	00090593          	mv	a1,s2
4001f878:	d0dff0ef          	jal	ra,4001f584 <sys_slist_find_and_remove.isra.0>
	return list->tail;
4001f87c:	0b040513          	addi	a0,s0,176
4001f880:	00452783          	lw	a5,4(a0)
	parent->next = child;
4001f884:	0004a823          	sw	zero,16(s1)
Z_GENLIST_APPEND(slist, snode)
4001f888:	02079263          	bnez	a5,4001f8ac <net_route_update_lifetime+0xd0>
	list->tail = node;
4001f88c:	01252223          	sw	s2,4(a0)
	list->head = node;
4001f890:	01252023          	sw	s2,0(a0)
		k_work_reschedule(&route_lifetime_timer, K_NO_WAIT);
4001f894:	4003a537          	lui	a0,0x4003a
4001f898:	00000593          	li	a1,0
4001f89c:	00000613          	li	a2,0
4001f8a0:	c4050513          	addi	a0,a0,-960 # 40039c40 <route_lifetime_timer>
4001f8a4:	0b1100ef          	jal	ra,40030154 <k_work_reschedule>
4001f8a8:	f8dff06f          	j	4001f834 <net_route_update_lifetime+0x58>
	parent->next = child;
4001f8ac:	0127a023          	sw	s2,0(a5)
	list->tail = node;
4001f8b0:	01252223          	sw	s2,4(a0)
}
4001f8b4:	fe1ff06f          	j	4001f894 <net_route_update_lifetime+0xb8>
4001f8b8:	00008067          	ret

4001f8bc <net_route_del>:
	struct net_route_nexthop *nexthop_route;
#if defined(CONFIG_NET_MGMT_EVENT_INFO)
       struct net_event_ipv6_route info;
#endif

	if (!route) {
4001f8bc:	0e050063          	beqz	a0,4001f99c <net_route_del+0xe0>
{
4001f8c0:	ff010113          	addi	sp,sp,-16
4001f8c4:	00812423          	sw	s0,8(sp)
		return -EINVAL;
	}

	k_mutex_lock(&lock, K_FOREVER);
4001f8c8:	fff00593          	li	a1,-1
4001f8cc:	00050413          	mv	s0,a0
4001f8d0:	fff00513          	li	a0,-1
{
4001f8d4:	00112623          	sw	ra,12(sp)
4001f8d8:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001f8dc:	c89ff0ef          	jal	ra,4001f564 <k_mutex_lock.constprop.0.isra.0>
	net_mgmt_event_notify_with_info(mgmt_event, iface, NULL, 0);
4001f8e0:	00c42583          	lw	a1,12(s0)
4001f8e4:	e0600537          	lui	a0,0xe0600
4001f8e8:	00000693          	li	a3,0
4001f8ec:	00000613          	li	a2,0
4001f8f0:	00c50513          	addi	a0,a0,12 # e060000c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000d>
4001f8f4:	dd9f50ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
					sizeof(struct net_event_ipv6_route));
#else
	net_mgmt_event_notify(NET_EVENT_IPV6_ROUTE_DEL, route->iface);
#endif

	if (!route->is_infinite) {
4001f8f8:	03144783          	lbu	a5,49(s0)
4001f8fc:	0047f793          	andi	a5,a5,4
4001f900:	02079463          	bnez	a5,4001f928 <net_route_del+0x6c>
		sys_slist_find_and_remove(&active_route_lifetime_timers,
4001f904:	400394b7          	lui	s1,0x40039
4001f908:	01040593          	addi	a1,s0,16
4001f90c:	0b048513          	addi	a0,s1,176 # 400390b0 <active_route_lifetime_timers>
4001f910:	c75ff0ef          	jal	ra,4001f584 <sys_slist_find_and_remove.isra.0>
					  &route->lifetime.node);

		if (sys_slist_is_empty(&active_route_lifetime_timers)) {
4001f914:	0b04a783          	lw	a5,176(s1)
4001f918:	00079863          	bnez	a5,4001f928 <net_route_del+0x6c>
			k_work_cancel_delayable(&route_lifetime_timer);
4001f91c:	4003a537          	lui	a0,0x4003a
4001f920:	c4050513          	addi	a0,a0,-960 # 40039c40 <route_lifetime_timer>
4001f924:	049100ef          	jal	ra,4003016c <k_work_cancel_delayable>
		}
	}

	sys_slist_find_and_remove(&routes, &route->node);
4001f928:	40039537          	lui	a0,0x40039
4001f92c:	00040593          	mv	a1,s0
4001f930:	0b850513          	addi	a0,a0,184 # 400390b8 <routes>
4001f934:	c51ff0ef          	jal	ra,4001f584 <sys_slist_find_and_remove.isra.0>

	nbr = net_route_get_nbr(route);
4001f938:	00040513          	mv	a0,s0
4001f93c:	ca5ff0ef          	jal	ra,4001f5e0 <net_route_get_nbr>
4001f940:	00050493          	mv	s1,a0
	if (!nbr) {
4001f944:	02051063          	bnez	a0,4001f964 <net_route_del+0xa8>
		k_mutex_unlock(&lock);
4001f948:	c31ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>
		return -ENOENT;
4001f94c:	ffe00513          	li	a0,-2

	nbr_free(nbr);

	k_mutex_unlock(&lock);
	return 0;
}
4001f950:	00c12083          	lw	ra,12(sp)
4001f954:	00812403          	lw	s0,8(sp)
4001f958:	00412483          	lw	s1,4(sp)
4001f95c:	01010113          	addi	sp,sp,16
4001f960:	00008067          	ret
	return list->head;
4001f964:	00442403          	lw	s0,4(s0)
	SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route, node) {
4001f968:	00041c63          	bnez	s0,4001f980 <net_route_del+0xc4>
	net_nbr_unref(nbr);
4001f96c:	00048513          	mv	a0,s1
4001f970:	91dfb0ef          	jal	ra,4001b28c <net_nbr_unref>
	k_mutex_unlock(&lock);
4001f974:	c05ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>
	return 0;
4001f978:	00000513          	li	a0,0
4001f97c:	fd5ff06f          	j	4001f950 <net_route_del+0x94>
		if (!nexthop_route->nbr) {
4001f980:	00442503          	lw	a0,4(s0)
4001f984:	00050863          	beqz	a0,4001f994 <net_route_del+0xd8>
	net_nbr_unref(nbr);
4001f988:	905fb0ef          	jal	ra,4001b28c <net_nbr_unref>
	net_nbr_unref(nbr);
4001f98c:	fec40513          	addi	a0,s0,-20
4001f990:	8fdfb0ef          	jal	ra,4001b28c <net_nbr_unref>
	return node->next;
4001f994:	00042403          	lw	s0,0(s0)
4001f998:	fd1ff06f          	j	4001f968 <net_route_del+0xac>
		return -EINVAL;
4001f99c:	fea00513          	li	a0,-22
}
4001f9a0:	00008067          	ret

4001f9a4 <route_lifetime_timeout>:
{
4001f9a4:	fe010113          	addi	sp,sp,-32
4001f9a8:	00112e23          	sw	ra,28(sp)
4001f9ac:	00812c23          	sw	s0,24(sp)
4001f9b0:	00912a23          	sw	s1,20(sp)
4001f9b4:	01212823          	sw	s2,16(sp)
4001f9b8:	01312623          	sw	s3,12(sp)
4001f9bc:	01412423          	sw	s4,8(sp)
4001f9c0:	01512223          	sw	s5,4(sp)
4001f9c4:	491110ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
4001f9c8:	00050913          	mv	s2,a0
	k_mutex_lock(&lock, K_FOREVER);
4001f9cc:	fff00593          	li	a1,-1
4001f9d0:	fff00513          	li	a0,-1
	return list->head;
4001f9d4:	40039a37          	lui	s4,0x40039
4001f9d8:	b8dff0ef          	jal	ra,4001f564 <k_mutex_lock.constprop.0.isra.0>
4001f9dc:	0b0a2403          	lw	s0,176(s4) # 400390b0 <active_route_lifetime_timers>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_route_lifetime_timers,
4001f9e0:	0a040263          	beqz	s0,4001fa84 <route_lifetime_timeout+0xe0>
	return node->next;
4001f9e4:	00042483          	lw	s1,0(s0)
4001f9e8:	00048463          	beqz	s1,4001f9f0 <route_lifetime_timeout+0x4c>
4001f9ec:	ff048493          	addi	s1,s1,-16
			return t * ((uint64_t)to_hz / from_hz);
4001f9f0:	00a00993          	li	s3,10
4001f9f4:	032989b3          	mul	s3,s3,s2
4001f9f8:	ff040413          	addi	s0,s0,-16
4001f9fc:	fff00913          	li	s2,-1
4001fa00:	00c0006f          	j	4001fa0c <route_lifetime_timeout+0x68>
4001fa04:	00048413          	mv	s0,s1
4001fa08:	00078493          	mv	s1,a5
		struct net_timeout *timeout = &current->lifetime;
4001fa0c:	01040a93          	addi	s5,s0,16
		uint32_t this_update = net_timeout_evaluate(timeout,
4001fa10:	00098593          	mv	a1,s3
4001fa14:	000a8513          	mv	a0,s5
4001fa18:	911f40ef          	jal	ra,40014328 <net_timeout_evaluate>
		if (this_update == 0U) {
4001fa1c:	02051663          	bnez	a0,4001fa48 <route_lifetime_timeout+0xa4>
	sys_slist_find_and_remove(&active_route_lifetime_timers,
4001fa20:	0b0a0513          	addi	a0,s4,176
4001fa24:	000a8593          	mv	a1,s5
4001fa28:	b5dff0ef          	jal	ra,4001f584 <sys_slist_find_and_remove.isra.0>
	net_route_del(route);
4001fa2c:	00040513          	mv	a0,s0
4001fa30:	e8dff0ef          	jal	ra,4001f8bc <net_route_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_route_lifetime_timers,
4001fa34:	02048063          	beqz	s1,4001fa54 <route_lifetime_timeout+0xb0>
4001fa38:	0104a783          	lw	a5,16(s1)
4001fa3c:	fc0784e3          	beqz	a5,4001fa04 <route_lifetime_timeout+0x60>
4001fa40:	ff078793          	addi	a5,a5,-16
4001fa44:	fc1ff06f          	j	4001fa04 <route_lifetime_timeout+0x60>
		if (this_update < next_update) {
4001fa48:	ff2576e3          	bgeu	a0,s2,4001fa34 <route_lifetime_timeout+0x90>
4001fa4c:	00050913          	mv	s2,a0
4001fa50:	fe5ff06f          	j	4001fa34 <route_lifetime_timeout+0x90>
	if (next_update != UINT32_MAX) {
4001fa54:	fff00793          	li	a5,-1
4001fa58:	02f90663          	beq	s2,a5,4001fa84 <route_lifetime_timeout+0xe0>
		t += off;
4001fa5c:	00990513          	addi	a0,s2,9
			return t / ((uint64_t)from_hz / to_hz);
4001fa60:	00a00613          	li	a2,10
4001fa64:	00000693          	li	a3,0
4001fa68:	012535b3          	sltu	a1,a0,s2
4001fa6c:	84de00ef          	jal	ra,400002b8 <__udivdi3>
		k_work_reschedule(&route_lifetime_timer, K_MSEC(next_update));
4001fa70:	00058613          	mv	a2,a1
4001fa74:	00050593          	mv	a1,a0
4001fa78:	4003a537          	lui	a0,0x4003a
4001fa7c:	c4050513          	addi	a0,a0,-960 # 40039c40 <route_lifetime_timer>
4001fa80:	6d4100ef          	jal	ra,40030154 <k_work_reschedule>
}
4001fa84:	01812403          	lw	s0,24(sp)
4001fa88:	01c12083          	lw	ra,28(sp)
4001fa8c:	01412483          	lw	s1,20(sp)
4001fa90:	01012903          	lw	s2,16(sp)
4001fa94:	00c12983          	lw	s3,12(sp)
4001fa98:	00812a03          	lw	s4,8(sp)
4001fa9c:	00412a83          	lw	s5,4(sp)
4001faa0:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
4001faa4:	ad5ff06f          	j	4001f578 <k_mutex_unlock.constprop.0.isra.0>

4001faa8 <net_route_del_by_nexthop>:

int net_route_del_by_nexthop(struct net_if *iface, struct in6_addr *nexthop)
{
4001faa8:	fe010113          	addi	sp,sp,-32
4001faac:	00812c23          	sw	s0,24(sp)
4001fab0:	00912a23          	sw	s1,20(sp)
4001fab4:	00050413          	mv	s0,a0
4001fab8:	00058493          	mv	s1,a1
	int i, ret;

	NET_ASSERT(iface);
	NET_ASSERT(nexthop);

	k_mutex_lock(&lock, K_FOREVER);
4001fabc:	fff00513          	li	a0,-1
4001fac0:	fff00593          	li	a1,-1
{
4001fac4:	00112e23          	sw	ra,28(sp)
4001fac8:	01212823          	sw	s2,16(sp)
4001facc:	01312623          	sw	s3,12(sp)
4001fad0:	01412423          	sw	s4,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001fad4:	a91ff0ef          	jal	ra,4001f564 <k_mutex_lock.constprop.0.isra.0>

	nbr_nexthop = net_ipv6_nbr_lookup(iface, nexthop);
4001fad8:	00048593          	mv	a1,s1
4001fadc:	00040513          	mv	a0,s0
4001fae0:	400444b7          	lui	s1,0x40044
4001fae4:	fbdfc0ef          	jal	ra,4001caa0 <net_ipv6_nbr_lookup>
4001fae8:	35048493          	addi	s1,s1,848 # 40044350 <net_route_entries_pool>
4001faec:	00050913          	mv	s2,a0

	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
4001faf0:	24048a13          	addi	s4,s1,576
	int count = 0, status = 0;
4001faf4:	00000993          	li	s3,0
4001faf8:	00000413          	li	s0,0
	return (struct net_route_entry *)nbr->data;
4001fafc:	00c4a503          	lw	a0,12(s1)
		struct net_nbr *nbr = get_nbr(i);
		struct net_route_entry *route = net_route_data(nbr);

		if (!route) {
4001fb00:	02050063          	beqz	a0,4001fb20 <net_route_del_by_nexthop+0x78>
	return list->head;
4001fb04:	00452783          	lw	a5,4(a0)
			continue;
		}

		SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route,
4001fb08:	00078c63          	beqz	a5,4001fb20 <net_route_del_by_nexthop+0x78>
					     node) {
			if (nexthop_route->nbr == nbr_nexthop) {
4001fb0c:	0047a703          	lw	a4,4(a5)
4001fb10:	05271863          	bne	a4,s2,4001fb60 <net_route_del_by_nexthop+0xb8>
				/* This route contains this nexthop */
				ret = net_route_del(route);
4001fb14:	da9ff0ef          	jal	ra,4001f8bc <net_route_del>
				if (!ret) {
4001fb18:	04051863          	bnez	a0,4001fb68 <net_route_del_by_nexthop+0xc0>
					count++;
4001fb1c:	00140413          	addi	s0,s0,1
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
4001fb20:	04848493          	addi	s1,s1,72
4001fb24:	fd449ce3          	bne	s1,s4,4001fafc <net_route_del_by_nexthop+0x54>
				break;
			}
		}
	}

	k_mutex_unlock(&lock);
4001fb28:	a51ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>

	if (count) {
4001fb2c:	00041863          	bnez	s0,4001fb3c <net_route_del_by_nexthop+0x94>
		return count;
	} else if (status < 0) {
4001fb30:	00098413          	mv	s0,s3
4001fb34:	01305463          	blez	s3,4001fb3c <net_route_del_by_nexthop+0x94>
4001fb38:	00000413          	li	s0,0
		return status;
	}

	return 0;
}
4001fb3c:	01c12083          	lw	ra,28(sp)
4001fb40:	00040513          	mv	a0,s0
4001fb44:	01812403          	lw	s0,24(sp)
4001fb48:	01412483          	lw	s1,20(sp)
4001fb4c:	01012903          	lw	s2,16(sp)
4001fb50:	00c12983          	lw	s3,12(sp)
4001fb54:	00812a03          	lw	s4,8(sp)
4001fb58:	02010113          	addi	sp,sp,32
4001fb5c:	00008067          	ret
	return node->next;
4001fb60:	0007a783          	lw	a5,0(a5)
4001fb64:	fa5ff06f          	j	4001fb08 <net_route_del_by_nexthop+0x60>
4001fb68:	00050993          	mv	s3,a0
4001fb6c:	fb5ff06f          	j	4001fb20 <net_route_del_by_nexthop+0x78>

4001fb70 <net_route_get_nexthop>:
struct in6_addr *net_route_get_nexthop(struct net_route_entry *route)
{
	struct net_route_nexthop *nexthop_route;
	struct net_ipv6_nbr_data *ipv6_nbr_data;

	if (!route) {
4001fb70:	0c050463          	beqz	a0,4001fc38 <net_route_get_nexthop+0xc8>
{
4001fb74:	fb010113          	addi	sp,sp,-80
4001fb78:	04812423          	sw	s0,72(sp)
		return NULL;
	}

	k_mutex_lock(&lock, K_FOREVER);
4001fb7c:	fff00593          	li	a1,-1
4001fb80:	00050413          	mv	s0,a0
4001fb84:	fff00513          	li	a0,-1
{
4001fb88:	04912223          	sw	s1,68(sp)
4001fb8c:	05212023          	sw	s2,64(sp)
4001fb90:	03312e23          	sw	s3,60(sp)
4001fb94:	03412c23          	sw	s4,56(sp)
4001fb98:	04112623          	sw	ra,76(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001fb9c:	9c9ff0ef          	jal	ra,4001f564 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4001fba0:	00442403          	lw	s0,4(s0)
			NET_ASSERT(addr);

			k_mutex_unlock(&lock);
			return addr;
		} else {
			NET_ERR("could not get neighbor data from next hop");
4001fba4:	400354b7          	lui	s1,0x40035
4001fba8:	00001937          	lui	s2,0x1
4001fbac:	400449b7          	lui	s3,0x40044
4001fbb0:	21048493          	addi	s1,s1,528 # 40035210 <CSWTCH.16862+0x18>
4001fbb4:	00200a13          	li	s4,2
4001fbb8:	04090913          	addi	s2,s2,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
	SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route, node) {
4001fbbc:	00041863          	bnez	s0,4001fbcc <net_route_get_nexthop+0x5c>
		}
	}

	k_mutex_unlock(&lock);
4001fbc0:	9b9ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>
		return NULL;
4001fbc4:	00000513          	li	a0,0
4001fbc8:	0200006f          	j	4001fbe8 <net_route_get_nexthop+0x78>
4001fbcc:	00442783          	lw	a5,4(s0)
4001fbd0:	00c7a503          	lw	a0,12(a5)
		if (ipv6_nbr_data) {
4001fbd4:	02050a63          	beqz	a0,4001fc08 <net_route_get_nexthop+0x98>
			addr = &ipv6_nbr_data->addr;
4001fbd8:	00450513          	addi	a0,a0,4
4001fbdc:	00a12623          	sw	a0,12(sp)
			k_mutex_unlock(&lock);
4001fbe0:	999ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>
			return addr;
4001fbe4:	00c12503          	lw	a0,12(sp)
	return NULL;
}
4001fbe8:	04c12083          	lw	ra,76(sp)
4001fbec:	04812403          	lw	s0,72(sp)
4001fbf0:	04412483          	lw	s1,68(sp)
4001fbf4:	04012903          	lw	s2,64(sp)
4001fbf8:	03c12983          	lw	s3,60(sp)
4001fbfc:	03812a03          	lw	s4,56(sp)
4001fc00:	05010113          	addi	sp,sp,80
4001fc04:	00008067          	ret
			NET_ERR("could not get neighbor data from next hop");
4001fc08:	7909a783          	lw	a5,1936(s3) # 40044790 <log_dynamic_net_route>
4001fc0c:	0077f793          	andi	a5,a5,7
4001fc10:	02078063          	beqz	a5,4001fc30 <net_route_get_nexthop+0xc0>
4001fc14:	02912623          	sw	s1,44(sp)
4001fc18:	03412423          	sw	s4,40(sp)
4001fc1c:	00000693          	li	a3,0
4001fc20:	02810613          	addi	a2,sp,40
4001fc24:	00090593          	mv	a1,s2
4001fc28:	79098513          	addi	a0,s3,1936
4001fc2c:	b68e50ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
	return node->next;
4001fc30:	00042403          	lw	s0,0(s0)
4001fc34:	f89ff06f          	j	4001fbbc <net_route_get_nexthop+0x4c>
		return NULL;
4001fc38:	00000513          	li	a0,0
}
4001fc3c:	00008067          	ret

4001fc40 <net_route_add>:
{
4001fc40:	fc010113          	addi	sp,sp,-64
4001fc44:	02112e23          	sw	ra,60(sp)
4001fc48:	02812c23          	sw	s0,56(sp)
4001fc4c:	02912a23          	sw	s1,52(sp)
4001fc50:	03212823          	sw	s2,48(sp)
4001fc54:	03312623          	sw	s3,44(sp)
4001fc58:	03412423          	sw	s4,40(sp)
4001fc5c:	03512223          	sw	s5,36(sp)
4001fc60:	03612023          	sw	s6,32(sp)
4001fc64:	00058a93          	mv	s5,a1
4001fc68:	00060b13          	mv	s6,a2
4001fc6c:	00068993          	mv	s3,a3
4001fc70:	00070a13          	mv	s4,a4
4001fc74:	00078493          	mv	s1,a5
4001fc78:	00050913          	mv	s2,a0
	if (net_ipv6_addr_cmp(addr, net_ipv6_unspecified_address())) {
4001fc7c:	f8cf50ef          	jal	ra,40015408 <net_ipv6_unspecified_address>
4001fc80:	00050593          	mv	a1,a0
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4001fc84:	01000613          	li	a2,16
4001fc88:	000a8513          	mv	a0,s5
4001fc8c:	fedec0ef          	jal	ra,4000cc78 <memcmp>
		return NULL;
4001fc90:	00000413          	li	s0,0
	if (net_ipv6_addr_cmp(addr, net_ipv6_unspecified_address())) {
4001fc94:	08050263          	beqz	a0,4001fd18 <net_route_add+0xd8>
	k_mutex_lock(&lock, K_FOREVER);
4001fc98:	fff00513          	li	a0,-1
4001fc9c:	fff00593          	li	a1,-1
4001fca0:	8c5ff0ef          	jal	ra,4001f564 <k_mutex_lock.constprop.0.isra.0>
	nbr_nexthop = net_ipv6_nbr_lookup(iface, nexthop);
4001fca4:	00098593          	mv	a1,s3
4001fca8:	00090513          	mv	a0,s2
4001fcac:	df5fc0ef          	jal	ra,4001caa0 <net_ipv6_nbr_lookup>
	if (!nbr_nexthop) {
4001fcb0:	14050c63          	beqz	a0,4001fe08 <net_route_add+0x1c8>
	if (nbr_nexthop && nbr_nexthop->idx != NET_NBR_LLADDR_UNKNOWN) {
4001fcb4:	00154503          	lbu	a0,1(a0)
4001fcb8:	0ff00793          	li	a5,255
4001fcbc:	00f50463          	beq	a0,a5,4001fcc4 <net_route_add+0x84>
		nexthop_lladdr = net_nbr_get_lladdr(nbr_nexthop->idx);
4001fcc0:	845fb0ef          	jal	ra,4001b504 <net_nbr_get_lladdr>
	route = net_route_lookup(iface, addr);
4001fcc4:	000a8593          	mv	a1,s5
4001fcc8:	00090513          	mv	a0,s2
4001fccc:	995ff0ef          	jal	ra,4001f660 <net_route_lookup>
4001fcd0:	00050413          	mv	s0,a0
	if (route) {
4001fcd4:	0a050463          	beqz	a0,4001fd7c <net_route_add+0x13c>
		nexthop_addr = net_route_get_nexthop(route);
4001fcd8:	e99ff0ef          	jal	ra,4001fb70 <net_route_get_nexthop>
4001fcdc:	00050593          	mv	a1,a0
		if (nexthop_addr && net_ipv6_addr_cmp(nexthop, nexthop_addr)) {
4001fce0:	06050263          	beqz	a0,4001fd44 <net_route_add+0x104>
4001fce4:	01000613          	li	a2,16
4001fce8:	00098513          	mv	a0,s3
4001fcec:	f8dec0ef          	jal	ra,4000cc78 <memcmp>
4001fcf0:	04051a63          	bnez	a0,4001fd44 <net_route_add+0x104>
			net_route_update_lifetime(route, lifetime);
4001fcf4:	000a0593          	mv	a1,s4
4001fcf8:	00040513          	mv	a0,s0
4001fcfc:	ae1ff0ef          	jal	ra,4001f7dc <net_route_update_lifetime>
			route->preference = preference;
4001fd00:	03144783          	lbu	a5,49(s0)
4001fd04:	0034f493          	andi	s1,s1,3
4001fd08:	ffc7f793          	andi	a5,a5,-4
4001fd0c:	0097e4b3          	or	s1,a5,s1
4001fd10:	029408a3          	sb	s1,49(s0)
	k_mutex_unlock(&lock);
4001fd14:	865ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>
}
4001fd18:	03c12083          	lw	ra,60(sp)
4001fd1c:	00040513          	mv	a0,s0
4001fd20:	03812403          	lw	s0,56(sp)
4001fd24:	03412483          	lw	s1,52(sp)
4001fd28:	03012903          	lw	s2,48(sp)
4001fd2c:	02c12983          	lw	s3,44(sp)
4001fd30:	02812a03          	lw	s4,40(sp)
4001fd34:	02412a83          	lw	s5,36(sp)
4001fd38:	02012b03          	lw	s6,32(sp)
4001fd3c:	04010113          	addi	sp,sp,64
4001fd40:	00008067          	ret
		if (route_preference_is_lower(route->preference, preference)) {
4001fd44:	03042783          	lw	a5,48(s0)
	if (new == NET_ROUTE_PREFERENCE_RESERVED || (new & 0xfc) != 0) {
4001fd48:	00200713          	li	a4,2
		if (route_preference_is_lower(route->preference, preference)) {
4001fd4c:	0087d793          	srli	a5,a5,0x8
4001fd50:	0037f793          	andi	a5,a5,3
	if (new == NET_ROUTE_PREFERENCE_RESERVED || (new & 0xfc) != 0) {
4001fd54:	0ae48a63          	beq	s1,a4,4001fe08 <net_route_add+0x1c8>
4001fd58:	00300713          	li	a4,3
4001fd5c:	0a976663          	bltu	a4,s1,4001fe08 <net_route_add+0x1c8>
	old = (old + 1) & 0x3;
4001fd60:	00178793          	addi	a5,a5,1
	new = (new + 1) & 0x3;
4001fd64:	00148713          	addi	a4,s1,1
		if (route_preference_is_lower(route->preference, preference)) {
4001fd68:	0037f793          	andi	a5,a5,3
4001fd6c:	00377713          	andi	a4,a4,3
4001fd70:	08f76c63          	bltu	a4,a5,4001fe08 <net_route_add+0x1c8>
		net_route_del(route);
4001fd74:	00040513          	mv	a0,s0
4001fd78:	b45ff0ef          	jal	ra,4001f8bc <net_route_del>
	nbr = nbr_new(iface, addr, prefix_len);
4001fd7c:	000b0613          	mv	a2,s6
4001fd80:	000a8593          	mv	a1,s5
4001fd84:	00090513          	mv	a0,s2
4001fd88:	f5cff0ef          	jal	ra,4001f4e4 <nbr_new>
4001fd8c:	00050413          	mv	s0,a0
	if (!nbr) {
4001fd90:	08051063          	bnez	a0,4001fe10 <net_route_add+0x1d0>
	return list->tail;
4001fd94:	40039537          	lui	a0,0x40039
4001fd98:	0b850793          	addi	a5,a0,184 # 400390b8 <routes>
4001fd9c:	0047a403          	lw	s0,4(a5)
		sys_slist_find_and_remove(&routes, last);
4001fda0:	0b850513          	addi	a0,a0,184
4001fda4:	00040593          	mv	a1,s0
4001fda8:	fdcff0ef          	jal	ra,4001f584 <sys_slist_find_and_remove.isra.0>
		net_route_del(route);
4001fdac:	00040513          	mv	a0,s0
4001fdb0:	b0dff0ef          	jal	ra,4001f8bc <net_route_del>
		nbr = nbr_new(iface, addr, prefix_len);
4001fdb4:	000b0613          	mv	a2,s6
4001fdb8:	000a8593          	mv	a1,s5
4001fdbc:	00090513          	mv	a0,s2
4001fdc0:	f24ff0ef          	jal	ra,4001f4e4 <nbr_new>
4001fdc4:	00050413          	mv	s0,a0
		if (!nbr) {
4001fdc8:	04051463          	bnez	a0,4001fe10 <net_route_add+0x1d0>
			NET_ERR("Neighbor route alloc failed!");
4001fdcc:	40044537          	lui	a0,0x40044
4001fdd0:	79052783          	lw	a5,1936(a0) # 40044790 <log_dynamic_net_route>
4001fdd4:	0077f793          	andi	a5,a5,7
4001fdd8:	02078863          	beqz	a5,4001fe08 <net_route_add+0x1c8>
4001fddc:	400357b7          	lui	a5,0x40035
4001fde0:	23c78793          	addi	a5,a5,572 # 4003523c <CSWTCH.16862+0x44>
		NET_ERR("No nexthop route available!");
4001fde4:	00f12e23          	sw	a5,28(sp)
4001fde8:	00200793          	li	a5,2
4001fdec:	00f12c23          	sw	a5,24(sp)
4001fdf0:	000015b7          	lui	a1,0x1
4001fdf4:	00000693          	li	a3,0
4001fdf8:	01810613          	addi	a2,sp,24
4001fdfc:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4001fe00:	79050513          	addi	a0,a0,1936
4001fe04:	990e50ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
	struct net_route_entry *route = NULL;
4001fe08:	00000413          	li	s0,0
4001fe0c:	f09ff06f          	j	4001fd14 <net_route_add+0xd4>
			((sizeof(struct net_nbr) + start->size) * idx));
4001fe10:	400447b7          	lui	a5,0x40044
4001fe14:	59078713          	addi	a4,a5,1424 # 40044590 <net_route_nexthop_pool>
4001fe18:	00275703          	lhu	a4,2(a4)
4001fe1c:	59078513          	addi	a0,a5,1424
4001fe20:	00800793          	li	a5,8
4001fe24:	01470713          	addi	a4,a4,20
		if (!nbr->ref) {
4001fe28:	00054683          	lbu	a3,0(a0)
4001fe2c:	02069c63          	bnez	a3,4001fe64 <net_route_add+0x224>
			nbr->data = nbr->__nbr;
4001fe30:	01450793          	addi	a5,a0,20
4001fe34:	00f52623          	sw	a5,12(a0)
			nbr->idx = NET_NBR_LLADDR_UNKNOWN;
4001fe38:	fff00793          	li	a5,-1
4001fe3c:	00f500a3          	sb	a5,1(a0)
			return net_nbr_ref(nbr);
4001fe40:	c70fb0ef          	jal	ra,4001b2b0 <net_nbr_ref>
	if (!tmp) {
4001fe44:	02051863          	bnez	a0,4001fe74 <net_route_add+0x234>
		NET_ERR("No nexthop route available!");
4001fe48:	40044537          	lui	a0,0x40044
4001fe4c:	79052783          	lw	a5,1936(a0) # 40044790 <log_dynamic_net_route>
4001fe50:	0077f793          	andi	a5,a5,7
4001fe54:	fa078ae3          	beqz	a5,4001fe08 <net_route_add+0x1c8>
4001fe58:	400357b7          	lui	a5,0x40035
4001fe5c:	25c78793          	addi	a5,a5,604 # 4003525c <CSWTCH.16862+0x64>
4001fe60:	f85ff06f          	j	4001fde4 <net_route_add+0x1a4>
	for (i = 0; i < CONFIG_NET_MAX_NEXTHOPS; i++) {
4001fe64:	fff78793          	addi	a5,a5,-1
4001fe68:	00e50533          	add	a0,a0,a4
4001fe6c:	fa079ee3          	bnez	a5,4001fe28 <net_route_add+0x1e8>
4001fe70:	fd9ff06f          	j	4001fe48 <net_route_add+0x208>
	return (struct net_route_entry *)nbr->data;
4001fe74:	00c42403          	lw	s0,12(s0)
	route->preference = preference;
4001fe78:	0034f493          	andi	s1,s1,3
	return (struct net_route_nexthop *)nbr->data;
4001fe7c:	00c52a83          	lw	s5,12(a0)
	route->preference = preference;
4001fe80:	03144783          	lbu	a5,49(s0)
	route->iface = iface;
4001fe84:	01242623          	sw	s2,12(s0)
	net_route_update_lifetime(route, lifetime);
4001fe88:	000a0593          	mv	a1,s4
	route->preference = preference;
4001fe8c:	ffc7f793          	andi	a5,a5,-4
4001fe90:	0097e7b3          	or	a5,a5,s1
4001fe94:	02f408a3          	sb	a5,49(s0)
	net_route_update_lifetime(route, lifetime);
4001fe98:	00040513          	mv	a0,s0
4001fe9c:	941ff0ef          	jal	ra,4001f7dc <net_route_update_lifetime>
	return list->head;
4001fea0:	400397b7          	lui	a5,0x40039
4001fea4:	0b878793          	addi	a5,a5,184 # 400390b8 <routes>
4001fea8:	0007a703          	lw	a4,0(a5)
	parent->next = child;
4001feac:	00e42023          	sw	a4,0(s0)
Z_GENLIST_PREPEND(slist, snode)
4001feb0:	0047a703          	lw	a4,4(a5)
	list->head = node;
4001feb4:	0087a023          	sw	s0,0(a5)
Z_GENLIST_PREPEND(slist, snode)
4001feb8:	00071463          	bnez	a4,4001fec0 <net_route_add+0x280>
	list->tail = node;
4001febc:	0087a223          	sw	s0,4(a5)
	nbr = net_ipv6_nbr_lookup(iface, addr);
4001fec0:	00098593          	mv	a1,s3
4001fec4:	00090513          	mv	a0,s2
4001fec8:	bd9fc0ef          	jal	ra,4001caa0 <net_ipv6_nbr_lookup>
4001fecc:	00050493          	mv	s1,a0
	if (nbr == NULL) {
4001fed0:	00050463          	beqz	a0,4001fed8 <net_route_add+0x298>
	net_nbr_ref(nbr);
4001fed4:	bdcfb0ef          	jal	ra,4001b2b0 <net_nbr_ref>
	nexthop_route->nbr = tmp;
4001fed8:	009aa223          	sw	s1,4(s5)
	parent->next = child;
4001fedc:	000aa023          	sw	zero,0(s5)
4001fee0:	e0600537          	lui	a0,0xe0600
	list->head = node;
4001fee4:	01542223          	sw	s5,4(s0)
	list->tail = node;
4001fee8:	01542423          	sw	s5,8(s0)
4001feec:	00000693          	li	a3,0
4001fef0:	00000613          	li	a2,0
4001fef4:	00090593          	mv	a1,s2
4001fef8:	00b50513          	addi	a0,a0,11 # e060000b <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000c>
4001fefc:	fd0f50ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
}
4001ff00:	e15ff06f          	j	4001fd14 <net_route_add+0xd4>

4001ff04 <net_route_foreach>:

int net_route_foreach(net_route_cb_t cb, void *user_data)
{
4001ff04:	fe010113          	addi	sp,sp,-32
4001ff08:	00812c23          	sw	s0,24(sp)
4001ff0c:	40044437          	lui	s0,0x40044
4001ff10:	01212823          	sw	s2,16(sp)
4001ff14:	01312623          	sw	s3,12(sp)
4001ff18:	00050913          	mv	s2,a0
4001ff1c:	00058993          	mv	s3,a1
	int i, ret = 0;

	k_mutex_lock(&lock, K_FOREVER);
4001ff20:	fff00513          	li	a0,-1
4001ff24:	fff00593          	li	a1,-1
4001ff28:	35040413          	addi	s0,s0,848 # 40044350 <net_route_entries_pool>
{
4001ff2c:	00912a23          	sw	s1,20(sp)
4001ff30:	01412423          	sw	s4,8(sp)
4001ff34:	00112e23          	sw	ra,28(sp)
4001ff38:	24040a13          	addi	s4,s0,576
	k_mutex_lock(&lock, K_FOREVER);
4001ff3c:	e28ff0ef          	jal	ra,4001f564 <k_mutex_lock.constprop.0.isra.0>
	int i, ret = 0;
4001ff40:	00000493          	li	s1,0
		nbr = get_nbr(i);
		if (!nbr) {
			continue;
		}

		if (!nbr->ref) {
4001ff44:	00044783          	lbu	a5,0(s0)
4001ff48:	00078c63          	beqz	a5,4001ff60 <net_route_foreach+0x5c>
	return (struct net_route_entry *)nbr->data;
4001ff4c:	00c42503          	lw	a0,12(s0)
			continue;
		}

		route = net_route_data(nbr);
		if (!route) {
4001ff50:	00050863          	beqz	a0,4001ff60 <net_route_foreach+0x5c>
			continue;
		}

		cb(route, user_data);
4001ff54:	00098593          	mv	a1,s3
4001ff58:	000900e7          	jalr	s2

		ret++;
4001ff5c:	00148493          	addi	s1,s1,1
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
4001ff60:	04840413          	addi	s0,s0,72
4001ff64:	ff4410e3          	bne	s0,s4,4001ff44 <net_route_foreach+0x40>
	}

	k_mutex_unlock(&lock);
4001ff68:	e10ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>
	return ret;
}
4001ff6c:	01c12083          	lw	ra,28(sp)
4001ff70:	01812403          	lw	s0,24(sp)
4001ff74:	01012903          	lw	s2,16(sp)
4001ff78:	00c12983          	lw	s3,12(sp)
4001ff7c:	00812a03          	lw	s4,8(sp)
4001ff80:	00048513          	mv	a0,s1
4001ff84:	01412483          	lw	s1,20(sp)
4001ff88:	02010113          	addi	sp,sp,32
4001ff8c:	00008067          	ret

4001ff90 <net_route_get_info>:

bool net_route_get_info(struct net_if *iface,
			struct in6_addr *dst,
			struct net_route_entry **route,
			struct in6_addr **nexthop)
{
4001ff90:	fd010113          	addi	sp,sp,-48
4001ff94:	02812423          	sw	s0,40(sp)
4001ff98:	01312e23          	sw	s3,28(sp)
4001ff9c:	00058413          	mv	s0,a1
4001ffa0:	00050993          	mv	s3,a0
	struct net_if_router *router;
	bool ret = false;

	k_mutex_lock(&lock, K_FOREVER);
4001ffa4:	fff00593          	li	a1,-1
4001ffa8:	fff00513          	li	a0,-1
{
4001ffac:	02912223          	sw	s1,36(sp)
4001ffb0:	03212023          	sw	s2,32(sp)
4001ffb4:	02112623          	sw	ra,44(sp)
4001ffb8:	00060913          	mv	s2,a2
4001ffbc:	00068493          	mv	s1,a3
	k_mutex_lock(&lock, K_FOREVER);
4001ffc0:	da4ff0ef          	jal	ra,4001f564 <k_mutex_lock.constprop.0.isra.0>

	/* Search in neighbor table first, if not search in routing table. */
	if (net_ipv6_nbr_lookup(iface, dst)) {
4001ffc4:	00040593          	mv	a1,s0
4001ffc8:	00098513          	mv	a0,s3
4001ffcc:	ad5fc0ef          	jal	ra,4001caa0 <net_ipv6_nbr_lookup>
4001ffd0:	00050a63          	beqz	a0,4001ffe4 <net_route_get_info+0x54>
		/* Found nexthop, no need to look into routing table. */
		*route = NULL;
4001ffd4:	00092023          	sw	zero,0(s2)
		router = net_if_ipv6_router_find_default(NULL, dst);
		if (!router) {
			goto exit;
		}

		*nexthop = &router->address.in6_addr;
4001ffd8:	0084a023          	sw	s0,0(s1)
		ret = true;
4001ffdc:	00100513          	li	a0,1
4001ffe0:	0240006f          	j	40020004 <net_route_get_info+0x74>
	*route = net_route_lookup(iface, dst);
4001ffe4:	00040593          	mv	a1,s0
4001ffe8:	00098513          	mv	a0,s3
4001ffec:	e74ff0ef          	jal	ra,4001f660 <net_route_lookup>
4001fff0:	00a92023          	sw	a0,0(s2)
	if (*route) {
4001fff4:	02050c63          	beqz	a0,4002002c <net_route_get_info+0x9c>
		*nexthop = net_route_get_nexthop(*route);
4001fff8:	b79ff0ef          	jal	ra,4001fb70 <net_route_get_nexthop>
4001fffc:	00a4a023          	sw	a0,0(s1)
		if (!*nexthop) {
40020000:	00a03533          	snez	a0,a0
40020004:	00a12623          	sw	a0,12(sp)
		ret = true;
		goto exit;
	}

exit:
	k_mutex_unlock(&lock);
40020008:	d70ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>
	return ret;
}
4002000c:	02c12083          	lw	ra,44(sp)
40020010:	02812403          	lw	s0,40(sp)
40020014:	00c12503          	lw	a0,12(sp)
40020018:	02412483          	lw	s1,36(sp)
4002001c:	02012903          	lw	s2,32(sp)
40020020:	01c12983          	lw	s3,28(sp)
40020024:	03010113          	addi	sp,sp,48
40020028:	00008067          	ret
		router = net_if_ipv6_router_find_default(NULL, dst);
4002002c:	00040593          	mv	a1,s0
40020030:	ab1f20ef          	jal	ra,40012ae0 <net_if_ipv6_router_find_default>
40020034:	00050413          	mv	s0,a0
	bool ret = false;
40020038:	00000513          	li	a0,0
		if (!router) {
4002003c:	fc0404e3          	beqz	s0,40020004 <net_route_get_info+0x74>
		*nexthop = &router->address.in6_addr;
40020040:	00840413          	addi	s0,s0,8
		goto exit;
40020044:	f95ff06f          	j	4001ffd8 <net_route_get_info+0x48>

40020048 <net_route_packet>:

int net_route_packet(struct net_pkt *pkt, struct in6_addr *nexthop)
{
40020048:	fb010113          	addi	sp,sp,-80
4002004c:	04812423          	sw	s0,72(sp)
40020050:	04912223          	sw	s1,68(sp)
40020054:	00050413          	mv	s0,a0
40020058:	00058493          	mv	s1,a1
	struct net_linkaddr_storage *lladdr;
	struct net_nbr *nbr;
	int err;

	k_mutex_lock(&lock, K_FOREVER);
4002005c:	fff00513          	li	a0,-1
40020060:	fff00593          	li	a1,-1
{
40020064:	04112623          	sw	ra,76(sp)
40020068:	05212023          	sw	s2,64(sp)
4002006c:	03312e23          	sw	s3,60(sp)
	k_mutex_lock(&lock, K_FOREVER);
40020070:	cf4ff0ef          	jal	ra,4001f564 <k_mutex_lock.constprop.0.isra.0>

	nbr = net_ipv6_nbr_lookup(NULL, nexthop);
40020074:	00048593          	mv	a1,s1
40020078:	00000513          	li	a0,0
4002007c:	a25fc0ef          	jal	ra,4001caa0 <net_ipv6_nbr_lookup>
	if (!nbr) {
40020080:	12050663          	beqz	a0,400201ac <net_route_packet+0x164>
40020084:	00050913          	mv	s2,a0
			net_sprint_ipv6_addr(nexthop));
		err = -ENOENT;
		goto error;
	}

	lladdr = net_nbr_get_lladdr(nbr->idx);
40020088:	00154503          	lbu	a0,1(a0)
4002008c:	c78fb0ef          	jal	ra,4001b504 <net_nbr_get_lladdr>
40020090:	00050493          	mv	s1,a0
	if (!lladdr) {
40020094:	12050063          	beqz	a0,400201b4 <net_route_packet+0x16c>
#endif
#if defined(CONFIG_NET_L2_PPP)
		/* PPP does not populate the lladdr fields */
		if (net_if_l2(net_pkt_iface(pkt)) != &NET_L2_GET_NAME(PPP)) {
#endif
			if (!net_pkt_lladdr_src(pkt)->addr) {
40020098:	02442503          	lw	a0,36(s0)
4002009c:	04050a63          	beqz	a0,400200f0 <net_route_packet+0xa8>

			/* Sanitycheck: If src and dst ll addresses are going
			 * to be same, then something went wrong in route
			 * lookup.
			 */
			if (!memcmp(net_pkt_lladdr_src(pkt)->addr, lladdr->addr,
400200a0:	0014c603          	lbu	a2,1(s1)
400200a4:	00248993          	addi	s3,s1,2
400200a8:	00098593          	mv	a1,s3
400200ac:	bcdec0ef          	jal	ra,4000cc78 <memcmp>
400200b0:	06051663          	bnez	a0,4002011c <net_route_packet+0xd4>
				    lladdr->len)) {
				NET_ERR("Src ll and Dst ll are same");
400200b4:	40044537          	lui	a0,0x40044
400200b8:	79052783          	lw	a5,1936(a0) # 40044790 <log_dynamic_net_route>
400200bc:	0077f793          	andi	a5,a5,7
400200c0:	02078863          	beqz	a5,400200f0 <net_route_packet+0xa8>
400200c4:	400357b7          	lui	a5,0x40035
400200c8:	27878793          	addi	a5,a5,632 # 40035278 <CSWTCH.16862+0x80>
400200cc:	02f12623          	sw	a5,44(sp)
400200d0:	00200793          	li	a5,2
400200d4:	02f12423          	sw	a5,40(sp)
400200d8:	000015b7          	lui	a1,0x1
400200dc:	00000693          	li	a3,0
400200e0:	02810613          	addi	a2,sp,40
400200e4:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
400200e8:	79050513          	addi	a0,a0,1936
400200ec:	ea9e40ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
				err = -EINVAL;
400200f0:	fea00513          	li	a0,-22
400200f4:	00a12623          	sw	a0,12(sp)

	k_mutex_unlock(&lock);
	return net_send_data(pkt);

error:
	k_mutex_unlock(&lock);
400200f8:	c80ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>
	return err;
}
400200fc:	04c12083          	lw	ra,76(sp)
40020100:	04812403          	lw	s0,72(sp)
40020104:	00c12503          	lw	a0,12(sp)
40020108:	04412483          	lw	s1,68(sp)
4002010c:	04012903          	lw	s2,64(sp)
40020110:	03c12983          	lw	s3,60(sp)
40020114:	05010113          	addi	sp,sp,80
40020118:	00008067          	ret
	pkt->forwarding = forward;
4002011c:	03744783          	lbu	a5,55(s0)
40020120:	0107e793          	ori	a5,a5,16
40020124:	02f40ba3          	sb	a5,55(s0)
	return net_if_get_link_addr(pkt->iface);
40020128:	01842783          	lw	a5,24(s0)
	net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
4002012c:	0007a703          	lw	a4,0(a5)
40020130:	01072703          	lw	a4,16(a4)
40020134:	02e42223          	sw	a4,36(s0)
	net_pkt_lladdr_src(pkt)->type = net_pkt_lladdr_if(pkt)->type;
40020138:	0007a703          	lw	a4,0(a5)
4002013c:	01574703          	lbu	a4,21(a4)
40020140:	02e404a3          	sb	a4,41(s0)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
40020144:	0007a783          	lw	a5,0(a5)
40020148:	0147c783          	lbu	a5,20(a5)
	net_pkt_lladdr_dst(pkt)->addr = lladdr->addr;
4002014c:	03342623          	sw	s3,44(s0)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
40020150:	02f40423          	sb	a5,40(s0)
	net_pkt_lladdr_dst(pkt)->type = lladdr->type;
40020154:	0004c783          	lbu	a5,0(s1)
40020158:	02f408a3          	sb	a5,49(s0)
	net_pkt_lladdr_dst(pkt)->len = lladdr->len;
4002015c:	0014c783          	lbu	a5,1(s1)
40020160:	02f40823          	sb	a5,48(s0)
	net_pkt_set_iface(pkt, nbr->iface);
40020164:	00892783          	lw	a5,8(s2)
	pkt->iface = iface;
40020168:	00f42c23          	sw	a5,24(s0)
	if (iface) {
4002016c:	00078e63          	beqz	a5,40020188 <net_route_packet+0x140>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
40020170:	0007a703          	lw	a4,0(a5)
40020174:	01574703          	lbu	a4,21(a4)
40020178:	02e404a3          	sb	a4,41(s0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
4002017c:	0007a783          	lw	a5,0(a5)
40020180:	0157c783          	lbu	a5,21(a5)
40020184:	02f408a3          	sb	a5,49(s0)
	k_mutex_unlock(&lock);
40020188:	bf0ff0ef          	jal	ra,4001f578 <k_mutex_unlock.constprop.0.isra.0>
	return net_send_data(pkt);
4002018c:	00040513          	mv	a0,s0
}
40020190:	04812403          	lw	s0,72(sp)
40020194:	04c12083          	lw	ra,76(sp)
40020198:	04412483          	lw	s1,68(sp)
4002019c:	04012903          	lw	s2,64(sp)
400201a0:	03c12983          	lw	s3,60(sp)
400201a4:	05010113          	addi	sp,sp,80
	return net_send_data(pkt);
400201a8:	d04ef06f          	j	4000f6ac <net_send_data>
		err = -ENOENT;
400201ac:	ffe00513          	li	a0,-2
400201b0:	f45ff06f          	j	400200f4 <net_route_packet+0xac>
		err = -ESRCH;
400201b4:	ffd00513          	li	a0,-3
400201b8:	f3dff06f          	j	400200f4 <net_route_packet+0xac>

400201bc <net_route_packet_if>:
	pkt->iface = iface;
400201bc:	00b52c23          	sw	a1,24(a0)
	if (iface) {
400201c0:	00058e63          	beqz	a1,400201dc <net_route_packet_if+0x20>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
400201c4:	0005a783          	lw	a5,0(a1)
400201c8:	0157c783          	lbu	a5,21(a5)
400201cc:	02f504a3          	sb	a5,41(a0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
400201d0:	0005a783          	lw	a5,0(a1)
400201d4:	0157c783          	lbu	a5,21(a5)
400201d8:	02f508a3          	sb	a5,49(a0)
	pkt->forwarding = forward;
400201dc:	03754783          	lbu	a5,55(a0)
400201e0:	0107e793          	ori	a5,a5,16
400201e4:	02f50ba3          	sb	a5,55(a0)
	net_pkt_set_orig_iface(pkt, net_pkt_iface(pkt));
	net_pkt_set_iface(pkt, iface);

	net_pkt_set_forwarding(pkt, true);

	net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
400201e8:	0005a783          	lw	a5,0(a1)
400201ec:	0107a783          	lw	a5,16(a5)
400201f0:	02f52223          	sw	a5,36(a0)
	net_pkt_lladdr_src(pkt)->type = net_pkt_lladdr_if(pkt)->type;
400201f4:	0005a783          	lw	a5,0(a1)
400201f8:	0157c783          	lbu	a5,21(a5)
400201fc:	02f504a3          	sb	a5,41(a0)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
40020200:	0005a783          	lw	a5,0(a1)
40020204:	0147c783          	lbu	a5,20(a5)
40020208:	02f50423          	sb	a5,40(a0)

	return net_send_data(pkt);
4002020c:	ca0ef06f          	j	4000f6ac <net_send_data>

40020210 <net_route_init>:
		CONFIG_NET_MAX_ROUTES, sizeof(net_route_entries_pool));

	NET_DBG("Allocated %d nexthop entries (%zu bytes)",
		CONFIG_NET_MAX_NEXTHOPS, sizeof(net_route_nexthop_pool));

	k_work_init_delayable(&route_lifetime_timer, route_lifetime_timeout);
40020210:	400205b7          	lui	a1,0x40020
40020214:	4003a537          	lui	a0,0x4003a
40020218:	9a458593          	addi	a1,a1,-1628 # 4001f9a4 <route_lifetime_timeout>
4002021c:	c4050513          	addi	a0,a0,-960 # 40039c40 <route_lifetime_timer>
40020220:	5e50f06f          	j	40030004 <k_work_init_delayable>

40020224 <net_stats_reset>:

#endif /* CONFIG_NET_STATISTICS_USER_API */

void net_stats_reset(struct net_if *iface)
{
	if (iface) {
40020224:	00050463          	beqz	a0,4002022c <net_stats_reset+0x8>
		net_if_stats_reset(iface);
40020228:	9d9f006f          	j	40010c00 <net_if_stats_reset>
{
4002022c:	ff010113          	addi	sp,sp,-16
40020230:	00112623          	sw	ra,12(sp)
		return;
	}

	net_if_stats_reset_all();
40020234:	a01f00ef          	jal	ra,40010c34 <net_if_stats_reset_all>
	memset(&net_stats, 0, sizeof(net_stats));
}
40020238:	00c12083          	lw	ra,12(sp)
	memset(&net_stats, 0, sizeof(net_stats));
4002023c:	4003b537          	lui	a0,0x4003b
40020240:	0b800613          	li	a2,184
40020244:	00000593          	li	a1,0
40020248:	ed050513          	addi	a0,a0,-304 # 4003aed0 <net_stats>
}
4002024c:	01010113          	addi	sp,sp,16
	memset(&net_stats, 0, sizeof(net_stats));
40020250:	acdec06f          	j	4000cd1c <memset>

40020254 <sys_slist_get>:
Z_GENLIST_GET(slist, snode)
40020254:	00050793          	mv	a5,a0
	return list->head;
40020258:	00052503          	lw	a0,0(a0)
Z_GENLIST_GET(slist, snode)
4002025c:	00050c63          	beqz	a0,40020274 <sys_slist_get+0x20>
	return node->next;
40020260:	00052703          	lw	a4,0(a0)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
40020264:	0047a683          	lw	a3,4(a5)
	list->head = node;
40020268:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
4002026c:	00d51463          	bne	a0,a3,40020274 <sys_slist_get+0x20>
	list->tail = node;
40020270:	00e7a223          	sw	a4,4(a5)
Z_GENLIST_GET(slist, snode)
40020274:	00008067          	ret

40020278 <tcp_validate_seq>:
	return conn;
}

static bool tcp_validate_seq(struct tcp *conn, struct tcphdr *hdr)
{
	return (net_tcp_seq_cmp(th_seq(hdr), conn->ack) >= 0) &&
40020278:	0055c783          	lbu	a5,5(a1)
4002027c:	0045c703          	lbu	a4,4(a1)
40020280:	00010637          	lui	a2,0x10
40020284:	00879793          	slli	a5,a5,0x8
40020288:	00e7e7b3          	or	a5,a5,a4
4002028c:	0065c703          	lbu	a4,6(a1)
40020290:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
40020294:	01071713          	slli	a4,a4,0x10
40020298:	00f76733          	or	a4,a4,a5
4002029c:	0075c783          	lbu	a5,7(a1)
400202a0:	01879793          	slli	a5,a5,0x18
400202a4:	00e7e6b3          	or	a3,a5,a4
400202a8:	01871713          	slli	a4,a4,0x18
400202ac:	0187d793          	srli	a5,a5,0x18
400202b0:	00e7e7b3          	or	a5,a5,a4
400202b4:	0086d713          	srli	a4,a3,0x8
400202b8:	00c77733          	and	a4,a4,a2
400202bc:	00e7e7b3          	or	a5,a5,a4
400202c0:	00869693          	slli	a3,a3,0x8
400202c4:	00ff0737          	lui	a4,0xff0
400202c8:	00e6f6b3          	and	a3,a3,a4
400202cc:	00d7e7b3          	or	a5,a5,a3
400202d0:	22c52683          	lw	a3,556(a0)
 *
 * @return < 0 if seq1 < seq2, 0 if seq1 == seq2, > 0 if seq > seq2
 */
static inline int32_t net_tcp_seq_cmp(uint32_t seq1, uint32_t seq2)
{
	return (int32_t)(seq1 - seq2);
400202d4:	40d78733          	sub	a4,a5,a3
400202d8:	00074c63          	bltz	a4,400202f0 <tcp_validate_seq+0x78>
		(net_tcp_seq_cmp(th_seq(hdr), conn->ack + conn->recv_win) < 0);
400202dc:	23255703          	lhu	a4,562(a0)
400202e0:	00d70733          	add	a4,a4,a3
400202e4:	40e78533          	sub	a0,a5,a4
	return (net_tcp_seq_cmp(th_seq(hdr), conn->ack) >= 0) &&
400202e8:	01f55513          	srli	a0,a0,0x1f
400202ec:	00008067          	ret
400202f0:	00000513          	li	a0,0
}
400202f4:	00008067          	ret

400202f8 <tcp_derive_rto>:
{
400202f8:	fe010113          	addi	sp,sp,-32
400202fc:	00812c23          	sw	s0,24(sp)
40020300:	00112e23          	sw	ra,28(sp)
40020304:	00050413          	mv	s0,a0
		(void) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_SYS_RAND_GET);
		return;
	}
#endif
	compiler_barrier();
	z_impl_sys_rand_get(dst, len);
40020308:	00100593          	li	a1,1
4002030c:	00f10513          	addi	a0,sp,15
40020310:	f55ec0ef          	jal	ra,4000d264 <z_impl_sys_rand_get>
	gain = (uint32_t)gain8;
40020314:	00f14783          	lbu	a5,15(sp)
	rto = (gain * rto) >> 9;
40020318:	0c800713          	li	a4,200
	gain += 1 << 9;
4002031c:	20078793          	addi	a5,a5,512
	rto = (gain * rto) >> 9;
40020320:	02e787b3          	mul	a5,a5,a4
40020324:	0097d793          	srli	a5,a5,0x9
	conn->rto = (uint16_t)rto;
40020328:	22f41c23          	sh	a5,568(s0)
}
4002032c:	01c12083          	lw	ra,28(sp)
40020330:	01812403          	lw	s0,24(sp)
40020334:	02010113          	addi	sp,sp,32
40020338:	00008067          	ret

4002033c <is_destination_local>:
{
4002033c:	ff010113          	addi	sp,sp,-16
40020340:	00812423          	sw	s0,8(sp)
40020344:	00112623          	sw	ra,12(sp)
40020348:	00912223          	sw	s1,4(sp)
4002034c:	01212023          	sw	s2,0(sp)
	return pkt->family;
40020350:	03452783          	lw	a5,52(a0)
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
40020354:	00100713          	li	a4,1
{
40020358:	00050413          	mv	s0,a0
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
4002035c:	01d7d793          	srli	a5,a5,0x1d
40020360:	10e78c63          	beq	a5,a4,40020478 <is_destination_local+0x13c>
40020364:	03442783          	lw	a5,52(s0)
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
40020368:	00200713          	li	a4,2
	return false;
4002036c:	00000513          	li	a0,0
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
40020370:	01d7d793          	srli	a5,a5,0x1d
40020374:	10e79e63          	bne	a5,a4,40020490 <is_destination_local+0x154>
	return pkt->frags->data;
40020378:	00842783          	lw	a5,8(s0)
4002037c:	00c7a783          	lw	a5,12(a5)
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40020380:	0197c703          	lbu	a4,25(a5)
40020384:	0187c683          	lbu	a3,24(a5)
				(struct in6_addr *)NET_IPV6_HDR(pkt)->dst) ||
40020388:	01878513          	addi	a0,a5,24
4002038c:	00871713          	slli	a4,a4,0x8
40020390:	00d76733          	or	a4,a4,a3
40020394:	01a7c683          	lbu	a3,26(a5)
40020398:	01069693          	slli	a3,a3,0x10
4002039c:	00e6e6b3          	or	a3,a3,a4
400203a0:	01b7c703          	lbu	a4,27(a5)
400203a4:	01871713          	slli	a4,a4,0x18
400203a8:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
400203ac:	0a071e63          	bnez	a4,40020468 <is_destination_local+0x12c>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
400203b0:	01d7c703          	lbu	a4,29(a5)
400203b4:	01c7c683          	lbu	a3,28(a5)
400203b8:	00871713          	slli	a4,a4,0x8
400203bc:	00d76733          	or	a4,a4,a3
400203c0:	01e7c683          	lbu	a3,30(a5)
400203c4:	01069693          	slli	a3,a3,0x10
400203c8:	00e6e6b3          	or	a3,a3,a4
400203cc:	01f7c703          	lbu	a4,31(a5)
400203d0:	01871713          	slli	a4,a4,0x18
400203d4:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
400203d8:	08071863          	bnez	a4,40020468 <is_destination_local+0x12c>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
400203dc:	0217c703          	lbu	a4,33(a5)
400203e0:	0207c683          	lbu	a3,32(a5)
400203e4:	00871713          	slli	a4,a4,0x8
400203e8:	00d76733          	or	a4,a4,a3
400203ec:	0227c683          	lbu	a3,34(a5)
400203f0:	01069693          	slli	a3,a3,0x10
400203f4:	00e6e6b3          	or	a3,a3,a4
400203f8:	0237c703          	lbu	a4,35(a5)
400203fc:	01871713          	slli	a4,a4,0x18
40020400:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
40020404:	06071263          	bnez	a4,40020468 <is_destination_local+0x12c>
		ntohl(UNALIGNED_GET(&addr->s6_addr32[3])) == 1;
40020408:	0257c683          	lbu	a3,37(a5)
4002040c:	0247c703          	lbu	a4,36(a5)
40020410:	00010637          	lui	a2,0x10
40020414:	00869693          	slli	a3,a3,0x8
40020418:	00e6e6b3          	or	a3,a3,a4
4002041c:	0267c703          	lbu	a4,38(a5)
40020420:	0277c783          	lbu	a5,39(a5)
40020424:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
40020428:	01071713          	slli	a4,a4,0x10
4002042c:	00d76733          	or	a4,a4,a3
40020430:	01879793          	slli	a5,a5,0x18
40020434:	00e7e6b3          	or	a3,a5,a4
40020438:	01871713          	slli	a4,a4,0x18
4002043c:	0187d793          	srli	a5,a5,0x18
40020440:	00e7e7b3          	or	a5,a5,a4
40020444:	0086d713          	srli	a4,a3,0x8
40020448:	00c77733          	and	a4,a4,a2
4002044c:	00e7e7b3          	or	a5,a5,a4
40020450:	00869693          	slli	a3,a3,0x8
40020454:	00ff0737          	lui	a4,0xff0
40020458:	00e6f6b3          	and	a3,a3,a4
4002045c:	00d7e7b3          	or	a5,a5,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40020460:	00100713          	li	a4,1
40020464:	02e78463          	beq	a5,a4,4002048c <is_destination_local+0x150>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
40020468:	00000593          	li	a1,0
4002046c:	c45f00ef          	jal	ra,400110b0 <net_if_ipv6_addr_lookup>
40020470:	00a03533          	snez	a0,a0
40020474:	01c0006f          	j	40020490 <is_destination_local+0x154>
40020478:	00852783          	lw	a5,8(a0)
4002047c:	00c7a483          	lw	s1,12(a5)
		if (net_ipv4_is_addr_loopback(
40020480:	07f00793          	li	a5,127
40020484:	0104c703          	lbu	a4,16(s1)
40020488:	02f71063          	bne	a4,a5,400204a8 <is_destination_local+0x16c>
			return true;
4002048c:	00100513          	li	a0,1
}
40020490:	00c12083          	lw	ra,12(sp)
40020494:	00812403          	lw	s0,8(sp)
40020498:	00412483          	lw	s1,4(sp)
4002049c:	00012903          	lw	s2,0(sp)
400204a0:	01010113          	addi	sp,sp,16
400204a4:	00008067          	ret
				(struct in_addr *)NET_IPV4_HDR(pkt)->dst)) {
400204a8:	01048913          	addi	s2,s1,16
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
400204ac:	00000593          	li	a1,0
400204b0:	00090513          	mv	a0,s2
400204b4:	dfdf20ef          	jal	ra,400132b0 <net_if_ipv4_addr_lookup>
	if (!ret) {
400204b8:	fc051ae3          	bnez	a0,4002048c <is_destination_local+0x150>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
400204bc:	f41f40ef          	jal	ra,400153fc <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
400204c0:	0114c703          	lbu	a4,17(s1)
400204c4:	0104c783          	lbu	a5,16(s1)
400204c8:	00054683          	lbu	a3,0(a0)
400204cc:	00871713          	slli	a4,a4,0x8
400204d0:	00f76733          	or	a4,a4,a5
400204d4:	0124c783          	lbu	a5,18(s1)
400204d8:	01079793          	slli	a5,a5,0x10
400204dc:	00e7e7b3          	or	a5,a5,a4
400204e0:	0134c703          	lbu	a4,19(s1)
400204e4:	01871713          	slli	a4,a4,0x18
400204e8:	00f76733          	or	a4,a4,a5
400204ec:	00154783          	lbu	a5,1(a0)
400204f0:	00879793          	slli	a5,a5,0x8
400204f4:	00d7e7b3          	or	a5,a5,a3
400204f8:	00254683          	lbu	a3,2(a0)
400204fc:	01069693          	slli	a3,a3,0x10
40020500:	00f6e6b3          	or	a3,a3,a5
40020504:	00354783          	lbu	a5,3(a0)
40020508:	01879793          	slli	a5,a5,0x18
4002050c:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
40020510:	f6f70ee3          	beq	a4,a5,4002048c <is_destination_local+0x150>
	return net_if_ipv4_is_addr_bcast(iface, addr);
40020514:	00090593          	mv	a1,s2
40020518:	00000513          	li	a0,0
4002051c:	b59f20ef          	jal	ra,40013074 <net_if_ipv4_is_addr_bcast>
				(struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
40020520:	e40502e3          	beqz	a0,40020364 <is_destination_local+0x28>
40020524:	f69ff06f          	j	4002048c <is_destination_local+0x150>

40020528 <z_log_msg_static_create.constprop.0>:
40020528:	00000693          	li	a3,0
4002052c:	a69e406f          	j	40004f94 <z_impl_z_log_msg_static_create>

40020530 <tcp_unsent_len>:
	if (conn->unacked_len > conn->send_data_total) {
40020530:	21852703          	lw	a4,536(a0)
40020534:	21052783          	lw	a5,528(a0)
40020538:	08e7f263          	bgeu	a5,a4,400205bc <tcp_unsent_len+0x8c>
		NET_ERR("total=%zu, unacked_len=%d",
4002053c:	40044537          	lui	a0,0x40044
40020540:	7a052683          	lw	a3,1952(a0) # 400447a0 <log_dynamic_net_tcp>
40020544:	0076f693          	andi	a3,a3,7
40020548:	08068a63          	beqz	a3,400205dc <tcp_unsent_len+0xac>
{
4002054c:	ff010113          	addi	sp,sp,-16
40020550:	00812423          	sw	s0,8(sp)
40020554:	00912223          	sw	s1,4(sp)
40020558:	00112623          	sw	ra,12(sp)
4002055c:	01010413          	addi	s0,sp,16
		NET_ERR("total=%zu, unacked_len=%d",
40020560:	00010493          	mv	s1,sp
40020564:	fe010113          	addi	sp,sp,-32
40020568:	00010613          	mv	a2,sp
4002056c:	400356b7          	lui	a3,0x40035
40020570:	00f62c23          	sw	a5,24(a2)
40020574:	2ac68693          	addi	a3,a3,684 # 400352ac <CSWTCH.16862+0xb4>
40020578:	00400793          	li	a5,4
4002057c:	000025b7          	lui	a1,0x2
40020580:	00d62a23          	sw	a3,20(a2)
40020584:	00e62e23          	sw	a4,28(a2)
40020588:	00f62823          	sw	a5,16(a2)
4002058c:	7a050513          	addi	a0,a0,1952
40020590:	01060613          	addi	a2,a2,16
40020594:	04058593          	addi	a1,a1,64 # 2040 <CONFIG_SRAM_SIZE+0x40>
40020598:	f91ff0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
4002059c:	00048113          	mv	sp,s1
}
400205a0:	ff040113          	addi	sp,s0,-16
400205a4:	00c12083          	lw	ra,12(sp)
400205a8:	00812403          	lw	s0,8(sp)
400205ac:	00412483          	lw	s1,4(sp)
		unsent_len = -ERANGE;
400205b0:	fde00513          	li	a0,-34
}
400205b4:	01010113          	addi	sp,sp,16
400205b8:	00008067          	ret
	if (conn->unacked_len >= conn->send_win) {
400205bc:	23655683          	lhu	a3,566(a0)
		unsent_len = 0;
400205c0:	00000513          	li	a0,0
	if (conn->unacked_len >= conn->send_win) {
400205c4:	00d75e63          	bge	a4,a3,400205e0 <tcp_unsent_len+0xb0>
	unsent_len = conn->send_data_total - conn->unacked_len;
400205c8:	40e787b3          	sub	a5,a5,a4
		unsent_len = MIN(unsent_len, conn->send_win - conn->unacked_len);
400205cc:	40e68533          	sub	a0,a3,a4
400205d0:	00a7d863          	bge	a5,a0,400205e0 <tcp_unsent_len+0xb0>
400205d4:	00078513          	mv	a0,a5
400205d8:	00008067          	ret
		unsent_len = -ERANGE;
400205dc:	fde00513          	li	a0,-34
}
400205e0:	00008067          	ret

400205e4 <tcp_send>:
{
400205e4:	fd010113          	addi	sp,sp,-48
400205e8:	02812423          	sw	s0,40(sp)
400205ec:	02112623          	sw	ra,44(sp)
400205f0:	00050413          	mv	s0,a0
	tcp_pkt_ref(pkt);
400205f4:	9c0f70ef          	jal	ra,400177b4 <net_pkt_ref>
	if (tcp_send_cb) {
400205f8:	400397b7          	lui	a5,0x40039
400205fc:	0c47a783          	lw	a5,196(a5) # 400390c4 <tcp_send_cb>
		if (tcp_send_cb(pkt) < 0) {
40020600:	00040513          	mv	a0,s0
	if (tcp_send_cb) {
40020604:	06078063          	beqz	a5,40020664 <tcp_send+0x80>
		if (tcp_send_cb(pkt) < 0) {
40020608:	000780e7          	jalr	a5
		if (net_send_data(pkt) < 0) {
4002060c:	04055263          	bgez	a0,40020650 <tcp_send+0x6c>
			NET_ERR("net_send_data()");
40020610:	40044537          	lui	a0,0x40044
40020614:	7a052783          	lw	a5,1952(a0) # 400447a0 <log_dynamic_net_tcp>
40020618:	0077f793          	andi	a5,a5,7
4002061c:	02078663          	beqz	a5,40020648 <tcp_send+0x64>
			NET_ERR("net_send_data()");
40020620:	400357b7          	lui	a5,0x40035
40020624:	2c878793          	addi	a5,a5,712 # 400352c8 <CSWTCH.16862+0xd0>
40020628:	000015b7          	lui	a1,0x1
4002062c:	00f12e23          	sw	a5,28(sp)
40020630:	01810613          	addi	a2,sp,24
40020634:	00200793          	li	a5,2
40020638:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4002063c:	7a050513          	addi	a0,a0,1952
40020640:	00f12c23          	sw	a5,24(sp)
40020644:	ee5ff0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
			tcp_pkt_unref(pkt);
40020648:	00040513          	mv	a0,s0
4002064c:	9d0f70ef          	jal	ra,4001781c <net_pkt_unref>
	tcp_pkt_unref(pkt);
40020650:	00040513          	mv	a0,s0
}
40020654:	02812403          	lw	s0,40(sp)
40020658:	02c12083          	lw	ra,44(sp)
4002065c:	03010113          	addi	sp,sp,48
	tcp_pkt_unref(pkt);
40020660:	9bcf706f          	j	4001781c <net_pkt_unref>
		if (net_send_data(pkt) < 0) {
40020664:	848ef0ef          	jal	ra,4000f6ac <net_send_data>
40020668:	fa5ff06f          	j	4002060c <tcp_send+0x28>

4002066c <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
4002066c:	5d10e06f          	j	4002f43c <z_impl_k_mutex_lock>

40020670 <net_pkt_get_len.isra.0>:
static inline size_t net_pkt_get_len(struct net_pkt *pkt)
40020670:	00050793          	mv	a5,a0
	size_t bytes = 0;
40020674:	00000513          	li	a0,0
	while (buf) {
40020678:	00079463          	bnez	a5,40020680 <net_pkt_get_len.isra.0+0x10>
}
4002067c:	00008067          	ret
		bytes += buf->len;
40020680:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
40020684:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
40020688:	00e50533          	add	a0,a0,a4
		buf = buf->frags;
4002068c:	fedff06f          	j	40020678 <net_pkt_get_len.isra.0+0x8>

40020690 <tcp_pkt_pull>:
{
40020690:	ff010113          	addi	sp,sp,-16
40020694:	00812423          	sw	s0,8(sp)
40020698:	00912223          	sw	s1,4(sp)
4002069c:	00112623          	sw	ra,12(sp)
400206a0:	00050413          	mv	s0,a0
	int total = net_pkt_get_len(pkt);
400206a4:	00852503          	lw	a0,8(a0)
{
400206a8:	00058493          	mv	s1,a1
	int total = net_pkt_get_len(pkt);
400206ac:	fc5ff0ef          	jal	ra,40020670 <net_pkt_get_len.isra.0>
	if (len > total) {
400206b0:	04956263          	bltu	a0,s1,400206f4 <tcp_pkt_pull+0x64>
	net_pkt_cursor_init(pkt);
400206b4:	00040513          	mv	a0,s0
400206b8:	c38f70ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	pkt->overwrite = overwrite;
400206bc:	03744783          	lbu	a5,55(s0)
	net_pkt_pull(pkt, len);
400206c0:	00048593          	mv	a1,s1
400206c4:	00040513          	mv	a0,s0
400206c8:	0017e793          	ori	a5,a5,1
400206cc:	02f40ba3          	sb	a5,55(s0)
400206d0:	e8df70ef          	jal	ra,4001855c <net_pkt_pull>
	net_pkt_trim_buffer(pkt);
400206d4:	00040513          	mv	a0,s0
400206d8:	b2cf70ef          	jal	ra,40017a04 <net_pkt_trim_buffer>
	int ret = 0;
400206dc:	00000513          	li	a0,0
}
400206e0:	00c12083          	lw	ra,12(sp)
400206e4:	00812403          	lw	s0,8(sp)
400206e8:	00412483          	lw	s1,4(sp)
400206ec:	01010113          	addi	sp,sp,16
400206f0:	00008067          	ret
		ret = -EINVAL;
400206f4:	fea00513          	li	a0,-22
	return ret;
400206f8:	fe9ff06f          	j	400206e0 <tcp_pkt_pull+0x50>

400206fc <net_context_get_iface.isra.0>:
400206fc:	c30f006f          	j	40010b2c <z_impl_net_if_get_by_index>

40020700 <th_get>:
{
40020700:	fd010113          	addi	sp,sp,-48
40020704:	02812423          	sw	s0,40(sp)
40020708:	02912223          	sw	s1,36(sp)
4002070c:	01712623          	sw	s7,12(sp)
40020710:	01812423          	sw	s8,8(sp)
40020714:	02112623          	sw	ra,44(sp)
40020718:	03212023          	sw	s2,32(sp)
4002071c:	01312e23          	sw	s3,28(sp)
40020720:	01412c23          	sw	s4,24(sp)
40020724:	01512a23          	sw	s5,20(sp)
40020728:	01612823          	sw	s6,16(sp)
4002072c:	01912223          	sw	s9,4(sp)
40020730:	03010413          	addi	s0,sp,48
	size_t ip_len = net_pkt_ip_hdr_len(pkt) + net_pkt_ip_opts_len(pkt);
40020734:	03654a83          	lbu	s5,54(a0)
40020738:	03a55783          	lhu	a5,58(a0)
{
4002073c:	00050493          	mv	s1,a0
	if (!buf || buf->size < len) {
40020740:	01300c13          	li	s8,19
	size_t ip_len = net_pkt_ip_hdr_len(pkt) + net_pkt_ip_opts_len(pkt);
40020744:	00fa8ab3          	add	s5,s5,a5
	if (net_pkt_get_len(pkt) < (pos + len)) {
40020748:	014a8b93          	addi	s7,s5,20
	net_pkt_cursor_init(pkt);
4002074c:	00048513          	mv	a0,s1
40020750:	ba0f70ef          	jal	ra,40017af0 <net_pkt_cursor_init>
40020754:	0374c783          	lbu	a5,55(s1)
	if (net_pkt_skip(pkt, ip_len) != 0) {
40020758:	000a8593          	mv	a1,s5
4002075c:	00048513          	mv	a0,s1
40020760:	0017e793          	ori	a5,a5,1
40020764:	02f48ba3          	sb	a5,55(s1)
40020768:	969f70ef          	jal	ra,400180d0 <net_pkt_skip>
4002076c:	06051c63          	bnez	a0,400207e4 <th_get+0xe4>
	if (!net_pkt_is_contiguous(pkt, sizeof(*th))) {
40020770:	01400593          	li	a1,20
40020774:	00048513          	mv	a0,s1
40020778:	8e0f80ef          	jal	ra,40018858 <net_pkt_is_contiguous>
4002077c:	14051e63          	bnez	a0,400208d8 <th_get+0x1d8>
	struct net_buf *buf, *first = pkt->cursor.buf, *second = first->frags;
40020780:	00c4ab03          	lw	s6,12(s1)
	if (net_pkt_get_len(pkt) < (pos + len)) {
40020784:	0084a503          	lw	a0,8(s1)
	struct net_buf *buf, *first = pkt->cursor.buf, *second = first->frags;
40020788:	004b2983          	lw	s3,4(s6)
	if (net_pkt_get_len(pkt) < (pos + len)) {
4002078c:	ee5ff0ef          	jal	ra,40020670 <net_pkt_get_len.isra.0>
40020790:	09757863          	bgeu	a0,s7,40020820 <th_get+0x120>
		NET_ERR("Insufficient packet len=%zd (pos+len=%zu)",
40020794:	40044737          	lui	a4,0x40044
40020798:	7a072783          	lw	a5,1952(a4) # 400447a0 <log_dynamic_net_tcp>
4002079c:	0077f793          	andi	a5,a5,7
400207a0:	04078263          	beqz	a5,400207e4 <th_get+0xe4>
400207a4:	00010493          	mv	s1,sp
400207a8:	fe010113          	addi	sp,sp,-32
400207ac:	00010613          	mv	a2,sp
400207b0:	400357b7          	lui	a5,0x40035
400207b4:	2d878793          	addi	a5,a5,728 # 400352d8 <CSWTCH.16862+0xe0>
400207b8:	00f62a23          	sw	a5,20(a2)
400207bc:	000025b7          	lui	a1,0x2
400207c0:	00400793          	li	a5,4
400207c4:	00a62c23          	sw	a0,24(a2)
400207c8:	01762e23          	sw	s7,28(a2)
400207cc:	00f62823          	sw	a5,16(a2)
400207d0:	04058593          	addi	a1,a1,64 # 2040 <CONFIG_SRAM_SIZE+0x40>
400207d4:	01060613          	addi	a2,a2,16
400207d8:	7a070513          	addi	a0,a4,1952
400207dc:	d4dff0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
400207e0:	00048113          	mv	sp,s1
	struct tcphdr *th = NULL;
400207e4:	00000513          	li	a0,0
}
400207e8:	fd040113          	addi	sp,s0,-48
400207ec:	02c12083          	lw	ra,44(sp)
400207f0:	02812403          	lw	s0,40(sp)
400207f4:	02412483          	lw	s1,36(sp)
400207f8:	02012903          	lw	s2,32(sp)
400207fc:	01c12983          	lw	s3,28(sp)
40020800:	01812a03          	lw	s4,24(sp)
40020804:	01412a83          	lw	s5,20(sp)
40020808:	01012b03          	lw	s6,16(sp)
4002080c:	00c12b83          	lw	s7,12(sp)
40020810:	00812c03          	lw	s8,8(sp)
40020814:	00412c83          	lw	s9,4(sp)
40020818:	03010113          	addi	sp,sp,48
4002081c:	00008067          	ret
	buf = net_pkt_get_frag(pkt, len, TCP_PKT_ALLOC_TIMEOUT);
40020820:	00a00613          	li	a2,10
40020824:	00000693          	li	a3,0
40020828:	01400593          	li	a1,20
4002082c:	00048513          	mv	a0,s1
40020830:	f5df60ef          	jal	ra,4001778c <net_pkt_get_frag>
40020834:	00050913          	mv	s2,a0
	if (!buf || buf->size < len) {
40020838:	fa0506e3          	beqz	a0,400207e4 <th_get+0xe4>
4002083c:	01255583          	lhu	a1,18(a0)
40020840:	00bc6663          	bltu	s8,a1,4002084c <th_get+0x14c>
			net_buf_unref(buf);
40020844:	d79ec0ef          	jal	ra,4000d5bc <net_buf_unref>
	return ret;
40020848:	f9dff06f          	j	400207e4 <th_get+0xe4>
	net_buf_linearize(buf->data, buf->size, pkt->frags, pos, len);
4002084c:	0084a603          	lw	a2,8(s1)
40020850:	00c52503          	lw	a0,12(a0)
40020854:	01400713          	li	a4,20
40020858:	000a8693          	mv	a3,s5
4002085c:	eb9ec0ef          	jal	ra,4000d714 <net_buf_linearize>
	return net_buf_simple_add(&buf->b, len);
40020860:	01400593          	li	a1,20
40020864:	00c90513          	addi	a0,s2,12
40020868:	f61ec0ef          	jal	ra,4000d7c8 <net_buf_simple_add>
	len1 = first->len - (pkt->cursor.pos - pkt->cursor.buf->data);
4002086c:	00c4a683          	lw	a3,12(s1)
40020870:	0104a783          	lw	a5,16(s1)
40020874:	010b5703          	lhu	a4,16(s6)
40020878:	00c6a683          	lw	a3,12(a3)
	len2 = len - len1;
4002087c:	01400a13          	li	s4,20
	len1 = first->len - (pkt->cursor.pos - pkt->cursor.buf->data);
40020880:	40d787b3          	sub	a5,a5,a3
40020884:	40f707b3          	sub	a5,a4,a5
	first->len -= len1;
40020888:	40f70733          	sub	a4,a4,a5
	len2 = len - len1;
4002088c:	40fa0a33          	sub	s4,s4,a5
	first->len -= len1;
40020890:	00eb1823          	sh	a4,16(s6)
	while (len2) {
40020894:	000a1863          	bnez	s4,400208a4 <th_get+0x1a4>
	buf->frags = second;
40020898:	01392223          	sw	s3,4(s2)
	first->frags = buf;
4002089c:	012b2223          	sw	s2,4(s6)
	return ret;
400208a0:	eadff06f          	j	4002074c <th_get+0x4c>
		size_t pull_len = MIN(second->len, len2);
400208a4:	0109d583          	lhu	a1,16(s3)
400208a8:	00ba7463          	bgeu	s4,a1,400208b0 <th_get+0x1b0>
400208ac:	000a0593          	mv	a1,s4
	return net_buf_simple_pull(&buf->b, len);
400208b0:	00c98513          	addi	a0,s3,12
		len2 -= pull_len;
400208b4:	40ba0a33          	sub	s4,s4,a1
400208b8:	f4dec0ef          	jal	ra,4000d804 <net_buf_simple_pull>
		if (second->len == 0) {
400208bc:	0109d783          	lhu	a5,16(s3)
		next = second->frags;
400208c0:	0049ac83          	lw	s9,4(s3)
		if (second->len == 0) {
400208c4:	00079663          	bnez	a5,400208d0 <th_get+0x1d0>
			net_buf_unref(second);
400208c8:	00098513          	mv	a0,s3
400208cc:	cf1ec0ef          	jal	ra,4000d5bc <net_buf_unref>
{
400208d0:	000c8993          	mv	s3,s9
400208d4:	fc1ff06f          	j	40020894 <th_get+0x194>
	return pkt->cursor.pos;
400208d8:	0104a503          	lw	a0,16(s1)
	return th;
400208dc:	f0dff06f          	j	400207e8 <th_get+0xe8>

400208e0 <tcp_endpoint_set>:
{
400208e0:	fe010113          	addi	sp,sp,-32
400208e4:	00812c23          	sw	s0,24(sp)
400208e8:	00912a23          	sw	s1,20(sp)
400208ec:	01512223          	sw	s5,4(sp)
400208f0:	01612023          	sw	s6,0(sp)
400208f4:	00112e23          	sw	ra,28(sp)
400208f8:	01212823          	sw	s2,16(sp)
400208fc:	01312623          	sw	s3,12(sp)
40020900:	01412423          	sw	s4,8(sp)
40020904:	02010413          	addi	s0,sp,32
	return pkt->family;
40020908:	0345aa03          	lw	s4,52(a1)
	switch (net_pkt_family(pkt)) {
4002090c:	00100b13          	li	s6,1
{
40020910:	00050493          	mv	s1,a0
40020914:	01da5a13          	srli	s4,s4,0x1d
40020918:	00058513          	mv	a0,a1
4002091c:	00060a93          	mv	s5,a2
	switch (net_pkt_family(pkt)) {
40020920:	076a0063          	beq	s4,s6,40020980 <tcp_endpoint_set+0xa0>
40020924:	00200793          	li	a5,2
40020928:	12fa0a63          	beq	s4,a5,40020a5c <tcp_endpoint_set+0x17c>
		NET_ERR("Unknown address family: %hu", net_pkt_family(pkt));
4002092c:	40044537          	lui	a0,0x40044
40020930:	7a052783          	lw	a5,1952(a0) # 400447a0 <log_dynamic_net_tcp>
40020934:	0077f793          	andi	a5,a5,7
40020938:	04078063          	beqz	a5,40020978 <tcp_endpoint_set+0x98>
4002093c:	00010493          	mv	s1,sp
40020940:	fe010113          	addi	sp,sp,-32
40020944:	00010613          	mv	a2,sp
40020948:	400357b7          	lui	a5,0x40035
4002094c:	30478793          	addi	a5,a5,772 # 40035304 <CSWTCH.16862+0x10c>
40020950:	00f62a23          	sw	a5,20(a2)
40020954:	000025b7          	lui	a1,0x2
40020958:	00300793          	li	a5,3
	switch (net_pkt_family(pkt)) {
4002095c:	01462c23          	sw	s4,24(a2)
		NET_ERR("Unknown address family: %hu", net_pkt_family(pkt));
40020960:	00f62823          	sw	a5,16(a2)
40020964:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
40020968:	01060613          	addi	a2,a2,16
4002096c:	7a050513          	addi	a0,a0,1952
40020970:	bb9ff0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
40020974:	00048113          	mv	sp,s1
		ret = -EINVAL;
40020978:	fea00513          	li	a0,-22
4002097c:	01c0006f          	j	40020998 <tcp_endpoint_set+0xb8>
	return pkt->frags->data;
40020980:	0085a783          	lw	a5,8(a1)
40020984:	00c7a903          	lw	s2,12(a5)
			th = th_get(pkt);
40020988:	d79ff0ef          	jal	ra,40020700 <th_get>
4002098c:	00050993          	mv	s3,a0
			if (!th) {
40020990:	02051a63          	bnez	a0,400209c4 <tcp_endpoint_set+0xe4>
				return -ENOBUFS;
40020994:	f9700513          	li	a0,-105
}
40020998:	fe040113          	addi	sp,s0,-32
4002099c:	01c12083          	lw	ra,28(sp)
400209a0:	01812403          	lw	s0,24(sp)
400209a4:	01412483          	lw	s1,20(sp)
400209a8:	01012903          	lw	s2,16(sp)
400209ac:	00c12983          	lw	s3,12(sp)
400209b0:	00812a03          	lw	s4,8(sp)
400209b4:	00412a83          	lw	s5,4(sp)
400209b8:	00012b03          	lw	s6,0(sp)
400209bc:	02010113          	addi	sp,sp,32
400209c0:	00008067          	ret
			memset(ep, 0, sizeof(*ep));
400209c4:	01800613          	li	a2,24
400209c8:	00000593          	li	a1,0
400209cc:	00048513          	mv	a0,s1
400209d0:	b4cec0ef          	jal	ra,4000cd1c <memset>
			ep->sin.sin_port = src == TCP_EP_SRC ? th_sport(th) :
400209d4:	074a9863          	bne	s5,s4,40020a44 <tcp_endpoint_set+0x164>
400209d8:	0019c783          	lbu	a5,1(s3)
400209dc:	0009c703          	lbu	a4,0(s3)
400209e0:	00879793          	slli	a5,a5,0x8
400209e4:	00e7e7b3          	or	a5,a5,a4
			net_ipv4_addr_copy_raw((uint8_t *)&ep->sin.sin_addr,
400209e8:	00c90713          	addi	a4,s2,12
400209ec:	00f49123          	sh	a5,2(s1)
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
400209f0:	00174783          	lbu	a5,1(a4)
400209f4:	00074683          	lbu	a3,0(a4)
400209f8:	00879793          	slli	a5,a5,0x8
400209fc:	00d7e7b3          	or	a5,a5,a3
40020a00:	00274683          	lbu	a3,2(a4)
40020a04:	01069693          	slli	a3,a3,0x10
40020a08:	00f6e6b3          	or	a3,a3,a5
40020a0c:	00374783          	lbu	a5,3(a4)
40020a10:	00d48223          	sb	a3,4(s1)
40020a14:	01879793          	slli	a5,a5,0x18
40020a18:	00d7e7b3          	or	a5,a5,a3
40020a1c:	0087d713          	srli	a4,a5,0x8
40020a20:	00e482a3          	sb	a4,5(s1)
40020a24:	0107d713          	srli	a4,a5,0x10
40020a28:	0187d793          	srli	a5,a5,0x18
40020a2c:	00f483a3          	sb	a5,7(s1)
40020a30:	00e48323          	sb	a4,6(s1)
		break;
40020a34:	00100793          	li	a5,1
			ep->sa.sa_family = AF_INET;
40020a38:	00f49023          	sh	a5,0(s1)
	int ret = 0;
40020a3c:	00000513          	li	a0,0
40020a40:	f59ff06f          	j	40020998 <tcp_endpoint_set+0xb8>
							       th_dport(th);
40020a44:	0039c783          	lbu	a5,3(s3)
40020a48:	0029c703          	lbu	a4,2(s3)
40020a4c:	00879793          	slli	a5,a5,0x8
40020a50:	00e7e7b3          	or	a5,a5,a4
			net_ipv4_addr_copy_raw((uint8_t *)&ep->sin.sin_addr,
40020a54:	01090713          	addi	a4,s2,16
40020a58:	f95ff06f          	j	400209ec <tcp_endpoint_set+0x10c>
40020a5c:	0085a783          	lw	a5,8(a1)
40020a60:	00c7a983          	lw	s3,12(a5)
			th = th_get(pkt);
40020a64:	c9dff0ef          	jal	ra,40020700 <th_get>
40020a68:	00050913          	mv	s2,a0
			if (!th) {
40020a6c:	f20504e3          	beqz	a0,40020994 <tcp_endpoint_set+0xb4>
			memset(ep, 0, sizeof(*ep));
40020a70:	01800613          	li	a2,24
40020a74:	00000593          	li	a1,0
40020a78:	00048513          	mv	a0,s1
40020a7c:	aa0ec0ef          	jal	ra,4000cd1c <memset>
			net_ipv6_addr_copy_raw((uint8_t *)&ep->sin6.sin6_addr,
40020a80:	00448513          	addi	a0,s1,4
			ep->sin6.sin6_port = src == TCP_EP_SRC ? th_sport(th) :
40020a84:	036a9663          	bne	s5,s6,40020ab0 <tcp_endpoint_set+0x1d0>
40020a88:	00194783          	lbu	a5,1(s2)
40020a8c:	00094703          	lbu	a4,0(s2)
			net_ipv6_addr_copy_raw((uint8_t *)&ep->sin6.sin6_addr,
40020a90:	00898593          	addi	a1,s3,8
			ep->sin6.sin6_port = src == TCP_EP_SRC ? th_sport(th) :
40020a94:	00879793          	slli	a5,a5,0x8
40020a98:	00e7e7b3          	or	a5,a5,a4
			net_ipv6_addr_copy_raw((uint8_t *)&ep->sin6.sin6_addr,
40020a9c:	00f49123          	sh	a5,2(s1)
	memcpy(dest, src, sizeof(struct in6_addr));
40020aa0:	01000613          	li	a2,16
40020aa4:	a54ec0ef          	jal	ra,4000ccf8 <memcpy>
		break;
40020aa8:	00200793          	li	a5,2
40020aac:	f8dff06f          	j	40020a38 <tcp_endpoint_set+0x158>
								 th_dport(th);
40020ab0:	00394783          	lbu	a5,3(s2)
40020ab4:	00294703          	lbu	a4,2(s2)
			net_ipv6_addr_copy_raw((uint8_t *)&ep->sin6.sin6_addr,
40020ab8:	01898593          	addi	a1,s3,24
								 th_dport(th);
40020abc:	00879793          	slli	a5,a5,0x8
40020ac0:	00e7e7b3          	or	a5,a5,a4
			net_ipv6_addr_copy_raw((uint8_t *)&ep->sin6.sin6_addr,
40020ac4:	fd9ff06f          	j	40020a9c <tcp_endpoint_set+0x1bc>

40020ac8 <tcp_endpoint_cmp>:
{
40020ac8:	fd010113          	addi	sp,sp,-48
40020acc:	02812423          	sw	s0,40(sp)
40020ad0:	00050413          	mv	s0,a0
	if (tcp_endpoint_set(&ep_tmp, pkt, which) < 0) {
40020ad4:	00810513          	addi	a0,sp,8
{
40020ad8:	02112623          	sw	ra,44(sp)
	if (tcp_endpoint_set(&ep_tmp, pkt, which) < 0) {
40020adc:	e05ff0ef          	jal	ra,400208e0 <tcp_endpoint_set>
40020ae0:	02054c63          	bltz	a0,40020b18 <tcp_endpoint_cmp+0x50>
	return (af == AF_INET) ? sizeof(struct sockaddr_in) :
40020ae4:	00045703          	lhu	a4,0(s0)
40020ae8:	00100793          	li	a5,1
40020aec:	01800613          	li	a2,24
40020af0:	00f71463          	bne	a4,a5,40020af8 <tcp_endpoint_cmp+0x30>
40020af4:	00800613          	li	a2,8
	return !memcmp(ep, &ep_tmp, tcp_endpoint_len(ep->sa.sa_family));
40020af8:	00810593          	addi	a1,sp,8
40020afc:	00040513          	mv	a0,s0
40020b00:	978ec0ef          	jal	ra,4000cc78 <memcmp>
40020b04:	00153513          	seqz	a0,a0
}
40020b08:	02c12083          	lw	ra,44(sp)
40020b0c:	02812403          	lw	s0,40(sp)
40020b10:	03010113          	addi	sp,sp,48
40020b14:	00008067          	ret
		return false;
40020b18:	00000513          	li	a0,0
40020b1c:	fedff06f          	j	40020b08 <tcp_endpoint_cmp+0x40>

40020b20 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
40020b20:	2790e06f          	j	4002f598 <z_impl_k_mutex_unlock>

40020b24 <tcp_send_timer_cancel>:
	if (conn->in_retransmission == false) {
40020b24:	23c52783          	lw	a5,572(a0)
40020b28:	0087d793          	srli	a5,a5,0x8
40020b2c:	0017f793          	andi	a5,a5,1
40020b30:	0e078463          	beqz	a5,40020c18 <tcp_send_timer_cancel+0xf4>
{
40020b34:	fe010113          	addi	sp,sp,-32
40020b38:	01312623          	sw	s3,12(sp)
	k_work_cancel_delayable(&conn->send_timer);
40020b3c:	09050993          	addi	s3,a0,144
{
40020b40:	00812c23          	sw	s0,24(sp)
40020b44:	00050413          	mv	s0,a0
	k_work_cancel_delayable(&conn->send_timer);
40020b48:	00098513          	mv	a0,s3
{
40020b4c:	00112e23          	sw	ra,28(sp)
40020b50:	00912a23          	sw	s1,20(sp)
40020b54:	01212823          	sw	s2,16(sp)
	k_work_cancel_delayable(&conn->send_timer);
40020b58:	6140f0ef          	jal	ra,4003016c <k_work_cancel_delayable>
		struct net_pkt *pkt = tcp_slist(conn, &conn->send_queue, get,
40020b5c:	02840913          	addi	s2,s0,40
40020b60:	fff00593          	li	a1,-1
40020b64:	fff00613          	li	a2,-1
40020b68:	00090513          	mv	a0,s2
40020b6c:	b01ff0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
40020b70:	01840513          	addi	a0,s0,24
40020b74:	ee0ff0ef          	jal	ra,40020254 <sys_slist_get>
40020b78:	00050493          	mv	s1,a0
40020b7c:	00090513          	mv	a0,s2
40020b80:	02049c63          	bnez	s1,40020bb8 <tcp_send_timer_cancel+0x94>
40020b84:	f9dff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
	if (sys_slist_is_empty(&conn->send_queue)) {
40020b88:	01842783          	lw	a5,24(s0)
40020b8c:	02079e63          	bnez	a5,40020bc8 <tcp_send_timer_cancel+0xa4>
		conn->in_retransmission = false;
40020b90:	23d44783          	lbu	a5,573(s0)
40020b94:	ffe7f793          	andi	a5,a5,-2
40020b98:	22f40ea3          	sb	a5,573(s0)
}
40020b9c:	01c12083          	lw	ra,28(sp)
40020ba0:	01812403          	lw	s0,24(sp)
40020ba4:	01412483          	lw	s1,20(sp)
40020ba8:	01012903          	lw	s2,16(sp)
40020bac:	00c12983          	lw	s3,12(sp)
40020bb0:	02010113          	addi	sp,sp,32
40020bb4:	00008067          	ret
		struct net_pkt *pkt = tcp_slist(conn, &conn->send_queue, get,
40020bb8:	f69ff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
			tcp_pkt_unref(pkt);
40020bbc:	fe448513          	addi	a0,s1,-28
40020bc0:	c5df60ef          	jal	ra,4001781c <net_pkt_unref>
40020bc4:	fc5ff06f          	j	40020b88 <tcp_send_timer_cancel+0x64>
					    K_MSEC(TCP_RTO_MS));
40020bc8:	23845503          	lhu	a0,568(s0)
		conn->send_retries = tcp_retries;
40020bcc:	00900793          	li	a5,9
40020bd0:	20f42a23          	sw	a5,532(s0)
40020bd4:	00a00613          	li	a2,10
40020bd8:	00000693          	li	a3,0
40020bdc:	00950513          	addi	a0,a0,9
40020be0:	00000593          	li	a1,0
40020be4:	ed4df0ef          	jal	ra,400002b8 <__udivdi3>
}
40020be8:	01812403          	lw	s0,24(sp)
40020bec:	01c12083          	lw	ra,28(sp)
40020bf0:	01412483          	lw	s1,20(sp)
40020bf4:	01012903          	lw	s2,16(sp)
40020bf8:	00058693          	mv	a3,a1
		k_work_reschedule_for_queue(&tcp_work_q, &conn->send_timer,
40020bfc:	00098593          	mv	a1,s3
}
40020c00:	00c12983          	lw	s3,12(sp)
40020c04:	00050613          	mv	a2,a0
		k_work_reschedule_for_queue(&tcp_work_q, &conn->send_timer,
40020c08:	4003a537          	lui	a0,0x4003a
40020c0c:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
}
40020c10:	02010113          	addi	sp,sp,32
		k_work_reschedule_for_queue(&tcp_work_q, &conn->send_timer,
40020c14:	4b00f06f          	j	400300c4 <k_work_reschedule_for_queue>
40020c18:	00008067          	ret

40020c1c <tcp_cleanup_recv_queue>:
{
40020c1c:	ff010113          	addi	sp,sp,-16
40020c20:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
40020c24:	f6850493          	addi	s1,a0,-152
{
40020c28:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
40020c2c:	fff00593          	li	a1,-1
{
40020c30:	00050413          	mv	s0,a0
	k_mutex_lock(&conn->lock, K_FOREVER);
40020c34:	fff00613          	li	a2,-1
40020c38:	00048513          	mv	a0,s1
{
40020c3c:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
40020c40:	a2dff0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	net_buf_unref(conn->queue_recv_data->buffer);
40020c44:	f4c42783          	lw	a5,-180(s0)
40020c48:	0087a503          	lw	a0,8(a5)
40020c4c:	971ec0ef          	jal	ra,4000d5bc <net_buf_unref>
	conn->queue_recv_data->buffer = NULL;
40020c50:	f4c42783          	lw	a5,-180(s0)
	k_mutex_unlock(&conn->lock);
40020c54:	00048513          	mv	a0,s1
	conn->queue_recv_data->buffer = NULL;
40020c58:	0007a423          	sw	zero,8(a5)
}
40020c5c:	00812403          	lw	s0,8(sp)
40020c60:	00c12083          	lw	ra,12(sp)
40020c64:	00412483          	lw	s1,4(sp)
40020c68:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&conn->lock);
40020c6c:	eb5ff06f          	j	40020b20 <k_mutex_unlock.isra.0>

40020c70 <tcp_send_process_no_lock>:
{
40020c70:	fd010113          	addi	sp,sp,-48
40020c74:	03212023          	sw	s2,32(sp)
	pkt = tcp_slist(conn, &conn->send_queue, peek_head,
40020c78:	02850913          	addi	s2,a0,40
{
40020c7c:	02812423          	sw	s0,40(sp)
	pkt = tcp_slist(conn, &conn->send_queue, peek_head,
40020c80:	fff00593          	li	a1,-1
{
40020c84:	00050413          	mv	s0,a0
	pkt = tcp_slist(conn, &conn->send_queue, peek_head,
40020c88:	fff00613          	li	a2,-1
40020c8c:	00090513          	mv	a0,s2
{
40020c90:	02912223          	sw	s1,36(sp)
40020c94:	02112623          	sw	ra,44(sp)
	pkt = tcp_slist(conn, &conn->send_queue, peek_head,
40020c98:	9d5ff0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	return list->head;
40020c9c:	01842483          	lw	s1,24(s0)
40020ca0:	08048c63          	beqz	s1,40020d38 <tcp_send_process_no_lock+0xc8>
40020ca4:	00090513          	mv	a0,s2
40020ca8:	e79ff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
	if (conn->in_retransmission) {
40020cac:	23d44783          	lbu	a5,573(s0)
	pkt = tcp_slist(conn, &conn->send_queue, peek_head,
40020cb0:	fe448493          	addi	s1,s1,-28
	if (conn->in_retransmission) {
40020cb4:	0017f793          	andi	a5,a5,1
40020cb8:	0a079263          	bnez	a5,40020d5c <tcp_send_process_no_lock+0xec>
		uint8_t fl = th_get(pkt)->th_flags;
40020cbc:	00048513          	mv	a0,s1
40020cc0:	a41ff0ef          	jal	ra,40020700 <th_get>
40020cc4:	00d54783          	lbu	a5,13(a0)
		bool forget = ACK == fl || PSH == fl || (ACK | PSH) == fl ||
40020cc8:	01000713          	li	a4,16
40020ccc:	10e78063          	beq	a5,a4,40020dcc <tcp_send_process_no_lock+0x15c>
40020cd0:	0ef7f713          	andi	a4,a5,239
40020cd4:	00800693          	li	a3,8
40020cd8:	0ed70a63          	beq	a4,a3,40020dcc <tcp_send_process_no_lock+0x15c>
40020cdc:	0047f793          	andi	a5,a5,4
40020ce0:	0e079663          	bnez	a5,40020dcc <tcp_send_process_no_lock+0x15c>
			tcp_pkt_clone(pkt);
40020ce4:	00048513          	mv	a0,s1
40020ce8:	00a00593          	li	a1,10
40020cec:	00000613          	li	a2,0
40020cf0:	aedf70ef          	jal	ra,400187dc <net_pkt_clone>
40020cf4:	00050493          	mv	s1,a0
		if (!pkt) {
40020cf8:	14051063          	bnez	a0,40020e38 <tcp_send_process_no_lock+0x1c8>
			NET_ERR("net_pkt alloc failure");
40020cfc:	40044537          	lui	a0,0x40044
40020d00:	7a052783          	lw	a5,1952(a0) # 400447a0 <log_dynamic_net_tcp>
40020d04:	0077f793          	andi	a5,a5,7
40020d08:	02078c63          	beqz	a5,40020d40 <tcp_send_process_no_lock+0xd0>
40020d0c:	400357b7          	lui	a5,0x40035
40020d10:	32078793          	addi	a5,a5,800 # 40035320 <CSWTCH.16862+0x128>
40020d14:	000015b7          	lui	a1,0x1
40020d18:	00f12e23          	sw	a5,28(sp)
40020d1c:	01810613          	addi	a2,sp,24
40020d20:	00200793          	li	a5,2
40020d24:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
40020d28:	7a050513          	addi	a0,a0,1952
40020d2c:	00f12c23          	sw	a5,24(sp)
40020d30:	ff8ff0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
			goto out;
40020d34:	00c0006f          	j	40020d40 <tcp_send_process_no_lock+0xd0>
	pkt = tcp_slist(conn, &conn->send_queue, peek_head,
40020d38:	00090513          	mv	a0,s2
40020d3c:	de5ff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
	bool unref = false;
40020d40:	00000513          	li	a0,0
}
40020d44:	02c12083          	lw	ra,44(sp)
40020d48:	02812403          	lw	s0,40(sp)
40020d4c:	02412483          	lw	s1,36(sp)
40020d50:	02012903          	lw	s2,32(sp)
40020d54:	03010113          	addi	sp,sp,48
40020d58:	00008067          	ret
		if (conn->send_retries > 0) {
40020d5c:	21442783          	lw	a5,532(s0)
			unref = true;
40020d60:	00100513          	li	a0,1
		if (conn->send_retries > 0) {
40020d64:	fe0780e3          	beqz	a5,40020d44 <tcp_send_process_no_lock+0xd4>
			struct net_pkt *clone = tcp_pkt_clone(pkt);
40020d68:	00a00593          	li	a1,10
40020d6c:	00000613          	li	a2,0
40020d70:	00048513          	mv	a0,s1
40020d74:	a69f70ef          	jal	ra,400187dc <net_pkt_clone>
			if (clone) {
40020d78:	00050a63          	beqz	a0,40020d8c <tcp_send_process_no_lock+0x11c>
				tcp_send(clone);
40020d7c:	869ff0ef          	jal	ra,400205e4 <tcp_send>
				conn->send_retries--;
40020d80:	21442783          	lw	a5,532(s0)
40020d84:	fff78793          	addi	a5,a5,-1
40020d88:	20f42a23          	sw	a5,532(s0)
	if (conn->in_retransmission) {
40020d8c:	23d44783          	lbu	a5,573(s0)
40020d90:	0017f793          	andi	a5,a5,1
40020d94:	fa0786e3          	beqz	a5,40020d40 <tcp_send_process_no_lock+0xd0>
					    K_MSEC(TCP_RTO_MS));
40020d98:	23845503          	lhu	a0,568(s0)
40020d9c:	00a00613          	li	a2,10
40020da0:	00000693          	li	a3,0
40020da4:	00950513          	addi	a0,a0,9
40020da8:	00000593          	li	a1,0
40020dac:	d0cdf0ef          	jal	ra,400002b8 <__udivdi3>
40020db0:	00050613          	mv	a2,a0
40020db4:	00058693          	mv	a3,a1
		k_work_reschedule_for_queue(&tcp_work_q, &conn->send_timer,
40020db8:	4003a537          	lui	a0,0x4003a
40020dbc:	09040593          	addi	a1,s0,144
40020dc0:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
40020dc4:	3000f0ef          	jal	ra,400300c4 <k_work_reschedule_for_queue>
40020dc8:	f79ff06f          	j	40020d40 <tcp_send_process_no_lock+0xd0>
		pkt = forget ? tcp_slist(conn, &conn->send_queue, get,
40020dcc:	00090513          	mv	a0,s2
40020dd0:	fff00593          	li	a1,-1
40020dd4:	fff00613          	li	a2,-1
40020dd8:	895ff0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
40020ddc:	01840513          	addi	a0,s0,24
40020de0:	c74ff0ef          	jal	ra,40020254 <sys_slist_get>
40020de4:	00051863          	bnez	a0,40020df4 <tcp_send_process_no_lock+0x184>
40020de8:	00090513          	mv	a0,s2
40020dec:	d35ff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
		if (!pkt) {
40020df0:	f0dff06f          	j	40020cfc <tcp_send_process_no_lock+0x8c>
		pkt = forget ? tcp_slist(conn, &conn->send_queue, get,
40020df4:	fe450493          	addi	s1,a0,-28
40020df8:	00090513          	mv	a0,s2
40020dfc:	d25ff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
		if (is_destination_local(pkt)) {
40020e00:	00048513          	mv	a0,s1
40020e04:	d38ff0ef          	jal	ra,4002033c <is_destination_local>
40020e08:	00050913          	mv	s2,a0
		tcp_send(pkt);
40020e0c:	00048513          	mv	a0,s1
40020e10:	fd4ff0ef          	jal	ra,400205e4 <tcp_send>
	if (conn->in_retransmission) {
40020e14:	23d44783          	lbu	a5,573(s0)
40020e18:	0017f793          	andi	a5,a5,1
40020e1c:	f6079ee3          	bnez	a5,40020d98 <tcp_send_process_no_lock+0x128>
	} else if (local && !sys_slist_is_empty(&conn->send_queue)) {
40020e20:	f20900e3          	beqz	s2,40020d40 <tcp_send_process_no_lock+0xd0>
40020e24:	01842783          	lw	a5,24(s0)
40020e28:	f0078ce3          	beqz	a5,40020d40 <tcp_send_process_no_lock+0xd0>
		k_work_reschedule_for_queue(&tcp_work_q, &conn->send_timer,
40020e2c:	00000613          	li	a2,0
40020e30:	00000693          	li	a3,0
40020e34:	f85ff06f          	j	40020db8 <tcp_send_process_no_lock+0x148>
		if (is_destination_local(pkt)) {
40020e38:	d04ff0ef          	jal	ra,4002033c <is_destination_local>
40020e3c:	00050913          	mv	s2,a0
		tcp_send(pkt);
40020e40:	00048513          	mv	a0,s1
40020e44:	fa0ff0ef          	jal	ra,400205e4 <tcp_send>
	return z_timeout_remaining(&dwork->timeout);
40020e48:	0a040513          	addi	a0,s0,160
40020e4c:	63c100ef          	jal	ra,40031488 <z_timeout_remaining>
		if (forget == false &&
40020e50:	00b56533          	or	a0,a0,a1
40020e54:	fc0510e3          	bnez	a0,40020e14 <tcp_send_process_no_lock+0x1a4>
			conn->send_retries = tcp_retries;
40020e58:	00900793          	li	a5,9
40020e5c:	20f42a23          	sw	a5,532(s0)
			conn->in_retransmission = true;
40020e60:	23d44783          	lbu	a5,573(s0)
40020e64:	0017e793          	ori	a5,a5,1
40020e68:	22f40ea3          	sb	a5,573(s0)
40020e6c:	fa9ff06f          	j	40020e14 <tcp_send_process_no_lock+0x1a4>

40020e70 <atomic_inc.isra.0>:
	return z_impl_atomic_add(target, value);
40020e70:	00100593          	li	a1,1
40020e74:	3d51006f          	j	40031a48 <z_impl_atomic_add>

40020e78 <tcp_conn_unref.isra.0>:
static int tcp_conn_unref(struct tcp *conn)
40020e78:	fd010113          	addi	sp,sp,-48
40020e7c:	00a12623          	sw	a0,12(sp)
	int ref_count = atomic_get(&conn->ref_count);
40020e80:	21c50513          	addi	a0,a0,540
static int tcp_conn_unref(struct tcp *conn)
40020e84:	02112623          	sw	ra,44(sp)
40020e88:	02812423          	sw	s0,40(sp)
40020e8c:	02912223          	sw	s1,36(sp)
40020e90:	03212023          	sw	s2,32(sp)
40020e94:	01312e23          	sw	s3,28(sp)
	int ref_count = atomic_get(&conn->ref_count);
40020e98:	3f1100ef          	jal	ra,40031a88 <atomic_get>
	k_mutex_lock(&conn->lock, K_FOREVER);
40020e9c:	00c12503          	lw	a0,12(sp)
40020ea0:	fff00593          	li	a1,-1
40020ea4:	fff00613          	li	a2,-1
40020ea8:	02850513          	addi	a0,a0,40
40020eac:	fc0ff0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	if (conn->in_connect) {
40020eb0:	00c12503          	lw	a0,12(sp)
40020eb4:	23d54783          	lbu	a5,573(a0)
40020eb8:	0027f713          	andi	a4,a5,2
40020ebc:	00070a63          	beqz	a4,40020ed0 <tcp_conn_unref.isra.0+0x58>
		conn->in_connect = false;
40020ec0:	ffd7f793          	andi	a5,a5,-3
40020ec4:	22f50ea3          	sb	a5,573(a0)
	z_impl_k_sem_reset(sem);
40020ec8:	03c50513          	addi	a0,a0,60
40020ecc:	3310e0ef          	jal	ra,4002f9fc <z_impl_k_sem_reset>
	k_mutex_unlock(&conn->lock);
40020ed0:	00c12503          	lw	a0,12(sp)
40020ed4:	02850513          	addi	a0,a0,40
40020ed8:	c49ff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
	ref_count = atomic_dec(&conn->ref_count) - 1;
40020edc:	00c12503          	lw	a0,12(sp)
40020ee0:	21c50513          	addi	a0,a0,540
	return z_impl_atomic_sub(target, value);
40020ee4:	00100593          	li	a1,1
40020ee8:	381100ef          	jal	ra,40031a68 <z_impl_atomic_sub>
	if (ref_count != 0) {
40020eec:	00100793          	li	a5,1
40020ef0:	14f51c63          	bne	a0,a5,40021048 <tcp_conn_unref.isra.0+0x1d0>
	k_mutex_lock(&tcp_lock, K_FOREVER);
40020ef4:	40045937          	lui	s2,0x40045
40020ef8:	fff00593          	li	a1,-1
40020efc:	fff00613          	li	a2,-1
40020f00:	88490513          	addi	a0,s2,-1916 # 40044884 <tcp_lock>
40020f04:	f68ff0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
		if (net_context_packet_received(
40020f08:	00200493          	li	s1,2
	while ((pkt = k_fifo_get(&conn->recv_data, K_NO_WAIT)) != NULL) {
40020f0c:	00c12503          	lw	a0,12(sp)
40020f10:	06c50513          	addi	a0,a0,108
	return z_impl_k_queue_get(queue, timeout);
40020f14:	00000593          	li	a1,0
40020f18:	00000613          	li	a2,0
40020f1c:	1110e0ef          	jal	ra,4002f82c <z_impl_k_queue_get>
40020f20:	00c12783          	lw	a5,12(sp)
40020f24:	00050413          	mv	s0,a0
40020f28:	12051e63          	bnez	a0,40021064 <tcp_conn_unref.isra.0+0x1ec>
	if (conn->context->conn_handler) {
40020f2c:	0047a783          	lw	a5,4(a5)
40020f30:	0447a503          	lw	a0,68(a5)
40020f34:	00050a63          	beqz	a0,40020f48 <tcp_conn_unref.isra.0+0xd0>
		net_conn_unregister(conn->context->conn_handler);
40020f38:	be0f80ef          	jal	ra,40019318 <net_conn_unregister>
		conn->context->conn_handler = NULL;
40020f3c:	00c12783          	lw	a5,12(sp)
40020f40:	0047a783          	lw	a5,4(a5)
40020f44:	0407a223          	sw	zero,68(a5)
	conn->context->tcp = NULL;
40020f48:	00c12783          	lw	a5,12(sp)
40020f4c:	0047a703          	lw	a4,4(a5)
40020f50:	04072a23          	sw	zero,84(a4)
	net_context_unref(conn->context);
40020f54:	0047a503          	lw	a0,4(a5)
40020f58:	83cf50ef          	jal	ra,40015f94 <net_context_unref>
	tcp_send_queue_flush(conn);
40020f5c:	00c12483          	lw	s1,12(sp)
	k_work_cancel_delayable(&conn->send_timer);
40020f60:	09048513          	addi	a0,s1,144
	while ((pkt = tcp_slist(conn, &conn->send_queue, get,
40020f64:	02848993          	addi	s3,s1,40
	k_work_cancel_delayable(&conn->send_timer);
40020f68:	2040f0ef          	jal	ra,4003016c <k_work_cancel_delayable>
	while ((pkt = tcp_slist(conn, &conn->send_queue, get,
40020f6c:	01848493          	addi	s1,s1,24
40020f70:	fff00593          	li	a1,-1
40020f74:	fff00613          	li	a2,-1
40020f78:	00098513          	mv	a0,s3
40020f7c:	ef0ff0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
40020f80:	00048513          	mv	a0,s1
40020f84:	ad0ff0ef          	jal	ra,40020254 <sys_slist_get>
40020f88:	00050413          	mv	s0,a0
40020f8c:	00098513          	mv	a0,s3
40020f90:	10041063          	bnez	s0,40021090 <tcp_conn_unref.isra.0+0x218>
40020f94:	b8dff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
	k_work_cancel_delayable(&conn->send_data_timer);
40020f98:	00c12503          	lw	a0,12(sp)
40020f9c:	0f050513          	addi	a0,a0,240
40020fa0:	1cc0f0ef          	jal	ra,4003016c <k_work_cancel_delayable>
	tcp_pkt_unref(conn->send_data);
40020fa4:	00c12783          	lw	a5,12(sp)
40020fa8:	0087a503          	lw	a0,8(a5)
40020fac:	871f60ef          	jal	ra,4001781c <net_pkt_unref>
		tcp_pkt_unref(conn->queue_recv_data);
40020fb0:	00c12783          	lw	a5,12(sp)
40020fb4:	00c7a503          	lw	a0,12(a5)
40020fb8:	865f60ef          	jal	ra,4001781c <net_pkt_unref>
	(void)k_work_cancel_delayable(&conn->timewait_timer);
40020fbc:	00c12503          	lw	a0,12(sp)
40020fc0:	12050513          	addi	a0,a0,288
40020fc4:	1a80f0ef          	jal	ra,4003016c <k_work_cancel_delayable>
	(void)k_work_cancel_delayable(&conn->fin_timer);
40020fc8:	00c12503          	lw	a0,12(sp)
40020fcc:	1b050513          	addi	a0,a0,432
40020fd0:	19c0f0ef          	jal	ra,4003016c <k_work_cancel_delayable>
	(void)k_work_cancel_delayable(&conn->persist_timer);
40020fd4:	00c12503          	lw	a0,12(sp)
40020fd8:	15050513          	addi	a0,a0,336
40020fdc:	1900f0ef          	jal	ra,4003016c <k_work_cancel_delayable>
	(void)k_work_cancel_delayable(&conn->ack_timer);
40020fe0:	00c12503          	lw	a0,12(sp)
40020fe4:	18050513          	addi	a0,a0,384
40020fe8:	1840f0ef          	jal	ra,4003016c <k_work_cancel_delayable>
	sys_slist_find_and_remove(&tcp_conns, &conn->next);
40020fec:	00c12683          	lw	a3,12(sp)
40020ff0:	400397b7          	lui	a5,0x40039
40020ff4:	0c87a703          	lw	a4,200(a5) # 400390c8 <tcp_conns>
40020ff8:	0c878793          	addi	a5,a5,200
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40020ffc:	02070263          	beqz	a4,40021020 <tcp_conn_unref.isra.0+0x1a8>
40021000:	0ae69a63          	bne	a3,a4,400210b4 <tcp_conn_unref.isra.0+0x23c>
	return node->next;
40021004:	0006a703          	lw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
40021008:	08041c63          	bnez	s0,400210a0 <tcp_conn_unref.isra.0+0x228>
4002100c:	0047a603          	lw	a2,4(a5)
	list->head = node;
40021010:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_REMOVE(slist, snode)
40021014:	00c69463          	bne	a3,a2,4002101c <tcp_conn_unref.isra.0+0x1a4>
	list->tail = node;
40021018:	00e7a223          	sw	a4,4(a5)
	parent->next = child;
4002101c:	0006a023          	sw	zero,0(a3)
	memset(conn, 0, sizeof(*conn));
40021020:	00c12503          	lw	a0,12(sp)
40021024:	24000613          	li	a2,576
40021028:	00000593          	li	a1,0
4002102c:	cf1eb0ef          	jal	ra,4000cd1c <memset>
	k_mem_slab_free(&tcp_conns_slab, (void **)&conn);
40021030:	40044537          	lui	a0,0x40044
40021034:	7d450513          	addi	a0,a0,2004 # 400447d4 <tcp_conns_slab>
40021038:	00c10593          	addi	a1,sp,12
4002103c:	34d0d0ef          	jal	ra,4002eb88 <k_mem_slab_free>
	k_mutex_unlock(&tcp_lock);
40021040:	88490513          	addi	a0,s2,-1916
40021044:	addff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
}
40021048:	02c12083          	lw	ra,44(sp)
4002104c:	02812403          	lw	s0,40(sp)
40021050:	02412483          	lw	s1,36(sp)
40021054:	02012903          	lw	s2,32(sp)
40021058:	01c12983          	lw	s3,28(sp)
4002105c:	03010113          	addi	sp,sp,48
40021060:	00008067          	ret
			    (struct net_conn *)conn->context->conn_handler,
40021064:	0047a503          	lw	a0,4(a5)
		if (net_context_packet_received(
40021068:	0147a703          	lw	a4,20(a5)
4002106c:	00000693          	li	a3,0
40021070:	04452503          	lw	a0,68(a0)
40021074:	00000613          	li	a2,0
40021078:	00040593          	mv	a1,s0
4002107c:	b2df40ef          	jal	ra,40015ba8 <net_context_packet_received>
40021080:	e89516e3          	bne	a0,s1,40020f0c <tcp_conn_unref.isra.0+0x94>
			tcp_pkt_unref(pkt);
40021084:	00040513          	mv	a0,s0
40021088:	f94f60ef          	jal	ra,4001781c <net_pkt_unref>
4002108c:	e81ff06f          	j	40020f0c <tcp_conn_unref.isra.0+0x94>
	while ((pkt = tcp_slist(conn, &conn->send_queue, get,
40021090:	a91ff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
		tcp_pkt_unref(pkt);
40021094:	fe440513          	addi	a0,s0,-28
40021098:	f84f60ef          	jal	ra,4001781c <net_pkt_unref>
4002109c:	ed5ff06f          	j	40020f70 <tcp_conn_unref.isra.0+0xf8>
400210a0:	00e42023          	sw	a4,0(s0)
Z_GENLIST_REMOVE(slist, snode)
400210a4:	0047a703          	lw	a4,4(a5)
400210a8:	f6e69ae3          	bne	a3,a4,4002101c <tcp_conn_unref.isra.0+0x1a4>
	list->tail = node;
400210ac:	0087a223          	sw	s0,4(a5)
}
400210b0:	f6dff06f          	j	4002101c <tcp_conn_unref.isra.0+0x1a4>
	return node->next;
400210b4:	00070413          	mv	s0,a4
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
400210b8:	00072703          	lw	a4,0(a4)
400210bc:	f41ff06f          	j	40020ffc <tcp_conn_unref.isra.0+0x184>

400210c0 <tcp_conn_close.isra.0>:
static int tcp_conn_close(struct tcp *conn, int status)
400210c0:	fe010113          	addi	sp,sp,-32
400210c4:	00812c23          	sw	s0,24(sp)
400210c8:	00112e23          	sw	ra,28(sp)
	if (conn->in_connect) {
400210cc:	23d54783          	lbu	a5,573(a0)
static int tcp_conn_close(struct tcp *conn, int status)
400210d0:	00050413          	mv	s0,a0
400210d4:	00058713          	mv	a4,a1
	if (conn->in_connect) {
400210d8:	0027f793          	andi	a5,a5,2
400210dc:	02078263          	beqz	a5,40021100 <tcp_conn_close.isra.0+0x40>
		if (conn->connect_cb) {
400210e0:	02452783          	lw	a5,36(a0)
400210e4:	00078e63          	beqz	a5,40021100 <tcp_conn_close.isra.0+0x40>
			conn->connect_cb(conn->context, status, conn->context->user_data);
400210e8:	00452503          	lw	a0,4(a0)
400210ec:	00b12623          	sw	a1,12(sp)
400210f0:	00452603          	lw	a2,4(a0)
400210f4:	000780e7          	jalr	a5
			conn->connect_cb = NULL;
400210f8:	00c12703          	lw	a4,12(sp)
400210fc:	02042223          	sw	zero,36(s0)
	if (conn->context->recv_cb) {
40021100:	00442503          	lw	a0,4(s0)
40021104:	04852803          	lw	a6,72(a0)
40021108:	00080c63          	beqz	a6,40021120 <tcp_conn_close.isra.0+0x60>
		conn->context->recv_cb(conn->context, NULL, NULL, NULL,
4002110c:	01442783          	lw	a5,20(s0)
40021110:	00000693          	li	a3,0
40021114:	00000613          	li	a2,0
40021118:	00000593          	li	a1,0
4002111c:	000800e7          	jalr	a6
	return tcp_conn_unref(conn);
40021120:	00040513          	mv	a0,s0
}
40021124:	01812403          	lw	s0,24(sp)
40021128:	01c12083          	lw	ra,28(sp)
4002112c:	02010113          	addi	sp,sp,32
	return tcp_conn_unref(conn);
40021130:	d49ff06f          	j	40020e78 <tcp_conn_unref.isra.0>

40021134 <tcp_send_process>:
{
40021134:	ff010113          	addi	sp,sp,-16
40021138:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4002113c:	f9850413          	addi	s0,a0,-104
{
40021140:	01212023          	sw	s2,0(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
40021144:	fff00593          	li	a1,-1
	struct tcp *conn = CONTAINER_OF(dwork, struct tcp, send_timer);
40021148:	f7050913          	addi	s2,a0,-144
	k_mutex_lock(&conn->lock, K_FOREVER);
4002114c:	fff00613          	li	a2,-1
40021150:	00040513          	mv	a0,s0
{
40021154:	00112623          	sw	ra,12(sp)
40021158:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4002115c:	d10ff0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	unref = tcp_send_process_no_lock(conn);
40021160:	00090513          	mv	a0,s2
40021164:	b0dff0ef          	jal	ra,40020c70 <tcp_send_process_no_lock>
40021168:	00050493          	mv	s1,a0
	k_mutex_unlock(&conn->lock);
4002116c:	00040513          	mv	a0,s0
40021170:	9b1ff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
	if (unref) {
40021174:	02048263          	beqz	s1,40021198 <tcp_send_process+0x64>
}
40021178:	00812403          	lw	s0,8(sp)
4002117c:	00c12083          	lw	ra,12(sp)
40021180:	00412483          	lw	s1,4(sp)
		tcp_conn_close(conn, -ETIMEDOUT);
40021184:	00090513          	mv	a0,s2
}
40021188:	00012903          	lw	s2,0(sp)
		tcp_conn_close(conn, -ETIMEDOUT);
4002118c:	f8c00593          	li	a1,-116
}
40021190:	01010113          	addi	sp,sp,16
		tcp_conn_close(conn, -ETIMEDOUT);
40021194:	f2dff06f          	j	400210c0 <tcp_conn_close.isra.0>
}
40021198:	00c12083          	lw	ra,12(sp)
4002119c:	00812403          	lw	s0,8(sp)
400211a0:	00412483          	lw	s1,4(sp)
400211a4:	00012903          	lw	s2,0(sp)
400211a8:	01010113          	addi	sp,sp,16
400211ac:	00008067          	ret

400211b0 <tcp_timewait_timeout>:
	(void)tcp_conn_close(conn, -ETIMEDOUT);
400211b0:	f8c00593          	li	a1,-116
400211b4:	ee050513          	addi	a0,a0,-288
400211b8:	f09ff06f          	j	400210c0 <tcp_conn_close.isra.0>

400211bc <tcp_fin_timeout>:
	(void)tcp_conn_close(conn, -ETIMEDOUT);
400211bc:	f8c00593          	li	a1,-116
400211c0:	e5050513          	addi	a0,a0,-432
400211c4:	efdff06f          	j	400210c0 <tcp_conn_close.isra.0>

400211c8 <tcp_init_isn>:
{
400211c8:	fa010113          	addi	sp,sp,-96
400211cc:	04812c23          	sw	s0,88(sp)
400211d0:	04112e23          	sw	ra,92(sp)
400211d4:	04912a23          	sw	s1,84(sp)
400211d8:	05212823          	sw	s2,80(sp)
		    saddr->sa_family == AF_INET6) {
400211dc:	00055483          	lhu	s1,0(a0)
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
400211e0:	00200793          	li	a5,2
{
400211e4:	00058413          	mv	s0,a1
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
400211e8:	0af49e63          	bne	s1,a5,400212a4 <tcp_init_isn+0xdc>
			return tcpv6_init_isn(&net_sin6(saddr)->sin6_addr,
400211ec:	0025d483          	lhu	s1,2(a1)
400211f0:	00255903          	lhu	s2,2(a0)
	} buf = {
400211f4:	00450593          	addi	a1,a0,4
400211f8:	01000613          	li	a2,16
400211fc:	02c10513          	addi	a0,sp,44
40021200:	00012e23          	sw	zero,28(sp)
40021204:	02012023          	sw	zero,32(sp)
40021208:	02012223          	sw	zero,36(sp)
4002120c:	02012423          	sw	zero,40(sp)
40021210:	ae9eb0ef          	jal	ra,4000ccf8 <memcpy>
40021214:	00440593          	addi	a1,s0,4
40021218:	01000613          	li	a2,16
4002121c:	03c10513          	addi	a0,sp,60
40021220:	ad9eb0ef          	jal	ra,4000ccf8 <memcpy>
40021224:	04911723          	sh	s1,78(sp)
	if (!once) {
40021228:	400394b7          	lui	s1,0x40039
4002122c:	10b4c783          	lbu	a5,267(s1) # 4003910b <once.1>
	} buf = {
40021230:	05211623          	sh	s2,76(sp)
40021234:	4003b437          	lui	s0,0x4003b
	if (!once) {
40021238:	00079c63          	bnez	a5,40021250 <tcp_init_isn+0x88>
4002123c:	01000593          	li	a1,16
40021240:	f8840513          	addi	a0,s0,-120 # 4003af88 <unique_key>
40021244:	820ec0ef          	jal	ra,4000d264 <z_impl_sys_rand_get>
		once = true;
40021248:	00100793          	li	a5,1
4002124c:	10f485a3          	sb	a5,267(s1)
	memcpy(buf.key, unique_key, sizeof(buf.key));
40021250:	01000613          	li	a2,16
40021254:	f8840593          	addi	a1,s0,-120
40021258:	01c10513          	addi	a0,sp,28
4002125c:	a9deb0ef          	jal	ra,4000ccf8 <memcpy>
	mbedtls_md5((const unsigned char *)&buf, sizeof(buf), hash);
40021260:	00c10613          	addi	a2,sp,12
40021264:	03400593          	li	a1,52
	mbedtls_md5((const unsigned char *)&buf, sizeof(buf), hash);
40021268:	01c10513          	addi	a0,sp,28
4002126c:	6d90c0ef          	jal	ra,4002e144 <mbedtls_md5>
	return seq_scale(UNALIGNED_GET((uint32_t *)&hash[0]));
40021270:	00c12403          	lw	s0,12(sp)
	return z_impl_k_uptime_ticks();
40021274:	3e0100ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
			return ((uint32_t)t) * (to_hz / from_hz);
40021278:	009897b7          	lui	a5,0x989
4002127c:	68078793          	addi	a5,a5,1664 # 989680 <__rom_region_size+0x9506c4>
40021280:	02f50533          	mul	a0,a0,a5
}
40021284:	05c12083          	lw	ra,92(sp)
40021288:	05412483          	lw	s1,84(sp)
4002128c:	05012903          	lw	s2,80(sp)
	return seq + (k_ticks_to_ns_floor32(k_uptime_ticks()) >> 6);
40021290:	00655513          	srli	a0,a0,0x6
40021294:	00850533          	add	a0,a0,s0
}
40021298:	05812403          	lw	s0,88(sp)
4002129c:	06010113          	addi	sp,sp,96
400212a0:	00008067          	ret
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
400212a4:	00100793          	li	a5,1
400212a8:	06f49863          	bne	s1,a5,40021318 <tcp_init_isn+0x150>
			return tcpv4_init_isn(&net_sin(saddr)->sin_addr,
400212ac:	0025d783          	lhu	a5,2(a1)
400212b0:	00255703          	lhu	a4,2(a0)
400212b4:	00452603          	lw	a2,4(a0)
400212b8:	0045a683          	lw	a3,4(a1)
	if (!once) {
400212bc:	40039937          	lui	s2,0x40039
	} buf = {
400212c0:	02f11b23          	sh	a5,54(sp)
	if (!once) {
400212c4:	10a94783          	lbu	a5,266(s2) # 4003910a <once.0>
	} buf = {
400212c8:	00012e23          	sw	zero,28(sp)
400212cc:	02012023          	sw	zero,32(sp)
400212d0:	02012223          	sw	zero,36(sp)
400212d4:	02012423          	sw	zero,40(sp)
400212d8:	02c12623          	sw	a2,44(sp)
400212dc:	02d12823          	sw	a3,48(sp)
400212e0:	02e11a23          	sh	a4,52(sp)
400212e4:	4003b437          	lui	s0,0x4003b
	if (!once) {
400212e8:	00079a63          	bnez	a5,400212fc <tcp_init_isn+0x134>
400212ec:	01000593          	li	a1,16
400212f0:	f8840513          	addi	a0,s0,-120 # 4003af88 <unique_key>
400212f4:	f71eb0ef          	jal	ra,4000d264 <z_impl_sys_rand_get>
		once = true;
400212f8:	10990523          	sb	s1,266(s2)
	memcpy(buf.key, unique_key, sizeof(unique_key));
400212fc:	01000613          	li	a2,16
40021300:	f8840593          	addi	a1,s0,-120
40021304:	01c10513          	addi	a0,sp,28
40021308:	9f1eb0ef          	jal	ra,4000ccf8 <memcpy>
	mbedtls_md5((const unsigned char *)&buf, sizeof(buf), hash);
4002130c:	00c10613          	addi	a2,sp,12
40021310:	01c00593          	li	a1,28
40021314:	f55ff06f          	j	40021268 <tcp_init_isn+0xa0>
}
40021318:	05812403          	lw	s0,88(sp)
4002131c:	05c12083          	lw	ra,92(sp)
40021320:	05412483          	lw	s1,84(sp)
40021324:	05012903          	lw	s2,80(sp)
40021328:	06010113          	addi	sp,sp,96
	return z_impl_sys_rand32_get();
4002132c:	ef5eb06f          	j	4000d220 <z_impl_sys_rand32_get>

40021330 <net_tcp_get>:
{
40021330:	fc010113          	addi	sp,sp,-64
40021334:	02812c23          	sw	s0,56(sp)
40021338:	02912a23          	sw	s1,52(sp)
4002133c:	04010413          	addi	s0,sp,64
40021340:	03212823          	sw	s2,48(sp)
40021344:	03312623          	sw	s3,44(sp)
40021348:	02112e23          	sw	ra,60(sp)
	k_mutex_lock(&tcp_lock, K_FOREVER);
4002134c:	40045937          	lui	s2,0x40045
40021350:	fff00593          	li	a1,-1
40021354:	fff00613          	li	a2,-1
{
40021358:	00050493          	mv	s1,a0
	k_mutex_lock(&tcp_lock, K_FOREVER);
4002135c:	88490513          	addi	a0,s2,-1916 # 40044884 <tcp_lock>
40021360:	b0cff0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	ret = k_mem_slab_alloc(&tcp_conns_slab, (void **)&conn, K_NO_WAIT);
40021364:	400449b7          	lui	s3,0x40044
40021368:	00000613          	li	a2,0
4002136c:	00000693          	li	a3,0
40021370:	fc440593          	addi	a1,s0,-60
40021374:	7d498513          	addi	a0,s3,2004 # 400447d4 <tcp_conns_slab>
	struct tcp *conn = NULL;
40021378:	fc042223          	sw	zero,-60(s0)
	ret = k_mem_slab_alloc(&tcp_conns_slab, (void **)&conn, K_NO_WAIT);
4002137c:	77c0d0ef          	jal	ra,4002eaf8 <k_mem_slab_alloc>
	if (ret) {
40021380:	06050a63          	beqz	a0,400213f4 <net_tcp_get+0xc4>
		NET_ERR("Cannot allocate slab");
40021384:	40044537          	lui	a0,0x40044
40021388:	7a052783          	lw	a5,1952(a0) # 400447a0 <log_dynamic_net_tcp>
4002138c:	0077f793          	andi	a5,a5,7
40021390:	02078663          	beqz	a5,400213bc <net_tcp_get+0x8c>
40021394:	400357b7          	lui	a5,0x40035
40021398:	33878793          	addi	a5,a5,824 # 40035338 <CSWTCH.16862+0x140>
4002139c:	000015b7          	lui	a1,0x1
400213a0:	fcf42e23          	sw	a5,-36(s0)
400213a4:	fd840613          	addi	a2,s0,-40
400213a8:	00200793          	li	a5,2
400213ac:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
400213b0:	7a050513          	addi	a0,a0,1952
400213b4:	fcf42c23          	sw	a5,-40(s0)
400213b8:	970ff0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
	return conn;
400213bc:	fc442783          	lw	a5,-60(s0)
	if (conn == NULL) {
400213c0:	26079a63          	bnez	a5,40021634 <net_tcp_get+0x304>
		ret = -ENOMEM;
400213c4:	ff400493          	li	s1,-12
	k_mutex_unlock(&tcp_lock);
400213c8:	88490513          	addi	a0,s2,-1916
400213cc:	f54ff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
}
400213d0:	fc040113          	addi	sp,s0,-64
400213d4:	03c12083          	lw	ra,60(sp)
400213d8:	00048513          	mv	a0,s1
400213dc:	03812403          	lw	s0,56(sp)
400213e0:	03412483          	lw	s1,52(sp)
400213e4:	03012903          	lw	s2,48(sp)
400213e8:	02c12983          	lw	s3,44(sp)
400213ec:	04010113          	addi	sp,sp,64
400213f0:	00008067          	ret
	memset(conn, 0, sizeof(*conn));
400213f4:	fc442503          	lw	a0,-60(s0)
400213f8:	24000613          	li	a2,576
400213fc:	00000593          	li	a1,0
40021400:	91deb0ef          	jal	ra,4000cd1c <memset>
		conn->queue_recv_data = tcp_rx_pkt_alloc(conn, 0);
40021404:	00a00513          	li	a0,10
40021408:	00000593          	li	a1,0
4002140c:	fc4f60ef          	jal	ra,40017bd0 <net_pkt_rx_alloc>
40021410:	fc442703          	lw	a4,-60(s0)
40021414:	00a72623          	sw	a0,12(a4)
		if (conn->queue_recv_data == NULL) {
40021418:	08051863          	bnez	a0,400214a8 <net_tcp_get+0x178>
			NET_ERR("Cannot allocate %s queue for conn %p", "recv",
4002141c:	40044537          	lui	a0,0x40044
40021420:	7a052783          	lw	a5,1952(a0) # 400447a0 <log_dynamic_net_tcp>
40021424:	0077f793          	andi	a5,a5,7
40021428:	04078c63          	beqz	a5,40021480 <net_tcp_get+0x150>
4002142c:	00010493          	mv	s1,sp
40021430:	fd010113          	addi	sp,sp,-48
40021434:	00010613          	mv	a2,sp
40021438:	400357b7          	lui	a5,0x40035
4002143c:	35078793          	addi	a5,a5,848 # 40035350 <CSWTCH.16862+0x158>
40021440:	00f62a23          	sw	a5,20(a2)
40021444:	400357b7          	lui	a5,0x40035
40021448:	37878793          	addi	a5,a5,888 # 40035378 <CSWTCH.16862+0x180>
4002144c:	00f62c23          	sw	a5,24(a2)
40021450:	00e62e23          	sw	a4,28(a2)
		NET_ERR("Cannot allocate %s queue for conn %p", "send", conn);
40021454:	20000793          	li	a5,512
40021458:	02f61023          	sh	a5,32(a2)
4002145c:	010007b7          	lui	a5,0x1000
40021460:	00478793          	addi	a5,a5,4 # 1000004 <__rom_region_size+0xfc7048>
40021464:	000025b7          	lui	a1,0x2
40021468:	00f62823          	sw	a5,16(a2)
4002146c:	44058593          	addi	a1,a1,1088 # 2440 <CONFIG_SRAM_SIZE+0x440>
40021470:	01060613          	addi	a2,a2,16
40021474:	7a050513          	addi	a0,a0,1952
40021478:	8b0ff0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
4002147c:	00048113          	mv	sp,s1
	if (CONFIG_NET_TCP_RECV_QUEUE_TIMEOUT && conn->queue_recv_data) {
40021480:	fc442783          	lw	a5,-60(s0)
40021484:	00c7a503          	lw	a0,12(a5)
40021488:	00050863          	beqz	a0,40021498 <net_tcp_get+0x168>
		tcp_pkt_unref(conn->queue_recv_data);
4002148c:	b90f60ef          	jal	ra,4001781c <net_pkt_unref>
		conn->queue_recv_data = NULL;
40021490:	fc442783          	lw	a5,-60(s0)
40021494:	0007a623          	sw	zero,12(a5)
	k_mem_slab_free(&tcp_conns_slab, (void **)&conn);
40021498:	fc440593          	addi	a1,s0,-60
4002149c:	7d498513          	addi	a0,s3,2004
400214a0:	6e80d0ef          	jal	ra,4002eb88 <k_mem_slab_free>
	if (conn == NULL) {
400214a4:	f21ff06f          	j	400213c4 <net_tcp_get+0x94>
	conn->send_data = tcp_pkt_alloc(conn, 0);
400214a8:	00a00513          	li	a0,10
400214ac:	00000593          	li	a1,0
400214b0:	f0cf60ef          	jal	ra,40017bbc <net_pkt_alloc>
400214b4:	fc442783          	lw	a5,-60(s0)
400214b8:	00a7a423          	sw	a0,8(a5)
	if (conn->send_data == NULL) {
400214bc:	04051063          	bnez	a0,400214fc <net_tcp_get+0x1cc>
		NET_ERR("Cannot allocate %s queue for conn %p", "send", conn);
400214c0:	40044537          	lui	a0,0x40044
400214c4:	7a052703          	lw	a4,1952(a0) # 400447a0 <log_dynamic_net_tcp>
400214c8:	00777713          	andi	a4,a4,7
400214cc:	fa070ae3          	beqz	a4,40021480 <net_tcp_get+0x150>
400214d0:	00010493          	mv	s1,sp
400214d4:	fd010113          	addi	sp,sp,-48
400214d8:	00010613          	mv	a2,sp
400214dc:	40035737          	lui	a4,0x40035
400214e0:	35070713          	addi	a4,a4,848 # 40035350 <CSWTCH.16862+0x158>
400214e4:	00e62a23          	sw	a4,20(a2)
400214e8:	40035737          	lui	a4,0x40035
400214ec:	38070713          	addi	a4,a4,896 # 40035380 <CSWTCH.16862+0x188>
400214f0:	00e62c23          	sw	a4,24(a2)
400214f4:	00f62e23          	sw	a5,28(a2)
400214f8:	f5dff06f          	j	40021454 <net_tcp_get+0x124>
	return z_impl_k_mutex_init(mutex);
400214fc:	02878513          	addi	a0,a5,40
40021500:	7250d0ef          	jal	ra,4002f424 <z_impl_k_mutex_init>
	k_fifo_init(&conn->recv_data);
40021504:	fc442503          	lw	a0,-60(s0)
40021508:	06c50513          	addi	a0,a0,108
	z_impl_k_queue_init(queue);
4002150c:	2d40e0ef          	jal	ra,4002f7e0 <z_impl_k_queue_init>
	k_sem_init(&conn->connect_sem, 0, K_SEM_MAX_LIMIT);
40021510:	fc442503          	lw	a0,-60(s0)
40021514:	03c50513          	addi	a0,a0,60
	return z_impl_k_sem_init(sem, initial_count, limit);
40021518:	fff00613          	li	a2,-1
4002151c:	00000593          	li	a1,0
40021520:	3e00e0ef          	jal	ra,4002f900 <z_impl_k_sem_init>
	k_sem_init(&conn->tx_sem, 1, 1);
40021524:	fc442503          	lw	a0,-60(s0)
40021528:	05450513          	addi	a0,a0,84
4002152c:	00100613          	li	a2,1
40021530:	00100593          	li	a1,1
40021534:	3cc0e0ef          	jal	ra,4002f900 <z_impl_k_sem_init>
	conn->in_connect = false;
40021538:	fc442503          	lw	a0,-60(s0)
	conn->state = TCP_LISTEN;
4002153c:	00100713          	li	a4,1
	k_work_init_delayable(&conn->send_timer, tcp_send_process);
40021540:	400215b7          	lui	a1,0x40021
	conn->state = TCP_LISTEN;
40021544:	22e52023          	sw	a4,544(a0)
	conn->recv_win_max = tcp_rx_window;
40021548:	05550737          	lui	a4,0x5550
4002154c:	55570713          	addi	a4,a4,1365 # 5550555 <__rom_region_size+0x5517599>
40021550:	22e52823          	sw	a4,560(a0)
	conn->send_win_max = MAX(tcp_tx_window, NET_IPV6_MTU);
40021554:	22e52a23          	sw	a4,564(a0)
	conn->in_connect = false;
40021558:	23d54703          	lbu	a4,573(a0)
	conn->dup_ack_cnt = 0;
4002155c:	22050da3          	sb	zero,571(a0)
	conn->seq = 0U;
40021560:	22052423          	sw	zero,552(a0)
	conn->in_connect = false;
40021564:	ff577713          	andi	a4,a4,-11
40021568:	22e50ea3          	sb	a4,573(a0)
	list->head = NULL;
4002156c:	00052c23          	sw	zero,24(a0)
	list->tail = NULL;
40021570:	00052e23          	sw	zero,28(a0)
	k_work_init_delayable(&conn->send_timer, tcp_send_process);
40021574:	13458593          	addi	a1,a1,308 # 40021134 <tcp_send_process>
40021578:	09050513          	addi	a0,a0,144
4002157c:	2890e0ef          	jal	ra,40030004 <k_work_init_delayable>
	k_work_init_delayable(&conn->timewait_timer, tcp_timewait_timeout);
40021580:	fc442503          	lw	a0,-60(s0)
40021584:	400215b7          	lui	a1,0x40021
40021588:	1b058593          	addi	a1,a1,432 # 400211b0 <tcp_timewait_timeout>
4002158c:	12050513          	addi	a0,a0,288
40021590:	2750e0ef          	jal	ra,40030004 <k_work_init_delayable>
	k_work_init_delayable(&conn->fin_timer, tcp_fin_timeout);
40021594:	fc442503          	lw	a0,-60(s0)
40021598:	400215b7          	lui	a1,0x40021
4002159c:	1bc58593          	addi	a1,a1,444 # 400211bc <tcp_fin_timeout>
400215a0:	1b050513          	addi	a0,a0,432
400215a4:	2610e0ef          	jal	ra,40030004 <k_work_init_delayable>
	k_work_init_delayable(&conn->send_data_timer, tcp_resend_data);
400215a8:	fc442503          	lw	a0,-60(s0)
400215ac:	400225b7          	lui	a1,0x40022
400215b0:	2f058593          	addi	a1,a1,752 # 400222f0 <tcp_resend_data>
400215b4:	0f050513          	addi	a0,a0,240
400215b8:	24d0e0ef          	jal	ra,40030004 <k_work_init_delayable>
	k_work_init_delayable(&conn->recv_queue_timer, tcp_cleanup_recv_queue);
400215bc:	fc442503          	lw	a0,-60(s0)
400215c0:	400215b7          	lui	a1,0x40021
400215c4:	c1c58593          	addi	a1,a1,-996 # 40020c1c <tcp_cleanup_recv_queue>
400215c8:	0c050513          	addi	a0,a0,192
400215cc:	2390e0ef          	jal	ra,40030004 <k_work_init_delayable>
	k_work_init_delayable(&conn->persist_timer, tcp_send_zwp);
400215d0:	fc442503          	lw	a0,-60(s0)
400215d4:	400225b7          	lui	a1,0x40022
400215d8:	d4c58593          	addi	a1,a1,-692 # 40021d4c <tcp_send_zwp>
400215dc:	15050513          	addi	a0,a0,336
400215e0:	2250e0ef          	jal	ra,40030004 <k_work_init_delayable>
	k_work_init_delayable(&conn->ack_timer, tcp_send_ack);
400215e4:	fc442503          	lw	a0,-60(s0)
400215e8:	400225b7          	lui	a1,0x40022
400215ec:	d0058593          	addi	a1,a1,-768 # 40021d00 <tcp_send_ack>
400215f0:	18050513          	addi	a0,a0,384
400215f4:	2110e0ef          	jal	ra,40030004 <k_work_init_delayable>
	int ref_count = atomic_inc(&conn->ref_count) + 1;
400215f8:	fc442503          	lw	a0,-60(s0)
400215fc:	21c50513          	addi	a0,a0,540
40021600:	871ff0ef          	jal	ra,40020e70 <atomic_inc.isra.0>
	sys_slist_append(&tcp_conns, &conn->next);
40021604:	fc442703          	lw	a4,-60(s0)
	return list->tail;
40021608:	400397b7          	lui	a5,0x40039
4002160c:	0c878793          	addi	a5,a5,200 # 400390c8 <tcp_conns>
	parent->next = child;
40021610:	00072023          	sw	zero,0(a4)
	return list->tail;
40021614:	0047a683          	lw	a3,4(a5)
Z_GENLIST_APPEND(slist, snode)
40021618:	00069863          	bnez	a3,40021628 <net_tcp_get+0x2f8>
	list->tail = node;
4002161c:	00e7a223          	sw	a4,4(a5)
	list->head = node;
40021620:	00e7a023          	sw	a4,0(a5)
}
40021624:	d99ff06f          	j	400213bc <net_tcp_get+0x8c>
	parent->next = child;
40021628:	00e6a023          	sw	a4,0(a3)
	list->tail = node;
4002162c:	00e7a223          	sw	a4,4(a5)
}
40021630:	d8dff06f          	j	400213bc <net_tcp_get+0x8c>
	conn->context = context;
40021634:	0097a223          	sw	s1,4(a5)
	context->tcp = conn;
40021638:	04f4aa23          	sw	a5,84(s1)
	int ret = 0;
4002163c:	00000493          	li	s1,0
40021640:	d89ff06f          	j	400213c8 <net_tcp_get+0x98>

40021644 <net_tcp_send_data>:

/* net context is about to send out queued data - inform caller only */
int net_tcp_send_data(struct net_context *context, net_context_send_cb_t cb,
		      void *user_data)
{
	if (cb) {
40021644:	02058463          	beqz	a1,4002166c <net_tcp_send_data+0x28>
{
40021648:	ff010113          	addi	sp,sp,-16
4002164c:	00112623          	sw	ra,12(sp)
40021650:	00058793          	mv	a5,a1
		cb(context, 0, user_data);
40021654:	00000593          	li	a1,0
40021658:	000780e7          	jalr	a5
	}

	return 0;
}
4002165c:	00c12083          	lw	ra,12(sp)
40021660:	00000513          	li	a0,0
40021664:	01010113          	addi	sp,sp,16
40021668:	00008067          	ret
4002166c:	00000513          	li	a0,0
40021670:	00008067          	ret

40021674 <net_tcp_recv>:
}

int net_tcp_recv(struct net_context *context, net_context_recv_cb_t cb,
		 void *user_data)
{
	struct tcp *conn = context->tcp;
40021674:	05452783          	lw	a5,84(a0)

	NET_DBG("context: %p, cb: %p, user_data: %p", context, cb, user_data);

	context->recv_cb = cb;
40021678:	04b52423          	sw	a1,72(a0)

	if (conn) {
4002167c:	00078463          	beqz	a5,40021684 <net_tcp_recv+0x10>
		conn->recv_user_data = user_data;
40021680:	00c7aa23          	sw	a2,20(a5)
	}

	return 0;
}
40021684:	00000513          	li	a0,0
40021688:	00008067          	ret

4002168c <net_tcp_finalize>:

int net_tcp_finalize(struct net_pkt *pkt)
{
4002168c:	fd010113          	addi	sp,sp,-48
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
40021690:	00c10793          	addi	a5,sp,12
40021694:	00f12223          	sw	a5,4(sp)
	struct net_tcp_hdr *tcp_hdr;

	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
40021698:	00410593          	addi	a1,sp,4
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
4002169c:	01400793          	li	a5,20
{
400216a0:	02912223          	sw	s1,36(sp)
400216a4:	02112623          	sw	ra,44(sp)
400216a8:	02812423          	sw	s0,40(sp)
400216ac:	00050493          	mv	s1,a0
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
400216b0:	00f12423          	sw	a5,8(sp)
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
400216b4:	a34f70ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!tcp_hdr) {
400216b8:	04050a63          	beqz	a0,4002170c <net_tcp_finalize+0x80>
		return -ENOBUFS;
	}

	tcp_hdr->chksum = 0U;
400216bc:	00050823          	sb	zero,16(a0)
400216c0:	000508a3          	sb	zero,17(a0)
400216c4:	00050413          	mv	s0,a0

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
400216c8:	0184a503          	lw	a0,24(s1)
400216cc:	c84f20ef          	jal	ra,40013b50 <net_if_need_calc_tx_checksum>
400216d0:	00050e63          	beqz	a0,400216ec <net_tcp_finalize+0x60>
	return net_calc_chksum(pkt, IPPROTO_TCP);
400216d4:	00600593          	li	a1,6
400216d8:	00048513          	mv	a0,s1
400216dc:	815f30ef          	jal	ra,40014ef0 <net_calc_chksum>
		tcp_hdr->chksum = net_calc_chksum_tcp(pkt);
400216e0:	00855793          	srli	a5,a0,0x8
400216e4:	00a40823          	sb	a0,16(s0)
400216e8:	00f408a3          	sb	a5,17(s0)
	}

	return net_pkt_set_data(pkt, &tcp_access);
400216ec:	00410593          	addi	a1,sp,4
400216f0:	00048513          	mv	a0,s1
400216f4:	ac4f70ef          	jal	ra,400189b8 <net_pkt_set_data>
}
400216f8:	02c12083          	lw	ra,44(sp)
400216fc:	02812403          	lw	s0,40(sp)
40021700:	02412483          	lw	s1,36(sp)
40021704:	03010113          	addi	sp,sp,48
40021708:	00008067          	ret
		return -ENOBUFS;
4002170c:	f9700513          	li	a0,-105
40021710:	fe9ff06f          	j	400216f8 <net_tcp_finalize+0x6c>

40021714 <net_tcp_input>:

struct net_tcp_hdr *net_tcp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *tcp_access)
{
40021714:	ff010113          	addi	sp,sp,-16
40021718:	00812423          	sw	s0,8(sp)
4002171c:	01212023          	sw	s2,0(sp)
40021720:	00112623          	sw	ra,12(sp)
40021724:	00912223          	sw	s1,4(sp)
40021728:	00050413          	mv	s0,a0
	struct net_tcp_hdr *tcp_hdr;

	if (IS_ENABLED(CONFIG_NET_TCP_CHECKSUM) &&
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
4002172c:	01852503          	lw	a0,24(a0)
{
40021730:	00058913          	mv	s2,a1
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
40021734:	c24f20ef          	jal	ra,40013b58 <net_if_need_calc_rx_checksum>
	if (IS_ENABLED(CONFIG_NET_TCP_CHECKSUM) &&
40021738:	04051e63          	bnez	a0,40021794 <net_tcp_input+0x80>
	    net_calc_chksum_tcp(pkt) != 0U) {
		NET_DBG("DROP: checksum mismatch");
		goto drop;
	}

	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, tcp_access);
4002173c:	00090593          	mv	a1,s2
40021740:	00040513          	mv	a0,s0
40021744:	9a4f70ef          	jal	ra,400188e8 <net_pkt_get_data>
40021748:	00050493          	mv	s1,a0
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
4002174c:	04051e63          	bnez	a0,400217a8 <net_tcp_input+0x94>
	UPDATE_STAT(iface, stats.tcp.chkerr++);
40021750:	4003b7b7          	lui	a5,0x4003b
40021754:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40021758:	0747a703          	lw	a4,116(a5)
	return pkt->iface;
4002175c:	01842683          	lw	a3,24(s0)
		return tcp_hdr;
	}

drop:
	net_stats_update_tcp_seg_chkerr(net_pkt_iface(pkt));
	return NULL;
40021760:	00000493          	li	s1,0
40021764:	00170713          	addi	a4,a4,1
40021768:	06e7aa23          	sw	a4,116(a5)
4002176c:	0786a783          	lw	a5,120(a3)
40021770:	00178793          	addi	a5,a5,1
40021774:	06f6ac23          	sw	a5,120(a3)
}
40021778:	00c12083          	lw	ra,12(sp)
4002177c:	00812403          	lw	s0,8(sp)
40021780:	00012903          	lw	s2,0(sp)
40021784:	00048513          	mv	a0,s1
40021788:	00412483          	lw	s1,4(sp)
4002178c:	01010113          	addi	sp,sp,16
40021790:	00008067          	ret
40021794:	00600593          	li	a1,6
40021798:	00040513          	mv	a0,s0
4002179c:	f54f30ef          	jal	ra,40014ef0 <net_calc_chksum>
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
400217a0:	f8050ee3          	beqz	a0,4002173c <net_tcp_input+0x28>
400217a4:	fadff06f          	j	40021750 <net_tcp_input+0x3c>
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
400217a8:	00090593          	mv	a1,s2
400217ac:	00040513          	mv	a0,s0
400217b0:	a08f70ef          	jal	ra,400189b8 <net_pkt_set_data>
400217b4:	fc0502e3          	beqz	a0,40021778 <net_tcp_input+0x64>
drop:
400217b8:	f99ff06f          	j	40021750 <net_tcp_input+0x3c>

400217bc <net_tcp_foreach>:
	}
}
#endif /* CONFIG_NET_TEST_PROTOCOL */

void net_tcp_foreach(net_tcp_cb_t cb, void *user_data)
{
400217bc:	fe010113          	addi	sp,sp,-32
400217c0:	00912a23          	sw	s1,20(sp)
	struct tcp *conn;
	struct tcp *tmp;

	k_mutex_lock(&tcp_lock, K_FOREVER);
400217c4:	400454b7          	lui	s1,0x40045
{
400217c8:	01312623          	sw	s3,12(sp)
400217cc:	01412423          	sw	s4,8(sp)
400217d0:	00050993          	mv	s3,a0
400217d4:	00058a13          	mv	s4,a1
	k_mutex_lock(&tcp_lock, K_FOREVER);
400217d8:	fff00613          	li	a2,-1
400217dc:	fff00593          	li	a1,-1
400217e0:	88448513          	addi	a0,s1,-1916 # 40044884 <tcp_lock>
{
400217e4:	00812c23          	sw	s0,24(sp)
400217e8:	00112e23          	sw	ra,28(sp)
400217ec:	01212823          	sw	s2,16(sp)
	k_mutex_lock(&tcp_lock, K_FOREVER);
400217f0:	e7dfe0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	return list->head;
400217f4:	400397b7          	lui	a5,0x40039
400217f8:	0c87a403          	lw	s0,200(a5) # 400390c8 <tcp_conns>

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp_conns, conn, tmp, next) {
400217fc:	00040663          	beqz	s0,40021808 <net_tcp_foreach+0x4c>
	return node->next;
40021800:	00042903          	lw	s2,0(s0)
40021804:	02041463          	bnez	s0,4002182c <net_tcp_foreach+0x70>
			k_mutex_lock(&tcp_lock, K_FOREVER);
		}
	}

	k_mutex_unlock(&tcp_lock);
}
40021808:	01812403          	lw	s0,24(sp)
4002180c:	01c12083          	lw	ra,28(sp)
40021810:	01012903          	lw	s2,16(sp)
40021814:	00c12983          	lw	s3,12(sp)
40021818:	00812a03          	lw	s4,8(sp)
	k_mutex_unlock(&tcp_lock);
4002181c:	88448513          	addi	a0,s1,-1916
}
40021820:	01412483          	lw	s1,20(sp)
40021824:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&tcp_lock);
40021828:	af8ff06f          	j	40020b20 <k_mutex_unlock.isra.0>
		if (atomic_get(&conn->ref_count) > 0) {
4002182c:	21c40513          	addi	a0,s0,540
40021830:	258100ef          	jal	ra,40031a88 <atomic_get>
40021834:	02a05463          	blez	a0,4002185c <net_tcp_foreach+0xa0>
			k_mutex_unlock(&tcp_lock);
40021838:	88448513          	addi	a0,s1,-1916
4002183c:	ae4ff0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
			cb(conn, user_data);
40021840:	000a0593          	mv	a1,s4
40021844:	00040513          	mv	a0,s0
40021848:	000980e7          	jalr	s3
			k_mutex_lock(&tcp_lock, K_FOREVER);
4002184c:	fff00593          	li	a1,-1
40021850:	fff00613          	li	a2,-1
40021854:	88448513          	addi	a0,s1,-1916
40021858:	e15fe0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp_conns, conn, tmp, next) {
4002185c:	00000793          	li	a5,0
40021860:	00090463          	beqz	s2,40021868 <net_tcp_foreach+0xac>
40021864:	00092783          	lw	a5,0(s2)
40021868:	00090413          	mv	s0,s2
4002186c:	00078913          	mv	s2,a5
40021870:	f95ff06f          	j	40021804 <net_tcp_foreach+0x48>

40021874 <net_tcp_get_supported_mss>:

uint16_t net_tcp_get_supported_mss(const struct tcp *conn)
{
40021874:	ff010113          	addi	sp,sp,-16
40021878:	00112623          	sw	ra,12(sp)
	sa_family_t family = net_context_get_family(conn->context);
4002187c:	00452703          	lw	a4,4(a0)

	if (family == AF_INET) {
40021880:	00100693          	li	a3,1
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40021884:	07475783          	lhu	a5,116(a4)
40021888:	0037d793          	srli	a5,a5,0x3
4002188c:	0077f793          	andi	a5,a5,7
40021890:	04d79463          	bne	a5,a3,400218d8 <net_tcp_get_supported_mss+0x64>
#if defined(CONFIG_NET_IPV4)
		struct net_if *iface = net_context_get_iface(conn->context);
40021894:	07670503          	lb	a0,118(a4)
40021898:	e65fe0ef          	jal	ra,400206fc <net_context_get_iface.isra.0>
			 */
			mss = net_if_get_mtu(iface) - NET_IPV4TCPH_LEN;
		}

		if (mss == 0) {
			mss = NET_IPV4_MTU - NET_IPV4TCPH_LEN;
4002189c:	21800793          	li	a5,536
		if (iface && net_if_get_mtu(iface) >= NET_IPV4TCPH_LEN) {
400218a0:	02050263          	beqz	a0,400218c4 <net_tcp_get_supported_mss+0x50>
	return iface->if_dev->mtu;
400218a4:	00052783          	lw	a5,0(a0)
400218a8:	02700693          	li	a3,39
400218ac:	0187d703          	lhu	a4,24(a5)
			mss = NET_IPV4_MTU - NET_IPV4TCPH_LEN;
400218b0:	21800793          	li	a5,536
		if (iface && net_if_get_mtu(iface) >= NET_IPV4TCPH_LEN) {
400218b4:	00e6f863          	bgeu	a3,a4,400218c4 <net_tcp_get_supported_mss+0x50>
			mss = net_if_get_mtu(iface) - NET_IPV4TCPH_LEN;
400218b8:	fd870793          	addi	a5,a4,-40
		if (mss == 0) {
400218bc:	00079463          	bnez	a5,400218c4 <net_tcp_get_supported_mss+0x50>
			mss = NET_IPV4_MTU - NET_IPV4TCPH_LEN;
400218c0:	21800793          	li	a5,536

		if (mss == 0) {
			mss = NET_IPV6_MTU - NET_IPV6TCPH_LEN;
		}

		return mss;
400218c4:	01079513          	slli	a0,a5,0x10
400218c8:	01055513          	srli	a0,a0,0x10
	}
#endif /* CONFIG_NET_IPV6 */

	return 0;
}
400218cc:	00c12083          	lw	ra,12(sp)
400218d0:	01010113          	addi	sp,sp,16
400218d4:	00008067          	ret
	else if (family == AF_INET6) {
400218d8:	00200693          	li	a3,2
	return 0;
400218dc:	00000513          	li	a0,0
	else if (family == AF_INET6) {
400218e0:	fed796e3          	bne	a5,a3,400218cc <net_tcp_get_supported_mss+0x58>
		struct net_if *iface = net_context_get_iface(conn->context);
400218e4:	07670503          	lb	a0,118(a4)
400218e8:	e15fe0ef          	jal	ra,400206fc <net_context_get_iface.isra.0>
			mss = NET_IPV6_MTU - NET_IPV6TCPH_LEN;
400218ec:	4c400793          	li	a5,1220
		if (iface && net_if_get_mtu(iface) >= NET_IPV6TCPH_LEN) {
400218f0:	fc050ae3          	beqz	a0,400218c4 <net_tcp_get_supported_mss+0x50>
400218f4:	00052783          	lw	a5,0(a0)
400218f8:	03b00693          	li	a3,59
400218fc:	0187d703          	lhu	a4,24(a5)
			mss = NET_IPV6_MTU - NET_IPV6TCPH_LEN;
40021900:	4c400793          	li	a5,1220
		if (iface && net_if_get_mtu(iface) >= NET_IPV6TCPH_LEN) {
40021904:	fce6f0e3          	bgeu	a3,a4,400218c4 <net_tcp_get_supported_mss+0x50>
			mss = net_if_get_mtu(iface) - NET_IPV6TCPH_LEN;
40021908:	fc470793          	addi	a5,a4,-60
		if (mss == 0) {
4002190c:	fa079ce3          	bnez	a5,400218c4 <net_tcp_get_supported_mss+0x50>
			mss = NET_IPV6_MTU - NET_IPV6TCPH_LEN;
40021910:	4c400793          	li	a5,1220
40021914:	fb1ff06f          	j	400218c4 <net_tcp_get_supported_mss+0x50>

40021918 <tcp_out_ext>:
{
40021918:	fc010113          	addi	sp,sp,-64
4002191c:	02812c23          	sw	s0,56(sp)
40021920:	02912a23          	sw	s1,52(sp)
40021924:	03312623          	sw	s3,44(sp)
40021928:	03612023          	sw	s6,32(sp)
4002192c:	02112e23          	sw	ra,60(sp)
40021930:	03212823          	sw	s2,48(sp)
40021934:	03412423          	sw	s4,40(sp)
40021938:	03512223          	sw	s5,36(sp)
	if (conn->send_options.mss_found) {
4002193c:	08e54783          	lbu	a5,142(a0)
{
40021940:	00058b13          	mv	s6,a1
40021944:	00050493          	mv	s1,a0
	if (conn->send_options.mss_found) {
40021948:	0017f793          	andi	a5,a5,1
{
4002194c:	00060413          	mv	s0,a2
40021950:	00068993          	mv	s3,a3
	size_t alloc_len = sizeof(struct tcphdr);
40021954:	01400593          	li	a1,20
	if (conn->send_options.mss_found) {
40021958:	00078463          	beqz	a5,40021960 <tcp_out_ext+0x48>
4002195c:	01800593          	li	a1,24
40021960:	0044a783          	lw	a5,4(s1)
	pkt = tcp_pkt_alloc(conn, alloc_len);
40021964:	0104a503          	lw	a0,16(s1)
40021968:	00a00713          	li	a4,10
4002196c:	0747d603          	lhu	a2,116(a5)
40021970:	00600693          	li	a3,6
40021974:	00000793          	li	a5,0
40021978:	00365613          	srli	a2,a2,0x3
4002197c:	00767613          	andi	a2,a2,7
40021980:	f08f60ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
40021984:	00050913          	mv	s2,a0
	if (!pkt) {
40021988:	36050263          	beqz	a0,40021cec <tcp_out_ext+0x3d4>
	if (data) {
4002198c:	00040863          	beqz	s0,4002199c <tcp_out_ext+0x84>
		net_pkt_append_buffer(pkt, data->buffer);
40021990:	00842583          	lw	a1,8(s0)
40021994:	aa0f60ef          	jal	ra,40017c34 <net_pkt_append_buffer>
		data->buffer = NULL;
40021998:	00042423          	sw	zero,8(s0)
	return pkt->family;
4002199c:	03492783          	lw	a5,52(s2)
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
400219a0:	00100713          	li	a4,1
400219a4:	01d7d793          	srli	a5,a5,0x1d
400219a8:	04e79a63          	bne	a5,a4,400219fc <tcp_out_ext+0xe4>
		return net_context_create_ipv4_new(conn->context, pkt,
400219ac:	0044a503          	lw	a0,4(s1)
400219b0:	1fc48693          	addi	a3,s1,508
400219b4:	1e448613          	addi	a2,s1,484
400219b8:	00090593          	mv	a1,s2
400219bc:	afdf40ef          	jal	ra,400164b8 <net_context_create_ipv4_new>
		return net_context_create_ipv6_new(conn->context, pkt,
400219c0:	00050413          	mv	s0,a0
	if (ret < 0) {
400219c4:	04055c63          	bgez	a0,40021a1c <tcp_out_ext+0x104>
		tcp_pkt_unref(pkt);
400219c8:	00090513          	mv	a0,s2
400219cc:	e51f50ef          	jal	ra,4001781c <net_pkt_unref>
}
400219d0:	03c12083          	lw	ra,60(sp)
400219d4:	00040513          	mv	a0,s0
400219d8:	03812403          	lw	s0,56(sp)
400219dc:	03412483          	lw	s1,52(sp)
400219e0:	03012903          	lw	s2,48(sp)
400219e4:	02c12983          	lw	s3,44(sp)
400219e8:	02812a03          	lw	s4,40(sp)
400219ec:	02412a83          	lw	s5,36(sp)
400219f0:	02012b03          	lw	s6,32(sp)
400219f4:	04010113          	addi	sp,sp,64
400219f8:	00008067          	ret
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
400219fc:	00200713          	li	a4,2
40021a00:	26e79e63          	bne	a5,a4,40021c7c <tcp_out_ext+0x364>
		return net_context_create_ipv6_new(conn->context, pkt,
40021a04:	0044a503          	lw	a0,4(s1)
40021a08:	1fc48693          	addi	a3,s1,508
40021a0c:	1e448613          	addi	a2,s1,484
40021a10:	00090593          	mv	a1,s2
40021a14:	bc9f40ef          	jal	ra,400165dc <net_context_create_ipv6_new>
40021a18:	fa9ff06f          	j	400219c0 <tcp_out_ext+0xa8>
	th = (struct tcphdr *)net_pkt_get_data(pkt, &tcp_access);
40021a1c:	00410a93          	addi	s5,sp,4
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct tcphdr);
40021a20:	01400793          	li	a5,20
40021a24:	00c10a13          	addi	s4,sp,12
	th = (struct tcphdr *)net_pkt_get_data(pkt, &tcp_access);
40021a28:	000a8593          	mv	a1,s5
40021a2c:	00090513          	mv	a0,s2
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct tcphdr);
40021a30:	01412223          	sw	s4,4(sp)
40021a34:	00f12423          	sw	a5,8(sp)
	th = (struct tcphdr *)net_pkt_get_data(pkt, &tcp_access);
40021a38:	eb1f60ef          	jal	ra,400188e8 <net_pkt_get_data>
40021a3c:	00050413          	mv	s0,a0
	if (!th) {
40021a40:	00051663          	bnez	a0,40021a4c <tcp_out_ext+0x134>
		return -ENOBUFS;
40021a44:	f9700413          	li	s0,-105
40021a48:	f81ff06f          	j	400219c8 <tcp_out_ext+0xb0>
	memset(th, 0, sizeof(struct tcphdr));
40021a4c:	00000593          	li	a1,0
40021a50:	01400613          	li	a2,20
40021a54:	ac8eb0ef          	jal	ra,4000cd1c <memset>
	UNALIGNED_PUT(conn->src.sin.sin_port, &th->th_sport);
40021a58:	1e24d783          	lhu	a5,482(s1)
	UNALIGNED_PUT(htonl(seq), &th->th_seq);
40021a5c:	000106b7          	lui	a3,0x10
40021a60:	f0068693          	addi	a3,a3,-256 # ff00 <__kernel_ram_size+0x43f8>
	UNALIGNED_PUT(conn->src.sin.sin_port, &th->th_sport);
40021a64:	00f40023          	sb	a5,0(s0)
40021a68:	0087d793          	srli	a5,a5,0x8
40021a6c:	00f400a3          	sb	a5,1(s0)
	UNALIGNED_PUT(conn->dst.sin.sin_port, &th->th_dport);
40021a70:	1fa4d783          	lhu	a5,506(s1)
	UNALIGNED_PUT(htonl(seq), &th->th_seq);
40021a74:	00ff05b7          	lui	a1,0xff0
	UNALIGNED_PUT(conn->dst.sin.sin_port, &th->th_dport);
40021a78:	00f40123          	sb	a5,2(s0)
40021a7c:	0087d793          	srli	a5,a5,0x8
40021a80:	00f401a3          	sb	a5,3(s0)
	th->th_off = 5;
40021a84:	00c44783          	lbu	a5,12(s0)
40021a88:	00f7f793          	andi	a5,a5,15
40021a8c:	0507e793          	ori	a5,a5,80
40021a90:	00f40623          	sb	a5,12(s0)
	if (conn->send_options.mss_found) {
40021a94:	08e4c783          	lbu	a5,142(s1)
40021a98:	00c44703          	lbu	a4,12(s0)
	UNALIGNED_PUT(flags, &th->th_flags);
40021a9c:	016406a3          	sb	s6,13(s0)
	if (conn->send_options.mss_found) {
40021aa0:	0017f793          	andi	a5,a5,1
40021aa4:	00578793          	addi	a5,a5,5
40021aa8:	00f77713          	andi	a4,a4,15
40021aac:	00479793          	slli	a5,a5,0x4
40021ab0:	00f767b3          	or	a5,a4,a5
40021ab4:	00f40623          	sb	a5,12(s0)
	UNALIGNED_PUT(htons(conn->recv_win), &th->th_win);
40021ab8:	2324d703          	lhu	a4,562(s1)
	if (ACK & flags) {
40021abc:	010b7b13          	andi	s6,s6,16
	UNALIGNED_PUT(htons(conn->recv_win), &th->th_win);
40021ac0:	00871793          	slli	a5,a4,0x8
40021ac4:	00875713          	srli	a4,a4,0x8
40021ac8:	00e7e7b3          	or	a5,a5,a4
40021acc:	01079713          	slli	a4,a5,0x10
40021ad0:	01075713          	srli	a4,a4,0x10
40021ad4:	00f40723          	sb	a5,14(s0)
40021ad8:	00875793          	srli	a5,a4,0x8
40021adc:	00f407a3          	sb	a5,15(s0)
	UNALIGNED_PUT(htonl(seq), &th->th_seq);
40021ae0:	01899713          	slli	a4,s3,0x18
40021ae4:	0189d793          	srli	a5,s3,0x18
40021ae8:	00e7e7b3          	or	a5,a5,a4
40021aec:	0089d713          	srli	a4,s3,0x8
40021af0:	00d77733          	and	a4,a4,a3
40021af4:	00899993          	slli	s3,s3,0x8
40021af8:	00e7e7b3          	or	a5,a5,a4
40021afc:	00b9f9b3          	and	s3,s3,a1
40021b00:	0137e9b3          	or	s3,a5,s3
40021b04:	00f40223          	sb	a5,4(s0)
40021b08:	0089d793          	srli	a5,s3,0x8
40021b0c:	00f402a3          	sb	a5,5(s0)
40021b10:	0109d793          	srli	a5,s3,0x10
40021b14:	0189d993          	srli	s3,s3,0x18
40021b18:	00f40323          	sb	a5,6(s0)
40021b1c:	013403a3          	sb	s3,7(s0)
	if (ACK & flags) {
40021b20:	040b0463          	beqz	s6,40021b68 <tcp_out_ext+0x250>
		UNALIGNED_PUT(htonl(conn->ack), &th->th_ack);
40021b24:	22c4a783          	lw	a5,556(s1)
40021b28:	01879613          	slli	a2,a5,0x18
40021b2c:	0187d713          	srli	a4,a5,0x18
40021b30:	00c76733          	or	a4,a4,a2
40021b34:	0087d613          	srli	a2,a5,0x8
40021b38:	00d676b3          	and	a3,a2,a3
40021b3c:	00879793          	slli	a5,a5,0x8
40021b40:	00d76733          	or	a4,a4,a3
40021b44:	00b7f7b3          	and	a5,a5,a1
40021b48:	00f767b3          	or	a5,a4,a5
40021b4c:	00e40423          	sb	a4,8(s0)
40021b50:	0087d713          	srli	a4,a5,0x8
40021b54:	00e404a3          	sb	a4,9(s0)
40021b58:	0107d713          	srli	a4,a5,0x10
40021b5c:	0187d793          	srli	a5,a5,0x18
40021b60:	00e40523          	sb	a4,10(s0)
40021b64:	00f405a3          	sb	a5,11(s0)
	return net_pkt_set_data(pkt, &tcp_access);
40021b68:	000a8593          	mv	a1,s5
40021b6c:	00090513          	mv	a0,s2
40021b70:	e49f60ef          	jal	ra,400189b8 <net_pkt_set_data>
40021b74:	00050413          	mv	s0,a0
	if (ret < 0) {
40021b78:	e40548e3          	bltz	a0,400219c8 <tcp_out_ext+0xb0>
	if (conn->send_options.mss_found) {
40021b7c:	08e4c783          	lbu	a5,142(s1)
40021b80:	0017f793          	andi	a5,a5,1
40021b84:	06078e63          	beqz	a5,40021c00 <tcp_out_ext+0x2e8>
	NET_PKT_DATA_ACCESS_DEFINE(mss_opt_access, struct tcp_mss_option);
40021b88:	00400793          	li	a5,4
	mss = net_pkt_get_data(pkt, &mss_opt_access);
40021b8c:	000a0593          	mv	a1,s4
40021b90:	00090513          	mv	a0,s2
	NET_PKT_DATA_ACCESS_DEFINE(mss_opt_access, struct tcp_mss_option);
40021b94:	01512623          	sw	s5,12(sp)
40021b98:	00f12823          	sw	a5,16(sp)
	mss = net_pkt_get_data(pkt, &mss_opt_access);
40021b9c:	d4df60ef          	jal	ra,400188e8 <net_pkt_get_data>
40021ba0:	00050413          	mv	s0,a0
	if (!mss) {
40021ba4:	ea0500e3          	beqz	a0,40021a44 <tcp_out_ext+0x12c>
	recv_mss = net_tcp_get_supported_mss(conn);
40021ba8:	00048513          	mv	a0,s1
40021bac:	cc9ff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
	recv_mss |= (NET_TCP_MSS_OPT << 24) | (NET_TCP_MSS_SIZE << 16);
40021bb0:	020407b7          	lui	a5,0x2040
40021bb4:	00f56533          	or	a0,a0,a5
	UNALIGNED_PUT(htonl(recv_mss), (uint32_t *)mss);
40021bb8:	00851793          	slli	a5,a0,0x8
40021bbc:	00ff0737          	lui	a4,0xff0
40021bc0:	00e7f7b3          	and	a5,a5,a4
40021bc4:	01851513          	slli	a0,a0,0x18
40021bc8:	00200713          	li	a4,2
40021bcc:	00a7e7b3          	or	a5,a5,a0
40021bd0:	00e40023          	sb	a4,0(s0)
40021bd4:	00400713          	li	a4,4
40021bd8:	00e400a3          	sb	a4,1(s0)
40021bdc:	0107d713          	srli	a4,a5,0x10
40021be0:	0187d793          	srli	a5,a5,0x18
40021be4:	00e40123          	sb	a4,2(s0)
40021be8:	00f401a3          	sb	a5,3(s0)
	return net_pkt_set_data(pkt, &mss_opt_access);
40021bec:	000a0593          	mv	a1,s4
40021bf0:	00090513          	mv	a0,s2
40021bf4:	dc5f60ef          	jal	ra,400189b8 <net_pkt_set_data>
40021bf8:	00050413          	mv	s0,a0
		if (ret < 0) {
40021bfc:	dc0546e3          	bltz	a0,400219c8 <tcp_out_ext+0xb0>
	net_pkt_cursor_init(pkt);
40021c00:	00090513          	mv	a0,s2
40021c04:	eedf50ef          	jal	ra,40017af0 <net_pkt_cursor_init>
40021c08:	03492783          	lw	a5,52(s2)
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
40021c0c:	00100713          	li	a4,1
40021c10:	01d7d793          	srli	a5,a5,0x1d
40021c14:	04e79863          	bne	a5,a4,40021c64 <tcp_out_ext+0x34c>
		return net_ipv4_finalize(pkt, IPPROTO_TCP);
40021c18:	00600593          	li	a1,6
40021c1c:	00090513          	mv	a0,s2
40021c20:	8a1f80ef          	jal	ra,4001a4c0 <net_ipv4_finalize>
		return net_ipv6_finalize(pkt, IPPROTO_TCP);
40021c24:	00050413          	mv	s0,a0
	if (ret < 0) {
40021c28:	da0540e3          	bltz	a0,400219c8 <tcp_out_ext+0xb0>
	if (tcp_send_cb) {
40021c2c:	400397b7          	lui	a5,0x40039
40021c30:	0c47a783          	lw	a5,196(a5) # 400390c4 <tcp_send_cb>
40021c34:	04078863          	beqz	a5,40021c84 <tcp_out_ext+0x36c>
}
40021c38:	03812403          	lw	s0,56(sp)
40021c3c:	03c12083          	lw	ra,60(sp)
40021c40:	03412483          	lw	s1,52(sp)
40021c44:	02c12983          	lw	s3,44(sp)
40021c48:	02812a03          	lw	s4,40(sp)
40021c4c:	02412a83          	lw	s5,36(sp)
40021c50:	02012b03          	lw	s6,32(sp)
		ret = tcp_send_cb(pkt);
40021c54:	00090513          	mv	a0,s2
}
40021c58:	03012903          	lw	s2,48(sp)
40021c5c:	04010113          	addi	sp,sp,64
		ret = tcp_send_cb(pkt);
40021c60:	00078067          	jr	a5
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
40021c64:	00200713          	li	a4,2
40021c68:	00e79a63          	bne	a5,a4,40021c7c <tcp_out_ext+0x364>
		return net_ipv6_finalize(pkt, IPPROTO_TCP);
40021c6c:	00600593          	li	a1,6
40021c70:	00090513          	mv	a0,s2
40021c74:	b69f90ef          	jal	ra,4001b7dc <net_ipv6_finalize>
40021c78:	fadff06f          	j	40021c24 <tcp_out_ext+0x30c>
	return -EINVAL;
40021c7c:	fea00413          	li	s0,-22
40021c80:	d49ff06f          	j	400219c8 <tcp_out_ext+0xb0>
	parent->next = child;
40021c84:	00092e23          	sw	zero,28(s2)
	return list->tail;
40021c88:	01c4a703          	lw	a4,28(s1)
	sys_slist_append(&conn->send_queue, &pkt->next);
40021c8c:	01c90793          	addi	a5,s2,28
Z_GENLIST_APPEND(slist, snode)
40021c90:	02071a63          	bnez	a4,40021cc4 <tcp_out_ext+0x3ac>
	list->tail = node;
40021c94:	00f4ae23          	sw	a5,28(s1)
	list->head = node;
40021c98:	00f4ac23          	sw	a5,24(s1)
	if (is_destination_local(pkt)) {
40021c9c:	00090513          	mv	a0,s2
40021ca0:	e9cfe0ef          	jal	ra,4002033c <is_destination_local>
40021ca4:	02050663          	beqz	a0,40021cd0 <tcp_out_ext+0x3b8>
		k_work_schedule_for_queue(&tcp_work_q,
40021ca8:	4003a537          	lui	a0,0x4003a
40021cac:	00000613          	li	a2,0
40021cb0:	00000693          	li	a3,0
40021cb4:	09048593          	addi	a1,s1,144
40021cb8:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
40021cbc:	3900e0ef          	jal	ra,4003004c <k_work_schedule_for_queue>
40021cc0:	d11ff06f          	j	400219d0 <tcp_out_ext+0xb8>
	parent->next = child;
40021cc4:	00f72023          	sw	a5,0(a4) # ff0000 <__rom_region_size+0xfb7044>
	list->tail = node;
40021cc8:	00f4ae23          	sw	a5,28(s1)
}
40021ccc:	fd1ff06f          	j	40021c9c <tcp_out_ext+0x384>
	} else if (tcp_send_process_no_lock(conn)) {
40021cd0:	00048513          	mv	a0,s1
40021cd4:	f9dfe0ef          	jal	ra,40020c70 <tcp_send_process_no_lock>
40021cd8:	ce050ce3          	beqz	a0,400219d0 <tcp_out_ext+0xb8>
		tcp_conn_close(conn, -ETIMEDOUT);
40021cdc:	f8c00593          	li	a1,-116
40021ce0:	00048513          	mv	a0,s1
40021ce4:	bdcff0ef          	jal	ra,400210c0 <tcp_conn_close.isra.0>
40021ce8:	ce9ff06f          	j	400219d0 <tcp_out_ext+0xb8>
		ret = -ENOBUFS;
40021cec:	f9700413          	li	s0,-105
	return ret;
40021cf0:	ce1ff06f          	j	400219d0 <tcp_out_ext+0xb8>

40021cf4 <tcp_out>:
	(void)tcp_out_ext(conn, flags, NULL /* no data */, conn->seq);
40021cf4:	22852683          	lw	a3,552(a0)
40021cf8:	00000613          	li	a2,0
40021cfc:	c1dff06f          	j	40021918 <tcp_out_ext>

40021d00 <tcp_send_ack>:
{
40021d00:	ff010113          	addi	sp,sp,-16
40021d04:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
40021d08:	ea850413          	addi	s0,a0,-344
{
40021d0c:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
40021d10:	fff00593          	li	a1,-1
40021d14:	e8050493          	addi	s1,a0,-384
40021d18:	fff00613          	li	a2,-1
40021d1c:	00040513          	mv	a0,s0
{
40021d20:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
40021d24:	949fe0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	tcp_out(conn, ACK);
40021d28:	00048513          	mv	a0,s1
40021d2c:	01000593          	li	a1,16
40021d30:	fc5ff0ef          	jal	ra,40021cf4 <tcp_out>
	k_mutex_unlock(&conn->lock);
40021d34:	00040513          	mv	a0,s0
}
40021d38:	00812403          	lw	s0,8(sp)
40021d3c:	00c12083          	lw	ra,12(sp)
40021d40:	00412483          	lw	s1,4(sp)
40021d44:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&conn->lock);
40021d48:	dd9fe06f          	j	40020b20 <k_mutex_unlock.isra.0>

40021d4c <tcp_send_zwp>:
{
40021d4c:	ff010113          	addi	sp,sp,-16
40021d50:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
40021d54:	ed850493          	addi	s1,a0,-296
{
40021d58:	00812423          	sw	s0,8(sp)
40021d5c:	01212023          	sw	s2,0(sp)
40021d60:	00050413          	mv	s0,a0
	struct tcp *conn = CONTAINER_OF(dwork, struct tcp, persist_timer);
40021d64:	eb050913          	addi	s2,a0,-336
	k_mutex_lock(&conn->lock, K_FOREVER);
40021d68:	fff00593          	li	a1,-1
40021d6c:	fff00613          	li	a2,-1
40021d70:	00048513          	mv	a0,s1
{
40021d74:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
40021d78:	8f5fe0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	(void)tcp_out_ext(conn, ACK, NULL, conn->seq - 1);
40021d7c:	0d842683          	lw	a3,216(s0)
40021d80:	00000613          	li	a2,0
40021d84:	01000593          	li	a1,16
40021d88:	fff68693          	addi	a3,a3,-1
40021d8c:	00090513          	mv	a0,s2
40021d90:	b89ff0ef          	jal	ra,40021918 <tcp_out_ext>
	tcp_derive_rto(conn);
40021d94:	00090513          	mv	a0,s2
40021d98:	d60fe0ef          	jal	ra,400202f8 <tcp_derive_rto>
	if (conn->send_win == 0) {
40021d9c:	0e645783          	lhu	a5,230(s0)
40021da0:	08079263          	bnez	a5,40021e24 <tcp_send_zwp+0xd8>
		if (conn->zwp_retries < UINT8_MAX) {
40021da4:	0ec44783          	lbu	a5,236(s0)
40021da8:	0ff00713          	li	a4,255
		uint64_t timeout = TCP_RTO_MS;
40021dac:	0e845503          	lhu	a0,232(s0)
		if (conn->zwp_retries < UINT8_MAX) {
40021db0:	00e78663          	beq	a5,a4,40021dbc <tcp_send_zwp+0x70>
			conn->zwp_retries++;
40021db4:	00178793          	addi	a5,a5,1
40021db8:	0ef40623          	sb	a5,236(s0)
		timeout <<= conn->zwp_retries;
40021dbc:	0ec44603          	lbu	a2,236(s0)
40021dc0:	00000593          	li	a1,0
40021dc4:	c20de0ef          	jal	ra,400001e4 <__ashldi3>
40021dc8:	00050793          	mv	a5,a0
		if (timeout == 0 || timeout > ZWP_MAX_DELAY_MS) {
40021dcc:	fff50693          	addi	a3,a0,-1
40021dd0:	00153513          	seqz	a0,a0
		timeout <<= conn->zwp_retries;
40021dd4:	00058813          	mv	a6,a1
		if (timeout == 0 || timeout > ZWP_MAX_DELAY_MS) {
40021dd8:	00b51863          	bne	a0,a1,40021de8 <tcp_send_zwp+0x9c>
40021ddc:	0001d737          	lui	a4,0x1d
40021de0:	4bf70713          	addi	a4,a4,1215 # 1d4bf <__kernel_ram_size+0x119b7>
40021de4:	00d77863          	bgeu	a4,a3,40021df4 <tcp_send_zwp+0xa8>
			timeout = ZWP_MAX_DELAY_MS;
40021de8:	0001d7b7          	lui	a5,0x1d
40021dec:	4c078793          	addi	a5,a5,1216 # 1d4c0 <__kernel_ram_size+0x119b8>
40021df0:	00000813          	li	a6,0
		t += off;
40021df4:	00978513          	addi	a0,a5,9
40021df8:	00f537b3          	sltu	a5,a0,a5
			return t / ((uint64_t)from_hz / to_hz);
40021dfc:	00a00613          	li	a2,10
40021e00:	00000693          	li	a3,0
40021e04:	010785b3          	add	a1,a5,a6
40021e08:	cb0de0ef          	jal	ra,400002b8 <__udivdi3>
40021e0c:	00050613          	mv	a2,a0
		(void)k_work_reschedule_for_queue(
40021e10:	4003a537          	lui	a0,0x4003a
40021e14:	00058693          	mv	a3,a1
40021e18:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
40021e1c:	00040593          	mv	a1,s0
40021e20:	2a40e0ef          	jal	ra,400300c4 <k_work_reschedule_for_queue>
}
40021e24:	00812403          	lw	s0,8(sp)
40021e28:	00c12083          	lw	ra,12(sp)
40021e2c:	00012903          	lw	s2,0(sp)
	k_mutex_unlock(&conn->lock);
40021e30:	00048513          	mv	a0,s1
}
40021e34:	00412483          	lw	s1,4(sp)
40021e38:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&conn->lock);
40021e3c:	ce5fe06f          	j	40020b20 <k_mutex_unlock.isra.0>

40021e40 <net_tcp_put>:
{
40021e40:	ff010113          	addi	sp,sp,-16
40021e44:	00112623          	sw	ra,12(sp)
40021e48:	00812423          	sw	s0,8(sp)
40021e4c:	00912223          	sw	s1,4(sp)
40021e50:	01212023          	sw	s2,0(sp)
	struct tcp *conn = context->tcp;
40021e54:	05452403          	lw	s0,84(a0)
		return -ENOENT;
40021e58:	ffe00513          	li	a0,-2
	if (!conn) {
40021e5c:	06040e63          	beqz	s0,40021ed8 <net_tcp_put+0x98>
	k_mutex_lock(&conn->lock, K_FOREVER);
40021e60:	02840493          	addi	s1,s0,40
40021e64:	fff00593          	li	a1,-1
40021e68:	fff00613          	li	a2,-1
40021e6c:	00048513          	mv	a0,s1
40021e70:	ffcfe0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	if (conn && conn->state == TCP_ESTABLISHED) {
40021e74:	22042703          	lw	a4,544(s0)
40021e78:	00400793          	li	a5,4
40021e7c:	0ef71663          	bne	a4,a5,40021f68 <net_tcp_put+0x128>
		if (conn->send_data_total > 0) {
40021e80:	21042783          	lw	a5,528(s0)
40021e84:	4003a937          	lui	s2,0x4003a
40021e88:	06078463          	beqz	a5,40021ef0 <net_tcp_put+0xb0>
			conn->in_close = true;
40021e8c:	23d44783          	lbu	a5,573(s0)
						    K_MSEC(TCP_RTO_MS));
40021e90:	23845503          	lhu	a0,568(s0)
40021e94:	00a00613          	li	a2,10
			conn->in_close = true;
40021e98:	0047e793          	ori	a5,a5,4
40021e9c:	00000693          	li	a3,0
40021ea0:	22f40ea3          	sb	a5,573(s0)
40021ea4:	00950513          	addi	a0,a0,9
40021ea8:	00000593          	li	a1,0
40021eac:	c0cde0ef          	jal	ra,400002b8 <__udivdi3>
40021eb0:	00050613          	mv	a2,a0
40021eb4:	00058693          	mv	a3,a1
			k_work_reschedule_for_queue(&tcp_work_q,
40021eb8:	c7090513          	addi	a0,s2,-912 # 40039c70 <tcp_work_q>
40021ebc:	0f040593          	addi	a1,s0,240
40021ec0:	2040e0ef          	jal	ra,400300c4 <k_work_reschedule_for_queue>
	k_mutex_unlock(&conn->lock);
40021ec4:	00048513          	mv	a0,s1
40021ec8:	c59fe0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
	tcp_conn_unref(conn);
40021ecc:	00040513          	mv	a0,s0
40021ed0:	fa9fe0ef          	jal	ra,40020e78 <tcp_conn_unref.isra.0>
	return 0;
40021ed4:	00000513          	li	a0,0
}
40021ed8:	00c12083          	lw	ra,12(sp)
40021edc:	00812403          	lw	s0,8(sp)
40021ee0:	00412483          	lw	s1,4(sp)
40021ee4:	00012903          	lw	s2,0(sp)
40021ee8:	01010113          	addi	sp,sp,16
40021eec:	00008067          	ret
						    FIN_TIMEOUT);
40021ef0:	400397b7          	lui	a5,0x40039
40021ef4:	0d07a783          	lw	a5,208(a5) # 400390d0 <tcp_fin_timeout_ms>
40021ef8:	0007d463          	bgez	a5,40021f00 <net_tcp_put+0xc0>
40021efc:	00000793          	li	a5,0
		t += off;
40021f00:	00978513          	addi	a0,a5,9
40021f04:	41f7d593          	srai	a1,a5,0x1f
40021f08:	00f537b3          	sltu	a5,a0,a5
			return t / ((uint64_t)from_hz / to_hz);
40021f0c:	00b785b3          	add	a1,a5,a1
40021f10:	00a00613          	li	a2,10
40021f14:	00000693          	li	a3,0
40021f18:	ba0de0ef          	jal	ra,400002b8 <__udivdi3>
40021f1c:	00050613          	mv	a2,a0
40021f20:	00058693          	mv	a3,a1
			k_work_reschedule_for_queue(&tcp_work_q,
40021f24:	c7090513          	addi	a0,s2,-912
40021f28:	1b040593          	addi	a1,s0,432
40021f2c:	1980e0ef          	jal	ra,400300c4 <k_work_reschedule_for_queue>
			ret = tcp_out_ext(conn, FIN | ACK, NULL,
40021f30:	22842683          	lw	a3,552(s0)
40021f34:	21842783          	lw	a5,536(s0)
40021f38:	00000613          	li	a2,0
40021f3c:	01100593          	li	a1,17
40021f40:	00f686b3          	add	a3,a3,a5
40021f44:	00040513          	mv	a0,s0
40021f48:	9d1ff0ef          	jal	ra,40021918 <tcp_out_ext>
			if (ret == 0) {
40021f4c:	00051863          	bnez	a0,40021f5c <net_tcp_put+0x11c>
				conn_seq(conn, + 1);
40021f50:	22842783          	lw	a5,552(s0)
40021f54:	00178793          	addi	a5,a5,1
40021f58:	22f42423          	sw	a5,552(s0)
			conn_state(conn, TCP_FIN_WAIT_1);
40021f5c:	00500793          	li	a5,5
40021f60:	22f42023          	sw	a5,544(s0)
40021f64:	f61ff06f          	j	40021ec4 <net_tcp_put+0x84>
	} else if (conn && conn->in_connect) {
40021f68:	23d44783          	lbu	a5,573(s0)
40021f6c:	0027f713          	andi	a4,a5,2
40021f70:	f4070ae3          	beqz	a4,40021ec4 <net_tcp_put+0x84>
		conn->in_connect = false;
40021f74:	ffd7f793          	andi	a5,a5,-3
40021f78:	22f40ea3          	sb	a5,573(s0)
40021f7c:	f49ff06f          	j	40021ec4 <net_tcp_put+0x84>

40021f80 <tcp_send_data>:
{
40021f80:	fd010113          	addi	sp,sp,-48
40021f84:	02812423          	sw	s0,40(sp)
40021f88:	02912223          	sw	s1,36(sp)
40021f8c:	01412c23          	sw	s4,24(sp)
40021f90:	02112623          	sw	ra,44(sp)
40021f94:	03212023          	sw	s2,32(sp)
40021f98:	01312e23          	sw	s3,28(sp)
40021f9c:	03010413          	addi	s0,sp,48
	len = MIN3(conn->send_data_total - conn->unacked_len,
40021fa0:	21852783          	lw	a5,536(a0)
40021fa4:	21052983          	lw	s3,528(a0)
40021fa8:	23655903          	lhu	s2,566(a0)
{
40021fac:	00050493          	mv	s1,a0
	len = MIN3(conn->send_data_total - conn->unacked_len,
40021fb0:	40f989b3          	sub	s3,s3,a5
40021fb4:	40f90933          	sub	s2,s2,a5
40021fb8:	08854783          	lbu	a5,136(a0)
40021fbc:	21800a13          	li	s4,536
40021fc0:	0017f793          	andi	a5,a5,1
40021fc4:	00078463          	beqz	a5,40021fcc <tcp_send_data+0x4c>
40021fc8:	08455a03          	lhu	s4,132(a0)
40021fcc:	00048513          	mv	a0,s1
40021fd0:	8a5ff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
40021fd4:	04aa5063          	bge	s4,a0,40022014 <tcp_send_data+0x94>
40021fd8:	0884c783          	lbu	a5,136(s1)
40021fdc:	0017f793          	andi	a5,a5,1
40021fe0:	24078e63          	beqz	a5,4002223c <tcp_send_data+0x2bc>
40021fe4:	0844d783          	lhu	a5,132(s1)
40021fe8:	24f94e63          	blt	s2,a5,40022244 <tcp_send_data+0x2c4>
40021fec:	0844d903          	lhu	s2,132(s1)
40021ff0:	00048513          	mv	a0,s1
40021ff4:	881ff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
40021ff8:	02a95e63          	bge	s2,a0,40022034 <tcp_send_data+0xb4>
40021ffc:	0884c783          	lbu	a5,136(s1)
40022000:	21800513          	li	a0,536
40022004:	0017f793          	andi	a5,a5,1
40022008:	24078463          	beqz	a5,40022250 <tcp_send_data+0x2d0>
4002200c:	0844d503          	lhu	a0,132(s1)
40022010:	2400006f          	j	40022250 <tcp_send_data+0x2d0>
40022014:	00048513          	mv	a0,s1
40022018:	85dff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
4002201c:	22a94463          	blt	s2,a0,40022244 <tcp_send_data+0x2c4>
40022020:	0884c783          	lbu	a5,136(s1)
40022024:	0017f793          	andi	a5,a5,1
40022028:	fc0792e3          	bnez	a5,40021fec <tcp_send_data+0x6c>
4002202c:	21800913          	li	s2,536
40022030:	fc1ff06f          	j	40021ff0 <tcp_send_data+0x70>
40022034:	00048513          	mv	a0,s1
40022038:	83dff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
4002203c:	2140006f          	j	40022250 <tcp_send_data+0x2d0>
40022040:	2364d903          	lhu	s2,566(s1)
40022044:	21800993          	li	s3,536
40022048:	40f90933          	sub	s2,s2,a5
4002204c:	0884c783          	lbu	a5,136(s1)
40022050:	0017f793          	andi	a5,a5,1
40022054:	00078463          	beqz	a5,4002205c <tcp_send_data+0xdc>
40022058:	0844d983          	lhu	s3,132(s1)
4002205c:	00048513          	mv	a0,s1
40022060:	815ff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
40022064:	06a9d463          	bge	s3,a0,400220cc <tcp_send_data+0x14c>
40022068:	0884c783          	lbu	a5,136(s1)
4002206c:	0017f793          	andi	a5,a5,1
40022070:	1a078c63          	beqz	a5,40022228 <tcp_send_data+0x2a8>
40022074:	0844d783          	lhu	a5,132(s1)
40022078:	1af94c63          	blt	s2,a5,40022230 <tcp_send_data+0x2b0>
4002207c:	0844d903          	lhu	s2,132(s1)
40022080:	00048513          	mv	a0,s1
40022084:	ff0ff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
40022088:	06a95263          	bge	s2,a0,400220ec <tcp_send_data+0x16c>
4002208c:	0884c783          	lbu	a5,136(s1)
40022090:	0017f793          	andi	a5,a5,1
40022094:	06078463          	beqz	a5,400220fc <tcp_send_data+0x17c>
40022098:	0844d903          	lhu	s2,132(s1)
	if (len == 0) {
4002209c:	1c091663          	bnez	s2,40022268 <tcp_send_data+0x2e8>
		ret = -ENODATA;
400220a0:	fc300a13          	li	s4,-61
}
400220a4:	fd040113          	addi	sp,s0,-48
400220a8:	02c12083          	lw	ra,44(sp)
400220ac:	000a0513          	mv	a0,s4
400220b0:	02812403          	lw	s0,40(sp)
400220b4:	02412483          	lw	s1,36(sp)
400220b8:	02012903          	lw	s2,32(sp)
400220bc:	01c12983          	lw	s3,28(sp)
400220c0:	01812a03          	lw	s4,24(sp)
400220c4:	03010113          	addi	sp,sp,48
400220c8:	00008067          	ret
	len = MIN3(conn->send_data_total - conn->unacked_len,
400220cc:	00048513          	mv	a0,s1
400220d0:	fa4ff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
400220d4:	14a94e63          	blt	s2,a0,40022230 <tcp_send_data+0x2b0>
400220d8:	0884c783          	lbu	a5,136(s1)
400220dc:	0017f793          	andi	a5,a5,1
400220e0:	f8079ee3          	bnez	a5,4002207c <tcp_send_data+0xfc>
400220e4:	21800913          	li	s2,536
400220e8:	f99ff06f          	j	40022080 <tcp_send_data+0x100>
400220ec:	00048513          	mv	a0,s1
400220f0:	f84ff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
400220f4:	00050913          	mv	s2,a0
	if (len == 0) {
400220f8:	fa5ff06f          	j	4002209c <tcp_send_data+0x11c>
	len = MIN3(conn->send_data_total - conn->unacked_len,
400220fc:	21800913          	li	s2,536
40022100:	1680006f          	j	40022268 <tcp_send_data+0x2e8>
	pkt = tcp_pkt_alloc(conn, len);
40022104:	00000593          	li	a1,0
40022108:	00a00513          	li	a0,10
4002210c:	ab1f50ef          	jal	ra,40017bbc <net_pkt_alloc>
40022110:	1800006f          	j	40022290 <tcp_send_data+0x310>
	ret = tcp_pkt_peek(pkt, conn->send_data, conn->unacked_len, len);
40022114:	2184a583          	lw	a1,536(s1)
40022118:	0084aa03          	lw	s4,8(s1)
4002211c:	fcb42e23          	sw	a1,-36(s0)
	net_pkt_cursor_init(to);
40022120:	9d1f50ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	net_pkt_cursor_init(from);
40022124:	000a0513          	mv	a0,s4
40022128:	9c9f50ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	if (pos) {
4002212c:	fdc42583          	lw	a1,-36(s0)
40022130:	00058c63          	beqz	a1,40022148 <tcp_send_data+0x1c8>
	pkt->overwrite = overwrite;
40022134:	037a4783          	lbu	a5,55(s4)
		net_pkt_skip(from, pos);
40022138:	000a0513          	mv	a0,s4
4002213c:	0017e793          	ori	a5,a5,1
40022140:	02fa0ba3          	sb	a5,55(s4)
40022144:	f8df50ef          	jal	ra,400180d0 <net_pkt_skip>
	return net_pkt_copy(to, from, len);
40022148:	00090613          	mv	a2,s2
4002214c:	000a0593          	mv	a1,s4
40022150:	00098513          	mv	a0,s3
40022154:	a48f60ef          	jal	ra,4001839c <net_pkt_copy>
	if (ret < 0) {
40022158:	00055863          	bgez	a0,40022168 <tcp_send_data+0x1e8>
		tcp_pkt_unref(pkt);
4002215c:	00098513          	mv	a0,s3
40022160:	ebcf50ef          	jal	ra,4001781c <net_pkt_unref>
		goto out;
40022164:	1840006f          	j	400222e8 <tcp_send_data+0x368>
	ret = tcp_out_ext(conn, PSH | ACK, pkt, conn->seq + conn->unacked_len);
40022168:	2284a683          	lw	a3,552(s1)
4002216c:	2184a783          	lw	a5,536(s1)
40022170:	00098613          	mv	a2,s3
40022174:	01800593          	li	a1,24
40022178:	00f686b3          	add	a3,a3,a5
4002217c:	00048513          	mv	a0,s1
40022180:	f98ff0ef          	jal	ra,40021918 <tcp_out_ext>
40022184:	00050a13          	mv	s4,a0
	if (ret == 0) {
40022188:	04051e63          	bnez	a0,400221e4 <tcp_send_data+0x264>
		conn->unacked_len += len;
4002218c:	2184a783          	lw	a5,536(s1)
		if (conn->data_mode == TCP_DATA_MODE_RESEND) {
40022190:	2244a603          	lw	a2,548(s1)
40022194:	00100693          	li	a3,1
		conn->unacked_len += len;
40022198:	012787b3          	add	a5,a5,s2
4002219c:	20f4ac23          	sw	a5,536(s1)
		if (conn->data_mode == TCP_DATA_MODE_RESEND) {
400221a0:	4003b7b7          	lui	a5,0x4003b
			net_stats_update_tcp_resent(conn->iface, len);
400221a4:	0104a703          	lw	a4,16(s1)
400221a8:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
		if (conn->data_mode == TCP_DATA_MODE_RESEND) {
400221ac:	04d61263          	bne	a2,a3,400221f0 <tcp_send_data+0x270>
	UPDATE_STAT(iface, stats.tcp.resent += bytes);
400221b0:	0607a683          	lw	a3,96(a5)
400221b4:	012686b3          	add	a3,a3,s2
400221b8:	06d7a023          	sw	a3,96(a5)
400221bc:	06472683          	lw	a3,100(a4)
400221c0:	012686b3          	add	a3,a3,s2
400221c4:	06d72223          	sw	a3,100(a4)
	UPDATE_STAT(iface, stats.tcp.rexmit++);
400221c8:	0847a703          	lw	a4,132(a5)
			net_stats_update_tcp_seg_rexmit(conn->iface);
400221cc:	0104a683          	lw	a3,16(s1)
400221d0:	00170713          	addi	a4,a4,1
400221d4:	08e7a223          	sw	a4,132(a5)
400221d8:	0886a783          	lw	a5,136(a3)
400221dc:	00178793          	addi	a5,a5,1
400221e0:	08f6a423          	sw	a5,136(a3)
	tcp_pkt_unref(pkt);
400221e4:	00098513          	mv	a0,s3
400221e8:	e34f50ef          	jal	ra,4001781c <net_pkt_unref>
	return ret;
400221ec:	eb9ff06f          	j	400220a4 <tcp_send_data+0x124>
	UPDATE_STAT(iface, stats.tcp.bytes.sent += bytes);
400221f0:	0587a683          	lw	a3,88(a5)
400221f4:	012686b3          	add	a3,a3,s2
400221f8:	04d7ac23          	sw	a3,88(a5)
400221fc:	05c72683          	lw	a3,92(a4)
40022200:	012686b3          	add	a3,a3,s2
40022204:	04d72e23          	sw	a3,92(a4)
	UPDATE_STAT(iface, stats.tcp.sent++);
40022208:	06c7a703          	lw	a4,108(a5)
			net_stats_update_tcp_seg_sent(conn->iface);
4002220c:	0104a683          	lw	a3,16(s1)
40022210:	00170713          	addi	a4,a4,1
40022214:	06e7a623          	sw	a4,108(a5)
40022218:	0706a783          	lw	a5,112(a3)
4002221c:	00178793          	addi	a5,a5,1
40022220:	06f6a823          	sw	a5,112(a3)
}
40022224:	fc1ff06f          	j	400221e4 <tcp_send_data+0x264>
	len = MIN3(conn->send_data_total - conn->unacked_len,
40022228:	21700793          	li	a5,535
4002222c:	eb27cce3          	blt	a5,s2,400220e4 <tcp_send_data+0x164>
40022230:	2364d903          	lhu	s2,566(s1)
40022234:	2184a783          	lw	a5,536(s1)
40022238:	0240006f          	j	4002225c <tcp_send_data+0x2dc>
4002223c:	21700793          	li	a5,535
40022240:	df27c6e3          	blt	a5,s2,4002202c <tcp_send_data+0xac>
40022244:	2364d503          	lhu	a0,566(s1)
40022248:	2184a783          	lw	a5,536(s1)
4002224c:	40f50533          	sub	a0,a0,a5
40022250:	2184a783          	lw	a5,536(s1)
40022254:	dea9f6e3          	bgeu	s3,a0,40022040 <tcp_send_data+0xc0>
40022258:	2104a903          	lw	s2,528(s1)
4002225c:	40f90933          	sub	s2,s2,a5
	if (len == 0) {
40022260:	e40900e3          	beqz	s2,400220a0 <tcp_send_data+0x120>
	pkt = tcp_pkt_alloc(conn, len);
40022264:	eb2050e3          	blez	s2,40022104 <tcp_send_data+0x184>
40022268:	0044a783          	lw	a5,4(s1)
4002226c:	0104a503          	lw	a0,16(s1)
40022270:	00a00713          	li	a4,10
40022274:	0747d603          	lhu	a2,116(a5)
40022278:	00600693          	li	a3,6
4002227c:	00000793          	li	a5,0
40022280:	00365613          	srli	a2,a2,0x3
40022284:	00767613          	andi	a2,a2,7
40022288:	00090593          	mv	a1,s2
4002228c:	dfdf50ef          	jal	ra,40018088 <net_pkt_alloc_with_buffer>
40022290:	00050993          	mv	s3,a0
	if (!pkt) {
40022294:	e80510e3          	bnez	a0,40022114 <tcp_send_data+0x194>
		NET_ERR("conn: %p packet allocation failed, len=%d", conn, len);
40022298:	40044537          	lui	a0,0x40044
4002229c:	7a052783          	lw	a5,1952(a0) # 400447a0 <log_dynamic_net_tcp>
400222a0:	0077f793          	andi	a5,a5,7
400222a4:	04078263          	beqz	a5,400222e8 <tcp_send_data+0x368>
400222a8:	00010993          	mv	s3,sp
400222ac:	fe010113          	addi	sp,sp,-32
400222b0:	00010613          	mv	a2,sp
400222b4:	400357b7          	lui	a5,0x40035
400222b8:	38878793          	addi	a5,a5,904 # 40035388 <CSWTCH.16862+0x190>
400222bc:	00f62a23          	sw	a5,20(a2)
400222c0:	000025b7          	lui	a1,0x2
400222c4:	00400793          	li	a5,4
400222c8:	00962c23          	sw	s1,24(a2)
400222cc:	01262e23          	sw	s2,28(a2)
400222d0:	00f62823          	sw	a5,16(a2)
400222d4:	04058593          	addi	a1,a1,64 # 2040 <CONFIG_SRAM_SIZE+0x40>
400222d8:	01060613          	addi	a2,a2,16
400222dc:	7a050513          	addi	a0,a0,1952
400222e0:	a48fe0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
400222e4:	00098113          	mv	sp,s3
		ret = -ENOBUFS;
400222e8:	f9700a13          	li	s4,-105
400222ec:	db9ff06f          	j	400220a4 <tcp_send_data+0x124>

400222f0 <tcp_resend_data>:
{
400222f0:	fd010113          	addi	sp,sp,-48
400222f4:	02912223          	sw	s1,36(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
400222f8:	f3850493          	addi	s1,a0,-200
{
400222fc:	02812423          	sw	s0,40(sp)
40022300:	03212023          	sw	s2,32(sp)
40022304:	00050413          	mv	s0,a0
	struct tcp *conn = CONTAINER_OF(dwork, struct tcp, send_data_timer);
40022308:	f1050913          	addi	s2,a0,-240
	k_mutex_lock(&conn->lock, K_FOREVER);
4002230c:	fff00593          	li	a1,-1
40022310:	fff00613          	li	a2,-1
40022314:	00048513          	mv	a0,s1
{
40022318:	02112623          	sw	ra,44(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4002231c:	b50fe0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	if (conn->send_data_retries >= tcp_retries) {
40022320:	14a44703          	lbu	a4,330(s0)
40022324:	00800793          	li	a5,8
40022328:	02e7f663          	bgeu	a5,a4,40022354 <tcp_resend_data+0x64>
	k_mutex_unlock(&conn->lock);
4002232c:	00048513          	mv	a0,s1
40022330:	ff0fe0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
}
40022334:	02812403          	lw	s0,40(sp)
40022338:	02c12083          	lw	ra,44(sp)
4002233c:	02412483          	lw	s1,36(sp)
		tcp_conn_close(conn, -ETIMEDOUT);
40022340:	00090513          	mv	a0,s2
}
40022344:	02012903          	lw	s2,32(sp)
		tcp_conn_close(conn, -ETIMEDOUT);
40022348:	f8c00593          	li	a1,-116
}
4002234c:	03010113          	addi	sp,sp,48
		tcp_conn_close(conn, -ETIMEDOUT);
40022350:	d71fe06f          	j	400210c0 <tcp_conn_close.isra.0>
	conn->data_mode = TCP_DATA_MODE_RESEND;
40022354:	00100793          	li	a5,1
40022358:	12f42a23          	sw	a5,308(s0)
	conn->unacked_len = 0;
4002235c:	12042423          	sw	zero,296(s0)
	ret = tcp_send_data(conn);
40022360:	00090513          	mv	a0,s2
40022364:	c1dff0ef          	jal	ra,40021f80 <tcp_send_data>
	conn->send_data_retries++;
40022368:	14a44783          	lbu	a5,330(s0)
4002236c:	00178793          	addi	a5,a5,1
40022370:	14f40523          	sb	a5,330(s0)
	if (ret == 0) {
40022374:	0a051663          	bnez	a0,40022420 <tcp_resend_data+0x130>
		if (conn->in_close && conn->send_data_total == 0) {
40022378:	14d44783          	lbu	a5,333(s0)
4002237c:	0047f793          	andi	a5,a5,4
40022380:	0e078863          	beqz	a5,40022470 <tcp_resend_data+0x180>
40022384:	12042783          	lw	a5,288(s0)
40022388:	0e079463          	bnez	a5,40022470 <tcp_resend_data+0x180>
						    FIN_TIMEOUT);
4002238c:	400397b7          	lui	a5,0x40039
40022390:	0d07a783          	lw	a5,208(a5) # 400390d0 <tcp_fin_timeout_ms>
40022394:	0007d463          	bgez	a5,4002239c <tcp_resend_data+0xac>
40022398:	00000793          	li	a5,0
		t += off;
4002239c:	00978513          	addi	a0,a5,9
400223a0:	41f7d593          	srai	a1,a5,0x1f
400223a4:	00f537b3          	sltu	a5,a0,a5
			return t / ((uint64_t)from_hz / to_hz);
400223a8:	00b785b3          	add	a1,a5,a1
400223ac:	00a00613          	li	a2,10
400223b0:	00000693          	li	a3,0
400223b4:	f05dd0ef          	jal	ra,400002b8 <__udivdi3>
400223b8:	00050613          	mv	a2,a0
			k_work_reschedule_for_queue(&tcp_work_q,
400223bc:	4003a537          	lui	a0,0x4003a
400223c0:	00058693          	mv	a3,a1
400223c4:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
400223c8:	0c040593          	addi	a1,s0,192
400223cc:	4f90d0ef          	jal	ra,400300c4 <k_work_reschedule_for_queue>
			conn_state(conn, TCP_FIN_WAIT_1);
400223d0:	00500793          	li	a5,5
			ret = tcp_out_ext(conn, FIN | ACK, NULL,
400223d4:	13842683          	lw	a3,312(s0)
			conn_state(conn, TCP_FIN_WAIT_1);
400223d8:	12f42823          	sw	a5,304(s0)
			ret = tcp_out_ext(conn, FIN | ACK, NULL,
400223dc:	12842783          	lw	a5,296(s0)
400223e0:	00000613          	li	a2,0
400223e4:	01100593          	li	a1,17
400223e8:	00f686b3          	add	a3,a3,a5
400223ec:	00090513          	mv	a0,s2
400223f0:	d28ff0ef          	jal	ra,40021918 <tcp_out_ext>
			if (ret == 0) {
400223f4:	00051863          	bnez	a0,40022404 <tcp_resend_data+0x114>
				conn_seq(conn, + 1);
400223f8:	13842783          	lw	a5,312(s0)
400223fc:	00178793          	addi	a5,a5,1
40022400:	12f42c23          	sw	a5,312(s0)
}
40022404:	02812403          	lw	s0,40(sp)
40022408:	02c12083          	lw	ra,44(sp)
4002240c:	02012903          	lw	s2,32(sp)
	k_mutex_unlock(&conn->lock);
40022410:	00048513          	mv	a0,s1
}
40022414:	02412483          	lw	s1,36(sp)
40022418:	03010113          	addi	sp,sp,48
	k_mutex_unlock(&conn->lock);
4002241c:	f04fe06f          	j	40020b20 <k_mutex_unlock.isra.0>
	} else if (ret == -ENODATA) {
40022420:	fc300793          	li	a5,-61
40022424:	00f51663          	bne	a0,a5,40022430 <tcp_resend_data+0x140>
		conn->data_mode = TCP_DATA_MODE_SEND;
40022428:	12042a23          	sw	zero,308(s0)
	k_mutex_unlock(&conn->lock);
4002242c:	fd9ff06f          	j	40022404 <tcp_resend_data+0x114>
	} else if (ret == -ENOBUFS) {
40022430:	f9700793          	li	a5,-105
40022434:	02f51e63          	bne	a0,a5,40022470 <tcp_resend_data+0x180>
		NET_ERR("TCP failed to allocate buffer in retransmission");
40022438:	40044537          	lui	a0,0x40044
4002243c:	7a052783          	lw	a5,1952(a0) # 400447a0 <log_dynamic_net_tcp>
40022440:	0077f793          	andi	a5,a5,7
40022444:	02078663          	beqz	a5,40022470 <tcp_resend_data+0x180>
40022448:	400357b7          	lui	a5,0x40035
4002244c:	3b478793          	addi	a5,a5,948 # 400353b4 <CSWTCH.16862+0x1bc>
40022450:	000015b7          	lui	a1,0x1
40022454:	00f12e23          	sw	a5,28(sp)
40022458:	01810613          	addi	a2,sp,24
4002245c:	00200793          	li	a5,2
40022460:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
40022464:	7a050513          	addi	a0,a0,1952
40022468:	00f12c23          	sw	a5,24(sp)
4002246c:	8bcfe0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
	if (conn->send_data_retries < tcp_retries) {
40022470:	14a44683          	lbu	a3,330(s0)
40022474:	00800713          	li	a4,8
	exp_tcp_rto = TCP_RTO_MS;
40022478:	14845783          	lhu	a5,328(s0)
	if (conn->send_data_retries < tcp_retries) {
4002247c:	04d75863          	bge	a4,a3,400224cc <tcp_resend_data+0x1dc>
		t += off;
40022480:	00978513          	addi	a0,a5,9
				    K_MSEC(exp_tcp_rto));
40022484:	41f7d593          	srai	a1,a5,0x1f
40022488:	00f537b3          	sltu	a5,a0,a5
			return t / ((uint64_t)from_hz / to_hz);
4002248c:	00a00613          	li	a2,10
40022490:	00000693          	li	a3,0
40022494:	00b785b3          	add	a1,a5,a1
40022498:	e21dd0ef          	jal	ra,400002b8 <__udivdi3>
4002249c:	00050613          	mv	a2,a0
	k_work_reschedule_for_queue(&tcp_work_q, &conn->send_data_timer,
400224a0:	4003a537          	lui	a0,0x4003a
400224a4:	00058693          	mv	a3,a1
400224a8:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
400224ac:	00040593          	mv	a1,s0
400224b0:	4150d0ef          	jal	ra,400300c4 <k_work_reschedule_for_queue>
400224b4:	f51ff06f          	j	40022404 <tcp_resend_data+0x114>
			exp_tcp_rto += exp_tcp_rto >> 1;
400224b8:	4017d613          	srai	a2,a5,0x1
400224bc:	00c787b3          	add	a5,a5,a2
		for (int i = 0; i < conn->send_data_retries; i++) {
400224c0:	00170713          	addi	a4,a4,1
400224c4:	fed74ae3          	blt	a4,a3,400224b8 <tcp_resend_data+0x1c8>
400224c8:	fb9ff06f          	j	40022480 <tcp_resend_data+0x190>
400224cc:	00000713          	li	a4,0
400224d0:	ff5ff06f          	j	400224c4 <tcp_resend_data+0x1d4>

400224d4 <tcp_short_window>:
{
400224d4:	ff010113          	addi	sp,sp,-16
400224d8:	00812423          	sw	s0,8(sp)
400224dc:	00912223          	sw	s1,4(sp)
400224e0:	00112623          	sw	ra,12(sp)
	int32_t threshold = MIN(conn_mss(conn), conn->recv_win_max / 2);
400224e4:	08854783          	lbu	a5,136(a0)
{
400224e8:	00050413          	mv	s0,a0
400224ec:	21800493          	li	s1,536
	int32_t threshold = MIN(conn_mss(conn), conn->recv_win_max / 2);
400224f0:	0017f793          	andi	a5,a5,1
400224f4:	00078463          	beqz	a5,400224fc <tcp_short_window+0x28>
400224f8:	08455483          	lhu	s1,132(a0)
400224fc:	00040513          	mv	a0,s0
40022500:	b74ff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
40022504:	06a4dc63          	bge	s1,a0,4002257c <tcp_short_window+0xa8>
40022508:	08844783          	lbu	a5,136(s0)
4002250c:	21800513          	li	a0,536
40022510:	0017f793          	andi	a5,a5,1
40022514:	00078463          	beqz	a5,4002251c <tcp_short_window+0x48>
40022518:	08445503          	lhu	a0,132(s0)
4002251c:	23045783          	lhu	a5,560(s0)
40022520:	0017d793          	srli	a5,a5,0x1
40022524:	02f55c63          	bge	a0,a5,4002255c <tcp_short_window+0x88>
40022528:	08844783          	lbu	a5,136(s0)
4002252c:	21800493          	li	s1,536
40022530:	0017f793          	andi	a5,a5,1
40022534:	00078463          	beqz	a5,4002253c <tcp_short_window+0x68>
40022538:	08445483          	lhu	s1,132(s0)
4002253c:	00040513          	mv	a0,s0
40022540:	b34ff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
40022544:	04a4d263          	bge	s1,a0,40022588 <tcp_short_window+0xb4>
40022548:	08844703          	lbu	a4,136(s0)
4002254c:	21800793          	li	a5,536
40022550:	00177713          	andi	a4,a4,1
40022554:	00070463          	beqz	a4,4002255c <tcp_short_window+0x88>
40022558:	08445783          	lhu	a5,132(s0)
	if (conn->recv_win > threshold) {
4002255c:	23245503          	lhu	a0,562(s0)
}
40022560:	00c12083          	lw	ra,12(sp)
40022564:	00812403          	lw	s0,8(sp)
	if (conn->recv_win > threshold) {
40022568:	00a7a533          	slt	a0,a5,a0
}
4002256c:	00412483          	lw	s1,4(sp)
40022570:	00154513          	xori	a0,a0,1
40022574:	01010113          	addi	sp,sp,16
40022578:	00008067          	ret
	int32_t threshold = MIN(conn_mss(conn), conn->recv_win_max / 2);
4002257c:	00040513          	mv	a0,s0
40022580:	af4ff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
40022584:	f99ff06f          	j	4002251c <tcp_short_window+0x48>
40022588:	00040513          	mv	a0,s0
4002258c:	ae8ff0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
40022590:	00050793          	mv	a5,a0
40022594:	fc9ff06f          	j	4002255c <tcp_short_window+0x88>

40022598 <tcp_update_recv_wnd>:
{
40022598:	ff010113          	addi	sp,sp,-16
4002259c:	00812423          	sw	s0,8(sp)
400225a0:	00912223          	sw	s1,4(sp)
400225a4:	00112623          	sw	ra,12(sp)
400225a8:	01212023          	sw	s2,0(sp)
	new_win = conn->recv_win + delta;
400225ac:	23255783          	lhu	a5,562(a0)
{
400225b0:	00050413          	mv	s0,a0
		new_win = 0;
400225b4:	00000493          	li	s1,0
	new_win = conn->recv_win + delta;
400225b8:	00b785b3          	add	a1,a5,a1
	if (new_win < 0) {
400225bc:	0005c863          	bltz	a1,400225cc <tcp_update_recv_wnd+0x34>
	} else if (new_win > conn->recv_win_max) {
400225c0:	23055483          	lhu	s1,560(a0)
400225c4:	0095d463          	bge	a1,s1,400225cc <tcp_update_recv_wnd+0x34>
400225c8:	00058493          	mv	s1,a1
	short_win_before = tcp_short_window(conn);
400225cc:	00040513          	mv	a0,s0
400225d0:	f05ff0ef          	jal	ra,400224d4 <tcp_short_window>
400225d4:	00050913          	mv	s2,a0
	conn->recv_win = new_win;
400225d8:	22941923          	sh	s1,562(s0)
	short_win_after = tcp_short_window(conn);
400225dc:	00040513          	mv	a0,s0
400225e0:	ef5ff0ef          	jal	ra,400224d4 <tcp_short_window>
	if (short_win_before && !short_win_after &&
400225e4:	02090463          	beqz	s2,4002260c <tcp_update_recv_wnd+0x74>
400225e8:	02051263          	bnez	a0,4002260c <tcp_update_recv_wnd+0x74>
400225ec:	22042703          	lw	a4,544(s0)
400225f0:	00400793          	li	a5,4
400225f4:	00f71c63          	bne	a4,a5,4002260c <tcp_update_recv_wnd+0x74>
		k_work_cancel_delayable(&conn->ack_timer);
400225f8:	18040513          	addi	a0,s0,384
400225fc:	3710d0ef          	jal	ra,4003016c <k_work_cancel_delayable>
		tcp_out(conn, ACK);
40022600:	01000593          	li	a1,16
40022604:	00040513          	mv	a0,s0
40022608:	eecff0ef          	jal	ra,40021cf4 <tcp_out>
}
4002260c:	00c12083          	lw	ra,12(sp)
40022610:	00812403          	lw	s0,8(sp)
40022614:	00412483          	lw	s1,4(sp)
40022618:	00012903          	lw	s2,0(sp)
4002261c:	00000513          	li	a0,0
40022620:	01010113          	addi	sp,sp,16
40022624:	00008067          	ret

40022628 <net_tcp_update_recv_wnd>:
{
40022628:	fd010113          	addi	sp,sp,-48
4002262c:	02112623          	sw	ra,44(sp)
40022630:	02812423          	sw	s0,40(sp)
40022634:	02912223          	sw	s1,36(sp)
40022638:	03212023          	sw	s2,32(sp)
	struct tcp *conn = context->tcp;
4002263c:	05452403          	lw	s0,84(a0)
	if (!conn) {
40022640:	06041063          	bnez	s0,400226a0 <net_tcp_update_recv_wnd+0x78>
		NET_ERR("context->tcp == NULL");
40022644:	40044537          	lui	a0,0x40044
40022648:	7a052783          	lw	a5,1952(a0) # 400447a0 <log_dynamic_net_tcp>
4002264c:	0077f793          	andi	a5,a5,7
40022650:	02079263          	bnez	a5,40022674 <net_tcp_update_recv_wnd+0x4c>
		return -EPROTOTYPE;
40022654:	f9500493          	li	s1,-107
}
40022658:	02c12083          	lw	ra,44(sp)
4002265c:	02812403          	lw	s0,40(sp)
40022660:	02012903          	lw	s2,32(sp)
40022664:	00048513          	mv	a0,s1
40022668:	02412483          	lw	s1,36(sp)
4002266c:	03010113          	addi	sp,sp,48
40022670:	00008067          	ret
		NET_ERR("context->tcp == NULL");
40022674:	400357b7          	lui	a5,0x40035
40022678:	3e478793          	addi	a5,a5,996 # 400353e4 <CSWTCH.16862+0x1ec>
4002267c:	000015b7          	lui	a1,0x1
40022680:	00f12e23          	sw	a5,28(sp)
40022684:	01810613          	addi	a2,sp,24
40022688:	00200793          	li	a5,2
4002268c:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
40022690:	7a050513          	addi	a0,a0,1952
40022694:	00f12c23          	sw	a5,24(sp)
40022698:	e91fd0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
4002269c:	fb9ff06f          	j	40022654 <net_tcp_update_recv_wnd+0x2c>
	k_mutex_lock(&conn->lock, K_FOREVER);
400226a0:	02840413          	addi	s0,s0,40
400226a4:	00050493          	mv	s1,a0
400226a8:	00058913          	mv	s2,a1
400226ac:	fff00613          	li	a2,-1
400226b0:	00040513          	mv	a0,s0
400226b4:	fff00593          	li	a1,-1
400226b8:	fb5fd0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	ret = tcp_update_recv_wnd((struct tcp *)context->tcp, delta);
400226bc:	0544a503          	lw	a0,84(s1)
400226c0:	00090593          	mv	a1,s2
400226c4:	ed5ff0ef          	jal	ra,40022598 <tcp_update_recv_wnd>
400226c8:	00050493          	mv	s1,a0
	k_mutex_unlock(&conn->lock);
400226cc:	00040513          	mv	a0,s0
400226d0:	c50fe0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
	return ret;
400226d4:	f85ff06f          	j	40022658 <net_tcp_update_recv_wnd+0x30>

400226d8 <tcp_data_get>:
	if (tcp_recv_cb) {
400226d8:	400397b7          	lui	a5,0x40039
400226dc:	0c07a783          	lw	a5,192(a5) # 400390c0 <tcp_recv_cb>
{
400226e0:	fc010113          	addi	sp,sp,-64
400226e4:	02112e23          	sw	ra,60(sp)
400226e8:	02812c23          	sw	s0,56(sp)
400226ec:	02912a23          	sw	s1,52(sp)
400226f0:	03212823          	sw	s2,48(sp)
400226f4:	03312623          	sw	s3,44(sp)
400226f8:	03412423          	sw	s4,40(sp)
400226fc:	03512223          	sw	s5,36(sp)
40022700:	03612023          	sw	s6,32(sp)
40022704:	01712e23          	sw	s7,28(sp)
40022708:	01812c23          	sw	s8,24(sp)
	if (tcp_recv_cb) {
4002270c:	02078e63          	beqz	a5,40022748 <tcp_data_get+0x70>
		tcp_recv_cb(conn, pkt);
40022710:	000780e7          	jalr	a5
	enum net_verdict ret = NET_DROP;
40022714:	00200513          	li	a0,2
}
40022718:	03c12083          	lw	ra,60(sp)
4002271c:	03812403          	lw	s0,56(sp)
40022720:	03412483          	lw	s1,52(sp)
40022724:	03012903          	lw	s2,48(sp)
40022728:	02c12983          	lw	s3,44(sp)
4002272c:	02812a03          	lw	s4,40(sp)
40022730:	02412a83          	lw	s5,36(sp)
40022734:	02012b03          	lw	s6,32(sp)
40022738:	01c12b83          	lw	s7,28(sp)
4002273c:	01812c03          	lw	s8,24(sp)
40022740:	04010113          	addi	sp,sp,64
40022744:	00008067          	ret
	if (conn->context->recv_cb) {
40022748:	00452783          	lw	a5,4(a0)
4002274c:	00050493          	mv	s1,a0
40022750:	0487a783          	lw	a5,72(a5)
40022754:	fc0780e3          	beqz	a5,40022714 <tcp_data_get+0x3c>
40022758:	00c52783          	lw	a5,12(a0)
		*len += tcp_check_pending_data(conn, pkt, *len);
4002275c:	00062a83          	lw	s5,0(a2)
40022760:	00058913          	mv	s2,a1
40022764:	0087a783          	lw	a5,8(a5)
40022768:	00060a13          	mv	s4,a2
	return !pkt->buffer || !net_pkt_data(pkt) || pkt->buffer->len == 0;
4002276c:	14078a63          	beqz	a5,400228c0 <tcp_data_get+0x1e8>
40022770:	00c7a703          	lw	a4,12(a5)
40022774:	14070663          	beqz	a4,400228c0 <tcp_data_get+0x1e8>
40022778:	0107d783          	lhu	a5,16(a5)
4002277c:	14078263          	beqz	a5,400228c0 <tcp_data_get+0x1e8>
		struct tcphdr *th = th_get(pkt);
40022780:	00058513          	mv	a0,a1
40022784:	f7dfd0ef          	jal	ra,40020700 <th_get>
		uint32_t expected_seq = th_seq(th) + len;
40022788:	00554703          	lbu	a4,5(a0)
4002278c:	00454783          	lbu	a5,4(a0)
40022790:	00754403          	lbu	s0,7(a0)
40022794:	00871713          	slli	a4,a4,0x8
40022798:	00f76733          	or	a4,a4,a5
4002279c:	00654783          	lbu	a5,6(a0)
400227a0:	01841413          	slli	s0,s0,0x18
400227a4:	000106b7          	lui	a3,0x10
400227a8:	01079793          	slli	a5,a5,0x10
400227ac:	00e7e7b3          	or	a5,a5,a4
400227b0:	00f46733          	or	a4,s0,a5
400227b4:	01879793          	slli	a5,a5,0x18
400227b8:	01845413          	srli	s0,s0,0x18
400227bc:	00f46433          	or	s0,s0,a5
400227c0:	f0068693          	addi	a3,a3,-256 # ff00 <__kernel_ram_size+0x43f8>
400227c4:	00875793          	srli	a5,a4,0x8
400227c8:	00d7f7b3          	and	a5,a5,a3
400227cc:	00f46433          	or	s0,s0,a5
400227d0:	00871713          	slli	a4,a4,0x8
400227d4:	00ff07b7          	lui	a5,0xff0
400227d8:	00f77733          	and	a4,a4,a5
		pending_seq = tcp_get_seq(conn->queue_recv_data->buffer);
400227dc:	00c4a783          	lw	a5,12(s1)
		uint32_t expected_seq = th_seq(th) + len;
400227e0:	00e46433          	or	s0,s0,a4
400227e4:	008a8c33          	add	s8,s5,s0
		pending_seq = tcp_get_seq(conn->queue_recv_data->buffer);
400227e8:	0087ab83          	lw	s7,8(a5) # ff0008 <__rom_region_size+0xfb704c>
	return *(uint32_t *)net_buf_user_data(buf);
400227ec:	018bab03          	lw	s6,24(s7)
		pending_len = net_pkt_get_len(conn->queue_recv_data);
400227f0:	000b8513          	mv	a0,s7
		end_offset = expected_seq - pending_seq;
400227f4:	416c05b3          	sub	a1,s8,s6
400227f8:	00b12623          	sw	a1,12(sp)
		pending_len = net_pkt_get_len(conn->queue_recv_data);
400227fc:	e75fd0ef          	jal	ra,40020670 <net_pkt_get_len.isra.0>
		if (end_offset < pending_len) {
40022800:	00c12583          	lw	a1,12(sp)
		pending_len = net_pkt_get_len(conn->queue_recv_data);
40022804:	00050993          	mv	s3,a0
		if (end_offset < pending_len) {
40022808:	08a5fa63          	bgeu	a1,a0,4002289c <tcp_data_get+0x1c4>
			if (end_offset) {
4002280c:	00058a63          	beqz	a1,40022820 <tcp_data_get+0x148>
				net_pkt_remove_tail(pkt, end_offset);
40022810:	00090513          	mv	a0,s2
40022814:	013b09b3          	add	s3,s6,s3
40022818:	a68f50ef          	jal	ra,40017a80 <net_pkt_remove_tail>
				pending_len -= end_offset;
4002281c:	418989b3          	sub	s3,s3,s8
			net_buf_frag_add(pkt->buffer,
40022820:	00c4a783          	lw	a5,12(s1)
40022824:	00892503          	lw	a0,8(s2)
40022828:	0087a583          	lw	a1,8(a5)
4002282c:	e99ea0ef          	jal	ra,4000d6c4 <net_buf_frag_add>
			conn->queue_recv_data->buffer = NULL;
40022830:	00c4a783          	lw	a5,12(s1)
			k_work_cancel_delayable(&conn->recv_queue_timer);
40022834:	0c048513          	addi	a0,s1,192
			conn->queue_recv_data->buffer = NULL;
40022838:	0007a423          	sw	zero,8(a5)
			k_work_cancel_delayable(&conn->recv_queue_timer);
4002283c:	1310d0ef          	jal	ra,4003016c <k_work_cancel_delayable>
		*len += tcp_check_pending_data(conn, pkt, *len);
40022840:	000a2783          	lw	a5,0(s4)
		net_pkt_cursor_init(pkt);
40022844:	00090513          	mv	a0,s2
		*len += tcp_check_pending_data(conn, pkt, *len);
40022848:	013787b3          	add	a5,a5,s3
4002284c:	00fa2023          	sw	a5,0(s4)
		net_pkt_cursor_init(pkt);
40022850:	aa0f50ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	pkt->overwrite = overwrite;
40022854:	03794783          	lbu	a5,55(s2)
		net_pkt_skip(pkt, net_pkt_get_len(pkt) - *len);
40022858:	00892503          	lw	a0,8(s2)
4002285c:	0017e793          	ori	a5,a5,1
40022860:	02f90ba3          	sb	a5,55(s2)
40022864:	e0dfd0ef          	jal	ra,40020670 <net_pkt_get_len.isra.0>
40022868:	000a2583          	lw	a1,0(s4)
4002286c:	40b505b3          	sub	a1,a0,a1
40022870:	00090513          	mv	a0,s2
40022874:	85df50ef          	jal	ra,400180d0 <net_pkt_skip>
		tcp_update_recv_wnd(conn, -*len);
40022878:	000a2583          	lw	a1,0(s4)
4002287c:	00048513          	mv	a0,s1
40022880:	40b005b3          	neg	a1,a1
40022884:	d15ff0ef          	jal	ra,40022598 <tcp_update_recv_wnd>
		k_fifo_put(&conn->recv_data, pkt);
40022888:	06c48513          	addi	a0,s1,108
4002288c:	00090593          	mv	a1,s2
40022890:	7750c0ef          	jal	ra,4002f804 <k_queue_append>
40022894:	00000513          	li	a0,0
	return ret;
40022898:	e81ff06f          	j	40022718 <tcp_data_get+0x40>
		gap_size = (int32_t)(pending_seq - th_seq(th) - ((uint32_t)len));
4002289c:	415b0b33          	sub	s6,s6,s5
400228a0:	408b0b33          	sub	s6,s6,s0
			if (gap_size <= 0) {
400228a4:	01604e63          	bgtz	s6,400228c0 <tcp_data_get+0x1e8>
				net_buf_unref(conn->queue_recv_data->buffer);
400228a8:	000b8513          	mv	a0,s7
400228ac:	d11ea0ef          	jal	ra,4000d5bc <net_buf_unref>
				conn->queue_recv_data->buffer = NULL;
400228b0:	00c4a783          	lw	a5,12(s1)
				k_work_cancel_delayable(&conn->recv_queue_timer);
400228b4:	0c048513          	addi	a0,s1,192
				conn->queue_recv_data->buffer = NULL;
400228b8:	0007a423          	sw	zero,8(a5)
				k_work_cancel_delayable(&conn->recv_queue_timer);
400228bc:	0b10d0ef          	jal	ra,4003016c <k_work_cancel_delayable>
	size_t pending_len = 0;
400228c0:	00000993          	li	s3,0
400228c4:	f7dff06f          	j	40022840 <tcp_data_get+0x168>

400228c8 <tcp_send_queued_data.part.0>:
static int tcp_send_queued_data(struct tcp *conn)
400228c8:	fe010113          	addi	sp,sp,-32
400228cc:	00812c23          	sw	s0,24(sp)
400228d0:	00912a23          	sw	s1,20(sp)
400228d4:	00112e23          	sw	ra,28(sp)
400228d8:	01212823          	sw	s2,16(sp)
400228dc:	01312623          	sw	s3,12(sp)
400228e0:	00050413          	mv	s0,a0
	int ret = 0;
400228e4:	00000493          	li	s1,0
	while (tcp_unsent_len(conn) > 0) {
400228e8:	00040513          	mv	a0,s0
400228ec:	c45fd0ef          	jal	ra,40020530 <tcp_unsent_len>
400228f0:	02a05263          	blez	a0,40022914 <tcp_send_queued_data.part.0+0x4c>
		if ((conn->tcp_nodelay == false) && (conn->unacked_len > 0)) {
400228f4:	23c42783          	lw	a5,572(s0)
400228f8:	00b7d793          	srli	a5,a5,0xb
400228fc:	0017f793          	andi	a5,a5,1
40022900:	04078463          	beqz	a5,40022948 <tcp_send_queued_data.part.0+0x80>
		ret = tcp_send_data(conn);
40022904:	00040513          	mv	a0,s0
40022908:	e78ff0ef          	jal	ra,40021f80 <tcp_send_data>
4002290c:	00050493          	mv	s1,a0
		if (ret < 0) {
40022910:	fc055ce3          	bgez	a0,400228e8 <tcp_send_queued_data.part.0+0x20>
	if (conn->send_data_total) {
40022914:	21042783          	lw	a5,528(s0)
40022918:	0f040913          	addi	s2,s0,240
4002291c:	10040513          	addi	a0,s0,256
40022920:	08079263          	bnez	a5,400229a4 <tcp_send_queued_data.part.0+0xdc>
40022924:	3650e0ef          	jal	ra,40031488 <z_timeout_remaining>
}
40022928:	01c12083          	lw	ra,28(sp)
4002292c:	01812403          	lw	s0,24(sp)
40022930:	01012903          	lw	s2,16(sp)
40022934:	00c12983          	lw	s3,12(sp)
40022938:	00048513          	mv	a0,s1
4002293c:	01412483          	lw	s1,20(sp)
40022940:	02010113          	addi	sp,sp,32
40022944:	00008067          	ret
		if ((conn->tcp_nodelay == false) && (conn->unacked_len > 0)) {
40022948:	21842783          	lw	a5,536(s0)
4002294c:	faf05ce3          	blez	a5,40022904 <tcp_send_queued_data.part.0+0x3c>
			if (tcp_unsent_len(conn) < conn_mss(conn)) {
40022950:	00040513          	mv	a0,s0
40022954:	bddfd0ef          	jal	ra,40020530 <tcp_unsent_len>
40022958:	08844783          	lbu	a5,136(s0)
4002295c:	00050913          	mv	s2,a0
40022960:	21800993          	li	s3,536
40022964:	0017f793          	andi	a5,a5,1
40022968:	00078463          	beqz	a5,40022970 <tcp_send_queued_data.part.0+0xa8>
4002296c:	08445983          	lhu	s3,132(s0)
40022970:	00040513          	mv	a0,s0
40022974:	f01fe0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
40022978:	02a9d063          	bge	s3,a0,40022998 <tcp_send_queued_data.part.0+0xd0>
4002297c:	08844783          	lbu	a5,136(s0)
40022980:	21800513          	li	a0,536
40022984:	0017f793          	andi	a5,a5,1
40022988:	00078463          	beqz	a5,40022990 <tcp_send_queued_data.part.0+0xc8>
4002298c:	08445503          	lhu	a0,132(s0)
40022990:	f6a95ae3          	bge	s2,a0,40022904 <tcp_send_queued_data.part.0+0x3c>
40022994:	f81ff06f          	j	40022914 <tcp_send_queued_data.part.0+0x4c>
40022998:	00040513          	mv	a0,s0
4002299c:	ed9fe0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
400229a0:	ff1ff06f          	j	40022990 <tcp_send_queued_data.part.0+0xc8>
400229a4:	2e50e0ef          	jal	ra,40031488 <z_timeout_remaining>
	if (k_work_delayable_remaining_get(&conn->send_data_timer)) {
400229a8:	00b56533          	or	a0,a0,a1
400229ac:	f6051ee3          	bnez	a0,40022928 <tcp_send_queued_data.part.0+0x60>
					    K_MSEC(TCP_RTO_MS));
400229b0:	23845503          	lhu	a0,568(s0)
		conn->send_data_retries = 0;
400229b4:	22040d23          	sb	zero,570(s0)
400229b8:	00a00613          	li	a2,10
400229bc:	00000693          	li	a3,0
400229c0:	00950513          	addi	a0,a0,9
400229c4:	00000593          	li	a1,0
400229c8:	8f1dd0ef          	jal	ra,400002b8 <__udivdi3>
400229cc:	00050613          	mv	a2,a0
		k_work_reschedule_for_queue(&tcp_work_q, &conn->send_data_timer,
400229d0:	4003a537          	lui	a0,0x4003a
400229d4:	00058693          	mv	a3,a1
400229d8:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
400229dc:	00090593          	mv	a1,s2
400229e0:	6e40d0ef          	jal	ra,400300c4 <k_work_reschedule_for_queue>
400229e4:	f45ff06f          	j	40022928 <tcp_send_queued_data.part.0+0x60>

400229e8 <net_tcp_queue_data>:
{
400229e8:	fe010113          	addi	sp,sp,-32
400229ec:	00912a23          	sw	s1,20(sp)
400229f0:	00112e23          	sw	ra,28(sp)
400229f4:	00812c23          	sw	s0,24(sp)
400229f8:	01212823          	sw	s2,16(sp)
400229fc:	01312623          	sw	s3,12(sp)
40022a00:	01412423          	sw	s4,8(sp)
40022a04:	01512223          	sw	s5,4(sp)
	struct tcp *conn = context->tcp;
40022a08:	05452403          	lw	s0,84(a0)
		return -ENOTCONN;
40022a0c:	f8000493          	li	s1,-128
	if (!conn || conn->state != TCP_ESTABLISHED) {
40022a10:	06040063          	beqz	s0,40022a70 <net_tcp_queue_data+0x88>
40022a14:	22042703          	lw	a4,544(s0)
40022a18:	00400793          	li	a5,4
		return -ENOTCONN;
40022a1c:	f8000493          	li	s1,-128
	if (!conn || conn->state != TCP_ESTABLISHED) {
40022a20:	04f71863          	bne	a4,a5,40022a70 <net_tcp_queue_data+0x88>
	k_mutex_lock(&conn->lock, K_FOREVER);
40022a24:	02840a93          	addi	s5,s0,40
40022a28:	00058913          	mv	s2,a1
40022a2c:	fff00613          	li	a2,-1
40022a30:	fff00593          	li	a1,-1
40022a34:	000a8513          	mv	a0,s5
40022a38:	c35fd0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	bool window_full = (conn->send_data_total >= conn->send_win);
40022a3c:	23645783          	lhu	a5,566(s0)
	if (tcp_window_full(conn)) {
40022a40:	21042703          	lw	a4,528(s0)
40022a44:	04f76a63          	bltu	a4,a5,40022a98 <net_tcp_queue_data+0xb0>
		if (conn->send_win == 0) {
40022a48:	00078e63          	beqz	a5,40022a64 <net_tcp_queue_data+0x7c>
		(void)k_work_schedule_for_queue(&tcp_work_q,
40022a4c:	4003a537          	lui	a0,0x4003a
40022a50:	00000613          	li	a2,0
40022a54:	00000693          	li	a3,0
40022a58:	0f040593          	addi	a1,s0,240
40022a5c:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
40022a60:	5ec0d0ef          	jal	ra,4003004c <k_work_schedule_for_queue>
		goto out;
40022a64:	ff500493          	li	s1,-11
	k_mutex_unlock(&conn->lock);
40022a68:	000a8513          	mv	a0,s5
40022a6c:	8b4fe0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
}
40022a70:	01c12083          	lw	ra,28(sp)
40022a74:	01812403          	lw	s0,24(sp)
40022a78:	01012903          	lw	s2,16(sp)
40022a7c:	00c12983          	lw	s3,12(sp)
40022a80:	00812a03          	lw	s4,8(sp)
40022a84:	00412a83          	lw	s5,4(sp)
40022a88:	00048513          	mv	a0,s1
40022a8c:	01412483          	lw	s1,20(sp)
40022a90:	02010113          	addi	sp,sp,32
40022a94:	00008067          	ret
	len = net_pkt_get_len(pkt);
40022a98:	00892503          	lw	a0,8(s2)
40022a9c:	bd5fd0ef          	jal	ra,40020670 <net_pkt_get_len.isra.0>
	if (conn->send_data->buffer) {
40022aa0:	00842783          	lw	a5,8(s0)
	len = net_pkt_get_len(pkt);
40022aa4:	00050a13          	mv	s4,a0
	if (conn->send_data->buffer) {
40022aa8:	0087a983          	lw	s3,8(a5)
40022aac:	00098863          	beqz	s3,40022abc <net_tcp_queue_data+0xd4>
		orig_buf = net_buf_frag_last(conn->send_data->buffer);
40022ab0:	00098513          	mv	a0,s3
40022ab4:	bd9ea0ef          	jal	ra,4000d68c <net_buf_frag_last>
40022ab8:	00050993          	mv	s3,a0
	net_pkt_append_buffer(conn->send_data, pkt->buffer);
40022abc:	00892583          	lw	a1,8(s2)
40022ac0:	00842503          	lw	a0,8(s0)
40022ac4:	970f50ef          	jal	ra,40017c34 <net_pkt_append_buffer>
	conn->send_data_total += len;
40022ac8:	21042783          	lw	a5,528(s0)
40022acc:	014787b3          	add	a5,a5,s4
40022ad0:	20f42823          	sw	a5,528(s0)
	pkt->buffer = NULL;
40022ad4:	00092423          	sw	zero,8(s2)
	if (conn->data_mode == TCP_DATA_MODE_RESEND) {
40022ad8:	22442703          	lw	a4,548(s0)
40022adc:	00100793          	li	a5,1
40022ae0:	08f70063          	beq	a4,a5,40022b60 <net_tcp_queue_data+0x178>
40022ae4:	00040513          	mv	a0,s0
40022ae8:	de1ff0ef          	jal	ra,400228c8 <tcp_send_queued_data.part.0>
40022aec:	00050493          	mv	s1,a0
	if (ret < 0 && ret != -ENOBUFS) {
40022af0:	06055a63          	bgez	a0,40022b64 <net_tcp_queue_data+0x17c>
40022af4:	f9700793          	li	a5,-105
40022af8:	00f50a63          	beq	a0,a5,40022b0c <net_tcp_queue_data+0x124>
		tcp_conn_close(conn, ret);
40022afc:	00050593          	mv	a1,a0
40022b00:	00040513          	mv	a0,s0
40022b04:	dbcfe0ef          	jal	ra,400210c0 <tcp_conn_close.isra.0>
		goto out;
40022b08:	f61ff06f          	j	40022a68 <net_tcp_queue_data+0x80>
		(conn->send_data_total < (conn->unacked_len + len))) {
40022b0c:	21842703          	lw	a4,536(s0)
40022b10:	21042783          	lw	a5,528(s0)
40022b14:	00ea0733          	add	a4,s4,a4
	if ((ret == -ENOBUFS) &&
40022b18:	04e7e463          	bltu	a5,a4,40022b60 <net_tcp_queue_data+0x178>
		conn->send_data_total -= len;
40022b1c:	414787b3          	sub	a5,a5,s4
40022b20:	20f42823          	sw	a5,528(s0)
		if (orig_buf) {
40022b24:	02098263          	beqz	s3,40022b48 <net_tcp_queue_data+0x160>
			pkt->buffer = orig_buf->frags;
40022b28:	0049a783          	lw	a5,4(s3)
40022b2c:	00f92423          	sw	a5,8(s2)
			orig_buf->frags = NULL;
40022b30:	0009a223          	sw	zero,4(s3)
		if (conn->send_data_total == 0) {
40022b34:	21042783          	lw	a5,528(s0)
40022b38:	f20798e3          	bnez	a5,40022a68 <net_tcp_queue_data+0x80>
			k_work_cancel_delayable(&conn->send_data_timer);
40022b3c:	0f040513          	addi	a0,s0,240
40022b40:	62c0d0ef          	jal	ra,4003016c <k_work_cancel_delayable>
40022b44:	f25ff06f          	j	40022a68 <net_tcp_queue_data+0x80>
			pkt->buffer = conn->send_data->buffer;
40022b48:	00842783          	lw	a5,8(s0)
40022b4c:	0087a783          	lw	a5,8(a5)
40022b50:	00f92423          	sw	a5,8(s2)
			conn->send_data->buffer = NULL;
40022b54:	00842783          	lw	a5,8(s0)
40022b58:	0007a423          	sw	zero,8(a5)
40022b5c:	fd9ff06f          	j	40022b34 <net_tcp_queue_data+0x14c>
{
40022b60:	00000493          	li	s1,0
	bool window_full = (conn->send_data_total >= conn->send_win);
40022b64:	23645703          	lhu	a4,566(s0)
		if (tcp_window_full(conn)) {
40022b68:	21042783          	lw	a5,528(s0)
40022b6c:	00e7ea63          	bltu	a5,a4,40022b80 <net_tcp_queue_data+0x198>
	return z_impl_k_sem_take(sem, timeout);
40022b70:	00000593          	li	a1,0
40022b74:	00000613          	li	a2,0
40022b78:	05440513          	addi	a0,s0,84
40022b7c:	62d0c0ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
		tcp_pkt_unref(pkt);
40022b80:	00090513          	mv	a0,s2
40022b84:	c99f40ef          	jal	ra,4001781c <net_pkt_unref>
40022b88:	ee1ff06f          	j	40022a68 <net_tcp_queue_data+0x80>

40022b8c <tcp_in>:
{
40022b8c:	f7010113          	addi	sp,sp,-144
40022b90:	08812423          	sw	s0,136(sp)
40022b94:	08912223          	sw	s1,132(sp)
40022b98:	09212023          	sw	s2,128(sp)
40022b9c:	08112623          	sw	ra,140(sp)
40022ba0:	07312e23          	sw	s3,124(sp)
40022ba4:	07412c23          	sw	s4,120(sp)
40022ba8:	07512a23          	sw	s5,116(sp)
40022bac:	07612823          	sw	s6,112(sp)
40022bb0:	07712623          	sw	s7,108(sp)
40022bb4:	07812423          	sw	s8,104(sp)
40022bb8:	07912223          	sw	s9,100(sp)
40022bbc:	07a12023          	sw	s10,96(sp)
40022bc0:	05b12e23          	sw	s11,92(sp)
40022bc4:	09010413          	addi	s0,sp,144
	k_mutex_lock(&conn->lock, K_FOREVER);
40022bc8:	02850793          	addi	a5,a0,40
40022bcc:	f6f42e23          	sw	a5,-132(s0)
{
40022bd0:	00050493          	mv	s1,a0
40022bd4:	00058913          	mv	s2,a1
	struct tcphdr *th = pkt ? th_get(pkt) : NULL;
40022bd8:	02059663          	bnez	a1,40022c04 <tcp_in+0x78>
	k_mutex_lock(&conn->lock, K_FOREVER);
40022bdc:	fff00593          	li	a1,-1
40022be0:	fff00613          	li	a2,-1
40022be4:	00078513          	mv	a0,a5
	uint8_t next = 0, fl = 0;
40022be8:	00000993          	li	s3,0
	k_mutex_lock(&conn->lock, K_FOREVER);
40022bec:	a81fd0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	struct tcphdr *th = pkt ? th_get(pkt) : NULL;
40022bf0:	00000c13          	li	s8,0
	enum net_verdict verdict = NET_DROP;
40022bf4:	00200a13          	li	s4,2
	int close_status = 0;
40022bf8:	00000b13          	li	s6,0
	return len > 0 ? (size_t)len : 0;
40022bfc:	00000a93          	li	s5,0
40022c00:	0680006f          	j	40022c68 <tcp_in+0xdc>
	struct tcphdr *th = pkt ? th_get(pkt) : NULL;
40022c04:	00058513          	mv	a0,a1
40022c08:	af9fd0ef          	jal	ra,40020700 <th_get>
40022c0c:	00050c13          	mv	s8,a0
	uint8_t next = 0, fl = 0;
40022c10:	00000993          	li	s3,0
	size_t tcp_options_len = th ? (th_off(th) - 5) * 4 : 0;
40022c14:	06051463          	bnez	a0,40022c7c <tcp_in+0xf0>
	k_mutex_lock(&conn->lock, K_FOREVER);
40022c18:	fff00593          	li	a1,-1
40022c1c:	fff00613          	li	a2,-1
40022c20:	02848513          	addi	a0,s1,40
40022c24:	a49fd0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	enum net_verdict verdict = NET_DROP;
40022c28:	00200a13          	li	s4,2
	int close_status = 0;
40022c2c:	00000b13          	li	s6,0
	struct tcphdr *th = th_get(pkt);
40022c30:	00090513          	mv	a0,s2
40022c34:	acdfd0ef          	jal	ra,40020700 <th_get>
40022c38:	00050b93          	mv	s7,a0
	int len = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -
40022c3c:	00892503          	lw	a0,8(s2)
40022c40:	a31fd0ef          	jal	ra,40020670 <net_pkt_get_len.isra.0>
40022c44:	03694703          	lbu	a4,54(s2)
		net_pkt_ip_opts_len(pkt) - sizeof(*th) - tcp_options_len;
40022c48:	03a95683          	lhu	a3,58(s2)
40022c4c:	00d70733          	add	a4,a4,a3
40022c50:	40e50ab3          	sub	s5,a0,a4
	size_t tcp_options_len = (th_off(th) - 5) * 4;
40022c54:	00cbc703          	lbu	a4,12(s7)
40022c58:	00475713          	srli	a4,a4,0x4
40022c5c:	00271713          	slli	a4,a4,0x2
		net_pkt_ip_opts_len(pkt) - sizeof(*th) - tcp_options_len;
40022c60:	40ea8ab3          	sub	s5,s5,a4
	return len > 0 ? (size_t)len : 0;
40022c64:	f80acce3          	bltz	s5,40022bfc <tcp_in+0x70>
	switch (conn->state) {
40022c68:	40035d37          	lui	s10,0x40035
40022c6c:	520d0793          	addi	a5,s10,1312 # 40035520 <CSWTCH.16862+0x328>
	len = pkt ? tcp_data_len(pkt) : 0;
40022c70:	00000c93          	li	s9,0
	switch (conn->state) {
40022c74:	f6f42c23          	sw	a5,-136(s0)
40022c78:	5040006f          	j	4002317c <tcp_in+0x5f0>
	size_t tcp_options_len = th ? (th_off(th) - 5) * 4 : 0;
40022c7c:	00c54a03          	lbu	s4,12(a0)
		fl = th_flags(th) & ~(ECN | CWR);
40022c80:	00d54a83          	lbu	s5,13(a0)
	k_mutex_lock(&conn->lock, K_FOREVER);
40022c84:	fff00593          	li	a1,-1
40022c88:	fff00613          	li	a2,-1
40022c8c:	02848513          	addi	a0,s1,40
40022c90:	9ddfd0ef          	jal	ra,4002066c <k_mutex_lock.constprop.0.isra.0>
	if (th && th_off(th) < 5) {
40022c94:	00cc4703          	lbu	a4,12(s8)
	size_t tcp_options_len = th ? (th_off(th) - 5) * 4 : 0;
40022c98:	004a5a13          	srli	s4,s4,0x4
40022c9c:	ffba0a13          	addi	s4,s4,-5
	if (th && th_off(th) < 5) {
40022ca0:	00475713          	srli	a4,a4,0x4
40022ca4:	00400693          	li	a3,4
	size_t tcp_options_len = th ? (th_off(th) - 5) * 4 : 0;
40022ca8:	002a1a13          	slli	s4,s4,0x2
		fl = th_flags(th) & ~(ECN | CWR);
40022cac:	03faf993          	andi	s3,s5,63
	if (th && th_off(th) < 5) {
40022cb0:	02e6e063          	bltu	a3,a4,40022cd0 <tcp_in+0x144>
		tcp_out(conn, RST);
40022cb4:	00400593          	li	a1,4
40022cb8:	00048513          	mv	a0,s1
40022cbc:	838ff0ef          	jal	ra,40021cf4 <tcp_out>
		conn_state(conn, TCP_CLOSED);
40022cc0:	00b00713          	li	a4,11
40022cc4:	22e4a023          	sw	a4,544(s1)
	enum net_verdict verdict = NET_DROP;
40022cc8:	00200a13          	li	s4,2
40022ccc:	1ac0006f          	j	40022e78 <tcp_in+0x2ec>
	if (FL(&fl, &, RST)) {
40022cd0:	0e099463          	bnez	s3,40022db8 <tcp_in+0x22c>
	if (tcp_options_len && !tcp_options_check(&conn->recv_options, pkt,
40022cd4:	080a0063          	beqz	s4,40022d54 <tcp_in+0x1c8>
	net_pkt_cursor_init(pkt);
40022cd8:	00090513          	mv	a0,s2
	backup->buf = pkt->cursor.buf;
40022cdc:	00c92b03          	lw	s6,12(s2)
	backup->pos = pkt->cursor.pos;
40022ce0:	01092a83          	lw	s5,16(s2)
40022ce4:	e0df40ef          	jal	ra,40017af0 <net_pkt_cursor_init>
	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) + net_pkt_ip_opts_len(pkt) +
40022ce8:	03a95703          	lhu	a4,58(s2)
40022cec:	03694583          	lbu	a1,54(s2)
40022cf0:	00090513          	mv	a0,s2
40022cf4:	00e585b3          	add	a1,a1,a4
40022cf8:	01458593          	addi	a1,a1,20
40022cfc:	bd4f50ef          	jal	ra,400180d0 <net_pkt_skip>
	ret = net_pkt_read(pkt, buf, MIN(tcp_options_len, buf_len));
40022d00:	02800713          	li	a4,40
40022d04:	000a0613          	mv	a2,s4
40022d08:	01477463          	bgeu	a4,s4,40022d10 <tcp_in+0x184>
40022d0c:	02800613          	li	a2,40
40022d10:	f9840593          	addi	a1,s0,-104
40022d14:	00090513          	mv	a0,s2
40022d18:	e20f50ef          	jal	ra,40018338 <net_pkt_read>
	pkt->cursor.buf = backup->buf;
40022d1c:	01692623          	sw	s6,12(s2)
	pkt->cursor.pos = backup->pos;
40022d20:	01592823          	sw	s5,16(s2)
	recv_options->mss_found = false;
40022d24:	0884c703          	lbu	a4,136(s1)
40022d28:	ffc77713          	andi	a4,a4,-4
40022d2c:	08e48423          	sb	a4,136(s1)
	if (ret < 0) {
40022d30:	02054063          	bltz	a0,40022d50 <tcp_in+0x1c4>
	if (tcp_options_len && !tcp_options_check(&conn->recv_options, pkt,
40022d34:	000a0593          	mv	a1,s4
	recv_options->mss_found = false;
40022d38:	f9840713          	addi	a4,s0,-104
		} else if (opt == NET_TCP_NOP_OPT) {
40022d3c:	00100513          	li	a0,1
		switch (opt) {
40022d40:	00200313          	li	t1,2
			if (opt_len != 4) {
40022d44:	00400e13          	li	t3,4
		switch (opt) {
40022d48:	00300813          	li	a6,3
	for ( ; options && len >= 1; options += opt_len, len -= opt_len) {
40022d4c:	12b04a63          	bgtz	a1,40022e80 <tcp_in+0x2f4>
	if (false == result) {
40022d50:	19405863          	blez	s4,40022ee0 <tcp_in+0x354>
	if (th && (conn->state != TCP_LISTEN) && (conn->state != TCP_SYN_SENT) &&
40022d54:	2204a703          	lw	a4,544(s1)
40022d58:	00100693          	li	a3,1
40022d5c:	fff70713          	addi	a4,a4,-1
40022d60:	22e6f663          	bgeu	a3,a4,40022f8c <tcp_in+0x400>
	    tcp_validate_seq(conn, th) && FL(&fl, &, SYN)) {
40022d64:	000c0593          	mv	a1,s8
40022d68:	00048513          	mv	a0,s1
40022d6c:	d0cfd0ef          	jal	ra,40020278 <tcp_validate_seq>
	if (th && (conn->state != TCP_LISTEN) && (conn->state != TCP_SYN_SENT) &&
40022d70:	20050e63          	beqz	a0,40022f8c <tcp_in+0x400>
	    tcp_validate_seq(conn, th) && FL(&fl, &, SYN)) {
40022d74:	20098c63          	beqz	s3,40022f8c <tcp_in+0x400>
40022d78:	40033537          	lui	a0,0x40033
40022d7c:	1e850513          	addi	a0,a0,488 # 400331e8 <severity_lvls+0xf0>
40022d80:	e55e90ef          	jal	ra,4000cbd4 <strlen>
40022d84:	0029f713          	andi	a4,s3,2
40022d88:	20070263          	beqz	a4,40022f8c <tcp_in+0x400>
	UPDATE_STAT(iface, stats.tcp.seg_drop++);
40022d8c:	4003b737          	lui	a4,0x4003b
40022d90:	ed070713          	addi	a4,a4,-304 # 4003aed0 <net_stats>
40022d94:	07072683          	lw	a3,112(a4)
		net_stats_update_tcp_seg_drop(conn->iface);
40022d98:	0104a603          	lw	a2,16(s1)
	    tcp_validate_seq(conn, th) && FL(&fl, &, SYN)) {
40022d9c:	0fd9f993          	andi	s3,s3,253
40022da0:	00168693          	addi	a3,a3,1
40022da4:	06d72823          	sw	a3,112(a4)
40022da8:	07462703          	lw	a4,116(a2)
40022dac:	00170713          	addi	a4,a4,1
40022db0:	06e62a23          	sw	a4,116(a2)
40022db4:	f01ff06f          	j	40022cb4 <tcp_in+0x128>
	if (FL(&fl, &, RST)) {
40022db8:	40033537          	lui	a0,0x40033
40022dbc:	1e850513          	addi	a0,a0,488 # 400331e8 <severity_lvls+0xf0>
40022dc0:	e15e90ef          	jal	ra,4000cbd4 <strlen>
40022dc4:	004af713          	andi	a4,s5,4
40022dc8:	f00706e3          	beqz	a4,40022cd4 <tcp_in+0x148>
		if (!tcp_validate_seq(conn, th)) {
40022dcc:	000c0593          	mv	a1,s8
40022dd0:	00048513          	mv	a0,s1
40022dd4:	ca4fd0ef          	jal	ra,40020278 <tcp_validate_seq>
40022dd8:	4003b737          	lui	a4,0x4003b
	return pkt->iface;
40022ddc:	01892683          	lw	a3,24(s2)
	if (FL(&fl, &, RST)) {
40022de0:	03baf993          	andi	s3,s5,59
		if (!tcp_validate_seq(conn, th)) {
40022de4:	ed070713          	addi	a4,a4,-304 # 4003aed0 <net_stats>
40022de8:	06051663          	bnez	a0,40022e54 <tcp_in+0x2c8>
	UPDATE_STAT(iface, stats.tcp.rsterr++);
40022dec:	07c72783          	lw	a5,124(a4)
			k_mutex_unlock(&conn->lock);
40022df0:	f7c42503          	lw	a0,-132(s0)
			return NET_DROP;
40022df4:	00200a13          	li	s4,2
40022df8:	00178793          	addi	a5,a5,1
40022dfc:	06f72e23          	sw	a5,124(a4)
40022e00:	0806a783          	lw	a5,128(a3)
40022e04:	00178793          	addi	a5,a5,1
40022e08:	08f6a023          	sw	a5,128(a3)
			k_mutex_unlock(&conn->lock);
40022e0c:	d15fd0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
}
40022e10:	f7040113          	addi	sp,s0,-144
40022e14:	08c12083          	lw	ra,140(sp)
40022e18:	000a0513          	mv	a0,s4
40022e1c:	08812403          	lw	s0,136(sp)
40022e20:	08412483          	lw	s1,132(sp)
40022e24:	08012903          	lw	s2,128(sp)
40022e28:	07c12983          	lw	s3,124(sp)
40022e2c:	07812a03          	lw	s4,120(sp)
40022e30:	07412a83          	lw	s5,116(sp)
40022e34:	07012b03          	lw	s6,112(sp)
40022e38:	06c12b83          	lw	s7,108(sp)
40022e3c:	06812c03          	lw	s8,104(sp)
40022e40:	06412c83          	lw	s9,100(sp)
40022e44:	06012d03          	lw	s10,96(sp)
40022e48:	05c12d83          	lw	s11,92(sp)
40022e4c:	09010113          	addi	sp,sp,144
40022e50:	00008067          	ret
	UPDATE_STAT(iface, stats.tcp.rst++);
40022e54:	08072603          	lw	a2,128(a4)
		verdict = NET_OK;
40022e58:	00000a13          	li	s4,0
40022e5c:	00160613          	addi	a2,a2,1
40022e60:	08c72023          	sw	a2,128(a4)
40022e64:	0846a703          	lw	a4,132(a3)
40022e68:	00170713          	addi	a4,a4,1
40022e6c:	08e6a223          	sw	a4,132(a3)
		conn_state(conn, TCP_CLOSED);
40022e70:	00b00713          	li	a4,11
40022e74:	22e4a023          	sw	a4,544(s1)
		close_status = -ECONNRESET;
40022e78:	f9800b13          	li	s6,-104
40022e7c:	db5ff06f          	j	40022c30 <tcp_in+0xa4>
		opt = options[0];
40022e80:	00074683          	lbu	a3,0(a4)
		if (opt == NET_TCP_END_OPT) {
40022e84:	ec0686e3          	beqz	a3,40022d50 <tcp_in+0x1c4>
		} else if (opt == NET_TCP_NOP_OPT) {
40022e88:	0ea68e63          	beq	a3,a0,40022f84 <tcp_in+0x3f8>
			if (len < 2) { /* Only END and NOP can have length 1 */
40022e8c:	08a59863          	bne	a1,a0,40022f1c <tcp_in+0x390>
				NET_ERR("Illegal option %d with length %zd",
40022e90:	40044537          	lui	a0,0x40044
40022e94:	7a052703          	lw	a4,1952(a0) # 400447a0 <log_dynamic_net_tcp>
40022e98:	00777713          	andi	a4,a4,7
40022e9c:	04070263          	beqz	a4,40022ee0 <tcp_in+0x354>
40022ea0:	00010a13          	mv	s4,sp
40022ea4:	fe010113          	addi	sp,sp,-32
40022ea8:	00010613          	mv	a2,sp
40022eac:	40035737          	lui	a4,0x40035
40022eb0:	3fc70713          	addi	a4,a4,1020 # 400353fc <CSWTCH.16862+0x204>
40022eb4:	00e62a23          	sw	a4,20(a2)
40022eb8:	00b62e23          	sw	a1,28(a2)
40022ebc:	00400713          	li	a4,4
40022ec0:	000025b7          	lui	a1,0x2
40022ec4:	00d62c23          	sw	a3,24(a2)
40022ec8:	00e62823          	sw	a4,16(a2)
40022ecc:	04058593          	addi	a1,a1,64 # 2040 <CONFIG_SRAM_SIZE+0x40>
40022ed0:	01060613          	addi	a2,a2,16
40022ed4:	7a050513          	addi	a0,a0,1952
40022ed8:	e50fd0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
40022edc:	000a0113          	mv	sp,s4
		NET_WARN("Invalid TCP options");
40022ee0:	40044537          	lui	a0,0x40044
40022ee4:	7a052703          	lw	a4,1952(a0) # 400447a0 <log_dynamic_net_tcp>
40022ee8:	00677713          	andi	a4,a4,6
40022eec:	dc0704e3          	beqz	a4,40022cb4 <tcp_in+0x128>
40022ef0:	40035737          	lui	a4,0x40035
40022ef4:	42070713          	addi	a4,a4,1056 # 40035420 <CSWTCH.16862+0x228>
40022ef8:	000015b7          	lui	a1,0x1
40022efc:	f8e42a23          	sw	a4,-108(s0)
40022f00:	f9040613          	addi	a2,s0,-112
40022f04:	00200713          	li	a4,2
40022f08:	08058593          	addi	a1,a1,128 # 1080 <CONFIG_HEAP_MEM_POOL_SIZE+0x80>
40022f0c:	7a050513          	addi	a0,a0,1952
40022f10:	f8e42823          	sw	a4,-112(s0)
40022f14:	e14fd0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
		tcp_out(conn, RST);
40022f18:	d9dff06f          	j	40022cb4 <tcp_in+0x128>
			opt_len = options[1];
40022f1c:	00174603          	lbu	a2,1(a4)
		if (opt_len < 2 || opt_len > len) {
40022f20:	fcc570e3          	bgeu	a0,a2,40022ee0 <tcp_in+0x354>
40022f24:	fac5cee3          	blt	a1,a2,40022ee0 <tcp_in+0x354>
		switch (opt) {
40022f28:	00668a63          	beq	a3,t1,40022f3c <tcp_in+0x3b0>
40022f2c:	05068263          	beq	a3,a6,40022f70 <tcp_in+0x3e4>
	for ( ; options && len >= 1; options += opt_len, len -= opt_len) {
40022f30:	00c70733          	add	a4,a4,a2
40022f34:	40c585b3          	sub	a1,a1,a2
40022f38:	e15ff06f          	j	40022d4c <tcp_in+0x1c0>
			if (opt_len != 4) {
40022f3c:	fbc612e3          	bne	a2,t3,40022ee0 <tcp_in+0x354>
			recv_options->mss =
40022f40:	00374683          	lbu	a3,3(a4)
40022f44:	00274883          	lbu	a7,2(a4)
40022f48:	00869693          	slli	a3,a3,0x8
40022f4c:	0116e6b3          	or	a3,a3,a7
40022f50:	00869893          	slli	a7,a3,0x8
40022f54:	0086d693          	srli	a3,a3,0x8
40022f58:	00d8e6b3          	or	a3,a7,a3
40022f5c:	08d49223          	sh	a3,132(s1)
			recv_options->mss_found = true;
40022f60:	0884c683          	lbu	a3,136(s1)
40022f64:	0016e693          	ori	a3,a3,1
			recv_options->wnd_found = true;
40022f68:	08d48423          	sb	a3,136(s1)
			break;
40022f6c:	fc5ff06f          	j	40022f30 <tcp_in+0x3a4>
			if (opt_len != 3) {
40022f70:	f70618e3          	bne	a2,a6,40022ee0 <tcp_in+0x354>
			recv_options->wnd_found = true;
40022f74:	0884c683          	lbu	a3,136(s1)
			recv_options->window = opt;
40022f78:	09049323          	sh	a6,134(s1)
			recv_options->wnd_found = true;
40022f7c:	0026e693          	ori	a3,a3,2
40022f80:	fe9ff06f          	j	40022f68 <tcp_in+0x3dc>
			opt_len = 1;
40022f84:	00100613          	li	a2,1
40022f88:	fa9ff06f          	j	40022f30 <tcp_in+0x3a4>
		if (conn->send_win > conn->send_win_max) {
40022f8c:	00fc4703          	lbu	a4,15(s8)
40022f90:	00ec4683          	lbu	a3,14(s8)
40022f94:	2344d603          	lhu	a2,564(s1)
40022f98:	00871713          	slli	a4,a4,0x8
40022f9c:	00d76733          	or	a4,a4,a3
40022fa0:	00871693          	slli	a3,a4,0x8
40022fa4:	00875713          	srli	a4,a4,0x8
40022fa8:	00e6e733          	or	a4,a3,a4
40022fac:	00070693          	mv	a3,a4
40022fb0:	01071713          	slli	a4,a4,0x10
40022fb4:	01075713          	srli	a4,a4,0x10
40022fb8:	00e67463          	bgeu	a2,a4,40022fc0 <tcp_in+0x434>
40022fbc:	00060693          	mv	a3,a2
40022fc0:	01069713          	slli	a4,a3,0x10
			if (!k_work_delayable_is_pending(&conn->persist_timer)) {
40022fc4:	15048a13          	addi	s4,s1,336
40022fc8:	01075713          	srli	a4,a4,0x10
40022fcc:	22d49b23          	sh	a3,566(s1)
	return k_work_delayable_busy_get(dwork) != 0;
40022fd0:	000a0513          	mv	a0,s4
		if (conn->send_win == 0) {
40022fd4:	06071063          	bnez	a4,40023034 <tcp_in+0x4a8>
40022fd8:	0700d0ef          	jal	ra,40030048 <k_work_delayable_busy_get>
			if (!k_work_delayable_is_pending(&conn->persist_timer)) {
40022fdc:	02051c63          	bnez	a0,40023014 <tcp_in+0x488>
					K_MSEC(TCP_RTO_MS));
40022fe0:	2384d503          	lhu	a0,568(s1)
40022fe4:	00a00613          	li	a2,10
40022fe8:	00000693          	li	a3,0
				conn->zwp_retries = 0;
40022fec:	22048e23          	sb	zero,572(s1)
40022ff0:	00950513          	addi	a0,a0,9
40022ff4:	00000593          	li	a1,0
40022ff8:	ac0dd0ef          	jal	ra,400002b8 <__udivdi3>
40022ffc:	00050613          	mv	a2,a0
				(void)k_work_reschedule_for_queue(
40023000:	4003a537          	lui	a0,0x4003a
40023004:	00058693          	mv	a3,a1
40023008:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
4002300c:	000a0593          	mv	a1,s4
40023010:	0b40d0ef          	jal	ra,400300c4 <k_work_reschedule_for_queue>
	bool window_full = (conn->send_data_total >= conn->send_win);
40023014:	2364d703          	lhu	a4,566(s1)
		if (tcp_window_full(conn)) {
40023018:	2104a683          	lw	a3,528(s1)
				k_sem_give(&conn->tx_sem);
4002301c:	05448513          	addi	a0,s1,84
		if (tcp_window_full(conn)) {
40023020:	00e6ee63          	bltu	a3,a4,4002303c <tcp_in+0x4b0>
40023024:	00000593          	li	a1,0
40023028:	00000613          	li	a2,0
4002302c:	17d0c0ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
40023030:	bf9ff06f          	j	40022c28 <tcp_in+0x9c>
			(void)k_work_cancel_delayable(&conn->persist_timer);
40023034:	1380d0ef          	jal	ra,4003016c <k_work_cancel_delayable>
40023038:	fddff06f          	j	40023014 <tcp_in+0x488>
	z_impl_k_sem_give(sem);
4002303c:	0fd0c0ef          	jal	ra,4002f938 <z_impl_k_sem_give>
}
40023040:	be9ff06f          	j	40022c28 <tcp_in+0x9c>
		if (FL(&fl, ==, SYN)) {
40023044:	0ff9fa93          	zext.b	s5,s3
40023048:	0e0a8263          	beqz	s5,4002312c <tcp_in+0x5a0>
4002304c:	40033537          	lui	a0,0x40033
40023050:	1e850513          	addi	a0,a0,488 # 400331e8 <severity_lvls+0xf0>
40023054:	b81e90ef          	jal	ra,4000cbd4 <strlen>
40023058:	00200713          	li	a4,2
4002305c:	0cea9863          	bne	s5,a4,4002312c <tcp_in+0x5a0>
			conn->send_options.mss_found = true;
40023060:	08e4c703          	lbu	a4,142(s1)
			conn_ack(conn, th_seq(th) + 1); /* capture peer's isn */
40023064:	00010637          	lui	a2,0x10
40023068:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
			conn->send_options.mss_found = true;
4002306c:	00176713          	ori	a4,a4,1
40023070:	08e48723          	sb	a4,142(s1)
			conn_ack(conn, th_seq(th) + 1); /* capture peer's isn */
40023074:	005c4683          	lbu	a3,5(s8)
40023078:	004c4703          	lbu	a4,4(s8)
4002307c:	007c4783          	lbu	a5,7(s8)
40023080:	00869693          	slli	a3,a3,0x8
40023084:	00e6e6b3          	or	a3,a3,a4
40023088:	006c4703          	lbu	a4,6(s8)
4002308c:	01879793          	slli	a5,a5,0x18
			tcp_out(conn, SYN | ACK);
40023090:	01200593          	li	a1,18
			conn_ack(conn, th_seq(th) + 1); /* capture peer's isn */
40023094:	01071713          	slli	a4,a4,0x10
40023098:	00d76733          	or	a4,a4,a3
4002309c:	00e7e6b3          	or	a3,a5,a4
400230a0:	01871713          	slli	a4,a4,0x18
400230a4:	0187d793          	srli	a5,a5,0x18
400230a8:	00e7e7b3          	or	a5,a5,a4
400230ac:	0086d713          	srli	a4,a3,0x8
400230b0:	00c77733          	and	a4,a4,a2
400230b4:	00e7e7b3          	or	a5,a5,a4
400230b8:	00869693          	slli	a3,a3,0x8
400230bc:	00ff0737          	lui	a4,0xff0
400230c0:	00e6f6b3          	and	a3,a3,a4
400230c4:	22c4a703          	lw	a4,556(s1)
400230c8:	00d7e7b3          	or	a5,a5,a3
			tcp_out(conn, SYN | ACK);
400230cc:	00048513          	mv	a0,s1
			conn_ack(conn, th_seq(th) + 1); /* capture peer's isn */
400230d0:	00170713          	addi	a4,a4,1 # ff0001 <__rom_region_size+0xfb7045>
400230d4:	00e787b3          	add	a5,a5,a4
400230d8:	22f4a623          	sw	a5,556(s1)
			tcp_out(conn, SYN | ACK);
400230dc:	c19fe0ef          	jal	ra,40021cf4 <tcp_out>
			conn->send_options.mss_found = false;
400230e0:	08e4c783          	lbu	a5,142(s1)
			k_work_reschedule_for_queue(&tcp_work_q,
400230e4:	4003a537          	lui	a0,0x4003a
400230e8:	06400613          	li	a2,100
			conn->send_options.mss_found = false;
400230ec:	ffe7f793          	andi	a5,a5,-2
400230f0:	08f48723          	sb	a5,142(s1)
			conn_seq(conn, + 1);
400230f4:	2284a783          	lw	a5,552(s1)
			k_work_reschedule_for_queue(&tcp_work_q,
400230f8:	00000693          	li	a3,0
400230fc:	1b048593          	addi	a1,s1,432
			conn_seq(conn, + 1);
40023100:	00178793          	addi	a5,a5,1
40023104:	22f4a423          	sw	a5,552(s1)
			k_work_reschedule_for_queue(&tcp_work_q,
40023108:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
		if (FL(&fl, ==, SYN)) {
4002310c:	00000993          	li	s3,0
			k_work_reschedule_for_queue(&tcp_work_q,
40023110:	7b50c0ef          	jal	ra,400300c4 <k_work_reschedule_for_queue>
	if (pkt) {
40023114:	00090663          	beqz	s2,40023120 <tcp_in+0x594>
			net_pkt_unref(pkt);
40023118:	00090513          	mv	a0,s2
4002311c:	f00f40ef          	jal	ra,4001781c <net_pkt_unref>
			next = TCP_SYN_RECEIVED;
40023120:	00300a93          	li	s5,3
			verdict = NET_OK;
40023124:	00000a13          	li	s4,0
40023128:	0400006f          	j	40023168 <tcp_in+0x5dc>
			conn->send_options.mss_found = true;
4002312c:	08e4c783          	lbu	a5,142(s1)
			tcp_out(conn, SYN);
40023130:	00200593          	li	a1,2
40023134:	00048513          	mv	a0,s1
			conn->send_options.mss_found = true;
40023138:	0017e793          	ori	a5,a5,1
4002313c:	08f48723          	sb	a5,142(s1)
			tcp_out(conn, SYN);
40023140:	bb5fe0ef          	jal	ra,40021cf4 <tcp_out>
			conn->send_options.mss_found = false;
40023144:	08e4c783          	lbu	a5,142(s1)
			next = TCP_SYN_SENT;
40023148:	00200a93          	li	s5,2
			conn->send_options.mss_found = false;
4002314c:	ffe7f793          	andi	a5,a5,-2
40023150:	08f48723          	sb	a5,142(s1)
			conn_seq(conn, + 1);
40023154:	2284a783          	lw	a5,552(s1)
40023158:	00178793          	addi	a5,a5,1
4002315c:	22f4a423          	sw	a5,552(s1)
	if (pkt) {
40023160:	00090463          	beqz	s2,40023168 <tcp_in+0x5dc>
40023164:	3400106f          	j	400244a4 <tcp_in+0x1918>
		conn_state(conn, next);
40023168:	2354a023          	sw	s5,544(s1)
		if (connection_ok) {
4002316c:	320c9463          	bnez	s9,40023494 <tcp_in+0x908>
	len = pkt ? tcp_data_len(pkt) : 0;
40023170:	00000913          	li	s2,0
40023174:	00000c13          	li	s8,0
40023178:	00000a93          	li	s5,0
	switch (conn->state) {
4002317c:	2204a703          	lw	a4,544(s1)
	len = pkt ? tcp_data_len(pkt) : 0;
40023180:	f9542c23          	sw	s5,-104(s0)
	switch (conn->state) {
40023184:	00a00793          	li	a5,10
40023188:	fff70713          	addi	a4,a4,-1
4002318c:	00e7f463          	bgeu	a5,a4,40023194 <tcp_in+0x608>
40023190:	0b40106f          	j	40024244 <tcp_in+0x16b8>
40023194:	f7842783          	lw	a5,-136(s0)
40023198:	00271713          	slli	a4,a4,0x2
4002319c:	00f70733          	add	a4,a4,a5
400231a0:	00072703          	lw	a4,0(a4)
400231a4:	00070067          	jr	a4
		if (FL(&fl, &, ACK, th_ack(th) == conn->seq &&
400231a8:	0ff9f993          	zext.b	s3,s3
400231ac:	00099463          	bnez	s3,400231b4 <tcp_in+0x628>
400231b0:	0940106f          	j	40024244 <tcp_in+0x16b8>
400231b4:	40035537          	lui	a0,0x40035
400231b8:	43450513          	addi	a0,a0,1076 # 40035434 <CSWTCH.16862+0x23c>
400231bc:	a19e90ef          	jal	ra,4000cbd4 <strlen>
400231c0:	0c050063          	beqz	a0,40023280 <tcp_in+0x6f4>
400231c4:	009c4703          	lbu	a4,9(s8)
400231c8:	008c4683          	lbu	a3,8(s8)
400231cc:	000105b7          	lui	a1,0x10
400231d0:	00871713          	slli	a4,a4,0x8
400231d4:	00d76733          	or	a4,a4,a3
400231d8:	00ac4683          	lbu	a3,10(s8)
400231dc:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x43f8>
400231e0:	00ff0537          	lui	a0,0xff0
400231e4:	01069693          	slli	a3,a3,0x10
400231e8:	00e6e6b3          	or	a3,a3,a4
400231ec:	00bc4703          	lbu	a4,11(s8)
400231f0:	01871713          	slli	a4,a4,0x18
400231f4:	00d76633          	or	a2,a4,a3
400231f8:	01869693          	slli	a3,a3,0x18
400231fc:	01875713          	srli	a4,a4,0x18
40023200:	00d76733          	or	a4,a4,a3
40023204:	00865693          	srli	a3,a2,0x8
40023208:	00b6f6b3          	and	a3,a3,a1
4002320c:	00d76733          	or	a4,a4,a3
40023210:	00861613          	slli	a2,a2,0x8
40023214:	2284a683          	lw	a3,552(s1)
40023218:	00a67633          	and	a2,a2,a0
4002321c:	00c76733          	or	a4,a4,a2
40023220:	00d70463          	beq	a4,a3,40023228 <tcp_in+0x69c>
40023224:	0200106f          	j	40024244 <tcp_in+0x16b8>
40023228:	005c4683          	lbu	a3,5(s8)
4002322c:	004c4703          	lbu	a4,4(s8)
40023230:	007c4783          	lbu	a5,7(s8)
40023234:	00869693          	slli	a3,a3,0x8
40023238:	00e6e6b3          	or	a3,a3,a4
4002323c:	006c4703          	lbu	a4,6(s8)
40023240:	01879793          	slli	a5,a5,0x18
40023244:	01071713          	slli	a4,a4,0x10
40023248:	00d76733          	or	a4,a4,a3
4002324c:	00e7e6b3          	or	a3,a5,a4
40023250:	01871713          	slli	a4,a4,0x18
40023254:	0187d793          	srli	a5,a5,0x18
40023258:	00e7e7b3          	or	a5,a5,a4
4002325c:	0086d713          	srli	a4,a3,0x8
40023260:	00b77733          	and	a4,a4,a1
40023264:	00e7e7b3          	or	a5,a5,a4
40023268:	00869693          	slli	a3,a3,0x8
4002326c:	22c4a703          	lw	a4,556(s1)
40023270:	00a6f6b3          	and	a3,a3,a0
40023274:	00d7e7b3          	or	a5,a5,a3
40023278:	00e78463          	beq	a5,a4,40023280 <tcp_in+0x6f4>
4002327c:	7c90006f          	j	40024244 <tcp_in+0x16b8>
40023280:	0109f793          	andi	a5,s3,16
40023284:	00079463          	bnez	a5,4002328c <tcp_in+0x700>
40023288:	7bd0006f          	j	40024244 <tcp_in+0x16b8>
			k_work_cancel_delayable(&conn->establish_timer);
4002328c:	1b048513          	addi	a0,s1,432
40023290:	6dd0c0ef          	jal	ra,4003016c <k_work_cancel_delayable>
			tcp_send_timer_cancel(conn);
40023294:	00048513          	mv	a0,s1
40023298:	88dfd0ef          	jal	ra,40020b24 <tcp_send_timer_cancel>
	int ref_count = atomic_inc(&conn->ref_count) + 1;
4002329c:	21c48513          	addi	a0,s1,540
400232a0:	bd1fd0ef          	jal	ra,40020e70 <atomic_inc.isra.0>
			net_context_set_state(conn->context,
400232a4:	0044a703          	lw	a4,4(s1)
		if (FL(&fl, &, ACK, th_ack(th) == conn->seq &&
400232a8:	0ef9f993          	andi	s3,s3,239
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
400232ac:	07475783          	lhu	a5,116(a4)
400232b0:	ff97f793          	andi	a5,a5,-7
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
400232b4:	0047e793          	ori	a5,a5,4
400232b8:	06f71a23          	sh	a5,116(a4)
			if (conn->accepted_conn) {
400232bc:	0204a783          	lw	a5,32(s1)
400232c0:	02078463          	beqz	a5,400232e8 <tcp_in+0x75c>
				if (conn->accepted_conn->accept_cb) {
400232c4:	0207a803          	lw	a6,32(a5)
400232c8:	00080e63          	beqz	a6,400232e4 <tcp_in+0x758>
						&conn->accepted_conn->context->remote,
400232cc:	0047a703          	lw	a4,4(a5)
					conn->accepted_conn->accept_cb(
400232d0:	0044a503          	lw	a0,4(s1)
400232d4:	00000693          	li	a3,0
400232d8:	01800613          	li	a2,24
400232dc:	02c70593          	addi	a1,a4,44
400232e0:	000800e7          	jalr	a6
				conn->accepted_conn = NULL;
400232e4:	0204a023          	sw	zero,32(s1)
			if (len) {
400232e8:	000a9463          	bnez	s5,400232f0 <tcp_in+0x764>
400232ec:	1400106f          	j	4002442c <tcp_in+0x18a0>
				verdict = tcp_data_get(conn, pkt, &len);
400232f0:	00090593          	mv	a1,s2
400232f4:	f9840613          	addi	a2,s0,-104
400232f8:	00048513          	mv	a0,s1
400232fc:	bdcff0ef          	jal	ra,400226d8 <tcp_data_get>
40023300:	22c4a783          	lw	a5,556(s1)
40023304:	f9842703          	lw	a4,-104(s0)
40023308:	00050a13          	mv	s4,a0
				tcp_out(conn, ACK);
4002330c:	01000593          	li	a1,16
				conn_ack(conn, + len);
40023310:	00e787b3          	add	a5,a5,a4
40023314:	22f4a623          	sw	a5,556(s1)
				tcp_out(conn, ACK);
40023318:	00048513          	mv	a0,s1
4002331c:	9d9fe0ef          	jal	ra,40021cf4 <tcp_out>
			next = TCP_ESTABLISHED;
40023320:	00400a93          	li	s5,4
40023324:	e45ff06f          	j	40023168 <tcp_in+0x5dc>
		if (FL(&fl, &, SYN | ACK, th && th_ack(th) == conn->seq)) {
40023328:	0ff9f993          	zext.b	s3,s3
4002332c:	00099463          	bnez	s3,40023334 <tcp_in+0x7a8>
40023330:	7150006f          	j	40024244 <tcp_in+0x16b8>
40023334:	40035537          	lui	a0,0x40035
40023338:	46850513          	addi	a0,a0,1128 # 40035468 <CSWTCH.16862+0x270>
4002333c:	899e90ef          	jal	ra,4000cbd4 <strlen>
40023340:	06050663          	beqz	a0,400233ac <tcp_in+0x820>
40023344:	000c1463          	bnez	s8,4002334c <tcp_in+0x7c0>
40023348:	6fd0006f          	j	40024244 <tcp_in+0x16b8>
4002334c:	009c4703          	lbu	a4,9(s8)
40023350:	008c4683          	lbu	a3,8(s8)
40023354:	000105b7          	lui	a1,0x10
40023358:	00871713          	slli	a4,a4,0x8
4002335c:	00d76733          	or	a4,a4,a3
40023360:	00ac4683          	lbu	a3,10(s8)
40023364:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x43f8>
40023368:	01069693          	slli	a3,a3,0x10
4002336c:	00e6e6b3          	or	a3,a3,a4
40023370:	00bc4703          	lbu	a4,11(s8)
40023374:	01871713          	slli	a4,a4,0x18
40023378:	00d76633          	or	a2,a4,a3
4002337c:	01869693          	slli	a3,a3,0x18
40023380:	01875713          	srli	a4,a4,0x18
40023384:	00d76733          	or	a4,a4,a3
40023388:	00865693          	srli	a3,a2,0x8
4002338c:	00b6f6b3          	and	a3,a3,a1
40023390:	00d76733          	or	a4,a4,a3
40023394:	00861613          	slli	a2,a2,0x8
40023398:	00ff06b7          	lui	a3,0xff0
4002339c:	00d67633          	and	a2,a2,a3
400233a0:	2284a683          	lw	a3,552(s1)
400233a4:	00c76733          	or	a4,a4,a2
400233a8:	68d71ee3          	bne	a4,a3,40024244 <tcp_in+0x16b8>
400233ac:	0129f713          	andi	a4,s3,18
400233b0:	68070ae3          	beqz	a4,40024244 <tcp_in+0x16b8>
			tcp_send_timer_cancel(conn);
400233b4:	00048513          	mv	a0,s1
400233b8:	f6cfd0ef          	jal	ra,40020b24 <tcp_send_timer_cancel>
			conn_ack(conn, th_seq(th) + 1);
400233bc:	005c4683          	lbu	a3,5(s8)
400233c0:	004c4703          	lbu	a4,4(s8)
400233c4:	007c4783          	lbu	a5,7(s8)
400233c8:	00869693          	slli	a3,a3,0x8
400233cc:	00e6e6b3          	or	a3,a3,a4
400233d0:	006c4703          	lbu	a4,6(s8)
400233d4:	01879793          	slli	a5,a5,0x18
400233d8:	00010637          	lui	a2,0x10
400233dc:	01071713          	slli	a4,a4,0x10
400233e0:	00d76733          	or	a4,a4,a3
400233e4:	00e7e6b3          	or	a3,a5,a4
400233e8:	01871713          	slli	a4,a4,0x18
400233ec:	0187d793          	srli	a5,a5,0x18
400233f0:	00e7e7b3          	or	a5,a5,a4
400233f4:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
400233f8:	0086d713          	srli	a4,a3,0x8
400233fc:	00c77733          	and	a4,a4,a2
40023400:	00e7e7b3          	or	a5,a5,a4
40023404:	00869693          	slli	a3,a3,0x8
40023408:	00ff0737          	lui	a4,0xff0
4002340c:	00e6f6b3          	and	a3,a3,a4
40023410:	22c4a703          	lw	a4,556(s1)
40023414:	00d7e7b3          	or	a5,a5,a3
		if (FL(&fl, &, SYN | ACK, th && th_ack(th) == conn->seq)) {
40023418:	0ed9f993          	andi	s3,s3,237
			conn_ack(conn, th_seq(th) + 1);
4002341c:	00170713          	addi	a4,a4,1 # ff0001 <__rom_region_size+0xfb7045>
40023420:	00e787b3          	add	a5,a5,a4
40023424:	22f4a623          	sw	a5,556(s1)
				verdict = NET_OK;
40023428:	00000a13          	li	s4,0
			if (len) {
4002342c:	020a8863          	beqz	s5,4002345c <tcp_in+0x8d0>
				verdict = tcp_data_get(conn, pkt, &len);
40023430:	f9840613          	addi	a2,s0,-104
40023434:	00090593          	mv	a1,s2
40023438:	00048513          	mv	a0,s1
4002343c:	a9cff0ef          	jal	ra,400226d8 <tcp_data_get>
40023440:	00050a13          	mv	s4,a0
				if (verdict == NET_OK) {
40023444:	00051463          	bnez	a0,4002344c <tcp_in+0x8c0>
					pkt = NULL;
40023448:	00000913          	li	s2,0
				conn_ack(conn, + len);
4002344c:	22c4a783          	lw	a5,556(s1)
40023450:	f9842703          	lw	a4,-104(s0)
40023454:	00e787b3          	add	a5,a5,a4
40023458:	22f4a623          	sw	a5,556(s1)
	int ref_count = atomic_inc(&conn->ref_count) + 1;
4002345c:	21c48513          	addi	a0,s1,540
40023460:	a11fd0ef          	jal	ra,40020e70 <atomic_inc.isra.0>
			net_context_set_state(conn->context,
40023464:	0044a703          	lw	a4,4(s1)
			tcp_out(conn, ACK);
40023468:	01000593          	li	a1,16
4002346c:	00048513          	mv	a0,s1
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
40023470:	07475783          	lhu	a5,116(a4)
40023474:	ff97f793          	andi	a5,a5,-7
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
40023478:	0047e793          	ori	a5,a5,4
4002347c:	06f71a23          	sh	a5,116(a4)
40023480:	875fe0ef          	jal	ra,40021cf4 <tcp_out>
	if (pkt) {
40023484:	00090463          	beqz	s2,4002348c <tcp_in+0x900>
40023488:	0140106f          	j	4002449c <tcp_in+0x1910>
		conn_state(conn, next);
4002348c:	00400793          	li	a5,4
40023490:	22f4a023          	sw	a5,544(s1)
			conn->in_connect = false;
40023494:	23d4c783          	lbu	a5,573(s1)
40023498:	ffd7f793          	andi	a5,a5,-3
4002349c:	22f48ea3          	sb	a5,573(s1)
			if (conn->connect_cb) {
400234a0:	0244a783          	lw	a5,36(s1)
400234a4:	00078c63          	beqz	a5,400234bc <tcp_in+0x930>
				conn->connect_cb(conn->context, 0, conn->context->user_data);
400234a8:	0044a503          	lw	a0,4(s1)
400234ac:	00000593          	li	a1,0
400234b0:	00452603          	lw	a2,4(a0)
400234b4:	000780e7          	jalr	a5
				conn->connect_cb = NULL;
400234b8:	0204a223          	sw	zero,36(s1)
	z_impl_k_sem_give(sem);
400234bc:	03c48513          	addi	a0,s1,60
400234c0:	4780c0ef          	jal	ra,4002f938 <z_impl_k_sem_give>
}
400234c4:	00100c93          	li	s9,1
400234c8:	ca9ff06f          	j	40023170 <tcp_in+0x5e4>
		if (th && FL(&fl, ==, (FIN | ACK), th_seq(th) == conn->ack)) {
400234cc:	560c0ce3          	beqz	s8,40024244 <tcp_in+0x16b8>
400234d0:	0ff9fb93          	zext.b	s7,s3
400234d4:	260b8e63          	beqz	s7,40023750 <tcp_in+0xbc4>
400234d8:	40035db7          	lui	s11,0x40035
400234dc:	488d8513          	addi	a0,s11,1160 # 40035488 <CSWTCH.16862+0x290>
400234e0:	ef4e90ef          	jal	ra,4000cbd4 <strlen>
400234e4:	06050263          	beqz	a0,40023548 <tcp_in+0x9bc>
400234e8:	005c4703          	lbu	a4,5(s8)
400234ec:	004c4683          	lbu	a3,4(s8)
400234f0:	000105b7          	lui	a1,0x10
400234f4:	00871713          	slli	a4,a4,0x8
400234f8:	00d76733          	or	a4,a4,a3
400234fc:	006c4683          	lbu	a3,6(s8)
40023500:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x43f8>
40023504:	01069693          	slli	a3,a3,0x10
40023508:	00e6e6b3          	or	a3,a3,a4
4002350c:	007c4703          	lbu	a4,7(s8)
40023510:	01871713          	slli	a4,a4,0x18
40023514:	00d76633          	or	a2,a4,a3
40023518:	01869693          	slli	a3,a3,0x18
4002351c:	01875713          	srli	a4,a4,0x18
40023520:	00d76733          	or	a4,a4,a3
40023524:	00865693          	srli	a3,a2,0x8
40023528:	00b6f6b3          	and	a3,a3,a1
4002352c:	00d76733          	or	a4,a4,a3
40023530:	00861613          	slli	a2,a2,0x8
40023534:	00ff06b7          	lui	a3,0xff0
40023538:	00d67633          	and	a2,a2,a3
4002353c:	22c4a683          	lw	a3,556(s1)
40023540:	00c76733          	or	a4,a4,a2
40023544:	0ad71263          	bne	a4,a3,400235e8 <tcp_in+0xa5c>
40023548:	01100713          	li	a4,17
4002354c:	08eb9e63          	bne	s7,a4,400235e8 <tcp_in+0xa5c>
			if (net_tcp_seq_cmp(th_ack(th), conn->seq) > 0) {
40023550:	009c4683          	lbu	a3,9(s8)
40023554:	008c4703          	lbu	a4,8(s8)
40023558:	00bc4783          	lbu	a5,11(s8)
4002355c:	00869693          	slli	a3,a3,0x8
40023560:	00e6e6b3          	or	a3,a3,a4
40023564:	00ac4703          	lbu	a4,10(s8)
40023568:	01879793          	slli	a5,a5,0x18
4002356c:	00010637          	lui	a2,0x10
40023570:	01071713          	slli	a4,a4,0x10
40023574:	00d76733          	or	a4,a4,a3
40023578:	00e7e6b3          	or	a3,a5,a4
4002357c:	01871713          	slli	a4,a4,0x18
40023580:	0187d793          	srli	a5,a5,0x18
40023584:	00e7e7b3          	or	a5,a5,a4
40023588:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
4002358c:	0086d713          	srli	a4,a3,0x8
40023590:	00c77733          	and	a4,a4,a2
40023594:	00e7e7b3          	or	a5,a5,a4
40023598:	00869693          	slli	a3,a3,0x8
4002359c:	00ff0737          	lui	a4,0xff0
400235a0:	00e6f6b3          	and	a3,a3,a4
	return (int32_t)(seq1 - seq2);
400235a4:	2284a703          	lw	a4,552(s1)
400235a8:	00d7e7b3          	or	a5,a5,a3
		if (th && FL(&fl, ==, (FIN | ACK), th_seq(th) == conn->ack)) {
400235ac:	00000993          	li	s3,0
400235b0:	40e78733          	sub	a4,a5,a4
			if (net_tcp_seq_cmp(th_ack(th), conn->seq) > 0) {
400235b4:	00e05463          	blez	a4,400235bc <tcp_in+0xa30>
				conn_seq(conn, + len_acked);
400235b8:	22f4a423          	sw	a5,552(s1)
			conn_ack(conn, + 1);
400235bc:	22c4a783          	lw	a5,556(s1)
			tcp_out(conn, FIN | ACK);
400235c0:	01100593          	li	a1,17
400235c4:	00048513          	mv	a0,s1
			conn_ack(conn, + 1);
400235c8:	00178793          	addi	a5,a5,1
400235cc:	22f4a623          	sw	a5,556(s1)
			tcp_out(conn, FIN | ACK);
400235d0:	f24fe0ef          	jal	ra,40021cf4 <tcp_out>
	if (pkt) {
400235d4:	00090663          	beqz	s2,400235e0 <tcp_in+0xa54>
			net_pkt_unref(pkt);
400235d8:	00090513          	mv	a0,s2
400235dc:	a40f40ef          	jal	ra,4001781c <net_pkt_unref>
			next = TCP_LAST_ACK;
400235e0:	00900a93          	li	s5,9
400235e4:	b41ff06f          	j	40023124 <tcp_in+0x598>
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
400235e8:	488d8513          	addi	a0,s11,1160
400235ec:	de8e90ef          	jal	ra,4000cbd4 <strlen>
400235f0:	06050263          	beqz	a0,40023654 <tcp_in+0xac8>
400235f4:	005c4703          	lbu	a4,5(s8)
400235f8:	004c4683          	lbu	a3,4(s8)
400235fc:	000105b7          	lui	a1,0x10
40023600:	00871713          	slli	a4,a4,0x8
40023604:	00d76733          	or	a4,a4,a3
40023608:	006c4683          	lbu	a3,6(s8)
4002360c:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x43f8>
40023610:	01069693          	slli	a3,a3,0x10
40023614:	00e6e6b3          	or	a3,a3,a4
40023618:	007c4703          	lbu	a4,7(s8)
4002361c:	01871713          	slli	a4,a4,0x18
40023620:	00d76633          	or	a2,a4,a3
40023624:	01869693          	slli	a3,a3,0x18
40023628:	01875713          	srli	a4,a4,0x18
4002362c:	00d76733          	or	a4,a4,a3
40023630:	00865693          	srli	a3,a2,0x8
40023634:	00b6f6b3          	and	a3,a3,a1
40023638:	00d76733          	or	a4,a4,a3
4002363c:	00861613          	slli	a2,a2,0x8
40023640:	00ff06b7          	lui	a3,0xff0
40023644:	00d67633          	and	a2,a2,a3
40023648:	22c4a683          	lw	a3,556(s1)
4002364c:	00c76733          	or	a4,a4,a2
40023650:	02d71e63          	bne	a4,a3,4002368c <tcp_in+0xb00>
40023654:	00100713          	li	a4,1
40023658:	02eb9a63          	bne	s7,a4,4002368c <tcp_in+0xb00>
			conn_ack(conn, + 1);
4002365c:	22c4a783          	lw	a5,556(s1)
			tcp_out(conn, ACK);
40023660:	01000593          	li	a1,16
40023664:	00048513          	mv	a0,s1
			conn_ack(conn, + 1);
40023668:	00178793          	addi	a5,a5,1
4002366c:	22f4a623          	sw	a5,556(s1)
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
40023670:	00000993          	li	s3,0
			tcp_out(conn, ACK);
40023674:	e80fe0ef          	jal	ra,40021cf4 <tcp_out>
	if (pkt) {
40023678:	00090663          	beqz	s2,40023684 <tcp_in+0xaf8>
			net_pkt_unref(pkt);
4002367c:	00090513          	mv	a0,s2
40023680:	99cf40ef          	jal	ra,4001781c <net_pkt_unref>
			next = TCP_CLOSE_WAIT;
40023684:	00700a93          	li	s5,7
40023688:	a9dff06f          	j	40023124 <tcp_in+0x598>
		} else if (th && FL(&fl, ==, (FIN | ACK | PSH),
4002368c:	488d8513          	addi	a0,s11,1160
40023690:	d44e90ef          	jal	ra,4000cbd4 <strlen>
40023694:	06050263          	beqz	a0,400236f8 <tcp_in+0xb6c>
40023698:	005c4703          	lbu	a4,5(s8)
4002369c:	004c4683          	lbu	a3,4(s8)
400236a0:	000105b7          	lui	a1,0x10
400236a4:	00871713          	slli	a4,a4,0x8
400236a8:	00d76733          	or	a4,a4,a3
400236ac:	006c4683          	lbu	a3,6(s8)
400236b0:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x43f8>
400236b4:	01069693          	slli	a3,a3,0x10
400236b8:	00e6e6b3          	or	a3,a3,a4
400236bc:	007c4703          	lbu	a4,7(s8)
400236c0:	01871713          	slli	a4,a4,0x18
400236c4:	00d76633          	or	a2,a4,a3
400236c8:	01869693          	slli	a3,a3,0x18
400236cc:	01875713          	srli	a4,a4,0x18
400236d0:	00d76733          	or	a4,a4,a3
400236d4:	00865693          	srli	a3,a2,0x8
400236d8:	00b6f6b3          	and	a3,a3,a1
400236dc:	00d76733          	or	a4,a4,a3
400236e0:	00861613          	slli	a2,a2,0x8
400236e4:	00ff06b7          	lui	a3,0xff0
400236e8:	00d67633          	and	a2,a2,a3
400236ec:	22c4a683          	lw	a3,556(s1)
400236f0:	00c76733          	or	a4,a4,a2
400236f4:	04d71e63          	bne	a4,a3,40023750 <tcp_in+0xbc4>
400236f8:	01900713          	li	a4,25
400236fc:	04eb9a63          	bne	s7,a4,40023750 <tcp_in+0xbc4>
40023700:	00000993          	li	s3,0
				verdict = NET_OK;
40023704:	00000a13          	li	s4,0
			if (len) {
40023708:	020a8063          	beqz	s5,40023728 <tcp_in+0xb9c>
				verdict = tcp_data_get(conn, pkt, &len);
4002370c:	f9840613          	addi	a2,s0,-104
40023710:	00090593          	mv	a1,s2
40023714:	00048513          	mv	a0,s1
40023718:	fc1fe0ef          	jal	ra,400226d8 <tcp_data_get>
4002371c:	00050a13          	mv	s4,a0
				if (verdict == NET_OK) {
40023720:	00051463          	bnez	a0,40023728 <tcp_in+0xb9c>
					pkt = NULL;
40023724:	00000913          	li	s2,0
			conn_ack(conn, + len + 1);
40023728:	f9842703          	lw	a4,-104(s0)
4002372c:	22c4a783          	lw	a5,556(s1)
			tcp_out(conn, FIN | ACK);
40023730:	01100593          	li	a1,17
			conn_ack(conn, + len + 1);
40023734:	00170713          	addi	a4,a4,1 # ff0001 <__rom_region_size+0xfb7045>
40023738:	00e787b3          	add	a5,a5,a4
4002373c:	22f4a623          	sw	a5,556(s1)
			tcp_out(conn, FIN | ACK);
40023740:	00048513          	mv	a0,s1
40023744:	db0fe0ef          	jal	ra,40021cf4 <tcp_out>
			next = TCP_LAST_ACK;
40023748:	00900a93          	li	s5,9
4002374c:	a15ff06f          	j	40023160 <tcp_in+0x5d4>
		if (th && (net_tcp_seq_cmp(th_ack(th), conn->seq) == 0)) {
40023750:	009c4703          	lbu	a4,9(s8)
40023754:	008c4683          	lbu	a3,8(s8)
40023758:	000105b7          	lui	a1,0x10
4002375c:	00871713          	slli	a4,a4,0x8
40023760:	00d76733          	or	a4,a4,a3
40023764:	00ac4683          	lbu	a3,10(s8)
40023768:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x43f8>
4002376c:	01069693          	slli	a3,a3,0x10
40023770:	00e6e6b3          	or	a3,a3,a4
40023774:	00bc4703          	lbu	a4,11(s8)
40023778:	01871713          	slli	a4,a4,0x18
4002377c:	00d76633          	or	a2,a4,a3
40023780:	01869693          	slli	a3,a3,0x18
40023784:	01875713          	srli	a4,a4,0x18
40023788:	00d76733          	or	a4,a4,a3
4002378c:	00865693          	srli	a3,a2,0x8
40023790:	00b6f6b3          	and	a3,a3,a1
40023794:	00d76733          	or	a4,a4,a3
40023798:	00861613          	slli	a2,a2,0x8
4002379c:	00ff06b7          	lui	a3,0xff0
400237a0:	00d67633          	and	a2,a2,a3
400237a4:	2284a683          	lw	a3,552(s1)
400237a8:	00c76733          	or	a4,a4,a2
400237ac:	04d71a63          	bne	a4,a3,40023800 <tcp_in+0xc74>
			if (conn->send_data_total > 0) {
400237b0:	2104a703          	lw	a4,528(s1)
400237b4:	18070863          	beqz	a4,40023944 <tcp_in+0xdb8>
				if (len == 0) {
400237b8:	020a9063          	bnez	s5,400237d8 <tcp_in+0xc4c>
					conn->dup_ack_cnt = MIN(conn->dup_ack_cnt + 1,
400237bc:	23b4c683          	lbu	a3,571(s1)
400237c0:	00300613          	li	a2,3
400237c4:	00068713          	mv	a4,a3
400237c8:	00d67463          	bgeu	a2,a3,400237d0 <tcp_in+0xc44>
400237cc:	00300713          	li	a4,3
400237d0:	00170713          	addi	a4,a4,1
400237d4:	22e48da3          	sb	a4,571(s1)
			if ((conn->data_mode == TCP_DATA_MODE_SEND) &&
400237d8:	2244a703          	lw	a4,548(s1)
400237dc:	02071263          	bnez	a4,40023800 <tcp_in+0xc74>
400237e0:	23b4c683          	lbu	a3,571(s1)
400237e4:	00300713          	li	a4,3
400237e8:	00e69c63          	bne	a3,a4,40023800 <tcp_in+0xc74>
				int temp_unacked_len = conn->unacked_len;
400237ec:	2184ad83          	lw	s11,536(s1)
				(void)tcp_send_data(conn);
400237f0:	00048513          	mv	a0,s1
				conn->unacked_len = 0;
400237f4:	2004ac23          	sw	zero,536(s1)
				(void)tcp_send_data(conn);
400237f8:	f88fe0ef          	jal	ra,40021f80 <tcp_send_data>
				conn->unacked_len = temp_unacked_len;
400237fc:	21b4ac23          	sw	s11,536(s1)
		if (th && (net_tcp_seq_cmp(th_ack(th), conn->seq) > 0)) {
40023800:	009c4683          	lbu	a3,9(s8)
40023804:	008c4703          	lbu	a4,8(s8)
40023808:	00bc4d83          	lbu	s11,11(s8)
4002380c:	00869693          	slli	a3,a3,0x8
40023810:	00e6e6b3          	or	a3,a3,a4
40023814:	00ac4703          	lbu	a4,10(s8)
40023818:	018d9d93          	slli	s11,s11,0x18
4002381c:	00010637          	lui	a2,0x10
40023820:	01071713          	slli	a4,a4,0x10
40023824:	00d76733          	or	a4,a4,a3
40023828:	00ede6b3          	or	a3,s11,a4
4002382c:	01871713          	slli	a4,a4,0x18
40023830:	018ddd93          	srli	s11,s11,0x18
40023834:	00ededb3          	or	s11,s11,a4
40023838:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
4002383c:	0086d713          	srli	a4,a3,0x8
40023840:	00c77733          	and	a4,a4,a2
40023844:	00ededb3          	or	s11,s11,a4
40023848:	00869693          	slli	a3,a3,0x8
4002384c:	00ff0737          	lui	a4,0xff0
40023850:	00e6f6b3          	and	a3,a3,a4
40023854:	00ddedb3          	or	s11,s11,a3
40023858:	2284a683          	lw	a3,552(s1)
4002385c:	40dd85b3          	sub	a1,s11,a3
40023860:	24b05c63          	blez	a1,40023ab8 <tcp_in+0xf2c>
			if ((conn->send_data_total < len_acked) ||
40023864:	2104a603          	lw	a2,528(s1)
40023868:	4003b737          	lui	a4,0x4003b
4002386c:	ed070d13          	addi	s10,a4,-304 # 4003aed0 <net_stats>
40023870:	0cb67e63          	bgeu	a2,a1,4002394c <tcp_in+0xdc0>
				NET_ERR("conn: %p, Invalid len_acked=%u "
40023874:	40044537          	lui	a0,0x40044
40023878:	7a052783          	lw	a5,1952(a0) # 400447a0 <log_dynamic_net_tcp>
4002387c:	0077f793          	andi	a5,a5,7
40023880:	04078663          	beqz	a5,400238cc <tcp_in+0xd40>
40023884:	00010993          	mv	s3,sp
40023888:	fd010113          	addi	sp,sp,-48
4002388c:	2104a683          	lw	a3,528(s1)
40023890:	00010613          	mv	a2,sp
40023894:	400357b7          	lui	a5,0x40035
40023898:	4a078793          	addi	a5,a5,1184 # 400354a0 <CSWTCH.16862+0x2a8>
4002389c:	00f62a23          	sw	a5,20(a2)
400238a0:	00b62e23          	sw	a1,28(a2)
400238a4:	00500793          	li	a5,5
400238a8:	000035b7          	lui	a1,0x3
400238ac:	00962c23          	sw	s1,24(a2)
400238b0:	02d62023          	sw	a3,32(a2)
400238b4:	00f62823          	sw	a5,16(a2)
400238b8:	84058593          	addi	a1,a1,-1984 # 2840 <CONFIG_SRAM_SIZE+0x840>
400238bc:	01060613          	addi	a2,a2,16
400238c0:	7a050513          	addi	a0,a0,1952
400238c4:	c65fc0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
400238c8:	00098113          	mv	sp,s3
	UPDATE_STAT(iface, stats.tcp.seg_drop++);
400238cc:	070d2783          	lw	a5,112(s10)
				net_stats_update_tcp_seg_drop(conn->iface);
400238d0:	0104a683          	lw	a3,16(s1)
				tcp_out(conn, RST);
400238d4:	00400593          	li	a1,4
400238d8:	00178793          	addi	a5,a5,1
400238dc:	06fd2823          	sw	a5,112(s10)
400238e0:	0746a783          	lw	a5,116(a3) # ff0074 <__rom_region_size+0xfb70b8>
400238e4:	00048513          	mv	a0,s1
	if (pkt) {
400238e8:	00000993          	li	s3,0
400238ec:	00178793          	addi	a5,a5,1
400238f0:	06f6aa23          	sw	a5,116(a3)
				tcp_out(conn, RST);
400238f4:	c00fe0ef          	jal	ra,40021cf4 <tcp_out>
				conn_state(conn, TCP_CLOSED);
400238f8:	00b00793          	li	a5,11
400238fc:	22f4a023          	sw	a5,544(s1)
				close_status = -ECONNRESET;
40023900:	f9800b13          	li	s6,-104
	if (pkt) {
40023904:	30091ce3          	bnez	s2,4002441c <tcp_in+0x1890>
	if (conn->context) {
40023908:	0044aa83          	lw	s5,4(s1)
4002390c:	000a8463          	beqz	s5,40023914 <tcp_in+0xd88>
		conn_handler = (struct net_conn *)conn->context->conn_handler;
40023910:	044aaa83          	lw	s5,68(s5)
	k_mutex_unlock(&conn->lock);
40023914:	f7c42503          	lw	a0,-132(s0)
	recv_user_data = conn->recv_user_data;
40023918:	0144ac83          	lw	s9,20(s1)
	while (conn_handler && atomic_get(&conn->ref_count) > 0 &&
4002391c:	21c48c13          	addi	s8,s1,540
	k_mutex_unlock(&conn->lock);
40023920:	a00fd0ef          	jal	ra,40020b20 <k_mutex_unlock.isra.0>
	       (recv_pkt = k_fifo_get(recv_data_fifo, K_NO_WAIT)) != NULL) {
40023924:	06c48b93          	addi	s7,s1,108
		if (net_context_packet_received(conn_handler, recv_pkt, NULL,
40023928:	00200d13          	li	s10,2
	while (conn_handler && atomic_get(&conn->ref_count) > 0 &&
4002392c:	320a92e3          	bnez	s5,40024450 <tcp_in+0x18c4>
	if (do_close) {
40023930:	ce098063          	beqz	s3,40022e10 <tcp_in+0x284>
		tcp_conn_close(conn, close_status);
40023934:	000b0593          	mv	a1,s6
40023938:	00048513          	mv	a0,s1
4002393c:	f84fd0ef          	jal	ra,400210c0 <tcp_conn_close.isra.0>
40023940:	cd0ff06f          	j	40022e10 <tcp_in+0x284>
				conn->dup_ack_cnt = 0;
40023944:	22048da3          	sb	zero,571(s1)
40023948:	e91ff06f          	j	400237d8 <tcp_in+0xc4c>
					(tcp_pkt_pull(conn->send_data,
4002394c:	0084a503          	lw	a0,8(s1)
40023950:	f6d42823          	sw	a3,-144(s0)
40023954:	f6b42a23          	sw	a1,-140(s0)
40023958:	d39fc0ef          	jal	ra,40020690 <tcp_pkt_pull>
			if ((conn->send_data_total < len_acked) ||
4002395c:	f7442583          	lw	a1,-140(s0)
40023960:	f7042683          	lw	a3,-144(s0)
40023964:	f00548e3          	bltz	a0,40023874 <tcp_in+0xce8>
			conn->send_data_total -= len_acked;
40023968:	2104a603          	lw	a2,528(s1)
4002396c:	41b686b3          	sub	a3,a3,s11
			if (conn->unacked_len < len_acked) {
40023970:	2184a803          	lw	a6,536(s1)
			conn->send_data_total -= len_acked;
40023974:	00c68633          	add	a2,a3,a2
			conn->dup_ack_cnt = 0;
40023978:	22048da3          	sb	zero,571(s1)
			conn->send_data_total -= len_acked;
4002397c:	20c4a823          	sw	a2,528(s1)
				conn->unacked_len = 0;
40023980:	00000513          	li	a0,0
			if (conn->unacked_len < len_acked) {
40023984:	00b86463          	bltu	a6,a1,4002398c <tcp_in+0xe00>
				conn->unacked_len -= len_acked;
40023988:	00d80533          	add	a0,a6,a3
	bool window_full = (conn->send_data_total >= conn->send_win);
4002398c:	2364d683          	lhu	a3,566(s1)
40023990:	20a4ac23          	sw	a0,536(s1)
			if (!tcp_window_full(conn)) {
40023994:	00d67a63          	bgeu	a2,a3,400239a8 <tcp_in+0xe1c>
40023998:	f6b42a23          	sw	a1,-140(s0)
	z_impl_k_sem_give(sem);
4002399c:	05448513          	addi	a0,s1,84
400239a0:	7990b0ef          	jal	ra,4002f938 <z_impl_k_sem_give>
400239a4:	f7442583          	lw	a1,-140(s0)
			conn_seq(conn, + len_acked);
400239a8:	2284a683          	lw	a3,552(s1)
			net_stats_update_tcp_seg_recv(conn->iface);
400239ac:	0104a603          	lw	a2,16(s1)
	return z_timeout_remaining(&dwork->timeout);
400239b0:	10048513          	addi	a0,s1,256
			conn_seq(conn, + len_acked);
400239b4:	00b686b3          	add	a3,a3,a1
400239b8:	22d4a423          	sw	a3,552(s1)
	UPDATE_STAT(iface, stats.tcp.recv++);
400239bc:	06c62703          	lw	a4,108(a2)
400239c0:	068d2683          	lw	a3,104(s10)
400239c4:	0f048d93          	addi	s11,s1,240
400239c8:	00170713          	addi	a4,a4,1
400239cc:	00168693          	addi	a3,a3,1
400239d0:	06e62623          	sw	a4,108(a2)
400239d4:	06dd2423          	sw	a3,104(s10)
400239d8:	2b10d0ef          	jal	ra,40031488 <z_timeout_remaining>
			if (!k_work_delayable_remaining_get(
400239dc:	00b56533          	or	a0,a0,a1
400239e0:	060502e3          	beqz	a0,40024244 <tcp_in+0x16b8>
			conn->send_data_retries = 0;
400239e4:	22048d23          	sb	zero,570(s1)
			k_work_cancel_delayable(&conn->send_data_timer);
400239e8:	000d8513          	mv	a0,s11
400239ec:	7800c0ef          	jal	ra,4003016c <k_work_cancel_delayable>
			if (conn->data_mode == TCP_DATA_MODE_RESEND) {
400239f0:	2244a683          	lw	a3,548(s1)
400239f4:	00100713          	li	a4,1
400239f8:	00e69863          	bne	a3,a4,40023a08 <tcp_in+0xe7c>
				conn->unacked_len = 0;
400239fc:	2004ac23          	sw	zero,536(s1)
				tcp_derive_rto(conn);
40023a00:	00048513          	mv	a0,s1
40023a04:	8f5fc0ef          	jal	ra,400202f8 <tcp_derive_rto>
			if (conn->in_close && conn->send_data_total == 0) {
40023a08:	23d4c703          	lbu	a4,573(s1)
			conn->data_mode = TCP_DATA_MODE_SEND;
40023a0c:	2204a223          	sw	zero,548(s1)
				tcp_send_timer_cancel(conn);
40023a10:	00048513          	mv	a0,s1
			if (conn->in_close && conn->send_data_total == 0) {
40023a14:	00477713          	andi	a4,a4,4
40023a18:	02070e63          	beqz	a4,40023a54 <tcp_in+0xec8>
40023a1c:	2104aa03          	lw	s4,528(s1)
40023a20:	020a1a63          	bnez	s4,40023a54 <tcp_in+0xec8>
				tcp_send_timer_cancel(conn);
40023a24:	900fd0ef          	jal	ra,40020b24 <tcp_send_timer_cancel>
				tcp_out(conn, FIN | ACK);
40023a28:	01100593          	li	a1,17
40023a2c:	00048513          	mv	a0,s1
40023a30:	ac4fe0ef          	jal	ra,40021cf4 <tcp_out>
				conn_seq(conn, + 1);
40023a34:	2284a783          	lw	a5,552(s1)
				next = TCP_FIN_WAIT_1;
40023a38:	00500a93          	li	s5,5
				conn_seq(conn, + 1);
40023a3c:	00178793          	addi	a5,a5,1
40023a40:	22f4a423          	sw	a5,552(s1)
	if (pkt) {
40023a44:	f2090263          	beqz	s2,40023168 <tcp_in+0x5dc>
			net_pkt_unref(pkt);
40023a48:	00090513          	mv	a0,s2
40023a4c:	dd1f30ef          	jal	ra,4001781c <net_pkt_unref>
	if (next) {
40023a50:	f18ff06f          	j	40023168 <tcp_in+0x5dc>
	if (conn->data_mode == TCP_DATA_MODE_RESEND) {
40023a54:	e75fe0ef          	jal	ra,400228c8 <tcp_send_queued_data.part.0>
40023a58:	00050993          	mv	s3,a0
			if (ret < 0 && ret != -ENOBUFS) {
40023a5c:	04055063          	bgez	a0,40023a9c <tcp_in+0xf10>
40023a60:	f9700713          	li	a4,-105
40023a64:	02e50c63          	beq	a0,a4,40023a9c <tcp_in+0xf10>
				tcp_out(conn, RST);
40023a68:	00400593          	li	a1,4
40023a6c:	00048513          	mv	a0,s1
40023a70:	a84fe0ef          	jal	ra,40021cf4 <tcp_out>
				conn_state(conn, TCP_CLOSED);
40023a74:	00b00793          	li	a5,11
40023a78:	22f4a023          	sw	a5,544(s1)
	if (pkt) {
40023a7c:	00091a63          	bnez	s2,40023a90 <tcp_in+0xf04>
40023a80:	00098b13          	mv	s6,s3
40023a84:	00000993          	li	s3,0
				verdict = NET_OK;
40023a88:	00000a13          	li	s4,0
40023a8c:	e7dff06f          	j	40023908 <tcp_in+0xd7c>
			net_pkt_unref(pkt);
40023a90:	00090513          	mv	a0,s2
40023a94:	d89f30ef          	jal	ra,4001781c <net_pkt_unref>
	if (next) {
40023a98:	fe9ff06f          	j	40023a80 <tcp_in+0xef4>
	bool window_full = (conn->send_data_total >= conn->send_win);
40023a9c:	2364d683          	lhu	a3,566(s1)
			if (tcp_window_full(conn)) {
40023aa0:	2104a703          	lw	a4,528(s1)
40023aa4:	00d76a63          	bltu	a4,a3,40023ab8 <tcp_in+0xf2c>
	return z_impl_k_sem_take(sem, timeout);
40023aa8:	00000593          	li	a1,0
40023aac:	00000613          	li	a2,0
40023ab0:	05448513          	addi	a0,s1,84
40023ab4:	6f50b0ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
			if (th_seq(th) == conn->ack) {
40023ab8:	005c4683          	lbu	a3,5(s8)
40023abc:	004c4703          	lbu	a4,4(s8)
40023ac0:	007c4983          	lbu	s3,7(s8)
40023ac4:	00869693          	slli	a3,a3,0x8
40023ac8:	00e6e6b3          	or	a3,a3,a4
40023acc:	006c4703          	lbu	a4,6(s8)
40023ad0:	01899993          	slli	s3,s3,0x18
40023ad4:	01071713          	slli	a4,a4,0x10
40023ad8:	00d76733          	or	a4,a4,a3
40023adc:	00e9e7b3          	or	a5,s3,a4
40023ae0:	000106b7          	lui	a3,0x10
40023ae4:	01871713          	slli	a4,a4,0x18
40023ae8:	0189d993          	srli	s3,s3,0x18
40023aec:	00e9e9b3          	or	s3,s3,a4
40023af0:	f0068693          	addi	a3,a3,-256 # ff00 <__kernel_ram_size+0x43f8>
40023af4:	0087d713          	srli	a4,a5,0x8
40023af8:	00d77733          	and	a4,a4,a3
40023afc:	00e9e9b3          	or	s3,s3,a4
40023b00:	00879793          	slli	a5,a5,0x8
40023b04:	00ff0737          	lui	a4,0xff0
40023b08:	00e7f7b3          	and	a5,a5,a4
40023b0c:	00f9e9b3          	or	s3,s3,a5
40023b10:	22c4a783          	lw	a5,556(s1)
40023b14:	0af99063          	bne	s3,a5,40023bb4 <tcp_in+0x1028>
				if (len > 0) {
40023b18:	0c0a8a63          	beqz	s5,40023bec <tcp_in+0x1060>
	if (*len == 0) {
40023b1c:	f9842783          	lw	a5,-104(s0)
40023b20:	120784e3          	beqz	a5,40024448 <tcp_in+0x18bc>
	ret = tcp_data_get(conn, pkt, len);
40023b24:	00090593          	mv	a1,s2
40023b28:	f9840613          	addi	a2,s0,-104
40023b2c:	00048513          	mv	a0,s1
40023b30:	ba9fe0ef          	jal	ra,400226d8 <tcp_data_get>
40023b34:	4003b7b7          	lui	a5,0x4003b
40023b38:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40023b3c:	0687a703          	lw	a4,104(a5)
	net_stats_update_tcp_seg_recv(conn->iface);
40023b40:	0104a683          	lw	a3,16(s1)
	ret = tcp_data_get(conn, pkt, len);
40023b44:	00050a13          	mv	s4,a0
40023b48:	00170713          	addi	a4,a4,1 # ff0001 <__rom_region_size+0xfb7045>
40023b4c:	06e7a423          	sw	a4,104(a5)
40023b50:	06c6a783          	lw	a5,108(a3)
	if (tcp_short_window(conn)) {
40023b54:	00048513          	mv	a0,s1
40023b58:	00178793          	addi	a5,a5,1
40023b5c:	06f6a623          	sw	a5,108(a3)
	conn_ack(conn, *len);
40023b60:	22c4a783          	lw	a5,556(s1)
40023b64:	f9842703          	lw	a4,-104(s0)
40023b68:	00e787b3          	add	a5,a5,a4
40023b6c:	22f4a623          	sw	a5,556(s1)
	if (tcp_short_window(conn)) {
40023b70:	965fe0ef          	jal	ra,400224d4 <tcp_short_window>
		k_work_schedule_for_queue(&tcp_work_q, &conn->ack_timer,
40023b74:	18048593          	addi	a1,s1,384
	if (tcp_short_window(conn)) {
40023b78:	02050263          	beqz	a0,40023b9c <tcp_in+0x1010>
		k_work_schedule_for_queue(&tcp_work_q, &conn->ack_timer,
40023b7c:	4003a537          	lui	a0,0x4003a
40023b80:	00a00613          	li	a2,10
40023b84:	00000693          	li	a3,0
40023b88:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
40023b8c:	4c00c0ef          	jal	ra,4003004c <k_work_schedule_for_queue>
					if (verdict == NET_OK) {
40023b90:	ee0a0ae3          	beqz	s4,40023a84 <tcp_in+0xef8>
		break;
40023b94:	00000993          	li	s3,0
40023b98:	d71ff06f          	j	40023908 <tcp_in+0xd7c>
		k_work_cancel_delayable(&conn->ack_timer);
40023b9c:	00058513          	mv	a0,a1
40023ba0:	5cc0c0ef          	jal	ra,4003016c <k_work_cancel_delayable>
		tcp_out(conn, ACK);
40023ba4:	01000593          	li	a1,16
40023ba8:	00048513          	mv	a0,s1
40023bac:	948fe0ef          	jal	ra,40021cf4 <tcp_out>
40023bb0:	fe1ff06f          	j	40023b90 <tcp_in+0x1004>
40023bb4:	413787b3          	sub	a5,a5,s3
			} else if (net_tcp_seq_greater(conn->ack, th_seq(th))) {
40023bb8:	02f05e63          	blez	a5,40023bf4 <tcp_in+0x1068>
				tcp_out(conn, ACK); /* peer has resent */
40023bbc:	01000593          	li	a1,16
40023bc0:	00048513          	mv	a0,s1
40023bc4:	930fe0ef          	jal	ra,40021cf4 <tcp_out>
	UPDATE_STAT(iface, stats.tcp.ackerr++);
40023bc8:	4003b7b7          	lui	a5,0x4003b
40023bcc:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40023bd0:	0787a703          	lw	a4,120(a5)
				net_stats_update_tcp_seg_ackerr(conn->iface);
40023bd4:	0104a683          	lw	a3,16(s1)
40023bd8:	00170713          	addi	a4,a4,1
40023bdc:	06e7ac23          	sw	a4,120(a5)
40023be0:	07c6a783          	lw	a5,124(a3)
40023be4:	00178793          	addi	a5,a5,1
40023be8:	06f6ae23          	sw	a5,124(a3)
	if (pkt) {
40023bec:	02091863          	bnez	s2,40023c1c <tcp_in+0x1090>
40023bf0:	e95ff06f          	j	40023a84 <tcp_in+0xef8>
	if (data_len == 0) {
40023bf4:	1e0a8a63          	beqz	s5,40023de8 <tcp_in+0x125c>
	headers_len = net_pkt_get_len(pkt) - data_len;
40023bf8:	00892503          	lw	a0,8(s2)
40023bfc:	a75fc0ef          	jal	ra,40020670 <net_pkt_get_len.isra.0>
	if (tcp_pkt_pull(pkt, headers_len) < 0) {
40023c00:	415505b3          	sub	a1,a0,s5
40023c04:	00090513          	mv	a0,s2
40023c08:	a89fc0ef          	jal	ra,40020690 <tcp_pkt_pull>
40023c0c:	00055e63          	bgez	a0,40023c28 <tcp_in+0x109c>
					tcp_out(conn, ACK);
40023c10:	01000593          	li	a1,16
40023c14:	00048513          	mv	a0,s1
40023c18:	8dcfe0ef          	jal	ra,40021cf4 <tcp_out>
			net_pkt_unref(pkt);
40023c1c:	00090513          	mv	a0,s2
40023c20:	bfdf30ef          	jal	ra,4001781c <net_pkt_unref>
	if (next) {
40023c24:	e61ff06f          	j	40023a84 <tcp_in+0xef8>
	tmp = pkt->buffer;
40023c28:	00892783          	lw	a5,8(s2)
	seq += tmp->len;
40023c2c:	0107d583          	lhu	a1,16(a5)
	tmp = tmp->frags;
40023c30:	0047aa03          	lw	s4,4(a5)
	*(uint32_t *)net_buf_user_data(buf) = seq;
40023c34:	0137ac23          	sw	s3,24(a5)
	seq += tmp->len;
40023c38:	013585b3          	add	a1,a1,s3
	while (tmp) {
40023c3c:	060a1663          	bnez	s4,40023ca8 <tcp_in+0x111c>
	if (!net_pkt_is_empty(conn->queue_recv_data)) {
40023c40:	00c4a503          	lw	a0,12(s1)
40023c44:	00852b83          	lw	s7,8(a0)
	return !pkt->buffer || !net_pkt_data(pkt) || pkt->buffer->len == 0;
40023c48:	060b8a63          	beqz	s7,40023cbc <tcp_in+0x1130>
40023c4c:	00cba783          	lw	a5,12(s7)
40023c50:	06078663          	beqz	a5,40023cbc <tcp_in+0x1130>
40023c54:	010bd783          	lhu	a5,16(s7)
40023c58:	06078263          	beqz	a5,40023cbc <tcp_in+0x1130>
		end_offset = seq - pending_seq;
40023c5c:	018ba783          	lw	a5,24(s7)
		pending_len = net_pkt_get_len(conn->queue_recv_data);
40023c60:	000b8513          	mv	a0,s7
		end_offset = seq - pending_seq;
40023c64:	40f585b3          	sub	a1,a1,a5
40023c68:	f6b42c23          	sw	a1,-136(s0)
		pending_len = net_pkt_get_len(conn->queue_recv_data);
40023c6c:	a05fc0ef          	jal	ra,40020670 <net_pkt_get_len.isra.0>
		if (end_offset < pending_len) {
40023c70:	f7842583          	lw	a1,-136(s0)
40023c74:	08a5e263          	bltu	a1,a0,40023cf8 <tcp_in+0x116c>
			last = net_buf_frag_last(conn->queue_recv_data->buffer);
40023c78:	000b8513          	mv	a0,s7
40023c7c:	a11e90ef          	jal	ra,4000d68c <net_buf_frag_last>
			start_offset = pending_seq - seq_start;
40023c80:	01852783          	lw	a5,24(a0)
			end_offset = (pending_seq + last->len) - seq_start;
40023c84:	01055583          	lhu	a1,16(a0)
			start_offset = pending_seq - seq_start;
40023c88:	413787b3          	sub	a5,a5,s3
			end_offset = (pending_seq + last->len) - seq_start;
40023c8c:	00f585b3          	add	a1,a1,a5
			if ((start_offset < len) && (end_offset <= len)) {
40023c90:	1157f863          	bgeu	a5,s5,40023da0 <tcp_in+0x1214>
40023c94:	f6baeee3          	bltu	s5,a1,40023c10 <tcp_in+0x1084>
				net_buf_unref(conn->queue_recv_data->buffer);
40023c98:	00c4a783          	lw	a5,12(s1)
40023c9c:	0087a503          	lw	a0,8(a5)
40023ca0:	91de90ef          	jal	ra,4000d5bc <net_buf_unref>
40023ca4:	0740006f          	j	40023d18 <tcp_in+0x118c>
		seq += tmp->len;
40023ca8:	010a5783          	lhu	a5,16(s4)
	*(uint32_t *)net_buf_user_data(buf) = seq;
40023cac:	00ba2c23          	sw	a1,24(s4)
		tmp = tmp->frags;
40023cb0:	004a2a03          	lw	s4,4(s4)
		seq += tmp->len;
40023cb4:	00f585b3          	add	a1,a1,a5
		tmp = tmp->frags;
40023cb8:	f85ff06f          	j	40023c3c <tcp_in+0x10b0>
		net_pkt_append_buffer(conn->queue_recv_data, pkt->buffer);
40023cbc:	00892583          	lw	a1,8(s2)
40023cc0:	f75f30ef          	jal	ra,40017c34 <net_pkt_append_buffer>
		if (!k_work_delayable_is_pending(&conn->recv_queue_timer)) {
40023cc4:	0c048593          	addi	a1,s1,192
	return k_work_delayable_busy_get(dwork) != 0;
40023cc8:	00058513          	mv	a0,a1
		pkt->buffer = NULL;
40023ccc:	00092423          	sw	zero,8(s2)
40023cd0:	f6b42c23          	sw	a1,-136(s0)
40023cd4:	3740c0ef          	jal	ra,40030048 <k_work_delayable_busy_get>
		if (!k_work_delayable_is_pending(&conn->recv_queue_timer)) {
40023cd8:	f7842583          	lw	a1,-136(s0)
40023cdc:	f2051ae3          	bnez	a0,40023c10 <tcp_in+0x1084>
			k_work_reschedule_for_queue(
40023ce0:	4003a537          	lui	a0,0x4003a
40023ce4:	0c800613          	li	a2,200
40023ce8:	00000693          	li	a3,0
40023cec:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
40023cf0:	3d40c0ef          	jal	ra,400300c4 <k_work_reschedule_for_queue>
40023cf4:	f1dff06f          	j	40023c10 <tcp_in+0x1084>
			if (end_offset < len) {
40023cf8:	f155fce3          	bgeu	a1,s5,40023c10 <tcp_in+0x1084>
				if (end_offset) {
40023cfc:	00058663          	beqz	a1,40023d08 <tcp_in+0x117c>
					net_pkt_remove_tail(pkt, end_offset);
40023d00:	00090513          	mv	a0,s2
40023d04:	d7df30ef          	jal	ra,40017a80 <net_pkt_remove_tail>
				net_buf_frag_add(pkt->buffer,
40023d08:	00c4a783          	lw	a5,12(s1)
40023d0c:	00892503          	lw	a0,8(s2)
40023d10:	0087a583          	lw	a1,8(a5)
40023d14:	9b1e90ef          	jal	ra,4000d6c4 <net_buf_frag_add>
				conn->queue_recv_data->buffer = pkt->buffer;
40023d18:	00c4a783          	lw	a5,12(s1)
40023d1c:	00892703          	lw	a4,8(s2)
40023d20:	00e7a423          	sw	a4,8(a5)
			if (check_seq_list(conn->queue_recv_data->buffer) == false) {
40023d24:	00c4a783          	lw	a5,12(s1)
	bool result = true;
40023d28:	00100693          	li	a3,1
	uint32_t next_seq = 0;
40023d2c:	00000713          	li	a4,0
			if (check_seq_list(conn->queue_recv_data->buffer) == false) {
40023d30:	0087a783          	lw	a5,8(a5)
	while (tmp) {
40023d34:	08079863          	bnez	a5,40023dc4 <tcp_in+0x1238>
			if (check_seq_list(conn->queue_recv_data->buffer) == false) {
40023d38:	f80696e3          	bnez	a3,40023cc4 <tcp_in+0x1138>
				NET_ERR("Incorrect order in out of order sequence for conn %p",
40023d3c:	40044537          	lui	a0,0x40044
40023d40:	7a052783          	lw	a5,1952(a0) # 400447a0 <log_dynamic_net_tcp>
40023d44:	0077f793          	andi	a5,a5,7
40023d48:	04078063          	beqz	a5,40023d88 <tcp_in+0x11fc>
40023d4c:	00010993          	mv	s3,sp
40023d50:	fe010113          	addi	sp,sp,-32
40023d54:	00010613          	mv	a2,sp
40023d58:	400357b7          	lui	a5,0x40035
40023d5c:	4cc78793          	addi	a5,a5,1228 # 400354cc <CSWTCH.16862+0x2d4>
40023d60:	00f62a23          	sw	a5,20(a2)
40023d64:	000025b7          	lui	a1,0x2
40023d68:	00300793          	li	a5,3
40023d6c:	00962c23          	sw	s1,24(a2)
40023d70:	00f62823          	sw	a5,16(a2)
40023d74:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
40023d78:	01060613          	addi	a2,a2,16
40023d7c:	7a050513          	addi	a0,a0,1952
40023d80:	fa8fc0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
40023d84:	00098113          	mv	sp,s3
				net_buf_unref(conn->queue_recv_data->buffer);
40023d88:	00c4a783          	lw	a5,12(s1)
40023d8c:	0087a503          	lw	a0,8(a5)
40023d90:	82de90ef          	jal	ra,4000d5bc <net_buf_unref>
				conn->queue_recv_data->buffer = NULL;
40023d94:	00c4a783          	lw	a5,12(s1)
40023d98:	0007a423          	sw	zero,8(a5)
40023d9c:	f29ff06f          	j	40023cc4 <tcp_in+0x1138>
				if (end_offset < len) {
40023da0:	e755f8e3          	bgeu	a1,s5,40023c10 <tcp_in+0x1084>
					if (end_offset) {
40023da4:	00058663          	beqz	a1,40023db0 <tcp_in+0x1224>
						net_pkt_remove_tail(conn->queue_recv_data,
40023da8:	00c4a503          	lw	a0,12(s1)
40023dac:	cd5f30ef          	jal	ra,40017a80 <net_pkt_remove_tail>
					net_buf_frag_add(conn->queue_recv_data->buffer,
40023db0:	00c4a783          	lw	a5,12(s1)
40023db4:	00892583          	lw	a1,8(s2)
40023db8:	0087a503          	lw	a0,8(a5)
40023dbc:	909e90ef          	jal	ra,4000d6c4 <net_buf_frag_add>
		if (inserted) {
40023dc0:	f65ff06f          	j	40023d24 <tcp_in+0x1198>
	return *(uint32_t *)net_buf_user_data(buf);
40023dc4:	0187a603          	lw	a2,24(a5)
		if (last != NULL) {
40023dc8:	000a0663          	beqz	s4,40023dd4 <tcp_in+0x1248>
			if (next_seq != seq) {
40023dcc:	00e60463          	beq	a2,a4,40023dd4 <tcp_in+0x1248>
				result = false;
40023dd0:	00000693          	li	a3,0
		next_seq = seq + tmp->len;
40023dd4:	0107d703          	lhu	a4,16(a5)
		tmp = tmp->frags;
40023dd8:	00078a13          	mv	s4,a5
40023ddc:	0047a783          	lw	a5,4(a5)
		next_seq = seq + tmp->len;
40023de0:	00c70733          	add	a4,a4,a2
		tmp = tmp->frags;
40023de4:	f51ff06f          	j	40023d34 <tcp_in+0x11a8>
				if ((len > 0) || FL(&fl, &, FIN)) {
40023de8:	e00b82e3          	beqz	s7,40023bec <tcp_in+0x1060>
40023dec:	40033537          	lui	a0,0x40033
40023df0:	1e850513          	addi	a0,a0,488 # 400331e8 <severity_lvls+0xf0>
40023df4:	001bfb93          	andi	s7,s7,1
40023df8:	ddde80ef          	jal	ra,4000cbd4 <strlen>
40023dfc:	de0b88e3          	beqz	s7,40023bec <tcp_in+0x1060>
					tcp_out(conn, ACK);
40023e00:	01000593          	li	a1,16
40023e04:	00048513          	mv	a0,s1
40023e08:	eedfd0ef          	jal	ra,40021cf4 <tcp_out>
	if (pkt) {
40023e0c:	de1ff06f          	j	40023bec <tcp_in+0x1060>
		tcp_out(conn, FIN);
40023e10:	00100593          	li	a1,1
40023e14:	92dff06f          	j	40023740 <tcp_in+0xbb4>
		if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
40023e18:	420c0663          	beqz	s8,40024244 <tcp_in+0x16b8>
40023e1c:	0ff9f993          	zext.b	s3,s3
40023e20:	42098263          	beqz	s3,40024244 <tcp_in+0x16b8>
40023e24:	40035537          	lui	a0,0x40035
40023e28:	48850513          	addi	a0,a0,1160 # 40035488 <CSWTCH.16862+0x290>
40023e2c:	da9e80ef          	jal	ra,4000cbd4 <strlen>
40023e30:	06050263          	beqz	a0,40023e94 <tcp_in+0x1308>
40023e34:	005c4683          	lbu	a3,5(s8)
40023e38:	004c4703          	lbu	a4,4(s8)
40023e3c:	007c4783          	lbu	a5,7(s8)
40023e40:	00869693          	slli	a3,a3,0x8
40023e44:	00e6e6b3          	or	a3,a3,a4
40023e48:	006c4703          	lbu	a4,6(s8)
40023e4c:	01879793          	slli	a5,a5,0x18
40023e50:	00010637          	lui	a2,0x10
40023e54:	01071713          	slli	a4,a4,0x10
40023e58:	00d76733          	or	a4,a4,a3
40023e5c:	00e7e6b3          	or	a3,a5,a4
40023e60:	01871713          	slli	a4,a4,0x18
40023e64:	0187d793          	srli	a5,a5,0x18
40023e68:	00e7e7b3          	or	a5,a5,a4
40023e6c:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
40023e70:	0086d713          	srli	a4,a3,0x8
40023e74:	00c77733          	and	a4,a4,a2
40023e78:	00e7e7b3          	or	a5,a5,a4
40023e7c:	00869693          	slli	a3,a3,0x8
40023e80:	00ff0737          	lui	a4,0xff0
40023e84:	00e6f6b3          	and	a3,a3,a4
40023e88:	22c4a703          	lw	a4,556(s1)
40023e8c:	00d7e7b3          	or	a5,a5,a3
40023e90:	3ae79a63          	bne	a5,a4,40024244 <tcp_in+0x16b8>
40023e94:	01000793          	li	a5,16
40023e98:	3af99663          	bne	s3,a5,40024244 <tcp_in+0x16b8>
			tcp_send_timer_cancel(conn);
40023e9c:	00048513          	mv	a0,s1
		if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
40023ea0:	00000993          	li	s3,0
			tcp_send_timer_cancel(conn);
40023ea4:	c81fc0ef          	jal	ra,40020b24 <tcp_send_timer_cancel>
	if (pkt) {
40023ea8:	00090663          	beqz	s2,40023eb4 <tcp_in+0x1328>
			net_pkt_unref(pkt);
40023eac:	00090513          	mv	a0,s2
40023eb0:	96df30ef          	jal	ra,4001781c <net_pkt_unref>
			next = TCP_CLOSED;
40023eb4:	00b00a93          	li	s5,11
			close_status = 0;
40023eb8:	00000b13          	li	s6,0
40023ebc:	a68ff06f          	j	40023124 <tcp_in+0x598>
		conn_ack(conn, + len);
40023ec0:	22c4a703          	lw	a4,556(s1)
40023ec4:	01570733          	add	a4,a4,s5
40023ec8:	22e4a623          	sw	a4,556(s1)
		if (th && FL(&fl, ==, (FIN | ACK), th_seq(th) == conn->ack)) {
40023ecc:	360c0c63          	beqz	s8,40024244 <tcp_in+0x16b8>
40023ed0:	0ff9f993          	zext.b	s3,s3
40023ed4:	36098863          	beqz	s3,40024244 <tcp_in+0x16b8>
40023ed8:	40035ab7          	lui	s5,0x40035
40023edc:	488a8513          	addi	a0,s5,1160 # 40035488 <CSWTCH.16862+0x290>
40023ee0:	cf5e80ef          	jal	ra,4000cbd4 <strlen>
40023ee4:	06050263          	beqz	a0,40023f48 <tcp_in+0x13bc>
40023ee8:	005c4703          	lbu	a4,5(s8)
40023eec:	004c4683          	lbu	a3,4(s8)
40023ef0:	000105b7          	lui	a1,0x10
40023ef4:	00871713          	slli	a4,a4,0x8
40023ef8:	00d76733          	or	a4,a4,a3
40023efc:	006c4683          	lbu	a3,6(s8)
40023f00:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x43f8>
40023f04:	01069693          	slli	a3,a3,0x10
40023f08:	00e6e6b3          	or	a3,a3,a4
40023f0c:	007c4703          	lbu	a4,7(s8)
40023f10:	01871713          	slli	a4,a4,0x18
40023f14:	00d76633          	or	a2,a4,a3
40023f18:	01869693          	slli	a3,a3,0x18
40023f1c:	01875713          	srli	a4,a4,0x18
40023f20:	00d76733          	or	a4,a4,a3
40023f24:	00865693          	srli	a3,a2,0x8
40023f28:	00b6f6b3          	and	a3,a3,a1
40023f2c:	00d76733          	or	a4,a4,a3
40023f30:	00861613          	slli	a2,a2,0x8
40023f34:	00ff06b7          	lui	a3,0xff0
40023f38:	00d67633          	and	a2,a2,a3
40023f3c:	22c4a683          	lw	a3,556(s1)
40023f40:	00c76733          	or	a4,a4,a2
40023f44:	04d71263          	bne	a4,a3,40023f88 <tcp_in+0x13fc>
40023f48:	01100713          	li	a4,17
40023f4c:	02e99e63          	bne	s3,a4,40023f88 <tcp_in+0x13fc>
			tcp_send_timer_cancel(conn);
40023f50:	00048513          	mv	a0,s1
		if (th && FL(&fl, ==, (FIN | ACK), th_seq(th) == conn->ack)) {
40023f54:	00000993          	li	s3,0
			tcp_send_timer_cancel(conn);
40023f58:	bcdfc0ef          	jal	ra,40020b24 <tcp_send_timer_cancel>
			conn_ack(conn, + 1);
40023f5c:	22c4a783          	lw	a5,556(s1)
			tcp_out(conn, ACK);
40023f60:	01000593          	li	a1,16
40023f64:	00048513          	mv	a0,s1
			conn_ack(conn, + 1);
40023f68:	00178793          	addi	a5,a5,1
40023f6c:	22f4a623          	sw	a5,556(s1)
			tcp_out(conn, ACK);
40023f70:	d85fd0ef          	jal	ra,40021cf4 <tcp_out>
	if (pkt) {
40023f74:	00090663          	beqz	s2,40023f80 <tcp_in+0x13f4>
			net_pkt_unref(pkt);
40023f78:	00090513          	mv	a0,s2
40023f7c:	8a1f30ef          	jal	ra,4001781c <net_pkt_unref>
			next = TCP_TIME_WAIT;
40023f80:	00a00a93          	li	s5,10
40023f84:	9a0ff06f          	j	40023124 <tcp_in+0x598>
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
40023f88:	488a8513          	addi	a0,s5,1160
40023f8c:	c49e80ef          	jal	ra,4000cbd4 <strlen>
40023f90:	06050263          	beqz	a0,40023ff4 <tcp_in+0x1468>
40023f94:	005c4703          	lbu	a4,5(s8)
40023f98:	004c4683          	lbu	a3,4(s8)
40023f9c:	000105b7          	lui	a1,0x10
40023fa0:	00871713          	slli	a4,a4,0x8
40023fa4:	00d76733          	or	a4,a4,a3
40023fa8:	006c4683          	lbu	a3,6(s8)
40023fac:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x43f8>
40023fb0:	01069693          	slli	a3,a3,0x10
40023fb4:	00e6e6b3          	or	a3,a3,a4
40023fb8:	007c4703          	lbu	a4,7(s8)
40023fbc:	01871713          	slli	a4,a4,0x18
40023fc0:	00d76633          	or	a2,a4,a3
40023fc4:	01869693          	slli	a3,a3,0x18
40023fc8:	01875713          	srli	a4,a4,0x18
40023fcc:	00d76733          	or	a4,a4,a3
40023fd0:	00865693          	srli	a3,a2,0x8
40023fd4:	00b6f6b3          	and	a3,a3,a1
40023fd8:	00d76733          	or	a4,a4,a3
40023fdc:	00861613          	slli	a2,a2,0x8
40023fe0:	00ff06b7          	lui	a3,0xff0
40023fe4:	00d67633          	and	a2,a2,a3
40023fe8:	22c4a683          	lw	a3,556(s1)
40023fec:	00c76733          	or	a4,a4,a2
40023ff0:	04d71263          	bne	a4,a3,40024034 <tcp_in+0x14a8>
40023ff4:	00100713          	li	a4,1
40023ff8:	02e99e63          	bne	s3,a4,40024034 <tcp_in+0x14a8>
			tcp_send_timer_cancel(conn);
40023ffc:	00048513          	mv	a0,s1
40024000:	b25fc0ef          	jal	ra,40020b24 <tcp_send_timer_cancel>
			conn_ack(conn, + 1);
40024004:	22c4a783          	lw	a5,556(s1)
			tcp_out(conn, ACK);
40024008:	01000593          	li	a1,16
4002400c:	00048513          	mv	a0,s1
			conn_ack(conn, + 1);
40024010:	00178793          	addi	a5,a5,1
40024014:	22f4a623          	sw	a5,556(s1)
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
40024018:	00000993          	li	s3,0
			tcp_out(conn, ACK);
4002401c:	cd9fd0ef          	jal	ra,40021cf4 <tcp_out>
	if (pkt) {
40024020:	00090663          	beqz	s2,4002402c <tcp_in+0x14a0>
			net_pkt_unref(pkt);
40024024:	00090513          	mv	a0,s2
40024028:	ff4f30ef          	jal	ra,4001781c <net_pkt_unref>
			next = TCP_CLOSING;
4002402c:	00800a93          	li	s5,8
40024030:	8f4ff06f          	j	40023124 <tcp_in+0x598>
		} else if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
40024034:	488a8513          	addi	a0,s5,1160
40024038:	b9de80ef          	jal	ra,4000cbd4 <strlen>
4002403c:	06050263          	beqz	a0,400240a0 <tcp_in+0x1514>
40024040:	005c4683          	lbu	a3,5(s8)
40024044:	004c4703          	lbu	a4,4(s8)
40024048:	007c4783          	lbu	a5,7(s8)
4002404c:	00869693          	slli	a3,a3,0x8
40024050:	00e6e6b3          	or	a3,a3,a4
40024054:	006c4703          	lbu	a4,6(s8)
40024058:	01879793          	slli	a5,a5,0x18
4002405c:	00010637          	lui	a2,0x10
40024060:	01071713          	slli	a4,a4,0x10
40024064:	00d76733          	or	a4,a4,a3
40024068:	00e7e6b3          	or	a3,a5,a4
4002406c:	01871713          	slli	a4,a4,0x18
40024070:	0187d793          	srli	a5,a5,0x18
40024074:	00e7e7b3          	or	a5,a5,a4
40024078:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
4002407c:	0086d713          	srli	a4,a3,0x8
40024080:	00c77733          	and	a4,a4,a2
40024084:	00e7e7b3          	or	a5,a5,a4
40024088:	00869693          	slli	a3,a3,0x8
4002408c:	00ff0737          	lui	a4,0xff0
40024090:	00e6f6b3          	and	a3,a3,a4
40024094:	22c4a703          	lw	a4,556(s1)
40024098:	00d7e7b3          	or	a5,a5,a3
4002409c:	1ae79463          	bne	a5,a4,40024244 <tcp_in+0x16b8>
400240a0:	01000793          	li	a5,16
400240a4:	1af99063          	bne	s3,a5,40024244 <tcp_in+0x16b8>
			tcp_send_timer_cancel(conn);
400240a8:	00048513          	mv	a0,s1
		} else if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
400240ac:	00000993          	li	s3,0
			tcp_send_timer_cancel(conn);
400240b0:	a75fc0ef          	jal	ra,40020b24 <tcp_send_timer_cancel>
	if (pkt) {
400240b4:	00090663          	beqz	s2,400240c0 <tcp_in+0x1534>
			net_pkt_unref(pkt);
400240b8:	00090513          	mv	a0,s2
400240bc:	f60f30ef          	jal	ra,4001781c <net_pkt_unref>
			next = TCP_FIN_WAIT_2;
400240c0:	00600a93          	li	s5,6
400240c4:	860ff06f          	j	40023124 <tcp_in+0x598>
		if (th && (FL(&fl, ==, FIN, th_seq(th) == conn->ack) ||
400240c8:	160c0e63          	beqz	s8,40024244 <tcp_in+0x16b8>
400240cc:	0ff9f993          	zext.b	s3,s3
400240d0:	16098a63          	beqz	s3,40024244 <tcp_in+0x16b8>
400240d4:	40035ab7          	lui	s5,0x40035
400240d8:	488a8513          	addi	a0,s5,1160 # 40035488 <CSWTCH.16862+0x290>
400240dc:	af9e80ef          	jal	ra,4000cbd4 <strlen>
400240e0:	06050263          	beqz	a0,40024144 <tcp_in+0x15b8>
400240e4:	005c4703          	lbu	a4,5(s8)
400240e8:	004c4683          	lbu	a3,4(s8)
400240ec:	000105b7          	lui	a1,0x10
400240f0:	00871713          	slli	a4,a4,0x8
400240f4:	00d76733          	or	a4,a4,a3
400240f8:	006c4683          	lbu	a3,6(s8)
400240fc:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x43f8>
40024100:	01069693          	slli	a3,a3,0x10
40024104:	00e6e6b3          	or	a3,a3,a4
40024108:	007c4703          	lbu	a4,7(s8)
4002410c:	01871713          	slli	a4,a4,0x18
40024110:	00d76633          	or	a2,a4,a3
40024114:	01869693          	slli	a3,a3,0x18
40024118:	01875713          	srli	a4,a4,0x18
4002411c:	00d76733          	or	a4,a4,a3
40024120:	00865693          	srli	a3,a2,0x8
40024124:	00b6f6b3          	and	a3,a3,a1
40024128:	00d76733          	or	a4,a4,a3
4002412c:	00861613          	slli	a2,a2,0x8
40024130:	00ff06b7          	lui	a3,0xff0
40024134:	00d67633          	and	a2,a2,a3
40024138:	22c4a683          	lw	a3,556(s1)
4002413c:	00c76733          	or	a4,a4,a2
40024140:	00d71e63          	bne	a4,a3,4002415c <tcp_in+0x15d0>
40024144:	00100713          	li	a4,1
40024148:	00e99a63          	bne	s3,a4,4002415c <tcp_in+0x15d0>
			k_work_cancel_delayable(&conn->fin_timer);
4002414c:	1b048513          	addi	a0,s1,432
			   FL(&fl, ==, FIN | PSH | ACK,
40024150:	00000993          	li	s3,0
			k_work_cancel_delayable(&conn->fin_timer);
40024154:	0180c0ef          	jal	ra,4003016c <k_work_cancel_delayable>
40024158:	e05ff06f          	j	40023f5c <tcp_in+0x13d0>
			   FL(&fl, ==, FIN | ACK, th_seq(th) == conn->ack) ||
4002415c:	488a8513          	addi	a0,s5,1160
40024160:	a75e80ef          	jal	ra,4000cbd4 <strlen>
40024164:	06050263          	beqz	a0,400241c8 <tcp_in+0x163c>
40024168:	005c4703          	lbu	a4,5(s8)
4002416c:	004c4683          	lbu	a3,4(s8)
40024170:	000105b7          	lui	a1,0x10
40024174:	00871713          	slli	a4,a4,0x8
40024178:	00d76733          	or	a4,a4,a3
4002417c:	006c4683          	lbu	a3,6(s8)
40024180:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x43f8>
40024184:	01069693          	slli	a3,a3,0x10
40024188:	00e6e6b3          	or	a3,a3,a4
4002418c:	007c4703          	lbu	a4,7(s8)
40024190:	01871713          	slli	a4,a4,0x18
40024194:	00d76633          	or	a2,a4,a3
40024198:	01869693          	slli	a3,a3,0x18
4002419c:	01875713          	srli	a4,a4,0x18
400241a0:	00d76733          	or	a4,a4,a3
400241a4:	00865693          	srli	a3,a2,0x8
400241a8:	00b6f6b3          	and	a3,a3,a1
400241ac:	00d76733          	or	a4,a4,a3
400241b0:	00861613          	slli	a2,a2,0x8
400241b4:	00ff06b7          	lui	a3,0xff0
400241b8:	00d67633          	and	a2,a2,a3
400241bc:	22c4a683          	lw	a3,556(s1)
400241c0:	00c76733          	or	a4,a4,a2
400241c4:	00d71663          	bne	a4,a3,400241d0 <tcp_in+0x1644>
400241c8:	01100713          	li	a4,17
400241cc:	f8e980e3          	beq	s3,a4,4002414c <tcp_in+0x15c0>
			   FL(&fl, ==, FIN | PSH | ACK,
400241d0:	488a8513          	addi	a0,s5,1160
400241d4:	a01e80ef          	jal	ra,4000cbd4 <strlen>
400241d8:	06050263          	beqz	a0,4002423c <tcp_in+0x16b0>
400241dc:	005c4683          	lbu	a3,5(s8)
400241e0:	004c4703          	lbu	a4,4(s8)
400241e4:	007c4783          	lbu	a5,7(s8)
400241e8:	00869693          	slli	a3,a3,0x8
400241ec:	00e6e6b3          	or	a3,a3,a4
400241f0:	006c4703          	lbu	a4,6(s8)
400241f4:	01879793          	slli	a5,a5,0x18
400241f8:	00010637          	lui	a2,0x10
400241fc:	01071713          	slli	a4,a4,0x10
40024200:	00d76733          	or	a4,a4,a3
40024204:	00e7e6b3          	or	a3,a5,a4
40024208:	01871713          	slli	a4,a4,0x18
4002420c:	0187d793          	srli	a5,a5,0x18
40024210:	00e7e7b3          	or	a5,a5,a4
40024214:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
40024218:	0086d713          	srli	a4,a3,0x8
4002421c:	00c77733          	and	a4,a4,a2
40024220:	00e7e7b3          	or	a5,a5,a4
40024224:	00869693          	slli	a3,a3,0x8
40024228:	00ff0737          	lui	a4,0xff0
4002422c:	00e6f6b3          	and	a3,a3,a4
40024230:	22c4a703          	lw	a4,556(s1)
40024234:	00d7e7b3          	or	a5,a5,a3
40024238:	00e79663          	bne	a5,a4,40024244 <tcp_in+0x16b8>
4002423c:	01900793          	li	a5,25
40024240:	f0f986e3          	beq	s3,a5,4002414c <tcp_in+0x15c0>
	if (pkt) {
40024244:	1c091a63          	bnez	s2,40024418 <tcp_in+0x188c>
40024248:	94dff06f          	j	40023b94 <tcp_in+0x1008>
		if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
4002424c:	1c0c0263          	beqz	s8,40024410 <tcp_in+0x1884>
40024250:	0ff9f993          	zext.b	s3,s3
40024254:	fe0988e3          	beqz	s3,40024244 <tcp_in+0x16b8>
40024258:	40035537          	lui	a0,0x40035
4002425c:	48850513          	addi	a0,a0,1160 # 40035488 <CSWTCH.16862+0x290>
40024260:	975e80ef          	jal	ra,4000cbd4 <strlen>
40024264:	06050263          	beqz	a0,400242c8 <tcp_in+0x173c>
40024268:	005c4683          	lbu	a3,5(s8)
4002426c:	004c4703          	lbu	a4,4(s8)
40024270:	007c4783          	lbu	a5,7(s8)
40024274:	00869693          	slli	a3,a3,0x8
40024278:	00e6e6b3          	or	a3,a3,a4
4002427c:	006c4703          	lbu	a4,6(s8)
40024280:	01879793          	slli	a5,a5,0x18
40024284:	00010637          	lui	a2,0x10
40024288:	01071713          	slli	a4,a4,0x10
4002428c:	00d76733          	or	a4,a4,a3
40024290:	00e7e6b3          	or	a3,a5,a4
40024294:	01871713          	slli	a4,a4,0x18
40024298:	0187d793          	srli	a5,a5,0x18
4002429c:	00e7e7b3          	or	a5,a5,a4
400242a0:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
400242a4:	0086d713          	srli	a4,a3,0x8
400242a8:	00c77733          	and	a4,a4,a2
400242ac:	00e7e7b3          	or	a5,a5,a4
400242b0:	00869693          	slli	a3,a3,0x8
400242b4:	00ff0737          	lui	a4,0xff0
400242b8:	00e6f6b3          	and	a3,a3,a4
400242bc:	22c4a703          	lw	a4,556(s1)
400242c0:	00d7e7b3          	or	a5,a5,a3
400242c4:	14e79663          	bne	a5,a4,40024410 <tcp_in+0x1884>
400242c8:	01000793          	li	a5,16
400242cc:	f6f99ce3          	bne	s3,a5,40024244 <tcp_in+0x16b8>
			tcp_send_timer_cancel(conn);
400242d0:	00048513          	mv	a0,s1
		if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
400242d4:	00000993          	li	s3,0
			tcp_send_timer_cancel(conn);
400242d8:	84dfc0ef          	jal	ra,40020b24 <tcp_send_timer_cancel>
400242dc:	c99ff06f          	j	40023f74 <tcp_in+0x13e8>
		if (th && (FL(&fl, ==, (FIN | ACK), th_seq(th) + 1 == conn->ack) ||
400242e0:	100c0863          	beqz	s8,400243f0 <tcp_in+0x1864>
400242e4:	0ff9f993          	zext.b	s3,s3
400242e8:	10098463          	beqz	s3,400243f0 <tcp_in+0x1864>
400242ec:	40035ab7          	lui	s5,0x40035
400242f0:	504a8513          	addi	a0,s5,1284 # 40035504 <CSWTCH.16862+0x30c>
400242f4:	8e1e80ef          	jal	ra,4000cbd4 <strlen>
400242f8:	06050463          	beqz	a0,40024360 <tcp_in+0x17d4>
400242fc:	005c4703          	lbu	a4,5(s8)
40024300:	004c4683          	lbu	a3,4(s8)
40024304:	000105b7          	lui	a1,0x10
40024308:	00871713          	slli	a4,a4,0x8
4002430c:	00d76733          	or	a4,a4,a3
40024310:	006c4683          	lbu	a3,6(s8)
40024314:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x43f8>
40024318:	01069693          	slli	a3,a3,0x10
4002431c:	00e6e6b3          	or	a3,a3,a4
40024320:	007c4703          	lbu	a4,7(s8)
40024324:	01871713          	slli	a4,a4,0x18
40024328:	00d76633          	or	a2,a4,a3
4002432c:	01869693          	slli	a3,a3,0x18
40024330:	01875713          	srli	a4,a4,0x18
40024334:	00d76733          	or	a4,a4,a3
40024338:	00865693          	srli	a3,a2,0x8
4002433c:	00b6f6b3          	and	a3,a3,a1
40024340:	00d76733          	or	a4,a4,a3
40024344:	00861613          	slli	a2,a2,0x8
40024348:	00ff06b7          	lui	a3,0xff0
4002434c:	00d67633          	and	a2,a2,a3
40024350:	22c4a683          	lw	a3,556(s1)
40024354:	00c76733          	or	a4,a4,a2
40024358:	00170713          	addi	a4,a4,1 # ff0001 <__rom_region_size+0xfb7045>
4002435c:	00d71663          	bne	a4,a3,40024368 <tcp_in+0x17dc>
40024360:	01100713          	li	a4,17
40024364:	06e98e63          	beq	s3,a4,400243e0 <tcp_in+0x1854>
			   FL(&fl, ==, FIN, th_seq(th) + 1 == conn->ack))) {
40024368:	504a8513          	addi	a0,s5,1284
4002436c:	869e80ef          	jal	ra,4000cbd4 <strlen>
40024370:	06050463          	beqz	a0,400243d8 <tcp_in+0x184c>
40024374:	005c4683          	lbu	a3,5(s8)
40024378:	004c4703          	lbu	a4,4(s8)
4002437c:	007c4783          	lbu	a5,7(s8)
40024380:	00869693          	slli	a3,a3,0x8
40024384:	00e6e6b3          	or	a3,a3,a4
40024388:	006c4703          	lbu	a4,6(s8)
4002438c:	01879793          	slli	a5,a5,0x18
40024390:	00010637          	lui	a2,0x10
40024394:	01071713          	slli	a4,a4,0x10
40024398:	00d76733          	or	a4,a4,a3
4002439c:	00e7e6b3          	or	a3,a5,a4
400243a0:	01871713          	slli	a4,a4,0x18
400243a4:	0187d793          	srli	a5,a5,0x18
400243a8:	00e7e7b3          	or	a5,a5,a4
400243ac:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x43f8>
400243b0:	0086d713          	srli	a4,a3,0x8
400243b4:	00c77733          	and	a4,a4,a2
400243b8:	00e7e7b3          	or	a5,a5,a4
400243bc:	00869693          	slli	a3,a3,0x8
400243c0:	00ff0737          	lui	a4,0xff0
400243c4:	00e6f6b3          	and	a3,a3,a4
400243c8:	22c4a703          	lw	a4,556(s1)
400243cc:	00d7e7b3          	or	a5,a5,a3
400243d0:	00178793          	addi	a5,a5,1
400243d4:	00e79e63          	bne	a5,a4,400243f0 <tcp_in+0x1864>
400243d8:	00100793          	li	a5,1
400243dc:	00f99a63          	bne	s3,a5,400243f0 <tcp_in+0x1864>
			tcp_out(conn, ACK);
400243e0:	01000593          	li	a1,16
400243e4:	00048513          	mv	a0,s1
400243e8:	90dfd0ef          	jal	ra,40021cf4 <tcp_out>
			verdict = NET_OK;
400243ec:	00000a13          	li	s4,0
		k_work_reschedule_for_queue(
400243f0:	4003a537          	lui	a0,0x4003a
400243f4:	09600613          	li	a2,150
400243f8:	00000693          	li	a3,0
400243fc:	12048593          	addi	a1,s1,288
40024400:	c7050513          	addi	a0,a0,-912 # 40039c70 <tcp_work_q>
40024404:	4c10b0ef          	jal	ra,400300c4 <k_work_reschedule_for_queue>
	if (pkt) {
40024408:	00000993          	li	s3,0
4002440c:	cf8ff06f          	j	40023904 <tcp_in+0xd78>
40024410:	00000993          	li	s3,0
40024414:	ce090a63          	beqz	s2,40023908 <tcp_in+0xd7c>
			next = TCP_SYN_SENT;
40024418:	00000993          	li	s3,0
		if (verdict == NET_OK) {
4002441c:	ce0a1663          	bnez	s4,40023908 <tcp_in+0xd7c>
			net_pkt_unref(pkt);
40024420:	00090513          	mv	a0,s2
40024424:	bf8f30ef          	jal	ra,4001781c <net_pkt_unref>
	if (next) {
40024428:	ce0ff06f          	j	40023908 <tcp_in+0xd7c>
	if (pkt) {
4002442c:	00090663          	beqz	s2,40024438 <tcp_in+0x18ac>
			net_pkt_unref(pkt);
40024430:	00090513          	mv	a0,s2
40024434:	be8f30ef          	jal	ra,4001781c <net_pkt_unref>
				verdict = NET_OK;
40024438:	00000a13          	li	s4,0
4002443c:	ee5fe06f          	j	40023320 <tcp_in+0x794>
		do_close = true;
40024440:	00100993          	li	s3,1
40024444:	cc0ff06f          	j	40023904 <tcp_in+0xd78>
		return NET_DROP;
40024448:	00200a13          	li	s4,2
4002444c:	f48ff06f          	j	40023b94 <tcp_in+0x1008>
	while (conn_handler && atomic_get(&conn->ref_count) > 0 &&
40024450:	000c0513          	mv	a0,s8
40024454:	6340d0ef          	jal	ra,40031a88 <atomic_get>
40024458:	cca05c63          	blez	a0,40023930 <tcp_in+0xda4>
	return z_impl_k_queue_get(queue, timeout);
4002445c:	00000593          	li	a1,0
40024460:	00000613          	li	a2,0
40024464:	000b8513          	mv	a0,s7
40024468:	3c40b0ef          	jal	ra,4002f82c <z_impl_k_queue_get>
4002446c:	00050913          	mv	s2,a0
40024470:	cc050063          	beqz	a0,40023930 <tcp_in+0xda4>
		if (net_context_packet_received(conn_handler, recv_pkt, NULL,
40024474:	000c8713          	mv	a4,s9
40024478:	00000693          	li	a3,0
4002447c:	00000613          	li	a2,0
40024480:	00090593          	mv	a1,s2
40024484:	000a8513          	mv	a0,s5
40024488:	f20f10ef          	jal	ra,40015ba8 <net_context_packet_received>
4002448c:	fda512e3          	bne	a0,s10,40024450 <tcp_in+0x18c4>
			tcp_pkt_unref(recv_pkt);
40024490:	00090513          	mv	a0,s2
40024494:	b88f30ef          	jal	ra,4001781c <net_pkt_unref>
40024498:	c94ff06f          	j	4002392c <tcp_in+0xda0>
			next = TCP_ESTABLISHED;
4002449c:	00400a93          	li	s5,4
			connection_ok = true;
400244a0:	00100c93          	li	s9,1
		if (verdict == NET_OK) {
400244a4:	000a0463          	beqz	s4,400244ac <tcp_in+0x1920>
400244a8:	cc1fe06f          	j	40023168 <tcp_in+0x5dc>
400244ac:	d9cff06f          	j	40023a48 <tcp_in+0xebc>

400244b0 <net_tcp_connect>:
{
400244b0:	fa010113          	addi	sp,sp,-96
400244b4:	04112e23          	sw	ra,92(sp)
400244b8:	04912a23          	sw	s1,84(sp)
400244bc:	05212823          	sw	s2,80(sp)
400244c0:	05312623          	sw	s3,76(sp)
400244c4:	05412423          	sw	s4,72(sp)
400244c8:	05512223          	sw	s5,68(sp)
400244cc:	05612023          	sw	s6,64(sp)
400244d0:	03712e23          	sw	s7,60(sp)
400244d4:	03812c23          	sw	s8,56(sp)
400244d8:	03912a23          	sw	s9,52(sp)
400244dc:	03a12823          	sw	s10,48(sp)
400244e0:	03b12623          	sw	s11,44(sp)
400244e4:	04812c23          	sw	s0,88(sp)
	conn = context->tcp;
400244e8:	05452403          	lw	s0,84(a0)
{
400244ec:	00050493          	mv	s1,a0
	conn->iface = net_context_get_iface(context);
400244f0:	07650503          	lb	a0,118(a0)
{
400244f4:	00078b93          	mv	s7,a5
400244f8:	00058993          	mv	s3,a1
400244fc:	00060c93          	mv	s9,a2
40024500:	00068a13          	mv	s4,a3
40024504:	00070a93          	mv	s5,a4
40024508:	00080b13          	mv	s6,a6
4002450c:	00088c13          	mv	s8,a7
	conn->iface = net_context_get_iface(context);
40024510:	9ecfc0ef          	jal	ra,400206fc <net_context_get_iface.isra.0>
40024514:	00a42823          	sw	a0,16(s0)
	tcp_derive_rto(conn);
40024518:	00040513          	mv	a0,s0
4002451c:	dddfb0ef          	jal	ra,400202f8 <tcp_derive_rto>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40024520:	0744d903          	lhu	s2,116(s1)
	switch (net_context_get_family(context)) {
40024524:	00100793          	li	a5,1
		memset(&conn->src, 0, sizeof(struct sockaddr_in));
40024528:	1e040d13          	addi	s10,s0,480
4002452c:	00395913          	srli	s2,s2,0x3
40024530:	00797913          	andi	s2,s2,7
		memset(&conn->dst, 0, sizeof(struct sockaddr_in));
40024534:	1f840d93          	addi	s11,s0,504
	switch (net_context_get_family(context)) {
40024538:	14f90463          	beq	s2,a5,40024680 <net_tcp_connect+0x1d0>
4002453c:	00200793          	li	a5,2
40024540:	1cf90863          	beq	s2,a5,40024710 <net_tcp_connect+0x260>
		conn->seq = tcp_init_isn(&conn->src.sa, &conn->dst.sa);
40024544:	000d8593          	mv	a1,s11
40024548:	000d0513          	mv	a0,s10
4002454c:	c7dfc0ef          	jal	ra,400211c8 <tcp_init_isn>
40024550:	22a42423          	sw	a0,552(s0)
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
40024554:	0744d583          	lhu	a1,116(s1)
	ret = net_conn_register(net_context_get_proto(context),
40024558:	04448693          	addi	a3,s1,68
4002455c:	008a9793          	slli	a5,s5,0x8
40024560:	ff95f593          	andi	a1,a1,-7
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
40024564:	0025e593          	ori	a1,a1,2
40024568:	06b49a23          	sh	a1,116(s1)
4002456c:	00d12223          	sw	a3,4(sp)
40024570:	008a1713          	slli	a4,s4,0x8
40024574:	00912023          	sw	s1,0(sp)
40024578:	008ada93          	srli	s5,s5,0x8
4002457c:	008a5a13          	srli	s4,s4,0x8
40024580:	0724d503          	lhu	a0,114(s1)
40024584:	0157e7b3          	or	a5,a5,s5
40024588:	01476733          	or	a4,a4,s4
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
4002458c:	0035d593          	srli	a1,a1,0x3
40024590:	400248b7          	lui	a7,0x40024
40024594:	01079793          	slli	a5,a5,0x10
40024598:	01071713          	slli	a4,a4,0x10
4002459c:	7a088893          	addi	a7,a7,1952 # 400247a0 <tcp_recv>
400245a0:	00048813          	mv	a6,s1
400245a4:	0107d793          	srli	a5,a5,0x10
400245a8:	01075713          	srli	a4,a4,0x10
400245ac:	000c8693          	mv	a3,s9
400245b0:	00098613          	mv	a2,s3
400245b4:	0075f593          	andi	a1,a1,7
400245b8:	859f40ef          	jal	ra,40018e10 <net_conn_register>
400245bc:	00050913          	mv	s2,a0
	if (ret < 0) {
400245c0:	08054063          	bltz	a0,40024640 <net_tcp_connect+0x190>
	context->user_data = user_data;
400245c4:	06012783          	lw	a5,96(sp)
	conn->connect_cb = cb;
400245c8:	03842223          	sw	s8,36(s0)
	(void)tcp_in(conn, NULL);
400245cc:	00000593          	li	a1,0
	context->user_data = user_data;
400245d0:	00f4a223          	sw	a5,4(s1)
	conn->in_connect = !IS_ENABLED(CONFIG_NET_TEST_PROTOCOL);
400245d4:	23d44783          	lbu	a5,573(s0)
	(void)tcp_in(conn, NULL);
400245d8:	00040513          	mv	a0,s0
	conn->in_connect = !IS_ENABLED(CONFIG_NET_TEST_PROTOCOL);
400245dc:	0027e793          	ori	a5,a5,2
400245e0:	22f40ea3          	sb	a5,573(s0)
	(void)tcp_in(conn, NULL);
400245e4:	da8fe0ef          	jal	ra,40022b8c <tcp_in>
		if ((K_TIMEOUT_EQ(timeout, K_NO_WAIT)) &&
400245e8:	016be7b3          	or	a5,s7,s6
400245ec:	00079863          	bnez	a5,400245fc <net_tcp_connect+0x14c>
400245f0:	22042703          	lw	a4,544(s0)
400245f4:	00400793          	li	a5,4
400245f8:	1af71063          	bne	a4,a5,40024798 <net_tcp_connect+0x2e8>
	return z_impl_k_sem_take(sem, timeout);
400245fc:	000b8593          	mv	a1,s7
40024600:	000b0613          	mv	a2,s6
40024604:	03c40513          	addi	a0,s0,60
40024608:	3a00b0ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
		} else if (k_sem_take(&conn->connect_sem, timeout) != 0 &&
4002460c:	16050e63          	beqz	a0,40024788 <net_tcp_connect+0x2d8>
40024610:	22042703          	lw	a4,544(s0)
40024614:	00400793          	li	a5,4
40024618:	16f70863          	beq	a4,a5,40024788 <net_tcp_connect+0x2d8>
			if (conn->in_connect) {
4002461c:	23d44783          	lbu	a5,573(s0)
40024620:	0027f713          	andi	a4,a5,2
40024624:	00070c63          	beqz	a4,4002463c <net_tcp_connect+0x18c>
				conn->in_connect = false;
40024628:	ffd7f793          	andi	a5,a5,-3
4002462c:	22f40ea3          	sb	a5,573(s0)
				tcp_conn_close(conn, -ETIMEDOUT);
40024630:	f8c00593          	li	a1,-116
40024634:	00040513          	mv	a0,s0
40024638:	a89fc0ef          	jal	ra,400210c0 <tcp_conn_close.isra.0>
			ret = -ETIMEDOUT;
4002463c:	f8c00913          	li	s2,-116
}
40024640:	05c12083          	lw	ra,92(sp)
40024644:	05812403          	lw	s0,88(sp)
40024648:	05412483          	lw	s1,84(sp)
4002464c:	04c12983          	lw	s3,76(sp)
40024650:	04812a03          	lw	s4,72(sp)
40024654:	04412a83          	lw	s5,68(sp)
40024658:	04012b03          	lw	s6,64(sp)
4002465c:	03c12b83          	lw	s7,60(sp)
40024660:	03812c03          	lw	s8,56(sp)
40024664:	03412c83          	lw	s9,52(sp)
40024668:	03012d03          	lw	s10,48(sp)
4002466c:	02c12d83          	lw	s11,44(sp)
40024670:	00090513          	mv	a0,s2
40024674:	05012903          	lw	s2,80(sp)
40024678:	06010113          	addi	sp,sp,96
4002467c:	00008067          	ret
		memset(&conn->src, 0, sizeof(struct sockaddr_in));
40024680:	00800613          	li	a2,8
40024684:	00000593          	li	a1,0
40024688:	000d0513          	mv	a0,s10
4002468c:	e90e80ef          	jal	ra,4000cd1c <memset>
		memset(&conn->dst, 0, sizeof(struct sockaddr_in));
40024690:	00800613          	li	a2,8
40024694:	00000593          	li	a1,0
40024698:	000d8513          	mv	a0,s11
4002469c:	e80e80ef          	jal	ra,4000cd1c <memset>
		conn->src.sa.sa_family = AF_INET;
400246a0:	1f241023          	sh	s2,480(s0)
		conn->dst.sa.sa_family = AF_INET;
400246a4:	1f241c23          	sh	s2,504(s0)
		conn->dst.sin.sin_port = remote_port;
400246a8:	1f441d23          	sh	s4,506(s0)
		conn->src.sin.sin_port = local_port;
400246ac:	1f541123          	sh	s5,482(s0)
		ip4 = net_if_ipv4_select_src_addr(
400246b0:	07648503          	lb	a0,118(s1)
400246b4:	848fc0ef          	jal	ra,400206fc <net_context_get_iface.isra.0>
400246b8:	00498593          	addi	a1,s3,4
400246bc:	ad1ee0ef          	jal	ra,4001318c <net_if_ipv4_select_src_addr>
		conn->src.sin.sin_addr = *ip4;
400246c0:	00052783          	lw	a5,0(a0)
400246c4:	1ef42223          	sw	a5,484(s0)
		net_ipaddr_copy(&conn->dst.sin.sin_addr,
400246c8:	0059c783          	lbu	a5,5(s3)
400246cc:	0049c703          	lbu	a4,4(s3)
400246d0:	00879793          	slli	a5,a5,0x8
400246d4:	00e7e7b3          	or	a5,a5,a4
400246d8:	0069c703          	lbu	a4,6(s3)
400246dc:	01071713          	slli	a4,a4,0x10
400246e0:	00f76733          	or	a4,a4,a5
400246e4:	0079c783          	lbu	a5,7(s3)
400246e8:	1ee40e23          	sb	a4,508(s0)
400246ec:	01879793          	slli	a5,a5,0x18
400246f0:	00e7e7b3          	or	a5,a5,a4
400246f4:	0087d713          	srli	a4,a5,0x8
400246f8:	1ee40ea3          	sb	a4,509(s0)
400246fc:	0107d713          	srli	a4,a5,0x10
40024700:	0187d793          	srli	a5,a5,0x18
40024704:	1ee40f23          	sb	a4,510(s0)
40024708:	1ef40fa3          	sb	a5,511(s0)
		break;
4002470c:	e39ff06f          	j	40024544 <net_tcp_connect+0x94>
		memset(&conn->src, 0, sizeof(struct sockaddr_in6));
40024710:	01800613          	li	a2,24
40024714:	00000593          	li	a1,0
40024718:	000d0513          	mv	a0,s10
4002471c:	e00e80ef          	jal	ra,4000cd1c <memset>
		memset(&conn->dst, 0, sizeof(struct sockaddr_in6));
40024720:	01800613          	li	a2,24
40024724:	00000593          	li	a1,0
40024728:	000d8513          	mv	a0,s11
4002472c:	df0e80ef          	jal	ra,4000cd1c <memset>
		conn->src.sin6.sin6_family = AF_INET6;
40024730:	1f241023          	sh	s2,480(s0)
		conn->dst.sin6.sin6_family = AF_INET6;
40024734:	1f241c23          	sh	s2,504(s0)
		conn->dst.sin6.sin6_port = remote_port;
40024738:	1f441d23          	sh	s4,506(s0)
		conn->src.sin6.sin6_port = local_port;
4002473c:	1f541123          	sh	s5,482(s0)
		ip6 = net_if_ipv6_select_src_addr(
40024740:	07648503          	lb	a0,118(s1)
					&net_sin6(remote_addr)->sin6_addr);
40024744:	00498913          	addi	s2,s3,4
		ip6 = net_if_ipv6_select_src_addr(
40024748:	fb5fb0ef          	jal	ra,400206fc <net_context_get_iface.isra.0>
4002474c:	00090593          	mv	a1,s2
40024750:	d38ee0ef          	jal	ra,40012c88 <net_if_ipv6_select_src_addr>
40024754:	00050593          	mv	a1,a0
		conn->src.sin6.sin6_addr = *ip6;
40024758:	01000613          	li	a2,16
4002475c:	1e440513          	addi	a0,s0,484
40024760:	d98e80ef          	jal	ra,4000ccf8 <memcpy>
		net_ipaddr_copy(&conn->dst.sin6.sin6_addr,
40024764:	00090593          	mv	a1,s2
40024768:	01000613          	li	a2,16
4002476c:	01010513          	addi	a0,sp,16
40024770:	d88e80ef          	jal	ra,4000ccf8 <memcpy>
40024774:	01000613          	li	a2,16
40024778:	01010593          	addi	a1,sp,16
4002477c:	1fc40513          	addi	a0,s0,508
40024780:	d78e80ef          	jal	ra,4000ccf8 <memcpy>
		break;
40024784:	dc1ff06f          	j	40024544 <net_tcp_connect+0x94>
		conn->in_connect = false;
40024788:	23d44783          	lbu	a5,573(s0)
4002478c:	ffd7f793          	andi	a5,a5,-3
40024790:	22f40ea3          	sb	a5,573(s0)
40024794:	eadff06f          	j	40024640 <net_tcp_connect+0x190>
			ret = -EINPROGRESS;
40024798:	f8900913          	li	s2,-119
	return ret;
4002479c:	ea5ff06f          	j	40024640 <net_tcp_connect+0x190>

400247a0 <tcp_recv>:
{
400247a0:	fa010113          	addi	sp,sp,-96
400247a4:	04812c23          	sw	s0,88(sp)
400247a8:	05212823          	sw	s2,80(sp)
400247ac:	05412423          	sw	s4,72(sp)
400247b0:	04112e23          	sw	ra,92(sp)
400247b4:	04912a23          	sw	s1,84(sp)
400247b8:	05312623          	sw	s3,76(sp)
400247bc:	05512223          	sw	s5,68(sp)
400247c0:	05612023          	sw	s6,64(sp)
400247c4:	06010413          	addi	s0,sp,96
	return list->head;
400247c8:	400397b7          	lui	a5,0x40039
400247cc:	0c87a483          	lw	s1,200(a5) # 400390c8 <tcp_conns>
400247d0:	00058913          	mv	s2,a1
400247d4:	00070a13          	mv	s4,a4
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp_conns, conn, tmp, next) {
400247d8:	00048663          	beqz	s1,400247e4 <tcp_recv+0x44>
	return node->next;
400247dc:	0004a983          	lw	s3,0(s1)
400247e0:	12049863          	bnez	s1,40024910 <tcp_recv+0x170>
	th = th_get(pkt);
400247e4:	00090513          	mv	a0,s2
400247e8:	f19fb0ef          	jal	ra,40020700 <th_get>
	if (th_flags(th) & SYN && !(th_flags(th) & ACK)) {
400247ec:	00d54983          	lbu	s3,13(a0)
400247f0:	0029f793          	andi	a5,s3,2
400247f4:	0e078663          	beqz	a5,400248e0 <tcp_recv+0x140>
400247f8:	0109f993          	andi	s3,s3,16
400247fc:	0e099263          	bnez	s3,400248e0 <tcp_recv+0x140>
		struct tcp *conn_old = ((struct net_context *)user_data)->tcp;
40024800:	054a2a83          	lw	s5,84(s4)
	return pkt->family;
40024804:	03492a03          	lw	s4,52(s2)
	struct sockaddr local_addr = { 0 };
40024808:	01800613          	li	a2,24
4002480c:	00000593          	li	a1,0
40024810:	fc840513          	addi	a0,s0,-56
	struct net_context *context = NULL;
40024814:	fa042a23          	sw	zero,-76(s0)
40024818:	01da5a13          	srli	s4,s4,0x1d
	struct sockaddr local_addr = { 0 };
4002481c:	d00e80ef          	jal	ra,4000cd1c <memset>
	ret = net_context_get(af, SOCK_STREAM, IPPROTO_TCP, &context);
40024820:	fb440693          	addi	a3,s0,-76
40024824:	00600613          	li	a2,6
40024828:	00100593          	li	a1,1
4002482c:	000a0513          	mv	a0,s4
40024830:	d08f10ef          	jal	ra,40015d38 <net_context_get>
	if (ret < 0) {
40024834:	12055663          	bgez	a0,40024960 <tcp_recv+0x1c0>
		NET_ERR("net_context_get(): %d", ret);
40024838:	40044737          	lui	a4,0x40044
4002483c:	7a072783          	lw	a5,1952(a4) # 400447a0 <log_dynamic_net_tcp>
40024840:	0077f793          	andi	a5,a5,7
40024844:	04078063          	beqz	a5,40024884 <tcp_recv+0xe4>
40024848:	00010493          	mv	s1,sp
4002484c:	fe010113          	addi	sp,sp,-32
40024850:	00810613          	addi	a2,sp,8
40024854:	400357b7          	lui	a5,0x40035
40024858:	54c78793          	addi	a5,a5,1356 # 4003554c <CSWTCH.16862+0x354>
4002485c:	00f62a23          	sw	a5,20(a2)
40024860:	000025b7          	lui	a1,0x2
40024864:	00300793          	li	a5,3
40024868:	00a62c23          	sw	a0,24(a2)
4002486c:	00f62823          	sw	a5,16(a2)
40024870:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
40024874:	01060613          	addi	a2,a2,16
40024878:	7a070513          	addi	a0,a4,1952
4002487c:	cadfb0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
40024880:	00048113          	mv	sp,s1
	UPDATE_STAT(iface, stats.tcp.conndrop++);
40024884:	4003b7b7          	lui	a5,0x4003b
40024888:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
4002488c:	0887a703          	lw	a4,136(a5)
	return pkt->iface;
40024890:	01892683          	lw	a3,24(s2)
			NET_ERR("Cannot allocate a new TCP connection");
40024894:	40044537          	lui	a0,0x40044
40024898:	00170713          	addi	a4,a4,1
4002489c:	08e7a423          	sw	a4,136(a5)
400248a0:	08c6a783          	lw	a5,140(a3) # ff008c <__rom_region_size+0xfb70d0>
400248a4:	00178793          	addi	a5,a5,1
400248a8:	08f6a623          	sw	a5,140(a3)
400248ac:	7a052783          	lw	a5,1952(a0) # 400447a0 <log_dynamic_net_tcp>
400248b0:	0077f793          	andi	a5,a5,7
400248b4:	02078663          	beqz	a5,400248e0 <tcp_recv+0x140>
400248b8:	400357b7          	lui	a5,0x40035
400248bc:	57c78793          	addi	a5,a5,1404 # 4003557c <CSWTCH.16862+0x384>
400248c0:	fcf42e23          	sw	a5,-36(s0)
400248c4:	000015b7          	lui	a1,0x1
400248c8:	00200793          	li	a5,2
400248cc:	fcf42c23          	sw	a5,-40(s0)
400248d0:	fd840613          	addi	a2,s0,-40
400248d4:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
400248d8:	7a050513          	addi	a0,a0,1952
400248dc:	c4dfb0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
	enum net_verdict verdict = NET_DROP;
400248e0:	00200513          	li	a0,2
}
400248e4:	fa040113          	addi	sp,s0,-96
400248e8:	05c12083          	lw	ra,92(sp)
400248ec:	05812403          	lw	s0,88(sp)
400248f0:	05412483          	lw	s1,84(sp)
400248f4:	05012903          	lw	s2,80(sp)
400248f8:	04c12983          	lw	s3,76(sp)
400248fc:	04812a03          	lw	s4,72(sp)
40024900:	04412a83          	lw	s5,68(sp)
40024904:	04012b03          	lw	s6,64(sp)
40024908:	06010113          	addi	sp,sp,96
4002490c:	00008067          	ret
	return tcp_endpoint_cmp(&conn->src, pkt, TCP_EP_DST) &&
40024910:	00000613          	li	a2,0
40024914:	00090593          	mv	a1,s2
40024918:	1e048513          	addi	a0,s1,480
4002491c:	9acfc0ef          	jal	ra,40020ac8 <tcp_endpoint_cmp>
40024920:	00051e63          	bnez	a0,4002493c <tcp_recv+0x19c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp_conns, conn, tmp, next) {
40024924:	00000793          	li	a5,0
40024928:	00098463          	beqz	s3,40024930 <tcp_recv+0x190>
4002492c:	0009a783          	lw	a5,0(s3)
40024930:	00098493          	mv	s1,s3
40024934:	00078993          	mv	s3,a5
40024938:	ea9ff06f          	j	400247e0 <tcp_recv+0x40>
		tcp_endpoint_cmp(&conn->dst, pkt, TCP_EP_SRC);
4002493c:	00100613          	li	a2,1
40024940:	00090593          	mv	a1,s2
40024944:	1f848513          	addi	a0,s1,504
40024948:	980fc0ef          	jal	ra,40020ac8 <tcp_endpoint_cmp>
	return tcp_endpoint_cmp(&conn->src, pkt, TCP_EP_DST) &&
4002494c:	fc050ce3          	beqz	a0,40024924 <tcp_recv+0x184>
		verdict = tcp_in(conn, pkt);
40024950:	00090593          	mv	a1,s2
40024954:	00048513          	mv	a0,s1
40024958:	a34fe0ef          	jal	ra,40022b8c <tcp_in>
	return verdict;
4002495c:	f89ff06f          	j	400248e4 <tcp_recv+0x144>
	conn = context->tcp;
40024960:	fb442783          	lw	a5,-76(s0)
40024964:	0547a483          	lw	s1,84(a5)
	conn->iface = pkt->iface;
40024968:	01892783          	lw	a5,24(s2)
	tcp_derive_rto(conn);
4002496c:	00048513          	mv	a0,s1
	conn->iface = pkt->iface;
40024970:	00f4a823          	sw	a5,16(s1)
	tcp_derive_rto(conn);
40024974:	985fb0ef          	jal	ra,400202f8 <tcp_derive_rto>
	return pkt->family;
40024978:	03492783          	lw	a5,52(s2)
	if (family == AF_UNSPEC || family == AF_INET || family == AF_INET6 ||
4002497c:	00400693          	li	a3,4
	net_context_set_family(conn->context, net_pkt_family(pkt));
40024980:	0044a703          	lw	a4,4(s1)
40024984:	01d7d793          	srli	a5,a5,0x1d
40024988:	00f6e463          	bltu	a3,a5,40024990 <tcp_recv+0x1f0>
		flag = family << 3;
4002498c:	00379993          	slli	s3,a5,0x3
	context->flags |= flag;
40024990:	07475783          	lhu	a5,116(a4)
	if (tcp_endpoint_set(&conn->dst, pkt, TCP_EP_SRC) < 0) {
40024994:	1f848b13          	addi	s6,s1,504
40024998:	00100613          	li	a2,1
4002499c:	00f9e9b3          	or	s3,s3,a5
400249a0:	07371a23          	sh	s3,116(a4)
400249a4:	00090593          	mv	a1,s2
400249a8:	000b0513          	mv	a0,s6
400249ac:	f35fb0ef          	jal	ra,400208e0 <tcp_endpoint_set>
400249b0:	00055663          	bgez	a0,400249bc <tcp_recv+0x21c>
		net_context_put(context);
400249b4:	fb442503          	lw	a0,-76(s0)
400249b8:	0200006f          	j	400249d8 <tcp_recv+0x238>
	if (tcp_endpoint_set(&conn->src, pkt, TCP_EP_DST) < 0) {
400249bc:	00000613          	li	a2,0
400249c0:	00090593          	mv	a1,s2
400249c4:	1e048513          	addi	a0,s1,480
400249c8:	f19fb0ef          	jal	ra,400208e0 <tcp_endpoint_set>
400249cc:	00050793          	mv	a5,a0
400249d0:	fb442503          	lw	a0,-76(s0)
400249d4:	0007d663          	bgez	a5,400249e0 <tcp_recv+0x240>
		net_context_put(context);
400249d8:	e3cf10ef          	jal	ra,40016014 <net_context_put>
	if (!conn) {
400249dc:	ea9ff06f          	j	40024884 <tcp_recv+0xe4>
	memcpy(&context->remote, &conn->dst, sizeof(context->remote));
400249e0:	01800613          	li	a2,24
400249e4:	000b0593          	mv	a1,s6
400249e8:	02c50513          	addi	a0,a0,44
400249ec:	b0ce80ef          	jal	ra,4000ccf8 <memcpy>
	context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
400249f0:	fb442983          	lw	s3,-76(s0)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
400249f4:	00200713          	li	a4,2
	context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
400249f8:	0749d783          	lhu	a5,116(s3)
	net_sin_ptr(&context->local)->sin_family = af;
400249fc:	03499023          	sh	s4,32(s3)
	context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
40024a00:	1007e793          	ori	a5,a5,256
40024a04:	06f99a23          	sh	a5,116(s3)
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40024a08:	0037d793          	srli	a5,a5,0x3
40024a0c:	0077f793          	andi	a5,a5,7
	local_addr.sa_family = net_context_get_family(context);
40024a10:	fcf41423          	sh	a5,-56(s0)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40024a14:	04e79463          	bne	a5,a4,40024a5c <tcp_recv+0x2bc>
		if (net_sin6_ptr(&context->local)->sin6_addr) {
40024a18:	0249a583          	lw	a1,36(s3)
40024a1c:	02058063          	beqz	a1,40024a3c <tcp_recv+0x29c>
			net_ipaddr_copy(&net_sin6(&local_addr)->sin6_addr,
40024a20:	01000613          	li	a2,16
40024a24:	fb840513          	addi	a0,s0,-72
40024a28:	ad0e80ef          	jal	ra,4000ccf8 <memcpy>
40024a2c:	01000613          	li	a2,16
40024a30:	fb840593          	addi	a1,s0,-72
40024a34:	fcc40513          	addi	a0,s0,-52
40024a38:	ac0e80ef          	jal	ra,4000ccf8 <memcpy>
	ret = net_context_bind(context, &local_addr, sizeof(local_addr));
40024a3c:	fc840593          	addi	a1,s0,-56
40024a40:	01800613          	li	a2,24
40024a44:	00098513          	mv	a0,s3
40024a48:	e58f10ef          	jal	ra,400160a0 <net_context_bind>
	if (ret < 0) {
40024a4c:	fb442583          	lw	a1,-76(s0)
40024a50:	04055663          	bgez	a0,40024a9c <tcp_recv+0x2fc>
		net_context_put(context);
40024a54:	00058513          	mv	a0,a1
40024a58:	f81ff06f          	j	400249d8 <tcp_recv+0x238>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40024a5c:	00100713          	li	a4,1
40024a60:	fce79ee3          	bne	a5,a4,40024a3c <tcp_recv+0x29c>
		if (net_sin_ptr(&context->local)->sin_addr) {
40024a64:	0249a783          	lw	a5,36(s3)
40024a68:	fc078ae3          	beqz	a5,40024a3c <tcp_recv+0x29c>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
40024a6c:	0017c683          	lbu	a3,1(a5)
40024a70:	0007c703          	lbu	a4,0(a5)
40024a74:	00869693          	slli	a3,a3,0x8
40024a78:	00e6e6b3          	or	a3,a3,a4
40024a7c:	0027c703          	lbu	a4,2(a5)
40024a80:	0037c783          	lbu	a5,3(a5)
40024a84:	01071713          	slli	a4,a4,0x10
40024a88:	00d76733          	or	a4,a4,a3
40024a8c:	01879793          	slli	a5,a5,0x18
40024a90:	00e7e7b3          	or	a5,a5,a4
40024a94:	fcf42623          	sw	a5,-52(s0)
40024a98:	fa5ff06f          	j	40024a3c <tcp_recv+0x29c>
		conn->seq = tcp_init_isn(&local_addr, &context->remote);
40024a9c:	02c58593          	addi	a1,a1,44
40024aa0:	fc840513          	addi	a0,s0,-56
40024aa4:	f24fc0ef          	jal	ra,400211c8 <tcp_init_isn>
	ret = net_conn_register(IPPROTO_TCP, af,
40024aa8:	1e24d703          	lhu	a4,482(s1)
40024aac:	1fa4d683          	lhu	a3,506(s1)
				&context->remote, &local_addr,
40024ab0:	fb442803          	lw	a6,-76(s0)
	ret = net_conn_register(IPPROTO_TCP, af,
40024ab4:	00871793          	slli	a5,a4,0x8
40024ab8:	00875713          	srli	a4,a4,0x8
40024abc:	00e7e7b3          	or	a5,a5,a4
40024ac0:	00869713          	slli	a4,a3,0x8
40024ac4:	0086d693          	srli	a3,a3,0x8
40024ac8:	00d76733          	or	a4,a4,a3
		conn->seq = tcp_init_isn(&local_addr, &context->remote);
40024acc:	22a4a423          	sw	a0,552(s1)
	ret = net_conn_register(IPPROTO_TCP, af,
40024ad0:	04480693          	addi	a3,a6,68
40024ad4:	400248b7          	lui	a7,0x40024
40024ad8:	01079793          	slli	a5,a5,0x10
40024adc:	01071713          	slli	a4,a4,0x10
40024ae0:	00d12223          	sw	a3,4(sp)
40024ae4:	01012023          	sw	a6,0(sp)
40024ae8:	7a088893          	addi	a7,a7,1952 # 400247a0 <tcp_recv>
40024aec:	0107d793          	srli	a5,a5,0x10
40024af0:	01075713          	srli	a4,a4,0x10
40024af4:	fc840693          	addi	a3,s0,-56
40024af8:	02c80613          	addi	a2,a6,44
40024afc:	000a0593          	mv	a1,s4
40024b00:	00600513          	li	a0,6
40024b04:	b0cf40ef          	jal	ra,40018e10 <net_conn_register>
	if (ret < 0) {
40024b08:	04055a63          	bgez	a0,40024b5c <tcp_recv+0x3bc>
		NET_ERR("net_conn_register(): %d", ret);
40024b0c:	40044737          	lui	a4,0x40044
40024b10:	7a072783          	lw	a5,1952(a4) # 400447a0 <log_dynamic_net_tcp>
40024b14:	0077f793          	andi	a5,a5,7
40024b18:	e8078ee3          	beqz	a5,400249b4 <tcp_recv+0x214>
40024b1c:	00010493          	mv	s1,sp
40024b20:	fe010113          	addi	sp,sp,-32
40024b24:	00810613          	addi	a2,sp,8
40024b28:	400357b7          	lui	a5,0x40035
40024b2c:	56478793          	addi	a5,a5,1380 # 40035564 <CSWTCH.16862+0x36c>
40024b30:	00f62a23          	sw	a5,20(a2)
40024b34:	000025b7          	lui	a1,0x2
40024b38:	00300793          	li	a5,3
40024b3c:	00a62c23          	sw	a0,24(a2)
40024b40:	00f62823          	sw	a5,16(a2)
40024b44:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
40024b48:	01060613          	addi	a2,a2,16
40024b4c:	7a070513          	addi	a0,a4,1952
40024b50:	9d9fb0ef          	jal	ra,40020528 <z_log_msg_static_create.constprop.0>
40024b54:	00048113          	mv	sp,s1
40024b58:	e5dff06f          	j	400249b4 <tcp_recv+0x214>
		net_ipaddr_copy(&conn_old->context->remote, &conn->dst.sa);
40024b5c:	004aa983          	lw	s3,4(s5)
40024b60:	01800613          	li	a2,24
40024b64:	000b0593          	mv	a1,s6
40024b68:	fc840513          	addi	a0,s0,-56
40024b6c:	98ce80ef          	jal	ra,4000ccf8 <memcpy>
40024b70:	01800613          	li	a2,24
40024b74:	fc840593          	addi	a1,s0,-56
40024b78:	02c98513          	addi	a0,s3,44
40024b7c:	97ce80ef          	jal	ra,4000ccf8 <memcpy>
		conn->accepted_conn = conn_old;
40024b80:	0354a023          	sw	s5,32(s1)
	if (conn) {
40024b84:	dcdff06f          	j	40024950 <tcp_recv+0x1b0>

40024b88 <net_tcp_state_str>:
	switch (state) {
40024b88:	fff50513          	addi	a0,a0,-1
40024b8c:	00a00793          	li	a5,10
40024b90:	02a7e063          	bltu	a5,a0,40024bb0 <net_tcp_state_str+0x28>
40024b94:	400357b7          	lui	a5,0x40035
40024b98:	00251513          	slli	a0,a0,0x2
40024b9c:	66078793          	addi	a5,a5,1632 # 40035660 <CSWTCH.15846>
40024ba0:	00a787b3          	add	a5,a5,a0
40024ba4:	0007a503          	lw	a0,0(a5)
}

const char *net_tcp_state_str(enum tcp_state state)
{
	return tcp_state_to_str(state, false);
}
40024ba8:	00450513          	addi	a0,a0,4
40024bac:	00008067          	ret
{
40024bb0:	00000513          	li	a0,0
40024bb4:	ff5ff06f          	j	40024ba8 <net_tcp_state_str+0x20>

40024bb8 <net_tcp_init>:

	return &conn->connect_sem;
}

void net_tcp_init(void)
{
40024bb8:	ff010113          	addi	sp,sp,-16
40024bbc:	00812423          	sw	s0,8(sp)
#define THREAD_PRIORITY K_PRIO_PREEMPT(0)
#endif

	/* Use private workqueue in order not to block the system work queue.
	 */
	k_work_queue_start(&tcp_work_q, work_q_stack,
40024bc0:	4003c5b7          	lui	a1,0x4003c
40024bc4:	4003a437          	lui	s0,0x4003a
40024bc8:	00000713          	li	a4,0
40024bcc:	ff000693          	li	a3,-16
40024bd0:	40000613          	li	a2,1024
40024bd4:	5d058593          	addi	a1,a1,1488 # 4003c5d0 <work_q_stack>
40024bd8:	c7040513          	addi	a0,s0,-912 # 40039c70 <tcp_work_q>
{
40024bdc:	00112623          	sw	ra,12(sp)
	k_work_queue_start(&tcp_work_q, work_q_stack,
40024be0:	3740b0ef          	jal	ra,4002ff54 <k_work_queue_start>
40024be4:	00900693          	li	a3,9
40024be8:	00000793          	li	a5,0
			   K_KERNEL_STACK_SIZEOF(work_q_stack), THREAD_PRIORITY,
			   NULL);

	/* Compute the largest possible retransmission timeout */
	tcp_fin_timeout_ms = 0;
	rto = tcp_rto;
40024bec:	0c800713          	li	a4,200
	for (i = 0; i < tcp_retries; i++) {
		tcp_fin_timeout_ms += rto;
		rto += rto >> 1;
40024bf0:	40175613          	srai	a2,a4,0x1
	for (i = 0; i < tcp_retries; i++) {
40024bf4:	fff68693          	addi	a3,a3,-1
		tcp_fin_timeout_ms += rto;
40024bf8:	00e787b3          	add	a5,a5,a4
		rto += rto >> 1;
40024bfc:	00c70733          	add	a4,a4,a2
	for (i = 0; i < tcp_retries; i++) {
40024c00:	fe0698e3          	bnez	a3,40024bf0 <net_tcp_init+0x38>
	}
	/* At the last timeout cicle */
	tcp_fin_timeout_ms += tcp_rto;
40024c04:	0c878793          	addi	a5,a5,200

	/* When CONFIG_NET_TCP_RANDOMIZED_RTO is active in can be worse case 1.5 times larger */
	if (IS_ENABLED(CONFIG_NET_TCP_RANDOMIZED_RTO)) {
		tcp_fin_timeout_ms += tcp_fin_timeout_ms >> 1;
40024c08:	4017d713          	srai	a4,a5,0x1
40024c0c:	00f707b3          	add	a5,a4,a5
40024c10:	40039737          	lui	a4,0x40039
40024c14:	0cf72823          	sw	a5,208(a4) # 400390d0 <tcp_fin_timeout_ms>
	return z_impl_k_thread_name_set(thread, str);
40024c18:	c7040513          	addi	a0,s0,-912
	}

	k_thread_name_set(&tcp_work_q.thread, "tcp_work");
	NET_DBG("Workq started. Thread ID: %p", &tcp_work_q.thread);
}
40024c1c:	00812403          	lw	s0,8(sp)
40024c20:	00c12083          	lw	ra,12(sp)
40024c24:	400355b7          	lui	a1,0x40035
40024c28:	5a458593          	addi	a1,a1,1444 # 400355a4 <CSWTCH.16862+0x3ac>
40024c2c:	01010113          	addi	sp,sp,16
40024c30:	0b40a06f          	j	4002ece4 <z_impl_k_thread_name_set>

40024c34 <net_udp_create>:
#include "net_stats.h"

#define PKT_WAIT_TIME K_SECONDS(1)

int net_udp_create(struct net_pkt *pkt, uint16_t src_port, uint16_t dst_port)
{
40024c34:	fe010113          	addi	sp,sp,-32
40024c38:	00912a23          	sw	s1,20(sp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
40024c3c:	00800793          	li	a5,8
{
40024c40:	00058493          	mv	s1,a1
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
40024c44:	00810593          	addi	a1,sp,8
{
40024c48:	00812c23          	sw	s0,24(sp)
40024c4c:	01212823          	sw	s2,16(sp)
40024c50:	00112e23          	sw	ra,28(sp)
40024c54:	00050913          	mv	s2,a0
40024c58:	00060413          	mv	s0,a2
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
40024c5c:	00212423          	sw	sp,8(sp)
40024c60:	00f12623          	sw	a5,12(sp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
40024c64:	c85f30ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!udp_hdr) {
40024c68:	04050863          	beqz	a0,40024cb8 <net_udp_create+0x84>
		return -ENOBUFS;
	}

	udp_hdr->src_port = src_port;
40024c6c:	00950023          	sb	s1,0(a0)
	udp_hdr->dst_port = dst_port;
40024c70:	00850123          	sb	s0,2(a0)
	udp_hdr->src_port = src_port;
40024c74:	0084d493          	srli	s1,s1,0x8
	udp_hdr->dst_port = dst_port;
40024c78:	00845413          	srli	s0,s0,0x8
	udp_hdr->src_port = src_port;
40024c7c:	009500a3          	sb	s1,1(a0)
	udp_hdr->dst_port = dst_port;
40024c80:	008501a3          	sb	s0,3(a0)
	udp_hdr->len      = 0U;
40024c84:	00050223          	sb	zero,4(a0)
40024c88:	000502a3          	sb	zero,5(a0)
	udp_hdr->chksum   = 0U;
40024c8c:	00050323          	sb	zero,6(a0)
40024c90:	000503a3          	sb	zero,7(a0)

	return net_pkt_set_data(pkt, &udp_access);
40024c94:	00810593          	addi	a1,sp,8
40024c98:	00090513          	mv	a0,s2
40024c9c:	d1df30ef          	jal	ra,400189b8 <net_pkt_set_data>
}
40024ca0:	01c12083          	lw	ra,28(sp)
40024ca4:	01812403          	lw	s0,24(sp)
40024ca8:	01412483          	lw	s1,20(sp)
40024cac:	01012903          	lw	s2,16(sp)
40024cb0:	02010113          	addi	sp,sp,32
40024cb4:	00008067          	ret
		return -ENOBUFS;
40024cb8:	f9700513          	li	a0,-105
40024cbc:	fe5ff06f          	j	40024ca0 <net_udp_create+0x6c>

40024cc0 <net_udp_finalize>:

int net_udp_finalize(struct net_pkt *pkt)
{
40024cc0:	fe010113          	addi	sp,sp,-32
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
40024cc4:	00800793          	li	a5,8
	struct net_udp_hdr *udp_hdr;
	uint16_t length = 0;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
40024cc8:	00810593          	addi	a1,sp,8
{
40024ccc:	00812c23          	sw	s0,24(sp)
40024cd0:	00112e23          	sw	ra,28(sp)
40024cd4:	00912a23          	sw	s1,20(sp)
40024cd8:	00050413          	mv	s0,a0
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
40024cdc:	00212423          	sw	sp,8(sp)
40024ce0:	00f12623          	sw	a5,12(sp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
40024ce4:	c05f30ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!udp_hdr) {
40024ce8:	0a050663          	beqz	a0,40024d94 <net_udp_finalize+0xd4>
40024cec:	00842703          	lw	a4,8(s0)
40024cf0:	00050493          	mv	s1,a0
	size_t bytes = 0;
40024cf4:	00000793          	li	a5,0
	while (buf) {
40024cf8:	08071663          	bnez	a4,40024d84 <net_udp_finalize+0xc4>
		return -ENOBUFS;
	}

	length = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -
40024cfc:	03644683          	lbu	a3,54(s0)
40024d00:	03a45703          	lhu	a4,58(s0)
40024d04:	00d70733          	add	a4,a4,a3
40024d08:	40e787b3          	sub	a5,a5,a4
		 net_pkt_ip_opts_len(pkt);

	udp_hdr->len = htons(length);
40024d0c:	00879713          	slli	a4,a5,0x8
40024d10:	01079793          	slli	a5,a5,0x10
40024d14:	0107d793          	srli	a5,a5,0x10
40024d18:	0087d793          	srli	a5,a5,0x8
40024d1c:	00f767b3          	or	a5,a4,a5
40024d20:	01079713          	slli	a4,a5,0x10
40024d24:	01075713          	srli	a4,a4,0x10
40024d28:	00f48223          	sb	a5,4(s1)
40024d2c:	00875793          	srli	a5,a4,0x8
40024d30:	00f482a3          	sb	a5,5(s1)

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
40024d34:	01842503          	lw	a0,24(s0)
40024d38:	e19ee0ef          	jal	ra,40013b50 <net_if_need_calc_tx_checksum>
40024d3c:	02050463          	beqz	a0,40024d64 <net_udp_finalize+0xa4>
	uint16_t chksum = net_calc_chksum(pkt, IPPROTO_UDP);
40024d40:	01100593          	li	a1,17
40024d44:	00040513          	mv	a0,s0
40024d48:	9a8f00ef          	jal	ra,40014ef0 <net_calc_chksum>
	return chksum == 0U ? 0xffff : chksum;
40024d4c:	00051663          	bnez	a0,40024d58 <net_udp_finalize+0x98>
40024d50:	000107b7          	lui	a5,0x10
40024d54:	fff78513          	addi	a0,a5,-1 # ffff <__kernel_ram_size+0x44f7>
		udp_hdr->chksum = net_calc_chksum_udp(pkt);
40024d58:	00855793          	srli	a5,a0,0x8
40024d5c:	00a48323          	sb	a0,6(s1)
40024d60:	00f483a3          	sb	a5,7(s1)
	}

	return net_pkt_set_data(pkt, &udp_access);
40024d64:	00810593          	addi	a1,sp,8
40024d68:	00040513          	mv	a0,s0
40024d6c:	c4df30ef          	jal	ra,400189b8 <net_pkt_set_data>
}
40024d70:	01c12083          	lw	ra,28(sp)
40024d74:	01812403          	lw	s0,24(sp)
40024d78:	01412483          	lw	s1,20(sp)
40024d7c:	02010113          	addi	sp,sp,32
40024d80:	00008067          	ret
		bytes += buf->len;
40024d84:	01075683          	lhu	a3,16(a4)
		buf = buf->frags;
40024d88:	00472703          	lw	a4,4(a4)
		bytes += buf->len;
40024d8c:	00d787b3          	add	a5,a5,a3
		buf = buf->frags;
40024d90:	f69ff06f          	j	40024cf8 <net_udp_finalize+0x38>
		return -ENOBUFS;
40024d94:	f9700513          	li	a0,-105
40024d98:	fd9ff06f          	j	40024d70 <net_udp_finalize+0xb0>

40024d9c <net_udp_input>:
	return net_conn_unregister(handle);
}

struct net_udp_hdr *net_udp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *udp_access)
{
40024d9c:	ff010113          	addi	sp,sp,-16
40024da0:	00912223          	sw	s1,4(sp)
40024da4:	01212023          	sw	s2,0(sp)
40024da8:	00112623          	sw	ra,12(sp)
40024dac:	00812423          	sw	s0,8(sp)
40024db0:	00050493          	mv	s1,a0
40024db4:	00058913          	mv	s2,a1
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);
40024db8:	b31f30ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
40024dbc:	04051463          	bnez	a0,40024e04 <net_udp_input+0x68>
	UPDATE_STAT(iface, stats.udp.chkerr++);
40024dc0:	4003b7b7          	lui	a5,0x4003b
40024dc4:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40024dc8:	09c7a703          	lw	a4,156(a5)
	return pkt->iface;
40024dcc:	0184a683          	lw	a3,24(s1)
	}
out:
	return udp_hdr;
drop:
	net_stats_update_udp_chkerr(net_pkt_iface(pkt));
	return NULL;
40024dd0:	00000413          	li	s0,0
40024dd4:	00170713          	addi	a4,a4,1
40024dd8:	08e7ae23          	sw	a4,156(a5)
40024ddc:	0a06a783          	lw	a5,160(a3)
40024de0:	00178793          	addi	a5,a5,1
40024de4:	0af6a023          	sw	a5,160(a3)
}
40024de8:	00c12083          	lw	ra,12(sp)
40024dec:	00040513          	mv	a0,s0
40024df0:	00812403          	lw	s0,8(sp)
40024df4:	00412483          	lw	s1,4(sp)
40024df8:	00012903          	lw	s2,0(sp)
40024dfc:	01010113          	addi	sp,sp,16
40024e00:	00008067          	ret
40024e04:	00050413          	mv	s0,a0
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
40024e08:	00090593          	mv	a1,s2
40024e0c:	00048513          	mv	a0,s1
40024e10:	ba9f30ef          	jal	ra,400189b8 <net_pkt_set_data>
40024e14:	fa0516e3          	bnez	a0,40024dc0 <net_udp_input+0x24>
	if (ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -
40024e18:	00544783          	lbu	a5,5(s0)
40024e1c:	00444703          	lbu	a4,4(s0)
40024e20:	0084a683          	lw	a3,8(s1)
40024e24:	00879793          	slli	a5,a5,0x8
40024e28:	00e7e7b3          	or	a5,a5,a4
40024e2c:	00879713          	slli	a4,a5,0x8
40024e30:	0087d793          	srli	a5,a5,0x8
40024e34:	00f76733          	or	a4,a4,a5
40024e38:	01071713          	slli	a4,a4,0x10
40024e3c:	01075713          	srli	a4,a4,0x10
	size_t bytes = 0;
40024e40:	00000793          	li	a5,0
	while (buf) {
40024e44:	04069663          	bnez	a3,40024e90 <net_udp_input+0xf4>
				    net_pkt_ip_hdr_len(pkt) -
40024e48:	0364c683          	lbu	a3,54(s1)
				    net_pkt_ip_opts_len(pkt))) {
40024e4c:	03a4d603          	lhu	a2,58(s1)
40024e50:	0184a503          	lw	a0,24(s1)
				    net_pkt_ip_hdr_len(pkt) -
40024e54:	00c686b3          	add	a3,a3,a2
40024e58:	40d787b3          	sub	a5,a5,a3
	if (ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -
40024e5c:	f6f712e3          	bne	a4,a5,40024dc0 <net_udp_input+0x24>
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
40024e60:	cf9ee0ef          	jal	ra,40013b58 <net_if_need_calc_rx_checksum>
	if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
40024e64:	f80502e3          	beqz	a0,40024de8 <net_udp_input+0x4c>
		if (!udp_hdr->chksum) {
40024e68:	00744783          	lbu	a5,7(s0)
40024e6c:	00644703          	lbu	a4,6(s0)
40024e70:	00879793          	slli	a5,a5,0x8
40024e74:	00e7e7b3          	or	a5,a5,a4
40024e78:	f40784e3          	beqz	a5,40024dc0 <net_udp_input+0x24>
	return net_calc_chksum(pkt, IPPROTO_UDP);
40024e7c:	01100593          	li	a1,17
40024e80:	00048513          	mv	a0,s1
40024e84:	86cf00ef          	jal	ra,40014ef0 <net_calc_chksum>
		if (net_calc_verify_chksum_udp(pkt) != 0U) {
40024e88:	f60500e3          	beqz	a0,40024de8 <net_udp_input+0x4c>
40024e8c:	f35ff06f          	j	40024dc0 <net_udp_input+0x24>
		bytes += buf->len;
40024e90:	0106d603          	lhu	a2,16(a3)
		buf = buf->frags;
40024e94:	0046a683          	lw	a3,4(a3)
		bytes += buf->len;
40024e98:	00c787b3          	add	a5,a5,a2
		buf = buf->frags;
40024e9c:	fa9ff06f          	j	40024e44 <net_udp_input+0xa8>

40024ea0 <is_pkt_part_of_slab>:
{
	size_t last_offset = (slab->num_blocks - 1) * slab->block_size;
	size_t ptr_offset;

	/* Check if pointer fits into slab buffer area. */
	if ((ptr < slab->buffer) || (ptr > slab->buffer + last_offset)) {
40024ea0:	01052703          	lw	a4,16(a0)
40024ea4:	02e5e863          	bltu	a1,a4,40024ed4 <is_pkt_part_of_slab+0x34>
	size_t last_offset = (slab->num_blocks - 1) * slab->block_size;
40024ea8:	00852783          	lw	a5,8(a0)
40024eac:	00c52683          	lw	a3,12(a0)
		return false;
40024eb0:	00000513          	li	a0,0
	size_t last_offset = (slab->num_blocks - 1) * slab->block_size;
40024eb4:	fff78793          	addi	a5,a5,-1
40024eb8:	02d787b3          	mul	a5,a5,a3
	if ((ptr < slab->buffer) || (ptr > slab->buffer + last_offset)) {
40024ebc:	00f707b3          	add	a5,a4,a5
40024ec0:	00b7ec63          	bltu	a5,a1,40024ed8 <is_pkt_part_of_slab+0x38>
	}

	/* Check if pointer offset is correct. */
	ptr_offset = ptr - slab->buffer;
40024ec4:	40e585b3          	sub	a1,a1,a4
	if (ptr_offset % slab->block_size != 0) {
40024ec8:	02d5f5b3          	remu	a1,a1,a3
40024ecc:	0015b513          	seqz	a0,a1
40024ed0:	00008067          	ret
		return false;
40024ed4:	00000513          	li	a0,0
		return false;
	}

	return true;
}
40024ed8:	00008067          	ret

40024edc <cmd_net_tcp>:
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	return 0;
}
40024edc:	00000513          	li	a0,0
40024ee0:	00008067          	ret

40024ee4 <net_if_get_by_index>:
40024ee4:	c49eb06f          	j	40010b2c <z_impl_net_if_get_by_index>

40024ee8 <nbr_address_get>:
SHELL_DYNAMIC_CMD_CREATE(nbr_address, nbr_address_get);

#define NBR_ADDRESS_CMD &nbr_address

static void nbr_address_get(size_t idx, struct shell_static_entry *entry)
{
40024ee8:	fe010113          	addi	sp,sp,-32
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &nbr_address;
40024eec:	400327b7          	lui	a5,0x40032
{
40024ef0:	00812c23          	sw	s0,24(sp)
40024ef4:	00912a23          	sw	s1,20(sp)
40024ef8:	00112e23          	sw	ra,28(sp)
	entry->subcmd = &nbr_address;
40024efc:	59c78793          	addi	a5,a5,1436 # 4003259c <nbr_address>
	entry->handler = NULL;
40024f00:	0005a623          	sw	zero,12(a1)
	entry->help  = NULL;
40024f04:	0005a223          	sw	zero,4(a1)
	entry->subcmd = &nbr_address;
40024f08:	00f5a423          	sw	a5,8(a1)
{
40024f0c:	00050413          	mv	s0,a0
40024f10:	00058493          	mv	s1,a1
	if (idx == 0) {
40024f14:	04051663          	bnez	a0,40024f60 <nbr_address_get+0x78>
		memset(nbr_address_buffer, 0, sizeof(nbr_address_buffer));
40024f18:	4003b537          	lui	a0,0x4003b
40024f1c:	00000593          	li	a1,0
40024f20:	14000613          	li	a2,320
40024f24:	00450513          	addi	a0,a0,4 # 4003b004 <nbr_address_buffer>
40024f28:	df5e70ef          	jal	ra,4000cd1c <memset>
	net_ipv6_nbr_foreach(nbr_address_cb, &count);
40024f2c:	40025537          	lui	a0,0x40025
40024f30:	00c10593          	addi	a1,sp,12
40024f34:	f8450513          	addi	a0,a0,-124 # 40024f84 <nbr_address_cb>
	int count = 0;
40024f38:	00012623          	sw	zero,12(sp)
	net_ipv6_nbr_foreach(nbr_address_cb, &count);
40024f3c:	97df70ef          	jal	ra,4001c8b8 <net_ipv6_nbr_foreach>
	if (!nbr_address_buffer[idx][0]) {
40024f40:	02800713          	li	a4,40
40024f44:	02e40433          	mul	s0,s0,a4
40024f48:	4003b7b7          	lui	a5,0x4003b
40024f4c:	00478793          	addi	a5,a5,4 # 4003b004 <nbr_address_buffer>
40024f50:	008787b3          	add	a5,a5,s0
40024f54:	0007c703          	lbu	a4,0(a5)
40024f58:	00071a63          	bnez	a4,40024f6c <nbr_address_get+0x84>
40024f5c:	00c0006f          	j	40024f68 <nbr_address_get+0x80>
	if (idx >= CONFIG_NET_IPV6_MAX_NEIGHBORS) {
40024f60:	00700793          	li	a5,7
40024f64:	fca7fee3          	bgeu	a5,a0,40024f40 <nbr_address_get+0x58>
		return NULL;
40024f68:	00000793          	li	a5,0
	entry->syntax = set_nbr_address(idx);
40024f6c:	00f4a023          	sw	a5,0(s1)
}
40024f70:	01c12083          	lw	ra,28(sp)
40024f74:	01812403          	lw	s0,24(sp)
40024f78:	01412483          	lw	s1,20(sp)
40024f7c:	02010113          	addi	sp,sp,32
40024f80:	00008067          	ret

40024f84 <nbr_address_cb>:
{
40024f84:	ff010113          	addi	sp,sp,-16
40024f88:	00112623          	sw	ra,12(sp)
40024f8c:	00812423          	sw	s0,8(sp)
40024f90:	00912223          	sw	s1,4(sp)
	if (*count >= CONFIG_NET_IPV6_MAX_NEIGHBORS) {
40024f94:	0005a483          	lw	s1,0(a1)
40024f98:	00700793          	li	a5,7
40024f9c:	0497c663          	blt	a5,s1,40024fe8 <nbr_address_cb+0x64>
40024fa0:	00058413          	mv	s0,a1
		 "%s", net_sprint_ipv6_addr(&net_ipv6_nbr_data(nbr)->addr));
40024fa4:	00c52583          	lw	a1,12(a0)
	snprintk(nbr_address_buffer[*count], NET_IPV6_ADDR_LEN,
40024fa8:	00200513          	li	a0,2
40024fac:	00458593          	addi	a1,a1,4
40024fb0:	905ef0ef          	jal	ra,400148b4 <net_sprint_addr>
40024fb4:	02800793          	li	a5,40
40024fb8:	02f484b3          	mul	s1,s1,a5
40024fbc:	00050693          	mv	a3,a0
40024fc0:	4003b537          	lui	a0,0x4003b
40024fc4:	40033637          	lui	a2,0x40033
40024fc8:	00450513          	addi	a0,a0,4 # 4003b004 <nbr_address_buffer>
40024fcc:	af860613          	addi	a2,a2,-1288 # 40032af8 <mpsc_config+0x9c>
40024fd0:	02800593          	li	a1,40
40024fd4:	00950533          	add	a0,a0,s1
40024fd8:	d45dc0ef          	jal	ra,40001d1c <snprintk>
	(*count)++;
40024fdc:	00042783          	lw	a5,0(s0)
40024fe0:	00178793          	addi	a5,a5,1
40024fe4:	00f42023          	sw	a5,0(s0)
}
40024fe8:	00c12083          	lw	ra,12(sp)
40024fec:	00812403          	lw	s0,8(sp)
40024ff0:	00412483          	lw	s1,4(sp)
40024ff4:	01010113          	addi	sp,sp,16
40024ff8:	00008067          	ret

40024ffc <cmd_net_websocket>:
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_WEBSOCKET_CLIENT",
40024ffc:	40035737          	lui	a4,0x40035
40025000:	400356b7          	lui	a3,0x40035
40025004:	40035637          	lui	a2,0x40035
{
40025008:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_WEBSOCKET_CLIENT",
4002500c:	69470713          	addi	a4,a4,1684 # 40035694 <CSWTCH.15846+0x34>
40025010:	6a068693          	addi	a3,a3,1696 # 400356a0 <CSWTCH.15846+0x40>
40025014:	6b860613          	addi	a2,a2,1720 # 400356b8 <CSWTCH.15846+0x58>
40025018:	00200593          	li	a1,2
{
4002501c:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_WEBSOCKET_CLIENT",
40025020:	ecde30ef          	jal	ra,40008eec <shell_fprintf>
}
40025024:	00c12083          	lw	ra,12(sp)
40025028:	00000513          	li	a0,0
4002502c:	01010113          	addi	sp,sp,16
40025030:	00008067          	ret

40025034 <cmd_net_vlan>:
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_VLAN", "VLAN");
40025034:	40035737          	lui	a4,0x40035
40025038:	400356b7          	lui	a3,0x40035
4002503c:	40035637          	lui	a2,0x40035
{
40025040:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_VLAN", "VLAN");
40025044:	6d870713          	addi	a4,a4,1752 # 400356d8 <CSWTCH.15846+0x78>
40025048:	6e068693          	addi	a3,a3,1760 # 400356e0 <CSWTCH.15846+0x80>
4002504c:	6b860613          	addi	a2,a2,1720 # 400356b8 <CSWTCH.15846+0x58>
40025050:	00200593          	li	a1,2
{
40025054:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_VLAN", "VLAN");
40025058:	e95e30ef          	jal	ra,40008eec <shell_fprintf>
}
4002505c:	00c12083          	lw	ra,12(sp)
40025060:	00000513          	li	a0,0
40025064:	01010113          	addi	sp,sp,16
40025068:	00008067          	ret

4002506c <cmd_net_vlan_add>:
static int cmd_net_vlan_add(const struct shell *sh, size_t argc,
4002506c:	fc9ff06f          	j	40025034 <cmd_net_vlan>

40025070 <cmd_net_vlan_del>:
static int cmd_net_vlan_del(const struct shell *sh, size_t argc,
40025070:	fc5ff06f          	j	40025034 <cmd_net_vlan>

40025074 <cmd_net_virtual>:
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_VIRTUAL",
40025074:	40035737          	lui	a4,0x40035
40025078:	400356b7          	lui	a3,0x40035
4002507c:	40035637          	lui	a2,0x40035
{
40025080:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_VIRTUAL",
40025084:	6f070713          	addi	a4,a4,1776 # 400356f0 <CSWTCH.15846+0x90>
40025088:	70c68693          	addi	a3,a3,1804 # 4003570c <CSWTCH.15846+0xac>
4002508c:	6b860613          	addi	a2,a2,1720 # 400356b8 <CSWTCH.15846+0x58>
40025090:	00200593          	li	a1,2
{
40025094:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_VIRTUAL",
40025098:	e55e30ef          	jal	ra,40008eec <shell_fprintf>
}
4002509c:	00c12083          	lw	ra,12(sp)
400250a0:	00000513          	li	a0,0
400250a4:	01010113          	addi	sp,sp,16
400250a8:	00008067          	ret

400250ac <tcp_sent_cb>:
	PR_SHELL(tcp_shell, "Message sent\n");
400250ac:	400397b7          	lui	a5,0x40039
400250b0:	0e07a503          	lw	a0,224(a5) # 400390e0 <tcp_shell>
400250b4:	40035637          	lui	a2,0x40035
400250b8:	72460613          	addi	a2,a2,1828 # 40035724 <CSWTCH.15846+0xc4>
400250bc:	00800593          	li	a1,8
400250c0:	e2de306f          	j	40008eec <shell_fprintf>

400250c4 <cmd_net_suspend>:
	PR_INFO("You need a network driver supporting Power Management.\n");
400250c4:	40035637          	lui	a2,0x40035
{
400250c8:	ff010113          	addi	sp,sp,-16
	PR_INFO("You need a network driver supporting Power Management.\n");
400250cc:	73460613          	addi	a2,a2,1844 # 40035734 <CSWTCH.15846+0xd4>
400250d0:	00200593          	li	a1,2
{
400250d4:	00112623          	sw	ra,12(sp)
	PR_INFO("You need a network driver supporting Power Management.\n");
400250d8:	e15e30ef          	jal	ra,40008eec <shell_fprintf>
}
400250dc:	00c12083          	lw	ra,12(sp)
400250e0:	00000513          	li	a0,0
400250e4:	01010113          	addi	sp,sp,16
400250e8:	00008067          	ret

400250ec <cmd_net_stacks>:
	PR("Type \"kernel stacks\" to see stack information.\n");
400250ec:	40035637          	lui	a2,0x40035
{
400250f0:	ff010113          	addi	sp,sp,-16
	PR("Type \"kernel stacks\" to see stack information.\n");
400250f4:	76c60613          	addi	a2,a2,1900 # 4003576c <CSWTCH.15846+0x10c>
400250f8:	00800593          	li	a1,8
{
400250fc:	00112623          	sw	ra,12(sp)
	PR("Type \"kernel stacks\" to see stack information.\n");
40025100:	dede30ef          	jal	ra,40008eec <shell_fprintf>
}
40025104:	00c12083          	lw	ra,12(sp)
40025108:	00000513          	li	a0,0
4002510c:	01010113          	addi	sp,sp,16
40025110:	00008067          	ret

40025114 <cmd_net_ppp_status>:
	PR_INFO("Set %s to enable %s support.\n",
40025114:	40035737          	lui	a4,0x40035
40025118:	400356b7          	lui	a3,0x40035
4002511c:	40035637          	lui	a2,0x40035
{
40025120:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n",
40025124:	79c70713          	addi	a4,a4,1948 # 4003579c <CSWTCH.15846+0x13c>
40025128:	7a068693          	addi	a3,a3,1952 # 400357a0 <CSWTCH.15846+0x140>
4002512c:	6b860613          	addi	a2,a2,1720 # 400356b8 <CSWTCH.15846+0x58>
40025130:	00200593          	li	a1,2
{
40025134:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n",
40025138:	db5e30ef          	jal	ra,40008eec <shell_fprintf>
}
4002513c:	00c12083          	lw	ra,12(sp)
40025140:	00000513          	li	a0,0
40025144:	01010113          	addi	sp,sp,16
40025148:	00008067          	ret

4002514c <cmd_net_ppp_ping>:
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_PPP", "PPP");
4002514c:	40035737          	lui	a4,0x40035
40025150:	400356b7          	lui	a3,0x40035
40025154:	40035637          	lui	a2,0x40035
{
40025158:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_PPP", "PPP");
4002515c:	79c70713          	addi	a4,a4,1948 # 4003579c <CSWTCH.15846+0x13c>
40025160:	7c868693          	addi	a3,a3,1992 # 400357c8 <CSWTCH.15846+0x168>
40025164:	6b860613          	addi	a2,a2,1720 # 400356b8 <CSWTCH.15846+0x58>
40025168:	00200593          	li	a1,2
{
4002516c:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_PPP", "PPP");
40025170:	d7de30ef          	jal	ra,40008eec <shell_fprintf>
}
40025174:	00c12083          	lw	ra,12(sp)
40025178:	00000513          	li	a0,0
4002517c:	01010113          	addi	sp,sp,16
40025180:	00008067          	ret

40025184 <cmd_net_set_mac>:
	PR_WARNING("Unsupported command, please enable CONFIG_NET_L2_ETHERNET "
40025184:	40035637          	lui	a2,0x40035
{
40025188:	ff010113          	addi	sp,sp,-16
	PR_WARNING("Unsupported command, please enable CONFIG_NET_L2_ETHERNET "
4002518c:	7dc60613          	addi	a2,a2,2012 # 400357dc <CSWTCH.15846+0x17c>
40025190:	00300593          	li	a1,3
{
40025194:	00112623          	sw	ra,12(sp)
	PR_WARNING("Unsupported command, please enable CONFIG_NET_L2_ETHERNET "
40025198:	d55e30ef          	jal	ra,40008eec <shell_fprintf>
}
4002519c:	00c12083          	lw	ra,12(sp)
400251a0:	ff800513          	li	a0,-8
400251a4:	01010113          	addi	sp,sp,16
400251a8:	00008067          	ret

400251ac <cmd_net_gptp_port>:
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_GPTP", "gPTP");
400251ac:	40036737          	lui	a4,0x40036
400251b0:	400366b7          	lui	a3,0x40036
400251b4:	40035637          	lui	a2,0x40035
{
400251b8:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_GPTP", "gPTP");
400251bc:	83870713          	addi	a4,a4,-1992 # 40035838 <CSWTCH.15846+0x1d8>
400251c0:	84068693          	addi	a3,a3,-1984 # 40035840 <CSWTCH.15846+0x1e0>
400251c4:	6b860613          	addi	a2,a2,1720 # 400356b8 <CSWTCH.15846+0x58>
400251c8:	00200593          	li	a1,2
{
400251cc:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_GPTP", "gPTP");
400251d0:	d1de30ef          	jal	ra,40008eec <shell_fprintf>
}
400251d4:	00c12083          	lw	ra,12(sp)
400251d8:	00000513          	li	a0,0
400251dc:	01010113          	addi	sp,sp,16
400251e0:	00008067          	ret

400251e4 <cmd_net_gptp>:
static int cmd_net_gptp(const struct shell *sh, size_t argc, char *argv[])
400251e4:	fc9ff06f          	j	400251ac <cmd_net_gptp_port>

400251e8 <cmd_net_events_on>:
	PR_INFO("Network management events are not supported. "
400251e8:	40036637          	lui	a2,0x40036
{
400251ec:	ff010113          	addi	sp,sp,-16
	PR_INFO("Network management events are not supported. "
400251f0:	85060613          	addi	a2,a2,-1968 # 40035850 <CSWTCH.15846+0x1f0>
400251f4:	00200593          	li	a1,2
{
400251f8:	00112623          	sw	ra,12(sp)
	PR_INFO("Network management events are not supported. "
400251fc:	cf1e30ef          	jal	ra,40008eec <shell_fprintf>
}
40025200:	00c12083          	lw	ra,12(sp)
40025204:	00000513          	li	a0,0
40025208:	01010113          	addi	sp,sp,16
4002520c:	00008067          	ret

40025210 <cmd_net_capture>:
	PR_INFO("Set %s to enable %s support.\n",
40025210:	40036737          	lui	a4,0x40036
40025214:	400366b7          	lui	a3,0x40036
40025218:	40035637          	lui	a2,0x40035
{
4002521c:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n",
40025220:	8b070713          	addi	a4,a4,-1872 # 400358b0 <CSWTCH.15846+0x250>
40025224:	8c868693          	addi	a3,a3,-1848 # 400358c8 <CSWTCH.15846+0x268>
40025228:	6b860613          	addi	a2,a2,1720 # 400356b8 <CSWTCH.15846+0x58>
4002522c:	00200593          	li	a1,2
{
40025230:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n",
40025234:	cb9e30ef          	jal	ra,40008eec <shell_fprintf>
}
40025238:	00c12083          	lw	ra,12(sp)
4002523c:	00000513          	li	a0,0
40025240:	01010113          	addi	sp,sp,16
40025244:	00008067          	ret

40025248 <cmd_net_capture_setup>:
static int cmd_net_capture_setup(const struct shell *sh, size_t argc,
40025248:	fc9ff06f          	j	40025210 <cmd_net_capture>

4002524c <cmd_net_capture_cleanup>:
static int cmd_net_capture_cleanup(const struct shell *sh, size_t argc,
4002524c:	fc5ff06f          	j	40025210 <cmd_net_capture>

40025250 <cmd_net_capture_enable>:
static int cmd_net_capture_enable(const struct shell *sh, size_t argc,
40025250:	fc1ff06f          	j	40025210 <cmd_net_capture>

40025254 <cmd_net_capture_disable>:
static int cmd_net_capture_disable(const struct shell *sh, size_t argc,
40025254:	fbdff06f          	j	40025210 <cmd_net_capture>

40025258 <cmd_net_allocs>:
	PR_INFO("Set %s to enable %s support.\n",
40025258:	40036737          	lui	a4,0x40036
4002525c:	400366b7          	lui	a3,0x40036
40025260:	40035637          	lui	a2,0x40035
{
40025264:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n",
40025268:	8dc70713          	addi	a4,a4,-1828 # 400358dc <CSWTCH.15846+0x27c>
4002526c:	8f068693          	addi	a3,a3,-1808 # 400358f0 <CSWTCH.15846+0x290>
40025270:	6b860613          	addi	a2,a2,1720 # 400356b8 <CSWTCH.15846+0x58>
40025274:	00200593          	li	a1,2
{
40025278:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n",
4002527c:	c71e30ef          	jal	ra,40008eec <shell_fprintf>
}
40025280:	00c12083          	lw	ra,12(sp)
40025284:	00000513          	li	a0,0
40025288:	01010113          	addi	sp,sp,16
4002528c:	00008067          	ret

40025290 <get_iface_idx>:
{
40025290:	fd010113          	addi	sp,sp,-48
40025294:	02112623          	sw	ra,44(sp)
40025298:	02812423          	sw	s0,40(sp)
	if (!index_str) {
4002529c:	02059463          	bnez	a1,400252c4 <get_iface_idx+0x34>
		PR_WARNING("Interface index is missing.\n");
400252a0:	40036637          	lui	a2,0x40036
400252a4:	91060613          	addi	a2,a2,-1776 # 40035910 <CSWTCH.15846+0x2b0>
400252a8:	00300593          	li	a1,3
400252ac:	c41e30ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
400252b0:	fea00513          	li	a0,-22
}
400252b4:	02c12083          	lw	ra,44(sp)
400252b8:	02812403          	lw	s0,40(sp)
400252bc:	03010113          	addi	sp,sp,48
400252c0:	00008067          	ret
400252c4:	00058693          	mv	a3,a1
	idx = strtol(index_str, &endptr, 10);
400252c8:	00050413          	mv	s0,a0
400252cc:	00a00613          	li	a2,10
400252d0:	00068513          	mv	a0,a3
400252d4:	01c10593          	addi	a1,sp,28
400252d8:	00d12623          	sw	a3,12(sp)
400252dc:	ca8e70ef          	jal	ra,4000c784 <strtol>
	if (*endptr != '\0') {
400252e0:	01c12783          	lw	a5,28(sp)
400252e4:	00c12683          	lw	a3,12(sp)
400252e8:	0007c783          	lbu	a5,0(a5)
400252ec:	02078063          	beqz	a5,4002530c <get_iface_idx+0x7c>
		PR_WARNING("Invalid index %s\n", index_str);
400252f0:	40036637          	lui	a2,0x40036
400252f4:	00040513          	mv	a0,s0
400252f8:	93060613          	addi	a2,a2,-1744 # 40035930 <CSWTCH.15846+0x2d0>
400252fc:	00300593          	li	a1,3
40025300:	bede30ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOENT;
40025304:	ffe00513          	li	a0,-2
40025308:	fadff06f          	j	400252b4 <get_iface_idx+0x24>
	if (idx < 0 || idx > 255) {
4002530c:	0ff00793          	li	a5,255
40025310:	faa7f2e3          	bgeu	a5,a0,400252b4 <get_iface_idx+0x24>
		PR_WARNING("Invalid index %d\n", idx);
40025314:	40036637          	lui	a2,0x40036
40025318:	00050693          	mv	a3,a0
4002531c:	94460613          	addi	a2,a2,-1724 # 40035944 <CSWTCH.15846+0x2e4>
40025320:	00040513          	mv	a0,s0
40025324:	00300593          	li	a1,3
40025328:	bc5e30ef          	jal	ra,40008eec <shell_fprintf>
		return -ERANGE;
4002532c:	fde00513          	li	a0,-34
40025330:	f85ff06f          	j	400252b4 <get_iface_idx+0x24>

40025334 <cmd_net_tcp_recv>:
{
40025334:	fe010113          	addi	sp,sp,-32
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
40025338:	400397b7          	lui	a5,0x40039
{
4002533c:	00812c23          	sw	s0,24(sp)
40025340:	00050413          	mv	s0,a0
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
40025344:	0e47a503          	lw	a0,228(a5) # 400390e4 <tcp_ctx>
{
40025348:	00112e23          	sw	ra,28(sp)
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
4002534c:	00050863          	beqz	a0,4002535c <cmd_net_tcp_recv+0x28>
	return context->flags & NET_CONTEXT_IN_USE;
40025350:	07455783          	lhu	a5,116(a0)
40025354:	0017f793          	andi	a5,a5,1
40025358:	02079663          	bnez	a5,40025384 <cmd_net_tcp_recv+0x50>
		PR_WARNING("Not connected\n");
4002535c:	40036637          	lui	a2,0x40036
40025360:	95860613          	addi	a2,a2,-1704 # 40035958 <CSWTCH.15846+0x2f8>
40025364:	00300593          	li	a1,3
40025368:	00040513          	mv	a0,s0
4002536c:	b81e30ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40025370:	ff800513          	li	a0,-8
}
40025374:	01c12083          	lw	ra,28(sp)
40025378:	01812403          	lw	s0,24(sp)
4002537c:	02010113          	addi	sp,sp,32
40025380:	00008067          	ret
	ret = net_context_recv(tcp_ctx, tcp_recv_cb, K_NO_WAIT, &user_data);
40025384:	400275b7          	lui	a1,0x40027
40025388:	00000693          	li	a3,0
4002538c:	00810713          	addi	a4,sp,8
40025390:	00000613          	li	a2,0
40025394:	38058593          	addi	a1,a1,896 # 40027380 <tcp_recv_cb>
	user_data.sh = sh;
40025398:	00812423          	sw	s0,8(sp)
	ret = net_context_recv(tcp_ctx, tcp_recv_cb, K_NO_WAIT, &user_data);
4002539c:	bc5f10ef          	jal	ra,40016f60 <net_context_recv>
400253a0:	00050693          	mv	a3,a0
	return 0;
400253a4:	00000513          	li	a0,0
	if (ret < 0) {
400253a8:	fc06d6e3          	bgez	a3,40025374 <cmd_net_tcp_recv+0x40>
		PR_WARNING("Cannot recv data (%d)\n", ret);
400253ac:	40036637          	lui	a2,0x40036
400253b0:	96860613          	addi	a2,a2,-1688 # 40035968 <CSWTCH.15846+0x308>
400253b4:	00300593          	li	a1,3
400253b8:	00040513          	mv	a0,s0
400253bc:	b31e30ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
400253c0:	fb1ff06f          	j	40025370 <cmd_net_tcp_recv+0x3c>

400253c4 <cmd_net_tcp_close>:
{
400253c4:	ff010113          	addi	sp,sp,-16
400253c8:	00912223          	sw	s1,4(sp)
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
400253cc:	400394b7          	lui	s1,0x40039
{
400253d0:	00812423          	sw	s0,8(sp)
400253d4:	00050413          	mv	s0,a0
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
400253d8:	0e44a503          	lw	a0,228(s1) # 400390e4 <tcp_ctx>
{
400253dc:	00112623          	sw	ra,12(sp)
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
400253e0:	00050863          	beqz	a0,400253f0 <cmd_net_tcp_close+0x2c>
400253e4:	07455783          	lhu	a5,116(a0)
400253e8:	0017f793          	andi	a5,a5,1
400253ec:	02079863          	bnez	a5,4002541c <cmd_net_tcp_close+0x58>
		PR_WARNING("Not connected\n");
400253f0:	40036637          	lui	a2,0x40036
400253f4:	95860613          	addi	a2,a2,-1704 # 40035958 <CSWTCH.15846+0x2f8>
400253f8:	00300593          	li	a1,3
400253fc:	00040513          	mv	a0,s0
40025400:	aede30ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40025404:	ff800513          	li	a0,-8
}
40025408:	00c12083          	lw	ra,12(sp)
4002540c:	00812403          	lw	s0,8(sp)
40025410:	00412483          	lw	s1,4(sp)
40025414:	01010113          	addi	sp,sp,16
40025418:	00008067          	ret
	ret = net_context_put(tcp_ctx);
4002541c:	bf9f00ef          	jal	ra,40016014 <net_context_put>
40025420:	00050693          	mv	a3,a0
	if (ret < 0) {
40025424:	00055e63          	bgez	a0,40025440 <cmd_net_tcp_close+0x7c>
		PR_WARNING("Cannot close the connection (%d)\n", ret);
40025428:	40036637          	lui	a2,0x40036
4002542c:	98060613          	addi	a2,a2,-1664 # 40035980 <CSWTCH.15846+0x320>
40025430:	00300593          	li	a1,3
40025434:	00040513          	mv	a0,s0
40025438:	ab5e30ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
4002543c:	fc9ff06f          	j	40025404 <cmd_net_tcp_close+0x40>
	PR("Connection closed.\n");
40025440:	40036637          	lui	a2,0x40036
40025444:	00040513          	mv	a0,s0
40025448:	9a460613          	addi	a2,a2,-1628 # 400359a4 <CSWTCH.15846+0x344>
4002544c:	00800593          	li	a1,8
40025450:	a9de30ef          	jal	ra,40008eec <shell_fprintf>
	return 0;
40025454:	00000513          	li	a0,0
	tcp_ctx = NULL;
40025458:	0e04a223          	sw	zero,228(s1)
	return 0;
4002545c:	fadff06f          	j	40025408 <cmd_net_tcp_close+0x44>

40025460 <cmd_net_tcp_send>:
{
40025460:	fd010113          	addi	sp,sp,-48
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
40025464:	400397b7          	lui	a5,0x40039
{
40025468:	02912223          	sw	s1,36(sp)
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
4002546c:	0e47a483          	lw	s1,228(a5) # 400390e4 <tcp_ctx>
{
40025470:	02812423          	sw	s0,40(sp)
40025474:	02112623          	sw	ra,44(sp)
40025478:	00050413          	mv	s0,a0
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
4002547c:	00048863          	beqz	s1,4002548c <cmd_net_tcp_send+0x2c>
40025480:	0744d783          	lhu	a5,116(s1)
40025484:	0017f793          	andi	a5,a5,1
40025488:	02079863          	bnez	a5,400254b8 <cmd_net_tcp_send+0x58>
		PR_WARNING("Not connected\n");
4002548c:	40036637          	lui	a2,0x40036
40025490:	95860613          	addi	a2,a2,-1704 # 40035958 <CSWTCH.15846+0x2f8>
40025494:	00300593          	li	a1,3
40025498:	00040513          	mv	a0,s0
		PR_WARNING("No data to send.\n");
4002549c:	a51e30ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
400254a0:	ff800513          	li	a0,-8
}
400254a4:	02c12083          	lw	ra,44(sp)
400254a8:	02812403          	lw	s0,40(sp)
400254ac:	02412483          	lw	s1,36(sp)
400254b0:	03010113          	addi	sp,sp,48
400254b4:	00008067          	ret
	if (!argv[++arg]) {
400254b8:	00462583          	lw	a1,4(a2)
400254bc:	00059a63          	bnez	a1,400254d0 <cmd_net_tcp_send+0x70>
		PR_WARNING("No data to send.\n");
400254c0:	40036637          	lui	a2,0x40036
400254c4:	9b860613          	addi	a2,a2,-1608 # 400359b8 <CSWTCH.15846+0x358>
400254c8:	00300593          	li	a1,3
400254cc:	fd1ff06f          	j	4002549c <cmd_net_tcp_send+0x3c>
	user_data.sh = sh;
400254d0:	00a12c23          	sw	a0,24(sp)
	ret = net_context_send(tcp_ctx, (uint8_t *)argv[arg],
400254d4:	00058513          	mv	a0,a1
400254d8:	00b12623          	sw	a1,12(sp)
400254dc:	ef8e70ef          	jal	ra,4000cbd4 <strlen>
400254e0:	00c12583          	lw	a1,12(sp)
400254e4:	400256b7          	lui	a3,0x40025
400254e8:	00050613          	mv	a2,a0
400254ec:	0ac68693          	addi	a3,a3,172 # 400250ac <tcp_sent_cb>
400254f0:	01810813          	addi	a6,sp,24
400254f4:	0c800713          	li	a4,200
400254f8:	00000793          	li	a5,0
400254fc:	00048513          	mv	a0,s1
40025500:	8fdf10ef          	jal	ra,40016dfc <net_context_send>
40025504:	00050693          	mv	a3,a0
	return 0;
40025508:	00000513          	li	a0,0
	if (ret < 0) {
4002550c:	f806dce3          	bgez	a3,400254a4 <cmd_net_tcp_send+0x44>
		PR_WARNING("Cannot send msg (%d)\n", ret);
40025510:	40036637          	lui	a2,0x40036
40025514:	9cc60613          	addi	a2,a2,-1588 # 400359cc <CSWTCH.15846+0x36c>
40025518:	00300593          	li	a1,3
4002551c:	00040513          	mv	a0,s0
40025520:	9cde30ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40025524:	f7dff06f          	j	400254a0 <cmd_net_tcp_send+0x40>

40025528 <net_addr_pton>:
40025528:	bc0ef06f          	j	400148e8 <z_impl_net_addr_pton>

4002552c <cmd_net_route>:
{
4002552c:	fe010113          	addi	sp,sp,-32
	user_data.sh = sh;
40025530:	00a12423          	sw	a0,8(sp)
	net_if_foreach(iface_per_route_cb, &user_data);
40025534:	40028537          	lui	a0,0x40028
40025538:	00810593          	addi	a1,sp,8
4002553c:	01450513          	addi	a0,a0,20 # 40028014 <iface_per_route_cb>
{
40025540:	00112e23          	sw	ra,28(sp)
	net_if_foreach(iface_per_route_cb, &user_data);
40025544:	e60ee0ef          	jal	ra,40013ba4 <net_if_foreach>
}
40025548:	01c12083          	lw	ra,28(sp)
4002554c:	00000513          	li	a0,0
40025550:	02010113          	addi	sp,sp,32
40025554:	00008067          	ret

40025558 <cmd_net_ipv4>:
	PR("IPv4 support                              : %s\n",
40025558:	400336b7          	lui	a3,0x40033
4002555c:	40036637          	lui	a2,0x40036
{
40025560:	fe010113          	addi	sp,sp,-32
	PR("IPv4 support                              : %s\n",
40025564:	b8068693          	addi	a3,a3,-1152 # 40032b80 <severity+0x14>
40025568:	9e460613          	addi	a2,a2,-1564 # 400359e4 <CSWTCH.15846+0x384>
4002556c:	00800593          	li	a1,8
{
40025570:	00112e23          	sw	ra,28(sp)
40025574:	00812c23          	sw	s0,24(sp)
40025578:	00050413          	mv	s0,a0
	PR("IPv4 support                              : %s\n",
4002557c:	971e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("IPv4 fragmentation support                : %s\n",
40025580:	400336b7          	lui	a3,0x40033
40025584:	40036637          	lui	a2,0x40036
40025588:	00040513          	mv	a0,s0
4002558c:	b8868693          	addi	a3,a3,-1144 # 40032b88 <severity+0x1c>
40025590:	a1460613          	addi	a2,a2,-1516 # 40035a14 <CSWTCH.15846+0x3b4>
40025594:	00800593          	li	a1,8
40025598:	955e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Max number of IPv4 network interfaces "
4002559c:	40036637          	lui	a2,0x40036
400255a0:	00040513          	mv	a0,s0
400255a4:	00100693          	li	a3,1
400255a8:	a4460613          	addi	a2,a2,-1468 # 40035a44 <CSWTCH.15846+0x3e4>
400255ac:	00800593          	li	a1,8
400255b0:	93de30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Max number of unicast IPv4 addresses "
400255b4:	40036637          	lui	a2,0x40036
400255b8:	00040513          	mv	a0,s0
400255bc:	00100693          	li	a3,1
400255c0:	a8860613          	addi	a2,a2,-1400 # 40035a88 <CSWTCH.15846+0x428>
400255c4:	00800593          	li	a1,8
400255c8:	925e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Max number of multicast IPv4 addresses "
400255cc:	40036637          	lui	a2,0x40036
400255d0:	00040513          	mv	a0,s0
400255d4:	00100693          	li	a3,1
400255d8:	acc60613          	addi	a2,a2,-1332 # 40035acc <CSWTCH.15846+0x46c>
400255dc:	00800593          	li	a1,8
400255e0:	90de30ef          	jal	ra,40008eec <shell_fprintf>
	net_if_foreach(ip_address_lifetime_cb, &user_data);
400255e4:	40028537          	lui	a0,0x40028
400255e8:	00810593          	addi	a1,sp,8
400255ec:	e8c50513          	addi	a0,a0,-372 # 40027e8c <ip_address_lifetime_cb>
	user_data.sh = sh;
400255f0:	00812423          	sw	s0,8(sp)
	user_data.user_data = NULL;
400255f4:	00012623          	sw	zero,12(sp)
	net_if_foreach(ip_address_lifetime_cb, &user_data);
400255f8:	dacee0ef          	jal	ra,40013ba4 <net_if_foreach>
}
400255fc:	01c12083          	lw	ra,28(sp)
40025600:	01812403          	lw	s0,24(sp)
40025604:	00000513          	li	a0,0
40025608:	02010113          	addi	sp,sp,32
4002560c:	00008067          	ret

40025610 <cmd_net_ipv6>:
{
40025610:	fe010113          	addi	sp,sp,-32
40025614:	00912a23          	sw	s1,20(sp)
	PR("IPv6 support                              : %s\n",
40025618:	40036637          	lui	a2,0x40036
4002561c:	400334b7          	lui	s1,0x40033
40025620:	b8048693          	addi	a3,s1,-1152 # 40032b80 <severity+0x14>
40025624:	b1060613          	addi	a2,a2,-1264 # 40035b10 <CSWTCH.15846+0x4b0>
40025628:	00800593          	li	a1,8
{
4002562c:	00112e23          	sw	ra,28(sp)
40025630:	00812c23          	sw	s0,24(sp)
40025634:	01212823          	sw	s2,16(sp)
40025638:	00050413          	mv	s0,a0
	PR("IPv6 support                              : %s\n",
4002563c:	8b1e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("IPv6 fragmentation support                : %s\n",
40025640:	40033937          	lui	s2,0x40033
40025644:	40036637          	lui	a2,0x40036
40025648:	b8890693          	addi	a3,s2,-1144 # 40032b88 <severity+0x1c>
4002564c:	00040513          	mv	a0,s0
40025650:	b4060613          	addi	a2,a2,-1216 # 40035b40 <CSWTCH.15846+0x4e0>
40025654:	00800593          	li	a1,8
40025658:	895e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Multicast Listener Discovery support      : %s\n",
4002565c:	40036637          	lui	a2,0x40036
40025660:	b8048693          	addi	a3,s1,-1152
40025664:	00040513          	mv	a0,s0
40025668:	b7060613          	addi	a2,a2,-1168 # 40035b70 <CSWTCH.15846+0x510>
4002566c:	00800593          	li	a1,8
40025670:	87de30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Neighbor cache support                    : %s\n",
40025674:	40036637          	lui	a2,0x40036
40025678:	b8048693          	addi	a3,s1,-1152
4002567c:	00040513          	mv	a0,s0
40025680:	ba060613          	addi	a2,a2,-1120 # 40035ba0 <CSWTCH.15846+0x540>
40025684:	00800593          	li	a1,8
40025688:	865e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Neighbor discovery support                : %s\n",
4002568c:	40036637          	lui	a2,0x40036
40025690:	b8048693          	addi	a3,s1,-1152
40025694:	00040513          	mv	a0,s0
40025698:	bd060613          	addi	a2,a2,-1072 # 40035bd0 <CSWTCH.15846+0x570>
4002569c:	00800593          	li	a1,8
400256a0:	84de30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Duplicate address detection (DAD) support : %s\n",
400256a4:	40036637          	lui	a2,0x40036
400256a8:	b8048693          	addi	a3,s1,-1152
400256ac:	00040513          	mv	a0,s0
400256b0:	c0060613          	addi	a2,a2,-1024 # 40035c00 <CSWTCH.15846+0x5a0>
400256b4:	00800593          	li	a1,8
400256b8:	835e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Router advertisement RDNSS option support : %s\n",
400256bc:	40036637          	lui	a2,0x40036
400256c0:	b8048693          	addi	a3,s1,-1152
400256c4:	00040513          	mv	a0,s0
400256c8:	c3060613          	addi	a2,a2,-976 # 40035c30 <CSWTCH.15846+0x5d0>
400256cc:	00800593          	li	a1,8
400256d0:	81de30ef          	jal	ra,40008eec <shell_fprintf>
	PR("6lo header compression support            : %s\n",
400256d4:	40036637          	lui	a2,0x40036
400256d8:	b8890693          	addi	a3,s2,-1144
400256dc:	00040513          	mv	a0,s0
400256e0:	c6060613          	addi	a2,a2,-928 # 40035c60 <CSWTCH.15846+0x600>
400256e4:	00800593          	li	a1,8
400256e8:	805e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Max number of IPv6 network interfaces "
400256ec:	40036637          	lui	a2,0x40036
400256f0:	00040513          	mv	a0,s0
400256f4:	00100693          	li	a3,1
400256f8:	c9060613          	addi	a2,a2,-880 # 40035c90 <CSWTCH.15846+0x630>
400256fc:	00800593          	li	a1,8
40025700:	fece30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Max number of unicast IPv6 addresses "
40025704:	40036637          	lui	a2,0x40036
40025708:	00040513          	mv	a0,s0
4002570c:	00300693          	li	a3,3
40025710:	cd460613          	addi	a2,a2,-812 # 40035cd4 <CSWTCH.15846+0x674>
40025714:	00800593          	li	a1,8
40025718:	fd4e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Max number of multicast IPv6 addresses "
4002571c:	40036637          	lui	a2,0x40036
40025720:	00040513          	mv	a0,s0
40025724:	00400693          	li	a3,4
40025728:	d1860613          	addi	a2,a2,-744 # 40035d18 <CSWTCH.15846+0x6b8>
4002572c:	00800593          	li	a1,8
40025730:	fbce30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Max number of IPv6 prefixes per network "
40025734:	40036637          	lui	a2,0x40036
40025738:	00040513          	mv	a0,s0
4002573c:	00200693          	li	a3,2
40025740:	d5c60613          	addi	a2,a2,-676 # 40035d5c <CSWTCH.15846+0x6fc>
40025744:	00800593          	li	a1,8
40025748:	fa4e30ef          	jal	ra,40008eec <shell_fprintf>
	net_if_foreach(address_lifetime_cb, &user_data);
4002574c:	40029537          	lui	a0,0x40029
40025750:	00810593          	addi	a1,sp,8
40025754:	ea850513          	addi	a0,a0,-344 # 40028ea8 <address_lifetime_cb>
	user_data.sh = sh;
40025758:	00812423          	sw	s0,8(sp)
	user_data.user_data = NULL;
4002575c:	00012623          	sw	zero,12(sp)
	net_if_foreach(address_lifetime_cb, &user_data);
40025760:	c44ee0ef          	jal	ra,40013ba4 <net_if_foreach>
}
40025764:	01c12083          	lw	ra,28(sp)
40025768:	01812403          	lw	s0,24(sp)
4002576c:	01412483          	lw	s1,20(sp)
40025770:	01012903          	lw	s2,16(sp)
40025774:	00000513          	li	a0,0
40025778:	02010113          	addi	sp,sp,32
4002577c:	00008067          	ret

40025780 <cmd_net_iface>:
{
40025780:	fd010113          	addi	sp,sp,-48
40025784:	02812423          	sw	s0,40(sp)
40025788:	02112623          	sw	ra,44(sp)
	if (argv[1]) {
4002578c:	00462583          	lw	a1,4(a2)
{
40025790:	00050413          	mv	s0,a0
	if (argv[1]) {
40025794:	04058463          	beqz	a1,400257dc <cmd_net_iface+0x5c>
		idx = get_iface_idx(sh, argv[1]);
40025798:	af9ff0ef          	jal	ra,40025290 <get_iface_idx>
		if (idx < 0) {
4002579c:	00a12623          	sw	a0,12(sp)
400257a0:	02054463          	bltz	a0,400257c8 <cmd_net_iface+0x48>
		iface = net_if_get_by_index(idx);
400257a4:	f40ff0ef          	jal	ra,40024ee4 <net_if_get_by_index>
		if (!iface) {
400257a8:	00c12683          	lw	a3,12(sp)
		iface = net_if_get_by_index(idx);
400257ac:	00050593          	mv	a1,a0
		if (!iface) {
400257b0:	02051663          	bnez	a0,400257dc <cmd_net_iface+0x5c>
			PR_WARNING("No such interface in index %d\n", idx);
400257b4:	40036637          	lui	a2,0x40036
400257b8:	da060613          	addi	a2,a2,-608 # 40035da0 <CSWTCH.15846+0x740>
400257bc:	00300593          	li	a1,3
400257c0:	00040513          	mv	a0,s0
400257c4:	f28e30ef          	jal	ra,40008eec <shell_fprintf>
			return -ENOEXEC;
400257c8:	ff800513          	li	a0,-8
}
400257cc:	02c12083          	lw	ra,44(sp)
400257d0:	02812403          	lw	s0,40(sp)
400257d4:	03010113          	addi	sp,sp,48
400257d8:	00008067          	ret
	net_if_foreach(iface_cb, &user_data);
400257dc:	40029537          	lui	a0,0x40029
	user_data.user_data = iface;
400257e0:	00b12e23          	sw	a1,28(sp)
	net_if_foreach(iface_cb, &user_data);
400257e4:	12850513          	addi	a0,a0,296 # 40029128 <iface_cb>
400257e8:	01810593          	addi	a1,sp,24
	user_data.sh = sh;
400257ec:	00812c23          	sw	s0,24(sp)
	net_if_foreach(iface_cb, &user_data);
400257f0:	bb4ee0ef          	jal	ra,40013ba4 <net_if_foreach>
	return 0;
400257f4:	00000513          	li	a0,0
400257f8:	fd5ff06f          	j	400257cc <cmd_net_iface+0x4c>

400257fc <cmd_net_ip6_route_del>:
{
400257fc:	fc010113          	addi	sp,sp,-64
40025800:	02112e23          	sw	ra,60(sp)
40025804:	02812c23          	sw	s0,56(sp)
40025808:	02912a23          	sw	s1,52(sp)
4002580c:	03212823          	sw	s2,48(sp)
40025810:	03312623          	sw	s3,44(sp)
	struct in6_addr prefix = { 0 };
40025814:	00012823          	sw	zero,16(sp)
40025818:	00012a23          	sw	zero,20(sp)
4002581c:	00012c23          	sw	zero,24(sp)
40025820:	00012e23          	sw	zero,28(sp)
	if (argc != 3) {
40025824:	00300793          	li	a5,3
40025828:	02f58c63          	beq	a1,a5,40025860 <cmd_net_ip6_route_del+0x64>
		PR_ERROR("Correct usage: net route del <index> <destination>\n");
4002582c:	40036637          	lui	a2,0x40036
40025830:	dc060613          	addi	a2,a2,-576 # 40035dc0 <CSWTCH.15846+0x760>
40025834:	00100593          	li	a1,1
40025838:	eb4e30ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
4002583c:	fea00413          	li	s0,-22
}
40025840:	03c12083          	lw	ra,60(sp)
40025844:	00040513          	mv	a0,s0
40025848:	03812403          	lw	s0,56(sp)
4002584c:	03412483          	lw	s1,52(sp)
40025850:	03012903          	lw	s2,48(sp)
40025854:	02c12983          	lw	s3,44(sp)
40025858:	04010113          	addi	sp,sp,64
4002585c:	00008067          	ret
	idx = get_iface_idx(sh, argv[1]);
40025860:	00462583          	lw	a1,4(a2)
40025864:	00050993          	mv	s3,a0
40025868:	00060493          	mv	s1,a2
4002586c:	a25ff0ef          	jal	ra,40025290 <get_iface_idx>
	if (idx < 0) {
40025870:	00a12623          	sw	a0,12(sp)
40025874:	02054463          	bltz	a0,4002589c <cmd_net_ip6_route_del+0xa0>
	iface = net_if_get_by_index(idx);
40025878:	e6cff0ef          	jal	ra,40024ee4 <net_if_get_by_index>
	if (!iface) {
4002587c:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
40025880:	00050913          	mv	s2,a0
	if (!iface) {
40025884:	02051063          	bnez	a0,400258a4 <cmd_net_ip6_route_del+0xa8>
		PR_WARNING("No such interface in index %d\n", idx);
40025888:	40036637          	lui	a2,0x40036
4002588c:	da060613          	addi	a2,a2,-608 # 40035da0 <CSWTCH.15846+0x740>
40025890:	00300593          	li	a1,3
40025894:	00098513          	mv	a0,s3
40025898:	e54e30ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
4002589c:	ff800413          	li	s0,-8
400258a0:	fa1ff06f          	j	40025840 <cmd_net_ip6_route_del+0x44>
	if (net_addr_pton(AF_INET6, argv[2], &prefix)) {
400258a4:	0084a583          	lw	a1,8(s1)
400258a8:	01010613          	addi	a2,sp,16
400258ac:	00200513          	li	a0,2
400258b0:	c79ff0ef          	jal	ra,40025528 <net_addr_pton>
400258b4:	00050413          	mv	s0,a0
400258b8:	02050063          	beqz	a0,400258d8 <cmd_net_ip6_route_del+0xdc>
		PR_ERROR("Invalid address: %s\n", argv[2]);
400258bc:	0084a683          	lw	a3,8(s1)
400258c0:	40036637          	lui	a2,0x40036
400258c4:	df460613          	addi	a2,a2,-524 # 40035df4 <CSWTCH.15846+0x794>
400258c8:	00100593          	li	a1,1
400258cc:	00098513          	mv	a0,s3
400258d0:	e1ce30ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
400258d4:	f69ff06f          	j	4002583c <cmd_net_ip6_route_del+0x40>
	route = net_route_lookup(iface, &prefix);
400258d8:	01010593          	addi	a1,sp,16
400258dc:	00090513          	mv	a0,s2
400258e0:	d81f90ef          	jal	ra,4001f660 <net_route_lookup>
	if (route) {
400258e4:	f4050ee3          	beqz	a0,40025840 <cmd_net_ip6_route_del+0x44>
		net_route_del(route);
400258e8:	fd5f90ef          	jal	ra,4001f8bc <net_route_del>
400258ec:	f55ff06f          	j	40025840 <cmd_net_ip6_route_del+0x44>

400258f0 <cmd_net_ip6_route_add>:
{
400258f0:	fb010113          	addi	sp,sp,-80
400258f4:	04112623          	sw	ra,76(sp)
400258f8:	04812423          	sw	s0,72(sp)
400258fc:	04912223          	sw	s1,68(sp)
40025900:	05212023          	sw	s2,64(sp)
40025904:	03312e23          	sw	s3,60(sp)
	struct in6_addr gw = {0};
40025908:	00012823          	sw	zero,16(sp)
4002590c:	00012a23          	sw	zero,20(sp)
40025910:	00012c23          	sw	zero,24(sp)
40025914:	00012e23          	sw	zero,28(sp)
	struct in6_addr prefix = {0};
40025918:	02012023          	sw	zero,32(sp)
4002591c:	02012223          	sw	zero,36(sp)
40025920:	02012423          	sw	zero,40(sp)
40025924:	02012623          	sw	zero,44(sp)
	if (argc != 4) {
40025928:	00400793          	li	a5,4
4002592c:	00f58e63          	beq	a1,a5,40025948 <cmd_net_ip6_route_add+0x58>
		PR_ERROR("Correct usage: net route add <index> "
40025930:	40036637          	lui	a2,0x40036
40025934:	e0c60613          	addi	a2,a2,-500 # 40035e0c <CSWTCH.15846+0x7ac>
40025938:	00100593          	li	a1,1
4002593c:	db0e30ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
40025940:	fea00493          	li	s1,-22
40025944:	0440006f          	j	40025988 <cmd_net_ip6_route_add+0x98>
	idx = get_iface_idx(sh, argv[1]);
40025948:	00462583          	lw	a1,4(a2)
4002594c:	00050913          	mv	s2,a0
40025950:	00060413          	mv	s0,a2
40025954:	93dff0ef          	jal	ra,40025290 <get_iface_idx>
	if (idx < 0) {
40025958:	00a12623          	sw	a0,12(sp)
4002595c:	02054463          	bltz	a0,40025984 <cmd_net_ip6_route_add+0x94>
	iface = net_if_get_by_index(idx);
40025960:	d84ff0ef          	jal	ra,40024ee4 <net_if_get_by_index>
	if (!iface) {
40025964:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
40025968:	00050993          	mv	s3,a0
	if (!iface) {
4002596c:	02051e63          	bnez	a0,400259a8 <cmd_net_ip6_route_add+0xb8>
		PR_WARNING("No such interface in index %d\n", idx);
40025970:	40036637          	lui	a2,0x40036
40025974:	da060613          	addi	a2,a2,-608 # 40035da0 <CSWTCH.15846+0x740>
40025978:	00300593          	li	a1,3
4002597c:	00090513          	mv	a0,s2
40025980:	d6ce30ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40025984:	ff800493          	li	s1,-8
}
40025988:	04c12083          	lw	ra,76(sp)
4002598c:	04812403          	lw	s0,72(sp)
40025990:	04012903          	lw	s2,64(sp)
40025994:	03c12983          	lw	s3,60(sp)
40025998:	00048513          	mv	a0,s1
4002599c:	04412483          	lw	s1,68(sp)
400259a0:	05010113          	addi	sp,sp,80
400259a4:	00008067          	ret
	if (net_addr_pton(AF_INET6, argv[2], &prefix)) {
400259a8:	00842583          	lw	a1,8(s0)
400259ac:	02010613          	addi	a2,sp,32
400259b0:	00200513          	li	a0,2
400259b4:	b75ff0ef          	jal	ra,40025528 <net_addr_pton>
400259b8:	02050063          	beqz	a0,400259d8 <cmd_net_ip6_route_add+0xe8>
		PR_ERROR("Invalid address: %s\n", argv[2]);
400259bc:	00842683          	lw	a3,8(s0)
400259c0:	40036637          	lui	a2,0x40036
400259c4:	df460613          	addi	a2,a2,-524 # 40035df4 <CSWTCH.15846+0x794>
		PR_ERROR("Invalid gateway: %s\n", argv[3]);
400259c8:	00100593          	li	a1,1
400259cc:	00090513          	mv	a0,s2
400259d0:	d1ce30ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
400259d4:	f6dff06f          	j	40025940 <cmd_net_ip6_route_add+0x50>
	if (net_addr_pton(AF_INET6, argv[3], &gw)) {
400259d8:	00c42583          	lw	a1,12(s0)
400259dc:	01010613          	addi	a2,sp,16
400259e0:	00200513          	li	a0,2
400259e4:	b45ff0ef          	jal	ra,40025528 <net_addr_pton>
400259e8:	00050493          	mv	s1,a0
400259ec:	00050a63          	beqz	a0,40025a00 <cmd_net_ip6_route_add+0x110>
		PR_ERROR("Invalid gateway: %s\n", argv[3]);
400259f0:	40036637          	lui	a2,0x40036
400259f4:	00c42683          	lw	a3,12(s0)
400259f8:	e4c60613          	addi	a2,a2,-436 # 40035e4c <CSWTCH.15846+0x7ec>
400259fc:	fcdff06f          	j	400259c8 <cmd_net_ip6_route_add+0xd8>
	route = net_route_add(iface, &prefix, NET_IPV6_DEFAULT_PREFIX_LEN,
40025a00:	00000793          	li	a5,0
40025a04:	fff00713          	li	a4,-1
40025a08:	01010693          	addi	a3,sp,16
40025a0c:	04000613          	li	a2,64
40025a10:	02010593          	addi	a1,sp,32
40025a14:	00098513          	mv	a0,s3
40025a18:	a28fa0ef          	jal	ra,4001fc40 <net_route_add>
	if (route == NULL) {
40025a1c:	f60516e3          	bnez	a0,40025988 <cmd_net_ip6_route_add+0x98>
		PR_ERROR("Failed to add route\n");
40025a20:	40036637          	lui	a2,0x40036
40025a24:	e6460613          	addi	a2,a2,-412 # 40035e64 <CSWTCH.15846+0x804>
40025a28:	00100593          	li	a1,1
40025a2c:	00090513          	mv	a0,s2
40025a30:	cbce30ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40025a34:	f51ff06f          	j	40025984 <cmd_net_ip6_route_add+0x94>

40025a38 <cmd_net_mem>:
{
40025a38:	fe010113          	addi	sp,sp,-32
40025a3c:	00812c23          	sw	s0,24(sp)
	net_pkt_get_info(&rx, &tx, &rx_data, &tx_data);
40025a40:	00c10693          	addi	a3,sp,12
{
40025a44:	00050413          	mv	s0,a0
	net_pkt_get_info(&rx, &tx, &rx_data, &tx_data);
40025a48:	00810613          	addi	a2,sp,8
40025a4c:	00410593          	addi	a1,sp,4
40025a50:	00010513          	mv	a0,sp
{
40025a54:	00112e23          	sw	ra,28(sp)
	net_pkt_get_info(&rx, &tx, &rx_data, &tx_data);
40025a58:	e7df10ef          	jal	ra,400178d4 <net_pkt_get_info>
	PR("Fragment length %d bytes\n", CONFIG_NET_BUF_DATA_SIZE);
40025a5c:	40036637          	lui	a2,0x40036
40025a60:	08000693          	li	a3,128
40025a64:	00040513          	mv	a0,s0
40025a68:	e7c60613          	addi	a2,a2,-388 # 40035e7c <CSWTCH.15846+0x81c>
40025a6c:	00800593          	li	a1,8
40025a70:	c7ce30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Network buffer pools:\n");
40025a74:	40036637          	lui	a2,0x40036
40025a78:	00040513          	mv	a0,s0
40025a7c:	e9860613          	addi	a2,a2,-360 # 40035e98 <CSWTCH.15846+0x838>
40025a80:	00800593          	li	a1,8
40025a84:	c68e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("Address\t\tTotal\tName\n");
40025a88:	40036637          	lui	a2,0x40036
40025a8c:	00040513          	mv	a0,s0
40025a90:	eb060613          	addi	a2,a2,-336 # 40035eb0 <CSWTCH.15846+0x850>
40025a94:	00800593          	li	a1,8
40025a98:	c54e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("%p\t%d\tRX\n", rx, rx->num_blocks);
40025a9c:	00012683          	lw	a3,0(sp)
40025aa0:	40036637          	lui	a2,0x40036
40025aa4:	00040513          	mv	a0,s0
40025aa8:	0086a703          	lw	a4,8(a3)
40025aac:	ec860613          	addi	a2,a2,-312 # 40035ec8 <CSWTCH.15846+0x868>
40025ab0:	00800593          	li	a1,8
40025ab4:	c38e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("%p\t%d\tTX\n", tx, tx->num_blocks);
40025ab8:	00412683          	lw	a3,4(sp)
40025abc:	40036637          	lui	a2,0x40036
40025ac0:	00040513          	mv	a0,s0
40025ac4:	0086a703          	lw	a4,8(a3)
40025ac8:	ed460613          	addi	a2,a2,-300 # 40035ed4 <CSWTCH.15846+0x874>
40025acc:	00800593          	li	a1,8
40025ad0:	c1ce30ef          	jal	ra,40008eec <shell_fprintf>
	PR("%p\t%d\tRX DATA\n", rx_data, rx_data->buf_count);
40025ad4:	00812683          	lw	a3,8(sp)
40025ad8:	40036637          	lui	a2,0x40036
40025adc:	00040513          	mv	a0,s0
40025ae0:	0186d703          	lhu	a4,24(a3)
40025ae4:	ee060613          	addi	a2,a2,-288 # 40035ee0 <CSWTCH.15846+0x880>
40025ae8:	00800593          	li	a1,8
40025aec:	c00e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("%p\t%d\tTX DATA\n", tx_data, tx_data->buf_count);
40025af0:	00c12683          	lw	a3,12(sp)
40025af4:	40036637          	lui	a2,0x40036
40025af8:	00040513          	mv	a0,s0
40025afc:	0186d703          	lhu	a4,24(a3)
40025b00:	ef060613          	addi	a2,a2,-272 # 40035ef0 <CSWTCH.15846+0x890>
40025b04:	00800593          	li	a1,8
40025b08:	be4e30ef          	jal	ra,40008eec <shell_fprintf>
	PR_INFO("Set %s to enable %s support.\n",
40025b0c:	40036737          	lui	a4,0x40036
40025b10:	400366b7          	lui	a3,0x40036
40025b14:	40035637          	lui	a2,0x40035
40025b18:	00040513          	mv	a0,s0
40025b1c:	f0070713          	addi	a4,a4,-256 # 40035f00 <CSWTCH.15846+0x8a0>
40025b20:	f1468693          	addi	a3,a3,-236 # 40035f14 <CSWTCH.15846+0x8b4>
40025b24:	6b860613          	addi	a2,a2,1720 # 400356b8 <CSWTCH.15846+0x58>
40025b28:	00200593          	li	a1,2
40025b2c:	bc0e30ef          	jal	ra,40008eec <shell_fprintf>
}
40025b30:	01c12083          	lw	ra,28(sp)
40025b34:	01812403          	lw	s0,24(sp)
40025b38:	00000513          	li	a0,0
40025b3c:	02010113          	addi	sp,sp,32
40025b40:	00008067          	ret

40025b44 <cmd_net_pkt>:
{
40025b44:	fc010113          	addi	sp,sp,-64
40025b48:	02112e23          	sw	ra,60(sp)
40025b4c:	02812c23          	sw	s0,56(sp)
40025b50:	02912a23          	sw	s1,52(sp)
40025b54:	03212823          	sw	s2,48(sp)
40025b58:	03312623          	sw	s3,44(sp)
40025b5c:	03412423          	sw	s4,40(sp)
40025b60:	03512223          	sw	s5,36(sp)
	if (argv[1]) {
40025b64:	00462483          	lw	s1,4(a2)
40025b68:	24048863          	beqz	s1,40025db8 <cmd_net_pkt+0x274>
	if (ptr_str[0] == '0' && ptr_str[1] == 'x') {
40025b6c:	0004c703          	lbu	a4,0(s1)
40025b70:	03000793          	li	a5,48
40025b74:	00050413          	mv	s0,a0
40025b78:	00060913          	mv	s2,a2
40025b7c:	00f71a63          	bne	a4,a5,40025b90 <cmd_net_pkt+0x4c>
40025b80:	0014c703          	lbu	a4,1(s1)
40025b84:	07800793          	li	a5,120
40025b88:	00f71463          	bne	a4,a5,40025b90 <cmd_net_pkt+0x4c>
		ptr_str += 2;
40025b8c:	00248493          	addi	s1,s1,2
	len = hex2bin(ptr_str, strlen(ptr_str), buf, sizeof(buf));
40025b90:	00048513          	mv	a0,s1
40025b94:	840e70ef          	jal	ra,4000cbd4 <strlen>
40025b98:	00050593          	mv	a1,a0
40025b9c:	00400693          	li	a3,4
40025ba0:	01c10613          	addi	a2,sp,28
40025ba4:	00048513          	mv	a0,s1
40025ba8:	fc1db0ef          	jal	ra,40001b68 <hex2bin>
	if (!len) {
40025bac:	00050c63          	beqz	a0,40025bc4 <cmd_net_pkt+0x80>
	for (i = len - 1; i >= 0; i--) {
40025bb0:	fff50513          	addi	a0,a0,-1
40025bb4:	00000793          	li	a5,0
	intptr_t ptr = 0;
40025bb8:	00000493          	li	s1,0
	for (i = len - 1; i >= 0; i--) {
40025bbc:	04055463          	bgez	a0,40025c04 <cmd_net_pkt+0xc0>
		if (!pkt) {
40025bc0:	06049263          	bnez	s1,40025c24 <cmd_net_pkt+0xe0>
			PR_ERROR("Invalid ptr value (%s). "
40025bc4:	00492683          	lw	a3,4(s2)
40025bc8:	40036637          	lui	a2,0x40036
40025bcc:	f3060613          	addi	a2,a2,-208 # 40035f30 <CSWTCH.15846+0x8d0>
			PR_ERROR("Pointer is not recognized as net_pkt (%s).\n",
40025bd0:	00100593          	li	a1,1
40025bd4:	00040513          	mv	a0,s0
40025bd8:	b14e30ef          	jal	ra,40008eec <shell_fprintf>
			return -ENOEXEC;
40025bdc:	ff800513          	li	a0,-8
}
40025be0:	03c12083          	lw	ra,60(sp)
40025be4:	03812403          	lw	s0,56(sp)
40025be8:	03412483          	lw	s1,52(sp)
40025bec:	03012903          	lw	s2,48(sp)
40025bf0:	02c12983          	lw	s3,44(sp)
40025bf4:	02812a03          	lw	s4,40(sp)
40025bf8:	02412a83          	lw	s5,36(sp)
40025bfc:	04010113          	addi	sp,sp,64
40025c00:	00008067          	ret
		ptr |= buf[i] << 8 * (len - 1 - i);
40025c04:	01c10713          	addi	a4,sp,28
40025c08:	00a70733          	add	a4,a4,a0
40025c0c:	00074703          	lbu	a4,0(a4)
	for (i = len - 1; i >= 0; i--) {
40025c10:	fff50513          	addi	a0,a0,-1
		ptr |= buf[i] << 8 * (len - 1 - i);
40025c14:	00f71733          	sll	a4,a4,a5
40025c18:	00e4e4b3          	or	s1,s1,a4
	for (i = len - 1; i >= 0; i--) {
40025c1c:	00878793          	addi	a5,a5,8
40025c20:	f9dff06f          	j	40025bbc <cmd_net_pkt+0x78>
	net_pkt_get_info(&rx, &tx, NULL, NULL);
40025c24:	01c10593          	addi	a1,sp,28
40025c28:	01810513          	addi	a0,sp,24
40025c2c:	00000693          	li	a3,0
40025c30:	00000613          	li	a2,0
40025c34:	ca1f10ef          	jal	ra,400178d4 <net_pkt_get_info>
	if (is_pkt_part_of_slab(rx, ptr) || is_pkt_part_of_slab(tx, ptr)) {
40025c38:	01812503          	lw	a0,24(sp)
40025c3c:	00048593          	mv	a1,s1
40025c40:	a60ff0ef          	jal	ra,40024ea0 <is_pkt_part_of_slab>
40025c44:	02051263          	bnez	a0,40025c68 <cmd_net_pkt+0x124>
40025c48:	01c12503          	lw	a0,28(sp)
40025c4c:	00048593          	mv	a1,s1
40025c50:	a50ff0ef          	jal	ra,40024ea0 <is_pkt_part_of_slab>
		if (!is_pkt_ptr_valid(pkt)) {
40025c54:	00051a63          	bnez	a0,40025c68 <cmd_net_pkt+0x124>
			PR_ERROR("Pointer is not recognized as net_pkt (%s).\n",
40025c58:	40036637          	lui	a2,0x40036
40025c5c:	00492683          	lw	a3,4(s2)
40025c60:	f6060613          	addi	a2,a2,-160 # 40035f60 <CSWTCH.15846+0x900>
40025c64:	f6dff06f          	j	40025bd0 <cmd_net_pkt+0x8c>
	PR("net_pkt %p buffer chain:\n", pkt);
40025c68:	40036637          	lui	a2,0x40036
40025c6c:	00048693          	mv	a3,s1
40025c70:	f8c60613          	addi	a2,a2,-116 # 40035f8c <CSWTCH.15846+0x92c>
40025c74:	00800593          	li	a1,8
40025c78:	00040513          	mv	a0,s0
	struct net_buf *buf = pkt->buffer;
40025c7c:	0084a903          	lw	s2,8(s1)
	PR("%p[%ld]", pkt, atomic_get(&pkt->atomic_ref));
40025c80:	02048a13          	addi	s4,s1,32
	PR("net_pkt %p buffer chain:\n", pkt);
40025c84:	a68e30ef          	jal	ra,40008eec <shell_fprintf>
	PR("%p[%ld]", pkt, atomic_get(&pkt->atomic_ref));
40025c88:	000a0513          	mv	a0,s4
40025c8c:	5fd0b0ef          	jal	ra,40031a88 <atomic_get>
40025c90:	40036637          	lui	a2,0x40036
40025c94:	00050713          	mv	a4,a0
40025c98:	00048693          	mv	a3,s1
40025c9c:	fa860613          	addi	a2,a2,-88 # 40035fa8 <CSWTCH.15846+0x948>
40025ca0:	00800593          	li	a1,8
40025ca4:	00040513          	mv	a0,s0
40025ca8:	a44e30ef          	jal	ra,40008eec <shell_fprintf>
	if (buf) {
40025cac:	06090263          	beqz	s2,40025d10 <cmd_net_pkt+0x1cc>
		PR("->");
40025cb0:	400369b7          	lui	s3,0x40036
40025cb4:	fb098613          	addi	a2,s3,-80 # 40035fb0 <CSWTCH.15846+0x950>
40025cb8:	00800593          	li	a1,8
40025cbc:	00040513          	mv	a0,s0
40025cc0:	a2ce30ef          	jal	ra,40008eec <shell_fprintf>
		PR("%p[%ld/%u (%u/%u)]", buf, atomic_get(&pkt->atomic_ref),
40025cc4:	40036ab7          	lui	s5,0x40036
40025cc8:	000a0513          	mv	a0,s4
40025ccc:	5bd0b0ef          	jal	ra,40031a88 <atomic_get>
40025cd0:	01095783          	lhu	a5,16(s2)
40025cd4:	00a12623          	sw	a0,12(sp)
	return net_buf_simple_max_len(&buf->b);
40025cd8:	00c90513          	addi	a0,s2,12
40025cdc:	00f12423          	sw	a5,8(sp)
40025ce0:	b65e70ef          	jal	ra,4000d844 <net_buf_simple_max_len>
40025ce4:	01295883          	lhu	a7,18(s2)
40025ce8:	00812783          	lw	a5,8(sp)
40025cec:	00c12703          	lw	a4,12(sp)
40025cf0:	00050813          	mv	a6,a0
40025cf4:	00090693          	mv	a3,s2
40025cf8:	fb4a8613          	addi	a2,s5,-76 # 40035fb4 <CSWTCH.15846+0x954>
40025cfc:	00800593          	li	a1,8
40025d00:	00040513          	mv	a0,s0
40025d04:	9e8e30ef          	jal	ra,40008eec <shell_fprintf>
		buf = buf->frags;
40025d08:	00492903          	lw	s2,4(s2)
		if (buf) {
40025d0c:	02091c63          	bnez	s2,40025d44 <cmd_net_pkt+0x200>
	PR("\n");
40025d10:	40033937          	lui	s2,0x40033
40025d14:	bf490613          	addi	a2,s2,-1036 # 40032bf4 <severity+0x88>
40025d18:	00800593          	li	a1,8
40025d1c:	00040513          	mv	a0,s0
40025d20:	9cce30ef          	jal	ra,40008eec <shell_fprintf>
		PR("\n");
40025d24:	bf490613          	addi	a2,s2,-1036
40025d28:	00800593          	li	a1,8
40025d2c:	00040513          	mv	a0,s0
40025d30:	9bce30ef          	jal	ra,40008eec <shell_fprintf>
	struct net_buf *buf = pkt->buffer;
40025d34:	0084a903          	lw	s2,8(s1)
	if (!buf || buf->ref == 0) {
40025d38:	02091063          	bnez	s2,40025d58 <cmd_net_pkt+0x214>
	return 0;
40025d3c:	00000513          	li	a0,0
40025d40:	ea1ff06f          	j	40025be0 <cmd_net_pkt+0x9c>
			PR("->");
40025d44:	fb098613          	addi	a2,s3,-80
40025d48:	00800593          	li	a1,8
40025d4c:	00040513          	mv	a0,s0
40025d50:	99ce30ef          	jal	ra,40008eec <shell_fprintf>
	while (buf) {
40025d54:	f75ff06f          	j	40025cc8 <cmd_net_pkt+0x184>
	if (!buf || buf->ref == 0) {
40025d58:	00894783          	lbu	a5,8(s2)
40025d5c:	fe0780e3          	beqz	a5,40025d3c <cmd_net_pkt+0x1f8>
	PR("net_pkt %p buffer chain hexdump:\n", pkt);
40025d60:	40036637          	lui	a2,0x40036
40025d64:	00048693          	mv	a3,s1
40025d68:	fc860613          	addi	a2,a2,-56 # 40035fc8 <CSWTCH.15846+0x968>
40025d6c:	00800593          	li	a1,8
40025d70:	00040513          	mv	a0,s0
40025d74:	978e30ef          	jal	ra,40008eec <shell_fprintf>
	int i = 0;
40025d78:	00000493          	li	s1,0
		PR("net_buf[%d] %p\n", i++, buf);
40025d7c:	400369b7          	lui	s3,0x40036
40025d80:	00048693          	mv	a3,s1
40025d84:	00090713          	mv	a4,s2
40025d88:	fec98613          	addi	a2,s3,-20 # 40035fec <CSWTCH.15846+0x98c>
40025d8c:	00800593          	li	a1,8
40025d90:	00040513          	mv	a0,s0
40025d94:	958e30ef          	jal	ra,40008eec <shell_fprintf>
		shell_hexdump(sh, buf->data, buf->len);
40025d98:	01095603          	lhu	a2,16(s2)
40025d9c:	00c92583          	lw	a1,12(s2)
40025da0:	00040513          	mv	a0,s0
		PR("net_buf[%d] %p\n", i++, buf);
40025da4:	00148493          	addi	s1,s1,1
		shell_hexdump(sh, buf->data, buf->len);
40025da8:	ba0e30ef          	jal	ra,40009148 <shell_hexdump>
		buf = buf->frags;
40025dac:	00492903          	lw	s2,4(s2)
	while (buf) {
40025db0:	fc0918e3          	bnez	s2,40025d80 <cmd_net_pkt+0x23c>
40025db4:	f89ff06f          	j	40025d3c <cmd_net_pkt+0x1f8>
		PR_INFO("Pointer value must be given.\n");
40025db8:	40036637          	lui	a2,0x40036
40025dbc:	ffc60613          	addi	a2,a2,-4 # 40035ffc <CSWTCH.15846+0x99c>
40025dc0:	00200593          	li	a1,2
40025dc4:	928e30ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40025dc8:	e15ff06f          	j	40025bdc <cmd_net_pkt+0x98>

40025dcc <ping_cleanup>:
{
40025dcc:	ff010113          	addi	sp,sp,-16
40025dd0:	00812423          	sw	s0,8(sp)
40025dd4:	00050413          	mv	s0,a0
	net_icmpv6_unregister_handler(&ping6_handler);
40025dd8:	40044537          	lui	a0,0x40044
40025ddc:	67c50513          	addi	a0,a0,1660 # 4004467c <ping6_handler>
{
40025de0:	00112623          	sw	ra,12(sp)
	net_icmpv6_unregister_handler(&ping6_handler);
40025de4:	b89f40ef          	jal	ra,4001a96c <net_icmpv6_unregister_handler>
	net_icmpv4_unregister_handler(&ping4_handler);
40025de8:	40044537          	lui	a0,0x40044
40025dec:	67050513          	addi	a0,a0,1648 # 40044670 <ping4_handler>
40025df0:	af0f40ef          	jal	ra,4001a0e0 <net_icmpv4_unregister_handler>
	shell_set_bypass(ctx->sh, NULL);
40025df4:	04842503          	lw	a0,72(s0)
}
40025df8:	00812403          	lw	s0,8(sp)
40025dfc:	00c12083          	lw	ra,12(sp)
	shell_set_bypass(ctx->sh, NULL);
40025e00:	00000593          	li	a1,0
}
40025e04:	01010113          	addi	sp,sp,16
	shell_set_bypass(ctx->sh, NULL);
40025e08:	c24e306f          	j	4000922c <shell_set_bypass>

40025e0c <ping_done>:
{
40025e0c:	ff010113          	addi	sp,sp,-16
40025e10:	00112623          	sw	ra,12(sp)
40025e14:	00812423          	sw	s0,8(sp)
40025e18:	00050413          	mv	s0,a0
	k_work_cancel_delayable(&ctx->work);
40025e1c:	3500a0ef          	jal	ra,4003016c <k_work_cancel_delayable>
	ping_cleanup(ctx);
40025e20:	00040513          	mv	a0,s0
40025e24:	fa9ff0ef          	jal	ra,40025dcc <ping_cleanup>
	shell_fprintf(ctx->sh, SHELL_NORMAL, "");
40025e28:	04842503          	lw	a0,72(s0)
}
40025e2c:	00812403          	lw	s0,8(sp)
40025e30:	00c12083          	lw	ra,12(sp)
	shell_fprintf(ctx->sh, SHELL_NORMAL, "");
40025e34:	40033637          	lui	a2,0x40033
40025e38:	1e860613          	addi	a2,a2,488 # 400331e8 <severity_lvls+0xf0>
40025e3c:	00800593          	li	a1,8
}
40025e40:	01010113          	addi	sp,sp,16
	shell_fprintf(ctx->sh, SHELL_NORMAL, "");
40025e44:	8a8e306f          	j	40008eec <shell_fprintf>

40025e48 <handle_ipv4_echo_reply>:
{
40025e48:	fa010113          	addi	sp,sp,-96
40025e4c:	05212823          	sw	s2,80(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
40025e50:	00400793          	li	a5,4
{
40025e54:	00058913          	mv	s2,a1
	icmp_echo = (struct net_icmpv4_echo_req *)net_pkt_get_data(pkt,
40025e58:	02810593          	addi	a1,sp,40
{
40025e5c:	04812c23          	sw	s0,88(sp)
40025e60:	04112e23          	sw	ra,92(sp)
40025e64:	04912a23          	sw	s1,84(sp)
40025e68:	05312623          	sw	s3,76(sp)
40025e6c:	05412423          	sw	s4,72(sp)
40025e70:	05512223          	sw	s5,68(sp)
40025e74:	00050413          	mv	s0,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
40025e78:	02012423          	sw	zero,40(sp)
40025e7c:	02f12623          	sw	a5,44(sp)
	char time_buf[16] = { 0 };
40025e80:	02012823          	sw	zero,48(sp)
40025e84:	02012a23          	sw	zero,52(sp)
40025e88:	02012c23          	sw	zero,56(sp)
40025e8c:	02012e23          	sw	zero,60(sp)
	icmp_echo = (struct net_icmpv4_echo_req *)net_pkt_get_data(pkt,
40025e90:	a59f20ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (icmp_echo == NULL) {
40025e94:	02051663          	bnez	a0,40025ec0 <handle_ipv4_echo_reply+0x78>
		return -NET_DROP;
40025e98:	ffe00513          	li	a0,-2
}
40025e9c:	05c12083          	lw	ra,92(sp)
40025ea0:	05812403          	lw	s0,88(sp)
40025ea4:	05412483          	lw	s1,84(sp)
40025ea8:	05012903          	lw	s2,80(sp)
40025eac:	04c12983          	lw	s3,76(sp)
40025eb0:	04812a03          	lw	s4,72(sp)
40025eb4:	04412a83          	lw	s5,68(sp)
40025eb8:	06010113          	addi	sp,sp,96
40025ebc:	00008067          	ret
	net_pkt_skip(pkt, sizeof(*icmp_echo));
40025ec0:	00400593          	li	a1,4
40025ec4:	00050493          	mv	s1,a0
40025ec8:	00040513          	mv	a0,s0
40025ecc:	a04f20ef          	jal	ra,400180d0 <net_pkt_skip>
	if (net_pkt_remaining_data(pkt) >= sizeof(uint32_t)) {
40025ed0:	00040513          	mv	a0,s0
40025ed4:	e00f20ef          	jal	ra,400184d4 <net_pkt_remaining_data>
40025ed8:	00300793          	li	a5,3
40025edc:	04a7f663          	bgeu	a5,a0,40025f28 <handle_ipv4_echo_reply+0xe0>
		if (net_pkt_read_be32(pkt, &cycles)) {
40025ee0:	02410593          	addi	a1,sp,36
40025ee4:	00040513          	mv	a0,s0
40025ee8:	c5cf20ef          	jal	ra,40018344 <net_pkt_read_be32>
40025eec:	fa0516e3          	bnez	a0,40025e98 <handle_ipv4_echo_reply+0x50>
40025ef0:	078070ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
		cycles = k_cycle_get_32() - cycles;
40025ef4:	02412783          	lw	a5,36(sp)
		snprintf(time_buf, sizeof(time_buf),
40025ef8:	000f46b7          	lui	a3,0xf4
40025efc:	24068693          	addi	a3,a3,576 # f4240 <__rom_region_size+0xbb284>
		cycles = k_cycle_get_32() - cycles;
40025f00:	40f50533          	sub	a0,a0,a5
			return t * ((uint64_t)to_hz / from_hz);
40025f04:	00a00793          	li	a5,10
40025f08:	02a12223          	sw	a0,36(sp)
40025f0c:	02f50533          	mul	a0,a0,a5
		snprintf(time_buf, sizeof(time_buf),
40025f10:	40036637          	lui	a2,0x40036
40025f14:	01c60613          	addi	a2,a2,28 # 4003601c <CSWTCH.15846+0x9bc>
40025f18:	01000593          	li	a1,16
40025f1c:	02d556b3          	divu	a3,a0,a3
40025f20:	03010513          	addi	a0,sp,48
40025f24:	e8de60ef          	jal	ra,4000cdb0 <snprintf>
	PR_SHELL(ping_ctx.sh, "%d bytes from %s to %s: icmp_seq=%d ttl=%d "
40025f28:	00394783          	lbu	a5,3(s2)
40025f2c:	00294703          	lbu	a4,2(s2)
40025f30:	4003aa37          	lui	s4,0x4003a
40025f34:	00879793          	slli	a5,a5,0x8
40025f38:	00e7e7b3          	or	a5,a5,a4
40025f3c:	00879693          	slli	a3,a5,0x8
40025f40:	0087d793          	srli	a5,a5,0x8
40025f44:	00f6e6b3          	or	a3,a3,a5
40025f48:	03a45783          	lhu	a5,58(s0)
40025f4c:	01069693          	slli	a3,a3,0x10
40025f50:	0106d693          	srli	a3,a3,0x10
40025f54:	40f686b3          	sub	a3,a3,a5
40025f58:	ffc68693          	addi	a3,a3,-4
40025f5c:	d58a0a93          	addi	s5,s4,-680 # 40039d58 <ping_ctx>
40025f60:	00c90593          	addi	a1,s2,12
40025f64:	00100513          	li	a0,1
40025f68:	00d12e23          	sw	a3,28(sp)
40025f6c:	048aa983          	lw	s3,72(s5)
40025f70:	945ee0ef          	jal	ra,400148b4 <net_sprint_addr>
40025f74:	00a12c23          	sw	a0,24(sp)
40025f78:	01090593          	addi	a1,s2,16
40025f7c:	00100513          	li	a0,1
40025f80:	935ee0ef          	jal	ra,400148b4 <net_sprint_addr>
40025f84:	0034c603          	lbu	a2,3(s1)
40025f88:	0024c583          	lbu	a1,2(s1)
40025f8c:	01812703          	lw	a4,24(sp)
40025f90:	00861613          	slli	a2,a2,0x8
40025f94:	00b66633          	or	a2,a2,a1
40025f98:	00861813          	slli	a6,a2,0x8
40025f9c:	00865613          	srli	a2,a2,0x8
40025fa0:	00c86833          	or	a6,a6,a2
40025fa4:	03010613          	addi	a2,sp,48
40025fa8:	00c12023          	sw	a2,0(sp)
40025fac:	00894883          	lbu	a7,8(s2)
40025fb0:	01c12683          	lw	a3,28(sp)
40025fb4:	01081813          	slli	a6,a6,0x10
40025fb8:	40036637          	lui	a2,0x40036
40025fbc:	00050793          	mv	a5,a0
40025fc0:	01085813          	srli	a6,a6,0x10
40025fc4:	02860613          	addi	a2,a2,40 # 40036028 <CSWTCH.15846+0x9c8>
40025fc8:	00800593          	li	a1,8
40025fcc:	00098513          	mv	a0,s3
40025fd0:	f1de20ef          	jal	ra,40008eec <shell_fprintf>
	if (ntohs(icmp_echo->sequence) == ping_ctx.count) {
40025fd4:	0034c783          	lbu	a5,3(s1)
40025fd8:	0024c703          	lbu	a4,2(s1)
40025fdc:	00879793          	slli	a5,a5,0x8
40025fe0:	00e7e7b3          	or	a5,a5,a4
40025fe4:	00879713          	slli	a4,a5,0x8
40025fe8:	0087d793          	srli	a5,a5,0x8
40025fec:	00f767b3          	or	a5,a4,a5
40025ff0:	04caa703          	lw	a4,76(s5)
40025ff4:	01079793          	slli	a5,a5,0x10
40025ff8:	0107d793          	srli	a5,a5,0x10
40025ffc:	00e79663          	bne	a5,a4,40026008 <handle_ipv4_echo_reply+0x1c0>
		ping_done(&ping_ctx);
40026000:	d58a0513          	addi	a0,s4,-680
40026004:	e09ff0ef          	jal	ra,40025e0c <ping_done>
	net_pkt_unref(pkt);
40026008:	00040513          	mv	a0,s0
4002600c:	811f10ef          	jal	ra,4001781c <net_pkt_unref>
	return NET_OK;
40026010:	00000513          	li	a0,0
40026014:	e89ff06f          	j	40025e9c <handle_ipv4_echo_reply+0x54>

40026018 <handle_ipv6_echo_reply>:
{
40026018:	fa010113          	addi	sp,sp,-96
4002601c:	05212823          	sw	s2,80(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
40026020:	00400793          	li	a5,4
{
40026024:	00058913          	mv	s2,a1
	icmp_echo = (struct net_icmpv6_echo_req *)net_pkt_get_data(pkt,
40026028:	02810593          	addi	a1,sp,40
{
4002602c:	04812c23          	sw	s0,88(sp)
40026030:	04112e23          	sw	ra,92(sp)
40026034:	04912a23          	sw	s1,84(sp)
40026038:	05312623          	sw	s3,76(sp)
4002603c:	05412423          	sw	s4,72(sp)
40026040:	05512223          	sw	s5,68(sp)
40026044:	00050413          	mv	s0,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
40026048:	02012423          	sw	zero,40(sp)
4002604c:	02f12623          	sw	a5,44(sp)
	char time_buf[16] = { 0 };
40026050:	02012823          	sw	zero,48(sp)
40026054:	02012a23          	sw	zero,52(sp)
40026058:	02012c23          	sw	zero,56(sp)
4002605c:	02012e23          	sw	zero,60(sp)
	icmp_echo = (struct net_icmpv6_echo_req *)net_pkt_get_data(pkt,
40026060:	889f20ef          	jal	ra,400188e8 <net_pkt_get_data>
	if (icmp_echo == NULL) {
40026064:	02051663          	bnez	a0,40026090 <handle_ipv6_echo_reply+0x78>
		return -NET_DROP;
40026068:	ffe00513          	li	a0,-2
}
4002606c:	05c12083          	lw	ra,92(sp)
40026070:	05812403          	lw	s0,88(sp)
40026074:	05412483          	lw	s1,84(sp)
40026078:	05012903          	lw	s2,80(sp)
4002607c:	04c12983          	lw	s3,76(sp)
40026080:	04812a03          	lw	s4,72(sp)
40026084:	04412a83          	lw	s5,68(sp)
40026088:	06010113          	addi	sp,sp,96
4002608c:	00008067          	ret
	net_pkt_skip(pkt, sizeof(*icmp_echo));
40026090:	00400593          	li	a1,4
40026094:	00050493          	mv	s1,a0
40026098:	00040513          	mv	a0,s0
4002609c:	834f20ef          	jal	ra,400180d0 <net_pkt_skip>
	if (net_pkt_remaining_data(pkt) >= sizeof(uint32_t)) {
400260a0:	00040513          	mv	a0,s0
400260a4:	c30f20ef          	jal	ra,400184d4 <net_pkt_remaining_data>
400260a8:	00300793          	li	a5,3
400260ac:	04a7f663          	bgeu	a5,a0,400260f8 <handle_ipv6_echo_reply+0xe0>
		if (net_pkt_read_be32(pkt, &cycles)) {
400260b0:	02410593          	addi	a1,sp,36
400260b4:	00040513          	mv	a0,s0
400260b8:	a8cf20ef          	jal	ra,40018344 <net_pkt_read_be32>
400260bc:	fa0516e3          	bnez	a0,40026068 <handle_ipv6_echo_reply+0x50>
400260c0:	6a9060ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
		cycles = k_cycle_get_32() - cycles;
400260c4:	02412783          	lw	a5,36(sp)
		snprintf(time_buf, sizeof(time_buf),
400260c8:	000f46b7          	lui	a3,0xf4
400260cc:	24068693          	addi	a3,a3,576 # f4240 <__rom_region_size+0xbb284>
		cycles = k_cycle_get_32() - cycles;
400260d0:	40f50533          	sub	a0,a0,a5
400260d4:	00a00793          	li	a5,10
400260d8:	02a12223          	sw	a0,36(sp)
400260dc:	02f50533          	mul	a0,a0,a5
		snprintf(time_buf, sizeof(time_buf),
400260e0:	40036637          	lui	a2,0x40036
400260e4:	01c60613          	addi	a2,a2,28 # 4003601c <CSWTCH.15846+0x9bc>
400260e8:	01000593          	li	a1,16
400260ec:	02d556b3          	divu	a3,a0,a3
400260f0:	03010513          	addi	a0,sp,48
400260f4:	cbde60ef          	jal	ra,4000cdb0 <snprintf>
	PR_SHELL(ping_ctx.sh, "%d bytes from %s to %s: icmp_seq=%d ttl=%d "
400260f8:	00594783          	lbu	a5,5(s2)
400260fc:	00494703          	lbu	a4,4(s2)
40026100:	4003aa37          	lui	s4,0x4003a
40026104:	00879793          	slli	a5,a5,0x8
40026108:	00e7e7b3          	or	a5,a5,a4
4002610c:	00879693          	slli	a3,a5,0x8
40026110:	0087d793          	srli	a5,a5,0x8
40026114:	00f6e6b3          	or	a3,a3,a5
40026118:	03a45783          	lhu	a5,58(s0)
4002611c:	01069693          	slli	a3,a3,0x10
40026120:	0106d693          	srli	a3,a3,0x10
40026124:	40f686b3          	sub	a3,a3,a5
40026128:	ffc68693          	addi	a3,a3,-4
4002612c:	d58a0a93          	addi	s5,s4,-680 # 40039d58 <ping_ctx>
40026130:	00890593          	addi	a1,s2,8
40026134:	00200513          	li	a0,2
40026138:	00d12e23          	sw	a3,28(sp)
4002613c:	048aa983          	lw	s3,72(s5)
40026140:	f74ee0ef          	jal	ra,400148b4 <net_sprint_addr>
40026144:	00a12c23          	sw	a0,24(sp)
40026148:	01890593          	addi	a1,s2,24
4002614c:	00200513          	li	a0,2
40026150:	f64ee0ef          	jal	ra,400148b4 <net_sprint_addr>
40026154:	0034c603          	lbu	a2,3(s1)
40026158:	0024c583          	lbu	a1,2(s1)
4002615c:	01812703          	lw	a4,24(sp)
40026160:	00861613          	slli	a2,a2,0x8
40026164:	00b66633          	or	a2,a2,a1
40026168:	00861813          	slli	a6,a2,0x8
4002616c:	00865613          	srli	a2,a2,0x8
40026170:	00c86833          	or	a6,a6,a2
40026174:	03010613          	addi	a2,sp,48
40026178:	00c12023          	sw	a2,0(sp)
4002617c:	00794883          	lbu	a7,7(s2)
40026180:	01c12683          	lw	a3,28(sp)
40026184:	01081813          	slli	a6,a6,0x10
40026188:	40036637          	lui	a2,0x40036
4002618c:	00050793          	mv	a5,a0
40026190:	01085813          	srli	a6,a6,0x10
40026194:	02860613          	addi	a2,a2,40 # 40036028 <CSWTCH.15846+0x9c8>
40026198:	00800593          	li	a1,8
4002619c:	00098513          	mv	a0,s3
400261a0:	d4de20ef          	jal	ra,40008eec <shell_fprintf>
	if (ntohs(icmp_echo->sequence) == ping_ctx.count) {
400261a4:	0034c783          	lbu	a5,3(s1)
400261a8:	0024c703          	lbu	a4,2(s1)
400261ac:	00879793          	slli	a5,a5,0x8
400261b0:	00e7e7b3          	or	a5,a5,a4
400261b4:	00879713          	slli	a4,a5,0x8
400261b8:	0087d793          	srli	a5,a5,0x8
400261bc:	00f767b3          	or	a5,a4,a5
400261c0:	04caa703          	lw	a4,76(s5)
400261c4:	01079793          	slli	a5,a5,0x10
400261c8:	0107d793          	srli	a5,a5,0x10
400261cc:	00e79663          	bne	a5,a4,400261d8 <handle_ipv6_echo_reply+0x1c0>
		ping_done(&ping_ctx);
400261d0:	d58a0513          	addi	a0,s4,-680
400261d4:	c39ff0ef          	jal	ra,40025e0c <ping_done>
	net_pkt_unref(pkt);
400261d8:	00040513          	mv	a0,s0
400261dc:	e40f10ef          	jal	ra,4001781c <net_pkt_unref>
	return NET_OK;
400261e0:	00000513          	li	a0,0
400261e4:	e89ff06f          	j	4002606c <handle_ipv6_echo_reply+0x54>

400261e8 <cmd_net_nbr_rm>:
{
400261e8:	fe010113          	addi	sp,sp,-32
400261ec:	00112e23          	sw	ra,28(sp)
400261f0:	00812c23          	sw	s0,24(sp)
400261f4:	00912a23          	sw	s1,20(sp)
	if (!argv[1]) {
400261f8:	00462583          	lw	a1,4(a2)
400261fc:	02059663          	bnez	a1,40026228 <cmd_net_nbr_rm+0x40>
		PR_WARNING("Neighbor IPv6 address missing.\n");
40026200:	40036637          	lui	a2,0x40036
40026204:	05860613          	addi	a2,a2,88 # 40036058 <CSWTCH.15846+0x9f8>
40026208:	00300593          	li	a1,3
4002620c:	ce1e20ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40026210:	ff800513          	li	a0,-8
}
40026214:	01c12083          	lw	ra,28(sp)
40026218:	01812403          	lw	s0,24(sp)
4002621c:	01412483          	lw	s1,20(sp)
40026220:	02010113          	addi	sp,sp,32
40026224:	00008067          	ret
40026228:	00050413          	mv	s0,a0
4002622c:	00060493          	mv	s1,a2
	ret = net_addr_pton(AF_INET6, argv[1], &addr);
40026230:	00200513          	li	a0,2
40026234:	00010613          	mv	a2,sp
40026238:	af0ff0ef          	jal	ra,40025528 <net_addr_pton>
	if (ret < 0) {
4002623c:	02055063          	bgez	a0,4002625c <cmd_net_nbr_rm+0x74>
		PR_WARNING("Cannot parse '%s'\n", argv[1]);
40026240:	0044a683          	lw	a3,4(s1)
40026244:	40036637          	lui	a2,0x40036
40026248:	07860613          	addi	a2,a2,120 # 40036078 <CSWTCH.15846+0xa18>
4002624c:	00300593          	li	a1,3
40026250:	00040513          	mv	a0,s0
40026254:	c99e20ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40026258:	fb9ff06f          	j	40026210 <cmd_net_nbr_rm+0x28>
	if (!net_ipv6_nbr_rm(NULL, &addr)) {
4002625c:	00010593          	mv	a1,sp
40026260:	00000513          	li	a0,0
40026264:	e80f60ef          	jal	ra,4001c8e4 <net_ipv6_nbr_rm>
		PR_WARNING("Cannot remove neighbor %s\n",
40026268:	00010593          	mv	a1,sp
	if (!net_ipv6_nbr_rm(NULL, &addr)) {
4002626c:	00051e63          	bnez	a0,40026288 <cmd_net_nbr_rm+0xa0>
		PR_WARNING("Cannot remove neighbor %s\n",
40026270:	00200513          	li	a0,2
40026274:	e40ee0ef          	jal	ra,400148b4 <net_sprint_addr>
40026278:	40036637          	lui	a2,0x40036
4002627c:	00050693          	mv	a3,a0
40026280:	08c60613          	addi	a2,a2,140 # 4003608c <CSWTCH.15846+0xa2c>
40026284:	fc9ff06f          	j	4002624c <cmd_net_nbr_rm+0x64>
		PR("Neighbor %s removed.\n", net_sprint_ipv6_addr(&addr));
40026288:	00200513          	li	a0,2
4002628c:	e28ee0ef          	jal	ra,400148b4 <net_sprint_addr>
40026290:	40036637          	lui	a2,0x40036
40026294:	00050693          	mv	a3,a0
40026298:	0a860613          	addi	a2,a2,168 # 400360a8 <CSWTCH.15846+0xa48>
4002629c:	00040513          	mv	a0,s0
400262a0:	00800593          	li	a1,8
400262a4:	c49e20ef          	jal	ra,40008eec <shell_fprintf>
	return 0;
400262a8:	00000513          	li	a0,0
400262ac:	f69ff06f          	j	40026214 <cmd_net_nbr_rm+0x2c>

400262b0 <cmd_net_ip_del>:
{
400262b0:	fc010113          	addi	sp,sp,-64
400262b4:	02112e23          	sw	ra,60(sp)
400262b8:	02812c23          	sw	s0,56(sp)
400262bc:	02912a23          	sw	s1,52(sp)
400262c0:	03212823          	sw	s2,48(sp)
400262c4:	03312623          	sw	s3,44(sp)
	if (argc != 3) {
400262c8:	00300793          	li	a5,3
400262cc:	00f58e63          	beq	a1,a5,400262e8 <cmd_net_ip_del+0x38>
		PR_ERROR("Correct usage: net ipv4 del <index> <address>");
400262d0:	40036637          	lui	a2,0x40036
400262d4:	0c060613          	addi	a2,a2,192 # 400360c0 <CSWTCH.15846+0xa60>
400262d8:	00100593          	li	a1,1
400262dc:	c11e20ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
400262e0:	fea00413          	li	s0,-22
400262e4:	0440006f          	j	40026328 <cmd_net_ip_del+0x78>
	idx = get_iface_idx(sh, argv[1]);
400262e8:	00462583          	lw	a1,4(a2)
400262ec:	00050913          	mv	s2,a0
400262f0:	00060493          	mv	s1,a2
400262f4:	f9dfe0ef          	jal	ra,40025290 <get_iface_idx>
	if (idx < 0) {
400262f8:	00a12623          	sw	a0,12(sp)
400262fc:	02054463          	bltz	a0,40026324 <cmd_net_ip_del+0x74>
	iface = net_if_get_by_index(idx);
40026300:	be5fe0ef          	jal	ra,40024ee4 <net_if_get_by_index>
	if (!iface) {
40026304:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
40026308:	00050993          	mv	s3,a0
	if (!iface) {
4002630c:	02051e63          	bnez	a0,40026348 <cmd_net_ip_del+0x98>
		PR_WARNING("No such interface in index %d\n", idx);
40026310:	40036637          	lui	a2,0x40036
40026314:	da060613          	addi	a2,a2,-608 # 40035da0 <CSWTCH.15846+0x740>
40026318:	00300593          	li	a1,3
4002631c:	00090513          	mv	a0,s2
40026320:	bcde20ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40026324:	ff800413          	li	s0,-8
}
40026328:	03c12083          	lw	ra,60(sp)
4002632c:	00040513          	mv	a0,s0
40026330:	03812403          	lw	s0,56(sp)
40026334:	03412483          	lw	s1,52(sp)
40026338:	03012903          	lw	s2,48(sp)
4002633c:	02c12983          	lw	s3,44(sp)
40026340:	04010113          	addi	sp,sp,64
40026344:	00008067          	ret
	if (net_addr_pton(AF_INET, argv[2], &addr)) {
40026348:	0084a583          	lw	a1,8(s1)
4002634c:	01c10613          	addi	a2,sp,28
40026350:	00100513          	li	a0,1
40026354:	9d4ff0ef          	jal	ra,40025528 <net_addr_pton>
40026358:	00050413          	mv	s0,a0
4002635c:	02050063          	beqz	a0,4002637c <cmd_net_ip_del+0xcc>
		PR_ERROR("Invalid address: %s\n", argv[2]);
40026360:	0084a683          	lw	a3,8(s1)
40026364:	40036637          	lui	a2,0x40036
40026368:	df460613          	addi	a2,a2,-524 # 40035df4 <CSWTCH.15846+0x794>
4002636c:	00100593          	li	a1,1
40026370:	00090513          	mv	a0,s2
40026374:	b79e20ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
40026378:	f69ff06f          	j	400262e0 <cmd_net_ip_del+0x30>
	if (!net_if_ipv4_addr_rm(iface, &addr)) {
4002637c:	01c10593          	addi	a1,sp,28
40026380:	00098513          	mv	a0,s3
40026384:	9e4ed0ef          	jal	ra,40013568 <net_if_ipv4_addr_rm>
40026388:	fa0510e3          	bnez	a0,40026328 <cmd_net_ip_del+0x78>
		PR_ERROR("Failed to delete %s\n", argv[2]);
4002638c:	40036637          	lui	a2,0x40036
40026390:	0084a683          	lw	a3,8(s1)
40026394:	0f060613          	addi	a2,a2,240 # 400360f0 <CSWTCH.15846+0xa90>
40026398:	00100593          	li	a1,1
4002639c:	f81ff06f          	j	4002631c <cmd_net_ip_del+0x6c>

400263a0 <cmd_net_ip_add>:
{
400263a0:	fc010113          	addi	sp,sp,-64
400263a4:	02112e23          	sw	ra,60(sp)
400263a8:	02812c23          	sw	s0,56(sp)
400263ac:	02912a23          	sw	s1,52(sp)
400263b0:	03212823          	sw	s2,48(sp)
400263b4:	03312623          	sw	s3,44(sp)
	if (argc != 4) {
400263b8:	00400793          	li	a5,4
400263bc:	00f58e63          	beq	a1,a5,400263d8 <cmd_net_ip_add+0x38>
		PR_ERROR("Correct usage: net ipv4 add <index> <address> <netmask>\n");
400263c0:	40036637          	lui	a2,0x40036
400263c4:	10860613          	addi	a2,a2,264 # 40036108 <CSWTCH.15846+0xaa8>
400263c8:	00100593          	li	a1,1
400263cc:	b21e20ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
400263d0:	fea00493          	li	s1,-22
400263d4:	0440006f          	j	40026418 <cmd_net_ip_add+0x78>
	idx = get_iface_idx(sh, argv[1]);
400263d8:	00462583          	lw	a1,4(a2)
400263dc:	00050993          	mv	s3,a0
400263e0:	00060413          	mv	s0,a2
400263e4:	eadfe0ef          	jal	ra,40025290 <get_iface_idx>
	if (idx < 0) {
400263e8:	00a12623          	sw	a0,12(sp)
400263ec:	02054463          	bltz	a0,40026414 <cmd_net_ip_add+0x74>
	iface = net_if_get_by_index(idx);
400263f0:	af5fe0ef          	jal	ra,40024ee4 <net_if_get_by_index>
	if (!iface) {
400263f4:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
400263f8:	00050913          	mv	s2,a0
	if (!iface) {
400263fc:	02051e63          	bnez	a0,40026438 <cmd_net_ip_add+0x98>
		PR_WARNING("No such interface in index %d\n", idx);
40026400:	40036637          	lui	a2,0x40036
40026404:	da060613          	addi	a2,a2,-608 # 40035da0 <CSWTCH.15846+0x740>
40026408:	00300593          	li	a1,3
4002640c:	00098513          	mv	a0,s3
40026410:	adde20ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40026414:	ff800493          	li	s1,-8
}
40026418:	03c12083          	lw	ra,60(sp)
4002641c:	03812403          	lw	s0,56(sp)
40026420:	03012903          	lw	s2,48(sp)
40026424:	02c12983          	lw	s3,44(sp)
40026428:	00048513          	mv	a0,s1
4002642c:	03412483          	lw	s1,52(sp)
40026430:	04010113          	addi	sp,sp,64
40026434:	00008067          	ret
	if (net_addr_pton(AF_INET, argv[2], &addr)) {
40026438:	00842583          	lw	a1,8(s0)
4002643c:	01c10613          	addi	a2,sp,28
40026440:	00100513          	li	a0,1
40026444:	8e4ff0ef          	jal	ra,40025528 <net_addr_pton>
40026448:	02050063          	beqz	a0,40026468 <cmd_net_ip_add+0xc8>
		PR_ERROR("Invalid address: %s\n", argv[2]);
4002644c:	00842683          	lw	a3,8(s0)
40026450:	40036637          	lui	a2,0x40036
40026454:	df460613          	addi	a2,a2,-524 # 40035df4 <CSWTCH.15846+0x794>
40026458:	00100593          	li	a1,1
4002645c:	00098513          	mv	a0,s3
40026460:	a8de20ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
40026464:	f6dff06f          	j	400263d0 <cmd_net_ip_add+0x30>
	net_if_ipv4_addr_add(iface, &addr, NET_ADDR_MANUAL, 0);
40026468:	00000693          	li	a3,0
4002646c:	00300613          	li	a2,3
40026470:	01c10593          	addi	a1,sp,28
40026474:	00090513          	mv	a0,s2
40026478:	f91ec0ef          	jal	ra,40013408 <net_if_ipv4_addr_add>
	if (net_addr_pton(AF_INET, argv[3], &addr)) {
4002647c:	00c42583          	lw	a1,12(s0)
40026480:	01c10613          	addi	a2,sp,28
40026484:	00100513          	li	a0,1
40026488:	8a0ff0ef          	jal	ra,40025528 <net_addr_pton>
4002648c:	00050493          	mv	s1,a0
40026490:	00050a63          	beqz	a0,400264a4 <cmd_net_ip_add+0x104>
		PR_ERROR("Invalid netmask: %s", argv[3]);
40026494:	40036637          	lui	a2,0x40036
40026498:	00c42683          	lw	a3,12(s0)
4002649c:	14460613          	addi	a2,a2,324 # 40036144 <CSWTCH.15846+0xae4>
400264a0:	fb9ff06f          	j	40026458 <cmd_net_ip_add+0xb8>
	net_if_ipv4_set_netmask(iface, &addr);
400264a4:	01c10593          	addi	a1,sp,28
400264a8:	00090513          	mv	a0,s2
400264ac:	ec9ec0ef          	jal	ra,40013374 <net_if_ipv4_set_netmask>
	return 0;
400264b0:	f69ff06f          	j	40026418 <cmd_net_ip_add+0x78>

400264b4 <cmd_net_ip6_del>:
{
400264b4:	fc010113          	addi	sp,sp,-64
400264b8:	02112e23          	sw	ra,60(sp)
400264bc:	02812c23          	sw	s0,56(sp)
400264c0:	02912a23          	sw	s1,52(sp)
400264c4:	03212823          	sw	s2,48(sp)
400264c8:	03312623          	sw	s3,44(sp)
	if (argc != 3) {
400264cc:	00300793          	li	a5,3
400264d0:	00f58e63          	beq	a1,a5,400264ec <cmd_net_ip6_del+0x38>
		PR_ERROR("Correct usage: net ipv6 del <index> <address>\n");
400264d4:	40036637          	lui	a2,0x40036
400264d8:	15860613          	addi	a2,a2,344 # 40036158 <CSWTCH.15846+0xaf8>
400264dc:	00100593          	li	a1,1
400264e0:	a0de20ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
400264e4:	fea00413          	li	s0,-22
400264e8:	0440006f          	j	4002652c <cmd_net_ip6_del+0x78>
	idx = get_iface_idx(sh, argv[1]);
400264ec:	00462583          	lw	a1,4(a2)
400264f0:	00050913          	mv	s2,a0
400264f4:	00060493          	mv	s1,a2
400264f8:	d99fe0ef          	jal	ra,40025290 <get_iface_idx>
	if (idx < 0) {
400264fc:	00a12623          	sw	a0,12(sp)
40026500:	02054463          	bltz	a0,40026528 <cmd_net_ip6_del+0x74>
	iface = net_if_get_by_index(idx);
40026504:	9e1fe0ef          	jal	ra,40024ee4 <net_if_get_by_index>
	if (!iface) {
40026508:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
4002650c:	00050993          	mv	s3,a0
	if (!iface) {
40026510:	02051e63          	bnez	a0,4002654c <cmd_net_ip6_del+0x98>
		PR_WARNING("No such interface in index %d\n", idx);
40026514:	40036637          	lui	a2,0x40036
40026518:	da060613          	addi	a2,a2,-608 # 40035da0 <CSWTCH.15846+0x740>
4002651c:	00300593          	li	a1,3
40026520:	00090513          	mv	a0,s2
40026524:	9c9e20ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40026528:	ff800413          	li	s0,-8
}
4002652c:	03c12083          	lw	ra,60(sp)
40026530:	00040513          	mv	a0,s0
40026534:	03812403          	lw	s0,56(sp)
40026538:	03412483          	lw	s1,52(sp)
4002653c:	03012903          	lw	s2,48(sp)
40026540:	02c12983          	lw	s3,44(sp)
40026544:	04010113          	addi	sp,sp,64
40026548:	00008067          	ret
	if (net_addr_pton(AF_INET6, argv[2], &addr)) {
4002654c:	0084a583          	lw	a1,8(s1)
40026550:	01010613          	addi	a2,sp,16
40026554:	00200513          	li	a0,2
40026558:	fd1fe0ef          	jal	ra,40025528 <net_addr_pton>
4002655c:	00050413          	mv	s0,a0
40026560:	02050063          	beqz	a0,40026580 <cmd_net_ip6_del+0xcc>
		PR_ERROR("Invalid address: %s\n", argv[2]);
40026564:	0084a683          	lw	a3,8(s1)
40026568:	40036637          	lui	a2,0x40036
4002656c:	df460613          	addi	a2,a2,-524 # 40035df4 <CSWTCH.15846+0x794>
40026570:	00100593          	li	a1,1
40026574:	00090513          	mv	a0,s2
40026578:	975e20ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
4002657c:	f69ff06f          	j	400264e4 <cmd_net_ip6_del+0x30>
	if (!net_if_ipv6_addr_rm(iface, &addr)) {
40026580:	01010593          	addi	a1,sp,16
40026584:	00098513          	mv	a0,s3
40026588:	f70eb0ef          	jal	ra,40011cf8 <net_if_ipv6_addr_rm>
4002658c:	fa0510e3          	bnez	a0,4002652c <cmd_net_ip6_del+0x78>
		PR_ERROR("Failed to delete %s\n", argv[2]);
40026590:	0084a683          	lw	a3,8(s1)
40026594:	40036637          	lui	a2,0x40036
40026598:	0f060613          	addi	a2,a2,240 # 400360f0 <CSWTCH.15846+0xa90>
4002659c:	00100593          	li	a1,1
400265a0:	00090513          	mv	a0,s2
400265a4:	949e20ef          	jal	ra,40008eec <shell_fprintf>
		return -1;
400265a8:	fff00413          	li	s0,-1
400265ac:	f81ff06f          	j	4002652c <cmd_net_ip6_del+0x78>

400265b0 <cmd_net_ip6_add>:
{
400265b0:	fc010113          	addi	sp,sp,-64
400265b4:	02112e23          	sw	ra,60(sp)
400265b8:	02812c23          	sw	s0,56(sp)
400265bc:	02912a23          	sw	s1,52(sp)
400265c0:	03212823          	sw	s2,48(sp)
400265c4:	03312623          	sw	s3,44(sp)
	if (argc != 3) {
400265c8:	00300793          	li	a5,3
400265cc:	00f58e63          	beq	a1,a5,400265e8 <cmd_net_ip6_add+0x38>
		PR_ERROR("Correct usage: net ipv6 add <index> <address>\n");
400265d0:	40036637          	lui	a2,0x40036
400265d4:	18860613          	addi	a2,a2,392 # 40036188 <CSWTCH.15846+0xb28>
400265d8:	00100593          	li	a1,1
400265dc:	911e20ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
400265e0:	fea00413          	li	s0,-22
400265e4:	0480006f          	j	4002662c <cmd_net_ip6_add+0x7c>
	idx = get_iface_idx(sh, argv[1]);
400265e8:	00462583          	lw	a1,4(a2)
400265ec:	00050913          	mv	s2,a0
400265f0:	00060493          	mv	s1,a2
400265f4:	c9dfe0ef          	jal	ra,40025290 <get_iface_idx>
	if (idx < 0) {
400265f8:	00a12623          	sw	a0,12(sp)
		return -ENOEXEC;
400265fc:	ff800413          	li	s0,-8
	if (idx < 0) {
40026600:	02054663          	bltz	a0,4002662c <cmd_net_ip6_add+0x7c>
	iface = net_if_get_by_index(idx);
40026604:	8e1fe0ef          	jal	ra,40024ee4 <net_if_get_by_index>
	if (!iface) {
40026608:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
4002660c:	00050993          	mv	s3,a0
	if (!iface) {
40026610:	02051e63          	bnez	a0,4002664c <cmd_net_ip6_add+0x9c>
		PR_WARNING("No such interface in index %d\n", idx);
40026614:	40036637          	lui	a2,0x40036
40026618:	da060613          	addi	a2,a2,-608 # 40035da0 <CSWTCH.15846+0x740>
4002661c:	00300593          	li	a1,3
40026620:	00090513          	mv	a0,s2
40026624:	8c9e20ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOENT;
40026628:	ffe00413          	li	s0,-2
}
4002662c:	03c12083          	lw	ra,60(sp)
40026630:	00040513          	mv	a0,s0
40026634:	03812403          	lw	s0,56(sp)
40026638:	03412483          	lw	s1,52(sp)
4002663c:	03012903          	lw	s2,48(sp)
40026640:	02c12983          	lw	s3,44(sp)
40026644:	04010113          	addi	sp,sp,64
40026648:	00008067          	ret
	if (net_addr_pton(AF_INET6, argv[2], &addr)) {
4002664c:	0084a583          	lw	a1,8(s1)
40026650:	01010613          	addi	a2,sp,16
40026654:	00200513          	li	a0,2
40026658:	ed1fe0ef          	jal	ra,40025528 <net_addr_pton>
4002665c:	00050413          	mv	s0,a0
40026660:	02050063          	beqz	a0,40026680 <cmd_net_ip6_add+0xd0>
		PR_ERROR("Invalid address: %s\n", argv[2]);
40026664:	0084a683          	lw	a3,8(s1)
40026668:	40036637          	lui	a2,0x40036
4002666c:	df460613          	addi	a2,a2,-524 # 40035df4 <CSWTCH.15846+0x794>
40026670:	00100593          	li	a1,1
40026674:	00090513          	mv	a0,s2
40026678:	875e20ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
4002667c:	f65ff06f          	j	400265e0 <cmd_net_ip6_add+0x30>
	if (!net_if_ipv6_addr_add(iface, &addr, NET_ADDR_MANUAL, 0)) {
40026680:	00000693          	li	a3,0
40026684:	00300613          	li	a2,3
40026688:	01010593          	addi	a1,sp,16
4002668c:	00098513          	mv	a0,s3
40026690:	dd1ea0ef          	jal	ra,40011460 <net_if_ipv6_addr_add>
40026694:	f8051ce3          	bnez	a0,4002662c <cmd_net_ip6_add+0x7c>
		PR_ERROR("Failed to add %s address to interface %p\n", argv[2], iface);
40026698:	0084a683          	lw	a3,8(s1)
4002669c:	40036637          	lui	a2,0x40036
400266a0:	00098713          	mv	a4,s3
400266a4:	1b860613          	addi	a2,a2,440 # 400361b8 <CSWTCH.15846+0xb58>
400266a8:	00100593          	li	a1,1
400266ac:	00090513          	mv	a0,s2
400266b0:	83de20ef          	jal	ra,40008eec <shell_fprintf>
400266b4:	f79ff06f          	j	4002662c <cmd_net_ip6_add+0x7c>

400266b8 <cmd_net_iface_down>:
{
400266b8:	fe010113          	addi	sp,sp,-32
400266bc:	00812c23          	sw	s0,24(sp)
400266c0:	00112e23          	sw	ra,28(sp)
	idx = get_iface_idx(sh, argv[1]);
400266c4:	00462583          	lw	a1,4(a2)
{
400266c8:	00050413          	mv	s0,a0
	idx = get_iface_idx(sh, argv[1]);
400266cc:	bc5fe0ef          	jal	ra,40025290 <get_iface_idx>
	if (idx < 0) {
400266d0:	00a12623          	sw	a0,12(sp)
400266d4:	02054263          	bltz	a0,400266f8 <cmd_net_iface_down+0x40>
	iface = net_if_get_by_index(idx);
400266d8:	80dfe0ef          	jal	ra,40024ee4 <net_if_get_by_index>
	if (!iface) {
400266dc:	00c12683          	lw	a3,12(sp)
400266e0:	02051863          	bnez	a0,40026710 <cmd_net_iface_down+0x58>
		PR_WARNING("No such interface in index %d\n", idx);
400266e4:	40036637          	lui	a2,0x40036
400266e8:	da060613          	addi	a2,a2,-608 # 40035da0 <CSWTCH.15846+0x740>
400266ec:	00300593          	li	a1,3
400266f0:	00040513          	mv	a0,s0
400266f4:	ff8e20ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
400266f8:	ff800713          	li	a4,-8
}
400266fc:	01c12083          	lw	ra,28(sp)
40026700:	01812403          	lw	s0,24(sp)
40026704:	00070513          	mv	a0,a4
40026708:	02010113          	addi	sp,sp,32
4002670c:	00008067          	ret
40026710:	00d12623          	sw	a3,12(sp)
	ret = net_if_down(iface);
40026714:	da0ed0ef          	jal	ra,40013cb4 <net_if_down>
	if (ret) {
40026718:	00c12683          	lw	a3,12(sp)
	ret = net_if_down(iface);
4002671c:	00050713          	mv	a4,a0
	if (ret) {
40026720:	00050e63          	beqz	a0,4002673c <cmd_net_iface_down+0x84>
		PR_WARNING("Cannot take interface %d down (%d)\n", idx, ret);
40026724:	40036637          	lui	a2,0x40036
40026728:	1e460613          	addi	a2,a2,484 # 400361e4 <CSWTCH.15846+0xb84>
4002672c:	00300593          	li	a1,3
40026730:	00040513          	mv	a0,s0
40026734:	fb8e20ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40026738:	fc1ff06f          	j	400266f8 <cmd_net_iface_down+0x40>
		PR("Interface %d is down\n", idx);
4002673c:	40036637          	lui	a2,0x40036
40026740:	00a12623          	sw	a0,12(sp)
40026744:	20860613          	addi	a2,a2,520 # 40036208 <CSWTCH.15846+0xba8>
40026748:	00800593          	li	a1,8
4002674c:	00040513          	mv	a0,s0
40026750:	f9ce20ef          	jal	ra,40008eec <shell_fprintf>
40026754:	00c12703          	lw	a4,12(sp)
	return 0;
40026758:	fa5ff06f          	j	400266fc <cmd_net_iface_down+0x44>

4002675c <cmd_net_dns_cancel>:
{
4002675c:	ff010113          	addi	sp,sp,-16
40026760:	00812423          	sw	s0,8(sp)
40026764:	00112623          	sw	ra,12(sp)
40026768:	00050413          	mv	s0,a0
	ctx = dns_resolve_get_default();
4002676c:	159050ef          	jal	ra,4002c0c4 <dns_resolve_get_default>
	if (!ctx) {
40026770:	04051c63          	bnez	a0,400267c8 <cmd_net_dns_cancel+0x6c>
		PR_WARNING("No default DNS context found.\n");
40026774:	40036637          	lui	a2,0x40036
40026778:	00040513          	mv	a0,s0
4002677c:	22060613          	addi	a2,a2,544 # 40036220 <CSWTCH.15846+0xbc0>
40026780:	00300593          	li	a1,3
40026784:	f68e20ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40026788:	ff800513          	li	a0,-8
}
4002678c:	00c12083          	lw	ra,12(sp)
40026790:	00812403          	lw	s0,8(sp)
40026794:	01010113          	addi	sp,sp,16
40026798:	00008067          	ret
		if (!dns_resolve_cancel(ctx, ctx->queries[i].id)) {
4002679c:	0907d583          	lhu	a1,144(a5)
400267a0:	4b0050ef          	jal	ra,4002bc50 <dns_resolve_cancel>
400267a4:	02051863          	bnez	a0,400267d4 <cmd_net_dns_cancel+0x78>
		PR("Cancelled %d pending requests.\n", ret);
400267a8:	40036637          	lui	a2,0x40036
400267ac:	00100693          	li	a3,1
400267b0:	24060613          	addi	a2,a2,576 # 40036240 <CSWTCH.15846+0xbe0>
400267b4:	00800593          	li	a1,8
400267b8:	00040513          	mv	a0,s0
400267bc:	f30e20ef          	jal	ra,40008eec <shell_fprintf>
	return 0;
400267c0:	00000513          	li	a0,0
400267c4:	fc9ff06f          	j	4002678c <cmd_net_dns_cancel+0x30>
		if (!ctx->queries[i].cb) {
400267c8:	07452703          	lw	a4,116(a0)
400267cc:	00050793          	mv	a5,a0
400267d0:	fc0716e3          	bnez	a4,4002679c <cmd_net_dns_cancel+0x40>
		PR("No pending DNS requests.\n");
400267d4:	40036637          	lui	a2,0x40036
400267d8:	26060613          	addi	a2,a2,608 # 40036260 <CSWTCH.15846+0xc00>
400267dc:	00800593          	li	a1,8
400267e0:	00040513          	mv	a0,s0
400267e4:	f08e20ef          	jal	ra,40008eec <shell_fprintf>
400267e8:	fd9ff06f          	j	400267c0 <cmd_net_dns_cancel+0x64>

400267ec <cmd_net_conn>:
	PR("     Context   \tIface  Flags            Local             Remote\n");
400267ec:	40036637          	lui	a2,0x40036
{
400267f0:	fe010113          	addi	sp,sp,-32
	PR("     Context   \tIface  Flags            Local             Remote\n");
400267f4:	27c60613          	addi	a2,a2,636 # 4003627c <CSWTCH.15846+0xc1c>
400267f8:	00800593          	li	a1,8
{
400267fc:	00112e23          	sw	ra,28(sp)
40026800:	00812c23          	sw	s0,24(sp)
	int count = 0;
40026804:	00012223          	sw	zero,4(sp)
{
40026808:	00050413          	mv	s0,a0
	PR("     Context   \tIface  Flags            Local             Remote\n");
4002680c:	ee0e20ef          	jal	ra,40008eec <shell_fprintf>
	net_context_foreach(context_cb, &user_data);
40026810:	40027537          	lui	a0,0x40027
	user_data.user_data = &count;
40026814:	00410793          	addi	a5,sp,4
	net_context_foreach(context_cb, &user_data);
40026818:	00810593          	addi	a1,sp,8
4002681c:	47450513          	addi	a0,a0,1140 # 40027474 <context_cb>
	user_data.user_data = &count;
40026820:	00f12623          	sw	a5,12(sp)
	user_data.sh = sh;
40026824:	00812423          	sw	s0,8(sp)
	net_context_foreach(context_cb, &user_data);
40026828:	9e5f00ef          	jal	ra,4001720c <net_context_foreach>
	if (count == 0) {
4002682c:	00412783          	lw	a5,4(sp)
40026830:	00079c63          	bnez	a5,40026848 <cmd_net_conn+0x5c>
		PR("No connections\n");
40026834:	40036637          	lui	a2,0x40036
40026838:	2c060613          	addi	a2,a2,704 # 400362c0 <CSWTCH.15846+0xc60>
4002683c:	00800593          	li	a1,8
40026840:	00040513          	mv	a0,s0
40026844:	ea8e20ef          	jal	ra,40008eec <shell_fprintf>
	PR("\nTCP        Context   Src port Dst port   "
40026848:	40036637          	lui	a2,0x40036
4002684c:	2d060613          	addi	a2,a2,720 # 400362d0 <CSWTCH.15846+0xc70>
40026850:	00800593          	li	a1,8
40026854:	00040513          	mv	a0,s0
40026858:	e94e20ef          	jal	ra,40008eec <shell_fprintf>
	net_tcp_foreach(tcp_cb, &user_data);
4002685c:	40027537          	lui	a0,0x40027
40026860:	00810593          	addi	a1,sp,8
40026864:	8c450513          	addi	a0,a0,-1852 # 400268c4 <tcp_cb>
	count = 0;
40026868:	00012223          	sw	zero,4(sp)
	net_tcp_foreach(tcp_cb, &user_data);
4002686c:	f51fa0ef          	jal	ra,400217bc <net_tcp_foreach>
	if (count == 0) {
40026870:	00412783          	lw	a5,4(sp)
40026874:	00079c63          	bnez	a5,4002688c <cmd_net_conn+0xa0>
		PR("No TCP connections\n");
40026878:	40036637          	lui	a2,0x40036
4002687c:	32060613          	addi	a2,a2,800 # 40036320 <CSWTCH.15846+0xcc0>
40026880:	00800593          	li	a1,8
40026884:	00040513          	mv	a0,s0
40026888:	e64e20ef          	jal	ra,40008eec <shell_fprintf>
	PR_INFO("Set %s to enable %s support.\n",
4002688c:	40036737          	lui	a4,0x40036
40026890:	400366b7          	lui	a3,0x40036
40026894:	40035637          	lui	a2,0x40035
40026898:	00040513          	mv	a0,s0
4002689c:	33470713          	addi	a4,a4,820 # 40036334 <CSWTCH.15846+0xcd4>
400268a0:	34468693          	addi	a3,a3,836 # 40036344 <CSWTCH.15846+0xce4>
400268a4:	6b860613          	addi	a2,a2,1720 # 400356b8 <CSWTCH.15846+0x58>
400268a8:	00200593          	li	a1,2
400268ac:	e40e20ef          	jal	ra,40008eec <shell_fprintf>
}
400268b0:	01c12083          	lw	ra,28(sp)
400268b4:	01812403          	lw	s0,24(sp)
400268b8:	00000513          	li	a0,0
400268bc:	02010113          	addi	sp,sp,32
400268c0:	00008067          	ret

400268c4 <tcp_cb>:
{
400268c4:	fc010113          	addi	sp,sp,-64
400268c8:	02112e23          	sw	ra,60(sp)
400268cc:	02812c23          	sw	s0,56(sp)
400268d0:	03212823          	sw	s2,48(sp)
400268d4:	03412423          	sw	s4,40(sp)
400268d8:	02912a23          	sw	s1,52(sp)
400268dc:	03312623          	sw	s3,44(sp)
400268e0:	00050413          	mv	s0,a0
	int *count = data->user_data;
400268e4:	0045a983          	lw	s3,4(a1)
	const struct shell *sh = data->sh;
400268e8:	0005a483          	lw	s1,0(a1)
	uint16_t recv_mss = net_tcp_get_supported_mss(conn);
400268ec:	f89fa0ef          	jal	ra,40021874 <net_tcp_get_supported_mss>
	PR("%p %p   %5u    %5u %10u %10u %5u   %s\n",
400268f0:	00442703          	lw	a4,4(s0)
400268f4:	22842883          	lw	a7,552(s0)
	uint16_t recv_mss = net_tcp_get_supported_mss(conn);
400268f8:	00050913          	mv	s2,a0
	PR("%p %p   %5u    %5u %10u %10u %5u   %s\n",
400268fc:	02275683          	lhu	a3,34(a4)
40026900:	22042503          	lw	a0,544(s0)
40026904:	22c42a03          	lw	s4,556(s0)
40026908:	00869793          	slli	a5,a3,0x8
4002690c:	0086d693          	srli	a3,a3,0x8
40026910:	00d7e7b3          	or	a5,a5,a3
40026914:	02e75683          	lhu	a3,46(a4)
40026918:	01079793          	slli	a5,a5,0x10
4002691c:	0107d793          	srli	a5,a5,0x10
40026920:	00869813          	slli	a6,a3,0x8
40026924:	0086d693          	srli	a3,a3,0x8
40026928:	00d86833          	or	a6,a6,a3
4002692c:	01081813          	slli	a6,a6,0x10
40026930:	01085813          	srli	a6,a6,0x10
40026934:	00f12e23          	sw	a5,28(sp)
40026938:	00e12c23          	sw	a4,24(sp)
4002693c:	01012a23          	sw	a6,20(sp)
40026940:	01112823          	sw	a7,16(sp)
40026944:	a44fe0ef          	jal	ra,40024b88 <net_tcp_state_str>
40026948:	01c12783          	lw	a5,28(sp)
4002694c:	01012883          	lw	a7,16(sp)
40026950:	01412803          	lw	a6,20(sp)
40026954:	01812703          	lw	a4,24(sp)
40026958:	40036637          	lui	a2,0x40036
4002695c:	00a12423          	sw	a0,8(sp)
40026960:	01212223          	sw	s2,4(sp)
40026964:	01412023          	sw	s4,0(sp)
40026968:	00040693          	mv	a3,s0
4002696c:	00048513          	mv	a0,s1
40026970:	36460613          	addi	a2,a2,868 # 40036364 <CSWTCH.15846+0xd04>
40026974:	00800593          	li	a1,8
40026978:	d74e20ef          	jal	ra,40008eec <shell_fprintf>
	(*count)++;
4002697c:	0009a783          	lw	a5,0(s3)
40026980:	00178793          	addi	a5,a5,1
40026984:	00f9a023          	sw	a5,0(s3)
}
40026988:	03c12083          	lw	ra,60(sp)
4002698c:	03812403          	lw	s0,56(sp)
40026990:	03412483          	lw	s1,52(sp)
40026994:	03012903          	lw	s2,48(sp)
40026998:	02c12983          	lw	s3,44(sp)
4002699c:	02812a03          	lw	s4,40(sp)
400269a0:	04010113          	addi	sp,sp,64
400269a4:	00008067          	ret

400269a8 <cmd_net_arp_flush>:
	PR("Flushing ARP cache.\n");
400269a8:	40036637          	lui	a2,0x40036
{
400269ac:	ff010113          	addi	sp,sp,-16
	PR("Flushing ARP cache.\n");
400269b0:	38c60613          	addi	a2,a2,908 # 4003638c <CSWTCH.15846+0xd2c>
400269b4:	00800593          	li	a1,8
{
400269b8:	00112623          	sw	ra,12(sp)
	PR("Flushing ARP cache.\n");
400269bc:	d30e20ef          	jal	ra,40008eec <shell_fprintf>
	net_arp_clear_cache(NULL);
400269c0:	00000513          	li	a0,0
400269c4:	f88e80ef          	jal	ra,4000f14c <net_arp_clear_cache>
}
400269c8:	00c12083          	lw	ra,12(sp)
400269cc:	00000513          	li	a0,0
400269d0:	01010113          	addi	sp,sp,16
400269d4:	00008067          	ret

400269d8 <cmd_net_nbr>:
{
400269d8:	fe010113          	addi	sp,sp,-32
400269dc:	00812c23          	sw	s0,24(sp)
	user_data.sh = sh;
400269e0:	00a12423          	sw	a0,8(sp)
{
400269e4:	00050413          	mv	s0,a0
	net_ipv6_nbr_foreach(nbr_cb, &user_data);
400269e8:	4002a537          	lui	a0,0x4002a
	user_data.user_data = &count;
400269ec:	00410793          	addi	a5,sp,4
	net_ipv6_nbr_foreach(nbr_cb, &user_data);
400269f0:	00810593          	addi	a1,sp,8
400269f4:	ae450513          	addi	a0,a0,-1308 # 40029ae4 <nbr_cb>
	user_data.user_data = &count;
400269f8:	00f12623          	sw	a5,12(sp)
{
400269fc:	00112e23          	sw	ra,28(sp)
	int count = 0;
40026a00:	00012223          	sw	zero,4(sp)
	net_ipv6_nbr_foreach(nbr_cb, &user_data);
40026a04:	eb5f50ef          	jal	ra,4001c8b8 <net_ipv6_nbr_foreach>
	if (count == 0) {
40026a08:	00412783          	lw	a5,4(sp)
40026a0c:	00079c63          	bnez	a5,40026a24 <cmd_net_nbr+0x4c>
		PR("No neighbors.\n");
40026a10:	40036637          	lui	a2,0x40036
40026a14:	3a460613          	addi	a2,a2,932 # 400363a4 <CSWTCH.15846+0xd44>
40026a18:	00800593          	li	a1,8
40026a1c:	00040513          	mv	a0,s0
40026a20:	ccce20ef          	jal	ra,40008eec <shell_fprintf>
}
40026a24:	01c12083          	lw	ra,28(sp)
40026a28:	01812403          	lw	s0,24(sp)
40026a2c:	00000513          	li	a0,0
40026a30:	02010113          	addi	sp,sp,32
40026a34:	00008067          	ret

40026a38 <cmd_net_udp_close>:
{
40026a38:	ff010113          	addi	sp,sp,-16
	if (!udp_ctx || !net_context_is_used(udp_ctx)) {
40026a3c:	400397b7          	lui	a5,0x40039
{
40026a40:	00812423          	sw	s0,8(sp)
40026a44:	00050413          	mv	s0,a0
	if (!udp_ctx || !net_context_is_used(udp_ctx)) {
40026a48:	0dc7a503          	lw	a0,220(a5) # 400390dc <udp_ctx>
{
40026a4c:	00112623          	sw	ra,12(sp)
	if (!udp_ctx || !net_context_is_used(udp_ctx)) {
40026a50:	00050863          	beqz	a0,40026a60 <cmd_net_udp_close+0x28>
40026a54:	07455783          	lhu	a5,116(a0)
40026a58:	0017f793          	andi	a5,a5,1
40026a5c:	02079663          	bnez	a5,40026a88 <cmd_net_udp_close+0x50>
		PR_WARNING("Network context is not used. Cannot close.\n");
40026a60:	40036637          	lui	a2,0x40036
40026a64:	00040513          	mv	a0,s0
40026a68:	3b460613          	addi	a2,a2,948 # 400363b4 <CSWTCH.15846+0xd54>
40026a6c:	00300593          	li	a1,3
40026a70:	c7ce20ef          	jal	ra,40008eec <shell_fprintf>
40026a74:	fea00513          	li	a0,-22
}
40026a78:	00c12083          	lw	ra,12(sp)
40026a7c:	00812403          	lw	s0,8(sp)
40026a80:	01010113          	addi	sp,sp,16
40026a84:	00008067          	ret
	ret = net_context_put(udp_ctx);
40026a88:	d8cef0ef          	jal	ra,40016014 <net_context_put>
40026a8c:	00050693          	mv	a3,a0
	if (ret < 0) {
40026a90:	00054663          	bltz	a0,40026a9c <cmd_net_udp_close+0x64>
	return 0;
40026a94:	00000513          	li	a0,0
40026a98:	fe1ff06f          	j	40026a78 <cmd_net_udp_close+0x40>
		PR_WARNING("Cannot close UDP port (%d)\n", ret);
40026a9c:	40036637          	lui	a2,0x40036
40026aa0:	3e060613          	addi	a2,a2,992 # 400363e0 <CSWTCH.15846+0xd80>
40026aa4:	00300593          	li	a1,3
40026aa8:	00040513          	mv	a0,s0
40026aac:	c40e20ef          	jal	ra,40008eec <shell_fprintf>
40026ab0:	fe5ff06f          	j	40026a94 <cmd_net_udp_close+0x5c>

40026ab4 <tcp_connected>:
{
40026ab4:	ff010113          	addi	sp,sp,-16
40026ab8:	00812423          	sw	s0,8(sp)
		PR_SHELL(tcp_shell, "TCP connection failed (%d)\n", status);
40026abc:	400397b7          	lui	a5,0x40039
{
40026ac0:	00112623          	sw	ra,12(sp)
40026ac4:	00050413          	mv	s0,a0
		PR_SHELL(tcp_shell, "TCP connection failed (%d)\n", status);
40026ac8:	0e07a503          	lw	a0,224(a5) # 400390e0 <tcp_shell>
	if (status < 0) {
40026acc:	0205dc63          	bgez	a1,40026b04 <tcp_connected+0x50>
		PR_SHELL(tcp_shell, "TCP connection failed (%d)\n", status);
40026ad0:	40036637          	lui	a2,0x40036
40026ad4:	00058693          	mv	a3,a1
40026ad8:	3fc60613          	addi	a2,a2,1020 # 400363fc <CSWTCH.15846+0xd9c>
40026adc:	00800593          	li	a1,8
40026ae0:	c0ce20ef          	jal	ra,40008eec <shell_fprintf>
		net_context_put(context);
40026ae4:	00040513          	mv	a0,s0
40026ae8:	d2cef0ef          	jal	ra,40016014 <net_context_put>
}
40026aec:	00c12083          	lw	ra,12(sp)
40026af0:	00812403          	lw	s0,8(sp)
		tcp_ctx = NULL;
40026af4:	400397b7          	lui	a5,0x40039
40026af8:	0e07a223          	sw	zero,228(a5) # 400390e4 <tcp_ctx>
}
40026afc:	01010113          	addi	sp,sp,16
40026b00:	00008067          	ret
40026b04:	00812403          	lw	s0,8(sp)
40026b08:	00c12083          	lw	ra,12(sp)
		PR_SHELL(tcp_shell, "TCP connected\n");
40026b0c:	40036637          	lui	a2,0x40036
40026b10:	41860613          	addi	a2,a2,1048 # 40036418 <CSWTCH.15846+0xdb8>
40026b14:	00800593          	li	a1,8
}
40026b18:	01010113          	addi	sp,sp,16
		PR_SHELL(tcp_shell, "TCP connected\n");
40026b1c:	bd0e206f          	j	40008eec <shell_fprintf>

40026b20 <ping_bypass>:
	for (size_t i = 0; i < len; i++) {
40026b20:	00000793          	li	a5,0
		if (data[i] == ASCII_CTRL_C) {
40026b24:	00300713          	li	a4,3
	for (size_t i = 0; i < len; i++) {
40026b28:	00c79463          	bne	a5,a2,40026b30 <ping_bypass+0x10>
40026b2c:	00008067          	ret
		if (data[i] == ASCII_CTRL_C) {
40026b30:	00f586b3          	add	a3,a1,a5
40026b34:	0006c683          	lbu	a3,0(a3)
40026b38:	02e69863          	bne	a3,a4,40026b68 <ping_bypass+0x48>
{
40026b3c:	ff010113          	addi	sp,sp,-16
40026b40:	00812423          	sw	s0,8(sp)
			k_work_cancel_delayable(&ping_ctx.work);
40026b44:	4003a437          	lui	s0,0x4003a
40026b48:	d5840513          	addi	a0,s0,-680 # 40039d58 <ping_ctx>
{
40026b4c:	00112623          	sw	ra,12(sp)
			k_work_cancel_delayable(&ping_ctx.work);
40026b50:	61c090ef          	jal	ra,4003016c <k_work_cancel_delayable>
			ping_cleanup(&ping_ctx);
40026b54:	d5840513          	addi	a0,s0,-680
}
40026b58:	00812403          	lw	s0,8(sp)
40026b5c:	00c12083          	lw	ra,12(sp)
40026b60:	01010113          	addi	sp,sp,16
			ping_cleanup(&ping_ctx);
40026b64:	a68ff06f          	j	40025dcc <ping_cleanup>
	for (size_t i = 0; i < len; i++) {
40026b68:	00178793          	addi	a5,a5,1
40026b6c:	fbdff06f          	j	40026b28 <ping_bypass+0x8>

40026b70 <cmd_net_arp>:
	if (!argv[arg]) {
40026b70:	00462783          	lw	a5,4(a2)
40026b74:	06079063          	bnez	a5,40026bd4 <cmd_net_arp+0x64>
{
40026b78:	fe010113          	addi	sp,sp,-32
40026b7c:	00812c23          	sw	s0,24(sp)
		user_data.sh = sh;
40026b80:	00a12423          	sw	a0,8(sp)
40026b84:	00050413          	mv	s0,a0
		if (net_arp_foreach(arp_cb, &user_data) == 0) {
40026b88:	4002a537          	lui	a0,0x4002a
		user_data.user_data = &count;
40026b8c:	00410793          	addi	a5,sp,4
		if (net_arp_foreach(arp_cb, &user_data) == 0) {
40026b90:	00810593          	addi	a1,sp,8
40026b94:	cec50513          	addi	a0,a0,-788 # 40029cec <arp_cb>
{
40026b98:	00112e23          	sw	ra,28(sp)
		int count = 0;
40026b9c:	00012223          	sw	zero,4(sp)
		user_data.user_data = &count;
40026ba0:	00f12623          	sw	a5,12(sp)
		if (net_arp_foreach(arp_cb, &user_data) == 0) {
40026ba4:	f48e80ef          	jal	ra,4000f2ec <net_arp_foreach>
40026ba8:	00051c63          	bnez	a0,40026bc0 <cmd_net_arp+0x50>
			PR("ARP cache is empty.\n");
40026bac:	40036637          	lui	a2,0x40036
40026bb0:	42860613          	addi	a2,a2,1064 # 40036428 <CSWTCH.15846+0xdc8>
40026bb4:	00800593          	li	a1,8
40026bb8:	00040513          	mv	a0,s0
40026bbc:	b30e20ef          	jal	ra,40008eec <shell_fprintf>
}
40026bc0:	01c12083          	lw	ra,28(sp)
40026bc4:	01812403          	lw	s0,24(sp)
40026bc8:	00000513          	li	a0,0
40026bcc:	02010113          	addi	sp,sp,32
40026bd0:	00008067          	ret
40026bd4:	00000513          	li	a0,0
40026bd8:	00008067          	ret

40026bdc <cmd_net_udp>:
static int cmd_net_udp(const struct shell *sh, size_t argc, char *argv[])
40026bdc:	00000513          	li	a0,0
40026be0:	00008067          	ret

40026be4 <cmd_net_dns_query>:
{
40026be4:	fe010113          	addi	sp,sp,-32
40026be8:	00112e23          	sw	ra,28(sp)
40026bec:	00812c23          	sw	s0,24(sp)
40026bf0:	00912a23          	sw	s1,20(sp)
40026bf4:	01212823          	sw	s2,16(sp)
	host = argv[arg++];
40026bf8:	00462483          	lw	s1,4(a2)
	if (!host) {
40026bfc:	02049863          	bnez	s1,40026c2c <cmd_net_dns_query+0x48>
		PR_WARNING("Hostname not specified.\n");
40026c00:	40036637          	lui	a2,0x40036
40026c04:	44060613          	addi	a2,a2,1088 # 40036440 <CSWTCH.15846+0xde0>
40026c08:	00300593          	li	a1,3
			PR_WARNING("Unknown query type, specify either "
40026c0c:	ae0e20ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40026c10:	ff800513          	li	a0,-8
}
40026c14:	01c12083          	lw	ra,28(sp)
40026c18:	01812403          	lw	s0,24(sp)
40026c1c:	01412483          	lw	s1,20(sp)
40026c20:	01012903          	lw	s2,16(sp)
40026c24:	02010113          	addi	sp,sp,32
40026c28:	00008067          	ret
	if (argv[arg]) {
40026c2c:	00862903          	lw	s2,8(a2)
40026c30:	00050413          	mv	s0,a0
40026c34:	02090663          	beqz	s2,40026c60 <cmd_net_dns_query+0x7c>
		if (strcmp(type, "A") == 0) {
40026c38:	400365b7          	lui	a1,0x40036
40026c3c:	45c58593          	addi	a1,a1,1116 # 4003645c <CSWTCH.15846+0xdfc>
40026c40:	00090513          	mv	a0,s2
40026c44:	fd5e50ef          	jal	ra,4000cc18 <strcmp>
40026c48:	02051063          	bnez	a0,40026c68 <cmd_net_dns_query+0x84>
			PR("IPv4 address type\n");
40026c4c:	40036637          	lui	a2,0x40036
40026c50:	46060613          	addi	a2,a2,1120 # 40036460 <CSWTCH.15846+0xe00>
40026c54:	00800593          	li	a1,8
40026c58:	00040513          	mv	a0,s0
40026c5c:	a90e20ef          	jal	ra,40008eec <shell_fprintf>
	enum dns_query_type qtype = DNS_QUERY_TYPE_A;
40026c60:	00100613          	li	a2,1
40026c64:	0300006f          	j	40026c94 <cmd_net_dns_query+0xb0>
		} else if (strcmp(type, "AAAA") == 0) {
40026c68:	400365b7          	lui	a1,0x40036
40026c6c:	47458593          	addi	a1,a1,1140 # 40036474 <CSWTCH.15846+0xe14>
40026c70:	00090513          	mv	a0,s2
40026c74:	fa5e50ef          	jal	ra,4000cc18 <strcmp>
40026c78:	06051663          	bnez	a0,40026ce4 <cmd_net_dns_query+0x100>
			PR("IPv6 address type\n");
40026c7c:	40036637          	lui	a2,0x40036
40026c80:	47c60613          	addi	a2,a2,1148 # 4003647c <CSWTCH.15846+0xe1c>
40026c84:	00800593          	li	a1,8
40026c88:	00040513          	mv	a0,s0
40026c8c:	a60e20ef          	jal	ra,40008eec <shell_fprintf>
			qtype = DNS_QUERY_TYPE_AAAA;
40026c90:	01c00613          	li	a2,28
40026c94:	00c12623          	sw	a2,12(sp)
				    uint16_t *dns_id,
				    dns_resolve_cb_t cb,
				    void *user_data,
				    int32_t timeout)
{
	return dns_resolve_name(dns_resolve_get_default(),
40026c98:	42c050ef          	jal	ra,4002c0c4 <dns_resolve_get_default>
40026c9c:	00c12603          	lw	a2,12(sp)
40026ca0:	40029737          	lui	a4,0x40029
40026ca4:	a6870713          	addi	a4,a4,-1432 # 40028a68 <dns_result_cb>
40026ca8:	00000693          	li	a3,0
40026cac:	7d000813          	li	a6,2000
40026cb0:	00040793          	mv	a5,s0
40026cb4:	00048593          	mv	a1,s1
40026cb8:	7a1040ef          	jal	ra,4002bc58 <dns_resolve_name>
40026cbc:	00050713          	mv	a4,a0
		PR_WARNING("Cannot resolve '%s' (%d)\n", host, ret);
40026cc0:	00048693          	mv	a3,s1
	if (ret < 0) {
40026cc4:	02055a63          	bgez	a0,40026cf8 <cmd_net_dns_query+0x114>
		PR_WARNING("Cannot resolve '%s' (%d)\n", host, ret);
40026cc8:	40036637          	lui	a2,0x40036
40026ccc:	4c060613          	addi	a2,a2,1216 # 400364c0 <CSWTCH.15846+0xe60>
40026cd0:	00300593          	li	a1,3
40026cd4:	00040513          	mv	a0,s0
40026cd8:	a14e20ef          	jal	ra,40008eec <shell_fprintf>
	return 0;
40026cdc:	00000513          	li	a0,0
40026ce0:	f35ff06f          	j	40026c14 <cmd_net_dns_query+0x30>
			PR_WARNING("Unknown query type, specify either "
40026ce4:	40036637          	lui	a2,0x40036
40026ce8:	49060613          	addi	a2,a2,1168 # 40036490 <CSWTCH.15846+0xe30>
40026cec:	00300593          	li	a1,3
40026cf0:	00040513          	mv	a0,s0
40026cf4:	f19ff06f          	j	40026c0c <cmd_net_dns_query+0x28>
		PR("Query for '%s' sent.\n", host);
40026cf8:	40036637          	lui	a2,0x40036
40026cfc:	4dc60613          	addi	a2,a2,1244 # 400364dc <CSWTCH.15846+0xe7c>
40026d00:	00800593          	li	a1,8
40026d04:	00040513          	mv	a0,s0
40026d08:	9e4e20ef          	jal	ra,40008eec <shell_fprintf>
40026d0c:	fd1ff06f          	j	40026cdc <cmd_net_dns_query+0xf8>

40026d10 <cmd_net_dns>:
{
40026d10:	ff010113          	addi	sp,sp,-16
40026d14:	00112623          	sw	ra,12(sp)
40026d18:	00812423          	sw	s0,8(sp)
40026d1c:	00912223          	sw	s1,4(sp)
	if (argv[1]) {
40026d20:	00462783          	lw	a5,4(a2)
40026d24:	00078863          	beqz	a5,40026d34 <cmd_net_dns+0x24>
		cmd_net_dns_query(sh, argc, argv);
40026d28:	ebdff0ef          	jal	ra,40026be4 <cmd_net_dns_query>
		return 0;
40026d2c:	00000513          	li	a0,0
40026d30:	02c0006f          	j	40026d5c <cmd_net_dns+0x4c>
40026d34:	00050493          	mv	s1,a0
	ctx = dns_resolve_get_default();
40026d38:	38c050ef          	jal	ra,4002c0c4 <dns_resolve_get_default>
40026d3c:	00050413          	mv	s0,a0
	if (!ctx) {
40026d40:	02051863          	bnez	a0,40026d70 <cmd_net_dns+0x60>
		PR_WARNING("No default DNS context found.\n");
40026d44:	40036637          	lui	a2,0x40036
40026d48:	00048513          	mv	a0,s1
40026d4c:	22060613          	addi	a2,a2,544 # 40036220 <CSWTCH.15846+0xbc0>
40026d50:	00300593          	li	a1,3
40026d54:	998e20ef          	jal	ra,40008eec <shell_fprintf>
40026d58:	ff800513          	li	a0,-8
}
40026d5c:	00c12083          	lw	ra,12(sp)
40026d60:	00812403          	lw	s0,8(sp)
40026d64:	00412483          	lw	s1,4(sp)
40026d68:	01010113          	addi	sp,sp,16
40026d6c:	00008067          	ret
	PR("DNS servers:\n");
40026d70:	40036637          	lui	a2,0x40036
40026d74:	4f460613          	addi	a2,a2,1268 # 400364f4 <CSWTCH.15846+0xe94>
40026d78:	00800593          	li	a1,8
40026d7c:	00048513          	mv	a0,s1
40026d80:	96ce20ef          	jal	ra,40008eec <shell_fprintf>
		if (ctx->servers[i].dns_server.sa_family == AF_INET) {
40026d84:	00045783          	lhu	a5,0(s0)
40026d88:	00100713          	li	a4,1
40026d8c:	0ae79063          	bne	a5,a4,40026e2c <cmd_net_dns+0x11c>
			PR("\t%s:%u\n",
40026d90:	00440593          	addi	a1,s0,4
40026d94:	00100513          	li	a0,1
40026d98:	b1ded0ef          	jal	ra,400148b4 <net_sprint_addr>
40026d9c:	00245783          	lhu	a5,2(s0)
40026da0:	40036637          	lui	a2,0x40036
40026da4:	00050693          	mv	a3,a0
40026da8:	00879713          	slli	a4,a5,0x8
40026dac:	0087d793          	srli	a5,a5,0x8
40026db0:	00f76733          	or	a4,a4,a5
40026db4:	01071713          	slli	a4,a4,0x10
40026db8:	01075713          	srli	a4,a4,0x10
40026dbc:	50460613          	addi	a2,a2,1284 # 40036504 <CSWTCH.15846+0xea4>
			PR("\t[%s]:%u\n",
40026dc0:	00800593          	li	a1,8
40026dc4:	00048513          	mv	a0,s1
40026dc8:	924e20ef          	jal	ra,40008eec <shell_fprintf>
	PR("Pending queries:\n");
40026dcc:	40036637          	lui	a2,0x40036
40026dd0:	51860613          	addi	a2,a2,1304 # 40036518 <CSWTCH.15846+0xeb8>
40026dd4:	00800593          	li	a1,8
40026dd8:	00048513          	mv	a0,s1
40026ddc:	910e20ef          	jal	ra,40008eec <shell_fprintf>
		if (!ctx->queries[i].cb || !ctx->queries[i].query) {
40026de0:	07442783          	lw	a5,116(s0)
40026de4:	f40784e3          	beqz	a5,40026d2c <cmd_net_dns+0x1c>
40026de8:	08842783          	lw	a5,136(s0)
40026dec:	f40780e3          	beqz	a5,40026d2c <cmd_net_dns+0x1c>
	return z_timeout_remaining(&dwork->timeout);
40026df0:	05040513          	addi	a0,s0,80
40026df4:	6940a0ef          	jal	ra,40031488 <z_timeout_remaining>
		if (ctx->queries[i].query_type == DNS_QUERY_TYPE_A) {
40026df8:	08c42703          	lw	a4,140(s0)
			return ((uint32_t)t) * (to_hz / from_hz);
40026dfc:	00a00793          	li	a5,10
40026e00:	00100693          	li	a3,1
40026e04:	02a787b3          	mul	a5,a5,a0
40026e08:	06d71063          	bne	a4,a3,40026e68 <cmd_net_dns+0x158>
			PR("\tIPv4[%u]: %s remaining %d\n",
40026e0c:	08842703          	lw	a4,136(s0)
40026e10:	09045683          	lhu	a3,144(s0)
40026e14:	40036637          	lui	a2,0x40036
40026e18:	52c60613          	addi	a2,a2,1324 # 4003652c <CSWTCH.15846+0xecc>
			PR("\tIPv6[%u]: %s remaining %d\n",
40026e1c:	00800593          	li	a1,8
40026e20:	00048513          	mv	a0,s1
40026e24:	8c8e20ef          	jal	ra,40008eec <shell_fprintf>
40026e28:	f05ff06f          	j	40026d2c <cmd_net_dns+0x1c>
		} else if (ctx->servers[i].dns_server.sa_family == AF_INET6) {
40026e2c:	00200713          	li	a4,2
40026e30:	f8e79ee3          	bne	a5,a4,40026dcc <cmd_net_dns+0xbc>
			PR("\t[%s]:%u\n",
40026e34:	00440593          	addi	a1,s0,4
40026e38:	00200513          	li	a0,2
40026e3c:	a79ed0ef          	jal	ra,400148b4 <net_sprint_addr>
40026e40:	00245783          	lhu	a5,2(s0)
40026e44:	40036637          	lui	a2,0x40036
40026e48:	00050693          	mv	a3,a0
40026e4c:	00879713          	slli	a4,a5,0x8
40026e50:	0087d793          	srli	a5,a5,0x8
40026e54:	00f76733          	or	a4,a4,a5
40026e58:	01071713          	slli	a4,a4,0x10
40026e5c:	01075713          	srli	a4,a4,0x10
40026e60:	50c60613          	addi	a2,a2,1292 # 4003650c <CSWTCH.15846+0xeac>
40026e64:	f5dff06f          	j	40026dc0 <cmd_net_dns+0xb0>
		} else if (ctx->queries[i].query_type == DNS_QUERY_TYPE_AAAA) {
40026e68:	01c00693          	li	a3,28
40026e6c:	ecd710e3          	bne	a4,a3,40026d2c <cmd_net_dns+0x1c>
			PR("\tIPv6[%u]: %s remaining %d\n",
40026e70:	40036637          	lui	a2,0x40036
40026e74:	08842703          	lw	a4,136(s0)
40026e78:	09045683          	lhu	a3,144(s0)
40026e7c:	54860613          	addi	a2,a2,1352 # 40036548 <CSWTCH.15846+0xee8>
40026e80:	f9dff06f          	j	40026e1c <cmd_net_dns+0x10c>

40026e84 <udp_sent>:
	PR_SHELL(udp_shell, "Message sent\n");
40026e84:	400397b7          	lui	a5,0x40039
40026e88:	0d87a503          	lw	a0,216(a5) # 400390d8 <udp_shell>
40026e8c:	40035637          	lui	a2,0x40035
{
40026e90:	ff010113          	addi	sp,sp,-16
	PR_SHELL(udp_shell, "Message sent\n");
40026e94:	72460613          	addi	a2,a2,1828 # 40035724 <CSWTCH.15846+0xc4>
40026e98:	00800593          	li	a1,8
{
40026e9c:	00112623          	sw	ra,12(sp)
	PR_SHELL(udp_shell, "Message sent\n");
40026ea0:	84ce20ef          	jal	ra,40008eec <shell_fprintf>
}
40026ea4:	00c12083          	lw	ra,12(sp)
	z_impl_k_sem_give(sem);
40026ea8:	40045537          	lui	a0,0x40045
40026eac:	8f850513          	addi	a0,a0,-1800 # 400448f8 <udp_send_wait>
40026eb0:	01010113          	addi	sp,sp,16
40026eb4:	2850806f          	j	4002f938 <z_impl_k_sem_give>

40026eb8 <cmd_net_udp_send>:
{
40026eb8:	fb010113          	addi	sp,sp,-80
40026ebc:	04112623          	sw	ra,76(sp)
40026ec0:	04812423          	sw	s0,72(sp)
40026ec4:	04912223          	sw	s1,68(sp)
40026ec8:	05212023          	sw	s2,64(sp)
40026ecc:	03312e23          	sw	s3,60(sp)
40026ed0:	03412c23          	sw	s4,56(sp)
40026ed4:	03512a23          	sw	s5,52(sp)
	char *endptr = NULL;
40026ed8:	00012a23          	sw	zero,20(sp)
	if (argc < 4) {
40026edc:	00300793          	li	a5,3
40026ee0:	04b7e063          	bltu	a5,a1,40026f20 <cmd_net_udp_send+0x68>
		PR_WARNING("Not enough arguments given for udp send command\n");
40026ee4:	40036637          	lui	a2,0x40036
40026ee8:	56460613          	addi	a2,a2,1380 # 40036564 <CSWTCH.15846+0xf04>
40026eec:	00300593          	li	a1,3
		PR_WARNING("Invalid port number\n");
40026ef0:	ffde10ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
40026ef4:	fea00913          	li	s2,-22
}
40026ef8:	04c12083          	lw	ra,76(sp)
40026efc:	04812403          	lw	s0,72(sp)
40026f00:	04412483          	lw	s1,68(sp)
40026f04:	03c12983          	lw	s3,60(sp)
40026f08:	03812a03          	lw	s4,56(sp)
40026f0c:	03412a83          	lw	s5,52(sp)
40026f10:	00090513          	mv	a0,s2
40026f14:	04012903          	lw	s2,64(sp)
40026f18:	05010113          	addi	sp,sp,80
40026f1c:	00008067          	ret
40026f20:	00060913          	mv	s2,a2
	host = argv[1];
40026f24:	00050413          	mv	s0,a0
	port = strtol(argv[2], &endptr, 0);
40026f28:	00892503          	lw	a0,8(s2)
	host = argv[1];
40026f2c:	00462a83          	lw	s5,4(a2)
	port = strtol(argv[2], &endptr, 0);
40026f30:	01410593          	addi	a1,sp,20
40026f34:	00000613          	li	a2,0
40026f38:	84de50ef          	jal	ra,4000c784 <strtol>
	if (endptr == argv[2]) {
40026f3c:	00892703          	lw	a4,8(s2)
40026f40:	01412783          	lw	a5,20(sp)
	port = strtol(argv[2], &endptr, 0);
40026f44:	01051493          	slli	s1,a0,0x10
	payload = argv[3];
40026f48:	00c92a03          	lw	s4,12(s2)
	port = strtol(argv[2], &endptr, 0);
40026f4c:	0104d493          	srli	s1,s1,0x10
	if (endptr == argv[2]) {
40026f50:	00f71c63          	bne	a4,a5,40026f68 <cmd_net_udp_send+0xb0>
		PR_WARNING("Invalid port number\n");
40026f54:	40036637          	lui	a2,0x40036
40026f58:	59860613          	addi	a2,a2,1432 # 40036598 <CSWTCH.15846+0xf38>
40026f5c:	00300593          	li	a1,3
40026f60:	00040513          	mv	a0,s0
40026f64:	f8dff06f          	j	40026ef0 <cmd_net_udp_send+0x38>
	if (udp_ctx && net_context_is_used(udp_ctx)) {
40026f68:	400399b7          	lui	s3,0x40039
40026f6c:	0dc9a783          	lw	a5,220(s3) # 400390dc <udp_ctx>
40026f70:	02078663          	beqz	a5,40026f9c <cmd_net_udp_send+0xe4>
40026f74:	0747d783          	lhu	a5,116(a5)
40026f78:	0017f793          	andi	a5,a5,1
40026f7c:	02078063          	beqz	a5,40026f9c <cmd_net_udp_send+0xe4>
		PR_WARNING("Network context already in use\n");
40026f80:	40036637          	lui	a2,0x40036
40026f84:	5b060613          	addi	a2,a2,1456 # 400365b0 <CSWTCH.15846+0xf50>
40026f88:	00300593          	li	a1,3
40026f8c:	00040513          	mv	a0,s0
40026f90:	f5de10ef          	jal	ra,40008eec <shell_fprintf>
		return -EALREADY;
40026f94:	f8800913          	li	s2,-120
40026f98:	f61ff06f          	j	40026ef8 <cmd_net_udp_send+0x40>
	memset(&addr, 0, sizeof(addr));
40026f9c:	01800613          	li	a2,24
40026fa0:	00000593          	li	a1,0
40026fa4:	01810513          	addi	a0,sp,24
40026fa8:	d75e50ef          	jal	ra,4000cd1c <memset>
	ret = net_ipaddr_parse(host, strlen(host), &addr);
40026fac:	000a8513          	mv	a0,s5
40026fb0:	c25e50ef          	jal	ra,4000cbd4 <strlen>
40026fb4:	00050593          	mv	a1,a0
40026fb8:	01810613          	addi	a2,sp,24
40026fbc:	000a8513          	mv	a0,s5
40026fc0:	9c4ee0ef          	jal	ra,40015184 <net_ipaddr_parse>
	ret = net_context_get(addr.sa_family, SOCK_DGRAM, IPPROTO_UDP,
40026fc4:	01815503          	lhu	a0,24(sp)
40026fc8:	0dc98693          	addi	a3,s3,220
40026fcc:	01100613          	li	a2,17
40026fd0:	00200593          	li	a1,2
40026fd4:	d65ee0ef          	jal	ra,40015d38 <net_context_get>
40026fd8:	00050913          	mv	s2,a0
	if (ret < 0) {
40026fdc:	02055063          	bgez	a0,40026ffc <cmd_net_udp_send+0x144>
		PR_WARNING("Cannot get UDP context (%d)\n", ret);
40026fe0:	40036637          	lui	a2,0x40036
40026fe4:	00050693          	mv	a3,a0
40026fe8:	5d060613          	addi	a2,a2,1488 # 400365d0 <CSWTCH.15846+0xf70>
40026fec:	00300593          	li	a1,3
40026ff0:	00040513          	mv	a0,s0
40026ff4:	ef9e10ef          	jal	ra,40008eec <shell_fprintf>
		return ret;
40026ff8:	f01ff06f          	j	40026ef8 <cmd_net_udp_send+0x40>
	udp_shell = sh;
40026ffc:	400397b7          	lui	a5,0x40039
40027000:	0c87ac23          	sw	s0,216(a5) # 400390d8 <udp_shell>
	if (IS_ENABLED(CONFIG_NET_IPV6) && addr.sa_family == AF_INET6) {
40027004:	01815783          	lhu	a5,24(sp)
40027008:	00200713          	li	a4,2
4002700c:	02e79e63          	bne	a5,a4,40027048 <cmd_net_udp_send+0x190>
		net_sin6(&addr)->sin6_port = htons(port);
40027010:	00849793          	slli	a5,s1,0x8
40027014:	0084d493          	srli	s1,s1,0x8
40027018:	0097e7b3          	or	a5,a5,s1
		iface = net_if_ipv6_select_src_iface(
4002701c:	01c10513          	addi	a0,sp,28
		net_sin6(&addr)->sin6_port = htons(port);
40027020:	00f11d23          	sh	a5,26(sp)
		addrlen = sizeof(struct sockaddr_in6);
40027024:	01800493          	li	s1,24
		iface = net_if_ipv6_select_src_iface(
40027028:	d85eb0ef          	jal	ra,40012dac <net_if_ipv6_select_src_iface>
	if (!iface) {
4002702c:	06051c63          	bnez	a0,400270a4 <cmd_net_udp_send+0x1ec>
		PR_WARNING("No interface to send to given host\n");
40027030:	40036637          	lui	a2,0x40036
40027034:	61860613          	addi	a2,a2,1560 # 40036618 <CSWTCH.15846+0xfb8>
		PR_WARNING("UDP packet sending failed\n");
40027038:	00300593          	li	a1,3
4002703c:	00040513          	mv	a0,s0
40027040:	eade10ef          	jal	ra,40008eec <shell_fprintf>
40027044:	0480006f          	j	4002708c <cmd_net_udp_send+0x1d4>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && addr.sa_family == AF_INET) {
40027048:	00100713          	li	a4,1
4002704c:	02e79263          	bne	a5,a4,40027070 <cmd_net_udp_send+0x1b8>
		net_sin(&addr)->sin_port = htons(port);
40027050:	00849793          	slli	a5,s1,0x8
40027054:	0084d493          	srli	s1,s1,0x8
40027058:	0097e7b3          	or	a5,a5,s1
		iface = net_if_ipv4_select_src_iface(
4002705c:	01c10513          	addi	a0,sp,28
		net_sin(&addr)->sin_port = htons(port);
40027060:	00f11d23          	sh	a5,26(sp)
		addrlen = sizeof(struct sockaddr_in);
40027064:	00800493          	li	s1,8
		iface = net_if_ipv4_select_src_iface(
40027068:	89cec0ef          	jal	ra,40013104 <net_if_ipv4_select_src_iface>
4002706c:	fc1ff06f          	j	4002702c <cmd_net_udp_send+0x174>
		PR_WARNING("IPv6 and IPv4 are disabled, cannot %s.\n", "send");
40027070:	400356b7          	lui	a3,0x40035
40027074:	40036637          	lui	a2,0x40036
40027078:	38068693          	addi	a3,a3,896 # 40035380 <CSWTCH.16862+0x188>
4002707c:	5f060613          	addi	a2,a2,1520 # 400365f0 <CSWTCH.15846+0xf90>
		PR_WARNING("Setting rcv callback failed (%d)\n", ret);
40027080:	00300593          	li	a1,3
40027084:	00040513          	mv	a0,s0
40027088:	e65e10ef          	jal	ra,40008eec <shell_fprintf>
	ret = net_context_put(udp_ctx);
4002708c:	0dc9a503          	lw	a0,220(s3)
40027090:	f85ee0ef          	jal	ra,40016014 <net_context_put>
40027094:	00050693          	mv	a3,a0
	if (ret < 0) {
40027098:	0a054e63          	bltz	a0,40027154 <cmd_net_udp_send+0x29c>
	return 0;
4002709c:	00000913          	li	s2,0
400270a0:	e59ff06f          	j	40026ef8 <cmd_net_udp_send+0x40>
	net_context_set_iface(udp_ctx, iface);
400270a4:	0dc9a903          	lw	s2,220(s3)
	context->iface = net_if_get_by_iface(iface);
400270a8:	ab9ec0ef          	jal	ra,40013b60 <net_if_get_by_iface>
	ret = net_context_recv(udp_ctx, udp_rcvd, K_NO_WAIT, NULL);
400270ac:	400275b7          	lui	a1,0x40027
400270b0:	06a90b23          	sb	a0,118(s2)
400270b4:	0dc9a503          	lw	a0,220(s3)
400270b8:	00000693          	li	a3,0
400270bc:	00000713          	li	a4,0
400270c0:	00000613          	li	a2,0
400270c4:	2c058593          	addi	a1,a1,704 # 400272c0 <udp_rcvd>
400270c8:	e99ef0ef          	jal	ra,40016f60 <net_context_recv>
400270cc:	00050693          	mv	a3,a0
	if (ret < 0) {
400270d0:	00055863          	bgez	a0,400270e0 <cmd_net_udp_send+0x228>
		PR_WARNING("Setting rcv callback failed (%d)\n", ret);
400270d4:	40036637          	lui	a2,0x40036
400270d8:	63c60613          	addi	a2,a2,1596 # 4003663c <CSWTCH.15846+0xfdc>
400270dc:	fa5ff06f          	j	40027080 <cmd_net_udp_send+0x1c8>
	ret = net_context_sendto(udp_ctx, payload, strlen(payload), &addr,
400270e0:	0dc9a903          	lw	s2,220(s3)
400270e4:	000a0513          	mv	a0,s4
400270e8:	aede50ef          	jal	ra,4000cbd4 <strlen>
400270ec:	400277b7          	lui	a5,0x40027
400270f0:	00050613          	mv	a2,a0
400270f4:	01810693          	addi	a3,sp,24
400270f8:	00012023          	sw	zero,0(sp)
400270fc:	fff00813          	li	a6,-1
40027100:	fff00893          	li	a7,-1
40027104:	e8478793          	addi	a5,a5,-380 # 40026e84 <udp_sent>
40027108:	00048713          	mv	a4,s1
4002710c:	000a0593          	mv	a1,s4
40027110:	00090513          	mv	a0,s2
40027114:	db9ef0ef          	jal	ra,40016ecc <net_context_sendto>
40027118:	00050693          	mv	a3,a0
	if (ret < 0) {
4002711c:	00055863          	bgez	a0,4002712c <cmd_net_udp_send+0x274>
		PR_WARNING("Sending packet failed (%d)\n", ret);
40027120:	40036637          	lui	a2,0x40036
40027124:	66060613          	addi	a2,a2,1632 # 40036660 <CSWTCH.15846+0x1000>
40027128:	f59ff06f          	j	40027080 <cmd_net_udp_send+0x1c8>
	return z_impl_k_sem_take(sem, timeout);
4002712c:	40045537          	lui	a0,0x40045
40027130:	0c800593          	li	a1,200
40027134:	00000613          	li	a2,0
40027138:	8f850513          	addi	a0,a0,-1800 # 400448f8 <udp_send_wait>
4002713c:	06d080ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
	if (ret == -EAGAIN) {
40027140:	ff500793          	li	a5,-11
40027144:	f4f514e3          	bne	a0,a5,4002708c <cmd_net_udp_send+0x1d4>
		PR_WARNING("UDP packet sending failed\n");
40027148:	40036637          	lui	a2,0x40036
4002714c:	67c60613          	addi	a2,a2,1660 # 4003667c <CSWTCH.15846+0x101c>
40027150:	ee9ff06f          	j	40027038 <cmd_net_udp_send+0x180>
		PR_WARNING("Cannot put UDP context (%d)\n", ret);
40027154:	40036637          	lui	a2,0x40036
40027158:	69860613          	addi	a2,a2,1688 # 40036698 <CSWTCH.15846+0x1038>
4002715c:	00300593          	li	a1,3
40027160:	00040513          	mv	a0,s0
40027164:	d89e10ef          	jal	ra,40008eec <shell_fprintf>
40027168:	f35ff06f          	j	4002709c <cmd_net_udp_send+0x1e4>

4002716c <net_if_flag_is_set>:
	if (iface == NULL) {
4002716c:	02050c63          	beqz	a0,400271a4 <net_if_flag_is_set+0x38>
{
40027170:	ff010113          	addi	sp,sp,-16
40027174:	00812423          	sw	s0,8(sp)
40027178:	00112623          	sw	ra,12(sp)
	return atomic_test_bit(iface->if_dev->flags, value);
4002717c:	00052503          	lw	a0,0(a0)
40027180:	00058413          	mv	s0,a1
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
40027184:	00c50513          	addi	a0,a0,12
40027188:	1010a0ef          	jal	ra,40031a88 <atomic_get>
}
4002718c:	00c12083          	lw	ra,12(sp)
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
40027190:	40855533          	sra	a0,a0,s0
40027194:	00812403          	lw	s0,8(sp)
40027198:	00157513          	andi	a0,a0,1
4002719c:	01010113          	addi	sp,sp,16
400271a0:	00008067          	ret
		return false;
400271a4:	00000513          	li	a0,0
}
400271a8:	00008067          	ret

400271ac <net_if_is_up>:
{
400271ac:	ff010113          	addi	sp,sp,-16
	return net_if_flag_is_set(iface, NET_IF_UP) &&
400271b0:	00000593          	li	a1,0
{
400271b4:	00812423          	sw	s0,8(sp)
400271b8:	00112623          	sw	ra,12(sp)
400271bc:	00050413          	mv	s0,a0
	return net_if_flag_is_set(iface, NET_IF_UP) &&
400271c0:	fadff0ef          	jal	ra,4002716c <net_if_flag_is_set>
400271c4:	02050263          	beqz	a0,400271e8 <net_if_is_up+0x3c>
	       net_if_flag_is_set(iface, NET_IF_RUNNING);
400271c8:	00800593          	li	a1,8
400271cc:	00040513          	mv	a0,s0
400271d0:	f9dff0ef          	jal	ra,4002716c <net_if_flag_is_set>
}
400271d4:	00c12083          	lw	ra,12(sp)
400271d8:	00812403          	lw	s0,8(sp)
400271dc:	00157513          	andi	a0,a0,1
400271e0:	01010113          	addi	sp,sp,16
400271e4:	00008067          	ret
	return net_if_flag_is_set(iface, NET_IF_UP) &&
400271e8:	00000513          	li	a0,0
400271ec:	fe9ff06f          	j	400271d4 <net_if_is_up+0x28>

400271f0 <cmd_net_iface_up>:
{
400271f0:	fe010113          	addi	sp,sp,-32
400271f4:	00812c23          	sw	s0,24(sp)
400271f8:	00112e23          	sw	ra,28(sp)
400271fc:	00912a23          	sw	s1,20(sp)
	idx = get_iface_idx(sh, argv[1]);
40027200:	00462583          	lw	a1,4(a2)
{
40027204:	00050413          	mv	s0,a0
	idx = get_iface_idx(sh, argv[1]);
40027208:	888fe0ef          	jal	ra,40025290 <get_iface_idx>
	if (idx < 0) {
4002720c:	00a12623          	sw	a0,12(sp)
40027210:	02054463          	bltz	a0,40027238 <cmd_net_iface_up+0x48>
	iface = net_if_get_by_index(idx);
40027214:	cd1fd0ef          	jal	ra,40024ee4 <net_if_get_by_index>
	if (!iface) {
40027218:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
4002721c:	00050493          	mv	s1,a0
	if (!iface) {
40027220:	02051a63          	bnez	a0,40027254 <cmd_net_iface_up+0x64>
		PR_WARNING("No such interface in index %d\n", idx);
40027224:	40036637          	lui	a2,0x40036
40027228:	da060613          	addi	a2,a2,-608 # 40035da0 <CSWTCH.15846+0x740>
4002722c:	00300593          	li	a1,3
40027230:	00040513          	mv	a0,s0
40027234:	cb9e10ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40027238:	ff800713          	li	a4,-8
}
4002723c:	01c12083          	lw	ra,28(sp)
40027240:	01812403          	lw	s0,24(sp)
40027244:	01412483          	lw	s1,20(sp)
40027248:	00070513          	mv	a0,a4
4002724c:	02010113          	addi	sp,sp,32
40027250:	00008067          	ret
40027254:	00d12623          	sw	a3,12(sp)
	if (net_if_is_up(iface)) {
40027258:	f55ff0ef          	jal	ra,400271ac <net_if_is_up>
4002725c:	00c12683          	lw	a3,12(sp)
40027260:	00050863          	beqz	a0,40027270 <cmd_net_iface_up+0x80>
		PR_WARNING("Interface %d is already up.\n", idx);
40027264:	40036637          	lui	a2,0x40036
40027268:	6b860613          	addi	a2,a2,1720 # 400366b8 <CSWTCH.15846+0x1058>
4002726c:	fc1ff06f          	j	4002722c <cmd_net_iface_up+0x3c>
	ret = net_if_up(iface);
40027270:	00048513          	mv	a0,s1
40027274:	00d12623          	sw	a3,12(sp)
40027278:	991ec0ef          	jal	ra,40013c08 <net_if_up>
	if (ret) {
4002727c:	00c12683          	lw	a3,12(sp)
	ret = net_if_up(iface);
40027280:	00050713          	mv	a4,a0
	if (ret) {
40027284:	00050e63          	beqz	a0,400272a0 <cmd_net_iface_up+0xb0>
		PR_WARNING("Cannot take interface %d up (%d)\n", idx, ret);
40027288:	40036637          	lui	a2,0x40036
4002728c:	6d860613          	addi	a2,a2,1752 # 400366d8 <CSWTCH.15846+0x1078>
40027290:	00300593          	li	a1,3
40027294:	00040513          	mv	a0,s0
40027298:	c55e10ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
4002729c:	f9dff06f          	j	40027238 <cmd_net_iface_up+0x48>
		PR("Interface %d is up\n", idx);
400272a0:	40036637          	lui	a2,0x40036
400272a4:	00a12623          	sw	a0,12(sp)
400272a8:	6fc60613          	addi	a2,a2,1788 # 400366fc <CSWTCH.15846+0x109c>
400272ac:	00800593          	li	a1,8
400272b0:	00040513          	mv	a0,s0
400272b4:	c39e10ef          	jal	ra,40008eec <shell_fprintf>
400272b8:	00c12703          	lw	a4,12(sp)
	return 0;
400272bc:	f81ff06f          	j	4002723c <cmd_net_iface_up+0x4c>

400272c0 <udp_rcvd>:
	if (pkt) {
400272c0:	0a058e63          	beqz	a1,4002737c <udp_rcvd+0xbc>
{
400272c4:	fd010113          	addi	sp,sp,-48
		size_t len = net_pkt_remaining_data(pkt);
400272c8:	00058513          	mv	a0,a1
{
400272cc:	02112623          	sw	ra,44(sp)
400272d0:	02812423          	sw	s0,40(sp)
400272d4:	02912223          	sw	s1,36(sp)
400272d8:	03212023          	sw	s2,32(sp)
400272dc:	01312e23          	sw	s3,28(sp)
400272e0:	01412c23          	sw	s4,24(sp)
400272e4:	00058413          	mv	s0,a1
		PR_SHELL(udp_shell, "Received UDP packet: ");
400272e8:	400394b7          	lui	s1,0x40039
		size_t len = net_pkt_remaining_data(pkt);
400272ec:	9e8f10ef          	jal	ra,400184d4 <net_pkt_remaining_data>
400272f0:	00050993          	mv	s3,a0
		PR_SHELL(udp_shell, "Received UDP packet: ");
400272f4:	0d84a503          	lw	a0,216(s1) # 400390d8 <udp_shell>
400272f8:	40036637          	lui	a2,0x40036
400272fc:	71060613          	addi	a2,a2,1808 # 40036710 <CSWTCH.15846+0x10b0>
40027300:	00800593          	li	a1,8
40027304:	be9e10ef          	jal	ra,40008eec <shell_fprintf>
		for (size_t i = 0; i < len; ++i) {
40027308:	00000913          	li	s2,0
			PR_SHELL(udp_shell, "%02x ", byte);
4002730c:	40033a37          	lui	s4,0x40033
		for (size_t i = 0; i < len; ++i) {
40027310:	05299063          	bne	s3,s2,40027350 <udp_rcvd+0x90>
		PR_SHELL(udp_shell, "\n");
40027314:	0d84a503          	lw	a0,216(s1)
40027318:	40033637          	lui	a2,0x40033
4002731c:	bf460613          	addi	a2,a2,-1036 # 40032bf4 <severity+0x88>
40027320:	00800593          	li	a1,8
40027324:	bc9e10ef          	jal	ra,40008eec <shell_fprintf>
		net_pkt_unref(pkt);
40027328:	00040513          	mv	a0,s0
4002732c:	cf0f00ef          	jal	ra,4001781c <net_pkt_unref>
}
40027330:	02c12083          	lw	ra,44(sp)
40027334:	02812403          	lw	s0,40(sp)
40027338:	02412483          	lw	s1,36(sp)
4002733c:	02012903          	lw	s2,32(sp)
40027340:	01c12983          	lw	s3,28(sp)
40027344:	01812a03          	lw	s4,24(sp)
40027348:	03010113          	addi	sp,sp,48
4002734c:	00008067          	ret
	return net_pkt_read(pkt, data, 1);
40027350:	00100613          	li	a2,1
40027354:	00f10593          	addi	a1,sp,15
40027358:	00040513          	mv	a0,s0
4002735c:	fddf00ef          	jal	ra,40018338 <net_pkt_read>
			PR_SHELL(udp_shell, "%02x ", byte);
40027360:	00f14683          	lbu	a3,15(sp)
40027364:	0d84a503          	lw	a0,216(s1)
40027368:	b10a0613          	addi	a2,s4,-1264 # 40032b10 <mpsc_config+0xb4>
4002736c:	00800593          	li	a1,8
40027370:	b7de10ef          	jal	ra,40008eec <shell_fprintf>
		for (size_t i = 0; i < len; ++i) {
40027374:	00190913          	addi	s2,s2,1
40027378:	f99ff06f          	j	40027310 <udp_rcvd+0x50>
4002737c:	00008067          	ret

40027380 <tcp_recv_cb>:
{
40027380:	ff010113          	addi	sp,sp,-16
40027384:	00112623          	sw	ra,12(sp)
40027388:	00812423          	sw	s0,8(sp)
4002738c:	00912223          	sw	s1,4(sp)
	if (pkt == NULL) {
40027390:	06059e63          	bnez	a1,4002740c <tcp_recv_cb+0x8c>
		if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
40027394:	40039437          	lui	s0,0x40039
40027398:	0e442503          	lw	a0,228(s0) # 400390e4 <tcp_ctx>
4002739c:	04050e63          	beqz	a0,400273f8 <tcp_recv_cb+0x78>
	return context->flags & NET_CONTEXT_IN_USE;
400273a0:	07455783          	lhu	a5,116(a0)
400273a4:	0017f793          	andi	a5,a5,1
400273a8:	04078863          	beqz	a5,400273f8 <tcp_recv_cb+0x78>
		ret = net_context_put(tcp_ctx);
400273ac:	c69ee0ef          	jal	ra,40016014 <net_context_put>
400273b0:	00050693          	mv	a3,a0
		if (ret < 0) {
400273b4:	400397b7          	lui	a5,0x40039
400273b8:	02055463          	bgez	a0,400273e0 <tcp_recv_cb+0x60>
}
400273bc:	00812403          	lw	s0,8(sp)
400273c0:	00c12083          	lw	ra,12(sp)
400273c4:	00412483          	lw	s1,4(sp)
			PR_SHELL(tcp_shell,
400273c8:	0e07a503          	lw	a0,224(a5) # 400390e0 <tcp_shell>
400273cc:	40036637          	lui	a2,0x40036
400273d0:	98060613          	addi	a2,a2,-1664 # 40035980 <CSWTCH.15846+0x320>
400273d4:	00800593          	li	a1,8
}
400273d8:	01010113          	addi	sp,sp,16
			PR_SHELL(tcp_shell,
400273dc:	b11e106f          	j	40008eec <shell_fprintf>
		PR_SHELL(tcp_shell, "Connection closed by remote peer.\n");
400273e0:	0e07a503          	lw	a0,224(a5)
400273e4:	40036637          	lui	a2,0x40036
400273e8:	72860613          	addi	a2,a2,1832 # 40036728 <CSWTCH.15846+0x10c8>
400273ec:	00800593          	li	a1,8
400273f0:	afde10ef          	jal	ra,40008eec <shell_fprintf>
		tcp_ctx = NULL;
400273f4:	0e042223          	sw	zero,228(s0)
}
400273f8:	00c12083          	lw	ra,12(sp)
400273fc:	00812403          	lw	s0,8(sp)
40027400:	00412483          	lw	s1,4(sp)
40027404:	01010113          	addi	sp,sp,16
40027408:	00008067          	ret
4002740c:	00050493          	mv	s1,a0
	len = net_pkt_remaining_data(pkt);
40027410:	00058513          	mv	a0,a1
40027414:	00058413          	mv	s0,a1
40027418:	8bcf10ef          	jal	ra,400184d4 <net_pkt_remaining_data>
4002741c:	00050593          	mv	a1,a0
	(void)net_context_update_recv_wnd(context, len);
40027420:	00048513          	mv	a0,s1
40027424:	d85ef0ef          	jal	ra,400171a8 <net_context_update_recv_wnd>
	PR_SHELL(tcp_shell, "%zu bytes received\n", net_pkt_get_len(pkt));
40027428:	400397b7          	lui	a5,0x40039
4002742c:	0e07a503          	lw	a0,224(a5) # 400390e0 <tcp_shell>
40027430:	00842783          	lw	a5,8(s0)
	size_t bytes = 0;
40027434:	00000693          	li	a3,0
	while (buf) {
40027438:	02079663          	bnez	a5,40027464 <tcp_recv_cb+0xe4>
4002743c:	40036637          	lui	a2,0x40036
40027440:	74c60613          	addi	a2,a2,1868 # 4003674c <CSWTCH.15846+0x10ec>
40027444:	00800593          	li	a1,8
40027448:	aa5e10ef          	jal	ra,40008eec <shell_fprintf>
	net_pkt_unref(pkt);
4002744c:	00040513          	mv	a0,s0
}
40027450:	00812403          	lw	s0,8(sp)
40027454:	00c12083          	lw	ra,12(sp)
40027458:	00412483          	lw	s1,4(sp)
4002745c:	01010113          	addi	sp,sp,16
	net_pkt_unref(pkt);
40027460:	bbcf006f          	j	4001781c <net_pkt_unref>
		bytes += buf->len;
40027464:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
40027468:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4002746c:	00e686b3          	add	a3,a3,a4
		buf = buf->frags;
40027470:	fc9ff06f          	j	40027438 <tcp_recv_cb+0xb8>

40027474 <context_cb>:
{
40027474:	f6010113          	addi	sp,sp,-160
40027478:	08812c23          	sw	s0,152(sp)
4002747c:	08912a23          	sw	s1,148(sp)
40027480:	09312623          	sw	s3,140(sp)
40027484:	08112e23          	sw	ra,156(sp)
40027488:	09212823          	sw	s2,144(sp)
4002748c:	09412423          	sw	s4,136(sp)
40027490:	09512223          	sw	s5,132(sp)
	const struct shell *sh = data->sh;
40027494:	0005aa03          	lw	s4,0(a1)
	int *count = data->user_data;
40027498:	0045a903          	lw	s2,4(a1)
{
4002749c:	00050413          	mv	s0,a0
	char addr_remote[ADDR_LEN + 7] = "";
400274a0:	02b00613          	li	a2,43
400274a4:	00000593          	li	a1,0
400274a8:	05410513          	addi	a0,sp,84
400274ac:	04012823          	sw	zero,80(sp)
400274b0:	86de50ef          	jal	ra,4000cd1c <memset>
	if (context->local.family == AF_INET6) {
400274b4:	02045683          	lhu	a3,32(s0)
400274b8:	00200793          	li	a5,2
400274bc:	02010493          	addi	s1,sp,32
400274c0:	05010993          	addi	s3,sp,80
400274c4:	16f69263          	bne	a3,a5,40027628 <context_cb+0x1b4>
		snprintk(addr_local, local_len, "[%s]:%u",
400274c8:	02442583          	lw	a1,36(s0)
400274cc:	00200513          	li	a0,2
400274d0:	40036ab7          	lui	s5,0x40036
400274d4:	be0ed0ef          	jal	ra,400148b4 <net_sprint_addr>
400274d8:	02245783          	lhu	a5,34(s0)
400274dc:	00050693          	mv	a3,a0
400274e0:	760a8613          	addi	a2,s5,1888 # 40036760 <CSWTCH.15846+0x1100>
400274e4:	00879713          	slli	a4,a5,0x8
400274e8:	0087d793          	srli	a5,a5,0x8
400274ec:	00f76733          	or	a4,a4,a5
400274f0:	01071713          	slli	a4,a4,0x10
400274f4:	01075713          	srli	a4,a4,0x10
400274f8:	02f00593          	li	a1,47
400274fc:	00048513          	mv	a0,s1
40027500:	81dda0ef          	jal	ra,40001d1c <snprintk>
		snprintk(addr_remote, remote_len, "[%s]:%u",
40027504:	03040593          	addi	a1,s0,48
40027508:	00200513          	li	a0,2
4002750c:	ba8ed0ef          	jal	ra,400148b4 <net_sprint_addr>
40027510:	02e45783          	lhu	a5,46(s0)
40027514:	00050693          	mv	a3,a0
40027518:	760a8613          	addi	a2,s5,1888
4002751c:	00879713          	slli	a4,a5,0x8
40027520:	0087d793          	srli	a5,a5,0x8
40027524:	00f76733          	or	a4,a4,a5
40027528:	01071713          	slli	a4,a4,0x10
4002752c:	01075713          	srli	a4,a4,0x10
		snprintk(addr_remote, remote_len, "%s:%d",
40027530:	02f00593          	li	a1,47
40027534:	00098513          	mv	a0,s3
40027538:	fe4da0ef          	jal	ra,40001d1c <snprintk>
	PR("[%2d] %p\t%d      %c%c%c   %16s\t%16s\n",
4002753c:	00092683          	lw	a3,0(s2)
	return net_if_get_by_index(context->iface);
40027540:	07640503          	lb	a0,118(s0)
40027544:	00168693          	addi	a3,a3,1
40027548:	00d12e23          	sw	a3,28(sp)
4002754c:	999fd0ef          	jal	ra,40024ee4 <net_if_get_by_index>
40027550:	e10ec0ef          	jal	ra,40013b60 <net_if_get_by_iface>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40027554:	07445703          	lhu	a4,116(s0)
40027558:	00200593          	li	a1,2
4002755c:	01c12683          	lw	a3,28(sp)
40027560:	00375613          	srli	a2,a4,0x3
40027564:	00767613          	andi	a2,a2,7
40027568:	00050793          	mv	a5,a0
4002756c:	03600813          	li	a6,54
40027570:	00b60a63          	beq	a2,a1,40027584 <context_cb+0x110>
40027574:	00100593          	li	a1,1
40027578:	02000813          	li	a6,32
4002757c:	00b61463          	bne	a2,a1,40027584 <context_cb+0x110>
40027580:	03400813          	li	a6,52
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
40027584:	00675713          	srli	a4,a4,0x6
40027588:	00377713          	andi	a4,a4,3
4002758c:	00200613          	li	a2,2
40027590:	04400893          	li	a7,68
40027594:	02c70063          	beq	a4,a2,400275b4 <context_cb+0x140>
40027598:	00100613          	li	a2,1
4002759c:	05300893          	li	a7,83
400275a0:	00c70a63          	beq	a4,a2,400275b4 <context_cb+0x140>
400275a4:	00300613          	li	a2,3
400275a8:	02000893          	li	a7,32
400275ac:	00c71463          	bne	a4,a2,400275b4 <context_cb+0x140>
400275b0:	05200893          	li	a7,82
	return context->proto;
400275b4:	07245603          	lhu	a2,114(s0)
400275b8:	01100593          	li	a1,17
400275bc:	05500713          	li	a4,85
400275c0:	00b60a63          	beq	a2,a1,400275d4 <context_cb+0x160>
400275c4:	00600593          	li	a1,6
400275c8:	02000713          	li	a4,32
400275cc:	00b61463          	bne	a2,a1,400275d4 <context_cb+0x160>
400275d0:	05400713          	li	a4,84
400275d4:	40036637          	lui	a2,0x40036
400275d8:	01312423          	sw	s3,8(sp)
400275dc:	00912223          	sw	s1,4(sp)
400275e0:	00e12023          	sw	a4,0(sp)
400275e4:	000a0513          	mv	a0,s4
400275e8:	00040713          	mv	a4,s0
400275ec:	77c60613          	addi	a2,a2,1916 # 4003677c <CSWTCH.15846+0x111c>
400275f0:	00800593          	li	a1,8
400275f4:	8f9e10ef          	jal	ra,40008eec <shell_fprintf>
	(*count)++;
400275f8:	00092783          	lw	a5,0(s2)
400275fc:	00178793          	addi	a5,a5,1
40027600:	00f92023          	sw	a5,0(s2)
}
40027604:	09c12083          	lw	ra,156(sp)
40027608:	09812403          	lw	s0,152(sp)
4002760c:	09412483          	lw	s1,148(sp)
40027610:	09012903          	lw	s2,144(sp)
40027614:	08c12983          	lw	s3,140(sp)
40027618:	08812a03          	lw	s4,136(sp)
4002761c:	08412a83          	lw	s5,132(sp)
40027620:	0a010113          	addi	sp,sp,160
40027624:	00008067          	ret
	if (context->local.family == AF_INET) {
40027628:	00100793          	li	a5,1
4002762c:	06f69863          	bne	a3,a5,4002769c <context_cb+0x228>
		snprintk(addr_local, local_len, "%s:%d",
40027630:	02442583          	lw	a1,36(s0)
40027634:	00100513          	li	a0,1
40027638:	40036ab7          	lui	s5,0x40036
4002763c:	a78ed0ef          	jal	ra,400148b4 <net_sprint_addr>
40027640:	02245783          	lhu	a5,34(s0)
40027644:	00050693          	mv	a3,a0
40027648:	768a8613          	addi	a2,s5,1896 # 40036768 <CSWTCH.15846+0x1108>
4002764c:	00879713          	slli	a4,a5,0x8
40027650:	0087d793          	srli	a5,a5,0x8
40027654:	00f76733          	or	a4,a4,a5
40027658:	01071713          	slli	a4,a4,0x10
4002765c:	01075713          	srli	a4,a4,0x10
40027660:	02f00593          	li	a1,47
40027664:	00048513          	mv	a0,s1
40027668:	eb4da0ef          	jal	ra,40001d1c <snprintk>
		snprintk(addr_remote, remote_len, "%s:%d",
4002766c:	03040593          	addi	a1,s0,48
40027670:	00100513          	li	a0,1
40027674:	a40ed0ef          	jal	ra,400148b4 <net_sprint_addr>
40027678:	02e45783          	lhu	a5,46(s0)
4002767c:	00050693          	mv	a3,a0
40027680:	768a8613          	addi	a2,s5,1896
40027684:	00879713          	slli	a4,a5,0x8
40027688:	0087d793          	srli	a5,a5,0x8
4002768c:	00f76733          	or	a4,a4,a5
40027690:	01071713          	slli	a4,a4,0x10
40027694:	01075713          	srli	a4,a4,0x10
40027698:	e99ff06f          	j	40027530 <context_cb+0xbc>
	if (context->local.family == AF_UNSPEC) {
4002769c:	00069e63          	bnez	a3,400276b8 <context_cb+0x244>
		snprintk(addr_local, local_len, "AF_UNSPEC");
400276a0:	40035637          	lui	a2,0x40035
400276a4:	c6c60613          	addi	a2,a2,-916 # 40034c6c <net_buf_fixed_cb+0x30c>
		snprintk(addr_local, local_len, "AF_CAN");
400276a8:	02f00593          	li	a1,47
400276ac:	00048513          	mv	a0,s1
400276b0:	e6cda0ef          	jal	ra,40001d1c <snprintk>
400276b4:	e89ff06f          	j	4002753c <context_cb+0xc8>
	} else if (context->local.family == AF_PACKET) {
400276b8:	00300793          	li	a5,3
400276bc:	00f69863          	bne	a3,a5,400276cc <context_cb+0x258>
		snprintk(addr_local, local_len, "AF_PACKET");
400276c0:	40035637          	lui	a2,0x40035
400276c4:	c8c60613          	addi	a2,a2,-884 # 40034c8c <net_buf_fixed_cb+0x32c>
400276c8:	fe1ff06f          	j	400276a8 <context_cb+0x234>
	} else if (context->local.family == AF_CAN) {
400276cc:	00400793          	li	a5,4
400276d0:	00f69863          	bne	a3,a5,400276e0 <context_cb+0x26c>
		snprintk(addr_local, local_len, "AF_CAN");
400276d4:	40035637          	lui	a2,0x40035
400276d8:	c9860613          	addi	a2,a2,-872 # 40034c98 <net_buf_fixed_cb+0x338>
400276dc:	fcdff06f          	j	400276a8 <context_cb+0x234>
		snprintk(addr_local, local_len, "AF_UNK(%d)",
400276e0:	40036637          	lui	a2,0x40036
400276e4:	77060613          	addi	a2,a2,1904 # 40036770 <CSWTCH.15846+0x1110>
400276e8:	02f00593          	li	a1,47
400276ec:	00048513          	mv	a0,s1
400276f0:	e2cda0ef          	jal	ra,40001d1c <snprintk>
400276f4:	e49ff06f          	j	4002753c <context_cb+0xc8>

400276f8 <cmd_net_resume>:
static int cmd_net_resume(const struct shell *sh, size_t argc,
400276f8:	40035637          	lui	a2,0x40035
400276fc:	ff010113          	addi	sp,sp,-16
40027700:	73460613          	addi	a2,a2,1844 # 40035734 <CSWTCH.15846+0xd4>
40027704:	00200593          	li	a1,2
40027708:	00112623          	sw	ra,12(sp)
4002770c:	fe0e10ef          	jal	ra,40008eec <shell_fprintf>
40027710:	00c12083          	lw	ra,12(sp)
40027714:	00000513          	li	a0,0
40027718:	01010113          	addi	sp,sp,16
4002771c:	00008067          	ret

40027720 <cmd_net_events_off>:
static int cmd_net_events_off(const struct shell *sh, size_t argc,
40027720:	40036637          	lui	a2,0x40036
40027724:	ff010113          	addi	sp,sp,-16
40027728:	85060613          	addi	a2,a2,-1968 # 40035850 <CSWTCH.15846+0x1f0>
4002772c:	00200593          	li	a1,2
40027730:	00112623          	sw	ra,12(sp)
40027734:	fb8e10ef          	jal	ra,40008eec <shell_fprintf>
40027738:	00c12083          	lw	ra,12(sp)
4002773c:	00000513          	li	a0,0
40027740:	01010113          	addi	sp,sp,16
40027744:	00008067          	ret

40027748 <cmd_net_events>:
static int cmd_net_events(const struct shell *sh, size_t argc, char *argv[])
40027748:	40036637          	lui	a2,0x40036
4002774c:	ff010113          	addi	sp,sp,-16
40027750:	85060613          	addi	a2,a2,-1968 # 40035850 <CSWTCH.15846+0x1f0>
40027754:	00200593          	li	a1,2
40027758:	00112623          	sw	ra,12(sp)
4002775c:	f90e10ef          	jal	ra,40008eec <shell_fprintf>
40027760:	00c12083          	lw	ra,12(sp)
40027764:	00000513          	li	a0,0
40027768:	01010113          	addi	sp,sp,16
4002776c:	00008067          	ret

40027770 <iface2str>:
	if (!iface || !iface->if_dev) {
40027770:	02050c63          	beqz	a0,400277a8 <iface2str+0x38>
40027774:	00052783          	lw	a5,0(a0)
40027778:	02078863          	beqz	a5,400277a8 <iface2str+0x38>
	if (net_if_l2(iface) == &NET_L2_GET_NAME(ETHERNET)) {
4002777c:	0047a703          	lw	a4,4(a5)
40027780:	400457b7          	lui	a5,0x40045
40027784:	ab878793          	addi	a5,a5,-1352 # 40044ab8 <_net_l2_ETHERNET>
40027788:	02f71063          	bne	a4,a5,400277a8 <iface2str+0x38>
		if (extra) {
4002778c:	00058863          	beqz	a1,4002779c <iface2str+0x2c>
			*extra = "========";
40027790:	400367b7          	lui	a5,0x40036
40027794:	7c078793          	addi	a5,a5,1984 # 400367c0 <CSWTCH.15846+0x1160>
40027798:	00f5a023          	sw	a5,0(a1)
		return "Ethernet";
4002779c:	40036537          	lui	a0,0x40036
400277a0:	7a450513          	addi	a0,a0,1956 # 400367a4 <CSWTCH.15846+0x1144>
400277a4:	00008067          	ret
	if (extra) {
400277a8:	00059863          	bnez	a1,400277b8 <iface2str+0x48>
	return "<unknown type>";
400277ac:	40036537          	lui	a0,0x40036
400277b0:	7b050513          	addi	a0,a0,1968 # 400367b0 <CSWTCH.15846+0x1150>
}
400277b4:	00008067          	ret
		*extra = "==============";
400277b8:	400367b7          	lui	a5,0x40036
400277bc:	7cc78793          	addi	a5,a5,1996 # 400367cc <CSWTCH.15846+0x116c>
400277c0:	00f5a023          	sw	a5,0(a1)
400277c4:	fe9ff06f          	j	400277ac <iface2str+0x3c>

400277c8 <iface_index_get>:
{
400277c8:	fe010113          	addi	sp,sp,-32
400277cc:	00912a23          	sw	s1,20(sp)
400277d0:	01212823          	sw	s2,16(sp)
400277d4:	00112e23          	sw	ra,28(sp)
400277d8:	00812c23          	sw	s0,24(sp)
	entry->handler = NULL;
400277dc:	0005a623          	sw	zero,12(a1)
{
400277e0:	00050913          	mv	s2,a0
400277e4:	00058493          	mv	s1,a1
	struct net_if *iface = net_if_get_by_index(idx);
400277e8:	efcfd0ef          	jal	ra,40024ee4 <net_if_get_by_index>
400277ec:	00050713          	mv	a4,a0
	if (!iface) {
400277f0:	04050263          	beqz	a0,40027834 <iface_index_get+0x6c>
	snprintk(iface_help_buffer[idx], MAX_IFACE_HELP_STR_LEN,
400277f4:	01c00413          	li	s0,28
400277f8:	02890433          	mul	s0,s2,s0
400277fc:	4003b7b7          	lui	a5,0x4003b
40027800:	14478793          	addi	a5,a5,324 # 4003b144 <iface_help_buffer>
40027804:	00000593          	li	a1,0
40027808:	00a12623          	sw	a0,12(sp)
4002780c:	00f40433          	add	s0,s0,a5
40027810:	f61ff0ef          	jal	ra,40027770 <iface2str>
40027814:	00c12703          	lw	a4,12(sp)
40027818:	40036637          	lui	a2,0x40036
4002781c:	00050693          	mv	a3,a0
40027820:	7dc60613          	addi	a2,a2,2012 # 400367dc <CSWTCH.15846+0x117c>
40027824:	01c00593          	li	a1,28
40027828:	00040513          	mv	a0,s0
4002782c:	cf0da0ef          	jal	ra,40001d1c <snprintk>
	return iface_help_buffer[idx];
40027830:	00040713          	mv	a4,s0
	entry->subcmd = &iface_index;
40027834:	400327b7          	lui	a5,0x40032
40027838:	59878793          	addi	a5,a5,1432 # 40032598 <iface_index>
	entry->help  = set_iface_index_help(idx);
4002783c:	00e4a223          	sw	a4,4(s1)
	entry->subcmd = &iface_index;
40027840:	00f4a423          	sw	a5,8(s1)
	struct net_if *iface = net_if_get_by_index(idx);
40027844:	00090513          	mv	a0,s2
40027848:	e9cfd0ef          	jal	ra,40024ee4 <net_if_get_by_index>
4002784c:	00050413          	mv	s0,a0
	if (!iface) {
40027850:	02050663          	beqz	a0,4002787c <iface_index_get+0xb4>
	snprintk(iface_index_buffer[idx], MAX_IFACE_STR_LEN, "%zu", idx);
40027854:	400397b7          	lui	a5,0x40039
40027858:	00291413          	slli	s0,s2,0x2
4002785c:	0d478793          	addi	a5,a5,212 # 400390d4 <iface_index_buffer>
40027860:	00f40433          	add	s0,s0,a5
40027864:	40036637          	lui	a2,0x40036
40027868:	00090693          	mv	a3,s2
4002786c:	7e460613          	addi	a2,a2,2020 # 400367e4 <CSWTCH.15846+0x1184>
40027870:	00400593          	li	a1,4
40027874:	00040513          	mv	a0,s0
40027878:	ca4da0ef          	jal	ra,40001d1c <snprintk>
	entry->syntax = set_iface_index_buffer(idx);
4002787c:	0084a023          	sw	s0,0(s1)
}
40027880:	01c12083          	lw	ra,28(sp)
40027884:	01812403          	lw	s0,24(sp)
40027888:	01412483          	lw	s1,20(sp)
4002788c:	01012903          	lw	s2,16(sp)
40027890:	02010113          	addi	sp,sp,32
40027894:	00008067          	ret

40027898 <net_shell_print_statistics>:
{
40027898:	fc010113          	addi	sp,sp,-64
4002789c:	02812c23          	sw	s0,56(sp)
400278a0:	02112e23          	sw	ra,60(sp)
400278a4:	02912a23          	sw	s1,52(sp)
400278a8:	03212823          	sw	s2,48(sp)
400278ac:	03312623          	sw	s3,44(sp)
	const struct shell *sh = data->sh;
400278b0:	0005a483          	lw	s1,0(a1)
{
400278b4:	00050413          	mv	s0,a0
	if (iface) {
400278b8:	2c050a63          	beqz	a0,40027b8c <net_shell_print_statistics+0x2f4>
		PR("\nInterface %p (%s) [%d]\n", iface,
400278bc:	01c10593          	addi	a1,sp,28
400278c0:	eb1ff0ef          	jal	ra,40027770 <iface2str>
400278c4:	00a12623          	sw	a0,12(sp)
400278c8:	00040513          	mv	a0,s0
400278cc:	a94ec0ef          	jal	ra,40013b60 <net_if_get_by_iface>
400278d0:	00c12703          	lw	a4,12(sp)
400278d4:	40036637          	lui	a2,0x40036
400278d8:	00050793          	mv	a5,a0
400278dc:	00040693          	mv	a3,s0
400278e0:	7e860613          	addi	a2,a2,2024 # 400367e8 <CSWTCH.15846+0x1188>
400278e4:	00800593          	li	a1,8
400278e8:	00048513          	mv	a0,s1
400278ec:	e00e10ef          	jal	ra,40008eec <shell_fprintf>
		PR("===========================%s\n", extra);
400278f0:	01c12683          	lw	a3,28(sp)
400278f4:	40037637          	lui	a2,0x40037
400278f8:	80460613          	addi	a2,a2,-2044 # 40036804 <CSWTCH.15846+0x11a4>
400278fc:	00800593          	li	a1,8
40027900:	00048513          	mv	a0,s1
40027904:	de8e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("IPv6 recv      %d\tsent\t%d\tdrop\t%d\tforwarded\t%d\n",
40027908:	02842683          	lw	a3,40(s0)
4002790c:	02c42703          	lw	a4,44(s0)
40027910:	03442783          	lw	a5,52(s0)
40027914:	03042803          	lw	a6,48(s0)
40027918:	40037637          	lui	a2,0x40037
4002791c:	84c60613          	addi	a2,a2,-1972 # 4003684c <CSWTCH.15846+0x11ec>
40027920:	00800593          	li	a1,8
40027924:	00048513          	mv	a0,s1
40027928:	dc4e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("IPv6 ND recv   %d\tsent\t%d\tdrop\t%d\n",
4002792c:	2a040263          	beqz	s0,40027bd0 <net_shell_print_statistics+0x338>
40027930:	0a842683          	lw	a3,168(s0)
40027934:	0ac42703          	lw	a4,172(s0)
40027938:	0a442783          	lw	a5,164(s0)
4002793c:	40037637          	lui	a2,0x40037
40027940:	87c60613          	addi	a2,a2,-1924 # 4003687c <CSWTCH.15846+0x121c>
40027944:	00800593          	li	a1,8
40027948:	00048513          	mv	a0,s1
4002794c:	da0e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("IPv6 MLD recv  %d\tsent\t%d\tdrop\t%d\n",
40027950:	28040c63          	beqz	s0,40027be8 <net_shell_print_statistics+0x350>
40027954:	0b042683          	lw	a3,176(s0)
40027958:	0b442703          	lw	a4,180(s0)
4002795c:	0b842783          	lw	a5,184(s0)
40027960:	40037637          	lui	a2,0x40037
40027964:	8a060613          	addi	a2,a2,-1888 # 400368a0 <CSWTCH.15846+0x1240>
40027968:	00800593          	li	a1,8
4002796c:	00048513          	mv	a0,s1
40027970:	d7ce10ef          	jal	ra,40008eec <shell_fprintf>
	PR("IPv4 recv      %d\tsent\t%d\tdrop\t%d\tforwarded\t%d\n",
40027974:	28040663          	beqz	s0,40027c00 <net_shell_print_statistics+0x368>
40027978:	03842683          	lw	a3,56(s0)
4002797c:	03c42703          	lw	a4,60(s0)
40027980:	04442783          	lw	a5,68(s0)
40027984:	04042803          	lw	a6,64(s0)
40027988:	40037637          	lui	a2,0x40037
4002798c:	8c460613          	addi	a2,a2,-1852 # 400368c4 <CSWTCH.15846+0x1264>
40027990:	00800593          	li	a1,8
40027994:	00048513          	mv	a0,s1
40027998:	d54e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("IP vhlerr      %d\thblener\t%d\tlblener\t%d\n",
4002799c:	28040063          	beqz	s0,40027c1c <net_shell_print_statistics+0x384>
400279a0:	01042683          	lw	a3,16(s0)
400279a4:	01442703          	lw	a4,20(s0)
400279a8:	01842783          	lw	a5,24(s0)
400279ac:	40037637          	lui	a2,0x40037
400279b0:	8f460613          	addi	a2,a2,-1804 # 400368f4 <CSWTCH.15846+0x1294>
400279b4:	00800593          	li	a1,8
400279b8:	00048513          	mv	a0,s1
400279bc:	d30e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("IP fragerr     %d\tchkerr\t%d\tprotoer\t%d\n",
400279c0:	26040a63          	beqz	s0,40027c34 <net_shell_print_statistics+0x39c>
400279c4:	01c42683          	lw	a3,28(s0)
400279c8:	02042703          	lw	a4,32(s0)
400279cc:	02442783          	lw	a5,36(s0)
400279d0:	40037637          	lui	a2,0x40037
400279d4:	92060613          	addi	a2,a2,-1760 # 40036920 <CSWTCH.15846+0x12c0>
400279d8:	00800593          	li	a1,8
400279dc:	00048513          	mv	a0,s1
400279e0:	d0ce10ef          	jal	ra,40008eec <shell_fprintf>
	PR("ICMP recv      %d\tsent\t%d\tdrop\t%d\n",
400279e4:	26040463          	beqz	s0,40027c4c <net_shell_print_statistics+0x3b4>
400279e8:	04842683          	lw	a3,72(s0)
400279ec:	04c42703          	lw	a4,76(s0)
400279f0:	05042783          	lw	a5,80(s0)
400279f4:	40037637          	lui	a2,0x40037
400279f8:	94860613          	addi	a2,a2,-1720 # 40036948 <CSWTCH.15846+0x12e8>
400279fc:	00800593          	li	a1,8
40027a00:	00048513          	mv	a0,s1
40027a04:	ce8e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("ICMP typeer    %d\tchkerr\t%d\n",
40027a08:	24040e63          	beqz	s0,40027c64 <net_shell_print_statistics+0x3cc>
40027a0c:	05442683          	lw	a3,84(s0)
40027a10:	05842703          	lw	a4,88(s0)
40027a14:	40037637          	lui	a2,0x40037
40027a18:	96c60613          	addi	a2,a2,-1684 # 4003696c <CSWTCH.15846+0x130c>
40027a1c:	00800593          	li	a1,8
40027a20:	00048513          	mv	a0,s1
40027a24:	cc8e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("UDP recv       %d\tsent\t%d\tdrop\t%d\n",
40027a28:	24040863          	beqz	s0,40027c78 <net_shell_print_statistics+0x3e0>
40027a2c:	09842683          	lw	a3,152(s0)
40027a30:	09c42703          	lw	a4,156(s0)
40027a34:	09442783          	lw	a5,148(s0)
40027a38:	40037637          	lui	a2,0x40037
40027a3c:	98c60613          	addi	a2,a2,-1652 # 4003698c <CSWTCH.15846+0x132c>
40027a40:	00800593          	li	a1,8
40027a44:	00048513          	mv	a0,s1
40027a48:	ca4e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("UDP chkerr     %d\n",
40027a4c:	40037637          	lui	a2,0x40037
40027a50:	24040063          	beqz	s0,40027c90 <net_shell_print_statistics+0x3f8>
40027a54:	0a042683          	lw	a3,160(s0)
40027a58:	9b060613          	addi	a2,a2,-1616 # 400369b0 <CSWTCH.15846+0x1350>
40027a5c:	00800593          	li	a1,8
40027a60:	00048513          	mv	a0,s1
40027a64:	c88e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("TCP bytes recv %u\tsent\t%d\tresent\t%d\n",
40027a68:	06042683          	lw	a3,96(s0)
40027a6c:	05c42703          	lw	a4,92(s0)
40027a70:	06442783          	lw	a5,100(s0)
40027a74:	40037637          	lui	a2,0x40037
40027a78:	9c460613          	addi	a2,a2,-1596 # 400369c4 <CSWTCH.15846+0x1364>
40027a7c:	00800593          	li	a1,8
40027a80:	00048513          	mv	a0,s1
40027a84:	c68e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("TCP seg recv   %d\tsent\t%d\tdrop\t%d\n",
40027a88:	22040a63          	beqz	s0,40027cbc <net_shell_print_statistics+0x424>
40027a8c:	06c42683          	lw	a3,108(s0)
40027a90:	07042703          	lw	a4,112(s0)
40027a94:	07442783          	lw	a5,116(s0)
40027a98:	40037637          	lui	a2,0x40037
40027a9c:	9ec60613          	addi	a2,a2,-1556 # 400369ec <CSWTCH.15846+0x138c>
40027aa0:	00800593          	li	a1,8
40027aa4:	00048513          	mv	a0,s1
40027aa8:	c44e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("TCP seg resent %d\tchkerr\t%d\tackerr\t%d\n",
40027aac:	22040463          	beqz	s0,40027cd4 <net_shell_print_statistics+0x43c>
40027ab0:	08842683          	lw	a3,136(s0)
40027ab4:	07842703          	lw	a4,120(s0)
40027ab8:	07c42783          	lw	a5,124(s0)
40027abc:	40037637          	lui	a2,0x40037
40027ac0:	a1060613          	addi	a2,a2,-1520 # 40036a10 <CSWTCH.15846+0x13b0>
40027ac4:	00800593          	li	a1,8
40027ac8:	00048513          	mv	a0,s1
40027acc:	c20e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("TCP seg rsterr %d\trst\t%d\n",
40027ad0:	20040e63          	beqz	s0,40027cec <net_shell_print_statistics+0x454>
40027ad4:	08042683          	lw	a3,128(s0)
40027ad8:	08442703          	lw	a4,132(s0)
40027adc:	40037637          	lui	a2,0x40037
40027ae0:	a3860613          	addi	a2,a2,-1480 # 40036a38 <CSWTCH.15846+0x13d8>
40027ae4:	00800593          	li	a1,8
40027ae8:	00048513          	mv	a0,s1
40027aec:	c00e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("TCP conn drop  %d\tconnrst\t%d\n",
40027af0:	20040863          	beqz	s0,40027d00 <net_shell_print_statistics+0x468>
40027af4:	08c42683          	lw	a3,140(s0)
40027af8:	09042703          	lw	a4,144(s0)
40027afc:	40037637          	lui	a2,0x40037
40027b00:	a5460613          	addi	a2,a2,-1452 # 40036a54 <CSWTCH.15846+0x13f4>
40027b04:	00800593          	li	a1,8
40027b08:	00048513          	mv	a0,s1
40027b0c:	be0e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("TCP pkt drop   %d\n", GET_STAT(iface, tcp.drop));
40027b10:	40037637          	lui	a2,0x40037
40027b14:	400379b7          	lui	s3,0x40037
40027b18:	40037937          	lui	s2,0x40037
40027b1c:	1e040c63          	beqz	s0,40027d14 <net_shell_print_statistics+0x47c>
40027b20:	06842683          	lw	a3,104(s0)
40027b24:	a7460613          	addi	a2,a2,-1420 # 40036a74 <CSWTCH.15846+0x1414>
40027b28:	00800593          	li	a1,8
40027b2c:	00048513          	mv	a0,s1
40027b30:	bbce10ef          	jal	ra,40008eec <shell_fprintf>
	PR("Bytes received %u\n", GET_STAT(iface, bytes.received));
40027b34:	00c42683          	lw	a3,12(s0)
40027b38:	a8898613          	addi	a2,s3,-1400 # 40036a88 <CSWTCH.15846+0x1428>
40027b3c:	00800593          	li	a1,8
40027b40:	00048513          	mv	a0,s1
40027b44:	ba8e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("Bytes sent     %u\n", GET_STAT(iface, bytes.sent));
40027b48:	00842683          	lw	a3,8(s0)
40027b4c:	a9c90613          	addi	a2,s2,-1380 # 40036a9c <CSWTCH.15846+0x143c>
40027b50:	00800593          	li	a1,8
40027b54:	00048513          	mv	a0,s1
40027b58:	b94e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("Processing err %d\n", GET_STAT(iface, processing_error));
40027b5c:	00442683          	lw	a3,4(s0)
}
40027b60:	03812403          	lw	s0,56(sp)
40027b64:	03c12083          	lw	ra,60(sp)
40027b68:	03012903          	lw	s2,48(sp)
40027b6c:	02c12983          	lw	s3,44(sp)
	PR("Processing err %d\n", GET_STAT(iface, processing_error));
40027b70:	00048513          	mv	a0,s1
}
40027b74:	03412483          	lw	s1,52(sp)
	PR("Processing err %d\n", GET_STAT(iface, processing_error));
40027b78:	40037637          	lui	a2,0x40037
40027b7c:	ab060613          	addi	a2,a2,-1360 # 40036ab0 <CSWTCH.15846+0x1450>
40027b80:	00800593          	li	a1,8
}
40027b84:	04010113          	addi	sp,sp,64
	PR("Processing err %d\n", GET_STAT(iface, processing_error));
40027b88:	b64e106f          	j	40008eec <shell_fprintf>
		PR("\nGlobal statistics\n");
40027b8c:	40037637          	lui	a2,0x40037
40027b90:	82460613          	addi	a2,a2,-2012 # 40036824 <CSWTCH.15846+0x11c4>
40027b94:	00800593          	li	a1,8
40027b98:	00048513          	mv	a0,s1
40027b9c:	b50e10ef          	jal	ra,40008eec <shell_fprintf>
		PR("=================\n");
40027ba0:	40037637          	lui	a2,0x40037
40027ba4:	83860613          	addi	a2,a2,-1992 # 40036838 <CSWTCH.15846+0x11d8>
40027ba8:	00800593          	li	a1,8
40027bac:	00048513          	mv	a0,s1
40027bb0:	b3ce10ef          	jal	ra,40008eec <shell_fprintf>
	PR("IPv6 recv      %d\tsent\t%d\tdrop\t%d\tforwarded\t%d\n",
40027bb4:	4003b637          	lui	a2,0x4003b
40027bb8:	ed060613          	addi	a2,a2,-304 # 4003aed0 <net_stats>
40027bbc:	02462683          	lw	a3,36(a2)
40027bc0:	02862703          	lw	a4,40(a2)
40027bc4:	03062783          	lw	a5,48(a2)
40027bc8:	02c62803          	lw	a6,44(a2)
40027bcc:	d4dff06f          	j	40027918 <net_shell_print_statistics+0x80>
	PR("IPv6 ND recv   %d\tsent\t%d\tdrop\t%d\n",
40027bd0:	4003b7b7          	lui	a5,0x4003b
40027bd4:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40027bd8:	0a47a683          	lw	a3,164(a5)
40027bdc:	0a87a703          	lw	a4,168(a5)
40027be0:	0a07a783          	lw	a5,160(a5)
40027be4:	d59ff06f          	j	4002793c <net_shell_print_statistics+0xa4>
	PR("IPv6 MLD recv  %d\tsent\t%d\tdrop\t%d\n",
40027be8:	4003b7b7          	lui	a5,0x4003b
40027bec:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40027bf0:	0ac7a683          	lw	a3,172(a5)
40027bf4:	0b07a703          	lw	a4,176(a5)
40027bf8:	0b47a783          	lw	a5,180(a5)
40027bfc:	d65ff06f          	j	40027960 <net_shell_print_statistics+0xc8>
	PR("IPv4 recv      %d\tsent\t%d\tdrop\t%d\tforwarded\t%d\n",
40027c00:	4003b637          	lui	a2,0x4003b
40027c04:	ed060613          	addi	a2,a2,-304 # 4003aed0 <net_stats>
40027c08:	03462683          	lw	a3,52(a2)
40027c0c:	03862703          	lw	a4,56(a2)
40027c10:	04062783          	lw	a5,64(a2)
40027c14:	03c62803          	lw	a6,60(a2)
40027c18:	d71ff06f          	j	40027988 <net_shell_print_statistics+0xf0>
	PR("IP vhlerr      %d\thblener\t%d\tlblener\t%d\n",
40027c1c:	4003b7b7          	lui	a5,0x4003b
40027c20:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40027c24:	00c7a683          	lw	a3,12(a5)
40027c28:	0107a703          	lw	a4,16(a5)
40027c2c:	0147a783          	lw	a5,20(a5)
40027c30:	d7dff06f          	j	400279ac <net_shell_print_statistics+0x114>
	PR("IP fragerr     %d\tchkerr\t%d\tprotoer\t%d\n",
40027c34:	4003b7b7          	lui	a5,0x4003b
40027c38:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40027c3c:	0187a683          	lw	a3,24(a5)
40027c40:	01c7a703          	lw	a4,28(a5)
40027c44:	0207a783          	lw	a5,32(a5)
40027c48:	d89ff06f          	j	400279d0 <net_shell_print_statistics+0x138>
	PR("ICMP recv      %d\tsent\t%d\tdrop\t%d\n",
40027c4c:	4003b7b7          	lui	a5,0x4003b
40027c50:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40027c54:	0447a683          	lw	a3,68(a5)
40027c58:	0487a703          	lw	a4,72(a5)
40027c5c:	04c7a783          	lw	a5,76(a5)
40027c60:	d95ff06f          	j	400279f4 <net_shell_print_statistics+0x15c>
	PR("ICMP typeer    %d\tchkerr\t%d\n",
40027c64:	4003b7b7          	lui	a5,0x4003b
40027c68:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40027c6c:	0507a683          	lw	a3,80(a5)
40027c70:	0547a703          	lw	a4,84(a5)
40027c74:	da1ff06f          	j	40027a14 <net_shell_print_statistics+0x17c>
	PR("UDP recv       %d\tsent\t%d\tdrop\t%d\n",
40027c78:	4003b7b7          	lui	a5,0x4003b
40027c7c:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40027c80:	0947a683          	lw	a3,148(a5)
40027c84:	0987a703          	lw	a4,152(a5)
40027c88:	0907a783          	lw	a5,144(a5)
40027c8c:	dadff06f          	j	40027a38 <net_shell_print_statistics+0x1a0>
	PR("UDP chkerr     %d\n",
40027c90:	4003b937          	lui	s2,0x4003b
40027c94:	ed090913          	addi	s2,s2,-304 # 4003aed0 <net_stats>
40027c98:	09c92683          	lw	a3,156(s2)
40027c9c:	9b060613          	addi	a2,a2,-1616
40027ca0:	00800593          	li	a1,8
40027ca4:	00048513          	mv	a0,s1
40027ca8:	a44e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("TCP bytes recv %u\tsent\t%d\tresent\t%d\n",
40027cac:	05c92683          	lw	a3,92(s2)
40027cb0:	05892703          	lw	a4,88(s2)
40027cb4:	06092783          	lw	a5,96(s2)
40027cb8:	dbdff06f          	j	40027a74 <net_shell_print_statistics+0x1dc>
	PR("TCP seg recv   %d\tsent\t%d\tdrop\t%d\n",
40027cbc:	4003b7b7          	lui	a5,0x4003b
40027cc0:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40027cc4:	0687a683          	lw	a3,104(a5)
40027cc8:	06c7a703          	lw	a4,108(a5)
40027ccc:	0707a783          	lw	a5,112(a5)
40027cd0:	dc9ff06f          	j	40027a98 <net_shell_print_statistics+0x200>
	PR("TCP seg resent %d\tchkerr\t%d\tackerr\t%d\n",
40027cd4:	4003b7b7          	lui	a5,0x4003b
40027cd8:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40027cdc:	0847a683          	lw	a3,132(a5)
40027ce0:	0747a703          	lw	a4,116(a5)
40027ce4:	0787a783          	lw	a5,120(a5)
40027ce8:	dd5ff06f          	j	40027abc <net_shell_print_statistics+0x224>
	PR("TCP seg rsterr %d\trst\t%d\n",
40027cec:	4003b7b7          	lui	a5,0x4003b
40027cf0:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40027cf4:	07c7a683          	lw	a3,124(a5)
40027cf8:	0807a703          	lw	a4,128(a5)
40027cfc:	de1ff06f          	j	40027adc <net_shell_print_statistics+0x244>
	PR("TCP conn drop  %d\tconnrst\t%d\n",
40027d00:	4003b7b7          	lui	a5,0x4003b
40027d04:	ed078793          	addi	a5,a5,-304 # 4003aed0 <net_stats>
40027d08:	0887a683          	lw	a3,136(a5)
40027d0c:	08c7a703          	lw	a4,140(a5)
40027d10:	dedff06f          	j	40027afc <net_shell_print_statistics+0x264>
	PR("TCP pkt drop   %d\n", GET_STAT(iface, tcp.drop));
40027d14:	4003b437          	lui	s0,0x4003b
40027d18:	ed040413          	addi	s0,s0,-304 # 4003aed0 <net_stats>
40027d1c:	06442683          	lw	a3,100(s0)
40027d20:	a7460613          	addi	a2,a2,-1420
40027d24:	00800593          	li	a1,8
40027d28:	00048513          	mv	a0,s1
40027d2c:	9c0e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("Bytes received %u\n", GET_STAT(iface, bytes.received));
40027d30:	00842683          	lw	a3,8(s0)
40027d34:	a8898613          	addi	a2,s3,-1400
40027d38:	00800593          	li	a1,8
40027d3c:	00048513          	mv	a0,s1
40027d40:	9ace10ef          	jal	ra,40008eec <shell_fprintf>
	PR("Bytes sent     %u\n", GET_STAT(iface, bytes.sent));
40027d44:	00442683          	lw	a3,4(s0)
40027d48:	a9c90613          	addi	a2,s2,-1380
40027d4c:	00800593          	li	a1,8
40027d50:	00048513          	mv	a0,s1
40027d54:	998e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("Processing err %d\n", GET_STAT(iface, processing_error));
40027d58:	00042683          	lw	a3,0(s0)
40027d5c:	e05ff06f          	j	40027b60 <net_shell_print_statistics+0x2c8>

40027d60 <cmd_net_stats_iface>:
{
40027d60:	fd010113          	addi	sp,sp,-48
40027d64:	02112623          	sw	ra,44(sp)
40027d68:	02812423          	sw	s0,40(sp)
40027d6c:	02912223          	sw	s1,36(sp)
	if (argv[1] == NULL) {
40027d70:	00462783          	lw	a5,4(a2)
40027d74:	02079663          	bnez	a5,40027da0 <cmd_net_stats_iface+0x40>
		PR_WARNING("Network interface index missing!\n");
40027d78:	40037637          	lui	a2,0x40037
40027d7c:	ac460613          	addi	a2,a2,-1340 # 40036ac4 <CSWTCH.15846+0x1464>
40027d80:	00300593          	li	a1,3
40027d84:	968e10ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40027d88:	ff800513          	li	a0,-8
}
40027d8c:	02c12083          	lw	ra,44(sp)
40027d90:	02812403          	lw	s0,40(sp)
40027d94:	02412483          	lw	s1,36(sp)
40027d98:	03010113          	addi	sp,sp,48
40027d9c:	00008067          	ret
40027da0:	00050413          	mv	s0,a0
40027da4:	00060493          	mv	s1,a2
	idx = strtol(argv[1], &endptr, 10);
40027da8:	00078513          	mv	a0,a5
40027dac:	00a00613          	li	a2,10
40027db0:	01410593          	addi	a1,sp,20
40027db4:	9d1e40ef          	jal	ra,4000c784 <strtol>
	if (*endptr != '\0') {
40027db8:	01412783          	lw	a5,20(sp)
40027dbc:	0007c783          	lbu	a5,0(a5)
40027dc0:	02078063          	beqz	a5,40027de0 <cmd_net_stats_iface+0x80>
		PR_WARNING("Invalid index %s\n", argv[1]);
40027dc4:	0044a683          	lw	a3,4(s1)
40027dc8:	40036637          	lui	a2,0x40036
40027dcc:	93060613          	addi	a2,a2,-1744 # 40035930 <CSWTCH.15846+0x2d0>
40027dd0:	00300593          	li	a1,3
40027dd4:	00040513          	mv	a0,s0
40027dd8:	914e10ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40027ddc:	fadff06f          	j	40027d88 <cmd_net_stats_iface+0x28>
40027de0:	00a12623          	sw	a0,12(sp)
	iface = net_if_get_by_index(idx);
40027de4:	900fd0ef          	jal	ra,40024ee4 <net_if_get_by_index>
	if (!iface) {
40027de8:	00c12683          	lw	a3,12(sp)
40027dec:	00051863          	bnez	a0,40027dfc <cmd_net_stats_iface+0x9c>
		PR_WARNING("No such interface in index %d\n", idx);
40027df0:	40036637          	lui	a2,0x40036
40027df4:	da060613          	addi	a2,a2,-608 # 40035da0 <CSWTCH.15846+0x740>
40027df8:	fd9ff06f          	j	40027dd0 <cmd_net_stats_iface+0x70>
	net_shell_print_statistics(iface, &data);
40027dfc:	01810593          	addi	a1,sp,24
	data.sh = sh;
40027e00:	00812c23          	sw	s0,24(sp)
	net_shell_print_statistics(iface, &data);
40027e04:	a95ff0ef          	jal	ra,40027898 <net_shell_print_statistics>
	return 0;
40027e08:	00000513          	li	a0,0
40027e0c:	f81ff06f          	j	40027d8c <cmd_net_stats_iface+0x2c>

40027e10 <cmd_net_stats>:
{
40027e10:	fd010113          	addi	sp,sp,-48
40027e14:	02812423          	sw	s0,40(sp)
40027e18:	02112623          	sw	ra,44(sp)
40027e1c:	02912223          	sw	s1,36(sp)
40027e20:	00050413          	mv	s0,a0
	if (!argv[1]) {
40027e24:	00462503          	lw	a0,4(a2)
40027e28:	02051863          	bnez	a0,40027e58 <cmd_net_stats+0x48>
	net_if_foreach(net_shell_print_statistics, data);
40027e2c:	40028537          	lui	a0,0x40028
40027e30:	01810593          	addi	a1,sp,24
40027e34:	89850513          	addi	a0,a0,-1896 # 40027898 <net_shell_print_statistics>
	user_data.sh = sh;
40027e38:	00812c23          	sw	s0,24(sp)
	net_if_foreach(net_shell_print_statistics, data);
40027e3c:	d69eb0ef          	jal	ra,40013ba4 <net_if_foreach>
}
40027e40:	02c12083          	lw	ra,44(sp)
40027e44:	02812403          	lw	s0,40(sp)
40027e48:	02412483          	lw	s1,36(sp)
40027e4c:	00000513          	li	a0,0
40027e50:	03010113          	addi	sp,sp,48
40027e54:	00008067          	ret
40027e58:	00058493          	mv	s1,a1
	if (strcmp(argv[1], "reset") == 0) {
40027e5c:	400345b7          	lui	a1,0x40034
40027e60:	2b058593          	addi	a1,a1,688 # 400342b0 <log_backend_shell_api+0x460>
40027e64:	00c12623          	sw	a2,12(sp)
40027e68:	db1e40ef          	jal	ra,4000cc18 <strcmp>
40027e6c:	00c12603          	lw	a2,12(sp)
40027e70:	00051663          	bnez	a0,40027e7c <cmd_net_stats+0x6c>
		net_stats_reset(NULL);
40027e74:	bb0f80ef          	jal	ra,40020224 <net_stats_reset>
40027e78:	fc9ff06f          	j	40027e40 <cmd_net_stats+0x30>
		cmd_net_stats_iface(sh, argc, argv);
40027e7c:	00048593          	mv	a1,s1
40027e80:	00040513          	mv	a0,s0
40027e84:	eddff0ef          	jal	ra,40027d60 <cmd_net_stats_iface>
40027e88:	fb9ff06f          	j	40027e40 <cmd_net_stats+0x30>

40027e8c <ip_address_lifetime_cb>:
{
40027e8c:	fd010113          	addi	sp,sp,-48
40027e90:	02112623          	sw	ra,44(sp)
40027e94:	03212023          	sw	s2,32(sp)
40027e98:	02812423          	sw	s0,40(sp)
40027e9c:	02912223          	sw	s1,36(sp)
	const struct shell *sh = data->sh;
40027ea0:	0005a483          	lw	s1,0(a1)
{
40027ea4:	00050913          	mv	s2,a0
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
40027ea8:	0c052403          	lw	s0,192(a0)
	PR("\nIPv4 addresses for interface %d (%p) (%s)\n",
40027eac:	cb5eb0ef          	jal	ra,40013b60 <net_if_get_by_iface>
40027eb0:	00a12223          	sw	a0,4(sp)
40027eb4:	01c10593          	addi	a1,sp,28
40027eb8:	00090513          	mv	a0,s2
40027ebc:	8b5ff0ef          	jal	ra,40027770 <iface2str>
40027ec0:	00412683          	lw	a3,4(sp)
40027ec4:	40037637          	lui	a2,0x40037
40027ec8:	00050793          	mv	a5,a0
40027ecc:	af860613          	addi	a2,a2,-1288 # 40036af8 <CSWTCH.15846+0x1498>
40027ed0:	00800593          	li	a1,8
40027ed4:	00048513          	mv	a0,s1
40027ed8:	00090713          	mv	a4,s2
40027edc:	810e10ef          	jal	ra,40008eec <shell_fprintf>
	PR("============================================%s\n", extra);
40027ee0:	01c12683          	lw	a3,28(sp)
40027ee4:	40037637          	lui	a2,0x40037
40027ee8:	b2460613          	addi	a2,a2,-1244 # 40036b24 <CSWTCH.15846+0x14c4>
40027eec:	00800593          	li	a1,8
40027ef0:	00048513          	mv	a0,s1
40027ef4:	ff9e00ef          	jal	ra,40008eec <shell_fprintf>
	if (!ipv4) {
40027ef8:	02041663          	bnez	s0,40027f24 <ip_address_lifetime_cb+0x98>
}
40027efc:	02812403          	lw	s0,40(sp)
40027f00:	02c12083          	lw	ra,44(sp)
40027f04:	02012903          	lw	s2,32(sp)
		PR("No IPv4 config found for this interface.\n");
40027f08:	00048513          	mv	a0,s1
}
40027f0c:	02412483          	lw	s1,36(sp)
		PR("No IPv4 config found for this interface.\n");
40027f10:	40037637          	lui	a2,0x40037
40027f14:	b5460613          	addi	a2,a2,-1196 # 40036b54 <CSWTCH.15846+0x14f4>
40027f18:	00800593          	li	a1,8
}
40027f1c:	03010113          	addi	sp,sp,48
		PR("No IPv4 config found for this interface.\n");
40027f20:	fcde006f          	j	40008eec <shell_fprintf>
	PR("Type      \tState    \tLifetime (sec)\tAddress\n");
40027f24:	40037637          	lui	a2,0x40037
40027f28:	b8060613          	addi	a2,a2,-1152 # 40036b80 <CSWTCH.15846+0x1520>
40027f2c:	00800593          	li	a1,8
40027f30:	00048513          	mv	a0,s1
40027f34:	fb9e00ef          	jal	ra,40008eec <shell_fprintf>
		if (!ipv4->unicast[i].is_used ||
40027f38:	02c42783          	lw	a5,44(s0)
40027f3c:	0197d793          	srli	a5,a5,0x19
40027f40:	0017f793          	andi	a5,a5,1
40027f44:	0a078063          	beqz	a5,40027fe4 <ip_address_lifetime_cb+0x158>
40027f48:	00045703          	lhu	a4,0(s0)
40027f4c:	00100793          	li	a5,1
40027f50:	08f71a63          	bne	a4,a5,40027fe4 <ip_address_lifetime_cb+0x158>
		PR("%s  \t%s    \t%12s/%12s\n",
40027f54:	02c44703          	lbu	a4,44(s0)
	switch (addr_type) {
40027f58:	00400793          	li	a5,4
40027f5c:	0ae7e063          	bltu	a5,a4,40027ffc <ip_address_lifetime_cb+0x170>
40027f60:	400387b7          	lui	a5,0x40038
40027f64:	00271713          	slli	a4,a4,0x2
40027f68:	37478793          	addi	a5,a5,884 # 40038374 <CSWTCH.236>
40027f6c:	00e787b3          	add	a5,a5,a4
40027f70:	0007a683          	lw	a3,0(a5)
	switch (addr_state) {
40027f74:	02d44783          	lbu	a5,45(s0)
40027f78:	00300713          	li	a4,3
40027f7c:	00178793          	addi	a5,a5,1
40027f80:	0ff7f793          	zext.b	a5,a5
40027f84:	08f76263          	bltu	a4,a5,40028008 <ip_address_lifetime_cb+0x17c>
40027f88:	40038737          	lui	a4,0x40038
40027f8c:	36470713          	addi	a4,a4,868 # 40038364 <CSWTCH.238>
40027f90:	00279793          	slli	a5,a5,0x2
40027f94:	00f707b3          	add	a5,a4,a5
40027f98:	0007a703          	lw	a4,0(a5)
		PR("%s  \t%s    \t%12s/%12s\n",
40027f9c:	00440593          	addi	a1,s0,4
40027fa0:	00100513          	li	a0,1
40027fa4:	00d12623          	sw	a3,12(sp)
40027fa8:	00e12423          	sw	a4,8(sp)
40027fac:	909ec0ef          	jal	ra,400148b4 <net_sprint_addr>
40027fb0:	00a12223          	sw	a0,4(sp)
40027fb4:	04c40593          	addi	a1,s0,76
40027fb8:	00100513          	li	a0,1
40027fbc:	8f9ec0ef          	jal	ra,400148b4 <net_sprint_addr>
40027fc0:	00412783          	lw	a5,4(sp)
40027fc4:	00812703          	lw	a4,8(sp)
40027fc8:	00c12683          	lw	a3,12(sp)
40027fcc:	40037637          	lui	a2,0x40037
40027fd0:	00050813          	mv	a6,a0
40027fd4:	bb060613          	addi	a2,a2,-1104 # 40036bb0 <CSWTCH.15846+0x1550>
40027fd8:	00800593          	li	a1,8
40027fdc:	00048513          	mv	a0,s1
40027fe0:	f0de00ef          	jal	ra,40008eec <shell_fprintf>
}
40027fe4:	02c12083          	lw	ra,44(sp)
40027fe8:	02812403          	lw	s0,40(sp)
40027fec:	02412483          	lw	s1,36(sp)
40027ff0:	02012903          	lw	s2,32(sp)
40027ff4:	03010113          	addi	sp,sp,48
40027ff8:	00008067          	ret
		PR("%s  \t%s    \t%12s/%12s\n",
40027ffc:	400376b7          	lui	a3,0x40037
40028000:	ae868693          	addi	a3,a3,-1304 # 40036ae8 <CSWTCH.15846+0x1488>
40028004:	f71ff06f          	j	40027f74 <ip_address_lifetime_cb+0xe8>
	switch (addr_state) {
40028008:	40035737          	lui	a4,0x40035
4002800c:	fd870713          	addi	a4,a4,-40 # 40034fd8 <all_nodes_mcast_group.0+0x3c>
40028010:	f8dff06f          	j	40027f9c <ip_address_lifetime_cb+0x110>

40028014 <iface_per_route_cb>:
{
40028014:	fd010113          	addi	sp,sp,-48
40028018:	02112623          	sw	ra,44(sp)
4002801c:	02812423          	sw	s0,40(sp)
40028020:	02912223          	sw	s1,36(sp)
40028024:	03212023          	sw	s2,32(sp)
	const struct shell *sh = data->sh;
40028028:	0005a903          	lw	s2,0(a1)
{
4002802c:	00050493          	mv	s1,a0
40028030:	00058413          	mv	s0,a1
	PR("\nIPv6 routes for interface %d (%p) (%s)\n",
40028034:	b2deb0ef          	jal	ra,40013b60 <net_if_get_by_iface>
40028038:	00a12623          	sw	a0,12(sp)
4002803c:	01c10593          	addi	a1,sp,28
40028040:	00048513          	mv	a0,s1
40028044:	f2cff0ef          	jal	ra,40027770 <iface2str>
40028048:	00c12683          	lw	a3,12(sp)
4002804c:	40037637          	lui	a2,0x40037
40028050:	00050793          	mv	a5,a0
40028054:	00048713          	mv	a4,s1
40028058:	00090513          	mv	a0,s2
4002805c:	bc860613          	addi	a2,a2,-1080 # 40036bc8 <CSWTCH.15846+0x1568>
40028060:	00800593          	li	a1,8
40028064:	e89e00ef          	jal	ra,40008eec <shell_fprintf>
	PR("=========================================%s\n", extra);
40028068:	01c12683          	lw	a3,28(sp)
4002806c:	40037637          	lui	a2,0x40037
40028070:	00090513          	mv	a0,s2
40028074:	00800593          	li	a1,8
40028078:	bf460613          	addi	a2,a2,-1036 # 40036bf4 <CSWTCH.15846+0x1594>
4002807c:	e71e00ef          	jal	ra,40008eec <shell_fprintf>
	data->user_data = iface;
40028080:	00942223          	sw	s1,4(s0)
	net_route_foreach(route_cb, data);
40028084:	00040593          	mv	a1,s0
}
40028088:	02812403          	lw	s0,40(sp)
4002808c:	02c12083          	lw	ra,44(sp)
40028090:	02412483          	lw	s1,36(sp)
40028094:	02012903          	lw	s2,32(sp)
	net_route_foreach(route_cb, data);
40028098:	40028537          	lui	a0,0x40028
4002809c:	61050513          	addi	a0,a0,1552 # 40028610 <route_cb>
}
400280a0:	03010113          	addi	sp,sp,48
	net_route_foreach(route_cb, data);
400280a4:	e61f706f          	j	4001ff04 <net_route_foreach>

400280a8 <parse_arg>:
{
400280a8:	fe010113          	addi	sp,sp,-32
400280ac:	00112e23          	sw	ra,28(sp)
400280b0:	00812c23          	sw	s0,24(sp)
400280b4:	00912a23          	sw	s1,20(sp)
	const char *str = argv[*i] + 2;
400280b8:	00052783          	lw	a5,0(a0)
400280bc:	00279713          	slli	a4,a5,0x2
400280c0:	00e60633          	add	a2,a2,a4
400280c4:	00062403          	lw	s0,0(a2)
	if (*str == 0) {
400280c8:	00244703          	lbu	a4,2(s0)
	const char *str = argv[*i] + 2;
400280cc:	00240413          	addi	s0,s0,2
	if (*str == 0) {
400280d0:	02071863          	bnez	a4,40028100 <parse_arg+0x58>
		if (*i + 1 >= argc) {
400280d4:	00178793          	addi	a5,a5,1
400280d8:	02b7e063          	bltu	a5,a1,400280f8 <parse_arg+0x50>
			return -1;
400280dc:	fff00493          	li	s1,-1
}
400280e0:	01c12083          	lw	ra,28(sp)
400280e4:	01812403          	lw	s0,24(sp)
400280e8:	00048513          	mv	a0,s1
400280ec:	01412483          	lw	s1,20(sp)
400280f0:	02010113          	addi	sp,sp,32
400280f4:	00008067          	ret
		*i += 1;
400280f8:	00f52023          	sw	a5,0(a0)
		str = argv[*i];
400280fc:	00462403          	lw	s0,4(a2)
40028100:	294060ef          	jal	ra,4002e394 <z_impl_z_errno>
	if (strncmp(str, "0x", 2) == 0) {
40028104:	400375b7          	lui	a1,0x40037
	errno = 0;
40028108:	00052023          	sw	zero,0(a0)
	if (strncmp(str, "0x", 2) == 0) {
4002810c:	00200613          	li	a2,2
40028110:	c2458593          	addi	a1,a1,-988 # 40036c24 <CSWTCH.15846+0x15c4>
40028114:	00040513          	mv	a0,s0
40028118:	b25e40ef          	jal	ra,4000cc3c <strncmp>
		res = strtol(str, &endptr, 16);
4002811c:	01000613          	li	a2,16
	if (strncmp(str, "0x", 2) == 0) {
40028120:	00050463          	beqz	a0,40028128 <parse_arg+0x80>
		res = strtol(str, &endptr, 10);
40028124:	00a00613          	li	a2,10
40028128:	00c10593          	addi	a1,sp,12
4002812c:	00040513          	mv	a0,s0
40028130:	e54e40ef          	jal	ra,4000c784 <strtol>
40028134:	00050493          	mv	s1,a0
40028138:	25c060ef          	jal	ra,4002e394 <z_impl_z_errno>
	if (errno || (endptr == str)) {
4002813c:	00052783          	lw	a5,0(a0)
40028140:	f8079ee3          	bnez	a5,400280dc <parse_arg+0x34>
40028144:	00c12783          	lw	a5,12(sp)
40028148:	f8879ce3          	bne	a5,s0,400280e0 <parse_arg+0x38>
4002814c:	f91ff06f          	j	400280dc <parse_arg+0x34>

40028150 <cmd_net_ping>:
{
40028150:	fa010113          	addi	sp,sp,-96
40028154:	04812c23          	sw	s0,88(sp)
40028158:	04912a23          	sw	s1,84(sp)
4002815c:	05212823          	sw	s2,80(sp)
40028160:	05312623          	sw	s3,76(sp)
40028164:	05412423          	sw	s4,72(sp)
40028168:	05512223          	sw	s5,68(sp)
4002816c:	05612023          	sw	s6,64(sp)
40028170:	03712e23          	sw	s7,60(sp)
40028174:	03812c23          	sw	s8,56(sp)
40028178:	03912a23          	sw	s9,52(sp)
4002817c:	03a12823          	sw	s10,48(sp)
40028180:	03b12623          	sw	s11,44(sp)
40028184:	04112e23          	sw	ra,92(sp)
40028188:	00a12423          	sw	a0,8(sp)
4002818c:	00b12623          	sw	a1,12(sp)
40028190:	00060413          	mv	s0,a2
	for (size_t i = 1; i < argc; ++i) {
40028194:	00100793          	li	a5,1
	int payload_size = 4;
40028198:	00400993          	li	s3,4
	int tos = 0;
4002819c:	00000a13          	li	s4,0
	int iface_idx = -1;
400281a0:	fff00913          	li	s2,-1
	int interval = 1000;
400281a4:	3e800a93          	li	s5,1000
	int count = 3;
400281a8:	00300b13          	li	s6,3
	char *host = NULL;
400281ac:	00000493          	li	s1,0
		switch (argv[i][1]) {
400281b0:	06300b93          	li	s7,99
400281b4:	06900c13          	li	s8,105
400281b8:	07300c93          	li	s9,115
400281bc:	04900d13          	li	s10,73
400281c0:	05100d93          	li	s11,81
	for (size_t i = 1; i < argc; ++i) {
400281c4:	00c12703          	lw	a4,12(sp)
400281c8:	00f12e23          	sw	a5,28(sp)
400281cc:	02e7e063          	bltu	a5,a4,400281ec <cmd_net_ping+0x9c>
	if (!host) {
400281d0:	16049463          	bnez	s1,40028338 <cmd_net_ping+0x1e8>
		PR_WARNING("Target host missing\n");
400281d4:	00812503          	lw	a0,8(sp)
400281d8:	40037637          	lui	a2,0x40037
400281dc:	c5860613          	addi	a2,a2,-936 # 40036c58 <CSWTCH.15846+0x15f8>
400281e0:	00300593          	li	a1,3
400281e4:	d09e00ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
400281e8:	0a00006f          	j	40028288 <cmd_net_ping+0x138>
		if (*argv[i] != '-') {
400281ec:	00279793          	slli	a5,a5,0x2
400281f0:	00f407b3          	add	a5,s0,a5
400281f4:	0007a683          	lw	a3,0(a5)
400281f8:	02d00713          	li	a4,45
400281fc:	0006c783          	lbu	a5,0(a3)
40028200:	12e79863          	bne	a5,a4,40028330 <cmd_net_ping+0x1e0>
		switch (argv[i][1]) {
40028204:	0016c783          	lbu	a5,1(a3)
40028208:	05778263          	beq	a5,s7,4002824c <cmd_net_ping+0xfc>
4002820c:	00fbec63          	bltu	s7,a5,40028224 <cmd_net_ping+0xd4>
40028210:	0da78e63          	beq	a5,s10,400282ec <cmd_net_ping+0x19c>
40028214:	0fb78e63          	beq	a5,s11,40028310 <cmd_net_ping+0x1c0>
			PR_WARNING("Unrecognized argument: %s\n", argv[i]);
40028218:	40037637          	lui	a2,0x40037
4002821c:	c3c60613          	addi	a2,a2,-964 # 40036c3c <CSWTCH.15846+0x15dc>
40028220:	05c0006f          	j	4002827c <cmd_net_ping+0x12c>
		switch (argv[i][1]) {
40028224:	0b878263          	beq	a5,s8,400282c8 <cmd_net_ping+0x178>
40028228:	ff9798e3          	bne	a5,s9,40028218 <cmd_net_ping+0xc8>
			payload_size = parse_arg(&i, argc, argv);
4002822c:	00c12583          	lw	a1,12(sp)
40028230:	00040613          	mv	a2,s0
40028234:	01c10513          	addi	a0,sp,28
40028238:	e71ff0ef          	jal	ra,400280a8 <parse_arg>
			if (payload_size < 0 || payload_size > UINT16_MAX) {
4002823c:	000107b7          	lui	a5,0x10
			payload_size = parse_arg(&i, argc, argv);
40028240:	00050993          	mv	s3,a0
			if (payload_size < 0 || payload_size > UINT16_MAX) {
40028244:	08f56e63          	bltu	a0,a5,400282e0 <cmd_net_ping+0x190>
40028248:	01c0006f          	j	40028264 <cmd_net_ping+0x114>
			count = parse_arg(&i, argc, argv);
4002824c:	00c12583          	lw	a1,12(sp)
40028250:	00040613          	mv	a2,s0
40028254:	01c10513          	addi	a0,sp,28
40028258:	e51ff0ef          	jal	ra,400280a8 <parse_arg>
4002825c:	00050b13          	mv	s6,a0
			if (count < 0) {
40028260:	08055063          	bgez	a0,400282e0 <cmd_net_ping+0x190>
				PR_WARNING("Parse error: %s\n", argv[i]);
40028264:	01c12783          	lw	a5,28(sp)
40028268:	40037637          	lui	a2,0x40037
4002826c:	c2860613          	addi	a2,a2,-984 # 40036c28 <CSWTCH.15846+0x15c8>
40028270:	00279793          	slli	a5,a5,0x2
40028274:	00f407b3          	add	a5,s0,a5
40028278:	0007a683          	lw	a3,0(a5) # 10000 <__kernel_ram_size+0x44f8>
			PR_WARNING("Unrecognized argument: %s\n", argv[i]);
4002827c:	00812503          	lw	a0,8(sp)
40028280:	00300593          	li	a1,3
40028284:	c69e00ef          	jal	ra,40008eec <shell_fprintf>
	char *host = NULL;
40028288:	ff800513          	li	a0,-8
}
4002828c:	05c12083          	lw	ra,92(sp)
40028290:	05812403          	lw	s0,88(sp)
40028294:	05412483          	lw	s1,84(sp)
40028298:	05012903          	lw	s2,80(sp)
4002829c:	04c12983          	lw	s3,76(sp)
400282a0:	04812a03          	lw	s4,72(sp)
400282a4:	04412a83          	lw	s5,68(sp)
400282a8:	04012b03          	lw	s6,64(sp)
400282ac:	03c12b83          	lw	s7,60(sp)
400282b0:	03812c03          	lw	s8,56(sp)
400282b4:	03412c83          	lw	s9,52(sp)
400282b8:	03012d03          	lw	s10,48(sp)
400282bc:	02c12d83          	lw	s11,44(sp)
400282c0:	06010113          	addi	sp,sp,96
400282c4:	00008067          	ret
			interval = parse_arg(&i, argc, argv);
400282c8:	00c12583          	lw	a1,12(sp)
400282cc:	00040613          	mv	a2,s0
400282d0:	01c10513          	addi	a0,sp,28
400282d4:	dd5ff0ef          	jal	ra,400280a8 <parse_arg>
400282d8:	00050a93          	mv	s5,a0
			if (interval < 0) {
400282dc:	f80544e3          	bltz	a0,40028264 <cmd_net_ping+0x114>
	for (size_t i = 1; i < argc; ++i) {
400282e0:	01c12783          	lw	a5,28(sp)
400282e4:	00178793          	addi	a5,a5,1
400282e8:	eddff06f          	j	400281c4 <cmd_net_ping+0x74>
			iface_idx = parse_arg(&i, argc, argv);
400282ec:	00c12583          	lw	a1,12(sp)
400282f0:	00040613          	mv	a2,s0
400282f4:	01c10513          	addi	a0,sp,28
400282f8:	db1ff0ef          	jal	ra,400280a8 <parse_arg>
400282fc:	00050913          	mv	s2,a0
			if (iface_idx < 0 || !net_if_get_by_index(iface_idx)) {
40028300:	f60542e3          	bltz	a0,40028264 <cmd_net_ping+0x114>
40028304:	be1fc0ef          	jal	ra,40024ee4 <net_if_get_by_index>
40028308:	fc051ce3          	bnez	a0,400282e0 <cmd_net_ping+0x190>
4002830c:	f59ff06f          	j	40028264 <cmd_net_ping+0x114>
			tos = parse_arg(&i, argc, argv);
40028310:	00c12583          	lw	a1,12(sp)
40028314:	00040613          	mv	a2,s0
40028318:	01c10513          	addi	a0,sp,28
4002831c:	d8dff0ef          	jal	ra,400280a8 <parse_arg>
			if (tos < 0 || tos > UINT8_MAX) {
40028320:	0ff00793          	li	a5,255
			tos = parse_arg(&i, argc, argv);
40028324:	00050a13          	mv	s4,a0
			if (tos < 0 || tos > UINT8_MAX) {
40028328:	faa7fce3          	bgeu	a5,a0,400282e0 <cmd_net_ping+0x190>
4002832c:	f39ff06f          	j	40028264 <cmd_net_ping+0x114>
		if (*argv[i] != '-') {
40028330:	00068493          	mv	s1,a3
40028334:	fadff06f          	j	400282e0 <cmd_net_ping+0x190>
	memset(&ping_ctx, 0, sizeof(ping_ctx));
40028338:	4003abb7          	lui	s7,0x4003a
4002833c:	06000613          	li	a2,96
40028340:	00000593          	li	a1,0
40028344:	d58b8513          	addi	a0,s7,-680 # 40039d58 <ping_ctx>
40028348:	9d5e40ef          	jal	ra,4000cd1c <memset>
	k_work_init_delayable(&ping_ctx.work, ping_work);
4002834c:	400285b7          	lui	a1,0x40028
40028350:	4d058593          	addi	a1,a1,1232 # 400284d0 <ping_work>
40028354:	d58b8513          	addi	a0,s7,-680
40028358:	4ad070ef          	jal	ra,40030004 <k_work_init_delayable>
	ping_ctx.sh = sh;
4002835c:	d58b8793          	addi	a5,s7,-680
40028360:	00812703          	lw	a4,8(sp)
	ping_ctx.payload_size = payload_size;
40028364:	05379c23          	sh	s3,88(a5)
	    net_addr_pton(AF_INET6, host, &ping_ctx.addr.in6_addr) == 0) {
40028368:	4003a9b7          	lui	s3,0x4003a
4002836c:	d8c98613          	addi	a2,s3,-628 # 40039d8c <ping_ctx+0x34>
40028370:	00048593          	mv	a1,s1
40028374:	00200513          	li	a0,2
	ping_ctx.tos = tos;
40028378:	05478d23          	sb	s4,90(a5)
	ping_ctx.sh = sh;
4002837c:	04e7a423          	sw	a4,72(a5)
	ping_ctx.count = count;
40028380:	0567a623          	sw	s6,76(a5)
	ping_ctx.interval = interval;
40028384:	0557a823          	sw	s5,80(a5)
	    net_addr_pton(AF_INET6, host, &ping_ctx.addr.in6_addr) == 0) {
40028388:	9a0fd0ef          	jal	ra,40025528 <net_addr_pton>
4002838c:	d58b8a13          	addi	s4,s7,-680
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40028390:	04051863          	bnez	a0,400283e0 <cmd_net_ping+0x290>
		net_icmpv6_register_handler(&ping6_handler);
40028394:	40044537          	lui	a0,0x40044
		ping_ctx.addr.family = AF_INET6;
40028398:	00200793          	li	a5,2
		net_icmpv6_register_handler(&ping6_handler);
4002839c:	67c50513          	addi	a0,a0,1660 # 4004467c <ping6_handler>
		ping_ctx.addr.family = AF_INET6;
400283a0:	02fa1823          	sh	a5,48(s4)
		net_icmpv6_register_handler(&ping6_handler);
400283a4:	da4f20ef          	jal	ra,4001a948 <net_icmpv6_register_handler>
	struct net_if *iface = net_if_get_by_index(id);
400283a8:	00090513          	mv	a0,s2
400283ac:	b39fc0ef          	jal	ra,40024ee4 <net_if_get_by_index>
400283b0:	00050793          	mv	a5,a0
	if (iface != NULL) {
400283b4:	08051e63          	bnez	a0,40028450 <cmd_net_ping+0x300>
	if (IS_ENABLED(CONFIG_NET_IPV4) && target->family == AF_INET) {
400283b8:	030a5703          	lhu	a4,48(s4)
400283bc:	00100693          	li	a3,1
400283c0:	06d71463          	bne	a4,a3,40028428 <cmd_net_ping+0x2d8>
		iface = net_if_ipv4_select_src_iface(&target->in_addr);
400283c4:	d8c98513          	addi	a0,s3,-628
400283c8:	d3dea0ef          	jal	ra,40013104 <net_if_ipv4_select_src_iface>
400283cc:	00050793          	mv	a5,a0
		if (iface != NULL) {
400283d0:	08051063          	bnez	a0,40028450 <cmd_net_ping+0x300>
		iface = net_if_get_default();
400283d4:	97de80ef          	jal	ra,40010d50 <net_if_get_default>
400283d8:	00050793          	mv	a5,a0
400283dc:	0740006f          	j	40028450 <cmd_net_ping+0x300>
		   net_addr_pton(AF_INET, host, &ping_ctx.addr.in_addr) == 0) {
400283e0:	d8c98613          	addi	a2,s3,-628
400283e4:	00048593          	mv	a1,s1
400283e8:	00100513          	li	a0,1
400283ec:	93cfd0ef          	jal	ra,40025528 <net_addr_pton>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
400283f0:	00051e63          	bnez	a0,4002840c <cmd_net_ping+0x2bc>
		net_icmpv4_register_handler(&ping4_handler);
400283f4:	40044537          	lui	a0,0x40044
		ping_ctx.addr.family = AF_INET;
400283f8:	00100793          	li	a5,1
		net_icmpv4_register_handler(&ping4_handler);
400283fc:	67050513          	addi	a0,a0,1648 # 40044670 <ping4_handler>
		ping_ctx.addr.family = AF_INET;
40028400:	02fa1823          	sh	a5,48(s4)
		net_icmpv4_register_handler(&ping4_handler);
40028404:	cb9f10ef          	jal	ra,4001a0bc <net_icmpv4_register_handler>
40028408:	fa1ff06f          	j	400283a8 <cmd_net_ping+0x258>
		PR_WARNING("Invalid IP address\n");
4002840c:	00812503          	lw	a0,8(sp)
40028410:	40037637          	lui	a2,0x40037
40028414:	c7060613          	addi	a2,a2,-912 # 40036c70 <CSWTCH.15846+0x1610>
40028418:	00300593          	li	a1,3
4002841c:	ad1e00ef          	jal	ra,40008eec <shell_fprintf>
		return 0;
40028420:	00000513          	li	a0,0
40028424:	e69ff06f          	j	4002828c <cmd_net_ping+0x13c>
	if (IS_ENABLED(CONFIG_NET_IPV6) && target->family == AF_INET6) {
40028428:	00200693          	li	a3,2
4002842c:	02d71263          	bne	a4,a3,40028450 <cmd_net_ping+0x300>
		iface = net_if_ipv6_select_src_iface(&target->in6_addr);
40028430:	d8c98513          	addi	a0,s3,-628
40028434:	979ea0ef          	jal	ra,40012dac <net_if_ipv6_select_src_iface>
40028438:	00050793          	mv	a5,a0
		if (iface != NULL) {
4002843c:	00051a63          	bnez	a0,40028450 <cmd_net_ping+0x300>
		nbr = net_ipv6_nbr_lookup(NULL, &target->in6_addr);
40028440:	d8c98593          	addi	a1,s3,-628
40028444:	e5cf40ef          	jal	ra,4001caa0 <net_ipv6_nbr_lookup>
		if (nbr) {
40028448:	04050463          	beqz	a0,40028490 <cmd_net_ping+0x340>
			iface = nbr->iface;
4002844c:	00852783          	lw	a5,8(a0)
	PR("PING %s\n", host);
40028450:	00812503          	lw	a0,8(sp)
40028454:	40037637          	lui	a2,0x40037
40028458:	00048693          	mv	a3,s1
4002845c:	c8460613          	addi	a2,a2,-892 # 40036c84 <CSWTCH.15846+0x1624>
40028460:	00800593          	li	a1,8
	ping_ctx.iface = ping_select_iface(iface_idx, &ping_ctx.addr);
40028464:	04fa2223          	sw	a5,68(s4)
	PR("PING %s\n", host);
40028468:	a85e00ef          	jal	ra,40008eec <shell_fprintf>
	shell_set_bypass(sh, ping_bypass);
4002846c:	00812503          	lw	a0,8(sp)
40028470:	400275b7          	lui	a1,0x40027
40028474:	b2058593          	addi	a1,a1,-1248 # 40026b20 <ping_bypass>
40028478:	db5e00ef          	jal	ra,4000922c <shell_set_bypass>
	k_work_reschedule(&ping_ctx.work, K_NO_WAIT);
4002847c:	00000593          	li	a1,0
40028480:	00000613          	li	a2,0
40028484:	d58b8513          	addi	a0,s7,-680
40028488:	4cd070ef          	jal	ra,40030154 <k_work_reschedule>
	return 0;
4002848c:	f95ff06f          	j	40028420 <cmd_net_ping+0x2d0>
		route = net_route_lookup(NULL, &target->in6_addr);
40028490:	d8c98593          	addi	a1,s3,-628
40028494:	9ccf70ef          	jal	ra,4001f660 <net_route_lookup>
		if (route) {
40028498:	f2050ee3          	beqz	a0,400283d4 <cmd_net_ping+0x284>
			iface = route->iface;
4002849c:	00c52783          	lw	a5,12(a0)
			goto out;
400284a0:	fb1ff06f          	j	40028450 <cmd_net_ping+0x300>

400284a4 <cmd_net_stats_all>:
{
400284a4:	fe010113          	addi	sp,sp,-32
	user_data.sh = sh;
400284a8:	00a12423          	sw	a0,8(sp)
	net_if_foreach(net_shell_print_statistics, data);
400284ac:	40028537          	lui	a0,0x40028
400284b0:	00810593          	addi	a1,sp,8
400284b4:	89850513          	addi	a0,a0,-1896 # 40027898 <net_shell_print_statistics>
{
400284b8:	00112e23          	sw	ra,28(sp)
	net_if_foreach(net_shell_print_statistics, data);
400284bc:	ee8eb0ef          	jal	ra,40013ba4 <net_if_foreach>
}
400284c0:	01c12083          	lw	ra,28(sp)
400284c4:	00000513          	li	a0,0
400284c8:	02010113          	addi	sp,sp,32
400284cc:	00008067          	ret

400284d0 <ping_work>:
{
400284d0:	fe010113          	addi	sp,sp,-32
400284d4:	00812c23          	sw	s0,24(sp)
400284d8:	00112e23          	sw	ra,28(sp)
400284dc:	00912a23          	sw	s1,20(sp)
400284e0:	01212823          	sw	s2,16(sp)
	ctx->sequence++;
400284e4:	05452783          	lw	a5,84(a0)
	if (ctx->sequence > ctx->count) {
400284e8:	04c52703          	lw	a4,76(a0)
	const struct shell *sh = ctx->sh;
400284ec:	04852483          	lw	s1,72(a0)
	ctx->sequence++;
400284f0:	00178793          	addi	a5,a5,1
400284f4:	04f52a23          	sw	a5,84(a0)
{
400284f8:	00050413          	mv	s0,a0
	if (ctx->sequence > ctx->count) {
400284fc:	02f77a63          	bgeu	a4,a5,40028530 <ping_work+0x60>
		PR_INFO("Ping timeout\n");
40028500:	40037637          	lui	a2,0x40037
40028504:	c9060613          	addi	a2,a2,-880 # 40036c90 <CSWTCH.15846+0x1630>
40028508:	00200593          	li	a1,2
4002850c:	00048513          	mv	a0,s1
40028510:	9dde00ef          	jal	ra,40008eec <shell_fprintf>
		ping_done(ctx);
40028514:	00040513          	mv	a0,s0
}
40028518:	01812403          	lw	s0,24(sp)
4002851c:	01c12083          	lw	ra,28(sp)
40028520:	01412483          	lw	s1,20(sp)
40028524:	01012903          	lw	s2,16(sp)
40028528:	02010113          	addi	sp,sp,32
		ping_done(ctx);
4002852c:	8e1fd06f          	j	40025e0c <ping_done>
	if (ctx->addr.family == AF_INET6) {
40028530:	03055703          	lhu	a4,48(a0)
		ret = net_icmpv6_send_echo_request(ctx->iface,
40028534:	03450593          	addi	a1,a0,52
	if (ctx->addr.family == AF_INET6) {
40028538:	00200793          	li	a5,2
4002853c:	00b12623          	sw	a1,12(sp)
		ret = net_icmpv6_send_echo_request(ctx->iface,
40028540:	04452903          	lw	s2,68(a0)
	if (ctx->addr.family == AF_INET6) {
40028544:	04f71663          	bne	a4,a5,40028590 <ping_work+0xc0>
40028548:	cd9e40ef          	jal	ra,4000d220 <z_impl_sys_rand32_get>
		ret = net_icmpv6_send_echo_request(ctx->iface,
4002854c:	05845803          	lhu	a6,88(s0)
40028550:	05a44703          	lbu	a4,90(s0)
40028554:	05445683          	lhu	a3,84(s0)
40028558:	00c12583          	lw	a1,12(sp)
4002855c:	01051613          	slli	a2,a0,0x10
40028560:	00000793          	li	a5,0
40028564:	01065613          	srli	a2,a2,0x10
40028568:	00090513          	mv	a0,s2
4002856c:	9c9f20ef          	jal	ra,4001af34 <net_icmpv6_send_echo_request>
		ret = net_icmpv4_send_echo_request(ctx->iface,
40028570:	00050693          	mv	a3,a0
	if (ret != 0) {
40028574:	04050463          	beqz	a0,400285bc <ping_work+0xec>
		PR_WARNING("Failed to send ping, err: %d", ret);
40028578:	40037637          	lui	a2,0x40037
4002857c:	ca060613          	addi	a2,a2,-864 # 40036ca0 <CSWTCH.15846+0x1640>
40028580:	00300593          	li	a1,3
40028584:	00048513          	mv	a0,s1
40028588:	965e00ef          	jal	ra,40008eec <shell_fprintf>
4002858c:	f89ff06f          	j	40028514 <ping_work+0x44>
40028590:	c91e40ef          	jal	ra,4000d220 <z_impl_sys_rand32_get>
		ret = net_icmpv4_send_echo_request(ctx->iface,
40028594:	05845803          	lhu	a6,88(s0)
40028598:	05a44703          	lbu	a4,90(s0)
4002859c:	05445683          	lhu	a3,84(s0)
400285a0:	00c12583          	lw	a1,12(sp)
400285a4:	01051613          	slli	a2,a0,0x10
400285a8:	00000793          	li	a5,0
400285ac:	01065613          	srli	a2,a2,0x10
400285b0:	00090513          	mv	a0,s2
400285b4:	eccf10ef          	jal	ra,40019c80 <net_icmpv4_send_echo_request>
400285b8:	fb9ff06f          	j	40028570 <ping_work+0xa0>
	if (ctx->sequence < ctx->count) {
400285bc:	05442703          	lw	a4,84(s0)
400285c0:	04c42783          	lw	a5,76(s0)
400285c4:	04f77063          	bgeu	a4,a5,40028604 <ping_work+0x134>
		k_work_reschedule(&ctx->work, K_MSEC(ctx->interval));
400285c8:	05042583          	lw	a1,80(s0)
			return t / ((uint64_t)from_hz / to_hz);
400285cc:	00a00613          	li	a2,10
400285d0:	00000693          	li	a3,0
		t += off;
400285d4:	00958513          	addi	a0,a1,9
			return t / ((uint64_t)from_hz / to_hz);
400285d8:	00b535b3          	sltu	a1,a0,a1
400285dc:	cddd70ef          	jal	ra,400002b8 <__udivdi3>
400285e0:	00058613          	mv	a2,a1
400285e4:	00050593          	mv	a1,a0
		k_work_reschedule(&ctx->work, K_SECONDS(2));
400285e8:	00040513          	mv	a0,s0
}
400285ec:	01812403          	lw	s0,24(sp)
400285f0:	01c12083          	lw	ra,28(sp)
400285f4:	01412483          	lw	s1,20(sp)
400285f8:	01012903          	lw	s2,16(sp)
400285fc:	02010113          	addi	sp,sp,32
		k_work_reschedule(&ctx->work, K_SECONDS(2));
40028600:	3550706f          	j	40030154 <k_work_reschedule>
40028604:	0c800593          	li	a1,200
40028608:	00000613          	li	a2,0
4002860c:	fddff06f          	j	400285e8 <ping_work+0x118>

40028610 <route_cb>:
{
40028610:	fb010113          	addi	sp,sp,-80
40028614:	04812423          	sw	s0,72(sp)
40028618:	04112623          	sw	ra,76(sp)
4002861c:	04912223          	sw	s1,68(sp)
40028620:	05212023          	sw	s2,64(sp)
40028624:	03312e23          	sw	s3,60(sp)
40028628:	03412c23          	sw	s4,56(sp)
4002862c:	03512a23          	sw	s5,52(sp)
40028630:	03612823          	sw	s6,48(sp)
40028634:	03712623          	sw	s7,44(sp)
40028638:	03812423          	sw	s8,40(sp)
4002863c:	03912223          	sw	s9,36(sp)
40028640:	03a12023          	sw	s10,32(sp)
40028644:	01b12e23          	sw	s11,28(sp)
	const struct shell *sh = data->sh;
40028648:	0005a483          	lw	s1,0(a1)
	struct net_if *iface = data->user_data;
4002864c:	0045a903          	lw	s2,4(a1)
{
40028650:	00050413          	mv	s0,a0
	return z_impl_k_uptime_ticks();
40028654:	000090ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
	if (entry->iface != iface) {
40028658:	00c42783          	lw	a5,12(s0)
4002865c:	17279a63          	bne	a5,s2,400287d0 <route_cb+0x1c0>
			return t * ((uint64_t)to_hz / from_hz);
40028660:	00a00a13          	li	s4,10
	PR("IPv6 prefix : %s/%d\n", net_sprint_ipv6_addr(&entry->addr),
40028664:	02040593          	addi	a1,s0,32
40028668:	02aa0a33          	mul	s4,s4,a0
4002866c:	00200513          	li	a0,2
40028670:	a44ec0ef          	jal	ra,400148b4 <net_sprint_addr>
40028674:	03044703          	lbu	a4,48(s0)
40028678:	40037637          	lui	a2,0x40037
4002867c:	00050693          	mv	a3,a0
40028680:	cc060613          	addi	a2,a2,-832 # 40036cc0 <CSWTCH.15846+0x1660>
40028684:	00800593          	li	a1,8
40028688:	00048513          	mv	a0,s1
4002868c:	861e00ef          	jal	ra,40008eec <shell_fprintf>
	return list->head;
40028690:	00442903          	lw	s2,4(s0)
40028694:	00000993          	li	s3,0
		PR("\tneighbor : %p\t", nexthop_route->nbr);
40028698:	40037ab7          	lui	s5,0x40037
		PR("lifetime : %s\n", remaining_str);
4002869c:	40037b37          	lui	s6,0x40037
			snprintk(remaining_str, sizeof(remaining_str) - 1,
400286a0:	40037bb7          	lui	s7,0x40037
			snprintk(remaining_str, sizeof(remaining_str) - 1,
400286a4:	40037c37          	lui	s8,0x40037
	return net_sprint_ll_addr_buf(ll, ll_len, (char *)buf, sizeof(buf));
400286a8:	4003bcb7          	lui	s9,0x4003b
			PR("addr : %s\t", net_sprint_ll_addr(lladdr->addr,
400286ac:	40037d37          	lui	s10,0x40037
			PR("addr : <unknown>\t");
400286b0:	40037db7          	lui	s11,0x40037
	SYS_SLIST_FOR_EACH_CONTAINER(&entry->nexthop, nexthop_route, node) {
400286b4:	04091a63          	bnez	s2,40028708 <route_cb+0xf8>
	if (count == 0) {
400286b8:	10099c63          	bnez	s3,400287d0 <route_cb+0x1c0>
}
400286bc:	04812403          	lw	s0,72(sp)
400286c0:	04c12083          	lw	ra,76(sp)
400286c4:	04012903          	lw	s2,64(sp)
400286c8:	03c12983          	lw	s3,60(sp)
400286cc:	03812a03          	lw	s4,56(sp)
400286d0:	03412a83          	lw	s5,52(sp)
400286d4:	03012b03          	lw	s6,48(sp)
400286d8:	02c12b83          	lw	s7,44(sp)
400286dc:	02812c03          	lw	s8,40(sp)
400286e0:	02412c83          	lw	s9,36(sp)
400286e4:	02012d03          	lw	s10,32(sp)
400286e8:	01c12d83          	lw	s11,28(sp)
		PR("\t<none>\n");
400286ec:	00048513          	mv	a0,s1
}
400286f0:	04412483          	lw	s1,68(sp)
		PR("\t<none>\n");
400286f4:	40037637          	lui	a2,0x40037
400286f8:	d2c60613          	addi	a2,a2,-724 # 40036d2c <CSWTCH.15846+0x16cc>
400286fc:	00800593          	li	a1,8
}
40028700:	05010113          	addi	sp,sp,80
		PR("\t<none>\n");
40028704:	fe8e006f          	j	40008eec <shell_fprintf>
		if (!nexthop_route->nbr) {
40028708:	00492683          	lw	a3,4(s2)
4002870c:	06068463          	beqz	a3,40028774 <route_cb+0x164>
		PR("\tneighbor : %p\t", nexthop_route->nbr);
40028710:	00048513          	mv	a0,s1
40028714:	cd8a8613          	addi	a2,s5,-808 # 40036cd8 <CSWTCH.15846+0x1678>
40028718:	00800593          	li	a1,8
4002871c:	fd0e00ef          	jal	ra,40008eec <shell_fprintf>
		if (nexthop_route->nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
40028720:	00492783          	lw	a5,4(s2)
40028724:	0017c503          	lbu	a0,1(a5)
40028728:	0ff00793          	li	a5,255
4002872c:	04f51863          	bne	a0,a5,4002877c <route_cb+0x16c>
			PR("addr : <unknown>\t");
40028730:	ce8d8613          	addi	a2,s11,-792 # 40036ce8 <CSWTCH.15846+0x1688>
40028734:	00800593          	li	a1,8
40028738:	00048513          	mv	a0,s1
4002873c:	fb0e00ef          	jal	ra,40008eec <shell_fprintf>
		if (entry->is_infinite) {
40028740:	03144783          	lbu	a5,49(s0)
40028744:	0047f793          	andi	a5,a5,4
40028748:	06078263          	beqz	a5,400287ac <route_cb+0x19c>
			snprintk(remaining_str, sizeof(remaining_str) - 1,
4002874c:	d08c0613          	addi	a2,s8,-760 # 40036d08 <CSWTCH.15846+0x16a8>
40028750:	00f00593          	li	a1,15
40028754:	00010513          	mv	a0,sp
40028758:	dc4d90ef          	jal	ra,40001d1c <snprintk>
		PR("lifetime : %s\n", remaining_str);
4002875c:	00010693          	mv	a3,sp
40028760:	d1cb0613          	addi	a2,s6,-740 # 40036d1c <CSWTCH.15846+0x16bc>
40028764:	00800593          	li	a1,8
40028768:	00048513          	mv	a0,s1
4002876c:	f80e00ef          	jal	ra,40008eec <shell_fprintf>
		count++;
40028770:	00198993          	addi	s3,s3,1
	return node->next;
40028774:	00092903          	lw	s2,0(s2)
40028778:	f3dff06f          	j	400286b4 <route_cb+0xa4>
			lladdr = net_nbr_get_lladdr(nexthop_route->nbr->idx);
4002877c:	d89f20ef          	jal	ra,4001b504 <net_nbr_get_lladdr>
40028780:	00154583          	lbu	a1,1(a0)
40028784:	fecc8613          	addi	a2,s9,-20 # 4003afec <buf.1>
40028788:	01800693          	li	a3,24
4002878c:	00250513          	addi	a0,a0,2
40028790:	d05eb0ef          	jal	ra,40014494 <net_sprint_ll_addr_buf>
40028794:	00050693          	mv	a3,a0
			PR("addr : %s\t", net_sprint_ll_addr(lladdr->addr,
40028798:	cfcd0613          	addi	a2,s10,-772 # 40036cfc <CSWTCH.15846+0x169c>
4002879c:	00800593          	li	a1,8
400287a0:	00048513          	mv	a0,s1
400287a4:	f48e00ef          	jal	ra,40008eec <shell_fprintf>
400287a8:	f99ff06f          	j	40028740 <route_cb+0x130>
			remaining = net_timeout_remaining(&entry->lifetime, now);
400287ac:	000a0593          	mv	a1,s4
400287b0:	01040513          	addi	a0,s0,16
400287b4:	afdeb0ef          	jal	ra,400142b0 <net_timeout_remaining>
400287b8:	00050693          	mv	a3,a0
			snprintk(remaining_str, sizeof(remaining_str) - 1,
400287bc:	d14b8613          	addi	a2,s7,-748 # 40036d14 <CSWTCH.15846+0x16b4>
400287c0:	00f00593          	li	a1,15
400287c4:	00010513          	mv	a0,sp
400287c8:	d54d90ef          	jal	ra,40001d1c <snprintk>
400287cc:	f91ff06f          	j	4002875c <route_cb+0x14c>
}
400287d0:	04c12083          	lw	ra,76(sp)
400287d4:	04812403          	lw	s0,72(sp)
400287d8:	04412483          	lw	s1,68(sp)
400287dc:	04012903          	lw	s2,64(sp)
400287e0:	03c12983          	lw	s3,60(sp)
400287e4:	03812a03          	lw	s4,56(sp)
400287e8:	03412a83          	lw	s5,52(sp)
400287ec:	03012b03          	lw	s6,48(sp)
400287f0:	02c12b83          	lw	s7,44(sp)
400287f4:	02812c03          	lw	s8,40(sp)
400287f8:	02412c83          	lw	s9,36(sp)
400287fc:	02012d03          	lw	s10,32(sp)
40028800:	01c12d83          	lw	s11,28(sp)
40028804:	05010113          	addi	sp,sp,80
40028808:	00008067          	ret

4002880c <cmd_net_udp_bind>:
{
4002880c:	fb010113          	addi	sp,sp,-80
40028810:	04112623          	sw	ra,76(sp)
40028814:	04812423          	sw	s0,72(sp)
40028818:	04912223          	sw	s1,68(sp)
4002881c:	05212023          	sw	s2,64(sp)
40028820:	03312e23          	sw	s3,60(sp)
40028824:	03412c23          	sw	s4,56(sp)
	char *endptr = NULL;
40028828:	00012a23          	sw	zero,20(sp)
	if (argc < 3) {
4002882c:	00200793          	li	a5,2
40028830:	02b7ee63          	bltu	a5,a1,4002886c <cmd_net_udp_bind+0x60>
		PR_WARNING("Not enough arguments given for udp bind command\n");
40028834:	40037637          	lui	a2,0x40037
40028838:	d3860613          	addi	a2,a2,-712 # 40036d38 <CSWTCH.15846+0x16d8>
4002883c:	00300593          	li	a1,3
		PR_WARNING("Invalid port number\n");
40028840:	eace00ef          	jal	ra,40008eec <shell_fprintf>
		return -EINVAL;
40028844:	fea00913          	li	s2,-22
}
40028848:	04c12083          	lw	ra,76(sp)
4002884c:	04812403          	lw	s0,72(sp)
40028850:	04412483          	lw	s1,68(sp)
40028854:	03c12983          	lw	s3,60(sp)
40028858:	03812a03          	lw	s4,56(sp)
4002885c:	00090513          	mv	a0,s2
40028860:	04012903          	lw	s2,64(sp)
40028864:	05010113          	addi	sp,sp,80
40028868:	00008067          	ret
4002886c:	00060913          	mv	s2,a2
	addr_str = argv[1];
40028870:	00050413          	mv	s0,a0
	port = strtol(argv[2], &endptr, 0);
40028874:	00892503          	lw	a0,8(s2)
	addr_str = argv[1];
40028878:	00462a03          	lw	s4,4(a2)
	port = strtol(argv[2], &endptr, 0);
4002887c:	01410593          	addi	a1,sp,20
40028880:	00000613          	li	a2,0
40028884:	f01e30ef          	jal	ra,4000c784 <strtol>
	if (endptr == argv[2]) {
40028888:	00892703          	lw	a4,8(s2)
4002888c:	01412783          	lw	a5,20(sp)
	port = strtol(argv[2], &endptr, 0);
40028890:	01051493          	slli	s1,a0,0x10
40028894:	0104d493          	srli	s1,s1,0x10
	if (endptr == argv[2]) {
40028898:	00f71c63          	bne	a4,a5,400288b0 <cmd_net_udp_bind+0xa4>
		PR_WARNING("Invalid port number\n");
4002889c:	40036637          	lui	a2,0x40036
400288a0:	59860613          	addi	a2,a2,1432 # 40036598 <CSWTCH.15846+0xf38>
400288a4:	00300593          	li	a1,3
400288a8:	00040513          	mv	a0,s0
400288ac:	f95ff06f          	j	40028840 <cmd_net_udp_bind+0x34>
	if (udp_ctx && net_context_is_used(udp_ctx)) {
400288b0:	400399b7          	lui	s3,0x40039
400288b4:	0dc9a783          	lw	a5,220(s3) # 400390dc <udp_ctx>
400288b8:	02078663          	beqz	a5,400288e4 <cmd_net_udp_bind+0xd8>
	return context->flags & NET_CONTEXT_IN_USE;
400288bc:	0747d783          	lhu	a5,116(a5)
400288c0:	0017f793          	andi	a5,a5,1
400288c4:	02078063          	beqz	a5,400288e4 <cmd_net_udp_bind+0xd8>
		PR_WARNING("Network context already in use\n");
400288c8:	40036637          	lui	a2,0x40036
400288cc:	5b060613          	addi	a2,a2,1456 # 400365b0 <CSWTCH.15846+0xf50>
400288d0:	00300593          	li	a1,3
400288d4:	00040513          	mv	a0,s0
400288d8:	e14e00ef          	jal	ra,40008eec <shell_fprintf>
		return -EALREADY;
400288dc:	f8800913          	li	s2,-120
400288e0:	f69ff06f          	j	40028848 <cmd_net_udp_bind+0x3c>
	memset(&addr, 0, sizeof(addr));
400288e4:	01800613          	li	a2,24
400288e8:	00000593          	li	a1,0
400288ec:	01810513          	addi	a0,sp,24
400288f0:	c2ce40ef          	jal	ra,4000cd1c <memset>
	ret = net_ipaddr_parse(addr_str, strlen(addr_str), &addr);
400288f4:	000a0513          	mv	a0,s4
400288f8:	adce40ef          	jal	ra,4000cbd4 <strlen>
400288fc:	00050593          	mv	a1,a0
40028900:	01810613          	addi	a2,sp,24
40028904:	000a0513          	mv	a0,s4
40028908:	87dec0ef          	jal	ra,40015184 <net_ipaddr_parse>
	ret = net_context_get(addr.sa_family, SOCK_DGRAM, IPPROTO_UDP,
4002890c:	01815503          	lhu	a0,24(sp)
40028910:	0dc98693          	addi	a3,s3,220
40028914:	01100613          	li	a2,17
40028918:	00200593          	li	a1,2
4002891c:	c1ced0ef          	jal	ra,40015d38 <net_context_get>
40028920:	00050913          	mv	s2,a0
	if (ret < 0) {
40028924:	02055063          	bgez	a0,40028944 <cmd_net_udp_bind+0x138>
		PR_WARNING("Cannot get UDP context (%d)\n", ret);
40028928:	40036637          	lui	a2,0x40036
4002892c:	00050693          	mv	a3,a0
40028930:	5d060613          	addi	a2,a2,1488 # 400365d0 <CSWTCH.15846+0xf70>
40028934:	00300593          	li	a1,3
40028938:	00040513          	mv	a0,s0
4002893c:	db0e00ef          	jal	ra,40008eec <shell_fprintf>
		return ret;
40028940:	f09ff06f          	j	40028848 <cmd_net_udp_bind+0x3c>
	udp_shell = sh;
40028944:	400397b7          	lui	a5,0x40039
40028948:	0c87ac23          	sw	s0,216(a5) # 400390d8 <udp_shell>
	if (IS_ENABLED(CONFIG_NET_IPV6) && addr.sa_family == AF_INET6) {
4002894c:	01815783          	lhu	a5,24(sp)
40028950:	00200713          	li	a4,2
40028954:	06e79063          	bne	a5,a4,400289b4 <cmd_net_udp_bind+0x1a8>
		net_sin6(&addr)->sin6_port = htons(port);
40028958:	00849793          	slli	a5,s1,0x8
4002895c:	0084d493          	srli	s1,s1,0x8
40028960:	0097e7b3          	or	a5,a5,s1
		iface = net_if_ipv6_select_src_iface(
40028964:	01c10513          	addi	a0,sp,28
		net_sin6(&addr)->sin6_port = htons(port);
40028968:	00f11d23          	sh	a5,26(sp)
		iface = net_if_ipv6_select_src_iface(
4002896c:	c40ea0ef          	jal	ra,40012dac <net_if_ipv6_select_src_iface>
		addrlen = sizeof(struct sockaddr_in6);
40028970:	01800613          	li	a2,24
	if (!iface) {
40028974:	08051463          	bnez	a0,400289fc <cmd_net_udp_bind+0x1f0>
		PR_WARNING("No interface to send to given host\n");
40028978:	40036637          	lui	a2,0x40036
4002897c:	61860613          	addi	a2,a2,1560 # 40036618 <CSWTCH.15846+0xfb8>
40028980:	00300593          	li	a1,3
40028984:	00040513          	mv	a0,s0
40028988:	d64e00ef          	jal	ra,40008eec <shell_fprintf>
	ret = net_context_put(udp_ctx);
4002898c:	0dc9a503          	lw	a0,220(s3)
40028990:	e84ed0ef          	jal	ra,40016014 <net_context_put>
40028994:	00050693          	mv	a3,a0
	if (ret < 0) {
40028998:	0a055e63          	bgez	a0,40028a54 <cmd_net_udp_bind+0x248>
		PR_WARNING("Cannot put UDP context (%d)\n", ret);
4002899c:	40036637          	lui	a2,0x40036
400289a0:	69860613          	addi	a2,a2,1688 # 40036698 <CSWTCH.15846+0x1038>
400289a4:	00300593          	li	a1,3
400289a8:	00040513          	mv	a0,s0
400289ac:	d40e00ef          	jal	ra,40008eec <shell_fprintf>
400289b0:	0a40006f          	j	40028a54 <cmd_net_udp_bind+0x248>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && addr.sa_family == AF_INET) {
400289b4:	00100713          	li	a4,1
400289b8:	02e79263          	bne	a5,a4,400289dc <cmd_net_udp_bind+0x1d0>
		net_sin(&addr)->sin_port = htons(port);
400289bc:	00849793          	slli	a5,s1,0x8
400289c0:	0084d493          	srli	s1,s1,0x8
400289c4:	0097e7b3          	or	a5,a5,s1
		iface = net_if_ipv4_select_src_iface(
400289c8:	01c10513          	addi	a0,sp,28
		net_sin(&addr)->sin_port = htons(port);
400289cc:	00f11d23          	sh	a5,26(sp)
		iface = net_if_ipv4_select_src_iface(
400289d0:	f34ea0ef          	jal	ra,40013104 <net_if_ipv4_select_src_iface>
		addrlen = sizeof(struct sockaddr_in);
400289d4:	00800613          	li	a2,8
400289d8:	f9dff06f          	j	40028974 <cmd_net_udp_bind+0x168>
		PR_WARNING("IPv6 and IPv4 are disabled, cannot %s.\n", "bind");
400289dc:	400376b7          	lui	a3,0x40037
400289e0:	40036637          	lui	a2,0x40036
400289e4:	d6c68693          	addi	a3,a3,-660 # 40036d6c <CSWTCH.15846+0x170c>
400289e8:	5f060613          	addi	a2,a2,1520 # 400365f0 <CSWTCH.15846+0xf90>
		PR_WARNING("Receiving from UDP port failed (%d)\n", ret);
400289ec:	00300593          	li	a1,3
400289f0:	00040513          	mv	a0,s0
400289f4:	cf8e00ef          	jal	ra,40008eec <shell_fprintf>
		goto release_ctx;
400289f8:	f95ff06f          	j	4002898c <cmd_net_udp_bind+0x180>
	net_context_set_iface(udp_ctx, iface);
400289fc:	0dc9a483          	lw	s1,220(s3)
40028a00:	00c12623          	sw	a2,12(sp)
	context->iface = net_if_get_by_iface(iface);
40028a04:	95ceb0ef          	jal	ra,40013b60 <net_if_get_by_iface>
40028a08:	06a48b23          	sb	a0,118(s1)
	ret = net_context_bind(udp_ctx, &addr, addrlen);
40028a0c:	00c12603          	lw	a2,12(sp)
40028a10:	0dc9a503          	lw	a0,220(s3)
40028a14:	01810593          	addi	a1,sp,24
40028a18:	e88ed0ef          	jal	ra,400160a0 <net_context_bind>
40028a1c:	00050693          	mv	a3,a0
	if (ret < 0) {
40028a20:	00055863          	bgez	a0,40028a30 <cmd_net_udp_bind+0x224>
		PR_WARNING("Binding to UDP port failed (%d)\n", ret);
40028a24:	40037637          	lui	a2,0x40037
40028a28:	d7460613          	addi	a2,a2,-652 # 40036d74 <CSWTCH.15846+0x1714>
40028a2c:	fc1ff06f          	j	400289ec <cmd_net_udp_bind+0x1e0>
	ret = net_context_recv(udp_ctx, udp_rcvd, K_NO_WAIT, NULL);
40028a30:	0dc9a503          	lw	a0,220(s3)
40028a34:	400275b7          	lui	a1,0x40027
40028a38:	00000693          	li	a3,0
40028a3c:	00000713          	li	a4,0
40028a40:	00000613          	li	a2,0
40028a44:	2c058593          	addi	a1,a1,704 # 400272c0 <udp_rcvd>
40028a48:	d18ee0ef          	jal	ra,40016f60 <net_context_recv>
40028a4c:	00050693          	mv	a3,a0
	if (ret < 0) {
40028a50:	00054663          	bltz	a0,40028a5c <cmd_net_udp_bind+0x250>
	return 0;
40028a54:	00000913          	li	s2,0
40028a58:	df1ff06f          	j	40028848 <cmd_net_udp_bind+0x3c>
		PR_WARNING("Receiving from UDP port failed (%d)\n", ret);
40028a5c:	40037637          	lui	a2,0x40037
40028a60:	d9860613          	addi	a2,a2,-616 # 40036d98 <CSWTCH.15846+0x1738>
40028a64:	f89ff06f          	j	400289ec <cmd_net_udp_bind+0x1e0>

40028a68 <dns_result_cb>:
{
40028a68:	fc010113          	addi	sp,sp,-64
40028a6c:	02812c23          	sw	s0,56(sp)
40028a70:	02112e23          	sw	ra,60(sp)
	if (status == DNS_EAI_CANCELED) {
40028a74:	f9b00793          	li	a5,-101
{
40028a78:	00060413          	mv	s0,a2
	if (status == DNS_EAI_CANCELED) {
40028a7c:	00f51a63          	bne	a0,a5,40028a90 <dns_result_cb+0x28>
		PR_WARNING("dns: Timeout while resolving name.\n");
40028a80:	40037637          	lui	a2,0x40037
40028a84:	dc060613          	addi	a2,a2,-576 # 40036dc0 <CSWTCH.15846+0x1760>
		PR_WARNING("dns: No such name found.\n");
40028a88:	00300593          	li	a1,3
40028a8c:	0a80006f          	j	40028b34 <dns_result_cb+0xcc>
	if (status == DNS_EAI_INPROGRESS && info) {
40028a90:	f9c00793          	li	a5,-100
40028a94:	00050693          	mv	a3,a0
40028a98:	08f51463          	bne	a0,a5,40028b20 <dns_result_cb+0xb8>
40028a9c:	0c058063          	beqz	a1,40028b5c <dns_result_cb+0xf4>
		if (info->ai_family == AF_INET) {
40028aa0:	01c5c783          	lbu	a5,28(a1)
40028aa4:	00100713          	li	a4,1
40028aa8:	04e79063          	bne	a5,a4,40028ae8 <dns_result_cb+0x80>
	return z_impl_net_addr_ntop(family, src, dst, size);
40028aac:	01000693          	li	a3,16
40028ab0:	00810613          	addi	a2,sp,8
40028ab4:	00458593          	addi	a1,a1,4
40028ab8:	00100513          	li	a0,1
40028abc:	ab9eb0ef          	jal	ra,40014574 <z_impl_net_addr_ntop>
		PR("dns: %s\n", addr);
40028ac0:	40037637          	lui	a2,0x40037
40028ac4:	00810693          	addi	a3,sp,8
40028ac8:	00040513          	mv	a0,s0
40028acc:	dfc60613          	addi	a2,a2,-516 # 40036dfc <CSWTCH.15846+0x179c>
40028ad0:	00800593          	li	a1,8
40028ad4:	c18e00ef          	jal	ra,40008eec <shell_fprintf>
}
40028ad8:	03c12083          	lw	ra,60(sp)
40028adc:	03812403          	lw	s0,56(sp)
40028ae0:	04010113          	addi	sp,sp,64
40028ae4:	00008067          	ret
		} else if (info->ai_family == AF_INET6) {
40028ae8:	00200713          	li	a4,2
40028aec:	00e79c63          	bne	a5,a4,40028b04 <dns_result_cb+0x9c>
40028af0:	02800693          	li	a3,40
40028af4:	00810613          	addi	a2,sp,8
40028af8:	00458593          	addi	a1,a1,4
40028afc:	00200513          	li	a0,2
40028b00:	fbdff06f          	j	40028abc <dns_result_cb+0x54>
			strncpy(addr, "Invalid protocol family",
40028b04:	400375b7          	lui	a1,0x40037
40028b08:	02800613          	li	a2,40
40028b0c:	de458593          	addi	a1,a1,-540 # 40036de4 <CSWTCH.15846+0x1784>
40028b10:	00810513          	addi	a0,sp,8
40028b14:	83ce40ef          	jal	ra,4000cb50 <strncpy>
			addr[sizeof(addr) - 1] = 0;
40028b18:	020107a3          	sb	zero,47(sp)
40028b1c:	fa5ff06f          	j	40028ac0 <dns_result_cb+0x58>
	if (status == DNS_EAI_ALLDONE) {
40028b20:	f9900793          	li	a5,-103
40028b24:	02f51263          	bne	a0,a5,40028b48 <dns_result_cb+0xe0>
		PR("dns: All results received\n");
40028b28:	40037637          	lui	a2,0x40037
40028b2c:	e0860613          	addi	a2,a2,-504 # 40036e08 <CSWTCH.15846+0x17a8>
40028b30:	00800593          	li	a1,8
40028b34:	00040513          	mv	a0,s0
}
40028b38:	03812403          	lw	s0,56(sp)
40028b3c:	03c12083          	lw	ra,60(sp)
40028b40:	04010113          	addi	sp,sp,64
		PR("dns: All results received\n");
40028b44:	ba8e006f          	j	40008eec <shell_fprintf>
	if (status == DNS_EAI_FAIL) {
40028b48:	ffc00793          	li	a5,-4
40028b4c:	00f51863          	bne	a0,a5,40028b5c <dns_result_cb+0xf4>
		PR_WARNING("dns: No such name found.\n");
40028b50:	40037637          	lui	a2,0x40037
40028b54:	e2460613          	addi	a2,a2,-476 # 40036e24 <CSWTCH.15846+0x17c4>
40028b58:	f31ff06f          	j	40028a88 <dns_result_cb+0x20>
	PR_WARNING("dns: Unhandled status %d received\n", status);
40028b5c:	00040513          	mv	a0,s0
}
40028b60:	03812403          	lw	s0,56(sp)
40028b64:	03c12083          	lw	ra,60(sp)
	PR_WARNING("dns: Unhandled status %d received\n", status);
40028b68:	40037637          	lui	a2,0x40037
40028b6c:	e4060613          	addi	a2,a2,-448 # 40036e40 <CSWTCH.15846+0x17e0>
40028b70:	00300593          	li	a1,3
}
40028b74:	04010113          	addi	sp,sp,64
	PR_WARNING("dns: Unhandled status %d received\n", status);
40028b78:	b74e006f          	j	40008eec <shell_fprintf>

40028b7c <cmd_net_tcp_connect>:
{
40028b7c:	fa010113          	addi	sp,sp,-96
40028b80:	05312623          	sw	s3,76(sp)
	if (tcp_ctx && net_context_is_used(tcp_ctx)) {
40028b84:	400399b7          	lui	s3,0x40039
40028b88:	0e49a783          	lw	a5,228(s3) # 400390e4 <tcp_ctx>
{
40028b8c:	04812c23          	sw	s0,88(sp)
40028b90:	05212823          	sw	s2,80(sp)
40028b94:	04112e23          	sw	ra,92(sp)
40028b98:	04912a23          	sw	s1,84(sp)
40028b9c:	05412423          	sw	s4,72(sp)
40028ba0:	00050413          	mv	s0,a0
40028ba4:	00060913          	mv	s2,a2
	if (tcp_ctx && net_context_is_used(tcp_ctx)) {
40028ba8:	04078263          	beqz	a5,40028bec <cmd_net_tcp_connect+0x70>
	return context->flags & NET_CONTEXT_IN_USE;
40028bac:	0747d783          	lhu	a5,116(a5)
40028bb0:	0017f793          	andi	a5,a5,1
40028bb4:	02078c63          	beqz	a5,40028bec <cmd_net_tcp_connect+0x70>
		PR("Already connected\n");
40028bb8:	40037637          	lui	a2,0x40037
40028bbc:	e6460613          	addi	a2,a2,-412 # 40036e64 <CSWTCH.15846+0x1804>
40028bc0:	00800593          	li	a1,8
		PR_WARNING("Peer IP address missing.\n");
40028bc4:	b28e00ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40028bc8:	ff800513          	li	a0,-8
}
40028bcc:	05c12083          	lw	ra,92(sp)
40028bd0:	05812403          	lw	s0,88(sp)
40028bd4:	05412483          	lw	s1,84(sp)
40028bd8:	05012903          	lw	s2,80(sp)
40028bdc:	04c12983          	lw	s3,76(sp)
40028be0:	04812a03          	lw	s4,72(sp)
40028be4:	06010113          	addi	sp,sp,96
40028be8:	00008067          	ret
	if (!argv[++arg]) {
40028bec:	00492a03          	lw	s4,4(s2)
40028bf0:	000a1c63          	bnez	s4,40028c08 <cmd_net_tcp_connect+0x8c>
		PR_WARNING("Peer IP address missing.\n");
40028bf4:	40037637          	lui	a2,0x40037
40028bf8:	e7860613          	addi	a2,a2,-392 # 40036e78 <CSWTCH.15846+0x1818>
40028bfc:	00300593          	li	a1,3
40028c00:	00040513          	mv	a0,s0
40028c04:	fc1ff06f          	j	40028bc4 <cmd_net_tcp_connect+0x48>
	if (!argv[++arg]) {
40028c08:	00892503          	lw	a0,8(s2)
40028c0c:	00051863          	bnez	a0,40028c1c <cmd_net_tcp_connect+0xa0>
		PR_WARNING("Peer port missing.\n");
40028c10:	40037637          	lui	a2,0x40037
40028c14:	e9460613          	addi	a2,a2,-364 # 40036e94 <CSWTCH.15846+0x1834>
40028c18:	fe5ff06f          	j	40028bfc <cmd_net_tcp_connect+0x80>
	port = strtol(argv[arg], &endptr, 10);
40028c1c:	00a00613          	li	a2,10
40028c20:	00c10593          	addi	a1,sp,12
40028c24:	b61e30ef          	jal	ra,4000c784 <strtol>
	if (*endptr != '\0') {
40028c28:	00c12783          	lw	a5,12(sp)
	port = strtol(argv[arg], &endptr, 10);
40028c2c:	01051493          	slli	s1,a0,0x10
40028c30:	0104d493          	srli	s1,s1,0x10
	if (*endptr != '\0') {
40028c34:	0007c783          	lbu	a5,0(a5)
40028c38:	02078063          	beqz	a5,40028c58 <cmd_net_tcp_connect+0xdc>
		PR_WARNING("Invalid port %s\n", argv[arg]);
40028c3c:	00892683          	lw	a3,8(s2)
40028c40:	40037637          	lui	a2,0x40037
40028c44:	ea860613          	addi	a2,a2,-344 # 40036ea8 <CSWTCH.15846+0x1848>
40028c48:	00300593          	li	a1,3
40028c4c:	00040513          	mv	a0,s0
40028c50:	a9ce00ef          	jal	ra,40008eec <shell_fprintf>
		return -ENOEXEC;
40028c54:	f75ff06f          	j	40028bc8 <cmd_net_tcp_connect+0x4c>
	struct net_if *iface = net_if_get_default();
40028c58:	8f8e80ef          	jal	ra,40010d50 <net_if_get_default>
40028c5c:	00050913          	mv	s2,a0
		ret = net_addr_pton(AF_INET6, host,
40028c60:	02c10613          	addi	a2,sp,44
40028c64:	000a0593          	mv	a1,s4
40028c68:	00200513          	li	a0,2
40028c6c:	8bdfc0ef          	jal	ra,40025528 <net_addr_pton>
		if (ret < 0) {
40028c70:	10055a63          	bgez	a0,40028d84 <cmd_net_tcp_connect+0x208>
			ret = net_addr_pton(AF_INET, host,
40028c74:	02c10613          	addi	a2,sp,44
40028c78:	000a0593          	mv	a1,s4
40028c7c:	00100513          	li	a0,1
40028c80:	8a9fc0ef          	jal	ra,40025528 <net_addr_pton>
			if (ret < 0) {
40028c84:	02055063          	bgez	a0,40028ca4 <cmd_net_tcp_connect+0x128>
				PR_WARNING("Invalid IP address\n");
40028c88:	40037637          	lui	a2,0x40037
40028c8c:	c7060613          	addi	a2,a2,-912 # 40036c70 <CSWTCH.15846+0x1610>
40028c90:	00300593          	li	a1,3
40028c94:	00040513          	mv	a0,s0
40028c98:	a54e00ef          	jal	ra,40008eec <shell_fprintf>
	return 0;
40028c9c:	00000513          	li	a0,0
40028ca0:	f2dff06f          	j	40028bcc <cmd_net_tcp_connect+0x50>
	       &iface->config.ip.ipv4->unicast[0].address.in_addr,
40028ca4:	0c092583          	lw	a1,192(s2)
			net_sin(&addr)->sin_port = htons(port);
40028ca8:	00849793          	slli	a5,s1,0x8
40028cac:	0084d493          	srli	s1,s1,0x8
40028cb0:	0097e7b3          	or	a5,a5,s1
	memcpy(&net_sin(myaddr)->sin_addr,
40028cb4:	00400613          	li	a2,4
40028cb8:	00458593          	addi	a1,a1,4
40028cbc:	01410513          	addi	a0,sp,20
			net_sin(&addr)->sin_port = htons(port);
40028cc0:	02f11523          	sh	a5,42(sp)
	memcpy(&net_sin(myaddr)->sin_addr,
40028cc4:	834e40ef          	jal	ra,4000ccf8 <memcpy>
			family = addr.sa_family = myaddr.sa_family = AF_INET;
40028cc8:	00100793          	li	a5,1
			PR("Connecting from %s:%u ",
40028ccc:	01410593          	addi	a1,sp,20
40028cd0:	00100513          	li	a0,1
			family = addr.sa_family = myaddr.sa_family = AF_INET;
40028cd4:	00f12823          	sw	a5,16(sp)
40028cd8:	02f11423          	sh	a5,40(sp)
			PR("Connecting from %s:%u ",
40028cdc:	bd9eb0ef          	jal	ra,400148b4 <net_sprint_addr>
40028ce0:	01215783          	lhu	a5,18(sp)
40028ce4:	40037637          	lui	a2,0x40037
40028ce8:	00050693          	mv	a3,a0
40028cec:	00879713          	slli	a4,a5,0x8
40028cf0:	0087d793          	srli	a5,a5,0x8
40028cf4:	00f76733          	or	a4,a4,a5
40028cf8:	01071713          	slli	a4,a4,0x10
40028cfc:	01075713          	srli	a4,a4,0x10
40028d00:	ebc60613          	addi	a2,a2,-324 # 40036ebc <CSWTCH.15846+0x185c>
40028d04:	00800593          	li	a1,8
40028d08:	00040513          	mv	a0,s0
40028d0c:	9e0e00ef          	jal	ra,40008eec <shell_fprintf>
			PR("to %s:%u\n",
40028d10:	02c10593          	addi	a1,sp,44
40028d14:	00100513          	li	a0,1
40028d18:	b9deb0ef          	jal	ra,400148b4 <net_sprint_addr>
40028d1c:	02a15783          	lhu	a5,42(sp)
40028d20:	40037637          	lui	a2,0x40037
40028d24:	00050693          	mv	a3,a0
40028d28:	00879713          	slli	a4,a5,0x8
40028d2c:	0087d793          	srli	a5,a5,0x8
40028d30:	00f76733          	or	a4,a4,a5
40028d34:	01071713          	slli	a4,a4,0x10
40028d38:	00040513          	mv	a0,s0
40028d3c:	01075713          	srli	a4,a4,0x10
40028d40:	ed460613          	addi	a2,a2,-300 # 40036ed4 <CSWTCH.15846+0x1874>
40028d44:	00800593          	li	a1,8
40028d48:	9a4e00ef          	jal	ra,40008eec <shell_fprintf>
			addrlen = sizeof(struct sockaddr_in);
40028d4c:	00800493          	li	s1,8
			family = addr.sa_family = myaddr.sa_family = AF_INET;
40028d50:	00100513          	li	a0,1
	ret = net_context_get(family, SOCK_STREAM, IPPROTO_TCP, ctx);
40028d54:	0e498693          	addi	a3,s3,228
40028d58:	00600613          	li	a2,6
40028d5c:	00100593          	li	a1,1
40028d60:	fd9ec0ef          	jal	ra,40015d38 <net_context_get>
40028d64:	00050693          	mv	a3,a0
	if (ret < 0) {
40028d68:	0e055663          	bgez	a0,40028e54 <cmd_net_tcp_connect+0x2d8>
		PR_WARNING("Cannot get TCP context (%d)\n", ret);
40028d6c:	40037637          	lui	a2,0x40037
40028d70:	f0860613          	addi	a2,a2,-248 # 40036f08 <CSWTCH.15846+0x18a8>
		PR_WARNING("Cannot bind TCP (%d)\n", ret);
40028d74:	00300593          	li	a1,3
40028d78:	00040513          	mv	a0,s0
40028d7c:	970e00ef          	jal	ra,40008eec <shell_fprintf>
		return;
40028d80:	f1dff06f          	j	40028c9c <cmd_net_tcp_connect+0x120>
			net_sin6(&addr)->sin6_port = htons(port);
40028d84:	00849793          	slli	a5,s1,0x8
40028d88:	0084d493          	srli	s1,s1,0x8
40028d8c:	0097e7b3          	or	a5,a5,s1
			nbr = net_ipv6_nbr_lookup(NULL,
40028d90:	02c10593          	addi	a1,sp,44
40028d94:	00000513          	li	a0,0
			net_sin6(&addr)->sin6_port = htons(port);
40028d98:	02f11523          	sh	a5,42(sp)
			nbr = net_ipv6_nbr_lookup(NULL,
40028d9c:	d05f30ef          	jal	ra,4001caa0 <net_ipv6_nbr_lookup>
			if (nbr) {
40028da0:	00050463          	beqz	a0,40028da8 <cmd_net_tcp_connect+0x22c>
				iface = nbr->iface;
40028da4:	00852903          	lw	s2,8(a0)
	my6addr = net_if_ipv6_select_src_addr(iface,
40028da8:	01410593          	addi	a1,sp,20
40028dac:	00090513          	mv	a0,s2
40028db0:	ed9e90ef          	jal	ra,40012c88 <net_if_ipv6_select_src_addr>
40028db4:	00050593          	mv	a1,a0
	memcpy(&net_sin6(myaddr)->sin6_addr, my6addr, sizeof(struct in6_addr));
40028db8:	01000613          	li	a2,16
40028dbc:	01410513          	addi	a0,sp,20
40028dc0:	f39e30ef          	jal	ra,4000ccf8 <memcpy>
			family = addr.sa_family = myaddr.sa_family = AF_INET6;
40028dc4:	00200793          	li	a5,2
			PR("Connecting from [%s]:%u ",
40028dc8:	01410593          	addi	a1,sp,20
40028dcc:	00200513          	li	a0,2
			family = addr.sa_family = myaddr.sa_family = AF_INET6;
40028dd0:	00f12823          	sw	a5,16(sp)
40028dd4:	02f11423          	sh	a5,40(sp)
			PR("Connecting from [%s]:%u ",
40028dd8:	addeb0ef          	jal	ra,400148b4 <net_sprint_addr>
40028ddc:	01215783          	lhu	a5,18(sp)
40028de0:	40037637          	lui	a2,0x40037
40028de4:	00050693          	mv	a3,a0
40028de8:	00879713          	slli	a4,a5,0x8
40028dec:	0087d793          	srli	a5,a5,0x8
40028df0:	00f76733          	or	a4,a4,a5
40028df4:	01071713          	slli	a4,a4,0x10
40028df8:	01075713          	srli	a4,a4,0x10
40028dfc:	ee060613          	addi	a2,a2,-288 # 40036ee0 <CSWTCH.15846+0x1880>
40028e00:	00800593          	li	a1,8
40028e04:	00040513          	mv	a0,s0
40028e08:	8e4e00ef          	jal	ra,40008eec <shell_fprintf>
			PR("to [%s]:%u\n",
40028e0c:	02c10593          	addi	a1,sp,44
40028e10:	00200513          	li	a0,2
40028e14:	aa1eb0ef          	jal	ra,400148b4 <net_sprint_addr>
40028e18:	02a15783          	lhu	a5,42(sp)
40028e1c:	40037637          	lui	a2,0x40037
40028e20:	00050693          	mv	a3,a0
40028e24:	00879713          	slli	a4,a5,0x8
40028e28:	0087d793          	srli	a5,a5,0x8
40028e2c:	00f76733          	or	a4,a4,a5
40028e30:	01071713          	slli	a4,a4,0x10
40028e34:	00040513          	mv	a0,s0
40028e38:	01075713          	srli	a4,a4,0x10
40028e3c:	efc60613          	addi	a2,a2,-260 # 40036efc <CSWTCH.15846+0x189c>
40028e40:	00800593          	li	a1,8
40028e44:	8a8e00ef          	jal	ra,40008eec <shell_fprintf>
			addrlen = sizeof(struct sockaddr_in6);
40028e48:	01800493          	li	s1,24
			family = addr.sa_family = myaddr.sa_family = AF_INET6;
40028e4c:	00200513          	li	a0,2
		break;
40028e50:	f05ff06f          	j	40028d54 <cmd_net_tcp_connect+0x1d8>
	ret = net_context_bind(*ctx, &myaddr, addrlen);
40028e54:	0e49a503          	lw	a0,228(s3)
40028e58:	00048613          	mv	a2,s1
40028e5c:	01010593          	addi	a1,sp,16
40028e60:	a40ed0ef          	jal	ra,400160a0 <net_context_bind>
40028e64:	00050693          	mv	a3,a0
	if (ret < 0) {
40028e68:	00055863          	bgez	a0,40028e78 <cmd_net_tcp_connect+0x2fc>
		PR_WARNING("Cannot bind TCP (%d)\n", ret);
40028e6c:	40037637          	lui	a2,0x40037
40028e70:	f2860613          	addi	a2,a2,-216 # 40036f28 <CSWTCH.15846+0x18c8>
40028e74:	f01ff06f          	j	40028d74 <cmd_net_tcp_connect+0x1f8>
	net_context_connect(*ctx, &addr, addrlen, tcp_connected,
40028e78:	0e49a503          	lw	a0,228(s3)
	tcp_shell = sh;
40028e7c:	400397b7          	lui	a5,0x40039
	net_context_connect(*ctx, &addr, addrlen, tcp_connected,
40028e80:	400276b7          	lui	a3,0x40027
	tcp_shell = sh;
40028e84:	0e87a023          	sw	s0,224(a5) # 400390e0 <tcp_shell>
	net_context_connect(*ctx, &addr, addrlen, tcp_connected,
40028e88:	00000813          	li	a6,0
40028e8c:	12c00713          	li	a4,300
40028e90:	00000793          	li	a5,0
40028e94:	ab468693          	addi	a3,a3,-1356 # 40026ab4 <tcp_connected>
40028e98:	00048613          	mv	a2,s1
40028e9c:	02810593          	addi	a1,sp,40
40028ea0:	c95ed0ef          	jal	ra,40016b34 <net_context_connect>
40028ea4:	df9ff06f          	j	40028c9c <cmd_net_tcp_connect+0x120>

40028ea8 <address_lifetime_cb>:
{
40028ea8:	fb010113          	addi	sp,sp,-80
40028eac:	04112623          	sw	ra,76(sp)
40028eb0:	04912223          	sw	s1,68(sp)
40028eb4:	04812423          	sw	s0,72(sp)
40028eb8:	05212023          	sw	s2,64(sp)
40028ebc:	03312e23          	sw	s3,60(sp)
40028ec0:	03412c23          	sw	s4,56(sp)
40028ec4:	03512a23          	sw	s5,52(sp)
40028ec8:	03612823          	sw	s6,48(sp)
40028ecc:	03712623          	sw	s7,44(sp)
40028ed0:	03812423          	sw	s8,40(sp)
40028ed4:	03912223          	sw	s9,36(sp)
	const struct shell *sh = data->sh;
40028ed8:	0005a983          	lw	s3,0(a1)
{
40028edc:	00050493          	mv	s1,a0
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
40028ee0:	0bc52a03          	lw	s4,188(a0)
	PR("\nIPv6 addresses for interface %d (%p) (%s)\n",
40028ee4:	c7dea0ef          	jal	ra,40013b60 <net_if_get_by_iface>
40028ee8:	00a12423          	sw	a0,8(sp)
40028eec:	01010593          	addi	a1,sp,16
40028ef0:	00048513          	mv	a0,s1
40028ef4:	87dfe0ef          	jal	ra,40027770 <iface2str>
40028ef8:	00812683          	lw	a3,8(sp)
40028efc:	40037637          	lui	a2,0x40037
40028f00:	00050793          	mv	a5,a0
40028f04:	f4060613          	addi	a2,a2,-192 # 40036f40 <CSWTCH.15846+0x18e0>
40028f08:	00800593          	li	a1,8
40028f0c:	00098513          	mv	a0,s3
40028f10:	00048713          	mv	a4,s1
40028f14:	fd9df0ef          	jal	ra,40008eec <shell_fprintf>
	PR("============================================%s\n", extra);
40028f18:	01012683          	lw	a3,16(sp)
40028f1c:	40037637          	lui	a2,0x40037
40028f20:	b2460613          	addi	a2,a2,-1244 # 40036b24 <CSWTCH.15846+0x14c4>
40028f24:	00800593          	li	a1,8
40028f28:	00098513          	mv	a0,s3
40028f2c:	fc1df0ef          	jal	ra,40008eec <shell_fprintf>
	if (!ipv6) {
40028f30:	040a1463          	bnez	s4,40028f78 <address_lifetime_cb+0xd0>
}
40028f34:	04812403          	lw	s0,72(sp)
40028f38:	04c12083          	lw	ra,76(sp)
40028f3c:	04412483          	lw	s1,68(sp)
40028f40:	04012903          	lw	s2,64(sp)
40028f44:	03812a03          	lw	s4,56(sp)
40028f48:	03412a83          	lw	s5,52(sp)
40028f4c:	03012b03          	lw	s6,48(sp)
40028f50:	02c12b83          	lw	s7,44(sp)
40028f54:	02812c03          	lw	s8,40(sp)
40028f58:	02412c83          	lw	s9,36(sp)
		PR("No IPv6 config found for this interface.\n");
40028f5c:	00098513          	mv	a0,s3
}
40028f60:	03c12983          	lw	s3,60(sp)
		PR("No IPv6 config found for this interface.\n");
40028f64:	40037637          	lui	a2,0x40037
40028f68:	f6c60613          	addi	a2,a2,-148 # 40036f6c <CSWTCH.15846+0x190c>
40028f6c:	00800593          	li	a1,8
}
40028f70:	05010113          	addi	sp,sp,80
		PR("No IPv6 config found for this interface.\n");
40028f74:	f79df06f          	j	40008eec <shell_fprintf>
	PR("Type      \tState    \tLifetime (sec)\tAddress\n");
40028f78:	40037637          	lui	a2,0x40037
40028f7c:	b8060613          	addi	a2,a2,-1152 # 40036b80 <CSWTCH.15846+0x1520>
40028f80:	00800593          	li	a1,8
40028f84:	00098513          	mv	a0,s3
40028f88:	f65df0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40028f8c:	004a0413          	addi	s0,s4,4
40028f90:	00000913          	li	s2,0
		if (!ipv6->unicast[i].is_used ||
40028f94:	03000b93          	li	s7,48
40028f98:	00200c13          	li	s8,2
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40028f9c:	00300b13          	li	s6,3
		if (!ipv6->unicast[i].is_used ||
40028fa0:	037907b3          	mul	a5,s2,s7
40028fa4:	00fa07b3          	add	a5,s4,a5
40028fa8:	02c7a783          	lw	a5,44(a5)
40028fac:	0197d793          	srli	a5,a5,0x19
40028fb0:	0017f793          	andi	a5,a5,1
40028fb4:	0e078663          	beqz	a5,400290a0 <address_lifetime_cb+0x1f8>
40028fb8:	ffc45783          	lhu	a5,-4(s0)
40028fbc:	0f879263          	bne	a5,s8,400290a0 <address_lifetime_cb+0x1f8>
40028fc0:	694080ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
		remaining = net_timeout_remaining(&ipv6->unicast[i].lifetime,
40028fc4:	00a00593          	li	a1,10
40028fc8:	02a585b3          	mul	a1,a1,a0
40028fcc:	01040513          	addi	a0,s0,16
			prefix_len = 128U;
40028fd0:	08000a93          	li	s5,128
		remaining = net_timeout_remaining(&ipv6->unicast[i].lifetime,
40028fd4:	adceb0ef          	jal	ra,400142b0 <net_timeout_remaining>
40028fd8:	00050c93          	mv	s9,a0
		prefix = net_if_ipv6_prefix_get(iface,
40028fdc:	00040593          	mv	a1,s0
40028fe0:	00048513          	mv	a0,s1
40028fe4:	e40e90ef          	jal	ra,40012624 <net_if_ipv6_prefix_get>
		if (prefix) {
40028fe8:	00050463          	beqz	a0,40028ff0 <address_lifetime_cb+0x148>
			prefix_len = prefix->len;
40028fec:	02454a83          	lbu	s5,36(a0)
		if (ipv6->unicast[i].is_infinite) {
40028ff0:	03000793          	li	a5,48
40028ff4:	02f907b3          	mul	a5,s2,a5
40028ff8:	00fa07b3          	add	a5,s4,a5
40028ffc:	02f7c783          	lbu	a5,47(a5)
40029000:	0017f793          	andi	a5,a5,1
40029004:	0c078e63          	beqz	a5,400290e0 <address_lifetime_cb+0x238>
			snprintk(remaining_str, sizeof(remaining_str) - 1,
40029008:	40037637          	lui	a2,0x40037
4002900c:	d0860613          	addi	a2,a2,-760 # 40036d08 <CSWTCH.15846+0x16a8>
40029010:	00b00593          	li	a1,11
40029014:	01410513          	addi	a0,sp,20
40029018:	d05d80ef          	jal	ra,40001d1c <snprintk>
		PR("%s  \t%s\t%s    \t%s/%d\n",
4002901c:	02844703          	lbu	a4,40(s0)
	switch (addr_type) {
40029020:	00400793          	li	a5,4
40029024:	0ee7e663          	bltu	a5,a4,40029110 <address_lifetime_cb+0x268>
40029028:	400387b7          	lui	a5,0x40038
4002902c:	00271713          	slli	a4,a4,0x2
40029030:	37478793          	addi	a5,a5,884 # 40038374 <CSWTCH.236>
40029034:	00e787b3          	add	a5,a5,a4
40029038:	0007a683          	lw	a3,0(a5)
	switch (addr_state) {
4002903c:	02944783          	lbu	a5,41(s0)
40029040:	00300713          	li	a4,3
40029044:	00178793          	addi	a5,a5,1
40029048:	0ff7f793          	zext.b	a5,a5
4002904c:	0cf76863          	bltu	a4,a5,4002911c <address_lifetime_cb+0x274>
40029050:	40038737          	lui	a4,0x40038
40029054:	36470713          	addi	a4,a4,868 # 40038364 <CSWTCH.238>
40029058:	00279793          	slli	a5,a5,0x2
4002905c:	00f707b3          	add	a5,a4,a5
40029060:	0007a703          	lw	a4,0(a5)
		PR("%s  \t%s\t%s    \t%s/%d\n",
40029064:	00040593          	mv	a1,s0
40029068:	00200513          	li	a0,2
4002906c:	00d12623          	sw	a3,12(sp)
40029070:	00e12423          	sw	a4,8(sp)
40029074:	841eb0ef          	jal	ra,400148b4 <net_sprint_addr>
40029078:	00812703          	lw	a4,8(sp)
4002907c:	00c12683          	lw	a3,12(sp)
40029080:	40037637          	lui	a2,0x40037
40029084:	00050813          	mv	a6,a0
40029088:	000a8893          	mv	a7,s5
4002908c:	01410793          	addi	a5,sp,20
40029090:	f9860613          	addi	a2,a2,-104 # 40036f98 <CSWTCH.15846+0x1938>
40029094:	00800593          	li	a1,8
40029098:	00098513          	mv	a0,s3
4002909c:	e51df0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
400290a0:	00190913          	addi	s2,s2,1
400290a4:	03040413          	addi	s0,s0,48
400290a8:	ef691ce3          	bne	s2,s6,40028fa0 <address_lifetime_cb+0xf8>
}
400290ac:	04c12083          	lw	ra,76(sp)
400290b0:	04812403          	lw	s0,72(sp)
400290b4:	04412483          	lw	s1,68(sp)
400290b8:	04012903          	lw	s2,64(sp)
400290bc:	03c12983          	lw	s3,60(sp)
400290c0:	03812a03          	lw	s4,56(sp)
400290c4:	03412a83          	lw	s5,52(sp)
400290c8:	03012b03          	lw	s6,48(sp)
400290cc:	02c12b83          	lw	s7,44(sp)
400290d0:	02812c03          	lw	s8,40(sp)
400290d4:	02412c83          	lw	s9,36(sp)
400290d8:	05010113          	addi	sp,sp,80
400290dc:	00008067          	ret
				 "%u", (uint32_t)(remaining / 1000U));
400290e0:	3e800613          	li	a2,1000
400290e4:	00000693          	li	a3,0
400290e8:	000c8513          	mv	a0,s9
400290ec:	00000593          	li	a1,0
400290f0:	9c8d70ef          	jal	ra,400002b8 <__udivdi3>
			snprintk(remaining_str, sizeof(remaining_str) - 1,
400290f4:	40035637          	lui	a2,0x40035
				 "%u", (uint32_t)(remaining / 1000U));
400290f8:	00050693          	mv	a3,a0
			snprintk(remaining_str, sizeof(remaining_str) - 1,
400290fc:	08860613          	addi	a2,a2,136 # 40035088 <all_nodes_mcast_group.0+0xec>
40029100:	00b00593          	li	a1,11
40029104:	01410513          	addi	a0,sp,20
40029108:	c15d80ef          	jal	ra,40001d1c <snprintk>
4002910c:	f11ff06f          	j	4002901c <address_lifetime_cb+0x174>
		PR("%s  \t%s\t%s    \t%s/%d\n",
40029110:	400376b7          	lui	a3,0x40037
40029114:	ae868693          	addi	a3,a3,-1304 # 40036ae8 <CSWTCH.15846+0x1488>
40029118:	f25ff06f          	j	4002903c <address_lifetime_cb+0x194>
	switch (addr_state) {
4002911c:	40035737          	lui	a4,0x40035
40029120:	fd870713          	addi	a4,a4,-40 # 40034fd8 <all_nodes_mcast_group.0+0x3c>
40029124:	f41ff06f          	j	40029064 <address_lifetime_cb+0x1bc>

40029128 <iface_cb>:
{
40029128:	fa010113          	addi	sp,sp,-96
4002912c:	04912a23          	sw	s1,84(sp)
40029130:	05212823          	sw	s2,80(sp)
40029134:	04112e23          	sw	ra,92(sp)
40029138:	04812c23          	sw	s0,88(sp)
4002913c:	05312623          	sw	s3,76(sp)
40029140:	05412423          	sw	s4,72(sp)
40029144:	05512223          	sw	s5,68(sp)
40029148:	05612023          	sw	s6,64(sp)
4002914c:	03712e23          	sw	s7,60(sp)
40029150:	03812c23          	sw	s8,56(sp)
40029154:	03912a23          	sw	s9,52(sp)
40029158:	03a12823          	sw	s10,48(sp)
4002915c:	03b12623          	sw	s11,44(sp)
	const struct shell *sh = data->sh;
40029160:	0005a783          	lw	a5,0(a1)
{
40029164:	00050913          	mv	s2,a0
40029168:	00058493          	mv	s1,a1
	const struct shell *sh = data->sh;
4002916c:	00f12423          	sw	a5,8(sp)
	if (data->user_data && data->user_data != iface) {
40029170:	0045a783          	lw	a5,4(a1)
40029174:	00078463          	beqz	a5,4002917c <iface_cb+0x54>
40029178:	2ca79e63          	bne	a5,a0,40029454 <iface_cb+0x32c>
	PR("\nInterface %p (%s) [%d]\n", iface, iface2str(iface, &extra),
4002917c:	01c10593          	addi	a1,sp,28
40029180:	00090513          	mv	a0,s2
40029184:	decfe0ef          	jal	ra,40027770 <iface2str>
40029188:	00a12623          	sw	a0,12(sp)
4002918c:	00090513          	mv	a0,s2
40029190:	9d1ea0ef          	jal	ra,40013b60 <net_if_get_by_iface>
40029194:	00050793          	mv	a5,a0
40029198:	00c12703          	lw	a4,12(sp)
4002919c:	00812503          	lw	a0,8(sp)
400291a0:	40036637          	lui	a2,0x40036
400291a4:	00090693          	mv	a3,s2
400291a8:	7e860613          	addi	a2,a2,2024 # 400367e8 <CSWTCH.15846+0x1188>
400291ac:	00800593          	li	a1,8
400291b0:	d3ddf0ef          	jal	ra,40008eec <shell_fprintf>
	PR("===========================%s\n", extra);
400291b4:	00812503          	lw	a0,8(sp)
400291b8:	01c12683          	lw	a3,28(sp)
400291bc:	40037637          	lui	a2,0x40037
400291c0:	80460613          	addi	a2,a2,-2044 # 40036804 <CSWTCH.15846+0x11a4>
400291c4:	00800593          	li	a1,8
400291c8:	d25df0ef          	jal	ra,40008eec <shell_fprintf>
	if (!net_if_is_up(iface)) {
400291cc:	00090513          	mv	a0,s2
400291d0:	fddfd0ef          	jal	ra,400271ac <net_if_is_up>
400291d4:	26050263          	beqz	a0,40029438 <iface_cb+0x310>
	return &iface->if_dev->link_addr;
400291d8:	00092783          	lw	a5,0(s2)
	    net_if_get_link_addr(iface)->addr) {
400291dc:	0107a503          	lw	a0,16(a5)
	if (net_if_get_link_addr(iface) &&
400291e0:	2a051863          	bnez	a0,40029490 <iface_cb+0x368>
	return iface->if_dev->mtu;
400291e4:	00092783          	lw	a5,0(s2)
	PR("MTU       : %d\n", net_if_get_mtu(iface));
400291e8:	00812503          	lw	a0,8(sp)
400291ec:	40037637          	lui	a2,0x40037
400291f0:	0187d683          	lhu	a3,24(a5)
400291f4:	fec60613          	addi	a2,a2,-20 # 40036fec <CSWTCH.15846+0x198c>
400291f8:	00800593          	li	a1,8
400291fc:	cf1df0ef          	jal	ra,40008eec <shell_fprintf>
	if (net_if_flag_is_set(iface, NET_IF_POINTOPOINT)) {
40029200:	00100593          	li	a1,1
40029204:	00090513          	mv	a0,s2
40029208:	f65fd0ef          	jal	ra,4002716c <net_if_flag_is_set>
4002920c:	4003ba37          	lui	s4,0x4003b
	int pos = 0;
40029210:	00000493          	li	s1,0
	if (net_if_flag_is_set(iface, NET_IF_POINTOPOINT)) {
40029214:	00050e63          	beqz	a0,40029230 <iface_cb+0x108>
		pos += snprintk(str + pos, sizeof(str) - pos,
40029218:	40037637          	lui	a2,0x40037
4002921c:	ffc60613          	addi	a2,a2,-4 # 40036ffc <CSWTCH.15846+0x199c>
40029220:	05100593          	li	a1,81
40029224:	f98a0513          	addi	a0,s4,-104 # 4003af98 <str.0>
40029228:	af5d80ef          	jal	ra,40001d1c <snprintk>
4002922c:	00050493          	mv	s1,a0
	if (net_if_flag_is_set(iface, NET_IF_PROMISC)) {
40029230:	00200593          	li	a1,2
40029234:	00090513          	mv	a0,s2
40029238:	4003b9b7          	lui	s3,0x4003b
4002923c:	f31fd0ef          	jal	ra,4002716c <net_if_flag_is_set>
40029240:	f9898993          	addi	s3,s3,-104 # 4003af98 <str.0>
40029244:	02050063          	beqz	a0,40029264 <iface_cb+0x13c>
		pos += snprintk(str + pos, sizeof(str) - pos,
40029248:	40037637          	lui	a2,0x40037
4002924c:	05100593          	li	a1,81
40029250:	409585b3          	sub	a1,a1,s1
40029254:	00998533          	add	a0,s3,s1
40029258:	00c60613          	addi	a2,a2,12 # 4003700c <CSWTCH.15846+0x19ac>
4002925c:	ac1d80ef          	jal	ra,40001d1c <snprintk>
40029260:	00a484b3          	add	s1,s1,a0
	if (net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
40029264:	00300593          	li	a1,3
40029268:	00090513          	mv	a0,s2
4002926c:	f01fd0ef          	jal	ra,4002716c <net_if_flag_is_set>
40029270:	00050793          	mv	a5,a0
		pos += snprintk(str + pos, sizeof(str) - pos,
40029274:	05100593          	li	a1,81
40029278:	00998533          	add	a0,s3,s1
4002927c:	409585b3          	sub	a1,a1,s1
	if (net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
40029280:	24078063          	beqz	a5,400294c0 <iface_cb+0x398>
		pos += snprintk(str + pos, sizeof(str) - pos,
40029284:	40037637          	lui	a2,0x40037
40029288:	01860613          	addi	a2,a2,24 # 40037018 <CSWTCH.15846+0x19b8>
		pos += snprintk(str + pos, sizeof(str) - pos,
4002928c:	a91d80ef          	jal	ra,40001d1c <snprintk>
40029290:	00a484b3          	add	s1,s1,a0
	if (net_if_flag_is_set(iface, NET_IF_FORWARD_MULTICASTS)) {
40029294:	00500593          	li	a1,5
40029298:	00090513          	mv	a0,s2
4002929c:	ed1fd0ef          	jal	ra,4002716c <net_if_flag_is_set>
400292a0:	02050063          	beqz	a0,400292c0 <iface_cb+0x198>
		pos += snprintk(str + pos, sizeof(str) - pos,
400292a4:	40037637          	lui	a2,0x40037
400292a8:	05100593          	li	a1,81
400292ac:	409585b3          	sub	a1,a1,s1
400292b0:	00998533          	add	a0,s3,s1
400292b4:	03460613          	addi	a2,a2,52 # 40037034 <CSWTCH.15846+0x19d4>
400292b8:	a65d80ef          	jal	ra,40001d1c <snprintk>
400292bc:	00a484b3          	add	s1,s1,a0
	if (net_if_flag_is_set(iface, NET_IF_IPV4)) {
400292c0:	00600593          	li	a1,6
400292c4:	00090513          	mv	a0,s2
400292c8:	ea5fd0ef          	jal	ra,4002716c <net_if_flag_is_set>
400292cc:	02050063          	beqz	a0,400292ec <iface_cb+0x1c4>
		pos += snprintk(str + pos, sizeof(str) - pos,
400292d0:	40037637          	lui	a2,0x40037
400292d4:	05100593          	li	a1,81
400292d8:	409585b3          	sub	a1,a1,s1
400292dc:	00998533          	add	a0,s3,s1
400292e0:	04460613          	addi	a2,a2,68 # 40037044 <CSWTCH.15846+0x19e4>
400292e4:	a39d80ef          	jal	ra,40001d1c <snprintk>
400292e8:	00a484b3          	add	s1,s1,a0
	if (net_if_flag_is_set(iface, NET_IF_IPV6)) {
400292ec:	00700593          	li	a1,7
400292f0:	00090513          	mv	a0,s2
400292f4:	e79fd0ef          	jal	ra,4002716c <net_if_flag_is_set>
400292f8:	02050063          	beqz	a0,40029318 <iface_cb+0x1f0>
		pos += snprintk(str + pos, sizeof(str) - pos,
400292fc:	40037637          	lui	a2,0x40037
40029300:	05100593          	li	a1,81
40029304:	409585b3          	sub	a1,a1,s1
40029308:	00998533          	add	a0,s3,s1
4002930c:	04c60613          	addi	a2,a2,76 # 4003704c <CSWTCH.15846+0x19ec>
40029310:	a0dd80ef          	jal	ra,40001d1c <snprintk>
40029314:	00a484b3          	add	s1,s1,a0
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {
40029318:	00b00593          	li	a1,11
4002931c:	00090513          	mv	a0,s2
40029320:	e4dfd0ef          	jal	ra,4002716c <net_if_flag_is_set>
40029324:	02050063          	beqz	a0,40029344 <iface_cb+0x21c>
		pos += snprintk(str + pos, sizeof(str) - pos,
40029328:	40037637          	lui	a2,0x40037
4002932c:	05100593          	li	a1,81
40029330:	409585b3          	sub	a1,a1,s1
40029334:	00998533          	add	a0,s3,s1
40029338:	05460613          	addi	a2,a2,84 # 40037054 <CSWTCH.15846+0x19f4>
4002933c:	9e1d80ef          	jal	ra,40001d1c <snprintk>
40029340:	00a484b3          	add	s1,s1,a0
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_MLD)) {
40029344:	00c00593          	li	a1,12
40029348:	00090513          	mv	a0,s2
4002934c:	e21fd0ef          	jal	ra,4002716c <net_if_flag_is_set>
40029350:	02050063          	beqz	a0,40029370 <iface_cb+0x248>
		pos += snprintk(str + pos, sizeof(str) - pos,
40029354:	40037637          	lui	a2,0x40037
40029358:	05100593          	li	a1,81
4002935c:	409585b3          	sub	a1,a1,s1
40029360:	00998533          	add	a0,s3,s1
40029364:	05c60613          	addi	a2,a2,92 # 4003705c <CSWTCH.15846+0x19fc>
40029368:	9b5d80ef          	jal	ra,40001d1c <snprintk>
4002936c:	00a484b3          	add	s1,s1,a0
	PR("Flags     : %s\n", iface_flags2str(iface));
40029370:	00812503          	lw	a0,8(sp)
40029374:	40037637          	lui	a2,0x40037
	str[pos - 1] = '\0';
40029378:	009989b3          	add	s3,s3,s1
	PR("Flags     : %s\n", iface_flags2str(iface));
4002937c:	f98a0693          	addi	a3,s4,-104
40029380:	06460613          	addi	a2,a2,100 # 40037064 <CSWTCH.15846+0x1a04>
40029384:	00800593          	li	a1,8
	str[pos - 1] = '\0';
40029388:	fe098fa3          	sb	zero,-1(s3)
	PR("Flags     : %s\n", iface_flags2str(iface));
4002938c:	b61df0ef          	jal	ra,40008eec <shell_fprintf>
	if (!iface || !iface->if_dev) {
40029390:	00092783          	lw	a5,0(s2)
40029394:	12079c63          	bnez	a5,400294cc <iface_cb+0x3a4>
	if (!net_if_flag_is_set(iface, NET_IF_IPV6)) {
40029398:	00700593          	li	a1,7
4002939c:	00090513          	mv	a0,s2
400293a0:	dcdfd0ef          	jal	ra,4002716c <net_if_flag_is_set>
400293a4:	1a051463          	bnez	a0,4002954c <iface_cb+0x424>
		PR("%s not %s for this interface.\n", "IPv6", "enabled");
400293a8:	00812503          	lw	a0,8(sp)
400293ac:	40033737          	lui	a4,0x40033
400293b0:	400376b7          	lui	a3,0x40037
400293b4:	40037637          	lui	a2,0x40037
400293b8:	b8070713          	addi	a4,a4,-1152 # 40032b80 <severity+0x14>
400293bc:	0a068693          	addi	a3,a3,160 # 400370a0 <CSWTCH.15846+0x1a40>
400293c0:	0a860613          	addi	a2,a2,168 # 400370a8 <CSWTCH.15846+0x1a48>
400293c4:	00800593          	li	a1,8
400293c8:	b25df0ef          	jal	ra,40008eec <shell_fprintf>
	if (!net_if_flag_is_set(iface, NET_IF_IPV4)) {
400293cc:	00600593          	li	a1,6
400293d0:	00090513          	mv	a0,s2
400293d4:	d99fd0ef          	jal	ra,4002716c <net_if_flag_is_set>
400293d8:	4e051a63          	bnez	a0,400298cc <iface_cb+0x7a4>
}
400293dc:	05812403          	lw	s0,88(sp)
		PR("%s not %s for this interface.\n", "IPv4", "enabled");
400293e0:	00812503          	lw	a0,8(sp)
}
400293e4:	05c12083          	lw	ra,92(sp)
400293e8:	05412483          	lw	s1,84(sp)
400293ec:	05012903          	lw	s2,80(sp)
400293f0:	04c12983          	lw	s3,76(sp)
400293f4:	04812a03          	lw	s4,72(sp)
400293f8:	04412a83          	lw	s5,68(sp)
400293fc:	04012b03          	lw	s6,64(sp)
40029400:	03c12b83          	lw	s7,60(sp)
40029404:	03812c03          	lw	s8,56(sp)
40029408:	03412c83          	lw	s9,52(sp)
4002940c:	03012d03          	lw	s10,48(sp)
40029410:	02c12d83          	lw	s11,44(sp)
		PR("%s not %s for this interface.\n", "IPv4", "enabled");
40029414:	40033737          	lui	a4,0x40033
40029418:	400376b7          	lui	a3,0x40037
4002941c:	40037637          	lui	a2,0x40037
40029420:	b8070713          	addi	a4,a4,-1152 # 40032b80 <severity+0x14>
40029424:	1e868693          	addi	a3,a3,488 # 400371e8 <CSWTCH.15846+0x1b88>
40029428:	0a860613          	addi	a2,a2,168 # 400370a8 <CSWTCH.15846+0x1a48>
4002942c:	00800593          	li	a1,8
}
40029430:	06010113          	addi	sp,sp,96
		PR("%s not %s for this interface.\n", "IPv4", "enabled");
40029434:	ab9df06f          	j	40008eec <shell_fprintf>
		PR_INFO("Interface is down.\n");
40029438:	00812503          	lw	a0,8(sp)
4002943c:	40037637          	lui	a2,0x40037
40029440:	fc860613          	addi	a2,a2,-56 # 40036fc8 <CSWTCH.15846+0x1968>
40029444:	00200593          	li	a1,2
40029448:	aa5df0ef          	jal	ra,40008eec <shell_fprintf>
		if (data->user_data == NULL) {
4002944c:	0044a783          	lw	a5,4(s1)
40029450:	d80794e3          	bnez	a5,400291d8 <iface_cb+0xb0>
}
40029454:	05c12083          	lw	ra,92(sp)
40029458:	05812403          	lw	s0,88(sp)
4002945c:	05412483          	lw	s1,84(sp)
40029460:	05012903          	lw	s2,80(sp)
40029464:	04c12983          	lw	s3,76(sp)
40029468:	04812a03          	lw	s4,72(sp)
4002946c:	04412a83          	lw	s5,68(sp)
40029470:	04012b03          	lw	s6,64(sp)
40029474:	03c12b83          	lw	s7,60(sp)
40029478:	03812c03          	lw	s8,56(sp)
4002947c:	03412c83          	lw	s9,52(sp)
40029480:	03012d03          	lw	s10,48(sp)
40029484:	02c12d83          	lw	s11,44(sp)
40029488:	06010113          	addi	sp,sp,96
4002948c:	00008067          	ret
40029490:	0147c583          	lbu	a1,20(a5)
40029494:	4003b637          	lui	a2,0x4003b
40029498:	01800693          	li	a3,24
4002949c:	fec60613          	addi	a2,a2,-20 # 4003afec <buf.1>
400294a0:	ff5ea0ef          	jal	ra,40014494 <net_sprint_ll_addr_buf>
400294a4:	00050693          	mv	a3,a0
		PR("Link addr : %s\n",
400294a8:	00812503          	lw	a0,8(sp)
400294ac:	40037637          	lui	a2,0x40037
400294b0:	fdc60613          	addi	a2,a2,-36 # 40036fdc <CSWTCH.15846+0x197c>
400294b4:	00800593          	li	a1,8
400294b8:	a35df0ef          	jal	ra,40008eec <shell_fprintf>
	if (iface == NULL) {
400294bc:	d29ff06f          	j	400291e4 <iface_cb+0xbc>
		pos += snprintk(str + pos, sizeof(str) - pos,
400294c0:	40037637          	lui	a2,0x40037
400294c4:	02860613          	addi	a2,a2,40 # 40037028 <CSWTCH.15846+0x19c8>
400294c8:	dc5ff06f          	j	4002928c <iface_cb+0x164>
	if (net_if_l2(iface) == &NET_L2_GET_NAME(ETHERNET)) {
400294cc:	0047a703          	lw	a4,4(a5)
400294d0:	400457b7          	lui	a5,0x40045
400294d4:	ab878793          	addi	a5,a5,-1352 # 40044ab8 <_net_l2_ETHERNET>
400294d8:	ecf710e3          	bne	a4,a5,40029398 <iface_cb+0x270>
		PR("Ethernet capabilities supported:\n");
400294dc:	00812503          	lw	a0,8(sp)
400294e0:	40037637          	lui	a2,0x40037
400294e4:	07460613          	addi	a2,a2,116 # 40037074 <CSWTCH.15846+0x1a14>
400294e8:	00800593          	li	a1,8
400294ec:	a01df0ef          	jal	ra,40008eec <shell_fprintf>
	return iface->if_dev->dev;
400294f0:	00092783          	lw	a5,0(s2)
		return (enum ethernet_hw_caps)0;
400294f4:	00000993          	li	s3,0
400294f8:	0007a503          	lw	a0,0(a5)
	if (!eth->get_capabilities) {
400294fc:	00852783          	lw	a5,8(a0)
40029500:	0107a783          	lw	a5,16(a5)
40029504:	00078663          	beqz	a5,40029510 <iface_cb+0x3e8>
	return eth->get_capabilities(net_if_get_device(iface));
40029508:	000780e7          	jalr	a5
4002950c:	00050993          	mv	s3,a0
	for (i = 0; i < ARRAY_SIZE(eth_hw_caps); i++) {
40029510:	400394b7          	lui	s1,0x40039
40029514:	9c848493          	addi	s1,s1,-1592 # 400389c8 <eth_hw_caps>
40029518:	09848a13          	addi	s4,s1,152
			PR("\t%s\n", eth_hw_caps[i].description);
4002951c:	40037ab7          	lui	s5,0x40037
		if (caps & eth_hw_caps[i].capability) {
40029520:	0004a783          	lw	a5,0(s1)
40029524:	00f9f7b3          	and	a5,s3,a5
40029528:	00078c63          	beqz	a5,40029540 <iface_cb+0x418>
			PR("\t%s\n", eth_hw_caps[i].description);
4002952c:	0044a683          	lw	a3,4(s1)
40029530:	00812503          	lw	a0,8(sp)
40029534:	098a8613          	addi	a2,s5,152 # 40037098 <CSWTCH.15846+0x1a38>
40029538:	00800593          	li	a1,8
4002953c:	9b1df0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; i < ARRAY_SIZE(eth_hw_caps); i++) {
40029540:	00848493          	addi	s1,s1,8
40029544:	fc9a1ee3          	bne	s4,s1,40029520 <iface_cb+0x3f8>
40029548:	e51ff06f          	j	40029398 <iface_cb+0x270>
	ipv6 = iface->config.ip.ipv6;
4002954c:	0bc92483          	lw	s1,188(s2)
	PR("IPv6 unicast addresses (max %d):\n", NET_IF_MAX_IPV6_ADDR);
40029550:	00812503          	lw	a0,8(sp)
40029554:	40037637          	lui	a2,0x40037
40029558:	00300693          	li	a3,3
4002955c:	0c860613          	addi	a2,a2,200 # 400370c8 <CSWTCH.15846+0x1a68>
40029560:	00800593          	li	a1,8
40029564:	989df0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_ADDR; i++) {
40029568:	02048463          	beqz	s1,40029590 <iface_cb+0x468>
4002956c:	00448d13          	addi	s10,s1,4
	count = 0;
40029570:	00000d93          	li	s11,0
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_ADDR; i++) {
40029574:	00000993          	li	s3,0
40029578:	00300a13          	li	s4,3
		if (!unicast->is_used) {
4002957c:	03000a93          	li	s5,48
40029580:	00400c13          	li	s8,4
		PR("\t%s %s %s%s%s\n",
40029584:	40037cb7          	lui	s9,0x40037
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_ADDR; i++) {
40029588:	19499a63          	bne	s3,s4,4002971c <iface_cb+0x5f4>
	if (count == 0) {
4002958c:	000d9c63          	bnez	s11,400295a4 <iface_cb+0x47c>
		PR("\t<none>\n");
40029590:	00812503          	lw	a0,8(sp)
40029594:	40037637          	lui	a2,0x40037
40029598:	d2c60613          	addi	a2,a2,-724 # 40036d2c <CSWTCH.15846+0x16cc>
4002959c:	00800593          	li	a1,8
400295a0:	94ddf0ef          	jal	ra,40008eec <shell_fprintf>
	PR("IPv6 multicast addresses (max %d):\n", NET_IF_MAX_IPV6_MADDR);
400295a4:	00812503          	lw	a0,8(sp)
400295a8:	40037637          	lui	a2,0x40037
400295ac:	00400693          	li	a3,4
400295b0:	0fc60613          	addi	a2,a2,252 # 400370fc <CSWTCH.15846+0x1a9c>
400295b4:	00800593          	li	a1,8
400295b8:	935df0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
400295bc:	02048263          	beqz	s1,400295e0 <iface_cb+0x4b8>
400295c0:	09448593          	addi	a1,s1,148
	count = 0;
400295c4:	00000993          	li	s3,0
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
400295c8:	00000793          	li	a5,0
400295cc:	00400b13          	li	s6,4
		if (!mcast->is_used) {
400295d0:	01800b93          	li	s7,24
		PR("\t%s\n", net_sprint_ipv6_addr(&mcast->address.in6_addr));
400295d4:	40037a37          	lui	s4,0x40037
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
400295d8:	23679863          	bne	a5,s6,40029808 <iface_cb+0x6e0>
	if (count == 0) {
400295dc:	00099c63          	bnez	s3,400295f4 <iface_cb+0x4cc>
		PR("\t<none>\n");
400295e0:	00812503          	lw	a0,8(sp)
400295e4:	40037637          	lui	a2,0x40037
400295e8:	d2c60613          	addi	a2,a2,-724 # 40036d2c <CSWTCH.15846+0x16cc>
400295ec:	00800593          	li	a1,8
400295f0:	8fddf0ef          	jal	ra,40008eec <shell_fprintf>
	PR("IPv6 prefixes (max %d):\n", NET_IF_MAX_IPV6_PREFIX);
400295f4:	00812503          	lw	a0,8(sp)
400295f8:	40037637          	lui	a2,0x40037
400295fc:	00200693          	li	a3,2
40029600:	12060613          	addi	a2,a2,288 # 40037120 <CSWTCH.15846+0x1ac0>
40029604:	00800593          	li	a1,8
40029608:	8e5df0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_PREFIX; i++) {
4002960c:	02048a63          	beqz	s1,40029640 <iface_cb+0x518>
		PR("\t%s/%d%s\n",
40029610:	40033ab7          	lui	s5,0x40033
40029614:	40037b37          	lui	s6,0x40037
40029618:	10048a13          	addi	s4,s1,256
	count = 0;
4002961c:	00000413          	li	s0,0
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_PREFIX; i++) {
40029620:	00000793          	li	a5,0
40029624:	00200c13          	li	s8,2
		if (!prefix->is_used) {
40029628:	02800c93          	li	s9,40
		PR("\t%s/%d%s\n",
4002962c:	1e8a8a93          	addi	s5,s5,488 # 400331e8 <severity_lvls+0xf0>
40029630:	fb0b0b13          	addi	s6,s6,-80 # 40036fb0 <CSWTCH.15846+0x1950>
40029634:	40037d37          	lui	s10,0x40037
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_PREFIX; i++) {
40029638:	23879063          	bne	a5,s8,40029858 <iface_cb+0x730>
	if (count == 0) {
4002963c:	00041c63          	bnez	s0,40029654 <iface_cb+0x52c>
		PR("\t<none>\n");
40029640:	00812503          	lw	a0,8(sp)
40029644:	40037637          	lui	a2,0x40037
40029648:	d2c60613          	addi	a2,a2,-724 # 40036d2c <CSWTCH.15846+0x16cc>
4002964c:	00800593          	li	a1,8
40029650:	89ddf0ef          	jal	ra,40008eec <shell_fprintf>
	router = net_if_ipv6_router_find_default(iface, NULL);
40029654:	00000593          	li	a1,0
40029658:	00090513          	mv	a0,s2
4002965c:	c84e90ef          	jal	ra,40012ae0 <net_if_ipv6_router_find_default>
40029660:	00050993          	mv	s3,a0
	if (router) {
40029664:	04050863          	beqz	a0,400296b4 <iface_cb+0x58c>
		PR("IPv6 default router :\n");
40029668:	00812503          	lw	a0,8(sp)
4002966c:	40037637          	lui	a2,0x40037
40029670:	14860613          	addi	a2,a2,328 # 40037148 <CSWTCH.15846+0x1ae8>
40029674:	00800593          	li	a1,8
40029678:	875df0ef          	jal	ra,40008eec <shell_fprintf>
		PR("\t%s%s\n",
4002967c:	00898593          	addi	a1,s3,8
40029680:	00200513          	li	a0,2
40029684:	a30eb0ef          	jal	ra,400148b4 <net_sprint_addr>
40029688:	0229c783          	lbu	a5,34(s3)
4002968c:	00050693          	mv	a3,a0
40029690:	0047f793          	andi	a5,a5,4
40029694:	22078663          	beqz	a5,400298c0 <iface_cb+0x798>
40029698:	40037737          	lui	a4,0x40037
4002969c:	fb070713          	addi	a4,a4,-80 # 40036fb0 <CSWTCH.15846+0x1950>
400296a0:	00812503          	lw	a0,8(sp)
400296a4:	40037637          	lui	a2,0x40037
400296a8:	16060613          	addi	a2,a2,352 # 40037160 <CSWTCH.15846+0x1b00>
400296ac:	00800593          	li	a1,8
400296b0:	83ddf0ef          	jal	ra,40008eec <shell_fprintf>
	if (ipv6) {
400296b4:	d0048ce3          	beqz	s1,400293cc <iface_cb+0x2a4>
		PR("IPv6 hop limit           : %d\n",
400296b8:	1554c683          	lbu	a3,341(s1)
400296bc:	00812503          	lw	a0,8(sp)
400296c0:	40037637          	lui	a2,0x40037
400296c4:	16860613          	addi	a2,a2,360 # 40037168 <CSWTCH.15846+0x1b08>
400296c8:	00800593          	li	a1,8
400296cc:	821df0ef          	jal	ra,40008eec <shell_fprintf>
		PR("IPv6 base reachable time : %d\n",
400296d0:	1404a683          	lw	a3,320(s1)
400296d4:	00812503          	lw	a0,8(sp)
400296d8:	40037637          	lui	a2,0x40037
400296dc:	18860613          	addi	a2,a2,392 # 40037188 <CSWTCH.15846+0x1b28>
400296e0:	00800593          	li	a1,8
400296e4:	809df0ef          	jal	ra,40008eec <shell_fprintf>
		PR("IPv6 reachable time      : %d\n",
400296e8:	1444a683          	lw	a3,324(s1)
400296ec:	00812503          	lw	a0,8(sp)
400296f0:	40037637          	lui	a2,0x40037
400296f4:	1a860613          	addi	a2,a2,424 # 400371a8 <CSWTCH.15846+0x1b48>
400296f8:	00800593          	li	a1,8
400296fc:	ff0df0ef          	jal	ra,40008eec <shell_fprintf>
		PR("IPv6 retransmit timer    : %d\n",
40029700:	1484a683          	lw	a3,328(s1)
40029704:	00812503          	lw	a0,8(sp)
40029708:	40037637          	lui	a2,0x40037
4002970c:	1c860613          	addi	a2,a2,456 # 400371c8 <CSWTCH.15846+0x1b68>
40029710:	00800593          	li	a1,8
40029714:	fd8df0ef          	jal	ra,40008eec <shell_fprintf>
40029718:	cb5ff06f          	j	400293cc <iface_cb+0x2a4>
		if (!unicast->is_used) {
4002971c:	035987b3          	mul	a5,s3,s5
40029720:	00198b93          	addi	s7,s3,1
40029724:	030d0b13          	addi	s6,s10,48 # 40037030 <CSWTCH.15846+0x19d0>
40029728:	00f487b3          	add	a5,s1,a5
4002972c:	02f7c783          	lbu	a5,47(a5)
40029730:	0027f793          	andi	a5,a5,2
40029734:	00079863          	bnez	a5,40029744 <iface_cb+0x61c>
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_ADDR; i++) {
40029738:	000b8993          	mv	s3,s7
4002973c:	000b0d13          	mv	s10,s6
40029740:	e49ff06f          	j	40029588 <iface_cb+0x460>
		PR("\t%s %s %s%s%s\n",
40029744:	000d0593          	mv	a1,s10
40029748:	00200513          	li	a0,2
4002974c:	968eb0ef          	jal	ra,400148b4 <net_sprint_addr>
40029750:	028d4703          	lbu	a4,40(s10)
40029754:	00050693          	mv	a3,a0
40029758:	08ec6063          	bltu	s8,a4,400297d8 <iface_cb+0x6b0>
4002975c:	400387b7          	lui	a5,0x40038
40029760:	00271713          	slli	a4,a4,0x2
40029764:	37478793          	addi	a5,a5,884 # 40038374 <CSWTCH.236>
40029768:	00e787b3          	add	a5,a5,a4
4002976c:	0007a703          	lw	a4,0(a5)
	switch (addr_state) {
40029770:	029d4783          	lbu	a5,41(s10)
40029774:	00178793          	addi	a5,a5,1
40029778:	0ff7f793          	zext.b	a5,a5
4002977c:	06fa6463          	bltu	s4,a5,400297e4 <iface_cb+0x6bc>
40029780:	40038637          	lui	a2,0x40038
40029784:	00279793          	slli	a5,a5,0x2
40029788:	36460613          	addi	a2,a2,868 # 40038364 <CSWTCH.238>
4002978c:	00f607b3          	add	a5,a2,a5
40029790:	0007a783          	lw	a5,0(a5)
		PR("\t%s %s %s%s%s\n",
40029794:	035989b3          	mul	s3,s3,s5
40029798:	013489b3          	add	s3,s1,s3
4002979c:	02f9c603          	lbu	a2,47(s3)
400297a0:	00167593          	andi	a1,a2,1
400297a4:	04059663          	bnez	a1,400297f0 <iface_cb+0x6c8>
400297a8:	40033837          	lui	a6,0x40033
400297ac:	1e880813          	addi	a6,a6,488 # 400331e8 <severity_lvls+0xf0>
400297b0:	00467613          	andi	a2,a2,4
400297b4:	04060463          	beqz	a2,400297fc <iface_cb+0x6d4>
400297b8:	400378b7          	lui	a7,0x40037
400297bc:	fbc88893          	addi	a7,a7,-68 # 40036fbc <CSWTCH.15846+0x195c>
400297c0:	00812503          	lw	a0,8(sp)
400297c4:	0ecc8613          	addi	a2,s9,236 # 400370ec <CSWTCH.15846+0x1a8c>
400297c8:	00800593          	li	a1,8
400297cc:	f20df0ef          	jal	ra,40008eec <shell_fprintf>
		count++;
400297d0:	001d8d93          	addi	s11,s11,1
400297d4:	f65ff06f          	j	40029738 <iface_cb+0x610>
		PR("\t%s %s %s%s%s\n",
400297d8:	40037737          	lui	a4,0x40037
400297dc:	ae870713          	addi	a4,a4,-1304 # 40036ae8 <CSWTCH.15846+0x1488>
400297e0:	f91ff06f          	j	40029770 <iface_cb+0x648>
	switch (addr_state) {
400297e4:	400357b7          	lui	a5,0x40035
400297e8:	fd878793          	addi	a5,a5,-40 # 40034fd8 <all_nodes_mcast_group.0+0x3c>
400297ec:	fa9ff06f          	j	40029794 <iface_cb+0x66c>
		PR("\t%s %s %s%s%s\n",
400297f0:	40037837          	lui	a6,0x40037
400297f4:	fb080813          	addi	a6,a6,-80 # 40036fb0 <CSWTCH.15846+0x1950>
400297f8:	fb9ff06f          	j	400297b0 <iface_cb+0x688>
400297fc:	400338b7          	lui	a7,0x40033
40029800:	1e888893          	addi	a7,a7,488 # 400331e8 <severity_lvls+0xf0>
40029804:	fbdff06f          	j	400297c0 <iface_cb+0x698>
		if (!mcast->is_used) {
40029808:	03778733          	mul	a4,a5,s7
4002980c:	01858a93          	addi	s5,a1,24
40029810:	00178793          	addi	a5,a5,1
40029814:	00e48733          	add	a4,s1,a4
40029818:	0a474703          	lbu	a4,164(a4)
4002981c:	00177713          	andi	a4,a4,1
40029820:	00071663          	bnez	a4,4002982c <iface_cb+0x704>
40029824:	000a8593          	mv	a1,s5
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
40029828:	db1ff06f          	j	400295d8 <iface_cb+0x4b0>
		PR("\t%s\n", net_sprint_ipv6_addr(&mcast->address.in6_addr));
4002982c:	00200513          	li	a0,2
40029830:	00f12623          	sw	a5,12(sp)
40029834:	880eb0ef          	jal	ra,400148b4 <net_sprint_addr>
40029838:	00050693          	mv	a3,a0
4002983c:	00812503          	lw	a0,8(sp)
40029840:	098a0613          	addi	a2,s4,152 # 40037098 <CSWTCH.15846+0x1a38>
40029844:	00800593          	li	a1,8
40029848:	ea4df0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
4002984c:	00c12783          	lw	a5,12(sp)
		count++;
40029850:	00198993          	addi	s3,s3,1
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
40029854:	fd1ff06f          	j	40029824 <iface_cb+0x6fc>
		if (!prefix->is_used) {
40029858:	03978db3          	mul	s11,a5,s9
4002985c:	00178993          	addi	s3,a5,1
40029860:	028a0b93          	addi	s7,s4,40
40029864:	01b48db3          	add	s11,s1,s11
40029868:	115dc703          	lbu	a4,277(s11)
4002986c:	00277713          	andi	a4,a4,2
40029870:	00071863          	bnez	a4,40029880 <iface_cb+0x758>
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_PREFIX; i++) {
40029874:	00098793          	mv	a5,s3
40029878:	000b8a13          	mv	s4,s7
4002987c:	dbdff06f          	j	40029638 <iface_cb+0x510>
		PR("\t%s/%d%s\n",
40029880:	000a0593          	mv	a1,s4
40029884:	00200513          	li	a0,2
40029888:	82ceb0ef          	jal	ra,400148b4 <net_sprint_addr>
4002988c:	115dc603          	lbu	a2,277(s11)
40029890:	014a4703          	lbu	a4,20(s4)
40029894:	00050693          	mv	a3,a0
40029898:	00167613          	andi	a2,a2,1
4002989c:	000a8793          	mv	a5,s5
400298a0:	00060463          	beqz	a2,400298a8 <iface_cb+0x780>
400298a4:	000b0793          	mv	a5,s6
400298a8:	00812503          	lw	a0,8(sp)
400298ac:	13cd0613          	addi	a2,s10,316
400298b0:	00800593          	li	a1,8
400298b4:	e38df0ef          	jal	ra,40008eec <shell_fprintf>
		count++;
400298b8:	00140413          	addi	s0,s0,1
400298bc:	fb9ff06f          	j	40029874 <iface_cb+0x74c>
		PR("\t%s%s\n",
400298c0:	40033737          	lui	a4,0x40033
400298c4:	1e870713          	addi	a4,a4,488 # 400331e8 <severity_lvls+0xf0>
400298c8:	dd9ff06f          	j	400296a0 <iface_cb+0x578>
	ipv4 = iface->config.ip.ipv4;
400298cc:	0c092483          	lw	s1,192(s2)
	PR("IPv4 unicast addresses (max %d):\n", NET_IF_MAX_IPV4_ADDR);
400298d0:	00812503          	lw	a0,8(sp)
400298d4:	40037637          	lui	a2,0x40037
400298d8:	00100693          	li	a3,1
400298dc:	1f060613          	addi	a2,a2,496 # 400371f0 <CSWTCH.15846+0x1b90>
400298e0:	00800593          	li	a1,8
400298e4:	e08df0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; ipv4 && i < NET_IF_MAX_IPV4_ADDR; i++) {
400298e8:	18048063          	beqz	s1,40029a68 <iface_cb+0x940>
		if (!unicast->is_used) {
400298ec:	02f4c783          	lbu	a5,47(s1)
400298f0:	0027f793          	andi	a5,a5,2
400298f4:	16078a63          	beqz	a5,40029a68 <iface_cb+0x940>
		PR("\t%s %s %s%s\n",
400298f8:	00448593          	addi	a1,s1,4
400298fc:	00100513          	li	a0,1
40029900:	fb5ea0ef          	jal	ra,400148b4 <net_sprint_addr>
40029904:	02c4c703          	lbu	a4,44(s1)
	switch (addr_type) {
40029908:	00400793          	li	a5,4
		PR("\t%s %s %s%s\n",
4002990c:	00050693          	mv	a3,a0
40029910:	12e7ea63          	bltu	a5,a4,40029a44 <iface_cb+0x91c>
40029914:	400387b7          	lui	a5,0x40038
40029918:	00271713          	slli	a4,a4,0x2
4002991c:	37478793          	addi	a5,a5,884 # 40038374 <CSWTCH.236>
40029920:	00e787b3          	add	a5,a5,a4
40029924:	0007a703          	lw	a4,0(a5)
	switch (addr_state) {
40029928:	02d4c783          	lbu	a5,45(s1)
4002992c:	00300613          	li	a2,3
40029930:	00178793          	addi	a5,a5,1
40029934:	0ff7f793          	zext.b	a5,a5
40029938:	10f66c63          	bltu	a2,a5,40029a50 <iface_cb+0x928>
4002993c:	40038637          	lui	a2,0x40038
40029940:	00279793          	slli	a5,a5,0x2
40029944:	36460613          	addi	a2,a2,868 # 40038364 <CSWTCH.238>
40029948:	00f607b3          	add	a5,a2,a5
4002994c:	0007a783          	lw	a5,0(a5)
		PR("\t%s %s %s%s\n",
40029950:	02f4c603          	lbu	a2,47(s1)
40029954:	00167613          	andi	a2,a2,1
40029958:	10060263          	beqz	a2,40029a5c <iface_cb+0x934>
4002995c:	40037837          	lui	a6,0x40037
40029960:	fb080813          	addi	a6,a6,-80 # 40036fb0 <CSWTCH.15846+0x1950>
40029964:	00812503          	lw	a0,8(sp)
40029968:	40037637          	lui	a2,0x40037
4002996c:	21460613          	addi	a2,a2,532 # 40037214 <CSWTCH.15846+0x1bb4>
40029970:	00800593          	li	a1,8
40029974:	d78df0ef          	jal	ra,40008eec <shell_fprintf>
	PR("IPv4 multicast addresses (max %d):\n", NET_IF_MAX_IPV4_MADDR);
40029978:	00812503          	lw	a0,8(sp)
4002997c:	40037637          	lui	a2,0x40037
40029980:	00100693          	li	a3,1
40029984:	22460613          	addi	a2,a2,548 # 40037224 <CSWTCH.15846+0x1bc4>
40029988:	00800593          	li	a1,8
4002998c:	d60df0ef          	jal	ra,40008eec <shell_fprintf>
	for (i = 0; ipv4 && i < NET_IF_MAX_IPV4_MADDR; i++) {
40029990:	0e048863          	beqz	s1,40029a80 <iface_cb+0x958>
		if (!mcast->is_used) {
40029994:	0444c783          	lbu	a5,68(s1)
40029998:	0017f793          	andi	a5,a5,1
4002999c:	12078863          	beqz	a5,40029acc <iface_cb+0x9a4>
		PR("\t%s\n", net_sprint_ipv4_addr(&mcast->address.in_addr));
400299a0:	03448593          	addi	a1,s1,52
400299a4:	00100513          	li	a0,1
400299a8:	f0dea0ef          	jal	ra,400148b4 <net_sprint_addr>
400299ac:	00050693          	mv	a3,a0
400299b0:	00812503          	lw	a0,8(sp)
400299b4:	40037637          	lui	a2,0x40037
400299b8:	09860613          	addi	a2,a2,152 # 40037098 <CSWTCH.15846+0x1a38>
400299bc:	00800593          	li	a1,8
400299c0:	d2cdf0ef          	jal	ra,40008eec <shell_fprintf>
		PR("IPv4 gateway : %s\n",
400299c4:	04848593          	addi	a1,s1,72
400299c8:	00100513          	li	a0,1
400299cc:	ee9ea0ef          	jal	ra,400148b4 <net_sprint_addr>
400299d0:	00050693          	mv	a3,a0
400299d4:	00812503          	lw	a0,8(sp)
400299d8:	40037637          	lui	a2,0x40037
400299dc:	24860613          	addi	a2,a2,584 # 40037248 <CSWTCH.15846+0x1be8>
400299e0:	00800593          	li	a1,8
400299e4:	d08df0ef          	jal	ra,40008eec <shell_fprintf>
		PR("IPv4 netmask : %s\n",
400299e8:	04c48593          	addi	a1,s1,76
400299ec:	00100513          	li	a0,1
400299f0:	ec5ea0ef          	jal	ra,400148b4 <net_sprint_addr>
}
400299f4:	05812403          	lw	s0,88(sp)
400299f8:	05c12083          	lw	ra,92(sp)
400299fc:	05412483          	lw	s1,84(sp)
40029a00:	05012903          	lw	s2,80(sp)
40029a04:	04c12983          	lw	s3,76(sp)
40029a08:	04812a03          	lw	s4,72(sp)
40029a0c:	04412a83          	lw	s5,68(sp)
40029a10:	04012b03          	lw	s6,64(sp)
40029a14:	03c12b83          	lw	s7,60(sp)
40029a18:	03812c03          	lw	s8,56(sp)
40029a1c:	03412c83          	lw	s9,52(sp)
40029a20:	03012d03          	lw	s10,48(sp)
40029a24:	02c12d83          	lw	s11,44(sp)
		PR("IPv4 netmask : %s\n",
40029a28:	00050693          	mv	a3,a0
40029a2c:	00812503          	lw	a0,8(sp)
40029a30:	40037637          	lui	a2,0x40037
40029a34:	25c60613          	addi	a2,a2,604 # 4003725c <CSWTCH.15846+0x1bfc>
40029a38:	00800593          	li	a1,8
}
40029a3c:	06010113          	addi	sp,sp,96
		PR("IPv4 netmask : %s\n",
40029a40:	cacdf06f          	j	40008eec <shell_fprintf>
		PR("\t%s %s %s%s\n",
40029a44:	40037737          	lui	a4,0x40037
40029a48:	ae870713          	addi	a4,a4,-1304 # 40036ae8 <CSWTCH.15846+0x1488>
40029a4c:	eddff06f          	j	40029928 <iface_cb+0x800>
	switch (addr_state) {
40029a50:	400357b7          	lui	a5,0x40035
40029a54:	fd878793          	addi	a5,a5,-40 # 40034fd8 <all_nodes_mcast_group.0+0x3c>
40029a58:	ef9ff06f          	j	40029950 <iface_cb+0x828>
		PR("\t%s %s %s%s\n",
40029a5c:	40033837          	lui	a6,0x40033
40029a60:	1e880813          	addi	a6,a6,488 # 400331e8 <severity_lvls+0xf0>
40029a64:	f01ff06f          	j	40029964 <iface_cb+0x83c>
		PR("\t<none>\n");
40029a68:	00812503          	lw	a0,8(sp)
40029a6c:	40037637          	lui	a2,0x40037
40029a70:	d2c60613          	addi	a2,a2,-724 # 40036d2c <CSWTCH.15846+0x16cc>
40029a74:	00800593          	li	a1,8
40029a78:	c74df0ef          	jal	ra,40008eec <shell_fprintf>
40029a7c:	efdff06f          	j	40029978 <iface_cb+0x850>
}
40029a80:	05812403          	lw	s0,88(sp)
		PR("\t<none>\n");
40029a84:	00812503          	lw	a0,8(sp)
}
40029a88:	05c12083          	lw	ra,92(sp)
40029a8c:	05412483          	lw	s1,84(sp)
40029a90:	05012903          	lw	s2,80(sp)
40029a94:	04c12983          	lw	s3,76(sp)
40029a98:	04812a03          	lw	s4,72(sp)
40029a9c:	04412a83          	lw	s5,68(sp)
40029aa0:	04012b03          	lw	s6,64(sp)
40029aa4:	03c12b83          	lw	s7,60(sp)
40029aa8:	03812c03          	lw	s8,56(sp)
40029aac:	03412c83          	lw	s9,52(sp)
40029ab0:	03012d03          	lw	s10,48(sp)
40029ab4:	02c12d83          	lw	s11,44(sp)
		PR("\t<none>\n");
40029ab8:	40037637          	lui	a2,0x40037
40029abc:	d2c60613          	addi	a2,a2,-724 # 40036d2c <CSWTCH.15846+0x16cc>
40029ac0:	00800593          	li	a1,8
}
40029ac4:	06010113          	addi	sp,sp,96
		PR("\t<none>\n");
40029ac8:	c24df06f          	j	40008eec <shell_fprintf>
40029acc:	00812503          	lw	a0,8(sp)
40029ad0:	40037637          	lui	a2,0x40037
40029ad4:	d2c60613          	addi	a2,a2,-724 # 40036d2c <CSWTCH.15846+0x16cc>
40029ad8:	00800593          	li	a1,8
40029adc:	c10df0ef          	jal	ra,40008eec <shell_fprintf>
40029ae0:	ee5ff06f          	j	400299c4 <iface_cb+0x89c>

40029ae4 <nbr_cb>:
{
40029ae4:	f9010113          	addi	sp,sp,-112
40029ae8:	05512a23          	sw	s5,84(sp)
40029aec:	06112623          	sw	ra,108(sp)
40029af0:	06812423          	sw	s0,104(sp)
40029af4:	06912223          	sw	s1,100(sp)
40029af8:	07212023          	sw	s2,96(sp)
40029afc:	05312e23          	sw	s3,92(sp)
40029b00:	05412c23          	sw	s4,88(sp)
40029b04:	05612823          	sw	s6,80(sp)
40029b08:	05712623          	sw	s7,76(sp)
40029b0c:	05812423          	sw	s8,72(sp)
40029b10:	05912223          	sw	s9,68(sp)
40029b14:	05a12023          	sw	s10,64(sp)
40029b18:	03b12e23          	sw	s11,60(sp)
	const struct shell *sh = data->sh;
40029b1c:	0005a783          	lw	a5,0(a1)
	int *count = data->user_data;
40029b20:	0045ab03          	lw	s6,4(a1)
{
40029b24:	00050a93          	mv	s5,a0
	const struct shell *sh = data->sh;
40029b28:	02f12623          	sw	a5,44(sp)
	if (*count == 0) {
40029b2c:	000b2783          	lw	a5,0(s6)
40029b30:	02079063          	bnez	a5,40029b50 <nbr_cb+0x6c>
		PR("     Neighbor  Interface  Flags    State     "
40029b34:	02c12503          	lw	a0,44(sp)
40029b38:	400336b7          	lui	a3,0x40033
40029b3c:	40037637          	lui	a2,0x40037
40029b40:	1e868693          	addi	a3,a3,488 # 400331e8 <severity_lvls+0xf0>
40029b44:	27c60613          	addi	a2,a2,636 # 4003727c <CSWTCH.15846+0x1c1c>
40029b48:	00800593          	li	a1,8
40029b4c:	ba0df0ef          	jal	ra,40008eec <shell_fprintf>
	(*count)++;
40029b50:	000b2783          	lw	a5,0(s6)
40029b54:	40033437          	lui	s0,0x40033
40029b58:	1e840d93          	addi	s11,s0,488 # 400331e8 <severity_lvls+0xf0>
40029b5c:	00178793          	addi	a5,a5,1
40029b60:	00fb2023          	sw	a5,0(s6)
	state_str = net_ipv6_nbr_state2str(net_ipv6_nbr_data(nbr)->state);
40029b64:	00caa783          	lw	a5,12(s5)
	char *state_pad = "";
40029b68:	1e840413          	addi	s0,s0,488
	state_str = net_ipv6_nbr_state2str(net_ipv6_nbr_data(nbr)->state);
40029b6c:	0307a503          	lw	a0,48(a5)
40029b70:	d1df20ef          	jal	ra,4001c88c <net_ipv6_nbr_state2str>
40029b74:	00050a13          	mv	s4,a0
	if (strlen(state_str) == 5) {
40029b78:	85ce30ef          	jal	ra,4000cbd4 <strlen>
40029b7c:	00500793          	li	a5,5
40029b80:	00f51663          	bne	a0,a5,40029b8c <nbr_cb+0xa8>
		state_pad = "    ";
40029b84:	40037437          	lui	s0,0x40037
40029b88:	27040413          	addi	s0,s0,624 # 40037270 <CSWTCH.15846+0x1c10>
40029b8c:	00caa603          	lw	a2,12(s5)
		    net_ipv6_nbr_data(nbr)->reachable_timeout -
40029b90:	02062783          	lw	a5,32(a2)
	remaining = net_ipv6_nbr_data(nbr)->reachable +
40029b94:	01862983          	lw	s3,24(a2)
40029b98:	01c62603          	lw	a2,28(a2)
		    net_ipv6_nbr_data(nbr)->reachable_timeout -
40029b9c:	41f7d693          	srai	a3,a5,0x1f
	remaining = net_ipv6_nbr_data(nbr)->reachable +
40029ba0:	013789b3          	add	s3,a5,s3
40029ba4:	00f9b7b3          	sltu	a5,s3,a5
40029ba8:	00c686b3          	add	a3,a3,a2
40029bac:	00d78933          	add	s2,a5,a3
40029bb0:	2a5070ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
40029bb4:	00a00793          	li	a5,10
40029bb8:	02b785b3          	mul	a1,a5,a1
	PR("[%2d] %p  %d      %5d/%d/%d/%d  %s%s %6d  %17s%s %s\n",
40029bbc:	000b2b03          	lw	s6,0(s6)
40029bc0:	02a784b3          	mul	s1,a5,a0
40029bc4:	02a7b7b3          	mulhu	a5,a5,a0
	remaining = net_ipv6_nbr_data(nbr)->reachable +
40029bc8:	409984b3          	sub	s1,s3,s1
40029bcc:	0099b9b3          	sltu	s3,s3,s1
40029bd0:	00f58533          	add	a0,a1,a5
40029bd4:	40a90933          	sub	s2,s2,a0
	PR("[%2d] %p  %d      %5d/%d/%d/%d  %s%s %6d  %17s%s %s\n",
40029bd8:	008aa503          	lw	a0,8(s5)
	remaining = net_ipv6_nbr_data(nbr)->reachable +
40029bdc:	41390933          	sub	s2,s2,s3
	PR("[%2d] %p  %d      %5d/%d/%d/%d  %s%s %6d  %17s%s %s\n",
40029be0:	f81e90ef          	jal	ra,40013b60 <net_if_get_by_iface>
40029be4:	00caa783          	lw	a5,12(s5)
40029be8:	000acc03          	lbu	s8,0(s5)
40029bec:	00050993          	mv	s3,a0
40029bf0:	0347db83          	lhu	s7,52(a5)
40029bf4:	0367cc83          	lbu	s9,54(a5)
40029bf8:	0377cd03          	lbu	s10,55(a5)
40029bfc:	00095463          	bgez	s2,40029c04 <nbr_cb+0x120>
40029c00:	00000493          	li	s1,0
40029c04:	001ac503          	lbu	a0,1(s5)
40029c08:	0ff00793          	li	a5,255
40029c0c:	0cf50a63          	beq	a0,a5,40029ce0 <nbr_cb+0x1fc>
40029c10:	8f5f10ef          	jal	ra,4001b504 <net_nbr_get_lladdr>
40029c14:	00050913          	mv	s2,a0
40029c18:	001ac503          	lbu	a0,1(s5)
40029c1c:	8e9f10ef          	jal	ra,4001b504 <net_nbr_get_lladdr>
40029c20:	00154583          	lbu	a1,1(a0)
40029c24:	4003b637          	lui	a2,0x4003b
40029c28:	00290513          	addi	a0,s2,2
40029c2c:	01800693          	li	a3,24
40029c30:	fec60613          	addi	a2,a2,-20 # 4003afec <buf.1>
40029c34:	861ea0ef          	jal	ra,40014494 <net_sprint_ll_addr_buf>
40029c38:	00050913          	mv	s2,a0
40029c3c:	001ac503          	lbu	a0,1(s5)
40029c40:	0ff00793          	li	a5,255
40029c44:	00f50463          	beq	a0,a5,40029c4c <nbr_cb+0x168>
40029c48:	8bdf10ef          	jal	ra,4001b504 <net_nbr_get_lladdr>
40029c4c:	00caa583          	lw	a1,12(s5)
40029c50:	00200513          	li	a0,2
40029c54:	00458593          	addi	a1,a1,4
40029c58:	c5dea0ef          	jal	ra,400148b4 <net_sprint_addr>
40029c5c:	00a12e23          	sw	a0,28(sp)
40029c60:	02c12503          	lw	a0,44(sp)
40029c64:	40037637          	lui	a2,0x40037
40029c68:	01b12c23          	sw	s11,24(sp)
40029c6c:	01212a23          	sw	s2,20(sp)
40029c70:	00912823          	sw	s1,16(sp)
40029c74:	00812623          	sw	s0,12(sp)
40029c78:	01412423          	sw	s4,8(sp)
40029c7c:	01a12223          	sw	s10,4(sp)
40029c80:	01912023          	sw	s9,0(sp)
40029c84:	000c0893          	mv	a7,s8
40029c88:	000b8813          	mv	a6,s7
40029c8c:	00098793          	mv	a5,s3
40029c90:	000a8713          	mv	a4,s5
40029c94:	000b0693          	mv	a3,s6
40029c98:	2d060613          	addi	a2,a2,720 # 400372d0 <CSWTCH.15846+0x1c70>
40029c9c:	00800593          	li	a1,8
40029ca0:	a4cdf0ef          	jal	ra,40008eec <shell_fprintf>
}
40029ca4:	06c12083          	lw	ra,108(sp)
40029ca8:	06812403          	lw	s0,104(sp)
40029cac:	06412483          	lw	s1,100(sp)
40029cb0:	06012903          	lw	s2,96(sp)
40029cb4:	05c12983          	lw	s3,92(sp)
40029cb8:	05812a03          	lw	s4,88(sp)
40029cbc:	05412a83          	lw	s5,84(sp)
40029cc0:	05012b03          	lw	s6,80(sp)
40029cc4:	04c12b83          	lw	s7,76(sp)
40029cc8:	04812c03          	lw	s8,72(sp)
40029ccc:	04412c83          	lw	s9,68(sp)
40029cd0:	04012d03          	lw	s10,64(sp)
40029cd4:	03c12d83          	lw	s11,60(sp)
40029cd8:	07010113          	addi	sp,sp,112
40029cdc:	00008067          	ret
	PR("[%2d] %p  %d      %5d/%d/%d/%d  %s%s %6d  %17s%s %s\n",
40029ce0:	40037937          	lui	s2,0x40037
40029ce4:	27890913          	addi	s2,s2,632 # 40037278 <CSWTCH.15846+0x1c18>
40029ce8:	f55ff06f          	j	40029c3c <nbr_cb+0x158>

40029cec <arp_cb>:
{
40029cec:	fd010113          	addi	sp,sp,-48
40029cf0:	02812423          	sw	s0,40(sp)
40029cf4:	02112623          	sw	ra,44(sp)
40029cf8:	02912223          	sw	s1,36(sp)
40029cfc:	03212023          	sw	s2,32(sp)
40029d00:	01312e23          	sw	s3,28(sp)
	int *count = data->user_data;
40029d04:	0045a483          	lw	s1,4(a1)
	const struct shell *sh = data->sh;
40029d08:	0005a903          	lw	s2,0(a1)
{
40029d0c:	00050413          	mv	s0,a0
	if (*count == 0) {
40029d10:	0004a783          	lw	a5,0(s1)
40029d14:	00079c63          	bnez	a5,40029d2c <arp_cb+0x40>
		PR("     Interface  Link              Address\n");
40029d18:	40037637          	lui	a2,0x40037
40029d1c:	30860613          	addi	a2,a2,776 # 40037308 <CSWTCH.15846+0x1ca8>
40029d20:	00800593          	li	a1,8
40029d24:	00090513          	mv	a0,s2
40029d28:	9c4df0ef          	jal	ra,40008eec <shell_fprintf>
	PR("[%2d] %d          %s %s\n", *count,
40029d2c:	00842503          	lw	a0,8(s0)
40029d30:	0004a983          	lw	s3,0(s1)
40029d34:	e2de90ef          	jal	ra,40013b60 <net_if_get_by_iface>
40029d38:	4003b637          	lui	a2,0x4003b
40029d3c:	00a12623          	sw	a0,12(sp)
40029d40:	01800693          	li	a3,24
40029d44:	fec60613          	addi	a2,a2,-20 # 4003afec <buf.1>
40029d48:	00600593          	li	a1,6
40029d4c:	01040513          	addi	a0,s0,16
40029d50:	f44ea0ef          	jal	ra,40014494 <net_sprint_ll_addr_buf>
40029d54:	00a12423          	sw	a0,8(sp)
40029d58:	00c40593          	addi	a1,s0,12
40029d5c:	00100513          	li	a0,1
40029d60:	b55ea0ef          	jal	ra,400148b4 <net_sprint_addr>
40029d64:	00812783          	lw	a5,8(sp)
40029d68:	00c12703          	lw	a4,12(sp)
40029d6c:	40037637          	lui	a2,0x40037
40029d70:	00050813          	mv	a6,a0
40029d74:	00098693          	mv	a3,s3
40029d78:	00090513          	mv	a0,s2
40029d7c:	33460613          	addi	a2,a2,820 # 40037334 <CSWTCH.15846+0x1cd4>
40029d80:	00800593          	li	a1,8
40029d84:	968df0ef          	jal	ra,40008eec <shell_fprintf>
	(*count)++;
40029d88:	0004a783          	lw	a5,0(s1)
40029d8c:	00178793          	addi	a5,a5,1
40029d90:	00f4a023          	sw	a5,0(s1)
}
40029d94:	02c12083          	lw	ra,44(sp)
40029d98:	02812403          	lw	s0,40(sp)
40029d9c:	02412483          	lw	s1,36(sp)
40029da0:	02012903          	lw	s2,32(sp)
40029da4:	01c12983          	lw	s3,28(sp)
40029da8:	03010113          	addi	sp,sp,48
40029dac:	00008067          	ret

40029db0 <net_shell_init>:

	(void)cmd_net_events_on(shell_backend_uart_get_ptr(), 1, argv);
#endif

	return 0;
}
40029db0:	00000513          	li	a0,0
40029db4:	00008067          	ret

40029db8 <z_log_msg_static_create.constprop.0>:
40029db8:	00000693          	li	a3,0
40029dbc:	9d8db06f          	j	40004f94 <z_impl_z_log_msg_static_create>

40029dc0 <net_if_flag_is_set>:
	if (iface == NULL) {
40029dc0:	02050c63          	beqz	a0,40029df8 <net_if_flag_is_set+0x38>
{
40029dc4:	ff010113          	addi	sp,sp,-16
40029dc8:	00812423          	sw	s0,8(sp)
40029dcc:	00112623          	sw	ra,12(sp)
	return atomic_test_bit(iface->if_dev->flags, value);
40029dd0:	00052503          	lw	a0,0(a0)
40029dd4:	00058413          	mv	s0,a1
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
40029dd8:	00c50513          	addi	a0,a0,12
40029ddc:	4ad070ef          	jal	ra,40031a88 <atomic_get>
}
40029de0:	00c12083          	lw	ra,12(sp)
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
40029de4:	40855533          	sra	a0,a0,s0
40029de8:	00812403          	lw	s0,8(sp)
40029dec:	00157513          	andi	a0,a0,1
40029df0:	01010113          	addi	sp,sp,16
40029df4:	00008067          	ret
		return false;
40029df8:	00000513          	li	a0,0
}
40029dfc:	00008067          	ret

40029e00 <iface_find_cb>:

static void iface_find_cb(struct net_if *iface, void *user_data)
{
	struct net_if **iface_to_use = user_data;

	if (*iface_to_use == NULL &&
40029e00:	0005a783          	lw	a5,0(a1)
40029e04:	04079063          	bnez	a5,40029e44 <iface_find_cb+0x44>
{
40029e08:	ff010113          	addi	sp,sp,-16
40029e0c:	00812423          	sw	s0,8(sp)
40029e10:	00058413          	mv	s0,a1
	    !net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
40029e14:	00300593          	li	a1,3
{
40029e18:	00912223          	sw	s1,4(sp)
40029e1c:	00112623          	sw	ra,12(sp)
40029e20:	00050493          	mv	s1,a0
	    !net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
40029e24:	f9dff0ef          	jal	ra,40029dc0 <net_if_flag_is_set>
	if (*iface_to_use == NULL &&
40029e28:	00051463          	bnez	a0,40029e30 <iface_find_cb+0x30>
		*iface_to_use = iface;
40029e2c:	00942023          	sw	s1,0(s0)
		return;
	}
}
40029e30:	00c12083          	lw	ra,12(sp)
40029e34:	00812403          	lw	s0,8(sp)
40029e38:	00412483          	lw	s1,4(sp)
40029e3c:	01010113          	addi	sp,sp,16
40029e40:	00008067          	ret
40029e44:	00008067          	ret

40029e48 <iface_up_handler.part.0>:
static void iface_up_handler(struct net_mgmt_event_callback *cb,
40029e48:	fe010113          	addi	sp,sp,-32
40029e4c:	00812c23          	sw	s0,24(sp)
40029e50:	01212823          	sw	s2,16(sp)
40029e54:	00112e23          	sw	ra,28(sp)
40029e58:	00912a23          	sw	s1,20(sp)
40029e5c:	01312623          	sw	s3,12(sp)
40029e60:	02010413          	addi	s0,sp,32
		NET_INFO("Interface %d (%p) coming up",
40029e64:	40044937          	lui	s2,0x40044
40029e68:	75092783          	lw	a5,1872(s2) # 40044750 <log_dynamic_net_config>
40029e6c:	00200713          	li	a4,2
40029e70:	0077f793          	andi	a5,a5,7
40029e74:	04f77663          	bgeu	a4,a5,40029ec0 <iface_up_handler.part.0+0x78>
40029e78:	00050493          	mv	s1,a0
40029e7c:	00010993          	mv	s3,sp
40029e80:	ce1e90ef          	jal	ra,40013b60 <net_if_get_by_iface>
40029e84:	fe010113          	addi	sp,sp,-32
40029e88:	00010613          	mv	a2,sp
40029e8c:	400397b7          	lui	a5,0x40039
40029e90:	a6078793          	addi	a5,a5,-1440 # 40038a60 <eth_hw_caps+0x98>
40029e94:	00f62a23          	sw	a5,20(a2)
40029e98:	000025b7          	lui	a1,0x2
40029e9c:	00400793          	li	a5,4
40029ea0:	00a62c23          	sw	a0,24(a2)
40029ea4:	00962e23          	sw	s1,28(a2)
40029ea8:	00f62823          	sw	a5,16(a2)
40029eac:	0c058593          	addi	a1,a1,192 # 20c0 <CONFIG_SRAM_SIZE+0xc0>
40029eb0:	01060613          	addi	a2,a2,16
40029eb4:	75090513          	addi	a0,s2,1872
40029eb8:	f01ff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
40029ebc:	00098113          	mv	sp,s3
	z_impl_k_sem_reset(sem);
40029ec0:	40045537          	lui	a0,0x40045
40029ec4:	8c850513          	addi	a0,a0,-1848 # 400448c8 <counter>
40029ec8:	335050ef          	jal	ra,4002f9fc <z_impl_k_sem_reset>
	z_impl_k_sem_give(sem);
40029ecc:	40045537          	lui	a0,0x40045
40029ed0:	91050513          	addi	a0,a0,-1776 # 40044910 <waiter>
40029ed4:	265050ef          	jal	ra,4002f938 <z_impl_k_sem_give>
}
40029ed8:	fe040113          	addi	sp,s0,-32
40029edc:	01c12083          	lw	ra,28(sp)
40029ee0:	01812403          	lw	s0,24(sp)
40029ee4:	01412483          	lw	s1,20(sp)
40029ee8:	01012903          	lw	s2,16(sp)
40029eec:	00c12983          	lw	s3,12(sp)
40029ef0:	02010113          	addi	sp,sp,32
40029ef4:	00008067          	ret

40029ef8 <iface_up_handler>:
	if (mgmt_event == NET_EVENT_IF_UP) {
40029ef8:	d00107b7          	lui	a5,0xd0010
40029efc:	00278793          	addi	a5,a5,2 # d0010002 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd0010003>
{
40029f00:	00060513          	mv	a0,a2
	if (mgmt_event == NET_EVENT_IF_UP) {
40029f04:	00f59463          	bne	a1,a5,40029f0c <iface_up_handler+0x14>
40029f08:	f41ff06f          	j	40029e48 <iface_up_handler.part.0>
}
40029f0c:	00008067          	ret

40029f10 <services_notify_ready>:
{
40029f10:	ff010113          	addi	sp,sp,-16
40029f14:	00112623          	sw	ra,12(sp)
40029f18:	00050593          	mv	a1,a0
	return z_impl_atomic_or(target, value);
40029f1c:	40039537          	lui	a0,0x40039
40029f20:	0e850513          	addi	a0,a0,232 # 400390e8 <services_flags>
40029f24:	389070ef          	jal	ra,40031aac <z_impl_atomic_or>
}
40029f28:	00c12083          	lw	ra,12(sp)
40029f2c:	40045537          	lui	a0,0x40045
40029f30:	91050513          	addi	a0,a0,-1776 # 40044910 <waiter>
40029f34:	01010113          	addi	sp,sp,16
40029f38:	2010506f          	j	4002f938 <z_impl_k_sem_give>

40029f3c <ipv6_event_handler>:
{
40029f3c:	fb010113          	addi	sp,sp,-80
40029f40:	04812423          	sw	s0,72(sp)
40029f44:	04112623          	sw	ra,76(sp)
40029f48:	04912223          	sw	s1,68(sp)
40029f4c:	05212023          	sw	s2,64(sp)
40029f50:	05010413          	addi	s0,sp,80
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
40029f54:	0bc62703          	lw	a4,188(a2)
{
40029f58:	fac42e23          	sw	a2,-68(s0)
	if (!ipv6) {
40029f5c:	02070a63          	beqz	a4,40029f90 <ipv6_event_handler+0x54>
	if (mgmt_event == NET_EVENT_IPV6_ADDR_ADD) {
40029f60:	e06007b7          	lui	a5,0xe0600
40029f64:	00178693          	addi	a3,a5,1 # e0600001 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600002>
40029f68:	08d59463          	bne	a1,a3,40029ff0 <ipv6_event_handler+0xb4>
			if (ipv6->unicast[i].is_used) {
40029f6c:	08c72783          	lw	a5,140(a4)
40029f70:	0197d793          	srli	a5,a5,0x19
40029f74:	0017f793          	andi	a5,a5,1
40029f78:	02078a63          	beqz	a5,40029fac <ipv6_event_handler+0x70>
				memcpy(&laddr,
40029f7c:	01000613          	li	a2,16
40029f80:	06470593          	addi	a1,a4,100
40029f84:	4003b537          	lui	a0,0x4003b
40029f88:	16050513          	addi	a0,a0,352 # 4003b160 <laddr>
40029f8c:	d6de20ef          	jal	ra,4000ccf8 <memcpy>
}
40029f90:	fb040113          	addi	sp,s0,-80
40029f94:	04c12083          	lw	ra,76(sp)
40029f98:	04812403          	lw	s0,72(sp)
40029f9c:	04412483          	lw	s1,68(sp)
40029fa0:	04012903          	lw	s2,64(sp)
40029fa4:	05010113          	addi	sp,sp,80
40029fa8:	00008067          	ret
			if (ipv6->unicast[i].is_used) {
40029fac:	05c72783          	lw	a5,92(a4)
40029fb0:	0197d793          	srli	a5,a5,0x19
40029fb4:	0017f793          	andi	a5,a5,1
40029fb8:	02079863          	bnez	a5,40029fe8 <ipv6_event_handler+0xac>
40029fbc:	02c72783          	lw	a5,44(a4)
40029fc0:	0197d793          	srli	a5,a5,0x19
40029fc4:	0017f793          	andi	a5,a5,1
40029fc8:	fc0784e3          	beqz	a5,40029f90 <ipv6_event_handler+0x54>
		for (i = NET_IF_MAX_IPV6_ADDR - 1; i >= 0; i--) {
40029fcc:	00000793          	li	a5,0
				       &ipv6->unicast[i].address.in6_addr,
40029fd0:	03000693          	li	a3,48
40029fd4:	02d787b3          	mul	a5,a5,a3
				memcpy(&laddr,
40029fd8:	01000613          	li	a2,16
				       &ipv6->unicast[i].address.in6_addr,
40029fdc:	00478793          	addi	a5,a5,4
				memcpy(&laddr,
40029fe0:	00f705b3          	add	a1,a4,a5
40029fe4:	fa1ff06f          	j	40029f84 <ipv6_event_handler+0x48>
		for (i = NET_IF_MAX_IPV6_ADDR - 1; i >= 0; i--) {
40029fe8:	00100793          	li	a5,1
40029fec:	fe5ff06f          	j	40029fd0 <ipv6_event_handler+0x94>
	if (mgmt_event == NET_EVENT_IPV6_DAD_SUCCEED) {
40029ff0:	00d78713          	addi	a4,a5,13
40029ff4:	0ae59c63          	bne	a1,a4,4002a0ac <ipv6_event_handler+0x170>
		ifaddr = net_if_ipv6_addr_lookup(&laddr, &iface);
40029ff8:	4003b937          	lui	s2,0x4003b
40029ffc:	fbc40593          	addi	a1,s0,-68
4002a000:	16090513          	addi	a0,s2,352 # 4003b160 <laddr>
4002a004:	8ace70ef          	jal	ra,400110b0 <net_if_ipv6_addr_lookup>
4002a008:	00050493          	mv	s1,a0
		if (!ifaddr ||
4002a00c:	f80502e3          	beqz	a0,40029f90 <ipv6_event_handler+0x54>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4002a010:	01000613          	li	a2,16
4002a014:	16090593          	addi	a1,s2,352
4002a018:	00450513          	addi	a0,a0,4
4002a01c:	c5de20ef          	jal	ra,4000cc78 <memcmp>
4002a020:	f60518e3          	bnez	a0,40029f90 <ipv6_event_handler+0x54>
		    !(net_ipv6_addr_cmp(&ifaddr->address.in6_addr, &laddr) &&
4002a024:	02d48703          	lb	a4,45(s1)
4002a028:	00100793          	li	a5,1
4002a02c:	f6f712e3          	bne	a4,a5,40029f90 <ipv6_event_handler+0x54>
		NET_INFO("IPv6 address: %s",
4002a030:	400444b7          	lui	s1,0x40044
4002a034:	7504a783          	lw	a5,1872(s1) # 40044750 <log_dynamic_net_config>
4002a038:	00200713          	li	a4,2
4002a03c:	0077f793          	andi	a5,a5,7
4002a040:	06f77063          	bgeu	a4,a5,4002a0a0 <ipv6_event_handler+0x164>
4002a044:	02800693          	li	a3,40
4002a048:	fc840613          	addi	a2,s0,-56
4002a04c:	16090593          	addi	a1,s2,352
4002a050:	00200513          	li	a0,2
4002a054:	d20ea0ef          	jal	ra,40014574 <z_impl_net_addr_ntop>
4002a058:	00010913          	mv	s2,sp
4002a05c:	fe010113          	addi	sp,sp,-32
4002a060:	00010613          	mv	a2,sp
4002a064:	400397b7          	lui	a5,0x40039
4002a068:	a7c78793          	addi	a5,a5,-1412 # 40038a7c <eth_hw_caps+0xb4>
4002a06c:	00f62a23          	sw	a5,20(a2)
4002a070:	20000793          	li	a5,512
4002a074:	00f61e23          	sh	a5,28(a2)
4002a078:	010007b7          	lui	a5,0x1000
4002a07c:	00378793          	addi	a5,a5,3 # 1000003 <__rom_region_size+0xfc7047>
4002a080:	000025b7          	lui	a1,0x2
4002a084:	00a62c23          	sw	a0,24(a2)
4002a088:	00f62823          	sw	a5,16(a2)
4002a08c:	cc058593          	addi	a1,a1,-832 # 1cc0 <CONFIG_HEAP_MEM_POOL_SIZE+0xcc0>
4002a090:	01060613          	addi	a2,a2,16
4002a094:	75048513          	addi	a0,s1,1872
4002a098:	d21ff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
4002a09c:	00090113          	mv	sp,s2
		services_notify_ready(NET_CONFIG_NEED_IPV6);
4002a0a0:	00200513          	li	a0,2
		services_notify_ready(NET_CONFIG_NEED_ROUTER);
4002a0a4:	e6dff0ef          	jal	ra,40029f10 <services_notify_ready>
4002a0a8:	ee9ff06f          	j	40029f90 <ipv6_event_handler+0x54>
	if (mgmt_event == NET_EVENT_IPV6_ROUTER_ADD) {
4002a0ac:	00978793          	addi	a5,a5,9
4002a0b0:	eef590e3          	bne	a1,a5,40029f90 <ipv6_event_handler+0x54>
		services_notify_ready(NET_CONFIG_NEED_ROUTER);
4002a0b4:	00100513          	li	a0,1
4002a0b8:	fedff06f          	j	4002a0a4 <ipv6_event_handler+0x168>

4002a0bc <net_config_init_by_iface>:
{
4002a0bc:	f9010113          	addi	sp,sp,-112
4002a0c0:	06812423          	sw	s0,104(sp)
4002a0c4:	06912223          	sw	s1,100(sp)
4002a0c8:	07212023          	sw	s2,96(sp)
4002a0cc:	05412c23          	sw	s4,88(sp)
4002a0d0:	05512a23          	sw	s5,84(sp)
4002a0d4:	05712623          	sw	s7,76(sp)
4002a0d8:	06112623          	sw	ra,108(sp)
4002a0dc:	05312e23          	sw	s3,92(sp)
4002a0e0:	05612823          	sw	s6,80(sp)
4002a0e4:	05812423          	sw	s8,72(sp)
4002a0e8:	05912223          	sw	s9,68(sp)
4002a0ec:	05a12023          	sw	s10,64(sp)
4002a0f0:	03b12e23          	sw	s11,60(sp)
4002a0f4:	07010413          	addi	s0,sp,112
	int loop = timeout / LOOP_DIVIDER;
4002a0f8:	00a00a13          	li	s4,10
4002a0fc:	0346ca33          	div	s4,a3,s4
{
4002a100:	00050913          	mv	s2,a0
4002a104:	00060b93          	mv	s7,a2
4002a108:	00068a93          	mv	s5,a3
4002a10c:	400444b7          	lui	s1,0x40044
	if (app_info) {
4002a110:	04058e63          	beqz	a1,4002a16c <net_config_init_by_iface+0xb0>
		NET_INFO("%s", app_info);
4002a114:	7504a783          	lw	a5,1872(s1) # 40044750 <log_dynamic_net_config>
4002a118:	00200713          	li	a4,2
4002a11c:	0077f793          	andi	a5,a5,7
4002a120:	04f77663          	bgeu	a4,a5,4002a16c <net_config_init_by_iface+0xb0>
4002a124:	00010993          	mv	s3,sp
4002a128:	fe010113          	addi	sp,sp,-32
4002a12c:	00010613          	mv	a2,sp
4002a130:	400337b7          	lui	a5,0x40033
4002a134:	af878793          	addi	a5,a5,-1288 # 40032af8 <mpsc_config+0x9c>
4002a138:	00f62a23          	sw	a5,20(a2)
4002a13c:	20000793          	li	a5,512
4002a140:	00f61e23          	sh	a5,28(a2)
4002a144:	010007b7          	lui	a5,0x1000
4002a148:	00b62c23          	sw	a1,24(a2)
4002a14c:	00378793          	addi	a5,a5,3 # 1000003 <__rom_region_size+0xfc7047>
4002a150:	000025b7          	lui	a1,0x2
4002a154:	00f62823          	sw	a5,16(a2)
4002a158:	cc058593          	addi	a1,a1,-832 # 1cc0 <CONFIG_HEAP_MEM_POOL_SIZE+0xcc0>
4002a15c:	01060613          	addi	a2,a2,16
4002a160:	75048513          	addi	a0,s1,1872
4002a164:	c55ff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
4002a168:	00098113          	mv	sp,s3
	if (!iface) {
4002a16c:	00091663          	bnez	s2,4002a178 <net_config_init_by_iface+0xbc>
		iface = net_if_get_default();
4002a170:	be1e60ef          	jal	ra,40010d50 <net_if_get_default>
4002a174:	00050913          	mv	s2,a0
		count = -1;
4002a178:	fff00993          	li	s3,-1
	if (timeout < 0) {
4002a17c:	000ac863          	bltz	s5,4002a18c <net_config_init_by_iface+0xd0>
		count = 0;
4002a180:	00000993          	li	s3,0
	} else if (timeout == 0) {
4002a184:	000a8463          	beqz	s5,4002a18c <net_config_init_by_iface+0xd0>
		count = LOOP_DIVIDER;
4002a188:	00a00993          	li	s3,10
	return net_if_flag_is_set(iface, NET_IF_UP) &&
4002a18c:	00000593          	li	a1,0
4002a190:	00090513          	mv	a0,s2
4002a194:	c2dff0ef          	jal	ra,40029dc0 <net_if_flag_is_set>
4002a198:	40045b37          	lui	s6,0x40045
4002a19c:	22050863          	beqz	a0,4002a3cc <net_config_init_by_iface+0x310>
	       net_if_flag_is_set(iface, NET_IF_RUNNING);
4002a1a0:	00800593          	li	a1,8
4002a1a4:	00090513          	mv	a0,s2
4002a1a8:	c19ff0ef          	jal	ra,40029dc0 <net_if_flag_is_set>
	return net_if_flag_is_set(iface, NET_IF_UP) &&
4002a1ac:	22050063          	beqz	a0,4002a3cc <net_config_init_by_iface+0x310>
	z_impl_k_sem_reset(sem);
4002a1b0:	8c8b0513          	addi	a0,s6,-1848 # 400448c8 <counter>
4002a1b4:	049050ef          	jal	ra,4002f9fc <z_impl_k_sem_reset>
	z_impl_k_sem_give(sem);
4002a1b8:	40045537          	lui	a0,0x40045
4002a1bc:	91050513          	addi	a0,a0,-1776 # 40044910 <waiter>
4002a1c0:	778050ef          	jal	ra,4002f938 <z_impl_k_sem_give>
	return z_impl_net_addr_pton(family, src, dst);
4002a1c4:	40039b37          	lui	s6,0x40039
4002a1c8:	fac40613          	addi	a2,s0,-84
4002a1cc:	ab8b0593          	addi	a1,s6,-1352 # 40038ab8 <eth_hw_caps+0xf0>
4002a1d0:	00100513          	li	a0,1
4002a1d4:	f14ea0ef          	jal	ra,400148e8 <z_impl_net_addr_pton>
	if (net_addr_pton(AF_INET, CONFIG_NET_CONFIG_MY_IPV4_ADDR, &addr)) {
4002a1d8:	2e050e63          	beqz	a0,4002a4d4 <net_config_init_by_iface+0x418>
		NET_ERR("Invalid address: %s", CONFIG_NET_CONFIG_MY_IPV4_ADDR);
4002a1dc:	7504a783          	lw	a5,1872(s1)
4002a1e0:	0077f793          	andi	a5,a5,7
4002a1e4:	04078863          	beqz	a5,4002a234 <net_config_init_by_iface+0x178>
4002a1e8:	00010c13          	mv	s8,sp
4002a1ec:	fe010113          	addi	sp,sp,-32
4002a1f0:	00010613          	mv	a2,sp
4002a1f4:	400397b7          	lui	a5,0x40039
4002a1f8:	ac878793          	addi	a5,a5,-1336 # 40038ac8 <eth_hw_caps+0x100>
4002a1fc:	00f62a23          	sw	a5,20(a2)
4002a200:	20000793          	li	a5,512
4002a204:	00f61e23          	sh	a5,28(a2)
4002a208:	010007b7          	lui	a5,0x1000
4002a20c:	00378793          	addi	a5,a5,3 # 1000003 <__rom_region_size+0xfc7047>
4002a210:	ab8b0b13          	addi	s6,s6,-1352
4002a214:	000025b7          	lui	a1,0x2
4002a218:	01662c23          	sw	s6,24(a2)
4002a21c:	00f62823          	sw	a5,16(a2)
4002a220:	c4058593          	addi	a1,a1,-960 # 1c40 <CONFIG_HEAP_MEM_POOL_SIZE+0xc40>
4002a224:	01060613          	addi	a2,a2,16
4002a228:	75048513          	addi	a0,s1,1872
4002a22c:	b8dff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
4002a230:	000c0113          	mv	sp,s8
4002a234:	4003bc37          	lui	s8,0x4003b
4002a238:	40039b37          	lui	s6,0x40039
4002a23c:	160c0613          	addi	a2,s8,352 # 4003b160 <laddr>
4002a240:	b00b0593          	addi	a1,s6,-1280 # 40038b00 <eth_hw_caps+0x138>
4002a244:	00200513          	li	a0,2
4002a248:	ea0ea0ef          	jal	ra,400148e8 <z_impl_net_addr_pton>
	if (net_addr_pton(AF_INET6, CONFIG_NET_CONFIG_MY_IPV6_ADDR, &laddr)) {
4002a24c:	04050e63          	beqz	a0,4002a2a8 <net_config_init_by_iface+0x1ec>
		NET_ERR("Invalid address: %s", CONFIG_NET_CONFIG_MY_IPV6_ADDR);
4002a250:	7504a783          	lw	a5,1872(s1)
4002a254:	0077f793          	andi	a5,a5,7
4002a258:	04078863          	beqz	a5,4002a2a8 <net_config_init_by_iface+0x1ec>
4002a25c:	00010c93          	mv	s9,sp
4002a260:	fe010113          	addi	sp,sp,-32
4002a264:	00010613          	mv	a2,sp
4002a268:	400397b7          	lui	a5,0x40039
4002a26c:	ac878793          	addi	a5,a5,-1336 # 40038ac8 <eth_hw_caps+0x100>
4002a270:	00f62a23          	sw	a5,20(a2)
4002a274:	b00b0793          	addi	a5,s6,-1280
4002a278:	00f62c23          	sw	a5,24(a2)
4002a27c:	20000793          	li	a5,512
4002a280:	00f61e23          	sh	a5,28(a2)
4002a284:	010007b7          	lui	a5,0x1000
4002a288:	00378793          	addi	a5,a5,3 # 1000003 <__rom_region_size+0xfc7047>
4002a28c:	000025b7          	lui	a1,0x2
4002a290:	00f62823          	sw	a5,16(a2)
4002a294:	c4058593          	addi	a1,a1,-960 # 1c40 <CONFIG_HEAP_MEM_POOL_SIZE+0xc40>
4002a298:	01060613          	addi	a2,a2,16
4002a29c:	75048513          	addi	a0,s1,1872
4002a2a0:	b19ff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
4002a2a4:	000c8113          	mv	sp,s9
	cb->handler = handler;
4002a2a8:	4003b537          	lui	a0,0x4003b
4002a2ac:	4002a7b7          	lui	a5,0x4002a
4002a2b0:	17050713          	addi	a4,a0,368 # 4003b170 <mgmt6_cb>
4002a2b4:	f3c78793          	addi	a5,a5,-196 # 40029f3c <ipv6_event_handler>
4002a2b8:	00f72223          	sw	a5,4(a4)
	cb->event_mask = mgmt_event_mask;
4002a2bc:	e06007b7          	lui	a5,0xe0600
4002a2c0:	00d78793          	addi	a5,a5,13 # e060000d <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000e>
	net_mgmt_add_event_callback(&mgmt6_cb);
4002a2c4:	17050513          	addi	a0,a0,368
4002a2c8:	00f72423          	sw	a5,8(a4)
4002a2cc:	aa8eb0ef          	jal	ra,40015574 <net_mgmt_add_event_callback>
		ifaddr = net_if_ipv6_addr_add(iface, &laddr,
4002a2d0:	00000693          	li	a3,0
4002a2d4:	00300613          	li	a2,3
4002a2d8:	160c0593          	addi	a1,s8,352
4002a2dc:	00090513          	mv	a0,s2
4002a2e0:	980e70ef          	jal	ra,40011460 <net_if_ipv6_addr_add>
		if (!ifaddr) {
4002a2e4:	04051e63          	bnez	a0,4002a340 <net_config_init_by_iface+0x284>
			NET_ERR("Cannot add %s to interface",
4002a2e8:	7504a783          	lw	a5,1872(s1)
4002a2ec:	0077f793          	andi	a5,a5,7
4002a2f0:	04078863          	beqz	a5,4002a340 <net_config_init_by_iface+0x284>
4002a2f4:	00010c13          	mv	s8,sp
4002a2f8:	fe010113          	addi	sp,sp,-32
4002a2fc:	00010613          	mv	a2,sp
4002a300:	40039737          	lui	a4,0x40039
4002a304:	b0c70713          	addi	a4,a4,-1268 # 40038b0c <eth_hw_caps+0x144>
4002a308:	00e62a23          	sw	a4,20(a2)
4002a30c:	20000713          	li	a4,512
4002a310:	00e61e23          	sh	a4,28(a2)
4002a314:	01000737          	lui	a4,0x1000
4002a318:	00370713          	addi	a4,a4,3 # 1000003 <__rom_region_size+0xfc7047>
4002a31c:	b00b0b13          	addi	s6,s6,-1280
4002a320:	000025b7          	lui	a1,0x2
4002a324:	01662c23          	sw	s6,24(a2)
4002a328:	00e62823          	sw	a4,16(a2)
4002a32c:	c4058593          	addi	a1,a1,-960 # 1c40 <CONFIG_HEAP_MEM_POOL_SIZE+0xc40>
4002a330:	01060613          	addi	a2,a2,16
4002a334:	75048513          	addi	a0,s1,1872
4002a338:	a81ff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
4002a33c:	000c0113          	mv	sp,s8
	    net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {
4002a340:	00b00593          	li	a1,11
4002a344:	00090513          	mv	a0,s2
4002a348:	a79ff0ef          	jal	ra,40029dc0 <net_if_flag_is_set>
	if (!IS_ENABLED(CONFIG_NET_IPV6_DAD) ||
4002a34c:	00050663          	beqz	a0,4002a358 <net_config_init_by_iface+0x29c>
		services_notify_ready(NET_CONFIG_NEED_IPV6);
4002a350:	00200513          	li	a0,2
4002a354:	bbdff0ef          	jal	ra,40029f10 <services_notify_ready>
	if (timeout > 0 && count < 0) {
4002a358:	01505463          	blez	s5,4002a360 <net_config_init_by_iface+0x2a4>
4002a35c:	2809c263          	bltz	s3,4002a5e0 <net_config_init_by_iface+0x524>
		k_sem_take(&waiter, K_MSEC(loop));
4002a360:	000a5463          	bgez	s4,4002a368 <net_config_init_by_iface+0x2ac>
4002a364:	00000a13          	li	s4,0
			return t / ((uint64_t)from_hz / to_hz);
4002a368:	009a0513          	addi	a0,s4,9
4002a36c:	00a00613          	li	a2,10
4002a370:	00000693          	li	a3,0
4002a374:	00000593          	li	a1,0
4002a378:	f41d50ef          	jal	ra,400002b8 <__udivdi3>
4002a37c:	00050913          	mv	s2,a0
4002a380:	00058a13          	mv	s4,a1
	return (atomic_get(&services_flags) & flags) == flags;
4002a384:	40039c37          	lui	s8,0x40039
	return z_impl_k_sem_take(sem, timeout);
4002a388:	40045cb7          	lui	s9,0x40045
4002a38c:	0e8c0513          	addi	a0,s8,232 # 400390e8 <services_flags>
4002a390:	6f8070ef          	jal	ra,40031a88 <atomic_get>
4002a394:	00abf533          	and	a0,s7,a0
	while (!services_are_ready(flags) && count-- > 0) {
4002a398:	00ab8863          	beq	s7,a0,4002a3a8 <net_config_init_by_iface+0x2ec>
4002a39c:	fff98b13          	addi	s6,s3,-1
4002a3a0:	2f304263          	bgtz	s3,4002a684 <net_config_init_by_iface+0x5c8>
4002a3a4:	000b0993          	mv	s3,s6
	if (count == -1 && timeout > 0) {
4002a3a8:	fff00793          	li	a5,-1
	return 0;
4002a3ac:	00000513          	li	a0,0
	if (count == -1 && timeout > 0) {
4002a3b0:	24f99063          	bne	s3,a5,4002a5f0 <net_config_init_by_iface+0x534>
4002a3b4:	23505e63          	blez	s5,4002a5f0 <net_config_init_by_iface+0x534>
		NET_ERR("Timeout while waiting network %s", "setup");
4002a3b8:	7504a783          	lw	a5,1872(s1)
4002a3bc:	0077f793          	andi	a5,a5,7
4002a3c0:	2c079e63          	bnez	a5,4002a69c <net_config_init_by_iface+0x5e0>
		return -ETIMEDOUT;
4002a3c4:	f8c00513          	li	a0,-116
4002a3c8:	2280006f          	j	4002a5f0 <net_config_init_by_iface+0x534>
	NET_INFO("Waiting interface %d (%p) to be up...",
4002a3cc:	7504a783          	lw	a5,1872(s1)
4002a3d0:	00200713          	li	a4,2
4002a3d4:	0077f793          	andi	a5,a5,7
4002a3d8:	04f77663          	bgeu	a4,a5,4002a424 <net_config_init_by_iface+0x368>
4002a3dc:	00090513          	mv	a0,s2
4002a3e0:	f80e90ef          	jal	ra,40013b60 <net_if_get_by_iface>
4002a3e4:	00010c13          	mv	s8,sp
4002a3e8:	fe010113          	addi	sp,sp,-32
4002a3ec:	00010613          	mv	a2,sp
4002a3f0:	400397b7          	lui	a5,0x40039
4002a3f4:	a9078793          	addi	a5,a5,-1392 # 40038a90 <eth_hw_caps+0xc8>
4002a3f8:	00f62a23          	sw	a5,20(a2)
4002a3fc:	000025b7          	lui	a1,0x2
4002a400:	00400793          	li	a5,4
4002a404:	00a62c23          	sw	a0,24(a2)
4002a408:	01262e23          	sw	s2,28(a2)
4002a40c:	00f62823          	sw	a5,16(a2)
4002a410:	0c058593          	addi	a1,a1,192 # 20c0 <CONFIG_SRAM_SIZE+0xc0>
4002a414:	01060613          	addi	a2,a2,16
4002a418:	75048513          	addi	a0,s1,1872
4002a41c:	99dff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
4002a420:	000c0113          	mv	sp,s8
	cb->handler = handler;
4002a424:	4003bc37          	lui	s8,0x4003b
4002a428:	4002a7b7          	lui	a5,0x4002a
4002a42c:	17cc0713          	addi	a4,s8,380 # 4003b17c <mgmt_iface_cb>
4002a430:	ef878793          	addi	a5,a5,-264 # 40029ef8 <iface_up_handler>
4002a434:	00f72223          	sw	a5,4(a4)
	cb->event_mask = mgmt_event_mask;
4002a438:	d00107b7          	lui	a5,0xd0010
4002a43c:	00278793          	addi	a5,a5,2 # d0010002 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd0010003>
	net_mgmt_add_event_callback(&mgmt_iface_cb);
4002a440:	17cc0513          	addi	a0,s8,380
4002a444:	00f72423          	sw	a5,8(a4)
4002a448:	92ceb0ef          	jal	ra,40015574 <net_mgmt_add_event_callback>
	return z_impl_k_sem_init(sem, initial_count, limit);
4002a44c:	fff00613          	li	a2,-1
4002a450:	00100593          	li	a1,1
4002a454:	8c8b0513          	addi	a0,s6,-1848
4002a458:	4a8050ef          	jal	ra,4002f900 <z_impl_k_sem_init>
			if (k_sem_take(&waiter, K_MSEC(loop))) {
4002a45c:	000a0513          	mv	a0,s4
4002a460:	000a5463          	bgez	s4,4002a468 <net_config_init_by_iface+0x3ac>
4002a464:	00000513          	li	a0,0
4002a468:	00a00613          	li	a2,10
4002a46c:	00000693          	li	a3,0
4002a470:	00950513          	addi	a0,a0,9
4002a474:	00000593          	li	a1,0
4002a478:	e41d50ef          	jal	ra,400002b8 <__udivdi3>
4002a47c:	f8a42e23          	sw	a0,-100(s0)
4002a480:	00058d13          	mv	s10,a1
	return sem->count;
4002a484:	8c8b0b13          	addi	s6,s6,-1848
	return z_impl_k_sem_take(sem, timeout);
4002a488:	40045cb7          	lui	s9,0x40045
		while (count-- > 0) {
4002a48c:	fff98d93          	addi	s11,s3,-1
4002a490:	01305663          	blez	s3,4002a49c <net_config_init_by_iface+0x3e0>
			if (!k_sem_count_get(&counter)) {
4002a494:	008b2703          	lw	a4,8(s6)
4002a498:	00071a63          	bnez	a4,4002a4ac <net_config_init_by_iface+0x3f0>
		net_mgmt_del_event_callback(&mgmt_iface_cb);
4002a49c:	17cc0513          	addi	a0,s8,380
4002a4a0:	948eb0ef          	jal	ra,400155e8 <net_mgmt_del_event_callback>
4002a4a4:	000d8993          	mv	s3,s11
4002a4a8:	d1dff06f          	j	4002a1c4 <net_config_init_by_iface+0x108>
4002a4ac:	f9c42583          	lw	a1,-100(s0)
4002a4b0:	000d0613          	mv	a2,s10
4002a4b4:	910c8513          	addi	a0,s9,-1776 # 40044910 <waiter>
4002a4b8:	4f0050ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
			if (k_sem_take(&waiter, K_MSEC(loop))) {
4002a4bc:	00051663          	bnez	a0,4002a4c8 <net_config_init_by_iface+0x40c>
		while (count-- > 0) {
4002a4c0:	000d8993          	mv	s3,s11
4002a4c4:	fc9ff06f          	j	4002a48c <net_config_init_by_iface+0x3d0>
				if (!k_sem_count_get(&counter)) {
4002a4c8:	008b2703          	lw	a4,8(s6)
4002a4cc:	fe071ae3          	bnez	a4,4002a4c0 <net_config_init_by_iface+0x404>
4002a4d0:	fcdff06f          	j	4002a49c <net_config_init_by_iface+0x3e0>
	net_if_ipv4_addr_add(iface, &addr, NET_ADDR_MANUAL, 0);
4002a4d4:	00000693          	li	a3,0
4002a4d8:	00300613          	li	a2,3
4002a4dc:	fac40593          	addi	a1,s0,-84
4002a4e0:	00090513          	mv	a0,s2
4002a4e4:	f25e80ef          	jal	ra,40013408 <net_if_ipv4_addr_add>
	NET_INFO("IPv4 address: %s",
4002a4e8:	7504a783          	lw	a5,1872(s1)
4002a4ec:	00200713          	li	a4,2
4002a4f0:	0077f793          	andi	a5,a5,7
4002a4f4:	06f77063          	bgeu	a4,a5,4002a554 <net_config_init_by_iface+0x498>
	return z_impl_net_addr_ntop(family, src, dst, size);
4002a4f8:	01000693          	li	a3,16
4002a4fc:	fb040613          	addi	a2,s0,-80
4002a500:	fac40593          	addi	a1,s0,-84
4002a504:	00100513          	li	a0,1
4002a508:	86cea0ef          	jal	ra,40014574 <z_impl_net_addr_ntop>
4002a50c:	00010b13          	mv	s6,sp
4002a510:	fe010113          	addi	sp,sp,-32
4002a514:	00010613          	mv	a2,sp
4002a518:	400397b7          	lui	a5,0x40039
4002a51c:	adc78793          	addi	a5,a5,-1316 # 40038adc <eth_hw_caps+0x114>
4002a520:	00f62a23          	sw	a5,20(a2)
4002a524:	20000793          	li	a5,512
4002a528:	00f61e23          	sh	a5,28(a2)
4002a52c:	010007b7          	lui	a5,0x1000
4002a530:	00378793          	addi	a5,a5,3 # 1000003 <__rom_region_size+0xfc7047>
4002a534:	000025b7          	lui	a1,0x2
4002a538:	00a62c23          	sw	a0,24(a2)
4002a53c:	00f62823          	sw	a5,16(a2)
4002a540:	cc058593          	addi	a1,a1,-832 # 1cc0 <CONFIG_HEAP_MEM_POOL_SIZE+0xcc0>
4002a544:	01060613          	addi	a2,a2,16
4002a548:	75048513          	addi	a0,s1,1872
4002a54c:	86dff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
4002a550:	000b0113          	mv	sp,s6
	return z_impl_net_addr_pton(family, src, dst);
4002a554:	40039b37          	lui	s6,0x40039
4002a558:	fac40613          	addi	a2,s0,-84
4002a55c:	af0b0593          	addi	a1,s6,-1296 # 40038af0 <eth_hw_caps+0x128>
4002a560:	00100513          	li	a0,1
4002a564:	b84ea0ef          	jal	ra,400148e8 <z_impl_net_addr_pton>
		if (net_addr_pton(AF_INET, CONFIG_NET_CONFIG_MY_IPV4_NETMASK,
4002a568:	06050463          	beqz	a0,4002a5d0 <net_config_init_by_iface+0x514>
			NET_ERR("Invalid netmask: %s",
4002a56c:	7504a783          	lw	a5,1872(s1)
4002a570:	0077f793          	andi	a5,a5,7
4002a574:	04078863          	beqz	a5,4002a5c4 <net_config_init_by_iface+0x508>
4002a578:	00010c13          	mv	s8,sp
4002a57c:	fe010113          	addi	sp,sp,-32
4002a580:	00010613          	mv	a2,sp
4002a584:	400367b7          	lui	a5,0x40036
4002a588:	14478793          	addi	a5,a5,324 # 40036144 <CSWTCH.15846+0xae4>
4002a58c:	00f62a23          	sw	a5,20(a2)
4002a590:	20000793          	li	a5,512
4002a594:	00f61e23          	sh	a5,28(a2)
4002a598:	010007b7          	lui	a5,0x1000
4002a59c:	00378793          	addi	a5,a5,3 # 1000003 <__rom_region_size+0xfc7047>
4002a5a0:	af0b0b13          	addi	s6,s6,-1296
4002a5a4:	000025b7          	lui	a1,0x2
4002a5a8:	01662c23          	sw	s6,24(a2)
4002a5ac:	00f62823          	sw	a5,16(a2)
4002a5b0:	c4058593          	addi	a1,a1,-960 # 1c40 <CONFIG_HEAP_MEM_POOL_SIZE+0xc40>
4002a5b4:	01060613          	addi	a2,a2,16
4002a5b8:	75048513          	addi	a0,s1,1872
4002a5bc:	ffcff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
4002a5c0:	000c0113          	mv	sp,s8
	services_notify_ready(NET_CONFIG_NEED_IPV4);
4002a5c4:	00400513          	li	a0,4
4002a5c8:	949ff0ef          	jal	ra,40029f10 <services_notify_ready>
4002a5cc:	c69ff06f          	j	4002a234 <net_config_init_by_iface+0x178>
			net_if_ipv4_set_netmask(iface, &addr);
4002a5d0:	fac40593          	addi	a1,s0,-84
4002a5d4:	00090513          	mv	a0,s2
4002a5d8:	d9de80ef          	jal	ra,40013374 <net_if_ipv4_set_netmask>
4002a5dc:	fe9ff06f          	j	4002a5c4 <net_config_init_by_iface+0x508>
		NET_ERR("Timeout while waiting network %s", "interface");
4002a5e0:	7504a783          	lw	a5,1872(s1)
4002a5e4:	0077f793          	andi	a5,a5,7
4002a5e8:	04079463          	bnez	a5,4002a630 <net_config_init_by_iface+0x574>
		return -ENETDOWN;
4002a5ec:	f8d00513          	li	a0,-115
}
4002a5f0:	f9040113          	addi	sp,s0,-112
4002a5f4:	06c12083          	lw	ra,108(sp)
4002a5f8:	06812403          	lw	s0,104(sp)
4002a5fc:	06412483          	lw	s1,100(sp)
4002a600:	06012903          	lw	s2,96(sp)
4002a604:	05c12983          	lw	s3,92(sp)
4002a608:	05812a03          	lw	s4,88(sp)
4002a60c:	05412a83          	lw	s5,84(sp)
4002a610:	05012b03          	lw	s6,80(sp)
4002a614:	04c12b83          	lw	s7,76(sp)
4002a618:	04812c03          	lw	s8,72(sp)
4002a61c:	04412c83          	lw	s9,68(sp)
4002a620:	04012d03          	lw	s10,64(sp)
4002a624:	03c12d83          	lw	s11,60(sp)
4002a628:	07010113          	addi	sp,sp,112
4002a62c:	00008067          	ret
		NET_ERR("Timeout while waiting network %s", "interface");
4002a630:	00010913          	mv	s2,sp
4002a634:	fe010113          	addi	sp,sp,-32
4002a638:	00010613          	mv	a2,sp
4002a63c:	400397b7          	lui	a5,0x40039
4002a640:	b2878793          	addi	a5,a5,-1240 # 40038b28 <eth_hw_caps+0x160>
4002a644:	00f62a23          	sw	a5,20(a2)
4002a648:	400357b7          	lui	a5,0x40035
4002a64c:	70078793          	addi	a5,a5,1792 # 40035700 <CSWTCH.15846+0xa0>
4002a650:	00f62c23          	sw	a5,24(a2)
4002a654:	20000793          	li	a5,512
4002a658:	00f61e23          	sh	a5,28(a2)
4002a65c:	010007b7          	lui	a5,0x1000
4002a660:	00378793          	addi	a5,a5,3 # 1000003 <__rom_region_size+0xfc7047>
4002a664:	000025b7          	lui	a1,0x2
4002a668:	00f62823          	sw	a5,16(a2)
4002a66c:	c4058593          	addi	a1,a1,-960 # 1c40 <CONFIG_HEAP_MEM_POOL_SIZE+0xc40>
4002a670:	01060613          	addi	a2,a2,16
4002a674:	75048513          	addi	a0,s1,1872
4002a678:	f40ff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
4002a67c:	00090113          	mv	sp,s2
4002a680:	f6dff06f          	j	4002a5ec <net_config_init_by_iface+0x530>
4002a684:	00090593          	mv	a1,s2
4002a688:	000a0613          	mv	a2,s4
4002a68c:	910c8513          	addi	a0,s9,-1776
4002a690:	318050ef          	jal	ra,4002f9a8 <z_impl_k_sem_take>
	while (!services_are_ready(flags) && count-- > 0) {
4002a694:	000b0993          	mv	s3,s6
4002a698:	cf5ff06f          	j	4002a38c <net_config_init_by_iface+0x2d0>
		NET_ERR("Timeout while waiting network %s", "setup");
4002a69c:	00010913          	mv	s2,sp
4002a6a0:	fe010113          	addi	sp,sp,-32
4002a6a4:	00010613          	mv	a2,sp
4002a6a8:	400397b7          	lui	a5,0x40039
4002a6ac:	b2878793          	addi	a5,a5,-1240 # 40038b28 <eth_hw_caps+0x160>
4002a6b0:	00f62a23          	sw	a5,20(a2)
4002a6b4:	400387b7          	lui	a5,0x40038
4002a6b8:	fb878793          	addi	a5,a5,-72 # 40037fb8 <CSWTCH.15846+0x2958>
4002a6bc:	00f62c23          	sw	a5,24(a2)
4002a6c0:	20000793          	li	a5,512
4002a6c4:	00f61e23          	sh	a5,28(a2)
4002a6c8:	010007b7          	lui	a5,0x1000
4002a6cc:	00378793          	addi	a5,a5,3 # 1000003 <__rom_region_size+0xfc7047>
4002a6d0:	000025b7          	lui	a1,0x2
4002a6d4:	00f62823          	sw	a5,16(a2)
4002a6d8:	c4058593          	addi	a1,a1,-960 # 1c40 <CONFIG_HEAP_MEM_POOL_SIZE+0xc40>
4002a6dc:	01060613          	addi	a2,a2,16
4002a6e0:	75048513          	addi	a0,s1,1872
4002a6e4:	ed4ff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
4002a6e8:	00090113          	mv	sp,s2
4002a6ec:	cd9ff06f          	j	4002a3c4 <net_config_init_by_iface+0x308>

4002a6f0 <net_config_init_app>:

int net_config_init_app(const struct device *dev, const char *app_info)
{
4002a6f0:	fd010113          	addi	sp,sp,-48
4002a6f4:	02812423          	sw	s0,40(sp)
4002a6f8:	03212023          	sw	s2,32(sp)
4002a6fc:	02112623          	sw	ra,44(sp)
4002a700:	02912223          	sw	s1,36(sp)
4002a704:	01312e23          	sw	s3,28(sp)
4002a708:	03010413          	addi	s0,sp,48
	struct net_if *iface = NULL;
4002a70c:	fc042e23          	sw	zero,-36(s0)
{
4002a710:	00058913          	mv	s2,a1
	uint32_t flags = 0U;
	int ret;

	if (dev) {
4002a714:	0e050c63          	beqz	a0,4002a80c <net_config_init_app+0x11c>
4002a718:	00050493          	mv	s1,a0
		iface = net_if_lookup_by_dev(dev);
4002a71c:	e00e60ef          	jal	ra,40010d1c <net_if_lookup_by_dev>
4002a720:	fca42e23          	sw	a0,-36(s0)
		if (iface == NULL) {
4002a724:	04051c63          	bnez	a0,4002a77c <net_config_init_app+0x8c>
			NET_WARN("No interface for device %p, using default",
4002a728:	40044537          	lui	a0,0x40044
4002a72c:	75052783          	lw	a5,1872(a0) # 40044750 <log_dynamic_net_config>
4002a730:	0067f793          	andi	a5,a5,6
4002a734:	0c078c63          	beqz	a5,4002a80c <net_config_init_app+0x11c>
4002a738:	00010993          	mv	s3,sp
4002a73c:	fe010113          	addi	sp,sp,-32
4002a740:	00010613          	mv	a2,sp
4002a744:	400397b7          	lui	a5,0x40039
4002a748:	b4c78793          	addi	a5,a5,-1204 # 40038b4c <eth_hw_caps+0x184>
4002a74c:	00f62a23          	sw	a5,20(a2)
4002a750:	000025b7          	lui	a1,0x2
4002a754:	00300793          	li	a5,3
4002a758:	00f62823          	sw	a5,16(a2)
4002a75c:	00962c23          	sw	s1,24(a2)
4002a760:	88058593          	addi	a1,a1,-1920 # 1880 <CONFIG_HEAP_MEM_POOL_SIZE+0x880>
4002a764:	01060613          	addi	a2,a2,16
4002a768:	75050513          	addi	a0,a0,1872
4002a76c:	e4cff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
	if (IS_ENABLED(CONFIG_NET_CONFIG_NEED_IPV4)) {
		flags |= NET_CONFIG_NEED_IPV4;
	}

	/* Only try to use a network interface that is auto started */
	if (iface == NULL) {
4002a770:	fdc42783          	lw	a5,-36(s0)
4002a774:	00098113          	mv	sp,s3
4002a778:	08078a63          	beqz	a5,4002a80c <net_config_init_app+0x11c>
		net_if_foreach(iface_find_cb, &iface);
	}

	/* Initialize the application automatically if needed */
	ret = net_config_init_by_iface(iface, app_info, flags,
4002a77c:	fdc42503          	lw	a0,-36(s0)
4002a780:	000076b7          	lui	a3,0x7
4002a784:	53068693          	addi	a3,a3,1328 # 7530 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3530>
4002a788:	00600613          	li	a2,6
4002a78c:	00090593          	mv	a1,s2
4002a790:	92dff0ef          	jal	ra,4002a0bc <net_config_init_by_iface>
4002a794:	00050493          	mv	s1,a0
				CONFIG_NET_CONFIG_INIT_TIMEOUT * MSEC_PER_SEC);
	if (ret < 0) {
4002a798:	04055863          	bgez	a0,4002a7e8 <net_config_init_app+0xf8>
		NET_ERR("Network initialization failed (%d)", ret);
4002a79c:	40044537          	lui	a0,0x40044
4002a7a0:	75052783          	lw	a5,1872(a0) # 40044750 <log_dynamic_net_config>
4002a7a4:	0077f793          	andi	a5,a5,7
4002a7a8:	04078063          	beqz	a5,4002a7e8 <net_config_init_app+0xf8>
4002a7ac:	00010913          	mv	s2,sp
4002a7b0:	fe010113          	addi	sp,sp,-32
4002a7b4:	00010613          	mv	a2,sp
4002a7b8:	400397b7          	lui	a5,0x40039
4002a7bc:	b7878793          	addi	a5,a5,-1160 # 40038b78 <eth_hw_caps+0x1b0>
4002a7c0:	00f62a23          	sw	a5,20(a2)
4002a7c4:	000025b7          	lui	a1,0x2
4002a7c8:	00300793          	li	a5,3
4002a7cc:	00962c23          	sw	s1,24(a2)
4002a7d0:	00f62823          	sw	a5,16(a2)
4002a7d4:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
4002a7d8:	01060613          	addi	a2,a2,16
4002a7dc:	75050513          	addi	a0,a0,1872
4002a7e0:	dd8ff0ef          	jal	ra,40029db8 <z_log_msg_static_create.constprop.0>
4002a7e4:	00090113          	mv	sp,s2
			log_backend_activate(backend, NULL);
		}
	}

	return ret;
}
4002a7e8:	fd040113          	addi	sp,s0,-48
4002a7ec:	02c12083          	lw	ra,44(sp)
4002a7f0:	00048513          	mv	a0,s1
4002a7f4:	02812403          	lw	s0,40(sp)
4002a7f8:	02412483          	lw	s1,36(sp)
4002a7fc:	02012903          	lw	s2,32(sp)
4002a800:	01c12983          	lw	s3,28(sp)
4002a804:	03010113          	addi	sp,sp,48
4002a808:	00008067          	ret
		net_if_foreach(iface_find_cb, &iface);
4002a80c:	4002a537          	lui	a0,0x4002a
4002a810:	fdc40593          	addi	a1,s0,-36
4002a814:	e0050513          	addi	a0,a0,-512 # 40029e00 <iface_find_cb>
4002a818:	b8ce90ef          	jal	ra,40013ba4 <net_if_foreach>
4002a81c:	f61ff06f          	j	4002a77c <net_config_init_app+0x8c>

4002a820 <init_app>:

#if defined(CONFIG_NET_CONFIG_AUTO_INIT)
static int init_app(void)
{

	(void)net_config_init_app(NULL, "Initializing network");
4002a820:	400395b7          	lui	a1,0x40039
{
4002a824:	ff010113          	addi	sp,sp,-16
	(void)net_config_init_app(NULL, "Initializing network");
4002a828:	b9c58593          	addi	a1,a1,-1124 # 40038b9c <eth_hw_caps+0x1d4>
4002a82c:	00000513          	li	a0,0
{
4002a830:	00112623          	sw	ra,12(sp)
	(void)net_config_init_app(NULL, "Initializing network");
4002a834:	ebdff0ef          	jal	ra,4002a6f0 <net_config_init_app>

	return 0;
}
4002a838:	00c12083          	lw	ra,12(sp)
4002a83c:	00000513          	li	a0,0
4002a840:	01010113          	addi	sp,sp,16
4002a844:	00008067          	ret

4002a848 <dns_msg_pack_qname>:

#include "dns_internal.h"

static inline uint16_t dns_strlen(const char *str)
{
	if (str == NULL) {
4002a848:	00069663          	bnez	a3,4002a854 <dns_msg_pack_qname+0xc>
	lb_index = 1U;
	lb_size = 0U;

	dn_size = dns_strlen(domain_name);
	if (dn_size == 0U) {
		return -EINVAL;
4002a84c:	fea00513          	li	a0,-22
	}

	*len = lb_index;

	return 0;
}
4002a850:	00008067          	ret
{
4002a854:	fe010113          	addi	sp,sp,-32
4002a858:	01312623          	sw	s3,12(sp)
4002a85c:	00050993          	mv	s3,a0
	return (uint16_t)strlen(str);
4002a860:	00068513          	mv	a0,a3
{
4002a864:	00812c23          	sw	s0,24(sp)
4002a868:	00912a23          	sw	s1,20(sp)
4002a86c:	01212823          	sw	s2,16(sp)
4002a870:	00068493          	mv	s1,a3
4002a874:	00112e23          	sw	ra,28(sp)
4002a878:	00058413          	mv	s0,a1
4002a87c:	00060913          	mv	s2,a2
	return (uint16_t)strlen(str);
4002a880:	b54e20ef          	jal	ra,4000cbd4 <strlen>
4002a884:	01051693          	slli	a3,a0,0x10
4002a888:	0106d693          	srli	a3,a3,0x10
		return -EINVAL;
4002a88c:	fea00513          	li	a0,-22
	if (dn_size == 0U) {
4002a890:	00068863          	beqz	a3,4002a8a0 <dns_msg_pack_qname+0x58>
		if (lb_index >= size) {
4002a894:	00100793          	li	a5,1
4002a898:	0727ea63          	bltu	a5,s2,4002a90c <dns_msg_pack_qname+0xc4>
			return -ENOMEM;
4002a89c:	ff400513          	li	a0,-12
}
4002a8a0:	01c12083          	lw	ra,28(sp)
4002a8a4:	01812403          	lw	s0,24(sp)
4002a8a8:	01412483          	lw	s1,20(sp)
4002a8ac:	01012903          	lw	s2,16(sp)
4002a8b0:	00c12983          	lw	s3,12(sp)
4002a8b4:	02010113          	addi	sp,sp,32
4002a8b8:	00008067          	ret
		if (lb_index >= size) {
4002a8bc:	00170713          	addi	a4,a4,1
4002a8c0:	01071613          	slli	a2,a4,0x10
4002a8c4:	01065613          	srli	a2,a2,0x10
4002a8c8:	fd267ae3          	bgeu	a2,s2,4002a89c <dns_msg_pack_qname+0x54>
		switch (domain_name[i]) {
4002a8cc:	00e48633          	add	a2,s1,a4
4002a8d0:	fff64603          	lbu	a2,-1(a2)
4002a8d4:	01071593          	slli	a1,a4,0x10
4002a8d8:	0105d593          	srli	a1,a1,0x10
4002a8dc:	04060c63          	beqz	a2,4002a934 <dns_msg_pack_qname+0xec>
4002a8e0:	04a60063          	beq	a2,a0,4002a920 <dns_msg_pack_qname+0xd8>
			lb_size += 1U;
4002a8e4:	00178793          	addi	a5,a5,1
			buf[lb_index] = domain_name[i];
4002a8e8:	00e408b3          	add	a7,s0,a4
			lb_size += 1U;
4002a8ec:	01079793          	slli	a5,a5,0x10
			buf[lb_index] = domain_name[i];
4002a8f0:	00c88023          	sb	a2,0(a7)
			lb_size += 1U;
4002a8f4:	0107d793          	srli	a5,a5,0x10
	for (i = 0U; i < dn_size + 1; i++) {
4002a8f8:	fcb6f2e3          	bgeu	a3,a1,4002a8bc <dns_msg_pack_qname+0x74>
		lb_index += 1U;
4002a8fc:	00158593          	addi	a1,a1,1
	*len = lb_index;
4002a900:	00b99023          	sh	a1,0(s3)
	return 0;
4002a904:	00000513          	li	a0,0
4002a908:	f99ff06f          	j	4002a8a0 <dns_msg_pack_qname+0x58>
		if (lb_index >= size) {
4002a90c:	00100713          	li	a4,1
	lb_size = 0U;
4002a910:	00000793          	li	a5,0
	lb_start = 0U;
4002a914:	00000813          	li	a6,0
		switch (domain_name[i]) {
4002a918:	02e00513          	li	a0,46
4002a91c:	fb1ff06f          	j	4002a8cc <dns_msg_pack_qname+0x84>
			buf[lb_start] = lb_size;
4002a920:	01040833          	add	a6,s0,a6
4002a924:	00f80023          	sb	a5,0(a6)
			break;
4002a928:	00058813          	mv	a6,a1
			lb_size = 0U;
4002a92c:	00000793          	li	a5,0
			break;
4002a930:	fc9ff06f          	j	4002a8f8 <dns_msg_pack_qname+0xb0>
			buf[lb_start] = lb_size;
4002a934:	01040633          	add	a2,s0,a6
4002a938:	00f60023          	sb	a5,0(a2)
			buf[lb_index] = 0U;
4002a93c:	00e40633          	add	a2,s0,a4
4002a940:	00060023          	sb	zero,0(a2)
			break;
4002a944:	fb5ff06f          	j	4002a8f8 <dns_msg_pack_qname+0xb0>

4002a948 <dns_unpack_answer>:
	uint16_t rem_size;
	uint16_t pos;
	uint16_t len;
	uint8_t *answer;

	answer = dns_msg->msg + dns_msg->answer_offset;
4002a948:	00e55883          	lhu	a7,14(a0)
4002a94c:	00052783          	lw	a5,0(a0)

	dname_len = skip_fqdn(answer,
			      dns_msg->msg_size - dns_msg->answer_offset);
4002a950:	01055803          	lhu	a6,16(a0)
	int i = 0;
4002a954:	00000713          	li	a4,0
	answer = dns_msg->msg + dns_msg->answer_offset;
4002a958:	011787b3          	add	a5,a5,a7
		} else if (answer[i] >= 0xc0) {
4002a95c:	0bf00313          	li	t1,191
	dname_len = skip_fqdn(answer,
4002a960:	411808b3          	sub	a7,a6,a7
		} else if (answer[i] < DNS_LABEL_MAX_SIZE) {
4002a964:	03e00e13          	li	t3,62
		if (i >= buf_sz) {
4002a968:	11175863          	bge	a4,a7,4002aa78 <dns_unpack_answer+0x130>
		if (answer[i] == 0) {
4002a96c:	00e785b3          	add	a1,a5,a4
4002a970:	0005c583          	lbu	a1,0(a1)
4002a974:	0e059c63          	bnez	a1,4002aa6c <dns_unpack_answer+0x124>
			i += 1;
4002a978:	00170713          	addi	a4,a4,1
	 *
	 * So, answer size >= 12
	 *
	 * See RFC-1035 4.1.3. Resource record format
	 */
	rem_size = dns_msg->msg_size - dname_len;
4002a97c:	01071313          	slli	t1,a4,0x10
4002a980:	01035313          	srli	t1,t1,0x10
4002a984:	40680833          	sub	a6,a6,t1
	if (rem_size < 2 + 2 + 4 + 2) {
4002a988:	01081813          	slli	a6,a6,0x10
4002a98c:	01085813          	srli	a6,a6,0x10
4002a990:	00900593          	li	a1,9
4002a994:	0f05f263          	bgeu	a1,a6,4002aa78 <dns_unpack_answer+0x130>
	}

	/* Only DNS_CLASS_IN answers. If mDNS is enabled, strip away the
	 * Cache-Flush bit (highest one).
	 */
	if ((dns_answer_class(dname_len, answer) &
4002a998:	00e787b3          	add	a5,a5,a4
4002a99c:	0037c803          	lbu	a6,3(a5)
4002a9a0:	0027c703          	lbu	a4,2(a5)
4002a9a4:	00881813          	slli	a6,a6,0x8
4002a9a8:	00e86833          	or	a6,a6,a4
4002a9ac:	10000713          	li	a4,256
4002a9b0:	0ce81463          	bne	a6,a4,4002aa78 <dns_unpack_answer+0x130>
	return ntohs(UNALIGNED_GET((uint16_t *)(answer + dname_size + 2)));
}

static inline int dns_answer_ttl(uint16_t dname_size, uint8_t *answer)
{
	return ntohl(UNALIGNED_GET((uint32_t *)(answer + dname_size + 4)));
4002a9b4:	0057c703          	lbu	a4,5(a5)
4002a9b8:	0047c583          	lbu	a1,4(a5)
4002a9bc:	00010e37          	lui	t3,0x10
4002a9c0:	00871713          	slli	a4,a4,0x8
4002a9c4:	00b76733          	or	a4,a4,a1
4002a9c8:	0067c583          	lbu	a1,6(a5)
4002a9cc:	f00e0e13          	addi	t3,t3,-256 # ff00 <__kernel_ram_size+0x43f8>
4002a9d0:	01059593          	slli	a1,a1,0x10
4002a9d4:	00e5e5b3          	or	a1,a1,a4
4002a9d8:	0077c703          	lbu	a4,7(a5)
4002a9dc:	01871713          	slli	a4,a4,0x18
4002a9e0:	00b768b3          	or	a7,a4,a1
4002a9e4:	01859593          	slli	a1,a1,0x18
4002a9e8:	01875713          	srli	a4,a4,0x18
4002a9ec:	00b76733          	or	a4,a4,a1
4002a9f0:	0088d593          	srli	a1,a7,0x8
4002a9f4:	01c5f5b3          	and	a1,a1,t3
4002a9f8:	00b76733          	or	a4,a4,a1
4002a9fc:	00889893          	slli	a7,a7,0x8
4002aa00:	00ff05b7          	lui	a1,0xff0
4002aa04:	00b8f8b3          	and	a7,a7,a1
4002aa08:	01176733          	or	a4,a4,a7
							!= DNS_CLASS_IN) {
		return -EINVAL;
	}

	/* TTL value */
	*ttl = dns_answer_ttl(dname_len, answer);
4002aa0c:	00e62023          	sw	a4,0(a2)
}

static inline int dns_answer_rdlength(uint16_t dname_size,
					     uint8_t *answer)
{
	return ntohs(UNALIGNED_GET((uint16_t *)(answer + dname_size + 8)));
4002aa10:	0097c703          	lbu	a4,9(a5)
4002aa14:	0087c603          	lbu	a2,8(a5)
	len = dns_answer_rdlength(dname_len, answer);
	pos = dns_msg->answer_offset + dname_len +
4002aa18:	00e55583          	lhu	a1,14(a0)
4002aa1c:	00871713          	slli	a4,a4,0x8
4002aa20:	00c76733          	or	a4,a4,a2
	return ntohs(UNALIGNED_GET((uint16_t *)(answer + dname_size + 0)));
4002aa24:	0007c603          	lbu	a2,0(a5)
4002aa28:	0017c783          	lbu	a5,1(a5)
4002aa2c:	00879793          	slli	a5,a5,0x8
4002aa30:	00c7e7b3          	or	a5,a5,a2
		DNS_COMMON_UINT_SIZE + /* class length */
		DNS_COMMON_UINT_SIZE + /* type length */
		DNS_TTL_LEN +
		DNS_RDLENGTH_LEN;
	*type = dns_answer_type(dname_len, answer);
4002aa34:	00879613          	slli	a2,a5,0x8
4002aa38:	0087d893          	srli	a7,a5,0x8
4002aa3c:	01166633          	or	a2,a2,a7
4002aa40:	01061613          	slli	a2,a2,0x10
4002aa44:	01065613          	srli	a2,a2,0x10
4002aa48:	00c6a023          	sw	a2,0(a3)

	switch (*type) {
4002aa4c:	50000693          	li	a3,1280
4002aa50:	04d78263          	beq	a5,a3,4002aa94 <dns_unpack_answer+0x14c>
4002aa54:	000026b7          	lui	a3,0x2
4002aa58:	c0068693          	addi	a3,a3,-1024 # 1c00 <CONFIG_HEAP_MEM_POOL_SIZE+0xc00>
4002aa5c:	00d78463          	beq	a5,a3,4002aa64 <dns_unpack_answer+0x11c>
4002aa60:	01079c63          	bne	a5,a6,4002aa78 <dns_unpack_answer+0x130>
4002aa64:	feb00793          	li	a5,-21
4002aa68:	0300006f          	j	4002aa98 <dns_unpack_answer+0x150>
		} else if (answer[i] >= 0xc0) {
4002aa6c:	00b37a63          	bgeu	t1,a1,4002aa80 <dns_unpack_answer+0x138>
			i += 2;
4002aa70:	00270713          	addi	a4,a4,2
			if (i > buf_sz) {
4002aa74:	f0e8d4e3          	bge	a7,a4,4002a97c <dns_unpack_answer+0x34>
	switch (*type) {
4002aa78:	fea00513          	li	a0,-22
4002aa7c:	00008067          	ret
		} else if (answer[i] < DNS_LABEL_MAX_SIZE) {
4002aa80:	febe6ce3          	bltu	t3,a1,4002aa78 <dns_unpack_answer+0x130>
			i += answer[i] + 1;
4002aa84:	00158593          	addi	a1,a1,1 # ff0001 <__rom_region_size+0xfb7045>
4002aa88:	0ff5f593          	zext.b	a1,a1
4002aa8c:	00b70733          	add	a4,a4,a1
		if (i >= buf_sz) {
4002aa90:	ed9ff06f          	j	4002a968 <dns_unpack_answer+0x20>
	switch (*type) {
4002aa94:	fed00793          	li	a5,-19
	dns_msg->response_type = type;
4002aa98:	00f52223          	sw	a5,4(a0)
	pos = dns_msg->answer_offset + dname_len +
4002aa9c:	00a58793          	addi	a5,a1,10
4002aaa0:	00f30333          	add	t1,t1,a5
	dns_msg->response_length = len;
4002aaa4:	00871793          	slli	a5,a4,0x8
4002aaa8:	00875713          	srli	a4,a4,0x8
4002aaac:	00e7e7b3          	or	a5,a5,a4
	dns_msg->response_position = pos;
4002aab0:	00651423          	sh	t1,8(a0)
	dns_msg->response_length = len;
4002aab4:	00f51523          	sh	a5,10(a0)
	case DNS_RR_TYPE_A:
	case DNS_RR_TYPE_AAAA:
		set_dns_msg_response(dns_msg, DNS_RESPONSE_IP, pos, len);
		return 0;
4002aab8:	00000513          	li	a0,0
		/* malformed dns answer */
		return -EINVAL;
	}

	return 0;
}
4002aabc:	00008067          	ret

4002aac0 <dns_unpack_response_header>:
	int rc;

	dns_header = msg->msg;
	size = msg->msg_size;

	if (size < DNS_MSG_HEADER_SIZE) {
4002aac0:	01055683          	lhu	a3,16(a0)
4002aac4:	00b00713          	li	a4,11
	dns_header = msg->msg;
4002aac8:	00052783          	lw	a5,0(a0)
	if (size < DNS_MSG_HEADER_SIZE) {
4002aacc:	08d77e63          	bgeu	a4,a3,4002ab68 <dns_unpack_response_header+0xa8>
	return ntohs(UNALIGNED_GET((uint16_t *)(header)));
4002aad0:	0017c703          	lbu	a4,1(a5)
4002aad4:	0007c683          	lbu	a3,0(a5)
		return -ENOMEM;
	}

	if (dns_unpack_header_id(dns_header) != src_id) {
		return -EINVAL;
4002aad8:	fea00513          	li	a0,-22
4002aadc:	00871713          	slli	a4,a4,0x8
4002aae0:	00d76733          	or	a4,a4,a3
4002aae4:	00871693          	slli	a3,a4,0x8
4002aae8:	00875713          	srli	a4,a4,0x8
4002aaec:	00e6e733          	or	a4,a3,a4
4002aaf0:	01071713          	slli	a4,a4,0x10
4002aaf4:	01075713          	srli	a4,a4,0x10
	if (dns_unpack_header_id(dns_header) != src_id) {
4002aaf8:	06e59663          	bne	a1,a4,4002ab64 <dns_unpack_response_header+0xa4>
	return ((*(header + 2)) & 0x80) ? 1 : 0;
4002aafc:	0027c703          	lbu	a4,2(a5)
	}

	if (dns_header_qr(dns_header) != DNS_RESPONSE) {
4002ab00:	00775693          	srli	a3,a4,0x7
4002ab04:	06068063          	beqz	a3,4002ab64 <dns_unpack_response_header+0xa4>
	return ((*(header + 2)) & 0x70) >> 1;
4002ab08:	40175713          	srai	a4,a4,0x1
4002ab0c:	03877713          	andi	a4,a4,56
		return -EINVAL;
	}

	if (dns_header_opcode(dns_header) != DNS_QUERY) {
4002ab10:	04071a63          	bnez	a4,4002ab64 <dns_unpack_response_header+0xa4>
	return ((*(header + 3)) & 0x70) >> 4;
4002ab14:	0037c703          	lbu	a4,3(a5)
4002ab18:	40475513          	srai	a0,a4,0x4
4002ab1c:	00757513          	andi	a0,a0,7
		return -EINVAL;
	}

	if (dns_header_z(dns_header) != 0) {
4002ab20:	04051063          	bnez	a0,4002ab60 <dns_unpack_response_header+0xa0>
	return ((*(header + 3)) & 0x0F);
4002ab24:	00f77713          	andi	a4,a4,15
		return -EINVAL;
	}

	rc = dns_header_rcode(dns_header);
	switch (rc) {
4002ab28:	00070663          	beqz	a4,4002ab34 <dns_unpack_response_header+0x74>
4002ab2c:	00070513          	mv	a0,a4
4002ab30:	00008067          	ret
	return ntohs(UNALIGNED_GET((uint16_t *)(header + 6)));
4002ab34:	0077c703          	lbu	a4,7(a5)
4002ab38:	0067c683          	lbu	a3,6(a5)
4002ab3c:	00871713          	slli	a4,a4,0x8
4002ab40:	00d76733          	or	a4,a4,a3
	ancount = dns_unpack_header_ancount(dns_header);

	/* For mDNS (when src_id == 0) the query count is 0 so accept
	 * the packet in that case.
	 */
	if ((qdcount < 1 && src_id > 0) || ancount < 1) {
4002ab44:	0047c683          	lbu	a3,4(a5)
4002ab48:	0057c783          	lbu	a5,5(a5)
4002ab4c:	00879793          	slli	a5,a5,0x8
4002ab50:	00d7e7b3          	or	a5,a5,a3
4002ab54:	00079463          	bnez	a5,4002ab5c <dns_unpack_response_header+0x9c>
4002ab58:	00059463          	bnez	a1,4002ab60 <dns_unpack_response_header+0xa0>
4002ab5c:	00071463          	bnez	a4,4002ab64 <dns_unpack_response_header+0xa4>
		return -EINVAL;
4002ab60:	fea00513          	li	a0,-22
		return -EINVAL;
	}

	return 0;
}
4002ab64:	00008067          	ret
		return -ENOMEM;
4002ab68:	ff400513          	li	a0,-12
4002ab6c:	00008067          	ret

4002ab70 <dns_msg_pack_query>:
}

int dns_msg_pack_query(uint8_t *buf, uint16_t *len, uint16_t size,
		       uint8_t *qname, uint16_t qname_len, uint16_t id,
		       enum dns_rr_type qtype)
{
4002ab70:	fe010113          	addi	sp,sp,-32
4002ab74:	01512223          	sw	s5,4(sp)
4002ab78:	00112e23          	sw	ra,28(sp)
4002ab7c:	00812c23          	sw	s0,24(sp)
4002ab80:	00912a23          	sw	s1,20(sp)
4002ab84:	01212823          	sw	s2,16(sp)
4002ab88:	01312623          	sw	s3,12(sp)
4002ab8c:	01412423          	sw	s4,8(sp)
	uint16_t msg_size;
	uint16_t offset;
	int rc;

	msg_size = DNS_MSG_HEADER_SIZE + DNS_QTYPE_LEN + DNS_QCLASS_LEN;
	if (msg_size + qname_len > size) {
4002ab90:	01070a93          	addi	s5,a4,16
4002ab94:	0f564663          	blt	a2,s5,4002ac80 <dns_msg_pack_query+0x110>
4002ab98:	00070493          	mv	s1,a4
	UNALIGNED_PUT(htons(id), (uint16_t *)(buf));
4002ab9c:	00879713          	slli	a4,a5,0x8
4002aba0:	0087d793          	srli	a5,a5,0x8
4002aba4:	00f767b3          	or	a5,a4,a5
4002aba8:	01079713          	slli	a4,a5,0x10
4002abac:	01075713          	srli	a4,a4,0x10
4002abb0:	00f50023          	sb	a5,0(a0)
	*(buf + offset) = DNS_FLAGS1;		/* QR, Opcode, AA, TC and RD */
4002abb4:	00100a13          	li	s4,1
	UNALIGNED_PUT(htons(id), (uint16_t *)(buf));
4002abb8:	00875793          	srli	a5,a4,0x8
4002abbc:	00050413          	mv	s0,a0
4002abc0:	00f500a3          	sb	a5,1(a0)
4002abc4:	00058993          	mv	s3,a1
	*(buf + offset) = DNS_FLAGS1;		/* QR, Opcode, AA, TC and RD */
4002abc8:	01450123          	sb	s4,2(a0)
4002abcc:	00068593          	mv	a1,a3
	*(buf + offset + 1) = DNS_FLAGS2;	/* RA, Z and RCODE */
4002abd0:	000501a3          	sb	zero,3(a0)
	UNALIGNED_PUT(htons(1), (uint16_t *)(buf + offset));
4002abd4:	00050223          	sb	zero,4(a0)
4002abd8:	014502a3          	sb	s4,5(a0)
	UNALIGNED_PUT(0, (uint32_t *)(buf + offset));
4002abdc:	00050323          	sb	zero,6(a0)
4002abe0:	000503a3          	sb	zero,7(a0)
4002abe4:	00050423          	sb	zero,8(a0)
4002abe8:	000504a3          	sb	zero,9(a0)
	UNALIGNED_PUT(0, (uint16_t *)(buf + offset));
4002abec:	00050523          	sb	zero,10(a0)
4002abf0:	000505a3          	sb	zero,11(a0)
	if (rc != 0) {
		return rc;
	}

	offset = DNS_MSG_HEADER_SIZE;
	memcpy(buf + offset, qname, qname_len);
4002abf4:	00048613          	mv	a2,s1
4002abf8:	00c50513          	addi	a0,a0,12
4002abfc:	00080913          	mv	s2,a6
4002ac00:	8f8e20ef          	jal	ra,4000ccf8 <memcpy>

	offset += qname_len;

	/* QType */
	UNALIGNED_PUT(htons(qtype), (uint16_t *)(buf + offset + 0));
4002ac04:	00891713          	slli	a4,s2,0x8
4002ac08:	01091913          	slli	s2,s2,0x10
4002ac0c:	01095913          	srli	s2,s2,0x10
	offset += qname_len;
4002ac10:	00c48793          	addi	a5,s1,12
	UNALIGNED_PUT(htons(qtype), (uint16_t *)(buf + offset + 0));
4002ac14:	00895913          	srli	s2,s2,0x8
4002ac18:	01276733          	or	a4,a4,s2
4002ac1c:	01079793          	slli	a5,a5,0x10
4002ac20:	01071693          	slli	a3,a4,0x10
4002ac24:	0107d793          	srli	a5,a5,0x10
	offset += DNS_QTYPE_LEN;
4002ac28:	00e48493          	addi	s1,s1,14
	UNALIGNED_PUT(htons(qtype), (uint16_t *)(buf + offset + 0));
4002ac2c:	00f407b3          	add	a5,s0,a5
4002ac30:	0106d693          	srli	a3,a3,0x10

	/* QClass */
	UNALIGNED_PUT(htons(DNS_CLASS_IN), (uint16_t *)(buf + offset));
4002ac34:	01049493          	slli	s1,s1,0x10
	UNALIGNED_PUT(htons(qtype), (uint16_t *)(buf + offset + 0));
4002ac38:	00e78023          	sb	a4,0(a5)
	UNALIGNED_PUT(htons(DNS_CLASS_IN), (uint16_t *)(buf + offset));
4002ac3c:	0104d493          	srli	s1,s1,0x10
	UNALIGNED_PUT(htons(qtype), (uint16_t *)(buf + offset + 0));
4002ac40:	0086d713          	srli	a4,a3,0x8
4002ac44:	00e780a3          	sb	a4,1(a5)
	UNALIGNED_PUT(htons(DNS_CLASS_IN), (uint16_t *)(buf + offset));
4002ac48:	00940433          	add	s0,s0,s1
4002ac4c:	00040023          	sb	zero,0(s0)
4002ac50:	014400a3          	sb	s4,1(s0)

	*len = offset + DNS_QCLASS_LEN;
4002ac54:	01599023          	sh	s5,0(s3)

	return 0;
4002ac58:	00000513          	li	a0,0
}
4002ac5c:	01c12083          	lw	ra,28(sp)
4002ac60:	01812403          	lw	s0,24(sp)
4002ac64:	01412483          	lw	s1,20(sp)
4002ac68:	01012903          	lw	s2,16(sp)
4002ac6c:	00c12983          	lw	s3,12(sp)
4002ac70:	00812a03          	lw	s4,8(sp)
4002ac74:	00412a83          	lw	s5,4(sp)
4002ac78:	02010113          	addi	sp,sp,32
4002ac7c:	00008067          	ret
		return -ENOMEM;
4002ac80:	ff400513          	li	a0,-12
4002ac84:	fd9ff06f          	j	4002ac5c <dns_msg_pack_query+0xec>

4002ac88 <dns_unpack_response_query>:
	int offset;
	int rc;

	dns_msg->query_offset = DNS_MSG_HEADER_SIZE;
	dns_query = dns_msg->msg + dns_msg->query_offset;
	remaining_size = dns_msg->msg_size - dns_msg->query_offset;
4002ac88:	01055803          	lhu	a6,16(a0)
	dns_query = dns_msg->msg + dns_msg->query_offset;
4002ac8c:	00052703          	lw	a4,0(a0)
	dns_msg->query_offset = DNS_MSG_HEADER_SIZE;
4002ac90:	00c00793          	li	a5,12

	rc = dns_find_null(&qname_size, dns_query, remaining_size);
4002ac94:	ff480613          	addi	a2,a6,-12
4002ac98:	01061613          	slli	a2,a2,0x10
	dns_msg->query_offset = DNS_MSG_HEADER_SIZE;
4002ac9c:	00f51623          	sh	a5,12(a0)
{
4002aca0:	00050693          	mv	a3,a0
	rc = dns_find_null(&qname_size, dns_query, remaining_size);
4002aca4:	01065613          	srli	a2,a2,0x10
	*qname_size = 0;
4002aca8:	00000793          	li	a5,0
	while (*qname_size < size) {
4002acac:	00c7c663          	blt	a5,a2,4002acb8 <dns_unpack_response_query+0x30>
	return -ENOMEM;
4002acb0:	ff400513          	li	a0,-12
4002acb4:	00008067          	ret
		if (buf[(*qname_size)++] == 0x00) {
4002acb8:	00178593          	addi	a1,a5,1
4002acbc:	00b70533          	add	a0,a4,a1
4002acc0:	00b54503          	lbu	a0,11(a0)
4002acc4:	06050c63          	beqz	a0,4002ad3c <dns_unpack_response_query+0xb4>
4002acc8:	00058793          	mv	a5,a1
4002accc:	fe1ff06f          	j	4002acac <dns_unpack_response_query+0x24>
	offset += DNS_QTYPE_LEN + DNS_QCLASS_LEN;
	if (offset >= dns_msg->msg_size) {
		return -ENOMEM;
	}

	buf = dns_query + qname_size;
4002acd0:	00d78793          	addi	a5,a5,13
4002acd4:	00f70733          	add	a4,a4,a5
	return ntohs(UNALIGNED_GET((uint16_t *)(question + 0)));
4002acd8:	00174783          	lbu	a5,1(a4)
4002acdc:	00074603          	lbu	a2,0(a4)
4002ace0:	00879793          	slli	a5,a5,0x8
4002ace4:	00c7e7b3          	or	a5,a5,a2
4002ace8:	00879613          	slli	a2,a5,0x8
4002acec:	0087d793          	srli	a5,a5,0x8
4002acf0:	00f667b3          	or	a5,a2,a5
4002acf4:	01079793          	slli	a5,a5,0x10
4002acf8:	0107d793          	srli	a5,a5,0x10
	if (dns_unpack_query_qtype(buf) != DNS_RR_TYPE_A &&
4002acfc:	00100613          	li	a2,1
4002ad00:	00c78863          	beq	a5,a2,4002ad10 <dns_unpack_response_query+0x88>
4002ad04:	01c00613          	li	a2,28
	    dns_unpack_query_qtype(buf) != DNS_RR_TYPE_AAAA) {
		return -EINVAL;
4002ad08:	fea00513          	li	a0,-22
	if (dns_unpack_query_qtype(buf) != DNS_RR_TYPE_A &&
4002ad0c:	02c79e63          	bne	a5,a2,4002ad48 <dns_unpack_response_query+0xc0>
	}

	if (dns_unpack_query_qclass(buf) != DNS_CLASS_IN) {
4002ad10:	00374783          	lbu	a5,3(a4)
4002ad14:	00274603          	lbu	a2,2(a4)
4002ad18:	10000713          	li	a4,256
4002ad1c:	00879793          	slli	a5,a5,0x8
4002ad20:	00c7e7b3          	or	a5,a5,a2
		return -EINVAL;
4002ad24:	fea00513          	li	a0,-22
	if (dns_unpack_query_qclass(buf) != DNS_CLASS_IN) {
4002ad28:	02e79063          	bne	a5,a4,4002ad48 <dns_unpack_response_query+0xc0>
		return -EINVAL;
	}

	dns_msg->answer_offset = dns_msg->query_offset + qname_size +
				 DNS_QTYPE_LEN + DNS_QCLASS_LEN;
4002ad2c:	01058593          	addi	a1,a1,16
	dns_msg->answer_offset = dns_msg->query_offset + qname_size +
4002ad30:	00b69723          	sh	a1,14(a3)

	return 0;
4002ad34:	00000513          	li	a0,0
4002ad38:	00008067          	ret
	offset += DNS_QTYPE_LEN + DNS_QCLASS_LEN;
4002ad3c:	01178613          	addi	a2,a5,17
	return -ENOMEM;
4002ad40:	ff400513          	li	a0,-12
	if (offset >= dns_msg->msg_size) {
4002ad44:	f90646e3          	blt	a2,a6,4002acd0 <dns_unpack_response_query+0x48>
}
4002ad48:	00008067          	ret

4002ad4c <dns_copy_qname>:

int dns_copy_qname(uint8_t *buf, uint16_t *len, uint16_t size,
		   struct dns_msg_t *dns_msg, uint16_t pos)
{
4002ad4c:	fd010113          	addi	sp,sp,-48
4002ad50:	02812423          	sw	s0,40(sp)
4002ad54:	03212023          	sw	s2,32(sp)
4002ad58:	01312e23          	sw	s3,28(sp)
4002ad5c:	01412c23          	sw	s4,24(sp)
4002ad60:	01512a23          	sw	s5,20(sp)
4002ad64:	01612823          	sw	s6,16(sp)
4002ad68:	01712623          	sw	s7,12(sp)
4002ad6c:	02112623          	sw	ra,44(sp)
4002ad70:	02912223          	sw	s1,36(sp)
	uint16_t msg_size = dns_msg->msg_size;
4002ad74:	0106da83          	lhu	s5,16(a3)
	uint8_t *msg = dns_msg->msg;
4002ad78:	0006ab03          	lw	s6,0(a3)
{
4002ad7c:	00050993          	mv	s3,a0
4002ad80:	00058913          	mv	s2,a1
4002ad84:	00060a13          	mv	s4,a2
4002ad88:	00070413          	mv	s0,a4
	uint16_t lb_size;
	int rc = -EINVAL;

	*len = 0U;
4002ad8c:	00059023          	sh	zero,0(a1)
		}

		lb_size = msg[pos];

		/* pointer */
		if (lb_size > DNS_LABEL_MAX_SIZE) {
4002ad90:	03f00b93          	li	s7,63
		if (pos >= msg_size) {
4002ad94:	09547c63          	bgeu	s0,s5,4002ae2c <dns_copy_qname+0xe0>
		lb_size = msg[pos];
4002ad98:	008b05b3          	add	a1,s6,s0
4002ad9c:	0005c483          	lbu	s1,0(a1)
		if (lb_size > DNS_LABEL_MAX_SIZE) {
4002ada0:	029bf063          	bgeu	s7,s1,4002adc0 <dns_copy_qname+0x74>
			uint8_t mask = DNS_LABEL_MAX_SIZE;

			if (pos + 1 >= msg_size) {
4002ada4:	00140413          	addi	s0,s0,1
4002ada8:	09545263          	bge	s0,s5,4002ae2c <dns_copy_qname+0xe0>
				rc = -ENOMEM;
				break;
			}

			/* See: RFC 1035, 4.1.4. Message compression */
			pos = ((msg[pos] & mask) << 8) + msg[pos + 1];
4002adac:	0015c403          	lbu	s0,1(a1)
4002adb0:	03f4f493          	andi	s1,s1,63
4002adb4:	00849493          	slli	s1,s1,0x8
4002adb8:	00848433          	add	s0,s1,s0

			continue;
4002adbc:	fd9ff06f          	j	4002ad94 <dns_copy_qname+0x48>
		}

		/* validate that the label (i.e. size + elements),
		 * fits the current msg buffer
		 */
		if (DNS_LABEL_LEN_SIZE + lb_size > size - *len) {
4002adc0:	00095503          	lhu	a0,0(s2)
4002adc4:	40aa07b3          	sub	a5,s4,a0
4002adc8:	06f4d263          	bge	s1,a5,4002ae2c <dns_copy_qname+0xe0>
			rc = -ENOMEM;
			break;
		}

		/* copy the lb_size value and label elements */
		memcpy(buf + *len, msg + pos, DNS_LABEL_LEN_SIZE + lb_size);
4002adcc:	00148613          	addi	a2,s1,1
4002add0:	00a98533          	add	a0,s3,a0
4002add4:	f25e10ef          	jal	ra,4000ccf8 <memcpy>
		/* update destination buffer len */
		*len += DNS_LABEL_LEN_SIZE + lb_size;
4002add8:	00095783          	lhu	a5,0(s2)
4002addc:	00140413          	addi	s0,s0,1
		/* update msg ptr position */
		pos += DNS_LABEL_LEN_SIZE + lb_size;
4002ade0:	00940433          	add	s0,s0,s1
		*len += DNS_LABEL_LEN_SIZE + lb_size;
4002ade4:	00178793          	addi	a5,a5,1
4002ade8:	00f487b3          	add	a5,s1,a5
		pos += DNS_LABEL_LEN_SIZE + lb_size;
4002adec:	01041413          	slli	s0,s0,0x10
		*len += DNS_LABEL_LEN_SIZE + lb_size;
4002adf0:	00f91023          	sh	a5,0(s2)
		pos += DNS_LABEL_LEN_SIZE + lb_size;
4002adf4:	01045413          	srli	s0,s0,0x10

		/* The domain name terminates with the zero length octet
		 * for the null label of the root
		 */
		if (lb_size == 0U) {
4002adf8:	f8049ee3          	bnez	s1,4002ad94 <dns_copy_qname+0x48>
			rc = 0;
4002adfc:	00000513          	li	a0,0
			break;
		}
	}

	return rc;
}
4002ae00:	02c12083          	lw	ra,44(sp)
4002ae04:	02812403          	lw	s0,40(sp)
4002ae08:	02412483          	lw	s1,36(sp)
4002ae0c:	02012903          	lw	s2,32(sp)
4002ae10:	01c12983          	lw	s3,28(sp)
4002ae14:	01812a03          	lw	s4,24(sp)
4002ae18:	01412a83          	lw	s5,20(sp)
4002ae1c:	01012b03          	lw	s6,16(sp)
4002ae20:	00c12b83          	lw	s7,12(sp)
4002ae24:	03010113          	addi	sp,sp,48
4002ae28:	00008067          	ret
			rc = -ENOMEM;
4002ae2c:	ff400513          	li	a0,-12
	return rc;
4002ae30:	fd1ff06f          	j	4002ae00 <dns_copy_qname+0xb4>

4002ae34 <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
4002ae34:	00054503          	lbu	a0,0(a0)
4002ae38:	f00007b7          	lui	a5,0xf0000
4002ae3c:	01851513          	slli	a0,a0,0x18
4002ae40:	00f57533          	and	a0,a0,a5
4002ae44:	200007b7          	lui	a5,0x20000
4002ae48:	00f50533          	add	a0,a0,a5
}
4002ae4c:	00153513          	seqz	a0,a0
4002ae50:	00008067          	ret

4002ae54 <invoke_query_callback>:
					 struct dns_pending_query *pending_query)
{
	/* Only notify if the slot is neither released nor in the process of
	 * being released.
	 */
	if (pending_query->query != NULL && pending_query->cb != NULL)  {
4002ae54:	04862783          	lw	a5,72(a2)
4002ae58:	00078a63          	beqz	a5,4002ae6c <invoke_query_callback+0x18>
4002ae5c:	03462783          	lw	a5,52(a2)
4002ae60:	00078663          	beqz	a5,4002ae6c <invoke_query_callback+0x18>
		pending_query->cb(status, info, pending_query->user_data);
4002ae64:	03862603          	lw	a2,56(a2)
4002ae68:	00078067          	jr	a5 # 20000000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1a0a1f00>
	}
}
4002ae6c:	00008067          	ret

4002ae70 <get_slot_by_id>:

/* Must be invoked with context lock held */
static inline int get_slot_by_id(struct dns_resolve_context *ctx,
				 uint16_t dns_id,
				 uint16_t query_hash)
{
4002ae70:	00050793          	mv	a5,a0
	if (pending_query->cb != NULL) {
4002ae74:	0747a703          	lw	a4,116(a5)
	int i;

	for (i = 0; i < CONFIG_DNS_NUM_CONCUR_QUERIES; i++) {
4002ae78:	00000513          	li	a0,0
	if (pending_query->cb != NULL) {
4002ae7c:	00070c63          	beqz	a4,4002ae94 <get_slot_by_id+0x24>
		if (check_query_active(&ctx->queries[i], false) &&
4002ae80:	0907d703          	lhu	a4,144(a5)
4002ae84:	00b71863          	bne	a4,a1,4002ae94 <get_slot_by_id+0x24>
		    ctx->queries[i].id == dns_id &&
4002ae88:	00060863          	beqz	a2,4002ae98 <get_slot_by_id+0x28>
		    (query_hash == 0 ||
4002ae8c:	0927d783          	lhu	a5,146(a5)
4002ae90:	00c78463          	beq	a5,a2,4002ae98 <get_slot_by_id+0x28>
		     ctx->queries[i].query_hash == query_hash)) {
			return i;
		}
	}

	return -ENOENT;
4002ae94:	ffe00513          	li	a0,-2
}
4002ae98:	00008067          	ret

4002ae9c <k_mutex_lock>:
	return z_impl_k_mutex_lock(mutex, timeout);
4002ae9c:	5a00406f          	j	4002f43c <z_impl_k_mutex_lock>

4002aea0 <release_query>:
{
4002aea0:	ff010113          	addi	sp,sp,-16
4002aea4:	00812423          	sw	s0,8(sp)
4002aea8:	00112623          	sw	ra,12(sp)
4002aeac:	00050413          	mv	s0,a0
	int busy = k_work_cancel_delayable(&pending_query->timer);
4002aeb0:	2bc050ef          	jal	ra,4003016c <k_work_cancel_delayable>
	if (busy == 0) {
4002aeb4:	00051c63          	bnez	a0,4002aecc <release_query+0x2c>
		pending_query->cb = NULL;
4002aeb8:	02042a23          	sw	zero,52(s0)
}
4002aebc:	00c12083          	lw	ra,12(sp)
4002aec0:	00812403          	lw	s0,8(sp)
4002aec4:	01010113          	addi	sp,sp,16
4002aec8:	00008067          	ret
		pending_query->query = NULL;
4002aecc:	04042423          	sw	zero,72(s0)
}
4002aed0:	fedff06f          	j	4002aebc <release_query+0x1c>

4002aed4 <dns_server_exists>:

static bool dns_server_exists(struct dns_resolve_context *ctx,
			      const struct sockaddr *addr)
{
	for (int i = 0; i < SERVER_COUNT; i++) {
		if (IS_ENABLED(CONFIG_NET_IPV4) && (addr->sa_family == AF_INET) &&
4002aed4:	0005d683          	lhu	a3,0(a1)
4002aed8:	00100813          	li	a6,1
{
4002aedc:	00050793          	mv	a5,a0
4002aee0:	00058713          	mv	a4,a1
		if (IS_ENABLED(CONFIG_NET_IPV4) && (addr->sa_family == AF_INET) &&
4002aee4:	07069e63          	bne	a3,a6,4002af60 <dns_server_exists+0x8c>
4002aee8:	00055603          	lhu	a2,0(a0)
				return true;
			}
		}
	}

	return false;
4002aeec:	00000513          	li	a0,0
		if (IS_ENABLED(CONFIG_NET_IPV4) && (addr->sa_family == AF_INET) &&
4002aef0:	04d61e63          	bne	a2,a3,4002af4c <dns_server_exists+0x78>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4002aef4:	0055c603          	lbu	a2,5(a1)
4002aef8:	0045c683          	lbu	a3,4(a1)
4002aefc:	0075c703          	lbu	a4,7(a1)
4002af00:	00861613          	slli	a2,a2,0x8
4002af04:	00d66633          	or	a2,a2,a3
4002af08:	0065c683          	lbu	a3,6(a1)
4002af0c:	01871713          	slli	a4,a4,0x18
4002af10:	01069693          	slli	a3,a3,0x10
4002af14:	00c6e6b3          	or	a3,a3,a2
4002af18:	0057c603          	lbu	a2,5(a5)
4002af1c:	00d76733          	or	a4,a4,a3
4002af20:	0047c683          	lbu	a3,4(a5)
4002af24:	00861613          	slli	a2,a2,0x8
4002af28:	00d66633          	or	a2,a2,a3
4002af2c:	0067c683          	lbu	a3,6(a5)
4002af30:	0077c783          	lbu	a5,7(a5)
4002af34:	01069693          	slli	a3,a3,0x10
4002af38:	00c6e6b3          	or	a3,a3,a2
4002af3c:	01879793          	slli	a5,a5,0x18
4002af40:	00d7e7b3          	or	a5,a5,a3
			if (net_ipv4_addr_cmp(&net_sin(addr)->sin_addr,
4002af44:	00f71463          	bne	a4,a5,4002af4c <dns_server_exists+0x78>
				return true;
4002af48:	00100513          	li	a0,1
}
4002af4c:	00008067          	ret
				return true;
4002af50:	00100513          	li	a0,1
}
4002af54:	00c12083          	lw	ra,12(sp)
4002af58:	01010113          	addi	sp,sp,16
4002af5c:	00008067          	ret
4002af60:	00200613          	li	a2,2
		if (IS_ENABLED(CONFIG_NET_IPV6) && (addr->sa_family == AF_INET6) &&
4002af64:	02c69863          	bne	a3,a2,4002af94 <dns_server_exists+0xc0>
4002af68:	00055783          	lhu	a5,0(a0)
4002af6c:	02d79463          	bne	a5,a3,4002af94 <dns_server_exists+0xc0>
{
4002af70:	ff010113          	addi	sp,sp,-16
4002af74:	00450593          	addi	a1,a0,4
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4002af78:	01000613          	li	a2,16
4002af7c:	00470513          	addi	a0,a4,4
4002af80:	00112623          	sw	ra,12(sp)
4002af84:	cf5e10ef          	jal	ra,4000cc78 <memcmp>
			if (net_ipv6_addr_cmp(&net_sin6(addr)->sin6_addr,
4002af88:	fc0504e3          	beqz	a0,4002af50 <dns_server_exists+0x7c>
	return false;
4002af8c:	00000513          	li	a0,0
4002af90:	fc5ff06f          	j	4002af54 <dns_server_exists+0x80>
4002af94:	00000513          	li	a0,0
4002af98:	00008067          	ret

4002af9c <dns_postprocess_server>:
{
4002af9c:	fe010113          	addi	sp,sp,-32
4002afa0:	01212823          	sw	s2,16(sp)
	struct sockaddr *addr = &ctx->servers[idx].dns_server;
4002afa4:	00559913          	slli	s2,a1,0x5
{
4002afa8:	00812c23          	sw	s0,24(sp)
4002afac:	00912a23          	sw	s1,20(sp)
4002afb0:	00112e23          	sw	ra,28(sp)
4002afb4:	01312623          	sw	s3,12(sp)
	struct sockaddr *addr = &ctx->servers[idx].dns_server;
4002afb8:	01250433          	add	s0,a0,s2
	if (addr->sa_family == AF_INET) {
4002afbc:	00045703          	lhu	a4,0(s0)
4002afc0:	00100793          	li	a5,1
{
4002afc4:	00050493          	mv	s1,a0
	if (addr->sa_family == AF_INET) {
4002afc8:	0af71263          	bne	a4,a5,4002b06c <dns_postprocess_server+0xd0>
		if (net_ipv4_is_addr_mcast(&net_sin(addr)->sin_addr) &&
4002afcc:	00440993          	addi	s3,s0,4
4002afd0:	00098513          	mv	a0,s3
4002afd4:	e61ff0ef          	jal	ra,4002ae34 <net_ipv4_is_addr_mcast>
4002afd8:	02050063          	beqz	a0,4002aff8 <dns_postprocess_server+0x5c>
4002afdc:	00744703          	lbu	a4,7(s0)
4002afe0:	0fb00793          	li	a5,251
4002afe4:	00f71a63          	bne	a4,a5,4002aff8 <dns_postprocess_server+0x5c>
		ctx->servers[idx].is_mdns = server_is_mdns(AF_INET6, addr);
4002afe8:	01c44783          	lbu	a5,28(s0)
4002afec:	0017e793          	ori	a5,a5,1
4002aff0:	00f40e23          	sb	a5,28(s0)
		if (!ctx->servers[idx].is_mdns) {
4002aff4:	0480006f          	j	4002b03c <dns_postprocess_server+0xa0>
		ctx->servers[idx].is_mdns = server_is_mdns(AF_INET, addr);
4002aff8:	01248733          	add	a4,s1,s2
4002affc:	01c74783          	lbu	a5,28(a4)
		if (net_ipv4_is_addr_mcast(&net_sin(addr)->sin_addr) &&
4002b000:	00098513          	mv	a0,s3
		ctx->servers[idx].is_mdns = server_is_mdns(AF_INET, addr);
4002b004:	ffe7f793          	andi	a5,a5,-2
4002b008:	00f70e23          	sb	a5,28(a4)
		if (net_ipv4_is_addr_mcast(&net_sin(addr)->sin_addr) &&
4002b00c:	e29ff0ef          	jal	ra,4002ae34 <net_ipv4_is_addr_mcast>
4002b010:	00050863          	beqz	a0,4002b020 <dns_postprocess_server+0x84>
4002b014:	00744783          	lbu	a5,7(s0)
4002b018:	f0478793          	addi	a5,a5,-252
4002b01c:	0017b513          	seqz	a0,a5
			ctx->servers[idx].is_llmnr =
4002b020:	01248933          	add	s2,s1,s2
4002b024:	01c94703          	lbu	a4,28(s2)
4002b028:	00157513          	andi	a0,a0,1
4002b02c:	00151793          	slli	a5,a0,0x1
4002b030:	ffd77713          	andi	a4,a4,-3
4002b034:	00f767b3          	or	a5,a4,a5
4002b038:	00f90e23          	sb	a5,28(s2)
		if (net_sin6(addr)->sin6_port == 0U) {
4002b03c:	00245783          	lhu	a5,2(s0)
4002b040:	00079863          	bnez	a5,4002b050 <dns_postprocess_server+0xb4>
				net_sin6(addr)->sin6_port = htons(53);
4002b044:	000037b7          	lui	a5,0x3
4002b048:	50078793          	addi	a5,a5,1280 # 3500 <CONFIG_SRAM_SIZE+0x1500>
4002b04c:	00f41123          	sh	a5,2(s0)
}
4002b050:	01c12083          	lw	ra,28(sp)
4002b054:	01812403          	lw	s0,24(sp)
4002b058:	01412483          	lw	s1,20(sp)
4002b05c:	01012903          	lw	s2,16(sp)
4002b060:	00c12983          	lw	s3,12(sp)
4002b064:	02010113          	addi	sp,sp,32
4002b068:	00008067          	ret
		if (net_ipv6_is_addr_mcast(&net_sin6(addr)->sin6_addr) &&
4002b06c:	00444703          	lbu	a4,4(s0)
4002b070:	0ff00793          	li	a5,255
4002b074:	00f71863          	bne	a4,a5,4002b084 <dns_postprocess_server+0xe8>
4002b078:	01344703          	lbu	a4,19(s0)
4002b07c:	0fb00793          	li	a5,251
4002b080:	f6f704e3          	beq	a4,a5,4002afe8 <dns_postprocess_server+0x4c>
		ctx->servers[idx].is_mdns = server_is_mdns(AF_INET6, addr);
4002b084:	01248733          	add	a4,s1,s2
4002b088:	01c74783          	lbu	a5,28(a4)
4002b08c:	ffe7f793          	andi	a5,a5,-2
4002b090:	00f70e23          	sb	a5,28(a4)
		if (net_ipv6_is_addr_mcast(&net_sin6(addr)->sin6_addr) &&
4002b094:	00444703          	lbu	a4,4(s0)
4002b098:	0ff00793          	li	a5,255
4002b09c:	02f70263          	beq	a4,a5,4002b0c0 <dns_postprocess_server+0x124>
		return false;
4002b0a0:	00000793          	li	a5,0
			ctx->servers[idx].is_llmnr =
4002b0a4:	012484b3          	add	s1,s1,s2
4002b0a8:	01c4c703          	lbu	a4,28(s1)
4002b0ac:	00179793          	slli	a5,a5,0x1
4002b0b0:	ffd77713          	andi	a4,a4,-3
4002b0b4:	00f767b3          	or	a5,a4,a5
4002b0b8:	00f48e23          	sb	a5,28(s1)
4002b0bc:	f81ff06f          	j	4002b03c <dns_postprocess_server+0xa0>
		if (net_ipv6_is_addr_mcast(&net_sin6(addr)->sin6_addr) &&
4002b0c0:	01344783          	lbu	a5,19(s0)
4002b0c4:	ffd78793          	addi	a5,a5,-3
4002b0c8:	0017b793          	seqz	a5,a5
4002b0cc:	fd9ff06f          	j	4002b0a4 <dns_postprocess_server+0x108>

4002b0d0 <dns_resolve_init_locked>:
{
4002b0d0:	fc010113          	addi	sp,sp,-64
4002b0d4:	02812c23          	sw	s0,56(sp)
4002b0d8:	02912a23          	sw	s1,52(sp)
4002b0dc:	03212823          	sw	s2,48(sp)
4002b0e0:	00050413          	mv	s0,a0
4002b0e4:	00058493          	mv	s1,a1
4002b0e8:	00060913          	mv	s2,a2
	struct sockaddr_in6 local_addr6 = {
4002b0ec:	00000593          	li	a1,0
4002b0f0:	01600613          	li	a2,22
4002b0f4:	00a10513          	addi	a0,sp,10
{
4002b0f8:	02112e23          	sw	ra,60(sp)
4002b0fc:	03312623          	sw	s3,44(sp)
	struct sockaddr_in6 local_addr6 = {
4002b100:	c1de10ef          	jal	ra,4000cd1c <memset>
4002b104:	00200793          	li	a5,2
	struct sockaddr_in local_addr4 = {
4002b108:	00100713          	li	a4,1
	struct sockaddr_in6 local_addr6 = {
4002b10c:	00f11423          	sh	a5,8(sp)
	struct sockaddr_in local_addr4 = {
4002b110:	00011123          	sh	zero,2(sp)
4002b114:	00011223          	sh	zero,4(sp)
4002b118:	00011323          	sh	zero,6(sp)
4002b11c:	00e11023          	sh	a4,0(sp)
		return -ENOENT;
4002b120:	ffe00513          	li	a0,-2
	if (!ctx) {
4002b124:	0a040863          	beqz	s0,4002b1d4 <dns_resolve_init_locked+0x104>
	if (ctx->state != DNS_RESOLVE_CONTEXT_INACTIVE) {
4002b128:	09842703          	lw	a4,152(s0)
		ret = -ENOTEMPTY;
4002b12c:	fa600513          	li	a0,-90
	if (ctx->state != DNS_RESOLVE_CONTEXT_INACTIVE) {
4002b130:	0af71263          	bne	a4,a5,4002b1d4 <dns_resolve_init_locked+0x104>
	if (servers) {
4002b134:	00048663          	beqz	s1,4002b140 <dns_resolve_init_locked+0x70>
		for (i = 0; idx < SERVER_COUNT && servers[i]; i++) {
4002b138:	0004a783          	lw	a5,0(s1)
4002b13c:	0a079a63          	bnez	a5,4002b1f0 <dns_resolve_init_locked+0x120>
	if (servers_sa) {
4002b140:	0e091a63          	bnez	s2,4002b234 <dns_resolve_init_locked+0x164>
	     i < SERVER_COUNT && ctx->servers[i].dns_server.sa_family; i++) {
4002b144:	00045783          	lhu	a5,0(s0)
		ret = -EINVAL;
4002b148:	fea00513          	li	a0,-22
	     i < SERVER_COUNT && ctx->servers[i].dns_server.sa_family; i++) {
4002b14c:	08078463          	beqz	a5,4002b1d4 <dns_resolve_init_locked+0x104>
		if (ctx->servers[i].dns_server.sa_family == AF_INET6) {
4002b150:	00200713          	li	a4,2
4002b154:	0ee78c63          	beq	a5,a4,4002b24c <dns_resolve_init_locked+0x17c>
		if (ctx->servers[i].dns_server.sa_family == AF_INET) {
4002b158:	00100713          	li	a4,1
			ret = -EAFNOSUPPORT;
4002b15c:	f9600513          	li	a0,-106
		if (ctx->servers[i].dns_server.sa_family == AF_INET) {
4002b160:	06e79a63          	bne	a5,a4,4002b1d4 <dns_resolve_init_locked+0x104>
			local_addr = (struct sockaddr *)&local_addr4;
4002b164:	00010493          	mv	s1,sp
			addr_len = sizeof(struct sockaddr_in);
4002b168:	00800913          	li	s2,8
		ret = net_context_get(ctx->servers[i].dns_server.sa_family,
4002b16c:	01840693          	addi	a3,s0,24
4002b170:	01100613          	li	a2,17
4002b174:	00200593          	li	a1,2
4002b178:	00078513          	mv	a0,a5
4002b17c:	bbdea0ef          	jal	ra,40015d38 <net_context_get>
		if (ret < 0) {
4002b180:	04054a63          	bltz	a0,4002b1d4 <dns_resolve_init_locked+0x104>
		ret = net_context_bind(ctx->servers[i].net_ctx,
4002b184:	01842503          	lw	a0,24(s0)
4002b188:	00090613          	mv	a2,s2
4002b18c:	00048593          	mv	a1,s1
4002b190:	f11ea0ef          	jal	ra,400160a0 <net_context_bind>
		if (ret < 0) {
4002b194:	04054063          	bltz	a0,4002b1d4 <dns_resolve_init_locked+0x104>
	return net_if_get_by_index(context->iface);
4002b198:	01842783          	lw	a5,24(s0)
4002b19c:	07678503          	lb	a0,118(a5)
4002b1a0:	98de50ef          	jal	ra,40010b2c <z_impl_net_if_get_by_index>
4002b1a4:	00050593          	mv	a1,a0
	net_mgmt_event_notify_with_info(mgmt_event, iface, NULL, 0);
4002b1a8:	f1140537          	lui	a0,0xf1140
4002b1ac:	00350513          	addi	a0,a0,3 # f1140003 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf1140004>
4002b1b0:	00000693          	li	a3,0
4002b1b4:	00000613          	li	a2,0
4002b1b8:	d14ea0ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
	ctx->buf_timeout = DNS_BUF_TIMEOUT;
4002b1bc:	03200713          	li	a4,50
4002b1c0:	00000793          	li	a5,0
	ctx->state = DNS_RESOLVE_CONTEXT_ACTIVE;
4002b1c4:	08042c23          	sw	zero,152(s0)
	ctx->buf_timeout = DNS_BUF_TIMEOUT;
4002b1c8:	02e42c23          	sw	a4,56(s0)
4002b1cc:	02f42e23          	sw	a5,60(s0)
	ret = 0;
4002b1d0:	00000513          	li	a0,0
}
4002b1d4:	03c12083          	lw	ra,60(sp)
4002b1d8:	03812403          	lw	s0,56(sp)
4002b1dc:	03412483          	lw	s1,52(sp)
4002b1e0:	03012903          	lw	s2,48(sp)
4002b1e4:	02c12983          	lw	s3,44(sp)
4002b1e8:	04010113          	addi	sp,sp,64
4002b1ec:	00008067          	ret
			(void)memset(addr, 0, sizeof(*addr));
4002b1f0:	01800613          	li	a2,24
4002b1f4:	00000593          	li	a1,0
4002b1f8:	00040513          	mv	a0,s0
4002b1fc:	b21e10ef          	jal	ra,4000cd1c <memset>
			ret = net_ipaddr_parse(servers[i], strlen(servers[i]),
4002b200:	0004a983          	lw	s3,0(s1)
			if (!ret) {
4002b204:	00448493          	addi	s1,s1,4
			ret = net_ipaddr_parse(servers[i], strlen(servers[i]),
4002b208:	00098513          	mv	a0,s3
4002b20c:	9c9e10ef          	jal	ra,4000cbd4 <strlen>
4002b210:	00050593          	mv	a1,a0
4002b214:	00040613          	mv	a2,s0
4002b218:	00098513          	mv	a0,s3
4002b21c:	f69e90ef          	jal	ra,40015184 <net_ipaddr_parse>
			if (!ret) {
4002b220:	f0050ce3          	beqz	a0,4002b138 <dns_resolve_init_locked+0x68>
			dns_postprocess_server(ctx, idx);
4002b224:	00000593          	li	a1,0
4002b228:	00040513          	mv	a0,s0
4002b22c:	d71ff0ef          	jal	ra,4002af9c <dns_postprocess_server>
		for (i = 0; idx < SERVER_COUNT && servers_sa[i]; i++) {
4002b230:	f15ff06f          	j	4002b144 <dns_resolve_init_locked+0x74>
4002b234:	00092583          	lw	a1,0(s2)
4002b238:	f00586e3          	beqz	a1,4002b144 <dns_resolve_init_locked+0x74>
			memcpy(&ctx->servers[idx].dns_server, servers_sa[i],
4002b23c:	01800613          	li	a2,24
4002b240:	00040513          	mv	a0,s0
4002b244:	ab5e10ef          	jal	ra,4000ccf8 <memcpy>
4002b248:	fddff06f          	j	4002b224 <dns_resolve_init_locked+0x154>
			local_addr = (struct sockaddr *)&local_addr6;
4002b24c:	00810493          	addi	s1,sp,8
			addr_len = sizeof(struct sockaddr_in6);
4002b250:	01800913          	li	s2,24
4002b254:	f19ff06f          	j	4002b16c <dns_resolve_init_locked+0x9c>

4002b258 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
4002b258:	3400406f          	j	4002f598 <z_impl_k_mutex_unlock>

4002b25c <dns_resolve_cancel_with_hash.constprop.0>:
static int dns_resolve_cancel_with_hash(struct dns_resolve_context *ctx,
4002b25c:	fe010113          	addi	sp,sp,-32
4002b260:	01312623          	sw	s3,12(sp)
	k_mutex_lock(&ctx->lock, K_FOREVER);
4002b264:	02050993          	addi	s3,a0,32
static int dns_resolve_cancel_with_hash(struct dns_resolve_context *ctx,
4002b268:	00812c23          	sw	s0,24(sp)
4002b26c:	00912a23          	sw	s1,20(sp)
4002b270:	01212823          	sw	s2,16(sp)
4002b274:	00050413          	mv	s0,a0
4002b278:	00058493          	mv	s1,a1
4002b27c:	00060913          	mv	s2,a2
	k_mutex_lock(&ctx->lock, K_FOREVER);
4002b280:	fff00593          	li	a1,-1
4002b284:	fff00613          	li	a2,-1
4002b288:	00098513          	mv	a0,s3
static int dns_resolve_cancel_with_hash(struct dns_resolve_context *ctx,
4002b28c:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&ctx->lock, K_FOREVER);
4002b290:	c0dff0ef          	jal	ra,4002ae9c <k_mutex_lock>
	if (ctx->state == DNS_RESOLVE_CONTEXT_DEACTIVATING) {
4002b294:	09842703          	lw	a4,152(s0)
4002b298:	00100793          	li	a5,1
4002b29c:	04f70263          	beq	a4,a5,4002b2e0 <dns_resolve_cancel_with_hash.constprop.0+0x84>
	i = get_slot_by_id(ctx, dns_id, query_hash);
4002b2a0:	00048593          	mv	a1,s1
4002b2a4:	00090613          	mv	a2,s2
4002b2a8:	00040513          	mv	a0,s0
4002b2ac:	bc5ff0ef          	jal	ra,4002ae70 <get_slot_by_id>
		ret = -ENOENT;
4002b2b0:	ffe00493          	li	s1,-2
	if (i < 0) {
4002b2b4:	02054863          	bltz	a0,4002b2e4 <dns_resolve_cancel_with_hash.constprop.0+0x88>
	invoke_query_callback(DNS_EAI_CANCELED, NULL, &ctx->queries[slot]);
4002b2b8:	05800793          	li	a5,88
4002b2bc:	02f50533          	mul	a0,a0,a5
4002b2c0:	00000593          	li	a1,0
4002b2c4:	04050513          	addi	a0,a0,64
4002b2c8:	00a40433          	add	s0,s0,a0
4002b2cc:	00040613          	mv	a2,s0
4002b2d0:	f9b00513          	li	a0,-101
4002b2d4:	b81ff0ef          	jal	ra,4002ae54 <invoke_query_callback>
	release_query(&ctx->queries[slot]);
4002b2d8:	00040513          	mv	a0,s0
4002b2dc:	bc5ff0ef          	jal	ra,4002aea0 <release_query>
	int ret = 0;
4002b2e0:	00000493          	li	s1,0
	k_mutex_unlock(&ctx->lock);
4002b2e4:	00098513          	mv	a0,s3
4002b2e8:	f71ff0ef          	jal	ra,4002b258 <k_mutex_unlock.isra.0>
}
4002b2ec:	01c12083          	lw	ra,28(sp)
4002b2f0:	01812403          	lw	s0,24(sp)
4002b2f4:	01012903          	lw	s2,16(sp)
4002b2f8:	00c12983          	lw	s3,12(sp)
4002b2fc:	00048513          	mv	a0,s1
4002b300:	01412483          	lw	s1,20(sp)
4002b304:	02010113          	addi	sp,sp,32
4002b308:	00008067          	ret

4002b30c <query_timeout>:
{
4002b30c:	ff010113          	addi	sp,sp,-16
4002b310:	00812423          	sw	s0,8(sp)
4002b314:	00112623          	sw	ra,12(sp)
4002b318:	00050413          	mv	s0,a0
	ret = k_mutex_lock(&pending_query->ctx->lock, K_NO_WAIT);
4002b31c:	03052503          	lw	a0,48(a0)
4002b320:	00000593          	li	a1,0
4002b324:	00000613          	li	a2,0
4002b328:	02050513          	addi	a0,a0,32
4002b32c:	b71ff0ef          	jal	ra,4002ae9c <k_mutex_lock>
	if (ret != 0) {
4002b330:	02050063          	beqz	a0,4002b350 <query_timeout+0x44>
		k_work_reschedule(dwork, K_MSEC(10));
4002b334:	00040513          	mv	a0,s0
}
4002b338:	00812403          	lw	s0,8(sp)
4002b33c:	00c12083          	lw	ra,12(sp)
		k_work_reschedule(dwork, K_MSEC(10));
4002b340:	00100593          	li	a1,1
4002b344:	00000613          	li	a2,0
}
4002b348:	01010113          	addi	sp,sp,16
		k_work_reschedule(dwork, K_MSEC(10));
4002b34c:	6090406f          	j	40030154 <k_work_reschedule>
	(void)dns_resolve_cancel_with_hash(pending_query->ctx,
4002b350:	05245603          	lhu	a2,82(s0)
4002b354:	05045583          	lhu	a1,80(s0)
4002b358:	03042503          	lw	a0,48(s0)
4002b35c:	f01ff0ef          	jal	ra,4002b25c <dns_resolve_cancel_with_hash.constprop.0>
	k_mutex_unlock(&pending_query->ctx->lock);
4002b360:	03042503          	lw	a0,48(s0)
}
4002b364:	00812403          	lw	s0,8(sp)
4002b368:	00c12083          	lw	ra,12(sp)
	k_mutex_unlock(&pending_query->ctx->lock);
4002b36c:	02050513          	addi	a0,a0,32
}
4002b370:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&pending_query->ctx->lock);
4002b374:	ee5ff06f          	j	4002b258 <k_mutex_unlock.isra.0>

4002b378 <dns_resolve_close_locked>:
	if (ctx->state != DNS_RESOLVE_CONTEXT_ACTIVE) {
4002b378:	09852783          	lw	a5,152(a0)
4002b37c:	08079863          	bnez	a5,4002b40c <dns_resolve_close_locked+0x94>
{
4002b380:	ff010113          	addi	sp,sp,-16
4002b384:	00812423          	sw	s0,8(sp)
4002b388:	00912223          	sw	s1,4(sp)
	ctx->state = DNS_RESOLVE_CONTEXT_DEACTIVATING;
4002b38c:	00100793          	li	a5,1
{
4002b390:	00112623          	sw	ra,12(sp)
	k_mutex_unlock(&ctx->lock);
4002b394:	02050493          	addi	s1,a0,32
	ctx->state = DNS_RESOLVE_CONTEXT_DEACTIVATING;
4002b398:	08f52c23          	sw	a5,152(a0)
4002b39c:	00050413          	mv	s0,a0
	k_mutex_unlock(&ctx->lock);
4002b3a0:	00048513          	mv	a0,s1
4002b3a4:	eb5ff0ef          	jal	ra,4002b258 <k_mutex_unlock.isra.0>
		if (ctx->servers[i].net_ctx) {
4002b3a8:	01842783          	lw	a5,24(s0)
4002b3ac:	02078863          	beqz	a5,4002b3dc <dns_resolve_close_locked+0x64>
4002b3b0:	07678503          	lb	a0,118(a5)
4002b3b4:	f78e50ef          	jal	ra,40010b2c <z_impl_net_if_get_by_index>
4002b3b8:	00050593          	mv	a1,a0
4002b3bc:	f1140537          	lui	a0,0xf1140
4002b3c0:	00000693          	li	a3,0
4002b3c4:	00000613          	li	a2,0
4002b3c8:	00450513          	addi	a0,a0,4 # f1140004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf1140005>
4002b3cc:	b00ea0ef          	jal	ra,400156cc <net_mgmt_event_notify_with_info>
			net_context_put(ctx->servers[i].net_ctx);
4002b3d0:	01842503          	lw	a0,24(s0)
4002b3d4:	c41ea0ef          	jal	ra,40016014 <net_context_put>
			ctx->servers[i].net_ctx = NULL;
4002b3d8:	00042c23          	sw	zero,24(s0)
	k_mutex_lock(&ctx->lock, K_FOREVER);
4002b3dc:	00048513          	mv	a0,s1
4002b3e0:	fff00593          	li	a1,-1
4002b3e4:	fff00613          	li	a2,-1
4002b3e8:	ab5ff0ef          	jal	ra,4002ae9c <k_mutex_lock>
	ctx->state = DNS_RESOLVE_CONTEXT_INACTIVE;
4002b3ec:	00200793          	li	a5,2
4002b3f0:	08f42c23          	sw	a5,152(s0)
}
4002b3f4:	00c12083          	lw	ra,12(sp)
4002b3f8:	00812403          	lw	s0,8(sp)
4002b3fc:	00412483          	lw	s1,4(sp)
	return 0;
4002b400:	00000513          	li	a0,0
}
4002b404:	01010113          	addi	sp,sp,16
4002b408:	00008067          	ret
		return -ENOENT;
4002b40c:	ffe00513          	li	a0,-2
}
4002b410:	00008067          	ret

4002b414 <dns_write.constprop.0>:
static int dns_write(struct dns_resolve_context *ctx,
4002b414:	fc010113          	addi	sp,sp,-64
4002b418:	03312623          	sw	s3,44(sp)
	query_type = ctx->queries[query_idx].query_type;
4002b41c:	05800993          	li	s3,88
4002b420:	033589b3          	mul	s3,a1,s3
static int dns_write(struct dns_resolve_context *ctx,
4002b424:	02812c23          	sw	s0,56(sp)
4002b428:	02912a23          	sw	s1,52(sp)
4002b42c:	03212823          	sw	s2,48(sp)
4002b430:	03512223          	sw	s5,36(sp)
4002b434:	02112e23          	sw	ra,60(sp)
4002b438:	03412423          	sw	s4,40(sp)
4002b43c:	00060913          	mv	s2,a2
	net_ctx = ctx->servers[server_idx].net_ctx;
4002b440:	01852a03          	lw	s4,24(a0)
	ret = dns_msg_pack_query(dns_data->data, &dns_data->len, dns_data->size,
4002b444:	0106d703          	lhu	a4,16(a3)
	query_type = ctx->queries[query_idx].query_type;
4002b448:	013509b3          	add	s3,a0,s3
static int dns_write(struct dns_resolve_context *ctx,
4002b44c:	00050413          	mv	s0,a0
4002b450:	00068a93          	mv	s5,a3
	ret = dns_msg_pack_query(dns_data->data, &dns_data->len, dns_data->size,
4002b454:	08c9a803          	lw	a6,140(s3)
4002b458:	0909d783          	lhu	a5,144(s3)
4002b45c:	00c6a683          	lw	a3,12(a3)
4002b460:	01265603          	lhu	a2,18(a2)
4002b464:	00c92503          	lw	a0,12(s2)
static int dns_write(struct dns_resolve_context *ctx,
4002b468:	00058493          	mv	s1,a1
	ret = dns_msg_pack_query(dns_data->data, &dns_data->len, dns_data->size,
4002b46c:	01090593          	addi	a1,s2,16
4002b470:	f00ff0ef          	jal	ra,4002ab70 <dns_msg_pack_query>
	if (ret < 0) {
4002b474:	10054463          	bltz	a0,4002b57c <dns_write.constprop.0+0x168>
			   dns_qname->len + 2);
4002b478:	010ad683          	lhu	a3,16(s5)
		crc16_ansi(dns_data->data + DNS_MSG_HEADER_SIZE,
4002b47c:	00c92603          	lw	a2,12(s2)
 *
 * @return The computed CRC16 value
 */
static inline uint16_t crc16_ansi(const uint8_t *src, size_t len)
{
	return crc16_reflect(0xA001, 0xffff, src, len);
4002b480:	000105b7          	lui	a1,0x10
4002b484:	0000a537          	lui	a0,0xa
4002b488:	00268693          	addi	a3,a3,2
4002b48c:	00c60613          	addi	a2,a2,12
4002b490:	fff58593          	addi	a1,a1,-1 # ffff <__kernel_ram_size+0x44f7>
4002b494:	00150513          	addi	a0,a0,1 # a001 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x6001>
4002b498:	be0d70ef          	jal	ra,40002878 <crc16_reflect>
	ctx->queries[query_idx].query_hash =
4002b49c:	08a99923          	sh	a0,146(s3)
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
4002b4a0:	074a5783          	lhu	a5,116(s4)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
4002b4a4:	00200713          	li	a4,2
4002b4a8:	0037d793          	srli	a5,a5,0x3
4002b4ac:	0077f793          	andi	a5,a5,7
4002b4b0:	00e79663          	bne	a5,a4,4002b4bc <dns_write.constprop.0+0xa8>
	context->ipv4_ttl = ttl;
4002b4b4:	060a0ba3          	sb	zero,119(s4)
}
4002b4b8:	00c0006f          	j	4002b4c4 <dns_write.constprop.0+0xb0>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
4002b4bc:	00100713          	li	a4,1
4002b4c0:	fee78ae3          	beq	a5,a4,4002b4b4 <dns_write.constprop.0+0xa0>
	ret = net_context_recv(net_ctx, cb_recv, K_NO_WAIT, ctx);
4002b4c4:	4002b5b7          	lui	a1,0x4002b
4002b4c8:	00040713          	mv	a4,s0
4002b4cc:	00000613          	li	a2,0
4002b4d0:	00000693          	li	a3,0
4002b4d4:	72058593          	addi	a1,a1,1824 # 4002b720 <cb_recv>
4002b4d8:	000a0513          	mv	a0,s4
4002b4dc:	a85eb0ef          	jal	ra,40016f60 <net_context_recv>
	if (ret < 0 && ret != -EALREADY) {
4002b4e0:	00055663          	bgez	a0,4002b4ec <dns_write.constprop.0+0xd8>
4002b4e4:	f8800793          	li	a5,-120
4002b4e8:	06f51863          	bne	a0,a5,4002b558 <dns_write.constprop.0+0x144>
	if (server->sa_family == AF_INET) {
4002b4ec:	00045683          	lhu	a3,0(s0)
4002b4f0:	00100793          	li	a5,1
		server_addr_len = sizeof(struct sockaddr_in6);
4002b4f4:	01800713          	li	a4,24
	if (server->sa_family == AF_INET) {
4002b4f8:	00f69463          	bne	a3,a5,4002b500 <dns_write.constprop.0+0xec>
		server_addr_len = sizeof(struct sockaddr_in);
4002b4fc:	00800713          	li	a4,8
	ret = k_work_reschedule(&ctx->queries[query_idx].timer,
4002b500:	05800793          	li	a5,88
4002b504:	02f484b3          	mul	s1,s1,a5
4002b508:	00e12e23          	sw	a4,28(sp)
4002b50c:	009407b3          	add	a5,s0,s1
4002b510:	0807a583          	lw	a1,128(a5)
4002b514:	0847a603          	lw	a2,132(a5)
4002b518:	04048493          	addi	s1,s1,64
4002b51c:	00940533          	add	a0,s0,s1
4002b520:	435040ef          	jal	ra,40030154 <k_work_reschedule>
	if (ret < 0) {
4002b524:	02054a63          	bltz	a0,4002b558 <dns_write.constprop.0+0x144>
	ret = net_context_sendto(net_ctx, dns_data->data, dns_data->len,
4002b528:	00012023          	sw	zero,0(sp)
4002b52c:	01c12703          	lw	a4,28(sp)
4002b530:	01095603          	lhu	a2,16(s2)
4002b534:	00c92583          	lw	a1,12(s2)
4002b538:	00000813          	li	a6,0
4002b53c:	00000893          	li	a7,0
4002b540:	00000793          	li	a5,0
4002b544:	00040693          	mv	a3,s0
4002b548:	000a0513          	mv	a0,s4
4002b54c:	981eb0ef          	jal	ra,40016ecc <net_context_sendto>
	if (ret < 0) {
4002b550:	00a05463          	blez	a0,4002b558 <dns_write.constprop.0+0x144>
4002b554:	00000513          	li	a0,0
}
4002b558:	03c12083          	lw	ra,60(sp)
4002b55c:	03812403          	lw	s0,56(sp)
4002b560:	03412483          	lw	s1,52(sp)
4002b564:	03012903          	lw	s2,48(sp)
4002b568:	02c12983          	lw	s3,44(sp)
4002b56c:	02812a03          	lw	s4,40(sp)
4002b570:	02412a83          	lw	s5,36(sp)
4002b574:	04010113          	addi	sp,sp,64
4002b578:	00008067          	ret
		return -EINVAL;
4002b57c:	fea00513          	li	a0,-22
4002b580:	fd9ff06f          	j	4002b558 <dns_write.constprop.0+0x144>

4002b584 <dns_resolve_init>:
	if (!ctx) {
4002b584:	06050263          	beqz	a0,4002b5e8 <dns_resolve_init+0x64>
{
4002b588:	ff010113          	addi	sp,sp,-16
4002b58c:	00912223          	sw	s1,4(sp)
4002b590:	01212023          	sw	s2,0(sp)
4002b594:	00058493          	mv	s1,a1
4002b598:	00060913          	mv	s2,a2
	(void)memset(ctx, 0, sizeof(*ctx));
4002b59c:	00000593          	li	a1,0
4002b5a0:	0a000613          	li	a2,160
{
4002b5a4:	00812423          	sw	s0,8(sp)
4002b5a8:	00112623          	sw	ra,12(sp)
4002b5ac:	00050413          	mv	s0,a0
	(void)memset(ctx, 0, sizeof(*ctx));
4002b5b0:	f6ce10ef          	jal	ra,4000cd1c <memset>
	return z_impl_k_mutex_init(mutex);
4002b5b4:	02040513          	addi	a0,s0,32
4002b5b8:	66d030ef          	jal	ra,4002f424 <z_impl_k_mutex_init>
	ctx->state = DNS_RESOLVE_CONTEXT_INACTIVE;
4002b5bc:	00200793          	li	a5,2
4002b5c0:	08f42c23          	sw	a5,152(s0)
	return dns_resolve_init_locked(ctx, servers, servers_sa);
4002b5c4:	00040513          	mv	a0,s0
}
4002b5c8:	00812403          	lw	s0,8(sp)
4002b5cc:	00c12083          	lw	ra,12(sp)
	return dns_resolve_init_locked(ctx, servers, servers_sa);
4002b5d0:	00090613          	mv	a2,s2
4002b5d4:	00048593          	mv	a1,s1
}
4002b5d8:	00012903          	lw	s2,0(sp)
4002b5dc:	00412483          	lw	s1,4(sp)
4002b5e0:	01010113          	addi	sp,sp,16
	return dns_resolve_init_locked(ctx, servers, servers_sa);
4002b5e4:	aedff06f          	j	4002b0d0 <dns_resolve_init_locked>
}
4002b5e8:	ffe00513          	li	a0,-2
4002b5ec:	00008067          	ret

4002b5f0 <dns_resolve_cancel_with_name>:
{
4002b5f0:	fc010113          	addi	sp,sp,-64
4002b5f4:	03212823          	sw	s2,48(sp)
4002b5f8:	03312623          	sw	s3,44(sp)
4002b5fc:	02112e23          	sw	ra,60(sp)
4002b600:	02812c23          	sw	s0,56(sp)
4002b604:	02912a23          	sw	s1,52(sp)
4002b608:	03412423          	sw	s4,40(sp)
4002b60c:	00050913          	mv	s2,a0
4002b610:	00058993          	mv	s3,a1
	if (query_name) {
4002b614:	10060263          	beqz	a2,4002b718 <dns_resolve_cancel_with_name+0x128>
	return net_buf_alloc_fixed(pool, timeout);
4002b618:	03852583          	lw	a1,56(a0)
4002b61c:	00060493          	mv	s1,a2
4002b620:	03c52603          	lw	a2,60(a0)
4002b624:	40045537          	lui	a0,0x40045
4002b628:	92850513          	addi	a0,a0,-1752 # 40044928 <dns_msg_pool>
4002b62c:	00068a13          	mv	s4,a3
4002b630:	f75e10ef          	jal	ra,4000d5a4 <net_buf_alloc_fixed>
4002b634:	00050413          	mv	s0,a0
		if (!buf) {
4002b638:	06050263          	beqz	a0,4002b69c <dns_resolve_cancel_with_name+0xac>
		ret = dns_msg_pack_qname(&len, buf->data, buf->size,
4002b63c:	01255603          	lhu	a2,18(a0)
4002b640:	00c52583          	lw	a1,12(a0)
4002b644:	00048693          	mv	a3,s1
4002b648:	01e10513          	addi	a0,sp,30
4002b64c:	9fcff0ef          	jal	ra,4002a848 <dns_msg_pack_qname>
4002b650:	00050493          	mv	s1,a0
		if (ret >= 0) {
4002b654:	02055863          	bgez	a0,4002b684 <dns_resolve_cancel_with_name+0x94>
		net_buf_unref(buf);
4002b658:	00040513          	mv	a0,s0
4002b65c:	f61e10ef          	jal	ra,4000d5bc <net_buf_unref>
}
4002b660:	03c12083          	lw	ra,60(sp)
4002b664:	03812403          	lw	s0,56(sp)
4002b668:	03012903          	lw	s2,48(sp)
4002b66c:	02c12983          	lw	s3,44(sp)
4002b670:	02812a03          	lw	s4,40(sp)
4002b674:	00048513          	mv	a0,s1
4002b678:	03412483          	lw	s1,52(sp)
4002b67c:	04010113          	addi	sp,sp,64
4002b680:	00008067          	ret
			if ((len + 2) > buf->size) {
4002b684:	01e15583          	lhu	a1,30(sp)
4002b688:	01245783          	lhu	a5,18(s0)
4002b68c:	00158713          	addi	a4,a1,1
4002b690:	00f74a63          	blt	a4,a5,4002b6a4 <dns_resolve_cancel_with_name+0xb4>
				net_buf_unref(buf);
4002b694:	00040513          	mv	a0,s0
4002b698:	f25e10ef          	jal	ra,4000d5bc <net_buf_unref>
			return -ENOMEM;
4002b69c:	ff400493          	li	s1,-12
4002b6a0:	fc1ff06f          	j	4002b660 <dns_resolve_cancel_with_name+0x70>
	return net_buf_simple_add(&buf->b, len);
4002b6a4:	00c40493          	addi	s1,s0,12
4002b6a8:	00048513          	mv	a0,s1
4002b6ac:	91ce20ef          	jal	ra,4000d7c8 <net_buf_simple_add>
	net_buf_simple_add_be16(&buf->b, val);
4002b6b0:	010a1593          	slli	a1,s4,0x10
4002b6b4:	0105d593          	srli	a1,a1,0x10
4002b6b8:	00048513          	mv	a0,s1
4002b6bc:	924e20ef          	jal	ra,4000d7e0 <net_buf_simple_add_be16>
			query_hash = crc16_ansi(buf->data, len + 2);
4002b6c0:	01e15683          	lhu	a3,30(sp)
4002b6c4:	00c42603          	lw	a2,12(s0)
4002b6c8:	000105b7          	lui	a1,0x10
4002b6cc:	0000a537          	lui	a0,0xa
4002b6d0:	00268693          	addi	a3,a3,2
4002b6d4:	fff58593          	addi	a1,a1,-1 # ffff <__kernel_ram_size+0x44f7>
4002b6d8:	00150513          	addi	a0,a0,1 # a001 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x6001>
4002b6dc:	99cd70ef          	jal	ra,40002878 <crc16_reflect>
4002b6e0:	00a12623          	sw	a0,12(sp)
		net_buf_unref(buf);
4002b6e4:	00040513          	mv	a0,s0
4002b6e8:	ed5e10ef          	jal	ra,4000d5bc <net_buf_unref>
		if (ret < 0) {
4002b6ec:	00c12603          	lw	a2,12(sp)
}
4002b6f0:	03812403          	lw	s0,56(sp)
4002b6f4:	03c12083          	lw	ra,60(sp)
4002b6f8:	03412483          	lw	s1,52(sp)
4002b6fc:	02812a03          	lw	s4,40(sp)
	return dns_resolve_cancel_with_hash(ctx, dns_id, query_hash,
4002b700:	00098593          	mv	a1,s3
4002b704:	00090513          	mv	a0,s2
}
4002b708:	02c12983          	lw	s3,44(sp)
4002b70c:	03012903          	lw	s2,48(sp)
4002b710:	04010113          	addi	sp,sp,64
	return dns_resolve_cancel_with_hash(ctx, dns_id, query_hash,
4002b714:	b49ff06f          	j	4002b25c <dns_resolve_cancel_with_hash.constprop.0>
	uint16_t query_hash = 0;
4002b718:	00000613          	li	a2,0
4002b71c:	fd5ff06f          	j	4002b6f0 <dns_resolve_cancel_with_name+0x100>

4002b720 <cb_recv>:
{
4002b720:	f6010113          	addi	sp,sp,-160
4002b724:	08812c23          	sw	s0,152(sp)
4002b728:	00078413          	mv	s0,a5
	k_mutex_lock(&ctx->lock, K_FOREVER);
4002b72c:	02078793          	addi	a5,a5,32
{
4002b730:	00b12223          	sw	a1,4(sp)
	k_mutex_lock(&ctx->lock, K_FOREVER);
4002b734:	00078513          	mv	a0,a5
4002b738:	fff00593          	li	a1,-1
4002b73c:	fff00613          	li	a2,-1
{
4002b740:	09612023          	sw	s6,128(sp)
	k_mutex_lock(&ctx->lock, K_FOREVER);
4002b744:	00f12423          	sw	a5,8(sp)
{
4002b748:	08112e23          	sw	ra,156(sp)
4002b74c:	08912a23          	sw	s1,148(sp)
4002b750:	09212823          	sw	s2,144(sp)
4002b754:	09312623          	sw	s3,140(sp)
4002b758:	09412423          	sw	s4,136(sp)
4002b75c:	09512223          	sw	s5,132(sp)
4002b760:	07712e23          	sw	s7,124(sp)
4002b764:	07812c23          	sw	s8,120(sp)
4002b768:	07912a23          	sw	s9,116(sp)
4002b76c:	07a12823          	sw	s10,112(sp)
4002b770:	07b12623          	sw	s11,108(sp)
4002b774:	00070b13          	mv	s6,a4
	k_mutex_lock(&ctx->lock, K_FOREVER);
4002b778:	f24ff0ef          	jal	ra,4002ae9c <k_mutex_lock>
	if (ctx->state != DNS_RESOLVE_CONTEXT_ACTIVE) {
4002b77c:	09842783          	lw	a5,152(s0)
4002b780:	40079663          	bnez	a5,4002bb8c <cb_recv+0x46c>
	if (status) {
4002b784:	480b1463          	bnez	s6,4002bc0c <cb_recv+0x4ec>
	return net_buf_alloc_fixed(pool, timeout);
4002b788:	03842583          	lw	a1,56(s0)
4002b78c:	03c42603          	lw	a2,60(s0)
4002b790:	40045537          	lui	a0,0x40045
4002b794:	92850513          	addi	a0,a0,-1752 # 40044928 <dns_msg_pool>
4002b798:	e0de10ef          	jal	ra,4000d5a4 <net_buf_alloc_fixed>
4002b79c:	00050993          	mv	s3,a0
	if (!dns_data) {
4002b7a0:	48050263          	beqz	a0,4002bc24 <cb_recv+0x504>
4002b7a4:	03842583          	lw	a1,56(s0)
4002b7a8:	03c42603          	lw	a2,60(s0)
4002b7ac:	40045537          	lui	a0,0x40045
4002b7b0:	95450513          	addi	a0,a0,-1708 # 40044954 <dns_qname_pool>
4002b7b4:	df1e10ef          	jal	ra,4000d5a4 <net_buf_alloc_fixed>
4002b7b8:	00050a13          	mv	s4,a0
	if (!dns_cname) {
4002b7bc:	44050063          	beqz	a0,4002bbfc <cb_recv+0x4dc>
	data_len = MIN(net_pkt_remaining_data(pkt), DNS_RESOLVER_MAX_BUF_SIZE);
4002b7c0:	00412503          	lw	a0,4(sp)
4002b7c4:	20000493          	li	s1,512
4002b7c8:	d0dec0ef          	jal	ra,400184d4 <net_pkt_remaining_data>
4002b7cc:	1ff00793          	li	a5,511
4002b7d0:	00a7e863          	bltu	a5,a0,4002b7e0 <cb_recv+0xc0>
4002b7d4:	00412503          	lw	a0,4(sp)
4002b7d8:	cfdec0ef          	jal	ra,400184d4 <net_pkt_remaining_data>
4002b7dc:	00050493          	mv	s1,a0
	ret = net_pkt_read(pkt, dns_data->data, data_len);
4002b7e0:	00c9a583          	lw	a1,12(s3)
4002b7e4:	00412503          	lw	a0,4(sp)
4002b7e8:	00048613          	mv	a2,s1
4002b7ec:	b4dec0ef          	jal	ra,40018338 <net_pkt_read>
	if (ret < 0) {
4002b7f0:	40054263          	bltz	a0,4002bbf4 <cb_recv+0x4d4>
	dns_msg.msg = dns_data->data;
4002b7f4:	00c9ab83          	lw	s7,12(s3)
	dns_msg.msg_size = data_len;
4002b7f8:	01049493          	slli	s1,s1,0x10
4002b7fc:	0104d493          	srli	s1,s1,0x10
	struct dns_addrinfo info = { 0 };
4002b800:	03400613          	li	a2,52
4002b804:	00000593          	li	a1,0
4002b808:	02c10513          	addi	a0,sp,44
	dns_msg.msg = dns_data->data;
4002b80c:	01712c23          	sw	s7,24(sp)
	dns_msg.msg_size = data_len;
4002b810:	02911423          	sh	s1,40(sp)
	struct dns_addrinfo info = { 0 };
4002b814:	d08e10ef          	jal	ra,4000cd1c <memset>
	if (dns_msg->msg_size < (sizeof(*dns_id) + sizeof(uint16_t))) {
4002b818:	00300793          	li	a5,3
4002b81c:	3a97fc63          	bgeu	a5,s1,4002bbd4 <cb_recv+0x4b4>
	return ntohs(UNALIGNED_GET((uint16_t *)(header)));
4002b820:	001bc483          	lbu	s1,1(s7)
4002b824:	000bc783          	lbu	a5,0(s7)
	if (dns_header_rcode(dns_msg->msg) == DNS_HEADER_REFUSED) {
4002b828:	00500713          	li	a4,5
4002b82c:	00849493          	slli	s1,s1,0x8
4002b830:	00f4e4b3          	or	s1,s1,a5
4002b834:	0084d793          	srli	a5,s1,0x8
4002b838:	00849913          	slli	s2,s1,0x8
4002b83c:	00f96933          	or	s2,s2,a5
4002b840:	003bc783          	lbu	a5,3(s7)
4002b844:	01091913          	slli	s2,s2,0x10
4002b848:	01095913          	srli	s2,s2,0x10
4002b84c:	00f7f793          	andi	a5,a5,15
4002b850:	02e78063          	beq	a5,a4,4002b870 <cb_recv+0x150>
	return ((*(header + 2)) & 0x80) ? 1 : 0;
4002b854:	002bcb83          	lbu	s7,2(s7)
4002b858:	007bdb93          	srli	s7,s7,0x7
	if (dns_header_qr(dns_msg->msg) == DNS_QUERY) {
4002b85c:	2c0b8663          	beqz	s7,4002bb28 <cb_recv+0x408>
	ret = dns_unpack_response_header(dns_msg, *dns_id);
4002b860:	00090593          	mv	a1,s2
4002b864:	01810513          	addi	a0,sp,24
4002b868:	a58ff0ef          	jal	ra,4002aac0 <dns_unpack_response_header>
	if (ret < 0) {
4002b86c:	00055663          	bgez	a0,4002b878 <cb_recv+0x158>
	uint16_t query_hash = 0U;
4002b870:	00000493          	li	s1,0
4002b874:	18c0006f          	j	4002ba00 <cb_recv+0x2e0>
	if (dns_header_qdcount(dns_msg->msg) != 1) {
4002b878:	01812783          	lw	a5,24(sp)
4002b87c:	0047c703          	lbu	a4,4(a5)
4002b880:	0057c783          	lbu	a5,5(a5)
4002b884:	00879793          	slli	a5,a5,0x8
4002b888:	00e7e7b3          	or	a5,a5,a4
4002b88c:	10000713          	li	a4,256
4002b890:	12e78c63          	beq	a5,a4,4002b9c8 <cb_recv+0x2a8>
		if (*dns_id > 0) {
4002b894:	fc049ee3          	bnez	s1,4002b870 <cb_recv+0x150>
	ret = dns_unpack_response_query(dns_msg);
4002b898:	01810513          	addi	a0,sp,24
4002b89c:	becff0ef          	jal	ra,4002ac88 <dns_unpack_response_query>
	if (ret < 0) {
4002b8a0:	00055663          	bgez	a0,4002b8ac <cb_recv+0x18c>
		dns_msg->answer_offset = dns_msg->query_offset;
4002b8a4:	02415783          	lhu	a5,36(sp)
4002b8a8:	02f11323          	sh	a5,38(sp)
	enum dns_rr_type answer_type = DNS_RR_TYPE_INVALID;
4002b8ac:	00012a23          	sw	zero,20(sp)
	server_idx = 0;
4002b8b0:	00000c13          	li	s8,0
	int query_idx = -1;
4002b8b4:	fff00a93          	li	s5,-1
	uint16_t query_hash = 0U;
4002b8b8:	00000493          	li	s1,0
	answer_ptr = DNS_QUERY_POS;
4002b8bc:	00c00c93          	li	s9,12
		switch (dns_msg->response_type) {
4002b8c0:	feb00d13          	li	s10,-21
4002b8c4:	fed00d93          	li	s11,-19
	while (server_idx < dns_header_ancount(dns_msg->msg)) {
4002b8c8:	01812603          	lw	a2,24(sp)
	return htons(UNALIGNED_GET((uint16_t *)(header + 6)));
4002b8cc:	00764703          	lbu	a4,7(a2)
4002b8d0:	00664683          	lbu	a3,6(a2)
4002b8d4:	00871713          	slli	a4,a4,0x8
4002b8d8:	00d76733          	or	a4,a4,a3
4002b8dc:	00871693          	slli	a3,a4,0x8
4002b8e0:	00875713          	srli	a4,a4,0x8
4002b8e4:	00e6e733          	or	a4,a3,a4
4002b8e8:	01071713          	slli	a4,a4,0x10
4002b8ec:	01075713          	srli	a4,a4,0x10
4002b8f0:	0eec4663          	blt	s8,a4,4002b9dc <cb_recv+0x2bc>
	if (*query_idx < 0) {
4002b8f4:	fff00713          	li	a4,-1
4002b8f8:	04ea9863          	bne	s5,a4,4002b948 <cb_recv+0x228>
		query_name = dns_msg->msg + dns_msg->query_offset;
4002b8fc:	02415783          	lhu	a5,36(sp)
4002b900:	00f60633          	add	a2,a2,a5
					 strlen(query_name) + 1 + 2);
4002b904:	00060513          	mv	a0,a2
4002b908:	00c12623          	sw	a2,12(sp)
4002b90c:	ac8e10ef          	jal	ra,4000cbd4 <strlen>
4002b910:	00c12603          	lw	a2,12(sp)
4002b914:	00350693          	addi	a3,a0,3
4002b918:	000105b7          	lui	a1,0x10
4002b91c:	0000a537          	lui	a0,0xa
4002b920:	fff58593          	addi	a1,a1,-1 # ffff <__kernel_ram_size+0x44f7>
4002b924:	00150513          	addi	a0,a0,1 # a001 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x6001>
4002b928:	f51d60ef          	jal	ra,40002878 <crc16_reflect>
		*query_idx = get_slot_by_id(ctx, *dns_id, *query_hash);
4002b92c:	00050613          	mv	a2,a0
4002b930:	00050493          	mv	s1,a0
4002b934:	00090593          	mv	a1,s2
4002b938:	00040513          	mv	a0,s0
4002b93c:	d34ff0ef          	jal	ra,4002ae70 <get_slot_by_id>
4002b940:	00050a93          	mv	s5,a0
		if (*query_idx < 0) {
4002b944:	2a054463          	bltz	a0,4002bbec <cb_recv+0x4cc>
	if (items == 0) {
4002b948:	280b1a63          	bnez	s6,4002bbdc <cb_recv+0x4bc>
		if (dns_msg->response_type == DNS_RESPONSE_CNAME_NO_IP) {
4002b94c:	01c12683          	lw	a3,28(sp)
4002b950:	fed00713          	li	a4,-19
4002b954:	28e69863          	bne	a3,a4,4002bbe4 <cb_recv+0x4c4>
				ret = dns_copy_qname(dns_cname->data,
4002b958:	02015703          	lhu	a4,32(sp)
4002b95c:	012a5603          	lhu	a2,18(s4)
4002b960:	00ca2503          	lw	a0,12(s4)
4002b964:	01810693          	addi	a3,sp,24
4002b968:	010a0593          	addi	a1,s4,16
4002b96c:	be0ff0ef          	jal	ra,4002ad4c <dns_copy_qname>
				if (ret < 0) {
4002b970:	26054e63          	bltz	a0,4002bbec <cb_recv+0x4cc>
	dns_resolve_cancel_with_name(ctx, *dns_id,
4002b974:	05800713          	li	a4,88
4002b978:	02ea87b3          	mul	a5,s5,a4
4002b97c:	00090593          	mv	a1,s2
4002b980:	00040513          	mv	a0,s0
4002b984:	00f407b3          	add	a5,s0,a5
4002b988:	0887a603          	lw	a2,136(a5)
4002b98c:	08c7a683          	lw	a3,140(a5)
4002b990:	c61ff0ef          	jal	ra,4002b5f0 <dns_resolve_cancel_with_name>
	net_pkt_unref(pkt);
4002b994:	00412503          	lw	a0,4(sp)
4002b998:	e85eb0ef          	jal	ra,4001781c <net_pkt_unref>
		i = get_slot_by_id(ctx, dns_id, query_hash);
4002b99c:	00090593          	mv	a1,s2
4002b9a0:	00048613          	mv	a2,s1
4002b9a4:	00040513          	mv	a0,s0
4002b9a8:	cc8ff0ef          	jal	ra,4002ae70 <get_slot_by_id>
4002b9ac:	00050593          	mv	a1,a0
		if (i < 0) {
4002b9b0:	26055e63          	bgez	a0,4002bc2c <cb_recv+0x50c>
		net_buf_unref(dns_data);
4002b9b4:	00098513          	mv	a0,s3
4002b9b8:	c05e10ef          	jal	ra,4000d5bc <net_buf_unref>
		net_buf_unref(dns_cname);
4002b9bc:	000a0513          	mv	a0,s4
4002b9c0:	bfde10ef          	jal	ra,4000d5bc <net_buf_unref>
4002b9c4:	1c80006f          	j	4002bb8c <cb_recv+0x46c>
	ret = dns_unpack_response_query(dns_msg);
4002b9c8:	01810513          	addi	a0,sp,24
4002b9cc:	abcff0ef          	jal	ra,4002ac88 <dns_unpack_response_query>
	if (ret < 0) {
4002b9d0:	ec055ee3          	bgez	a0,4002b8ac <cb_recv+0x18c>
		if (*dns_id > 0) {
4002b9d4:	ec0488e3          	beqz	s1,4002b8a4 <cb_recv+0x184>
4002b9d8:	e99ff06f          	j	4002b870 <cb_recv+0x150>
		ret = dns_unpack_answer(dns_msg, answer_ptr, &ttl,
4002b9dc:	01410693          	addi	a3,sp,20
4002b9e0:	01010613          	addi	a2,sp,16
4002b9e4:	000c8593          	mv	a1,s9
4002b9e8:	01810513          	addi	a0,sp,24
4002b9ec:	f5dfe0ef          	jal	ra,4002a948 <dns_unpack_answer>
		if (ret < 0) {
4002b9f0:	00054863          	bltz	a0,4002ba00 <cb_recv+0x2e0>
		switch (dns_msg->response_type) {
4002b9f4:	01c12703          	lw	a4,28(sp)
4002b9f8:	01a70863          	beq	a4,s10,4002ba08 <cb_recv+0x2e8>
4002b9fc:	13b70263          	beq	a4,s11,4002bb20 <cb_recv+0x400>
4002ba00:	ffc00b13          	li	s6,-4
4002ba04:	1340006f          	j	4002bb38 <cb_recv+0x418>
			if (*query_idx >= 0) {
4002ba08:	fff00713          	li	a4,-1
4002ba0c:	04ea9a63          	bne	s5,a4,4002ba60 <cb_recv+0x340>
			query_name = dns_msg->msg + dns_msg->query_offset;
4002ba10:	02415783          	lhu	a5,36(sp)
4002ba14:	01812603          	lw	a2,24(sp)
4002ba18:	00f60633          	add	a2,a2,a5
						 strlen(query_name) + 1 + 2);
4002ba1c:	00060513          	mv	a0,a2
4002ba20:	00c12623          	sw	a2,12(sp)
4002ba24:	9b0e10ef          	jal	ra,4000cbd4 <strlen>
4002ba28:	00c12603          	lw	a2,12(sp)
4002ba2c:	00350693          	addi	a3,a0,3
4002ba30:	000105b7          	lui	a1,0x10
4002ba34:	0000a537          	lui	a0,0xa
4002ba38:	fff58593          	addi	a1,a1,-1 # ffff <__kernel_ram_size+0x44f7>
4002ba3c:	00150513          	addi	a0,a0,1 # a001 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x6001>
4002ba40:	e39d60ef          	jal	ra,40002878 <crc16_reflect>
			*query_idx = get_slot_by_id(ctx, *dns_id, *query_hash);
4002ba44:	00050613          	mv	a2,a0
4002ba48:	00050493          	mv	s1,a0
4002ba4c:	00090593          	mv	a1,s2
4002ba50:	00040513          	mv	a0,s0
4002ba54:	c1cff0ef          	jal	ra,4002ae70 <get_slot_by_id>
4002ba58:	00050a93          	mv	s5,a0
			if (*query_idx < 0) {
4002ba5c:	18054863          	bltz	a0,4002bbec <cb_recv+0x4cc>
			if (ctx->queries[*query_idx].query_type ==
4002ba60:	05800713          	li	a4,88
4002ba64:	02ea8733          	mul	a4,s5,a4
4002ba68:	00100693          	li	a3,1
4002ba6c:	00e40733          	add	a4,s0,a4
4002ba70:	08c72703          	lw	a4,140(a4)
4002ba74:	08d71463          	bne	a4,a3,4002bafc <cb_recv+0x3dc>
				if (answer_type != DNS_RR_TYPE_A) {
4002ba78:	01412683          	lw	a3,20(sp)
4002ba7c:	14e69863          	bne	a3,a4,4002bbcc <cb_recv+0x4ac>
4002ba80:	000b8593          	mv	a1,s7
4002ba84:	00100693          	li	a3,1
4002ba88:	00800713          	li	a4,8
				address_size = DNS_IPV4_LEN;
4002ba8c:	00400613          	li	a2,4
				info.ai_addrlen = sizeof(struct sockaddr_in);
4002ba90:	04e12223          	sw	a4,68(sp)
			if (dns_msg->response_length < address_size) {
4002ba94:	02215703          	lhu	a4,34(sp)
				info.ai_family = AF_INET;
4002ba98:	04b10423          	sb	a1,72(sp)
				info.ai_addr.sa_family = AF_INET;
4002ba9c:	02d11623          	sh	a3,44(sp)
			if (dns_msg->response_length < address_size) {
4002baa0:	f6c740e3          	blt	a4,a2,4002ba00 <cb_recv+0x2e0>
			if ((dns_msg->response_position + address_size) >
4002baa4:	02015703          	lhu	a4,32(sp)
			    dns_msg->msg_size) {
4002baa8:	02815683          	lhu	a3,40(sp)
			if ((dns_msg->response_position + address_size) >
4002baac:	00c705b3          	add	a1,a4,a2
4002bab0:	f4b6c8e3          	blt	a3,a1,4002ba00 <cb_recv+0x2e0>
			memcpy(addr, src, address_size);
4002bab4:	01812583          	lw	a1,24(sp)
4002bab8:	03010513          	addi	a0,sp,48
			items++;
4002babc:	001b0b13          	addi	s6,s6,1
			memcpy(addr, src, address_size);
4002bac0:	00e585b3          	add	a1,a1,a4
4002bac4:	a34e10ef          	jal	ra,4000ccf8 <memcpy>
			invoke_query_callback(DNS_EAI_INPROGRESS, &info,
4002bac8:	05800613          	li	a2,88
4002bacc:	02ca8633          	mul	a2,s5,a2
4002bad0:	02c10593          	addi	a1,sp,44
4002bad4:	f9c00513          	li	a0,-100
4002bad8:	04060613          	addi	a2,a2,64
4002badc:	00c40633          	add	a2,s0,a2
4002bae0:	b74ff0ef          	jal	ra,4002ae54 <invoke_query_callback>
		dns_msg->answer_offset += dns_msg->response_length;
4002bae4:	02015703          	lhu	a4,32(sp)
4002bae8:	02215683          	lhu	a3,34(sp)
		server_idx++;
4002baec:	001c0c13          	addi	s8,s8,1
		dns_msg->answer_offset += dns_msg->response_length;
4002baf0:	00d70733          	add	a4,a4,a3
4002baf4:	02e11323          	sh	a4,38(sp)
		server_idx++;
4002baf8:	dd1ff06f          	j	4002b8c8 <cb_recv+0x1a8>
			} else if (ctx->queries[*query_idx].query_type ==
4002bafc:	01c00693          	li	a3,28
4002bb00:	02d71a63          	bne	a4,a3,4002bb34 <cb_recv+0x414>
				if (answer_type != DNS_RR_TYPE_AAAA) {
4002bb04:	01412683          	lw	a3,20(sp)
4002bb08:	0ce69263          	bne	a3,a4,4002bbcc <cb_recv+0x4ac>
4002bb0c:	00200593          	li	a1,2
4002bb10:	00200693          	li	a3,2
4002bb14:	01800713          	li	a4,24
				address_size = DNS_IPV6_LEN;
4002bb18:	01000613          	li	a2,16
4002bb1c:	f75ff06f          	j	4002ba90 <cb_recv+0x370>
			answer_ptr = dns_msg->response_position;
4002bb20:	02015c83          	lhu	s9,32(sp)
			break;
4002bb24:	fc1ff06f          	j	4002bae4 <cb_recv+0x3c4>
	net_pkt_unref(pkt);
4002bb28:	00412503          	lw	a0,4(sp)
4002bb2c:	cf1eb0ef          	jal	ra,4001781c <net_pkt_unref>
		net_buf_unref(dns_data);
4002bb30:	e85ff06f          	j	4002b9b4 <cb_recv+0x294>
				ret = DNS_EAI_FAMILY;
4002bb34:	ffa00b13          	li	s6,-6
	net_pkt_unref(pkt);
4002bb38:	00412503          	lw	a0,4(sp)
4002bb3c:	ce1eb0ef          	jal	ra,4001781c <net_pkt_unref>
	i = get_slot_by_id(ctx, dns_id, query_hash);
4002bb40:	00048613          	mv	a2,s1
4002bb44:	00090593          	mv	a1,s2
4002bb48:	00040513          	mv	a0,s0
4002bb4c:	b24ff0ef          	jal	ra,4002ae70 <get_slot_by_id>
	if (i < 0) {
4002bb50:	02054663          	bltz	a0,4002bb7c <cb_recv+0x45c>
	invoke_query_callback(ret, NULL, &ctx->queries[i]);
4002bb54:	05800793          	li	a5,88
4002bb58:	02f50533          	mul	a0,a0,a5
4002bb5c:	00000593          	li	a1,0
4002bb60:	04050513          	addi	a0,a0,64
4002bb64:	00a40433          	add	s0,s0,a0
4002bb68:	00040613          	mv	a2,s0
4002bb6c:	000b0513          	mv	a0,s6
4002bb70:	ae4ff0ef          	jal	ra,4002ae54 <invoke_query_callback>
	release_query(&ctx->queries[i]);
4002bb74:	00040513          	mv	a0,s0
4002bb78:	b28ff0ef          	jal	ra,4002aea0 <release_query>
	if (dns_data) {
4002bb7c:	00098663          	beqz	s3,4002bb88 <cb_recv+0x468>
		net_buf_unref(dns_data);
4002bb80:	00098513          	mv	a0,s3
4002bb84:	a39e10ef          	jal	ra,4000d5bc <net_buf_unref>
	if (dns_cname) {
4002bb88:	e20a1ae3          	bnez	s4,4002b9bc <cb_recv+0x29c>
}
4002bb8c:	09812403          	lw	s0,152(sp)
	k_mutex_unlock(&ctx->lock);
4002bb90:	00812503          	lw	a0,8(sp)
}
4002bb94:	09c12083          	lw	ra,156(sp)
4002bb98:	09412483          	lw	s1,148(sp)
4002bb9c:	09012903          	lw	s2,144(sp)
4002bba0:	08c12983          	lw	s3,140(sp)
4002bba4:	08812a03          	lw	s4,136(sp)
4002bba8:	08412a83          	lw	s5,132(sp)
4002bbac:	08012b03          	lw	s6,128(sp)
4002bbb0:	07c12b83          	lw	s7,124(sp)
4002bbb4:	07812c03          	lw	s8,120(sp)
4002bbb8:	07412c83          	lw	s9,116(sp)
4002bbbc:	07012d03          	lw	s10,112(sp)
4002bbc0:	06c12d83          	lw	s11,108(sp)
4002bbc4:	0a010113          	addi	sp,sp,160
	k_mutex_unlock(&ctx->lock);
4002bbc8:	e90ff06f          	j	4002b258 <k_mutex_unlock.isra.0>
					ret = DNS_EAI_ADDRFAMILY;
4002bbcc:	ff700b13          	li	s6,-9
4002bbd0:	f69ff06f          	j	4002bb38 <cb_recv+0x418>
	uint16_t dns_id = 0U;
4002bbd4:	00000913          	li	s2,0
4002bbd8:	c99ff06f          	j	4002b870 <cb_recv+0x150>
4002bbdc:	f9900b13          	li	s6,-103
4002bbe0:	f59ff06f          	j	4002bb38 <cb_recv+0x418>
4002bbe4:	ffb00b13          	li	s6,-5
4002bbe8:	f51ff06f          	j	4002bb38 <cb_recv+0x418>
4002bbec:	ff500b13          	li	s6,-11
4002bbf0:	f49ff06f          	j	4002bb38 <cb_recv+0x418>
	net_pkt_unref(pkt);
4002bbf4:	00412503          	lw	a0,4(sp)
4002bbf8:	c25eb0ef          	jal	ra,4001781c <net_pkt_unref>
	uint16_t dns_id = 0U;
4002bbfc:	00000913          	li	s2,0
	uint16_t query_hash = 0U;
4002bc00:	00000493          	li	s1,0
		ret = DNS_EAI_MEMORY;
4002bc04:	ff600b13          	li	s6,-10
4002bc08:	f39ff06f          	j	4002bb40 <cb_recv+0x420>
	uint16_t dns_id = 0U;
4002bc0c:	00000913          	li	s2,0
	uint16_t query_hash = 0U;
4002bc10:	00000493          	li	s1,0
		ret = DNS_EAI_SYSTEM;
4002bc14:	ff500b13          	li	s6,-11
	struct net_buf *dns_data = NULL;
4002bc18:	00000993          	li	s3,0
	struct net_buf *dns_cname = NULL;
4002bc1c:	00000a13          	li	s4,0
4002bc20:	f21ff06f          	j	4002bb40 <cb_recv+0x420>
4002bc24:	00000a13          	li	s4,0
4002bc28:	fd5ff06f          	j	4002bbfc <cb_recv+0x4dc>
			if (!ctx->servers[j].net_ctx) {
4002bc2c:	01842783          	lw	a5,24(s0)
4002bc30:	d80782e3          	beqz	a5,4002b9b4 <cb_recv+0x294>
			ret = dns_write(ctx, j, i, dns_data, dns_cname, 0);
4002bc34:	000a0693          	mv	a3,s4
4002bc38:	00098613          	mv	a2,s3
4002bc3c:	00040513          	mv	a0,s0
4002bc40:	fd4ff0ef          	jal	ra,4002b414 <dns_write.constprop.0>
			if (ret < 0) {
4002bc44:	d60558e3          	bgez	a0,4002b9b4 <cb_recv+0x294>
				ret = DNS_EAI_SYSTEM;
4002bc48:	ff500b13          	li	s6,-11
4002bc4c:	ef5ff06f          	j	4002bb40 <cb_recv+0x420>

4002bc50 <dns_resolve_cancel>:
	return dns_resolve_cancel_with_hash(ctx, dns_id, query_hash,
4002bc50:	00000613          	li	a2,0
4002bc54:	e08ff06f          	j	4002b25c <dns_resolve_cancel_with_hash.constprop.0>

4002bc58 <dns_resolve_name>:
{
4002bc58:	f8010113          	addi	sp,sp,-128
4002bc5c:	06112e23          	sw	ra,124(sp)
4002bc60:	06812c23          	sw	s0,120(sp)
4002bc64:	06912a23          	sw	s1,116(sp)
4002bc68:	07212823          	sw	s2,112(sp)
4002bc6c:	07312623          	sw	s3,108(sp)
4002bc70:	07412423          	sw	s4,104(sp)
4002bc74:	07512223          	sw	s5,100(sp)
4002bc78:	07612023          	sw	s6,96(sp)
4002bc7c:	05712e23          	sw	s7,92(sp)
4002bc80:	05812c23          	sw	s8,88(sp)
4002bc84:	05912a23          	sw	s9,84(sp)
4002bc88:	05a12823          	sw	s10,80(sp)
	if (!ctx || !query || !cb) {
4002bc8c:	06050863          	beqz	a0,4002bcfc <dns_resolve_name+0xa4>
4002bc90:	00058993          	mv	s3,a1
		return -EINVAL;
4002bc94:	fea00493          	li	s1,-22
	if (!ctx || !query || !cb) {
4002bc98:	10058263          	beqz	a1,4002bd9c <dns_resolve_name+0x144>
4002bc9c:	00070a13          	mv	s4,a4
4002bca0:	0e070e63          	beqz	a4,4002bd9c <dns_resolve_name+0x144>
4002bca4:	00078b13          	mv	s6,a5
	tout = SYS_TIMEOUT_MS(timeout);
4002bca8:	fff00793          	li	a5,-1
4002bcac:	00050413          	mv	s0,a0
4002bcb0:	00060a93          	mv	s5,a2
4002bcb4:	00068913          	mv	s2,a3
4002bcb8:	04f80663          	beq	a6,a5,4002bd04 <dns_resolve_name+0xac>
4002bcbc:	00085463          	bgez	a6,4002bcc4 <dns_resolve_name+0x6c>
4002bcc0:	00000813          	li	a6,0
		t += off;
4002bcc4:	00980b93          	addi	s7,a6,9
4002bcc8:	41f85793          	srai	a5,a6,0x1f
4002bccc:	010bb833          	sltu	a6,s7,a6
4002bcd0:	00f804b3          	add	s1,a6,a5
			return t / ((uint64_t)from_hz / to_hz);
4002bcd4:	00a00613          	li	a2,10
4002bcd8:	00000693          	li	a3,0
4002bcdc:	000b8513          	mv	a0,s7
4002bce0:	00048593          	mv	a1,s1
4002bce4:	dd4d40ef          	jal	ra,400002b8 <__udivdi3>
		t += off;
4002bce8:	00900d13          	li	s10,9
			return t / ((uint64_t)from_hz / to_hz);
4002bcec:	00050c13          	mv	s8,a0
4002bcf0:	00058c93          	mv	s9,a1
	if (K_TIMEOUT_EQ(tout, K_NO_WAIT)) {
4002bcf4:	01ab9c63          	bne	s7,s10,4002bd0c <dns_resolve_name+0xb4>
4002bcf8:	00049a63          	bnez	s1,4002bd0c <dns_resolve_name+0xb4>
		return -EINVAL;
4002bcfc:	fea00493          	li	s1,-22
4002bd00:	09c0006f          	j	4002bd9c <dns_resolve_name+0x144>
	tout = SYS_TIMEOUT_MS(timeout);
4002bd04:	fff00c13          	li	s8,-1
4002bd08:	fff00c93          	li	s9,-1
	ret = net_ipaddr_parse(query, strlen(query), &addr);
4002bd0c:	00098513          	mv	a0,s3
4002bd10:	ec5e00ef          	jal	ra,4000cbd4 <strlen>
4002bd14:	00050593          	mv	a1,a0
4002bd18:	00410613          	addi	a2,sp,4
4002bd1c:	00098513          	mv	a0,s3
4002bd20:	c64e90ef          	jal	ra,40015184 <net_ipaddr_parse>
	if (ret) {
4002bd24:	0e050463          	beqz	a0,4002be0c <dns_resolve_name+0x1b4>
		struct dns_addrinfo info = { 0 };
4002bd28:	03400613          	li	a2,52
4002bd2c:	00000593          	li	a1,0
4002bd30:	01c10513          	addi	a0,sp,28
4002bd34:	fe9e00ef          	jal	ra,4000cd1c <memset>
		if (type == DNS_QUERY_TYPE_A) {
4002bd38:	00100793          	li	a5,1
4002bd3c:	08fa9e63          	bne	s5,a5,4002bdd8 <dns_resolve_name+0x180>
			if (net_sin(&addr)->sin_family == AF_INET6) {
4002bd40:	00415703          	lhu	a4,4(sp)
4002bd44:	00200793          	li	a5,2
				return -EPFNOSUPPORT;
4002bd48:	fa000493          	li	s1,-96
			if (net_sin(&addr)->sin_family == AF_INET6) {
4002bd4c:	04f70863          	beq	a4,a5,4002bd9c <dns_resolve_name+0x144>
			memcpy(net_sin(&info.ai_addr), net_sin(&addr),
4002bd50:	00800613          	li	a2,8
4002bd54:	00410593          	addi	a1,sp,4
4002bd58:	01c10513          	addi	a0,sp,28
4002bd5c:	f9de00ef          	jal	ra,4000ccf8 <memcpy>
			info.ai_addrlen = sizeof(struct sockaddr_in);
4002bd60:	00100693          	li	a3,1
4002bd64:	00100713          	li	a4,1
4002bd68:	00800793          	li	a5,8
			info.ai_family = AF_INET;
4002bd6c:	02d10c23          	sb	a3,56(sp)
			info.ai_addr.sa_family = AF_INET;
4002bd70:	00e11e23          	sh	a4,28(sp)
			info.ai_addrlen = sizeof(struct sockaddr_in);
4002bd74:	02f12a23          	sw	a5,52(sp)
		cb(DNS_EAI_INPROGRESS, &info, user_data);
4002bd78:	000b0613          	mv	a2,s6
4002bd7c:	01c10593          	addi	a1,sp,28
4002bd80:	f9c00513          	li	a0,-100
4002bd84:	000a00e7          	jalr	s4
		cb(DNS_EAI_ALLDONE, NULL, user_data);
4002bd88:	000b0613          	mv	a2,s6
4002bd8c:	00000593          	li	a1,0
4002bd90:	f9900513          	li	a0,-103
4002bd94:	000a00e7          	jalr	s4
		return 0;
4002bd98:	00000493          	li	s1,0
}
4002bd9c:	07c12083          	lw	ra,124(sp)
4002bda0:	07812403          	lw	s0,120(sp)
4002bda4:	07012903          	lw	s2,112(sp)
4002bda8:	06c12983          	lw	s3,108(sp)
4002bdac:	06812a03          	lw	s4,104(sp)
4002bdb0:	06412a83          	lw	s5,100(sp)
4002bdb4:	06012b03          	lw	s6,96(sp)
4002bdb8:	05c12b83          	lw	s7,92(sp)
4002bdbc:	05812c03          	lw	s8,88(sp)
4002bdc0:	05412c83          	lw	s9,84(sp)
4002bdc4:	05012d03          	lw	s10,80(sp)
4002bdc8:	00048513          	mv	a0,s1
4002bdcc:	07412483          	lw	s1,116(sp)
4002bdd0:	08010113          	addi	sp,sp,128
4002bdd4:	00008067          	ret
		} else if (type == DNS_QUERY_TYPE_AAAA) {
4002bdd8:	01c00713          	li	a4,28
4002bddc:	02ea9863          	bne	s5,a4,4002be0c <dns_resolve_name+0x1b4>
			if (net_sin(&addr)->sin_family == AF_INET) {
4002bde0:	00415703          	lhu	a4,4(sp)
				return -EPFNOSUPPORT;
4002bde4:	fa000493          	li	s1,-96
			if (net_sin(&addr)->sin_family == AF_INET) {
4002bde8:	faf70ae3          	beq	a4,a5,4002bd9c <dns_resolve_name+0x144>
			memcpy(net_sin6(&info.ai_addr), net_sin6(&addr),
4002bdec:	01800613          	li	a2,24
4002bdf0:	00410593          	addi	a1,sp,4
4002bdf4:	01c10513          	addi	a0,sp,28
4002bdf8:	f01e00ef          	jal	ra,4000ccf8 <memcpy>
			info.ai_addrlen = sizeof(struct sockaddr_in6);
4002bdfc:	00200693          	li	a3,2
4002be00:	00200713          	li	a4,2
4002be04:	01800793          	li	a5,24
4002be08:	f65ff06f          	j	4002bd6c <dns_resolve_name+0x114>
	k_mutex_lock(&ctx->lock, K_FOREVER);
4002be0c:	02040b93          	addi	s7,s0,32
4002be10:	fff00593          	li	a1,-1
4002be14:	fff00613          	li	a2,-1
4002be18:	000b8513          	mv	a0,s7
4002be1c:	880ff0ef          	jal	ra,4002ae9c <k_mutex_lock>
	if (ctx->state != DNS_RESOLVE_CONTEXT_ACTIVE) {
4002be20:	09842783          	lw	a5,152(s0)
		ret = -EINVAL;
4002be24:	fea00493          	li	s1,-22
	if (ctx->state != DNS_RESOLVE_CONTEXT_ACTIVE) {
4002be28:	12079863          	bnez	a5,4002bf58 <dns_resolve_name+0x300>
	if (pending_query->cb != NULL) {
4002be2c:	07442783          	lw	a5,116(s0)
4002be30:	00078c63          	beqz	a5,4002be48 <dns_resolve_name+0x1f0>
		    && pending_query->query == NULL
4002be34:	08842783          	lw	a5,136(s0)
4002be38:	14079a63          	bnez	a5,4002bf8c <dns_resolve_name+0x334>
		    && k_work_delayable_busy_get(&pending_query->timer) == 0) {
4002be3c:	04040513          	addi	a0,s0,64
4002be40:	208040ef          	jal	ra,40030048 <k_work_delayable_busy_get>
4002be44:	14051463          	bnez	a0,4002bf8c <dns_resolve_name+0x334>
	ctx->queries[i].query_type = type;
4002be48:	09542623          	sw	s5,140(s0)
	k_work_init_delayable(&ctx->queries[i].timer, query_timeout);
4002be4c:	4002b5b7          	lui	a1,0x4002b
4002be50:	04040a93          	addi	s5,s0,64
	ctx->queries[i].query = query;
4002be54:	09342423          	sw	s3,136(s0)
	k_work_init_delayable(&ctx->queries[i].timer, query_timeout);
4002be58:	30c58593          	addi	a1,a1,780 # 4002b30c <query_timeout>
4002be5c:	000a8513          	mv	a0,s5
	ctx->queries[i].cb = cb;
4002be60:	07442a23          	sw	s4,116(s0)
	ctx->queries[i].timeout = tout;
4002be64:	09842023          	sw	s8,128(s0)
4002be68:	09942223          	sw	s9,132(s0)
	ctx->queries[i].user_data = user_data;
4002be6c:	07642c23          	sw	s6,120(s0)
	ctx->queries[i].ctx = ctx;
4002be70:	06842823          	sw	s0,112(s0)
	ctx->queries[i].query_hash = 0;
4002be74:	08041923          	sh	zero,146(s0)
	k_work_init_delayable(&ctx->queries[i].timer, query_timeout);
4002be78:	18c040ef          	jal	ra,40030004 <k_work_init_delayable>
4002be7c:	03842583          	lw	a1,56(s0)
4002be80:	03c42603          	lw	a2,60(s0)
4002be84:	40045537          	lui	a0,0x40045
4002be88:	92850513          	addi	a0,a0,-1752 # 40044928 <dns_msg_pool>
4002be8c:	f18e10ef          	jal	ra,4000d5a4 <net_buf_alloc_fixed>
4002be90:	00050993          	mv	s3,a0
	if (!dns_data) {
4002be94:	0c050e63          	beqz	a0,4002bf70 <dns_resolve_name+0x318>
4002be98:	03842583          	lw	a1,56(s0)
4002be9c:	03c42603          	lw	a2,60(s0)
4002bea0:	40045537          	lui	a0,0x40045
4002bea4:	95450513          	addi	a0,a0,-1708 # 40044954 <dns_qname_pool>
4002bea8:	efce10ef          	jal	ra,4000d5a4 <net_buf_alloc_fixed>
4002beac:	00050a13          	mv	s4,a0
	if (!dns_qname) {
4002beb0:	08050663          	beqz	a0,4002bf3c <dns_resolve_name+0x2e4>
	ret = dns_msg_pack_qname(&dns_qname->len, dns_qname->data,
4002beb4:	00c52583          	lw	a1,12(a0)
4002beb8:	08842683          	lw	a3,136(s0)
4002bebc:	0ff00613          	li	a2,255
4002bec0:	01050513          	addi	a0,a0,16
4002bec4:	985fe0ef          	jal	ra,4002a848 <dns_msg_pack_qname>
4002bec8:	00050493          	mv	s1,a0
	if (ret < 0) {
4002becc:	08054c63          	bltz	a0,4002bf64 <dns_resolve_name+0x30c>
4002bed0:	b50e10ef          	jal	ra,4000d220 <z_impl_sys_rand32_get>
	ctx->queries[i].id = sys_rand32_get();
4002bed4:	01051513          	slli	a0,a0,0x10
4002bed8:	01055513          	srli	a0,a0,0x10
4002bedc:	08a41823          	sh	a0,144(s0)
	if (dns_id) {
4002bee0:	00090463          	beqz	s2,4002bee8 <dns_resolve_name+0x290>
		*dns_id = ctx->queries[i].id;
4002bee4:	00a91023          	sh	a0,0(s2)
		if (!ctx->servers[j].net_ctx) {
4002bee8:	01842783          	lw	a5,24(s0)
4002beec:	02078c63          	beqz	a5,4002bf24 <dns_resolve_name+0x2cc>
		ret = dns_write(ctx, j, i, dns_data, dns_qname, hop_limit);
4002bef0:	000a0693          	mv	a3,s4
4002bef4:	00098613          	mv	a2,s3
4002bef8:	00000593          	li	a1,0
4002befc:	00040513          	mv	a0,s0
4002bf00:	d14ff0ef          	jal	ra,4002b414 <dns_write.constprop.0>
		if (ret < 0) {
4002bf04:	02055063          	bgez	a0,4002bf24 <dns_resolve_name+0x2cc>
			release_query(&ctx->queries[i]);
4002bf08:	000a8513          	mv	a0,s5
4002bf0c:	f95fe0ef          	jal	ra,4002aea0 <release_query>
			ret = -ENOENT;
4002bf10:	ffe00493          	li	s1,-2
		if (dns_id) {
4002bf14:	06091863          	bnez	s2,4002bf84 <dns_resolve_name+0x32c>
		net_buf_unref(dns_data);
4002bf18:	00098513          	mv	a0,s3
4002bf1c:	ea0e10ef          	jal	ra,4000d5bc <net_buf_unref>
	if (dns_qname) {
4002bf20:	0100006f          	j	4002bf30 <dns_resolve_name+0x2d8>
		net_buf_unref(dns_data);
4002bf24:	00098513          	mv	a0,s3
4002bf28:	e94e10ef          	jal	ra,4000d5bc <net_buf_unref>
	ret = 0;
4002bf2c:	00000493          	li	s1,0
		net_buf_unref(dns_qname);
4002bf30:	000a0513          	mv	a0,s4
4002bf34:	e88e10ef          	jal	ra,4000d5bc <net_buf_unref>
4002bf38:	0200006f          	j	4002bf58 <dns_resolve_name+0x300>
			release_query(&ctx->queries[i]);
4002bf3c:	000a8513          	mv	a0,s5
4002bf40:	f61fe0ef          	jal	ra,4002aea0 <release_query>
		if (dns_id) {
4002bf44:	00090463          	beqz	s2,4002bf4c <dns_resolve_name+0x2f4>
			*dns_id = 0U;
4002bf48:	00091023          	sh	zero,0(s2)
		net_buf_unref(dns_data);
4002bf4c:	00098513          	mv	a0,s3
4002bf50:	e6ce10ef          	jal	ra,4000d5bc <net_buf_unref>
		ret = -ENOMEM;
4002bf54:	ff400493          	li	s1,-12
	k_mutex_unlock(&ctx->lock);
4002bf58:	000b8513          	mv	a0,s7
4002bf5c:	afcff0ef          	jal	ra,4002b258 <k_mutex_unlock.isra.0>
	return ret;
4002bf60:	e3dff06f          	j	4002bd9c <dns_resolve_name+0x144>
			release_query(&ctx->queries[i]);
4002bf64:	000a8513          	mv	a0,s5
4002bf68:	f39fe0ef          	jal	ra,4002aea0 <release_query>
4002bf6c:	fa9ff06f          	j	4002bf14 <dns_resolve_name+0x2bc>
4002bf70:	000a8513          	mv	a0,s5
4002bf74:	f2dfe0ef          	jal	ra,4002aea0 <release_query>
		if (dns_id) {
4002bf78:	fc090ee3          	beqz	s2,4002bf54 <dns_resolve_name+0x2fc>
			*dns_id = 0U;
4002bf7c:	00091023          	sh	zero,0(s2)
	if (dns_qname) {
4002bf80:	fd5ff06f          	j	4002bf54 <dns_resolve_name+0x2fc>
			*dns_id = 0U;
4002bf84:	00091023          	sh	zero,0(s2)
4002bf88:	f91ff06f          	j	4002bf18 <dns_resolve_name+0x2c0>
		ret = -EAGAIN;
4002bf8c:	ff500493          	li	s1,-11
4002bf90:	fc9ff06f          	j	4002bf58 <dns_resolve_name+0x300>

4002bf94 <dns_resolve_reconfigure>:
}

int dns_resolve_reconfigure(struct dns_resolve_context *ctx,
			    const char *servers[],
			    const struct sockaddr *servers_sa[])
{
4002bf94:	fc010113          	addi	sp,sp,-64
4002bf98:	02912a23          	sw	s1,52(sp)
4002bf9c:	02112e23          	sw	ra,60(sp)
4002bfa0:	02812c23          	sw	s0,56(sp)
4002bfa4:	03212823          	sw	s2,48(sp)
4002bfa8:	03312623          	sw	s3,44(sp)
4002bfac:	03412423          	sw	s4,40(sp)
	int err;

	if (!ctx) {
		return -ENOENT;
4002bfb0:	ffe00493          	li	s1,-2
	if (!ctx) {
4002bfb4:	04050663          	beqz	a0,4002c000 <dns_resolve_reconfigure+0x6c>
	}

	k_mutex_lock(&ctx->lock, K_FOREVER);
4002bfb8:	02050a13          	addi	s4,a0,32
4002bfbc:	00058913          	mv	s2,a1
4002bfc0:	00050413          	mv	s0,a0
4002bfc4:	00060993          	mv	s3,a2
4002bfc8:	fff00593          	li	a1,-1
4002bfcc:	fff00613          	li	a2,-1
4002bfd0:	000a0513          	mv	a0,s4
4002bfd4:	ec9fe0ef          	jal	ra,4002ae9c <k_mutex_lock>
	if (servers) {
4002bfd8:	04091663          	bnez	s2,4002c024 <dns_resolve_reconfigure+0x90>
	if (servers_sa) {
4002bfdc:	00098c63          	beqz	s3,4002bff4 <dns_resolve_reconfigure+0x60>
		for (int i = 0; i < SERVER_COUNT && servers_sa[i]; i++) {
4002bfe0:	0009a583          	lw	a1,0(s3)
4002bfe4:	00058863          	beqz	a1,4002bff4 <dns_resolve_reconfigure+0x60>
			if (!dns_server_exists(ctx, servers_sa[i])) {
4002bfe8:	00040513          	mv	a0,s0
4002bfec:	ee9fe0ef          	jal	ra,4002aed4 <dns_server_exists>
4002bff0:	06050463          	beqz	a0,4002c058 <dns_resolve_reconfigure+0xc4>

	if (dns_servers_exists(ctx, servers, servers_sa)) {
		/* DNS servers did not change. */
		err = 0;
4002bff4:	00000493          	li	s1,0
	}

	err = dns_resolve_init_locked(ctx, servers, servers_sa);

unlock:
	k_mutex_unlock(&ctx->lock);
4002bff8:	000a0513          	mv	a0,s4
4002bffc:	a5cff0ef          	jal	ra,4002b258 <k_mutex_unlock.isra.0>

	return err;
}
4002c000:	03c12083          	lw	ra,60(sp)
4002c004:	03812403          	lw	s0,56(sp)
4002c008:	03012903          	lw	s2,48(sp)
4002c00c:	02c12983          	lw	s3,44(sp)
4002c010:	02812a03          	lw	s4,40(sp)
4002c014:	00048513          	mv	a0,s1
4002c018:	03412483          	lw	s1,52(sp)
4002c01c:	04010113          	addi	sp,sp,64
4002c020:	00008067          	ret
		for (int i = 0; i < SERVER_COUNT && servers[i]; i++) {
4002c024:	00092483          	lw	s1,0(s2)
4002c028:	fa048ae3          	beqz	s1,4002bfdc <dns_resolve_reconfigure+0x48>
			if (!net_ipaddr_parse(servers[i], strlen(servers[i]), &addr)) {
4002c02c:	00048513          	mv	a0,s1
4002c030:	ba5e00ef          	jal	ra,4000cbd4 <strlen>
4002c034:	00050593          	mv	a1,a0
4002c038:	00810613          	addi	a2,sp,8
4002c03c:	00048513          	mv	a0,s1
4002c040:	944e90ef          	jal	ra,40015184 <net_ipaddr_parse>
4002c044:	f8050ce3          	beqz	a0,4002bfdc <dns_resolve_reconfigure+0x48>
			if (!dns_server_exists(ctx, &addr)) {
4002c048:	00810593          	addi	a1,sp,8
4002c04c:	00040513          	mv	a0,s0
4002c050:	e85fe0ef          	jal	ra,4002aed4 <dns_server_exists>
4002c054:	f80514e3          	bnez	a0,4002bfdc <dns_resolve_reconfigure+0x48>
	if (ctx->state == DNS_RESOLVE_CONTEXT_DEACTIVATING) {
4002c058:	09842783          	lw	a5,152(s0)
4002c05c:	00100713          	li	a4,1
		err = -EBUSY;
4002c060:	ff000493          	li	s1,-16
	if (ctx->state == DNS_RESOLVE_CONTEXT_DEACTIVATING) {
4002c064:	f8e78ae3          	beq	a5,a4,4002bff8 <dns_resolve_reconfigure+0x64>
	if (ctx->state == DNS_RESOLVE_CONTEXT_ACTIVE) {
4002c068:	00078e63          	beqz	a5,4002c084 <dns_resolve_reconfigure+0xf0>
	err = dns_resolve_init_locked(ctx, servers, servers_sa);
4002c06c:	00098613          	mv	a2,s3
4002c070:	00090593          	mv	a1,s2
4002c074:	00040513          	mv	a0,s0
4002c078:	858ff0ef          	jal	ra,4002b0d0 <dns_resolve_init_locked>
4002c07c:	00050493          	mv	s1,a0
4002c080:	f79ff06f          	j	4002bff8 <dns_resolve_reconfigure+0x64>
		if (ctx->queries[i].cb && ctx->queries[i].query) {
4002c084:	07442783          	lw	a5,116(s0)
4002c088:	02078463          	beqz	a5,4002c0b0 <dns_resolve_reconfigure+0x11c>
4002c08c:	08842783          	lw	a5,136(s0)
4002c090:	02078063          	beqz	a5,4002c0b0 <dns_resolve_reconfigure+0x11c>
	invoke_query_callback(DNS_EAI_CANCELED, NULL, &ctx->queries[slot]);
4002c094:	04040493          	addi	s1,s0,64
4002c098:	f9b00513          	li	a0,-101
4002c09c:	00048613          	mv	a2,s1
4002c0a0:	00000593          	li	a1,0
4002c0a4:	db1fe0ef          	jal	ra,4002ae54 <invoke_query_callback>
	release_query(&ctx->queries[slot]);
4002c0a8:	00048513          	mv	a0,s1
4002c0ac:	df5fe0ef          	jal	ra,4002aea0 <release_query>
		err = dns_resolve_close_locked(ctx);
4002c0b0:	00040513          	mv	a0,s0
4002c0b4:	ac4ff0ef          	jal	ra,4002b378 <dns_resolve_close_locked>
4002c0b8:	00050493          	mv	s1,a0
		if (err) {
4002c0bc:	fa0508e3          	beqz	a0,4002c06c <dns_resolve_reconfigure+0xd8>
4002c0c0:	f39ff06f          	j	4002bff8 <dns_resolve_reconfigure+0x64>

4002c0c4 <dns_resolve_get_default>:

struct dns_resolve_context *dns_resolve_get_default(void)
{
	return &dns_default_ctx;
4002c0c4:	4003a537          	lui	a0,0x4003a
}
4002c0c8:	db850513          	addi	a0,a0,-584 # 40039db8 <dns_default_ctx>
4002c0cc:	00008067          	ret

4002c0d0 <dns_init_resolver>:
	}
#else
	/* We must always call init even if there are no servers configured so
	 * that DNS mutex gets initialized properly.
	 */
	(void)dns_resolve_init(dns_resolve_get_default(), NULL, NULL);
4002c0d0:	4003a537          	lui	a0,0x4003a
4002c0d4:	00000613          	li	a2,0
4002c0d8:	00000593          	li	a1,0
4002c0dc:	db850513          	addi	a0,a0,-584 # 40039db8 <dns_default_ctx>
4002c0e0:	ca4ff06f          	j	4002b584 <dns_resolve_init>

4002c0e4 <vexriscv_litex_irq_handler>:
				:: "r"(MSTATUS_IEN));
	}
}

static void vexriscv_litex_irq_handler(const void *device)
{
4002c0e4:	ff010113          	addi	sp,sp,-16
4002c0e8:	00112623          	sw	ra,12(sp)
4002c0ec:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrr %0, %1" : "=r"(pending) : "i"(IRQ_PENDING));
4002c0f0:	fc0027f3          	csrr	a5,0xfc0
	__asm__ volatile ("csrr %0, %1" : "=r"(mask) : "i"(IRQ_MASK));
4002c0f4:	bc002473          	csrr	s0,0xbc0
	struct _isr_table_entry *ite;
	uint32_t pending, mask, irqs;

	pending = vexriscv_litex_irq_pending();
	mask = vexriscv_litex_irq_getmask();
	irqs = pending & mask;
4002c0f8:	00f47433          	and	s0,s0,a5

#ifdef CONFIG_LITEX_TIMER
	if (irqs & (1 << TIMER0_IRQ)) {
4002c0fc:	00247793          	andi	a5,s0,2
4002c100:	00078c63          	beqz	a5,4002c118 <vexriscv_litex_irq_handler+0x34>
		ite = &_sw_isr_table[TIMER0_IRQ];
		ite->isr(ite->arg);
4002c104:	400327b7          	lui	a5,0x40032
4002c108:	37478793          	addi	a5,a5,884 # 40032374 <_sw_isr_table>
4002c10c:	00c7a703          	lw	a4,12(a5)
4002c110:	0087a503          	lw	a0,8(a5)
4002c114:	000700e7          	jalr	a4
		ite->isr(ite->arg);
	}
#endif

#ifdef CONFIG_ETH_LITEETH
	if (irqs & (1 << ETH0_IRQ)) {
4002c118:	00447793          	andi	a5,s0,4
4002c11c:	00078c63          	beqz	a5,4002c134 <vexriscv_litex_irq_handler+0x50>
		ite = &_sw_isr_table[ETH0_IRQ];
		ite->isr(ite->arg);
4002c120:	400327b7          	lui	a5,0x40032
4002c124:	37478793          	addi	a5,a5,884 # 40032374 <_sw_isr_table>
4002c128:	0147a703          	lw	a4,20(a5)
4002c12c:	0107a503          	lw	a0,16(a5)
4002c130:	000700e7          	jalr	a4
		ite = &_sw_isr_table[I2S_TX_IRQ];
		ite->isr(ite->arg);
	}
#endif

	if (irqs & (1 << GPIO_IRQ)) {
4002c134:	01047413          	andi	s0,s0,16
4002c138:	02040263          	beqz	s0,4002c15c <vexriscv_litex_irq_handler+0x78>
		ite = &_sw_isr_table[GPIO_IRQ];
		ite->isr(ite->arg);
4002c13c:	400327b7          	lui	a5,0x40032
	}
}
4002c140:	00812403          	lw	s0,8(sp)
		ite->isr(ite->arg);
4002c144:	37478793          	addi	a5,a5,884 # 40032374 <_sw_isr_table>
}
4002c148:	00c12083          	lw	ra,12(sp)
		ite->isr(ite->arg);
4002c14c:	0247a703          	lw	a4,36(a5)
4002c150:	0207a503          	lw	a0,32(a5)
}
4002c154:	01010113          	addi	sp,sp,16
		ite->isr(ite->arg);
4002c158:	00070067          	jr	a4
}
4002c15c:	00c12083          	lw	ra,12(sp)
4002c160:	00812403          	lw	s0,8(sp)
4002c164:	01010113          	addi	sp,sp,16
4002c168:	00008067          	ret

4002c16c <vexriscv_litex_irq_init>:
	return vexriscv_litex_irq_getmask() & (1 << irq);
}

static int vexriscv_litex_irq_init(void)
{
	__asm__ volatile ("csrrs x0, mie, %0"
4002c16c:	000017b7          	lui	a5,0x1
4002c170:	80078793          	addi	a5,a5,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
4002c174:	3047a073          	csrs	mie,a5
		__asm__ volatile ("csrrs x0, mstatus, %0"
4002c178:	00800793          	li	a5,8
4002c17c:	3007a073          	csrs	mstatus,a5
	vexriscv_litex_irq_setie(1);
	IRQ_CONNECT(RISCV_MACHINE_EXT_IRQ, 0, vexriscv_litex_irq_handler,
			NULL, 0);

	return 0;
}
4002c180:	00000513          	li	a0,0
4002c184:	00008067          	ret

4002c188 <arch_irq_enable>:
	__asm__ volatile ("csrr %0, %1" : "=r"(mask) : "i"(IRQ_MASK));
4002c188:	bc002773          	csrr	a4,0xbc0
	vexriscv_litex_irq_setmask(vexriscv_litex_irq_getmask() | (1 << irq));
4002c18c:	00100793          	li	a5,1
4002c190:	00a79533          	sll	a0,a5,a0
4002c194:	00e56533          	or	a0,a0,a4
	__asm__ volatile ("csrw %0, %1" :: "i"(IRQ_MASK), "r"(mask));
4002c198:	bc051073          	csrw	0xbc0,a0
}
4002c19c:	00008067          	ret

4002c1a0 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(void)
{
4002c1a0:	ff010113          	addi	sp,sp,-16
4002c1a4:	00112623          	sw	ra,12(sp)
4002c1a8:	00812423          	sw	s0,8(sp)
4002c1ac:	40032537          	lui	a0,0x40032
4002c1b0:	31450513          	addi	a0,a0,788 # 40032314 <__device_dts_ord_20>
4002c1b4:	164020ef          	jal	ra,4002e318 <z_device_is_ready>
4002c1b8:	fed00793          	li	a5,-19
	if (!device_is_ready(uart_console_dev)) {
4002c1bc:	00050e63          	beqz	a0,4002c1d8 <uart_console_init+0x38>
	__stdout_hook_install(console_out);
4002c1c0:	4002c437          	lui	s0,0x4002c
4002c1c4:	1ec40513          	addi	a0,s0,492 # 4002c1ec <console_out>
4002c1c8:	ba9e00ef          	jal	ra,4000cd70 <__stdout_hook_install>
	__printk_hook_install(console_out);
4002c1cc:	1ec40513          	addi	a0,s0,492
4002c1d0:	ab1d50ef          	jal	ra,40001c80 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
4002c1d4:	00000793          	li	a5,0
}
4002c1d8:	00c12083          	lw	ra,12(sp)
4002c1dc:	00812403          	lw	s0,8(sp)
4002c1e0:	00078513          	mv	a0,a5
4002c1e4:	01010113          	addi	sp,sp,16
4002c1e8:	00008067          	ret

4002c1ec <console_out>:
{
4002c1ec:	ff010113          	addi	sp,sp,-16
4002c1f0:	00812423          	sw	s0,8(sp)
4002c1f4:	00912223          	sw	s1,4(sp)
4002c1f8:	01212023          	sw	s2,0(sp)
4002c1fc:	400324b7          	lui	s1,0x40032
4002c200:	00112623          	sw	ra,12(sp)
	if ('\n' == c) {
4002c204:	00a00793          	li	a5,10
{
4002c208:	00050413          	mv	s0,a0
4002c20c:	31448913          	addi	s2,s1,788 # 40032314 <__device_dts_ord_20>
	if ('\n' == c) {
4002c210:	00f51c63          	bne	a0,a5,4002c228 <console_out+0x3c>
	api->poll_out(dev, out_char);
4002c214:	00892783          	lw	a5,8(s2)
4002c218:	00d00593          	li	a1,13
4002c21c:	31448513          	addi	a0,s1,788
4002c220:	0047a783          	lw	a5,4(a5)
4002c224:	000780e7          	jalr	a5
4002c228:	00892783          	lw	a5,8(s2)
4002c22c:	31448513          	addi	a0,s1,788
4002c230:	0ff47593          	zext.b	a1,s0
4002c234:	0047a783          	lw	a5,4(a5)
4002c238:	000780e7          	jalr	a5
}
4002c23c:	00c12083          	lw	ra,12(sp)
4002c240:	00040513          	mv	a0,s0
4002c244:	00812403          	lw	s0,8(sp)
4002c248:	00412483          	lw	s1,4(sp)
4002c24c:	00012903          	lw	s2,0(sp)
4002c250:	01010113          	addi	sp,sp,16
4002c254:	00008067          	ret

4002c258 <entropy_prbs_get_entropy>:
#define PRBS_STATUS     DT_INST_REG_ADDR(0)
#define PRBS_WIDTH      DT_INST_REG_SIZE(0)

static int entropy_prbs_get_entropy(const struct device *dev, uint8_t *buffer,
					 uint16_t length)
{
4002c258:	fd010113          	addi	sp,sp,-48
4002c25c:	02812423          	sw	s0,40(sp)
4002c260:	03212023          	sw	s2,32(sp)
4002c264:	01312e23          	sw	s3,28(sp)
4002c268:	01412c23          	sw	s4,24(sp)
4002c26c:	02112623          	sw	ra,44(sp)
4002c270:	02912223          	sw	s1,36(sp)
4002c274:	00058913          	mv	s2,a1
4002c278:	00060413          	mv	s0,a2
4002c27c:	e00079b7          	lui	s3,0xe0007
	while (length > 0) {
		size_t to_copy;
		uint32_t value;

		value = litex_read(PRBS_STATUS, PRBS_WIDTH);
		to_copy = MIN(length, sizeof(value));
4002c280:	00400a13          	li	s4,4
	while (length > 0) {
4002c284:	02041463          	bnez	s0,4002c2ac <entropy_prbs_get_entropy+0x54>
		memcpy(buffer, &value, to_copy);
		buffer += to_copy;
		length -= to_copy;
	}
	return 0;
}
4002c288:	02c12083          	lw	ra,44(sp)
4002c28c:	02812403          	lw	s0,40(sp)
4002c290:	02412483          	lw	s1,36(sp)
4002c294:	02012903          	lw	s2,32(sp)
4002c298:	01c12983          	lw	s3,28(sp)
4002c29c:	01812a03          	lw	s4,24(sp)
4002c2a0:	00000513          	li	a0,0
4002c2a4:	03010113          	addi	sp,sp,48
4002c2a8:	00008067          	ret
4002c2ac:	8009a783          	lw	a5,-2048(s3) # e0006800 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0006801>
		to_copy = MIN(length, sizeof(value));
4002c2b0:	00040493          	mv	s1,s0
		value = litex_read(PRBS_STATUS, PRBS_WIDTH);
4002c2b4:	00f12623          	sw	a5,12(sp)
		to_copy = MIN(length, sizeof(value));
4002c2b8:	008a7463          	bgeu	s4,s0,4002c2c0 <entropy_prbs_get_entropy+0x68>
4002c2bc:	00400493          	li	s1,4
4002c2c0:	01049493          	slli	s1,s1,0x10
4002c2c4:	0104d493          	srli	s1,s1,0x10
		length -= to_copy;
4002c2c8:	40940433          	sub	s0,s0,s1
		memcpy(buffer, &value, to_copy);
4002c2cc:	00090513          	mv	a0,s2
4002c2d0:	00048613          	mv	a2,s1
4002c2d4:	00c10593          	addi	a1,sp,12
		length -= to_copy;
4002c2d8:	01041413          	slli	s0,s0,0x10
		memcpy(buffer, &value, to_copy);
4002c2dc:	a1de00ef          	jal	ra,4000ccf8 <memcpy>
		buffer += to_copy;
4002c2e0:	00990933          	add	s2,s2,s1
		length -= to_copy;
4002c2e4:	01045413          	srli	s0,s0,0x10
4002c2e8:	f9dff06f          	j	4002c284 <entropy_prbs_get_entropy+0x2c>

4002c2ec <litex_write>:
 * Size is in bytes and meaningful are 1, 2 or 4
 * Address must be aligned to 4 bytes
 */
static inline void litex_write(uint32_t addr, uint32_t size, uint32_t value)
{
	switch (size) {
4002c2ec:	00200793          	li	a5,2
4002c2f0:	02f58063          	beq	a1,a5,4002c310 <litex_write+0x24>
4002c2f4:	00400793          	li	a5,4
4002c2f8:	02f58463          	beq	a1,a5,4002c320 <litex_write+0x34>
4002c2fc:	00100793          	li	a5,1
4002c300:	02f59263          	bne	a1,a5,4002c324 <litex_write+0x38>
	case 1:
		litex_write8(value, addr);
4002c304:	0ff67613          	zext.b	a2,a2
	*(volatile uint8_t *)addr = data;
4002c308:	00c50023          	sb	a2,0(a0)
}
4002c30c:	00008067          	ret
		break;
	case 2:
		litex_write16(value, addr);
4002c310:	01061613          	slli	a2,a2,0x10
4002c314:	01065613          	srli	a2,a2,0x10
	*(volatile uint16_t *)addr = data;
4002c318:	00c51023          	sh	a2,0(a0)
}
4002c31c:	00008067          	ret
	*(volatile uint32_t *)addr = data;
4002c320:	00c52023          	sw	a2,0(a0)
		litex_write32(value, addr);
		break;
	default:
		break;
	}
}
4002c324:	00008067          	ret

4002c328 <litex_read>:
 * Size is in bytes and meaningful are 1, 2 or 4
 * Address must be aligned to 4 bytes
 */
static inline uint32_t litex_read(uint32_t addr, uint32_t size)
{
	switch (size) {
4002c328:	00200713          	li	a4,2
{
4002c32c:	00050793          	mv	a5,a0
	switch (size) {
4002c330:	02e58263          	beq	a1,a4,4002c354 <litex_read+0x2c>
4002c334:	00400713          	li	a4,4
4002c338:	02e58663          	beq	a1,a4,4002c364 <litex_read+0x3c>
4002c33c:	00100713          	li	a4,1
4002c340:	00000513          	li	a0,0
4002c344:	02e59263          	bne	a1,a4,4002c368 <litex_read+0x40>
	return *(volatile uint8_t *)addr;
4002c348:	0007c503          	lbu	a0,0(a5)
4002c34c:	0ff57513          	zext.b	a0,a0
	case 1:
		return litex_read8(addr);
4002c350:	00008067          	ret
	return *(volatile uint16_t *)addr;
4002c354:	00055503          	lhu	a0,0(a0)
4002c358:	01051513          	slli	a0,a0,0x10
4002c35c:	01055513          	srli	a0,a0,0x10
	case 2:
		return litex_read16(addr);
4002c360:	00008067          	ret
	return *(volatile uint32_t *)addr;
4002c364:	00052503          	lw	a0,0(a0)
	case 4:
		return litex_read32(addr);
	default:
		return 0;
	}
}
4002c368:	00008067          	ret

4002c36c <set_bit>:

/* Helper functions for bit / port access */

static inline void set_bit(const struct gpio_litex_cfg *config,
			   uint32_t bit, bool val)
{
4002c36c:	fe010113          	addi	sp,sp,-32
4002c370:	00812c23          	sw	s0,24(sp)
4002c374:	00912a23          	sw	s1,20(sp)
4002c378:	00112e23          	sw	ra,28(sp)
4002c37c:	01212823          	sw	s2,16(sp)
	int regv, new_regv;

	regv = litex_read(config->reg_addr, config->reg_size);
4002c380:	00052903          	lw	s2,0(a0)
{
4002c384:	00058493          	mv	s1,a1
	regv = litex_read(config->reg_addr, config->reg_size);
4002c388:	00452583          	lw	a1,4(a0)
4002c38c:	00090513          	mv	a0,s2
{
4002c390:	00060413          	mv	s0,a2
	regv = litex_read(config->reg_addr, config->reg_size);
4002c394:	00b12623          	sw	a1,12(sp)
4002c398:	f91ff0ef          	jal	ra,4002c328 <litex_read>
	new_regv = (regv & ~BIT(bit)) | (val << bit);
4002c39c:	00100793          	li	a5,1
4002c3a0:	009797b3          	sll	a5,a5,s1
4002c3a4:	00941633          	sll	a2,s0,s1
4002c3a8:	fff7c793          	not	a5,a5
	litex_write(config->reg_addr, config->reg_size, new_regv);
}
4002c3ac:	01812403          	lw	s0,24(sp)
	litex_write(config->reg_addr, config->reg_size, new_regv);
4002c3b0:	00c12583          	lw	a1,12(sp)
}
4002c3b4:	01c12083          	lw	ra,28(sp)
4002c3b8:	01412483          	lw	s1,20(sp)
	new_regv = (regv & ~BIT(bit)) | (val << bit);
4002c3bc:	00a7f7b3          	and	a5,a5,a0
	litex_write(config->reg_addr, config->reg_size, new_regv);
4002c3c0:	00090513          	mv	a0,s2
}
4002c3c4:	01012903          	lw	s2,16(sp)
	litex_write(config->reg_addr, config->reg_size, new_regv);
4002c3c8:	00c7e633          	or	a2,a5,a2
}
4002c3cc:	02010113          	addi	sp,sp,32
	litex_write(config->reg_addr, config->reg_size, new_regv);
4002c3d0:	f1dff06f          	j	4002c2ec <litex_write>

4002c3d4 <get_port>:
{
	litex_write(config->reg_addr, config->reg_size, value);
}

static inline uint32_t get_port(const struct gpio_litex_cfg *config)
{
4002c3d4:	ff010113          	addi	sp,sp,-16
4002c3d8:	00812423          	sw	s0,8(sp)
4002c3dc:	00112623          	sw	ra,12(sp)
4002c3e0:	00050413          	mv	s0,a0
	int regv = litex_read(config->reg_addr, config->reg_size);
4002c3e4:	00452583          	lw	a1,4(a0)
4002c3e8:	00052503          	lw	a0,0(a0)
4002c3ec:	f3dff0ef          	jal	ra,4002c328 <litex_read>

	return (regv & BIT_MASK(config->nr_gpios));
4002c3f0:	01842703          	lw	a4,24(s0)
}
4002c3f4:	00c12083          	lw	ra,12(sp)
4002c3f8:	00812403          	lw	s0,8(sp)
	return (regv & BIT_MASK(config->nr_gpios));
4002c3fc:	fff00793          	li	a5,-1
4002c400:	00e797b3          	sll	a5,a5,a4
4002c404:	fff7c793          	not	a5,a5
}
4002c408:	00a7f533          	and	a0,a5,a0
4002c40c:	01010113          	addi	sp,sp,16
4002c410:	00008067          	ret

4002c414 <gpio_litex_port_get_raw>:
	return 0;
}

static int gpio_litex_port_get_raw(const struct device *dev,
				   gpio_port_value_t *value)
{
4002c414:	ff010113          	addi	sp,sp,-16
4002c418:	00812423          	sw	s0,8(sp)
4002c41c:	00112623          	sw	ra,12(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);

	*value = get_port(gpio_config);
4002c420:	00452503          	lw	a0,4(a0)
{
4002c424:	00058413          	mv	s0,a1
	*value = get_port(gpio_config);
4002c428:	fadff0ef          	jal	ra,4002c3d4 <get_port>
4002c42c:	00a42023          	sw	a0,0(s0)
	return 0;
}
4002c430:	00c12083          	lw	ra,12(sp)
4002c434:	00812403          	lw	s0,8(sp)
4002c438:	00000513          	li	a0,0
4002c43c:	01010113          	addi	sp,sp,16
4002c440:	00008067          	ret

4002c444 <gpio_litex_port_set_masked_raw>:

static int gpio_litex_port_set_masked_raw(const struct device *dev,
					  gpio_port_pins_t mask,
					  gpio_port_value_t value)
{
4002c444:	ff010113          	addi	sp,sp,-16
4002c448:	00112623          	sw	ra,12(sp)
4002c44c:	00812423          	sw	s0,8(sp)
4002c450:	01212023          	sw	s2,0(sp)
4002c454:	00912223          	sw	s1,4(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
4002c458:	00452483          	lw	s1,4(a0)
{
4002c45c:	00058913          	mv	s2,a1
4002c460:	00060413          	mv	s0,a2
	uint32_t port_val;

	port_val = get_port(gpio_config);
4002c464:	00048513          	mv	a0,s1
4002c468:	f6dff0ef          	jal	ra,4002c3d4 <get_port>
	port_val = (port_val & ~mask) | (value & mask);
4002c46c:	00854433          	xor	s0,a0,s0
4002c470:	01247633          	and	a2,s0,s2
	litex_write(config->reg_addr, config->reg_size, value);
4002c474:	0044a583          	lw	a1,4(s1)
4002c478:	00c54633          	xor	a2,a0,a2
4002c47c:	0004a503          	lw	a0,0(s1)
4002c480:	e6dff0ef          	jal	ra,4002c2ec <litex_write>
	set_port(gpio_config, port_val);

	return 0;
}
4002c484:	00c12083          	lw	ra,12(sp)
4002c488:	00812403          	lw	s0,8(sp)
4002c48c:	00412483          	lw	s1,4(sp)
4002c490:	00012903          	lw	s2,0(sp)
4002c494:	00000513          	li	a0,0
4002c498:	01010113          	addi	sp,sp,16
4002c49c:	00008067          	ret

4002c4a0 <gpio_litex_manage_callback>:
}

static int gpio_litex_manage_callback(const struct device *dev,
				      struct gpio_callback *callback, bool set)
{
	struct gpio_litex_data *data = dev->data;
4002c4a0:	01052783          	lw	a5,16(a0)
	return list->head;
4002c4a4:	0087a703          	lw	a4,8(a5)
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
4002c4a8:	06070663          	beqz	a4,4002c514 <gpio_litex_manage_callback+0x74>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4002c4ac:	04b71e63          	bne	a4,a1,4002c508 <gpio_litex_manage_callback+0x68>
	return node->next;
4002c4b0:	0005a703          	lw	a4,0(a1)
Z_GENLIST_REMOVE(slist, snode)
4002c4b4:	00c7a683          	lw	a3,12(a5)
	list->head = node;
4002c4b8:	00e7a423          	sw	a4,8(a5)
Z_GENLIST_REMOVE(slist, snode)
4002c4bc:	00d59463          	bne	a1,a3,4002c4c4 <gpio_litex_manage_callback+0x24>
	list->tail = node;
4002c4c0:	00e7a623          	sw	a4,12(a5)
	parent->next = child;
4002c4c4:	0005a023          	sw	zero,0(a1)
		}
	} else if (!set) {
		return -EINVAL;
	}

	if (set) {
4002c4c8:	00060e63          	beqz	a2,4002c4e4 <gpio_litex_manage_callback+0x44>
	return list->head;
4002c4cc:	0087a703          	lw	a4,8(a5)
	parent->next = child;
4002c4d0:	00e5a023          	sw	a4,0(a1)
Z_GENLIST_PREPEND(slist, snode)
4002c4d4:	00c7a703          	lw	a4,12(a5)
	list->head = node;
4002c4d8:	00b7a423          	sw	a1,8(a5)
Z_GENLIST_PREPEND(slist, snode)
4002c4dc:	00071463          	bnez	a4,4002c4e4 <gpio_litex_manage_callback+0x44>
	list->tail = node;
4002c4e0:	00b7a623          	sw	a1,12(a5)
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
4002c4e4:	00000513          	li	a0,0

	return gpio_manage_callback(&data->cb, callback, set);
}
4002c4e8:	00008067          	ret
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4002c4ec:	00e59e63          	bne	a1,a4,4002c508 <gpio_litex_manage_callback+0x68>
	return node->next;
4002c4f0:	0005a703          	lw	a4,0(a1)
	parent->next = child;
4002c4f4:	00e6a023          	sw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
4002c4f8:	00c7a703          	lw	a4,12(a5)
4002c4fc:	fce594e3          	bne	a1,a4,4002c4c4 <gpio_litex_manage_callback+0x24>
	list->tail = node;
4002c500:	00d7a623          	sw	a3,12(a5)
}
4002c504:	fc1ff06f          	j	4002c4c4 <gpio_litex_manage_callback+0x24>
	return node->next;
4002c508:	00070693          	mv	a3,a4
4002c50c:	00072703          	lw	a4,0(a4)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4002c510:	fc071ee3          	bnez	a4,4002c4ec <gpio_litex_manage_callback+0x4c>
			if (!set) {
4002c514:	fa061ce3          	bnez	a2,4002c4cc <gpio_litex_manage_callback+0x2c>
				return -EINVAL;
4002c518:	fea00513          	li	a0,-22
4002c51c:	00008067          	ret

4002c520 <gpio_litex_pin_interrupt_configure>:

static int gpio_litex_pin_interrupt_configure(const struct device *dev,
					      gpio_pin_t pin,
					      enum gpio_int_mode mode,
					      enum gpio_int_trig trig)
{
4002c520:	fc010113          	addi	sp,sp,-64
4002c524:	02112e23          	sw	ra,60(sp)
4002c528:	02812c23          	sw	s0,56(sp)
4002c52c:	02912a23          	sw	s1,52(sp)
4002c530:	03212823          	sw	s2,48(sp)
4002c534:	03312623          	sw	s3,44(sp)
4002c538:	03412423          	sw	s4,40(sp)
4002c53c:	03512223          	sw	s5,36(sp)
4002c540:	03612023          	sw	s6,32(sp)
4002c544:	01712e23          	sw	s7,28(sp)
4002c548:	01812c23          	sw	s8,24(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
4002c54c:	00452403          	lw	s0,4(a0)

	if (gpio_config->port_is_output == true) {
		return -ENOTSUP;
4002c550:	f7a00513          	li	a0,-134
	if (gpio_config->port_is_output == true) {
4002c554:	01c44783          	lbu	a5,28(s0)
4002c558:	0c079c63          	bnez	a5,4002c630 <gpio_litex_pin_interrupt_configure+0x110>
	}

	if (mode == GPIO_INT_MODE_EDGE) {
4002c55c:	014007b7          	lui	a5,0x1400
4002c560:	00058b13          	mv	s6,a1
4002c564:	10f61863          	bne	a2,a5,4002c674 <gpio_litex_pin_interrupt_configure+0x154>
		uint8_t ev_enabled = litex_read(gpio_config->ev_enable_addr,
4002c568:	00442c03          	lw	s8,4(s0)
4002c56c:	00c42b83          	lw	s7,12(s0)
4002c570:	00068a13          	mv	s4,a3
4002c574:	000c0593          	mv	a1,s8
4002c578:	000b8513          	mv	a0,s7
4002c57c:	dadff0ef          	jal	ra,4002c328 <litex_read>
4002c580:	00050a93          	mv	s5,a0
				gpio_config->reg_size);
		uint8_t ev_mode = litex_read(gpio_config->ev_mode_addr,
4002c584:	01042503          	lw	a0,16(s0)
4002c588:	000c0593          	mv	a1,s8
				gpio_config->reg_size);
		uint8_t ev_edge = litex_read(gpio_config->ev_edge_addr,
				gpio_config->reg_size);

		litex_write(gpio_config->ev_enable_addr, gpio_config->reg_size,
			    ev_enabled | BIT(pin));
4002c58c:	00100493          	li	s1,1
		uint8_t ev_mode = litex_read(gpio_config->ev_mode_addr,
4002c590:	d99ff0ef          	jal	ra,4002c328 <litex_read>
4002c594:	00050913          	mv	s2,a0
		uint8_t ev_edge = litex_read(gpio_config->ev_edge_addr,
4002c598:	01442503          	lw	a0,20(s0)
4002c59c:	000c0593          	mv	a1,s8
			    ev_enabled | BIT(pin));
4002c5a0:	016494b3          	sll	s1,s1,s6
		uint8_t ev_edge = litex_read(gpio_config->ev_edge_addr,
4002c5a4:	d85ff0ef          	jal	ra,4002c328 <litex_read>
			    ev_enabled | BIT(pin));
4002c5a8:	0ffaf613          	zext.b	a2,s5
		uint8_t ev_edge = litex_read(gpio_config->ev_edge_addr,
4002c5ac:	00050993          	mv	s3,a0
		litex_write(gpio_config->ev_enable_addr, gpio_config->reg_size,
4002c5b0:	00966633          	or	a2,a2,s1
4002c5b4:	000c0593          	mv	a1,s8
4002c5b8:	000b8513          	mv	a0,s7
4002c5bc:	d31ff0ef          	jal	ra,4002c2ec <litex_write>

		if (trig == GPIO_INT_TRIG_HIGH) {
4002c5c0:	040007b7          	lui	a5,0x4000
4002c5c4:	02fa1a63          	bne	s4,a5,4002c5f8 <gpio_litex_pin_interrupt_configure+0xd8>
			/* Change mode to 'edge' and edge to 'rising' */
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
			    ev_mode & ~BIT(pin));
4002c5c8:	fff4c493          	not	s1,s1
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
4002c5cc:	00442583          	lw	a1,4(s0)
4002c5d0:	01042503          	lw	a0,16(s0)
			    ev_mode & ~BIT(pin));
4002c5d4:	00997633          	and	a2,s2,s1
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
4002c5d8:	0ff67613          	zext.b	a2,a2
4002c5dc:	d11ff0ef          	jal	ra,4002c2ec <litex_write>
			litex_write(gpio_config->ev_edge_addr, gpio_config->reg_size,
			    ev_edge & ~BIT(pin));
4002c5e0:	0099f4b3          	and	s1,s3,s1
			litex_write(gpio_config->ev_edge_addr, gpio_config->reg_size,
4002c5e4:	0ff4f613          	zext.b	a2,s1
		} else if (trig == GPIO_INT_TRIG_LOW) {
			/* Change mode to 'edge' and edge to 'falling' */
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
			    ev_mode & ~BIT(pin));
			litex_write(gpio_config->ev_edge_addr, gpio_config->reg_size,
4002c5e8:	00442583          	lw	a1,4(s0)
4002c5ec:	01442503          	lw	a0,20(s0)
	}

	if (mode == GPIO_INT_DISABLE) {
		uint8_t ev_enabled = litex_read(gpio_config->ev_enable_addr,
				gpio_config->reg_size);
		litex_write(gpio_config->ev_enable_addr, gpio_config->reg_size,
4002c5f0:	cfdff0ef          	jal	ra,4002c2ec <litex_write>
			    ev_enabled & ~BIT(pin));
		return 0;
4002c5f4:	0380006f          	j	4002c62c <gpio_litex_pin_interrupt_configure+0x10c>
		} else if (trig == GPIO_INT_TRIG_LOW) {
4002c5f8:	020007b7          	lui	a5,0x2000
4002c5fc:	02fa1463          	bne	s4,a5,4002c624 <gpio_litex_pin_interrupt_configure+0x104>
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
4002c600:	00442583          	lw	a1,4(s0)
4002c604:	01042503          	lw	a0,16(s0)
			    ev_mode & ~BIT(pin));
4002c608:	fff4c613          	not	a2,s1
4002c60c:	01267633          	and	a2,a2,s2
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
4002c610:	0ff67613          	zext.b	a2,a2
4002c614:	cd9ff0ef          	jal	ra,4002c2ec <litex_write>
			    ev_edge | BIT(pin));
4002c618:	0ff9f613          	zext.b	a2,s3
			litex_write(gpio_config->ev_edge_addr, gpio_config->reg_size,
4002c61c:	00966633          	or	a2,a2,s1
4002c620:	fc9ff06f          	j	4002c5e8 <gpio_litex_pin_interrupt_configure+0xc8>
		} else if (trig == GPIO_INT_TRIG_BOTH) {
4002c624:	060007b7          	lui	a5,0x6000
4002c628:	02fa0c63          	beq	s4,a5,4002c660 <gpio_litex_pin_interrupt_configure+0x140>
		return 0;
4002c62c:	00000513          	li	a0,0
	}

	return -ENOTSUP;
}
4002c630:	03c12083          	lw	ra,60(sp)
4002c634:	03812403          	lw	s0,56(sp)
4002c638:	03412483          	lw	s1,52(sp)
4002c63c:	03012903          	lw	s2,48(sp)
4002c640:	02c12983          	lw	s3,44(sp)
4002c644:	02812a03          	lw	s4,40(sp)
4002c648:	02412a83          	lw	s5,36(sp)
4002c64c:	02012b03          	lw	s6,32(sp)
4002c650:	01c12b83          	lw	s7,28(sp)
4002c654:	01812c03          	lw	s8,24(sp)
4002c658:	04010113          	addi	sp,sp,64
4002c65c:	00008067          	ret
			    ev_mode | BIT(pin));
4002c660:	0ff97613          	zext.b	a2,s2
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
4002c664:	00442583          	lw	a1,4(s0)
4002c668:	01042503          	lw	a0,16(s0)
4002c66c:	00966633          	or	a2,a2,s1
4002c670:	f81ff06f          	j	4002c5f0 <gpio_litex_pin_interrupt_configure+0xd0>
	if (mode == GPIO_INT_DISABLE) {
4002c674:	002007b7          	lui	a5,0x200
		return -ENOTSUP;
4002c678:	f7a00513          	li	a0,-134
	if (mode == GPIO_INT_DISABLE) {
4002c67c:	faf61ae3          	bne	a2,a5,4002c630 <gpio_litex_pin_interrupt_configure+0x110>
		uint8_t ev_enabled = litex_read(gpio_config->ev_enable_addr,
4002c680:	00c42483          	lw	s1,12(s0)
4002c684:	00442583          	lw	a1,4(s0)
4002c688:	00048513          	mv	a0,s1
4002c68c:	00b12623          	sw	a1,12(sp)
4002c690:	c99ff0ef          	jal	ra,4002c328 <litex_read>
			    ev_enabled & ~BIT(pin));
4002c694:	00100613          	li	a2,1
4002c698:	01661633          	sll	a2,a2,s6
4002c69c:	fff64613          	not	a2,a2
4002c6a0:	00a67633          	and	a2,a2,a0
		litex_write(gpio_config->ev_enable_addr, gpio_config->reg_size,
4002c6a4:	00c12583          	lw	a1,12(sp)
4002c6a8:	0ff67613          	zext.b	a2,a2
4002c6ac:	00048513          	mv	a0,s1
4002c6b0:	f41ff06f          	j	4002c5f0 <gpio_litex_pin_interrupt_configure+0xd0>

4002c6b4 <gpio_litex_port_init_0.part.0>:
		IF_ENABLED(DT_INST_IRQ_HAS_IDX(n, 0), \
			   (GPIO_LITEX_IRQ_INIT(n);)) \
		return 0; \
	}

DT_INST_FOREACH_STATUS_OKAY(GPIO_LITEX_INIT)
4002c6b4:	40044537          	lui	a0,0x40044
4002c6b8:	73852783          	lw	a5,1848(a0) # 40044738 <log_dynamic_gpio_litex>
4002c6bc:	0077f793          	andi	a5,a5,7
4002c6c0:	08078463          	beqz	a5,4002c748 <gpio_litex_port_init_0.part.0+0x94>
4002c6c4:	ff010113          	addi	sp,sp,-16
4002c6c8:	00812423          	sw	s0,8(sp)
4002c6cc:	00912223          	sw	s1,4(sp)
4002c6d0:	00112623          	sw	ra,12(sp)
4002c6d4:	01010413          	addi	s0,sp,16
4002c6d8:	00010493          	mv	s1,sp
4002c6dc:	fe010113          	addi	sp,sp,-32
4002c6e0:	00010613          	mv	a2,sp
4002c6e4:	400337b7          	lui	a5,0x40033
4002c6e8:	af878793          	addi	a5,a5,-1288 # 40032af8 <mpsc_config+0x9c>
4002c6ec:	00f62a23          	sw	a5,20(a2)
4002c6f0:	400397b7          	lui	a5,0x40039
4002c6f4:	be078793          	addi	a5,a5,-1056 # 40038be0 <eth_hw_caps+0x218>
4002c6f8:	00f62c23          	sw	a5,24(a2)
4002c6fc:	20000793          	li	a5,512
4002c700:	00f61e23          	sh	a5,28(a2)
4002c704:	010007b7          	lui	a5,0x1000
4002c708:	00378793          	addi	a5,a5,3 # 1000003 <__rom_region_size+0xfc7047>
4002c70c:	00f62823          	sw	a5,16(a2)
4002c710:	000025b7          	lui	a1,0x2
4002c714:	00000693          	li	a3,0
4002c718:	73850513          	addi	a0,a0,1848
4002c71c:	01060613          	addi	a2,a2,16
4002c720:	c4058593          	addi	a1,a1,-960 # 1c40 <CONFIG_HEAP_MEM_POOL_SIZE+0xc40>
4002c724:	871d80ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
4002c728:	00048113          	mv	sp,s1
4002c72c:	ff040113          	addi	sp,s0,-16
4002c730:	00c12083          	lw	ra,12(sp)
4002c734:	00812403          	lw	s0,8(sp)
4002c738:	00412483          	lw	s1,4(sp)
4002c73c:	fea00513          	li	a0,-22
4002c740:	01010113          	addi	sp,sp,16
4002c744:	00008067          	ret
4002c748:	fea00513          	li	a0,-22
4002c74c:	00008067          	ret

4002c750 <gpio_litex_port_init_1>:
4002c750:	00452783          	lw	a5,4(a0)
4002c754:	0187a703          	lw	a4,24(a5)
4002c758:	02000793          	li	a5,32
4002c75c:	00e7d463          	bge	a5,a4,4002c764 <gpio_litex_port_init_1+0x14>
4002c760:	f55ff06f          	j	4002c6b4 <gpio_litex_port_init_0.part.0>
4002c764:	ff010113          	addi	sp,sp,-16
4002c768:	00400513          	li	a0,4
4002c76c:	00112623          	sw	ra,12(sp)
4002c770:	a19ff0ef          	jal	ra,4002c188 <arch_irq_enable>
4002c774:	00c12083          	lw	ra,12(sp)
4002c778:	00000513          	li	a0,0
4002c77c:	01010113          	addi	sp,sp,16
4002c780:	00008067          	ret

4002c784 <gpio_litex_port_init_0>:
4002c784:	00452783          	lw	a5,4(a0)
4002c788:	0187a703          	lw	a4,24(a5)
4002c78c:	02000793          	li	a5,32
4002c790:	00e7d463          	bge	a5,a4,4002c798 <gpio_litex_port_init_0+0x14>
4002c794:	f21ff06f          	j	4002c6b4 <gpio_litex_port_init_0.part.0>
4002c798:	00000513          	li	a0,0
4002c79c:	00008067          	ret

4002c7a0 <gpio_litex_irq_handler>:
{
4002c7a0:	fd010113          	addi	sp,sp,-48
4002c7a4:	02112623          	sw	ra,44(sp)
4002c7a8:	02812423          	sw	s0,40(sp)
4002c7ac:	02912223          	sw	s1,36(sp)
4002c7b0:	03212023          	sw	s2,32(sp)
4002c7b4:	01312e23          	sw	s3,28(sp)
4002c7b8:	01412c23          	sw	s4,24(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
4002c7bc:	00452903          	lw	s2,4(a0)
	struct gpio_litex_data *data = dev->data;
4002c7c0:	01052a03          	lw	s4,16(a0)
{
4002c7c4:	00050493          	mv	s1,a0
		litex_read(gpio_config->ev_pending_addr, gpio_config->reg_size);
4002c7c8:	00892983          	lw	s3,8(s2)
4002c7cc:	00492583          	lw	a1,4(s2)
4002c7d0:	00098513          	mv	a0,s3
4002c7d4:	00b12623          	sw	a1,12(sp)
4002c7d8:	b51ff0ef          	jal	ra,4002c328 <litex_read>
		litex_read(gpio_config->ev_enable_addr, gpio_config->reg_size);
4002c7dc:	00c12583          	lw	a1,12(sp)
		litex_read(gpio_config->ev_pending_addr, gpio_config->reg_size);
4002c7e0:	00050413          	mv	s0,a0
		litex_read(gpio_config->ev_enable_addr, gpio_config->reg_size);
4002c7e4:	00c92503          	lw	a0,12(s2)
4002c7e8:	b41ff0ef          	jal	ra,4002c328 <litex_read>
	litex_write(gpio_config->ev_pending_addr, gpio_config->reg_size,
4002c7ec:	00c12583          	lw	a1,12(sp)
		litex_read(gpio_config->ev_enable_addr, gpio_config->reg_size);
4002c7f0:	00050913          	mv	s2,a0
	litex_write(gpio_config->ev_pending_addr, gpio_config->reg_size,
4002c7f4:	0ff47613          	zext.b	a2,s0
4002c7f8:	00098513          	mv	a0,s3
4002c7fc:	af1ff0ef          	jal	ra,4002c2ec <litex_write>
	gpio_fire_callbacks(&data->cb, dev, int_status & ev_enabled);
4002c800:	008a2583          	lw	a1,8(s4)
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
4002c804:	00058a63          	beqz	a1,4002c818 <gpio_litex_irq_handler+0x78>
4002c808:	01247433          	and	s0,s0,s2
	return node->next;
4002c80c:	0005a903          	lw	s2,0(a1)
4002c810:	0ff47413          	zext.b	s0,s0
4002c814:	02059263          	bnez	a1,4002c838 <gpio_litex_irq_handler+0x98>
}
4002c818:	02c12083          	lw	ra,44(sp)
4002c81c:	02812403          	lw	s0,40(sp)
4002c820:	02412483          	lw	s1,36(sp)
4002c824:	02012903          	lw	s2,32(sp)
4002c828:	01c12983          	lw	s3,28(sp)
4002c82c:	01812a03          	lw	s4,24(sp)
4002c830:	03010113          	addi	sp,sp,48
4002c834:	00008067          	ret
		if (cb->pin_mask & pins) {
4002c838:	0085a603          	lw	a2,8(a1)
4002c83c:	00c47633          	and	a2,s0,a2
4002c840:	00060863          	beqz	a2,4002c850 <gpio_litex_irq_handler+0xb0>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
4002c844:	0045a783          	lw	a5,4(a1)
4002c848:	00048513          	mv	a0,s1
4002c84c:	000780e7          	jalr	a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
4002c850:	00000793          	li	a5,0
4002c854:	00090463          	beqz	s2,4002c85c <gpio_litex_irq_handler+0xbc>
4002c858:	00092783          	lw	a5,0(s2)
4002c85c:	00090593          	mv	a1,s2
4002c860:	00078913          	mv	s2,a5
4002c864:	fb1ff06f          	j	4002c814 <gpio_litex_irq_handler+0x74>

4002c868 <gpio_litex_configure>:
	if (flags & ~SUPPORTED_FLAGS) {
4002c868:	fff107b7          	lui	a5,0xfff10
4002c86c:	ffe78793          	addi	a5,a5,-2 # fff0fffe <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfff0ffff>
4002c870:	00f677b3          	and	a5,a2,a5
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
4002c874:	00452503          	lw	a0,4(a0)
	if (flags & ~SUPPORTED_FLAGS) {
4002c878:	0e079e63          	bnez	a5,4002c974 <gpio_litex_configure+0x10c>
	if ((flags & GPIO_OUTPUT) && (flags & GPIO_INPUT)) {
4002c87c:	000306b7          	lui	a3,0x30
4002c880:	00d67733          	and	a4,a2,a3
		return -ENOTSUP;
4002c884:	f7a00793          	li	a5,-134
	if ((flags & GPIO_OUTPUT) && (flags & GPIO_INPUT)) {
4002c888:	0ed70863          	beq	a4,a3,4002c978 <gpio_litex_configure+0x110>
	} else if (!(flags & (GPIO_INPUT | GPIO_OUTPUT))) {
4002c88c:	0e070663          	beqz	a4,4002c978 <gpio_litex_configure+0x110>
{
4002c890:	ff010113          	addi	sp,sp,-16
4002c894:	00812423          	sw	s0,8(sp)
4002c898:	00112623          	sw	ra,12(sp)
4002c89c:	00912223          	sw	s1,4(sp)
4002c8a0:	01010413          	addi	s0,sp,16
	if (flags & GPIO_OUTPUT) {
4002c8a4:	000207b7          	lui	a5,0x20
4002c8a8:	00f677b3          	and	a5,a2,a5
		if (!gpio_config->port_is_output) {
4002c8ac:	01c54703          	lbu	a4,28(a0)
	if (flags & GPIO_OUTPUT) {
4002c8b0:	0a078e63          	beqz	a5,4002c96c <gpio_litex_configure+0x104>
		if (!gpio_config->port_is_output) {
4002c8b4:	08071463          	bnez	a4,4002c93c <gpio_litex_configure+0xd4>
			LOG_ERR("%s", LITEX_LOG_CANNOT_CHANGE_DIR);
4002c8b8:	40044537          	lui	a0,0x40044
4002c8bc:	73852783          	lw	a5,1848(a0) # 40044738 <log_dynamic_gpio_litex>
4002c8c0:	0077f793          	andi	a5,a5,7
4002c8c4:	04078c63          	beqz	a5,4002c91c <gpio_litex_configure+0xb4>
			LOG_ERR("%s", LITEX_LOG_CANNOT_CHANGE_DIR);
4002c8c8:	00010493          	mv	s1,sp
4002c8cc:	fe010113          	addi	sp,sp,-32
4002c8d0:	00010613          	mv	a2,sp
4002c8d4:	400337b7          	lui	a5,0x40033
4002c8d8:	af878793          	addi	a5,a5,-1288 # 40032af8 <mpsc_config+0x9c>
4002c8dc:	00f62a23          	sw	a5,20(a2)
4002c8e0:	400397b7          	lui	a5,0x40039
4002c8e4:	c2078793          	addi	a5,a5,-992 # 40038c20 <eth_hw_caps+0x258>
4002c8e8:	00f62c23          	sw	a5,24(a2)
4002c8ec:	20000793          	li	a5,512
4002c8f0:	00f61e23          	sh	a5,28(a2)
4002c8f4:	010007b7          	lui	a5,0x1000
4002c8f8:	00378793          	addi	a5,a5,3 # 1000003 <__rom_region_size+0xfc7047>
4002c8fc:	00f62823          	sw	a5,16(a2)
4002c900:	000025b7          	lui	a1,0x2
4002c904:	00000693          	li	a3,0
4002c908:	01060613          	addi	a2,a2,16
4002c90c:	c4058593          	addi	a1,a1,-960 # 1c40 <CONFIG_HEAP_MEM_POOL_SIZE+0xc40>
4002c910:	73850513          	addi	a0,a0,1848
4002c914:	e80d80ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
4002c918:	00048113          	mv	sp,s1
			return -EINVAL;
4002c91c:	fea00793          	li	a5,-22
}
4002c920:	ff040113          	addi	sp,s0,-16
4002c924:	00c12083          	lw	ra,12(sp)
4002c928:	00812403          	lw	s0,8(sp)
4002c92c:	00412483          	lw	s1,4(sp)
4002c930:	00078513          	mv	a0,a5
4002c934:	01010113          	addi	sp,sp,16
4002c938:	00008067          	ret
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
4002c93c:	000807b7          	lui	a5,0x80
4002c940:	00f677b3          	and	a5,a2,a5
4002c944:	00078a63          	beqz	a5,4002c958 <gpio_litex_configure+0xf0>
			set_bit(gpio_config, pin, GPIO_HIGH);
4002c948:	00100613          	li	a2,1
			set_bit(gpio_config, pin, GPIO_LOW);
4002c94c:	a21ff0ef          	jal	ra,4002c36c <set_bit>
	return 0;
4002c950:	00000793          	li	a5,0
4002c954:	fcdff06f          	j	4002c920 <gpio_litex_configure+0xb8>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
4002c958:	000407b7          	lui	a5,0x40
4002c95c:	00f67633          	and	a2,a2,a5
4002c960:	fe0608e3          	beqz	a2,4002c950 <gpio_litex_configure+0xe8>
			set_bit(gpio_config, pin, GPIO_LOW);
4002c964:	00000613          	li	a2,0
4002c968:	fe5ff06f          	j	4002c94c <gpio_litex_configure+0xe4>
		if (gpio_config->port_is_output) {
4002c96c:	fe0702e3          	beqz	a4,4002c950 <gpio_litex_configure+0xe8>
4002c970:	f49ff06f          	j	4002c8b8 <gpio_litex_configure+0x50>
		return -ENOTSUP;
4002c974:	f7a00793          	li	a5,-134
}
4002c978:	00078513          	mv	a0,a5
4002c97c:	00008067          	ret

4002c980 <gpio_litex_port_toggle_bits>:
{
4002c980:	ff010113          	addi	sp,sp,-16
4002c984:	00112623          	sw	ra,12(sp)
4002c988:	00912223          	sw	s1,4(sp)
4002c98c:	00812423          	sw	s0,8(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
4002c990:	00452403          	lw	s0,4(a0)
{
4002c994:	00058493          	mv	s1,a1
	port_val = get_port(gpio_config);
4002c998:	00040513          	mv	a0,s0
4002c99c:	a39ff0ef          	jal	ra,4002c3d4 <get_port>
	litex_write(config->reg_addr, config->reg_size, value);
4002c9a0:	00954633          	xor	a2,a0,s1
4002c9a4:	00442583          	lw	a1,4(s0)
4002c9a8:	00042503          	lw	a0,0(s0)
4002c9ac:	941ff0ef          	jal	ra,4002c2ec <litex_write>
}
4002c9b0:	00c12083          	lw	ra,12(sp)
4002c9b4:	00812403          	lw	s0,8(sp)
4002c9b8:	00412483          	lw	s1,4(sp)
4002c9bc:	00000513          	li	a0,0
4002c9c0:	01010113          	addi	sp,sp,16
4002c9c4:	00008067          	ret

4002c9c8 <gpio_litex_port_clear_bits_raw>:
{
4002c9c8:	ff010113          	addi	sp,sp,-16
4002c9cc:	00112623          	sw	ra,12(sp)
4002c9d0:	00812423          	sw	s0,8(sp)
4002c9d4:	00912223          	sw	s1,4(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
4002c9d8:	00452483          	lw	s1,4(a0)
{
4002c9dc:	00058413          	mv	s0,a1
	port_val &= ~pins;
4002c9e0:	fff44413          	not	s0,s0
	port_val = get_port(gpio_config);
4002c9e4:	00048513          	mv	a0,s1
4002c9e8:	9edff0ef          	jal	ra,4002c3d4 <get_port>
	litex_write(config->reg_addr, config->reg_size, value);
4002c9ec:	00a47633          	and	a2,s0,a0
4002c9f0:	0044a583          	lw	a1,4(s1)
4002c9f4:	0004a503          	lw	a0,0(s1)
4002c9f8:	8f5ff0ef          	jal	ra,4002c2ec <litex_write>
}
4002c9fc:	00c12083          	lw	ra,12(sp)
4002ca00:	00812403          	lw	s0,8(sp)
4002ca04:	00412483          	lw	s1,4(sp)
4002ca08:	00000513          	li	a0,0
4002ca0c:	01010113          	addi	sp,sp,16
4002ca10:	00008067          	ret

4002ca14 <gpio_litex_port_set_bits_raw>:
{
4002ca14:	ff010113          	addi	sp,sp,-16
4002ca18:	00112623          	sw	ra,12(sp)
4002ca1c:	00912223          	sw	s1,4(sp)
4002ca20:	00812423          	sw	s0,8(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
4002ca24:	00452403          	lw	s0,4(a0)
{
4002ca28:	00058493          	mv	s1,a1
	port_val = get_port(gpio_config);
4002ca2c:	00040513          	mv	a0,s0
4002ca30:	9a5ff0ef          	jal	ra,4002c3d4 <get_port>
	litex_write(config->reg_addr, config->reg_size, value);
4002ca34:	00956633          	or	a2,a0,s1
4002ca38:	00442583          	lw	a1,4(s0)
4002ca3c:	00042503          	lw	a0,0(s0)
4002ca40:	8adff0ef          	jal	ra,4002c2ec <litex_write>
}
4002ca44:	00c12083          	lw	ra,12(sp)
4002ca48:	00812403          	lw	s0,8(sp)
4002ca4c:	00412483          	lw	s1,4(sp)
4002ca50:	00000513          	li	a0,0
4002ca54:	01010113          	addi	sp,sp,16
4002ca58:	00008067          	ret

4002ca5c <eth_initialize>:
struct eth_liteeth_config {
	void (*config_func)(void);
};

static int eth_initialize(const struct device *dev)
{
4002ca5c:	ff010113          	addi	sp,sp,-16
4002ca60:	00112623          	sw	ra,12(sp)
	const struct eth_liteeth_config *config = dev->config;

	config->config_func();
4002ca64:	00452783          	lw	a5,4(a0)
4002ca68:	0007a783          	lw	a5,0(a5) # 40000 <__rom_region_size+0x7044>
4002ca6c:	000780e7          	jalr	a5

	return 0;
}
4002ca70:	00c12083          	lw	ra,12(sp)
4002ca74:	00000513          	li	a0,0
4002ca78:	01010113          	addi	sp,sp,16
4002ca7c:	00008067          	ret

4002ca80 <eth_caps>:
static enum ethernet_hw_caps eth_caps(const struct device *dev)
{
	ARG_UNUSED(dev);
	return ETHERNET_LINK_10BASE_T | ETHERNET_LINK_100BASE_T |
	       ETHERNET_LINK_1000BASE_T;
}
4002ca80:	07000513          	li	a0,112
4002ca84:	00008067          	ret

4002ca88 <eth_irq_config>:
NET_DEVICE_DT_INST_DEFINE(0, eth_initialize, NULL,
		&eth_data, &eth_config, CONFIG_ETH_INIT_PRIORITY, &eth_api,
		ETHERNET_L2, NET_L2_GET_CTX_TYPE(ETHERNET_L2), NET_ETH_MTU);

static void eth_irq_config(void)
{
4002ca88:	ff010113          	addi	sp,sp,-16
	IRQ_CONNECT(LITEETH_IRQ, LITEETH_IRQ_PRIORITY, eth_irq_handler,
		    DEVICE_DT_INST_GET(0), 0);
	irq_enable(LITEETH_IRQ);
4002ca8c:	00200513          	li	a0,2
{
4002ca90:	00112623          	sw	ra,12(sp)
	irq_enable(LITEETH_IRQ);
4002ca94:	ef4ff0ef          	jal	ra,4002c188 <arch_irq_enable>
	*(volatile uint8_t *)addr = data;
4002ca98:	f00027b7          	lui	a5,0xf0002
4002ca9c:	00100713          	li	a4,1
4002caa0:	80e78a23          	sb	a4,-2028(a5) # f0001814 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0001815>
	litex_write8(1, LITEETH_RX_EV_ENABLE_ADDR);
}
4002caa4:	00c12083          	lw	ra,12(sp)
4002caa8:	01010113          	addi	sp,sp,16
4002caac:	00008067          	ret

4002cab0 <eth_iface_init>:
{
4002cab0:	fd010113          	addi	sp,sp,-48
4002cab4:	03212023          	sw	s2,32(sp)
4002cab8:	02112623          	sw	ra,44(sp)
4002cabc:	02812423          	sw	s0,40(sp)
4002cac0:	02912223          	sw	s1,36(sp)
	return iface->if_dev->dev;
4002cac4:	00052783          	lw	a5,0(a0)
	if (init_done) {
4002cac8:	40039937          	lui	s2,0x40039
	struct eth_liteeth_dev_data *context = port->data;
4002cacc:	0007a783          	lw	a5,0(a5)
4002cad0:	0107a403          	lw	s0,16(a5)
	if (init_done) {
4002cad4:	10c94783          	lbu	a5,268(s2) # 4003910c <init_done.0>
4002cad8:	06079263          	bnez	a5,4002cb3c <eth_iface_init+0x8c>
	context->iface = iface;
4002cadc:	00a42023          	sw	a0,0(s0)
4002cae0:	00050493          	mv	s1,a0
	ethernet_init(iface);
4002cae4:	fe8e10ef          	jal	ra,4000e2cc <ethernet_init>
	return net_if_set_link_addr_locked(iface, addr, len, type);
4002cae8:	00300693          	li	a3,3
4002caec:	00600613          	li	a2,6
4002caf0:	00440593          	addi	a1,s0,4
4002caf4:	00048513          	mv	a0,s1
4002caf8:	998e40ef          	jal	ra,40010c90 <net_if_set_link_addr_locked>
	if (net_if_set_link_addr(iface, context->mac_addr, sizeof(context->mac_addr),
4002cafc:	04055c63          	bgez	a0,4002cb54 <eth_iface_init+0xa4>
		LOG_ERR("setting mac failed");
4002cb00:	40044537          	lui	a0,0x40044
4002cb04:	73052783          	lw	a5,1840(a0) # 40044730 <log_dynamic_eth_liteeth>
4002cb08:	0077f793          	andi	a5,a5,7
4002cb0c:	02078863          	beqz	a5,4002cb3c <eth_iface_init+0x8c>
4002cb10:	400397b7          	lui	a5,0x40039
4002cb14:	ce878793          	addi	a5,a5,-792 # 40038ce8 <gpio_litex_driver_api+0x24>
4002cb18:	00f12e23          	sw	a5,28(sp)
4002cb1c:	00200793          	li	a5,2
4002cb20:	00f12c23          	sw	a5,24(sp)
4002cb24:	000015b7          	lui	a1,0x1
4002cb28:	00000693          	li	a3,0
4002cb2c:	01810613          	addi	a2,sp,24
4002cb30:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4002cb34:	73050513          	addi	a0,a0,1840
4002cb38:	c5cd80ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
}
4002cb3c:	02c12083          	lw	ra,44(sp)
4002cb40:	02812403          	lw	s0,40(sp)
4002cb44:	02412483          	lw	s1,36(sp)
4002cb48:	02012903          	lw	s2,32(sp)
4002cb4c:	03010113          	addi	sp,sp,48
4002cb50:	00008067          	ret
4002cb54:	f00027b7          	lui	a5,0xf0002
4002cb58:	00100713          	li	a4,1
4002cb5c:	82e78823          	sb	a4,-2000(a5) # f0001830 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0001831>
	context->tx_buf[1] = (uint8_t *)LITEETH_SLOT_TX1_ADDR;
4002cb60:	800026b7          	lui	a3,0x80002
4002cb64:	80e78823          	sb	a4,-2032(a5)
4002cb68:	80068693          	addi	a3,a3,-2048 # 80001800 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001801>
	context->tx_buf[0] = (uint8_t *)LITEETH_SLOT_TX0_ADDR;
4002cb6c:	800017b7          	lui	a5,0x80001
4002cb70:	00f42623          	sw	a5,12(s0)
	context->tx_buf[1] = (uint8_t *)LITEETH_SLOT_TX1_ADDR;
4002cb74:	00d42823          	sw	a3,16(s0)
	context->rx_buf[1] = (uint8_t *)LITEETH_SLOT_RX1_ADDR;
4002cb78:	80078793          	addi	a5,a5,-2048 # 80000800 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000801>
	context->rx_buf[0] = (uint8_t *)LITEETH_SLOT_RX0_ADDR;
4002cb7c:	800006b7          	lui	a3,0x80000
	context->txslot = 0;
4002cb80:	00041523          	sh	zero,10(s0)
	context->rx_buf[0] = (uint8_t *)LITEETH_SLOT_RX0_ADDR;
4002cb84:	00d42a23          	sw	a3,20(s0)
	context->rx_buf[1] = (uint8_t *)LITEETH_SLOT_RX1_ADDR;
4002cb88:	00f42c23          	sw	a5,24(s0)
	init_done = true;
4002cb8c:	10e90623          	sb	a4,268(s2)
4002cb90:	fadff06f          	j	4002cb3c <eth_iface_init+0x8c>

4002cb94 <eth_irq_handler>:
	return *(volatile uint8_t *)addr;
4002cb94:	f0002737          	lui	a4,0xf0002
4002cb98:	83074783          	lbu	a5,-2000(a4) # f0001830 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0001831>
	if (litex_read8(LITEETH_TX_EV_PENDING_ADDR) & LITEETH_EV_TX) {
4002cb9c:	0017f793          	andi	a5,a5,1
4002cba0:	00078663          	beqz	a5,4002cbac <eth_irq_handler+0x18>
	*(volatile uint8_t *)addr = data;
4002cba4:	00100793          	li	a5,1
4002cba8:	82f70823          	sb	a5,-2000(a4)
	return *(volatile uint8_t *)addr;
4002cbac:	f00027b7          	lui	a5,0xf0002
4002cbb0:	8107c703          	lbu	a4,-2032(a5) # f0001810 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0001811>
	if (litex_read8(LITEETH_RX_EV_PENDING_ADDR) & LITEETH_EV_RX) {
4002cbb4:	00177713          	andi	a4,a4,1
4002cbb8:	1a070263          	beqz	a4,4002cd5c <eth_irq_handler+0x1c8>
{
4002cbbc:	fc010113          	addi	sp,sp,-64
4002cbc0:	02812c23          	sw	s0,56(sp)
4002cbc4:	02112e23          	sw	ra,60(sp)
4002cbc8:	02912a23          	sw	s1,52(sp)
4002cbcc:	03212823          	sw	s2,48(sp)
4002cbd0:	03312623          	sw	s3,44(sp)
4002cbd4:	03412423          	sw	s4,40(sp)
4002cbd8:	04010413          	addi	s0,sp,64
4002cbdc:	01052903          	lw	s2,16(a0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002cbe0:	30047a73          	csrrci	s4,mstatus,8
	return *(volatile uint16_t *)addr;
4002cbe4:	8047d983          	lhu	s3,-2044(a5)
	return *(volatile uint8_t *)addr;
4002cbe8:	8007c783          	lbu	a5,-2048(a5)
	pkt = net_pkt_rx_alloc_with_buffer(context->iface, len, AF_UNSPEC, 0,
4002cbec:	00092503          	lw	a0,0(s2)
	return *(volatile uint16_t *)addr;
4002cbf0:	01099993          	slli	s3,s3,0x10
4002cbf4:	0109d993          	srli	s3,s3,0x10
	context->rxslot = litex_read8(LITEETH_RX_SLOT_ADDR);
4002cbf8:	00f905a3          	sb	a5,11(s2)
	pkt = net_pkt_rx_alloc_with_buffer(context->iface, len, AF_UNSPEC, 0,
4002cbfc:	00000713          	li	a4,0
4002cc00:	00000793          	li	a5,0
4002cc04:	00000693          	li	a3,0
4002cc08:	00000613          	li	a2,0
4002cc0c:	00098593          	mv	a1,s3
4002cc10:	c9ceb0ef          	jal	ra,400180ac <net_pkt_rx_alloc_with_buffer>
4002cc14:	00050493          	mv	s1,a0
	if (pkt == NULL) {
4002cc18:	06051c63          	bnez	a0,4002cc90 <eth_irq_handler+0xfc>
		LOG_ERR("Failed to obtain RX buffer");
4002cc1c:	40044537          	lui	a0,0x40044
4002cc20:	73052783          	lw	a5,1840(a0) # 40044730 <log_dynamic_eth_liteeth>
4002cc24:	0077f793          	andi	a5,a5,7
4002cc28:	02078863          	beqz	a5,4002cc58 <eth_irq_handler+0xc4>
4002cc2c:	400397b7          	lui	a5,0x40039
4002cc30:	cfc78793          	addi	a5,a5,-772 # 40038cfc <gpio_litex_driver_api+0x38>
4002cc34:	fcf42e23          	sw	a5,-36(s0)
4002cc38:	00200793          	li	a5,2
4002cc3c:	fcf42c23          	sw	a5,-40(s0)
4002cc40:	000015b7          	lui	a1,0x1
4002cc44:	00000693          	li	a3,0
4002cc48:	fd840613          	addi	a2,s0,-40
4002cc4c:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4002cc50:	73050513          	addi	a0,a0,1840
4002cc54:	b40d80ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
			  : "r" (key & MSTATUS_IEN)
4002cc58:	008a7a13          	andi	s4,s4,8
	__asm__ volatile ("csrs mstatus, %0"
4002cc5c:	300a2073          	csrs	mstatus,s4
	*(volatile uint8_t *)addr = data;
4002cc60:	f00027b7          	lui	a5,0xf0002
4002cc64:	00100713          	li	a4,1
4002cc68:	80e78823          	sb	a4,-2032(a5) # f0001810 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0001811>
}
4002cc6c:	fc040113          	addi	sp,s0,-64
4002cc70:	03c12083          	lw	ra,60(sp)
4002cc74:	03812403          	lw	s0,56(sp)
4002cc78:	03412483          	lw	s1,52(sp)
4002cc7c:	03012903          	lw	s2,48(sp)
4002cc80:	02c12983          	lw	s3,44(sp)
4002cc84:	02812a03          	lw	s4,40(sp)
4002cc88:	04010113          	addi	sp,sp,64
4002cc8c:	00008067          	ret
	if (net_pkt_write(pkt, (void *)context->rx_buf[context->rxslot], len) != 0) {
4002cc90:	00b94783          	lbu	a5,11(s2)
4002cc94:	00098613          	mv	a2,s3
4002cc98:	00478793          	addi	a5,a5,4
4002cc9c:	00279793          	slli	a5,a5,0x2
4002cca0:	00f907b3          	add	a5,s2,a5
4002cca4:	0047a583          	lw	a1,4(a5)
4002cca8:	bddeb0ef          	jal	ra,40018884 <net_pkt_write>
4002ccac:	04050663          	beqz	a0,4002ccf8 <eth_irq_handler+0x164>
		LOG_ERR("Failed to append RX buffer to context buffer");
4002ccb0:	40044537          	lui	a0,0x40044
4002ccb4:	73052783          	lw	a5,1840(a0) # 40044730 <log_dynamic_eth_liteeth>
4002ccb8:	0077f793          	andi	a5,a5,7
4002ccbc:	02078863          	beqz	a5,4002ccec <eth_irq_handler+0x158>
4002ccc0:	400397b7          	lui	a5,0x40039
4002ccc4:	d1878793          	addi	a5,a5,-744 # 40038d18 <gpio_litex_driver_api+0x54>
4002ccc8:	fcf42e23          	sw	a5,-36(s0)
4002cccc:	00200793          	li	a5,2
4002ccd0:	fcf42c23          	sw	a5,-40(s0)
4002ccd4:	000015b7          	lui	a1,0x1
4002ccd8:	00000693          	li	a3,0
4002ccdc:	fd840613          	addi	a2,s0,-40
4002cce0:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4002cce4:	73050513          	addi	a0,a0,1840
4002cce8:	aacd80ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
		net_pkt_unref(pkt);
4002ccec:	00048513          	mv	a0,s1
4002ccf0:	b2dea0ef          	jal	ra,4001781c <net_pkt_unref>
4002ccf4:	f65ff06f          	j	4002cc58 <eth_irq_handler+0xc4>
	r = net_recv_data(context->iface, pkt);
4002ccf8:	00092503          	lw	a0,0(s2)
4002ccfc:	00048593          	mv	a1,s1
4002cd00:	ddde20ef          	jal	ra,4000fadc <net_recv_data>
	if (r < 0) {
4002cd04:	f4055ae3          	bgez	a0,4002cc58 <eth_irq_handler+0xc4>
		LOG_ERR("Failed to enqueue frame into RX queue: %d", r);
4002cd08:	40044737          	lui	a4,0x40044
4002cd0c:	73072783          	lw	a5,1840(a4) # 40044730 <log_dynamic_eth_liteeth>
4002cd10:	0077f793          	andi	a5,a5,7
4002cd14:	fc078ce3          	beqz	a5,4002ccec <eth_irq_handler+0x158>
4002cd18:	00010913          	mv	s2,sp
4002cd1c:	fe010113          	addi	sp,sp,-32
4002cd20:	00010613          	mv	a2,sp
4002cd24:	400397b7          	lui	a5,0x40039
4002cd28:	d4878793          	addi	a5,a5,-696 # 40038d48 <gpio_litex_driver_api+0x84>
4002cd2c:	00f62a23          	sw	a5,20(a2)
4002cd30:	00300793          	li	a5,3
4002cd34:	00a62c23          	sw	a0,24(a2)
4002cd38:	00f62823          	sw	a5,16(a2)
4002cd3c:	000025b7          	lui	a1,0x2
4002cd40:	00000693          	li	a3,0
4002cd44:	01060613          	addi	a2,a2,16
4002cd48:	84058593          	addi	a1,a1,-1984 # 1840 <CONFIG_HEAP_MEM_POOL_SIZE+0x840>
4002cd4c:	73070513          	addi	a0,a4,1840
4002cd50:	a44d80ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
4002cd54:	00090113          	mv	sp,s2
4002cd58:	f95ff06f          	j	4002ccec <eth_irq_handler+0x158>
4002cd5c:	00008067          	ret

4002cd60 <eth_tx>:
{
4002cd60:	fc010113          	addi	sp,sp,-64
4002cd64:	00050793          	mv	a5,a0
4002cd68:	02112e23          	sw	ra,60(sp)
4002cd6c:	02812c23          	sw	s0,56(sp)
4002cd70:	02912a23          	sw	s1,52(sp)
4002cd74:	03212823          	sw	s2,48(sp)
4002cd78:	03312623          	sw	s3,44(sp)
4002cd7c:	00058513          	mv	a0,a1
	struct eth_liteeth_dev_data *context = dev->data;
4002cd80:	0107a483          	lw	s1,16(a5)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002cd84:	30047473          	csrrci	s0,mstatus,8
	len = net_pkt_get_len(pkt);
4002cd88:	0085a783          	lw	a5,8(a1)
	size_t bytes = 0;
4002cd8c:	00000613          	li	a2,0
	while (buf) {
4002cd90:	08079263          	bnez	a5,4002ce14 <eth_tx+0xb4>
	net_pkt_read(pkt, context->tx_buf[context->txslot], len);
4002cd94:	00a4c783          	lbu	a5,10(s1)
	len = net_pkt_get_len(pkt);
4002cd98:	01061913          	slli	s2,a2,0x10
4002cd9c:	01095913          	srli	s2,s2,0x10
	net_pkt_read(pkt, context->tx_buf[context->txslot], len);
4002cda0:	00279793          	slli	a5,a5,0x2
4002cda4:	00f487b3          	add	a5,s1,a5
4002cda8:	00c7a583          	lw	a1,12(a5)
4002cdac:	00090613          	mv	a2,s2
	return *(volatile uint8_t *)addr;
4002cdb0:	f00029b7          	lui	s3,0xf0002
4002cdb4:	d84eb0ef          	jal	ra,40018338 <net_pkt_read>
	litex_write8(context->txslot, LITEETH_TX_SLOT_ADDR);
4002cdb8:	00a4c703          	lbu	a4,10(s1)
	*(volatile uint8_t *)addr = data;
4002cdbc:	f00027b7          	lui	a5,0xf0002
4002cdc0:	82e78223          	sb	a4,-2012(a5) # f0001824 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0001825>
	*(volatile uint16_t *)addr = data;
4002cdc4:	83279423          	sh	s2,-2008(a5)
}
4002cdc8:	06500913          	li	s2,101
	return *(volatile uint8_t *)addr;
4002cdcc:	81c9c783          	lbu	a5,-2020(s3) # f000181c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf000181d>
	while (litex_read8(LITEETH_TX_READY_ADDR) == 0) {
4002cdd0:	04078a63          	beqz	a5,4002ce24 <eth_tx+0xc4>
	*(volatile uint8_t *)addr = data;
4002cdd4:	00100793          	li	a5,1
4002cdd8:	80f98c23          	sb	a5,-2024(s3)
	context->txslot = (context->txslot + 1) % 2;
4002cddc:	00a4c783          	lbu	a5,10(s1)
			  : "r" (key & MSTATUS_IEN)
4002cde0:	00847413          	andi	s0,s0,8
4002cde4:	00178793          	addi	a5,a5,1
4002cde8:	0017f793          	andi	a5,a5,1
4002cdec:	00f48523          	sb	a5,10(s1)
	__asm__ volatile ("csrs mstatus, %0"
4002cdf0:	30042073          	csrs	mstatus,s0
	return 0;
4002cdf4:	00000513          	li	a0,0
}
4002cdf8:	03c12083          	lw	ra,60(sp)
4002cdfc:	03812403          	lw	s0,56(sp)
4002ce00:	03412483          	lw	s1,52(sp)
4002ce04:	03012903          	lw	s2,48(sp)
4002ce08:	02c12983          	lw	s3,44(sp)
4002ce0c:	04010113          	addi	sp,sp,64
4002ce10:	00008067          	ret
		bytes += buf->len;
4002ce14:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
4002ce18:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4002ce1c:	00e60633          	add	a2,a2,a4
		buf = buf->frags;
4002ce20:	f71ff06f          	j	4002cd90 <eth_tx+0x30>
		if (attempts++ == MAX_TX_FAILURE) {
4002ce24:	fff90913          	addi	s2,s2,-1
4002ce28:	04091863          	bnez	s2,4002ce78 <eth_tx+0x118>
			  : "r" (key & MSTATUS_IEN)
4002ce2c:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrs mstatus, %0"
4002ce30:	30042073          	csrs	mstatus,s0
	LOG_ERR("TX fifo failed");
4002ce34:	40044537          	lui	a0,0x40044
4002ce38:	73052783          	lw	a5,1840(a0) # 40044730 <log_dynamic_eth_liteeth>
4002ce3c:	0077f793          	andi	a5,a5,7
4002ce40:	02078863          	beqz	a5,4002ce70 <eth_tx+0x110>
4002ce44:	400397b7          	lui	a5,0x40039
4002ce48:	d7478793          	addi	a5,a5,-652 # 40038d74 <gpio_litex_driver_api+0xb0>
4002ce4c:	00f12e23          	sw	a5,28(sp)
4002ce50:	00200793          	li	a5,2
4002ce54:	00f12c23          	sw	a5,24(sp)
4002ce58:	000015b7          	lui	a1,0x1
4002ce5c:	00000693          	li	a3,0
4002ce60:	01810613          	addi	a2,sp,24
4002ce64:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4002ce68:	73050513          	addi	a0,a0,1840
4002ce6c:	928d80ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
	return -1;
4002ce70:	fff00513          	li	a0,-1
4002ce74:	f85ff06f          	j	4002cdf8 <eth_tx+0x98>
	return z_impl_k_sleep(timeout);
4002ce78:	00000593          	li	a1,0
4002ce7c:	00100513          	li	a0,1
4002ce80:	084040ef          	jal	ra,40030f04 <z_impl_k_sleep>
4002ce84:	f49ff06f          	j	4002cdcc <eth_tx+0x6c>

4002ce88 <uart_liteuart_poll_out>:
	return *(volatile uint8_t *)addr;
4002ce88:	f00057b7          	lui	a5,0xf0005
4002ce8c:	8047c703          	lbu	a4,-2044(a5) # f0004804 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0004805>
 * @param c Character to send
 */
static void uart_liteuart_poll_out(const struct device *dev, unsigned char c)
{
	/* wait for space */
	while (litex_read8(UART_TXFULL_ADDR)) {
4002ce90:	fe071ee3          	bnez	a4,4002ce8c <uart_liteuart_poll_out+0x4>
	*(volatile uint8_t *)addr = data;
4002ce94:	80b78023          	sb	a1,-2048(a5)
	}

	litex_write8(c, UART_RXTX_ADDR);
}
4002ce98:	00008067          	ret

4002ce9c <uart_liteuart_poll_in>:
	return *(volatile uint8_t *)addr;
4002ce9c:	f00057b7          	lui	a5,0xf0005
4002cea0:	8087c703          	lbu	a4,-2040(a5) # f0004808 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0004809>
		 * to UART_EV_PENDING
		 */
		litex_write8(UART_EV_RX, UART_EV_PENDING_ADDR);
		return 0;
	} else {
		return -1;
4002cea4:	fff00513          	li	a0,-1
	if (!litex_read8(UART_RXEMPTY_ADDR)) {
4002cea8:	00071c63          	bnez	a4,4002cec0 <uart_liteuart_poll_in+0x24>
4002ceac:	8007c703          	lbu	a4,-2048(a5)
		return 0;
4002ceb0:	00000513          	li	a0,0
		*c = litex_read8(UART_RXTX_ADDR);
4002ceb4:	00e58023          	sb	a4,0(a1)
	*(volatile uint8_t *)addr = data;
4002ceb8:	00200713          	li	a4,2
4002cebc:	80e78823          	sb	a4,-2032(a5)
	}
}
4002cec0:	00008067          	ret

4002cec4 <uart_liteuart_init>:
4002cec4:	f00057b7          	lui	a5,0xf0005
4002cec8:	00300713          	li	a4,3
4002cecc:	80e78823          	sb	a4,-2032(a5) # f0004810 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0004811>
			0);
	irq_enable(UART_IRQ);
#endif

	return 0;
}
4002ced0:	00000513          	li	a0,0
4002ced4:	00008067          	ret

4002ced8 <sys_clock_set_timeout>:

/* Weak-linked noop defaults for optional driver interfaces*/

void __weak sys_clock_set_timeout(int32_t ticks, bool idle)
{
}
4002ced8:	00008067          	ret

4002cedc <sys_clock_driver_init>:
{
	return 0;
}

static int sys_clock_driver_init(void)
{
4002cedc:	ff010113          	addi	sp,sp,-16
	IRQ_CONNECT(TIMER_IRQ, DT_INST_IRQ(0, priority),
			litex_timer_irq_handler, NULL, 0);
	irq_enable(TIMER_IRQ);
4002cee0:	00100513          	li	a0,1
{
4002cee4:	00112623          	sw	ra,12(sp)
	irq_enable(TIMER_IRQ);
4002cee8:	aa0ff0ef          	jal	ra,4002c188 <arch_irq_enable>
4002ceec:	f00047b7          	lui	a5,0xf0004
	*(volatile uint32_t *)addr = data;
4002cef0:	000f4737          	lui	a4,0xf4
	*(volatile uint8_t *)addr = data;
4002cef4:	00078423          	sb	zero,8(a5) # f0004008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0004009>
	*(volatile uint32_t *)addr = data;
4002cef8:	24070713          	addi	a4,a4,576 # f4240 <__rom_region_size+0xbb284>
4002cefc:	00e7a223          	sw	a4,4(a5)
4002cf00:	00e7a023          	sw	a4,0(a5)
	*(volatile uint8_t *)addr = data;
4002cf04:	00100693          	li	a3,1
4002cf08:	00d78423          	sb	a3,8(a5)
	return *(volatile uint8_t *)addr;
4002cf0c:	0187c703          	lbu	a4,24(a5)
	litex_write8(TIMER_ENABLE, TIMER_EN_ADDR);
	litex_write8(litex_read8(TIMER_EV_PENDING_ADDR), TIMER_EV_PENDING_ADDR);
	litex_write8(TIMER_EV, TIMER_EV_ENABLE_ADDR);

	return 0;
}
4002cf10:	00000513          	li	a0,0
4002cf14:	0ff77713          	zext.b	a4,a4
	*(volatile uint8_t *)addr = data;
4002cf18:	00e78c23          	sb	a4,24(a5)
4002cf1c:	00d78e23          	sb	a3,28(a5)
4002cf20:	00c12083          	lw	ra,12(sp)
4002cf24:	01010113          	addi	sp,sp,16
4002cf28:	00008067          	ret

4002cf2c <litex_timer_irq_handler>:
{
4002cf2c:	ff010113          	addi	sp,sp,-16
4002cf30:	00112623          	sw	ra,12(sp)
4002cf34:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002cf38:	30047473          	csrrci	s0,mstatus,8
4002cf3c:	f00047b7          	lui	a5,0xf0004
4002cf40:	00100713          	li	a4,1
4002cf44:	00e78c23          	sb	a4,24(a5) # f0004018 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0004019>
	sys_clock_announce(1);
4002cf48:	00100513          	li	a0,1
4002cf4c:	568040ef          	jal	ra,400314b4 <sys_clock_announce>
			  : "r" (key & MSTATUS_IEN)
4002cf50:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrs mstatus, %0"
4002cf54:	30042073          	csrs	mstatus,s0
}
4002cf58:	00c12083          	lw	ra,12(sp)
4002cf5c:	00812403          	lw	s0,8(sp)
4002cf60:	01010113          	addi	sp,sp,16
4002cf64:	00008067          	ret

4002cf68 <sys_clock_cycle_get_32>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002cf68:	300477f3          	csrrci	a5,mstatus,8
4002cf6c:	f0004737          	lui	a4,0xf0004
4002cf70:	00100693          	li	a3,1
4002cf74:	02d70023          	sb	a3,32(a4) # f0004020 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0004021>
	return *(volatile uint32_t *)addr;
4002cf78:	02472683          	lw	a3,36(a4)
	__asm__ volatile ("csrs mstatus, %0"
4002cf7c:	0087f793          	andi	a5,a5,8
4002cf80:	02872503          	lw	a0,40(a4)
4002cf84:	3007a073          	csrs	mstatus,a5
}
4002cf88:	00008067          	ret

4002cf8c <sys_clock_elapsed>:
}
4002cf8c:	00000513          	li	a0,0
4002cf90:	00008067          	ret

4002cf94 <_mbedtls_init>:
#if defined(CONFIG_MBEDTLS_DEBUG_LEVEL)
	mbedtls_debug_set_threshold(CONFIG_MBEDTLS_DEBUG_LEVEL);
#endif

	return 0;
}
4002cf94:	00000513          	li	a0,0
4002cf98:	00008067          	ret

4002cf9c <mbedtls_md5_init>:

#if !defined(MBEDTLS_MD5_ALT)

void mbedtls_md5_init( mbedtls_md5_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_md5_context ) );
4002cf9c:	05800613          	li	a2,88
4002cfa0:	00000593          	li	a1,0
4002cfa4:	d79df06f          	j	4000cd1c <memset>

4002cfa8 <mbedtls_internal_md5_process>:
}

#if !defined(MBEDTLS_MD5_PROCESS_ALT)
int mbedtls_internal_md5_process( mbedtls_md5_context *ctx,
                                  const unsigned char data[64] )
{
4002cfa8:	f7010113          	addi	sp,sp,-144
4002cfac:	08112623          	sw	ra,140(sp)
4002cfb0:	08912223          	sw	s1,132(sp)
4002cfb4:	09212023          	sw	s2,128(sp)
4002cfb8:	07312e23          	sw	s3,124(sp)
4002cfbc:	07412c23          	sw	s4,120(sp)
4002cfc0:	07512a23          	sw	s5,116(sp)
4002cfc4:	07612823          	sw	s6,112(sp)
4002cfc8:	07712623          	sw	s7,108(sp)
4002cfcc:	07812423          	sw	s8,104(sp)
4002cfd0:	07912223          	sw	s9,100(sp)
4002cfd4:	07a12023          	sw	s10,96(sp)
4002cfd8:	05b12e23          	sw	s11,92(sp)
4002cfdc:	08812423          	sw	s0,136(sp)
    struct
    {
        uint32_t X[16], A, B, C, D;
    } local;

    local.X[ 0] = MBEDTLS_GET_UINT32_LE( data,  0 );
4002cfe0:	0015c703          	lbu	a4,1(a1)
4002cfe4:	0005c783          	lbu	a5,0(a1)
4002cfe8:	0035c403          	lbu	s0,3(a1)
4002cfec:	00871713          	slli	a4,a4,0x8
4002cff0:	00f76733          	or	a4,a4,a5
4002cff4:	0025c783          	lbu	a5,2(a1)
4002cff8:	01841413          	slli	s0,s0,0x18
    local.X[ 1] = MBEDTLS_GET_UINT32_LE( data,  4 );
4002cffc:	0075ce03          	lbu	t3,7(a1)
    local.X[ 0] = MBEDTLS_GET_UINT32_LE( data,  0 );
4002d000:	01079793          	slli	a5,a5,0x10
4002d004:	00e7e7b3          	or	a5,a5,a4
    local.X[ 1] = MBEDTLS_GET_UINT32_LE( data,  4 );
4002d008:	0055c703          	lbu	a4,5(a1)
    local.X[ 0] = MBEDTLS_GET_UINT32_LE( data,  0 );
4002d00c:	00f46433          	or	s0,s0,a5
    local.X[ 1] = MBEDTLS_GET_UINT32_LE( data,  4 );
4002d010:	0045c783          	lbu	a5,4(a1)
4002d014:	00871713          	slli	a4,a4,0x8
4002d018:	018e1e13          	slli	t3,t3,0x18
4002d01c:	00f76733          	or	a4,a4,a5
4002d020:	0065c783          	lbu	a5,6(a1)
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
    local.X[ 3] = MBEDTLS_GET_UINT32_LE( data, 12 );
4002d024:	00d5c683          	lbu	a3,13(a1)
4002d028:	00f5cf03          	lbu	t5,15(a1)
    local.X[ 1] = MBEDTLS_GET_UINT32_LE( data,  4 );
4002d02c:	01079793          	slli	a5,a5,0x10
4002d030:	00e7e7b3          	or	a5,a5,a4
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
4002d034:	0095c703          	lbu	a4,9(a1)
    local.X[ 1] = MBEDTLS_GET_UINT32_LE( data,  4 );
4002d038:	00fe6e33          	or	t3,t3,a5
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
4002d03c:	0085c783          	lbu	a5,8(a1)
4002d040:	00871713          	slli	a4,a4,0x8
    local.X[ 3] = MBEDTLS_GET_UINT32_LE( data, 12 );
4002d044:	00869693          	slli	a3,a3,0x8
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
4002d048:	00f76733          	or	a4,a4,a5
4002d04c:	00a5c783          	lbu	a5,10(a1)
    local.X[ 3] = MBEDTLS_GET_UINT32_LE( data, 12 );
4002d050:	018f1f13          	slli	t5,t5,0x18
    local.X[ 0] = MBEDTLS_GET_UINT32_LE( data,  0 );
4002d054:	00812023          	sw	s0,0(sp)
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
4002d058:	01079793          	slli	a5,a5,0x10
4002d05c:	00e7e7b3          	or	a5,a5,a4
4002d060:	00b5c703          	lbu	a4,11(a1)
    local.X[ 1] = MBEDTLS_GET_UINT32_LE( data,  4 );
4002d064:	01c12223          	sw	t3,4(sp)
    local.C = ctx->state[2];
    local.D = ctx->state[3];

#define F(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))

    P( local.A, local.B, local.C, local.D,  0,  7, 0xD76AA478 );
4002d068:	d76aa9b7          	lui	s3,0xd76aa
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
4002d06c:	01871713          	slli	a4,a4,0x18
4002d070:	00f76733          	or	a4,a4,a5
    local.X[ 3] = MBEDTLS_GET_UINT32_LE( data, 12 );
4002d074:	00c5c783          	lbu	a5,12(a1)
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
4002d078:	00e12423          	sw	a4,8(sp)
    P( local.A, local.B, local.C, local.D,  0,  7, 0xD76AA478 );
4002d07c:	47898993          	addi	s3,s3,1144 # d76aa478 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd76aa479>
    local.X[ 3] = MBEDTLS_GET_UINT32_LE( data, 12 );
4002d080:	00f6e6b3          	or	a3,a3,a5
4002d084:	00e5c783          	lbu	a5,14(a1)
    P( local.D, local.A, local.B, local.C,  1, 12, 0xE8C7B756 );
    P( local.C, local.D, local.A, local.B,  2, 17, 0x242070DB );
    P( local.B, local.C, local.D, local.A,  3, 22, 0xC1BDCEEE );
    P( local.A, local.B, local.C, local.D,  4,  7, 0xF57C0FAF );
4002d088:	f57c1d37          	lui	s10,0xf57c1
4002d08c:	fafd0d13          	addi	s10,s10,-81 # f57c0faf <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf57c0fb0>
    local.X[ 3] = MBEDTLS_GET_UINT32_LE( data, 12 );
4002d090:	01079793          	slli	a5,a5,0x10
4002d094:	00d7e7b3          	or	a5,a5,a3
4002d098:	00ff6f33          	or	t5,t5,a5
4002d09c:	01e12623          	sw	t5,12(sp)
    local.X[ 4] = MBEDTLS_GET_UINT32_LE( data, 16 );
4002d0a0:	0115c683          	lbu	a3,17(a1)
4002d0a4:	0105c783          	lbu	a5,16(a1)
4002d0a8:	0135c603          	lbu	a2,19(a1)
4002d0ac:	00869693          	slli	a3,a3,0x8
4002d0b0:	00f6e6b3          	or	a3,a3,a5
4002d0b4:	0125c783          	lbu	a5,18(a1)
4002d0b8:	01861613          	slli	a2,a2,0x18
    local.X[ 5] = MBEDTLS_GET_UINT32_LE( data, 20 );
4002d0bc:	0175c283          	lbu	t0,23(a1)
    local.X[ 4] = MBEDTLS_GET_UINT32_LE( data, 16 );
4002d0c0:	01079793          	slli	a5,a5,0x10
4002d0c4:	00d7e7b3          	or	a5,a5,a3
    local.X[ 5] = MBEDTLS_GET_UINT32_LE( data, 20 );
4002d0c8:	0155c683          	lbu	a3,21(a1)
    local.X[ 4] = MBEDTLS_GET_UINT32_LE( data, 16 );
4002d0cc:	00f66633          	or	a2,a2,a5
    local.X[ 5] = MBEDTLS_GET_UINT32_LE( data, 20 );
4002d0d0:	0145c783          	lbu	a5,20(a1)
4002d0d4:	00869693          	slli	a3,a3,0x8
4002d0d8:	01829293          	slli	t0,t0,0x18
4002d0dc:	00f6e6b3          	or	a3,a3,a5
4002d0e0:	0165c783          	lbu	a5,22(a1)
    local.X[ 6] = MBEDTLS_GET_UINT32_LE( data, 24 );
4002d0e4:	01b5c883          	lbu	a7,27(a1)
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
4002d0e8:	01f5c083          	lbu	ra,31(a1)
    local.X[ 5] = MBEDTLS_GET_UINT32_LE( data, 20 );
4002d0ec:	01079793          	slli	a5,a5,0x10
4002d0f0:	00d7e7b3          	or	a5,a5,a3
    local.X[ 6] = MBEDTLS_GET_UINT32_LE( data, 24 );
4002d0f4:	0195c683          	lbu	a3,25(a1)
    local.X[ 5] = MBEDTLS_GET_UINT32_LE( data, 20 );
4002d0f8:	00f2e2b3          	or	t0,t0,a5
    local.X[ 6] = MBEDTLS_GET_UINT32_LE( data, 24 );
4002d0fc:	0185c783          	lbu	a5,24(a1)
4002d100:	00869693          	slli	a3,a3,0x8
4002d104:	01889893          	slli	a7,a7,0x18
4002d108:	00f6e6b3          	or	a3,a3,a5
4002d10c:	01a5c783          	lbu	a5,26(a1)
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
4002d110:	01809093          	slli	ra,ra,0x18
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
4002d114:	0235c303          	lbu	t1,35(a1)
    local.X[ 6] = MBEDTLS_GET_UINT32_LE( data, 24 );
4002d118:	01079793          	slli	a5,a5,0x10
4002d11c:	00d7e7b3          	or	a5,a5,a3
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
4002d120:	01d5c683          	lbu	a3,29(a1)
    local.X[ 6] = MBEDTLS_GET_UINT32_LE( data, 24 );
4002d124:	00f8e8b3          	or	a7,a7,a5
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
4002d128:	01c5c783          	lbu	a5,28(a1)
4002d12c:	00869693          	slli	a3,a3,0x8
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
4002d130:	01831313          	slli	t1,t1,0x18
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
4002d134:	00f6e6b3          	or	a3,a3,a5
4002d138:	01e5c783          	lbu	a5,30(a1)
    local.X[10] = MBEDTLS_GET_UINT32_LE( data, 40 );
4002d13c:	0295c803          	lbu	a6,41(a1)
    local.X[ 4] = MBEDTLS_GET_UINT32_LE( data, 16 );
4002d140:	00c12823          	sw	a2,16(sp)
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
4002d144:	01079793          	slli	a5,a5,0x10
4002d148:	00d7e7b3          	or	a5,a5,a3
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
4002d14c:	0215c683          	lbu	a3,33(a1)
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
4002d150:	00f0e0b3          	or	ra,ra,a5
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
4002d154:	0205c783          	lbu	a5,32(a1)
4002d158:	00869693          	slli	a3,a3,0x8
    local.X[10] = MBEDTLS_GET_UINT32_LE( data, 40 );
4002d15c:	00881813          	slli	a6,a6,0x8
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
4002d160:	00f6e6b3          	or	a3,a3,a5
4002d164:	0225c783          	lbu	a5,34(a1)
    local.X[ 5] = MBEDTLS_GET_UINT32_LE( data, 20 );
4002d168:	00512a23          	sw	t0,20(sp)
    local.X[ 6] = MBEDTLS_GET_UINT32_LE( data, 24 );
4002d16c:	01112c23          	sw	a7,24(sp)
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
4002d170:	01079793          	slli	a5,a5,0x10
4002d174:	00d7e7b3          	or	a5,a5,a3
4002d178:	00f36333          	or	t1,t1,a5
    local.X[ 9] = MBEDTLS_GET_UINT32_LE( data, 36 );
4002d17c:	0255c783          	lbu	a5,37(a1)
4002d180:	0245c683          	lbu	a3,36(a1)
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
4002d184:	00112e23          	sw	ra,28(sp)
    local.X[ 9] = MBEDTLS_GET_UINT32_LE( data, 36 );
4002d188:	00879793          	slli	a5,a5,0x8
4002d18c:	00d7e7b3          	or	a5,a5,a3
4002d190:	0265c683          	lbu	a3,38(a1)
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
4002d194:	02612023          	sw	t1,32(sp)
    P( local.A, local.B, local.C, local.D,  4,  7, 0xF57C0FAF );
4002d198:	01a60d33          	add	s10,a2,s10
    local.X[ 9] = MBEDTLS_GET_UINT32_LE( data, 36 );
4002d19c:	01069693          	slli	a3,a3,0x10
4002d1a0:	00f6e6b3          	or	a3,a3,a5
4002d1a4:	0275c783          	lbu	a5,39(a1)
    P( local.C, local.D, local.A, local.B,  3, 14, 0xF4D50D87 );
    P( local.B, local.C, local.D, local.A,  8, 20, 0x455A14ED );
    P( local.A, local.B, local.C, local.D, 13,  5, 0xA9E3E905 );
    P( local.D, local.A, local.B, local.C,  2,  9, 0xFCEFA3F8 );
    P( local.C, local.D, local.A, local.B,  7, 14, 0x676F02D9 );
    P( local.B, local.C, local.D, local.A, 12, 20, 0x8D2A4C8A );
4002d1a8:	8d2a5db7          	lui	s11,0x8d2a5
4002d1ac:	c8ad8d93          	addi	s11,s11,-886 # 8d2a4c8a <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8d2a4c8b>
    local.X[ 9] = MBEDTLS_GET_UINT32_LE( data, 36 );
4002d1b0:	01879793          	slli	a5,a5,0x18
4002d1b4:	00d7e7b3          	or	a5,a5,a3
    local.X[10] = MBEDTLS_GET_UINT32_LE( data, 40 );
4002d1b8:	0285c683          	lbu	a3,40(a1)
    local.X[ 9] = MBEDTLS_GET_UINT32_LE( data, 36 );
4002d1bc:	02f12223          	sw	a5,36(sp)
    local.X[10] = MBEDTLS_GET_UINT32_LE( data, 40 );
4002d1c0:	00d86833          	or	a6,a6,a3
4002d1c4:	02a5c683          	lbu	a3,42(a1)
4002d1c8:	02b5ce83          	lbu	t4,43(a1)
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
4002d1cc:	0315cf83          	lbu	t6,49(a1)
    local.X[10] = MBEDTLS_GET_UINT32_LE( data, 40 );
4002d1d0:	01069693          	slli	a3,a3,0x10
4002d1d4:	0106e6b3          	or	a3,a3,a6
4002d1d8:	018e9e93          	slli	t4,t4,0x18
4002d1dc:	00deeeb3          	or	t4,t4,a3
    local.X[11] = MBEDTLS_GET_UINT32_LE( data, 44 );
4002d1e0:	02d5c683          	lbu	a3,45(a1)
4002d1e4:	02c5c803          	lbu	a6,44(a1)
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
4002d1e8:	008f9f93          	slli	t6,t6,0x8
    local.X[11] = MBEDTLS_GET_UINT32_LE( data, 44 );
4002d1ec:	00869693          	slli	a3,a3,0x8
4002d1f0:	0106e6b3          	or	a3,a3,a6
4002d1f4:	02e5c803          	lbu	a6,46(a1)
    local.X[13] = MBEDTLS_GET_UINT32_LE( data, 52 );
4002d1f8:	0345c383          	lbu	t2,52(a1)
    local.X[14] = MBEDTLS_GET_UINT32_LE( data, 56 );
4002d1fc:	0385c483          	lbu	s1,56(a1)
    local.X[11] = MBEDTLS_GET_UINT32_LE( data, 44 );
4002d200:	01081813          	slli	a6,a6,0x10
4002d204:	00d86833          	or	a6,a6,a3
4002d208:	02f5c683          	lbu	a3,47(a1)
    local.X[15] = MBEDTLS_GET_UINT32_LE( data, 60 );
4002d20c:	03d5c903          	lbu	s2,61(a1)
    local.C = ctx->state[2];
4002d210:	01052b03          	lw	s6,16(a0)
    local.X[11] = MBEDTLS_GET_UINT32_LE( data, 44 );
4002d214:	01869693          	slli	a3,a3,0x18
4002d218:	0106e6b3          	or	a3,a3,a6
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
4002d21c:	0305c803          	lbu	a6,48(a1)
    local.X[15] = MBEDTLS_GET_UINT32_LE( data, 60 );
4002d220:	00891913          	slli	s2,s2,0x8
    local.D = ctx->state[3];
4002d224:	01452b83          	lw	s7,20(a0)
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
4002d228:	010fefb3          	or	t6,t6,a6
4002d22c:	0325c803          	lbu	a6,50(a1)
    local.A = ctx->state[0];
4002d230:	00852c03          	lw	s8,8(a0)
    local.X[10] = MBEDTLS_GET_UINT32_LE( data, 40 );
4002d234:	03d12423          	sw	t4,40(sp)
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
4002d238:	01081813          	slli	a6,a6,0x10
4002d23c:	01f86833          	or	a6,a6,t6
4002d240:	0335cf83          	lbu	t6,51(a1)
    P( local.A, local.B, local.C, local.D,  0,  7, 0xD76AA478 );
4002d244:	013c09b3          	add	s3,s8,s3
4002d248:	008989b3          	add	s3,s3,s0
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
4002d24c:	018f9f93          	slli	t6,t6,0x18
4002d250:	010fefb3          	or	t6,t6,a6
    local.X[13] = MBEDTLS_GET_UINT32_LE( data, 52 );
4002d254:	0355c803          	lbu	a6,53(a1)
    P( local.B, local.C, local.D, local.A, 12, 20, 0x8D2A4C8A );
4002d258:	01bf8db3          	add	s11,t6,s11
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
4002d25c:	03f12823          	sw	t6,48(sp)
    local.X[13] = MBEDTLS_GET_UINT32_LE( data, 52 );
4002d260:	00881813          	slli	a6,a6,0x8
4002d264:	00786833          	or	a6,a6,t2
4002d268:	0365c383          	lbu	t2,54(a1)
    local.X[11] = MBEDTLS_GET_UINT32_LE( data, 44 );
4002d26c:	02d12623          	sw	a3,44(sp)
    local.X[13] = MBEDTLS_GET_UINT32_LE( data, 52 );
4002d270:	01039393          	slli	t2,t2,0x10
4002d274:	0103e3b3          	or	t2,t2,a6
4002d278:	0375c803          	lbu	a6,55(a1)
4002d27c:	01881813          	slli	a6,a6,0x18
4002d280:	00786833          	or	a6,a6,t2
    local.X[14] = MBEDTLS_GET_UINT32_LE( data, 56 );
4002d284:	0395c383          	lbu	t2,57(a1)
    local.X[13] = MBEDTLS_GET_UINT32_LE( data, 52 );
4002d288:	03012a23          	sw	a6,52(sp)
    local.X[14] = MBEDTLS_GET_UINT32_LE( data, 56 );
4002d28c:	00839393          	slli	t2,t2,0x8
4002d290:	0093e3b3          	or	t2,t2,s1
4002d294:	03a5c483          	lbu	s1,58(a1)
4002d298:	01049493          	slli	s1,s1,0x10
4002d29c:	0074e4b3          	or	s1,s1,t2
4002d2a0:	03b5c383          	lbu	t2,59(a1)
4002d2a4:	01839393          	slli	t2,t2,0x18
4002d2a8:	0093e3b3          	or	t2,t2,s1
    local.X[15] = MBEDTLS_GET_UINT32_LE( data, 60 );
4002d2ac:	03c5c483          	lbu	s1,60(a1)
    local.X[14] = MBEDTLS_GET_UINT32_LE( data, 56 );
4002d2b0:	02712c23          	sw	t2,56(sp)
    local.X[15] = MBEDTLS_GET_UINT32_LE( data, 60 );
4002d2b4:	00996933          	or	s2,s2,s1
4002d2b8:	03e5c483          	lbu	s1,62(a1)
4002d2bc:	03f5c583          	lbu	a1,63(a1)
4002d2c0:	01049493          	slli	s1,s1,0x10
4002d2c4:	0124e4b3          	or	s1,s1,s2
    local.B = ctx->state[1];
4002d2c8:	00c52903          	lw	s2,12(a0)
    local.X[15] = MBEDTLS_GET_UINT32_LE( data, 60 );
4002d2cc:	01859593          	slli	a1,a1,0x18
4002d2d0:	0095e5b3          	or	a1,a1,s1
    P( local.A, local.B, local.C, local.D,  0,  7, 0xD76AA478 );
4002d2d4:	017b44b3          	xor	s1,s6,s7
4002d2d8:	0124f4b3          	and	s1,s1,s2
4002d2dc:	0174c4b3          	xor	s1,s1,s7
4002d2e0:	013484b3          	add	s1,s1,s3
4002d2e4:	00749a13          	slli	s4,s1,0x7
4002d2e8:	0194d493          	srli	s1,s1,0x19
4002d2ec:	009a6a33          	or	s4,s4,s1
    P( local.D, local.A, local.B, local.C,  1, 12, 0xE8C7B756 );
4002d2f0:	e8c7b9b7          	lui	s3,0xe8c7b
    P( local.A, local.B, local.C, local.D,  0,  7, 0xD76AA478 );
4002d2f4:	012a0a33          	add	s4,s4,s2
    P( local.D, local.A, local.B, local.C,  1, 12, 0xE8C7B756 );
4002d2f8:	016944b3          	xor	s1,s2,s6
4002d2fc:	75698993          	addi	s3,s3,1878 # e8c7b756 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe8c7b757>
4002d300:	0144f4b3          	and	s1,s1,s4
4002d304:	013b89b3          	add	s3,s7,s3
4002d308:	01c989b3          	add	s3,s3,t3
4002d30c:	0164c4b3          	xor	s1,s1,s6
4002d310:	013484b3          	add	s1,s1,s3
4002d314:	00c49c93          	slli	s9,s1,0xc
4002d318:	0144d493          	srli	s1,s1,0x14
4002d31c:	009cecb3          	or	s9,s9,s1
    P( local.C, local.D, local.A, local.B,  2, 17, 0x242070DB );
4002d320:	242079b7          	lui	s3,0x24207
    P( local.D, local.A, local.B, local.C,  1, 12, 0xE8C7B756 );
4002d324:	014c8cb3          	add	s9,s9,s4
    P( local.C, local.D, local.A, local.B,  2, 17, 0x242070DB );
4002d328:	014944b3          	xor	s1,s2,s4
4002d32c:	0db98993          	addi	s3,s3,219 # 242070db <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1e2a8fdb>
4002d330:	0194f4b3          	and	s1,s1,s9
4002d334:	013b09b3          	add	s3,s6,s3
4002d338:	00e989b3          	add	s3,s3,a4
4002d33c:	0124c4b3          	xor	s1,s1,s2
4002d340:	013484b3          	add	s1,s1,s3
4002d344:	00f4da93          	srli	s5,s1,0xf
4002d348:	01149493          	slli	s1,s1,0x11
4002d34c:	009aeab3          	or	s5,s5,s1
    P( local.B, local.C, local.D, local.A,  3, 22, 0xC1BDCEEE );
4002d350:	c1bdd9b7          	lui	s3,0xc1bdd
    P( local.C, local.D, local.A, local.B,  2, 17, 0x242070DB );
4002d354:	019a8ab3          	add	s5,s5,s9
    P( local.B, local.C, local.D, local.A,  3, 22, 0xC1BDCEEE );
4002d358:	019a44b3          	xor	s1,s4,s9
4002d35c:	eee98993          	addi	s3,s3,-274 # c1bdceee <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xc1bdceef>
4002d360:	0154f4b3          	and	s1,s1,s5
4002d364:	013909b3          	add	s3,s2,s3
4002d368:	01e989b3          	add	s3,s3,t5
4002d36c:	0144c4b3          	xor	s1,s1,s4
4002d370:	013484b3          	add	s1,s1,s3
4002d374:	00a4d993          	srli	s3,s1,0xa
4002d378:	01649493          	slli	s1,s1,0x16
4002d37c:	0099e9b3          	or	s3,s3,s1
4002d380:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  4,  7, 0xF57C0FAF );
4002d384:	015cc4b3          	xor	s1,s9,s5
4002d388:	0134f4b3          	and	s1,s1,s3
4002d38c:	014d0a33          	add	s4,s10,s4
4002d390:	0194c4b3          	xor	s1,s1,s9
4002d394:	014484b3          	add	s1,s1,s4
4002d398:	00749a13          	slli	s4,s1,0x7
4002d39c:	0194d493          	srli	s1,s1,0x19
4002d3a0:	009a6a33          	or	s4,s4,s1
    P( local.D, local.A, local.B, local.C,  5, 12, 0x4787C62A );
4002d3a4:	4787cd37          	lui	s10,0x4787c
    P( local.A, local.B, local.C, local.D,  4,  7, 0xF57C0FAF );
4002d3a8:	013a0a33          	add	s4,s4,s3
    P( local.D, local.A, local.B, local.C,  5, 12, 0x4787C62A );
4002d3ac:	013ac4b3          	xor	s1,s5,s3
4002d3b0:	62ad0d13          	addi	s10,s10,1578 # 4787c62a <__data_region_end+0x7837b62>
4002d3b4:	01a28d33          	add	s10,t0,s10
4002d3b8:	0144f4b3          	and	s1,s1,s4
4002d3bc:	019d0cb3          	add	s9,s10,s9
4002d3c0:	0154c4b3          	xor	s1,s1,s5
4002d3c4:	019484b3          	add	s1,s1,s9
4002d3c8:	00c49c93          	slli	s9,s1,0xc
4002d3cc:	0144d493          	srli	s1,s1,0x14
4002d3d0:	009cecb3          	or	s9,s9,s1
    P( local.C, local.D, local.A, local.B,  6, 17, 0xA8304613 );
4002d3d4:	a8304d37          	lui	s10,0xa8304
    P( local.D, local.A, local.B, local.C,  5, 12, 0x4787C62A );
4002d3d8:	014c8cb3          	add	s9,s9,s4
    P( local.C, local.D, local.A, local.B,  6, 17, 0xA8304613 );
4002d3dc:	0149c4b3          	xor	s1,s3,s4
4002d3e0:	613d0d13          	addi	s10,s10,1555 # a8304613 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xa8304614>
4002d3e4:	01a88d33          	add	s10,a7,s10
4002d3e8:	0194f4b3          	and	s1,s1,s9
4002d3ec:	015d0ab3          	add	s5,s10,s5
4002d3f0:	0134c4b3          	xor	s1,s1,s3
4002d3f4:	015484b3          	add	s1,s1,s5
4002d3f8:	00f4da93          	srli	s5,s1,0xf
4002d3fc:	01149493          	slli	s1,s1,0x11
4002d400:	009aeab3          	or	s5,s5,s1
    P( local.B, local.C, local.D, local.A,  7, 22, 0xFD469501 );
4002d404:	fd469d37          	lui	s10,0xfd469
    P( local.C, local.D, local.A, local.B,  6, 17, 0xA8304613 );
4002d408:	019a8ab3          	add	s5,s5,s9
    P( local.B, local.C, local.D, local.A,  7, 22, 0xFD469501 );
4002d40c:	019a44b3          	xor	s1,s4,s9
4002d410:	501d0d13          	addi	s10,s10,1281 # fd469501 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfd469502>
4002d414:	01a08d33          	add	s10,ra,s10
4002d418:	0154f4b3          	and	s1,s1,s5
4002d41c:	013d09b3          	add	s3,s10,s3
4002d420:	0144c4b3          	xor	s1,s1,s4
4002d424:	013484b3          	add	s1,s1,s3
4002d428:	00a4d993          	srli	s3,s1,0xa
4002d42c:	01649493          	slli	s1,s1,0x16
4002d430:	0099e9b3          	or	s3,s3,s1
    P( local.A, local.B, local.C, local.D,  8,  7, 0x698098D8 );
4002d434:	6980ad37          	lui	s10,0x6980a
    P( local.B, local.C, local.D, local.A,  7, 22, 0xFD469501 );
4002d438:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  8,  7, 0x698098D8 );
4002d43c:	015cc4b3          	xor	s1,s9,s5
4002d440:	8d8d0d13          	addi	s10,s10,-1832 # 698098d8 <__data_region_end+0x297c4e10>
4002d444:	01a30d33          	add	s10,t1,s10
4002d448:	0134f4b3          	and	s1,s1,s3
4002d44c:	014d0a33          	add	s4,s10,s4
4002d450:	0194c4b3          	xor	s1,s1,s9
4002d454:	014484b3          	add	s1,s1,s4
4002d458:	00749a13          	slli	s4,s1,0x7
4002d45c:	0194d493          	srli	s1,s1,0x19
4002d460:	009a6a33          	or	s4,s4,s1
    P( local.D, local.A, local.B, local.C,  9, 12, 0x8B44F7AF );
4002d464:	8b44fd37          	lui	s10,0x8b44f
    P( local.A, local.B, local.C, local.D,  8,  7, 0x698098D8 );
4002d468:	013a0a33          	add	s4,s4,s3
    P( local.D, local.A, local.B, local.C,  9, 12, 0x8B44F7AF );
4002d46c:	013ac4b3          	xor	s1,s5,s3
4002d470:	7afd0d13          	addi	s10,s10,1967 # 8b44f7af <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8b44f7b0>
4002d474:	01a78d33          	add	s10,a5,s10
4002d478:	0144f4b3          	and	s1,s1,s4
4002d47c:	019d0cb3          	add	s9,s10,s9
4002d480:	0154c4b3          	xor	s1,s1,s5
4002d484:	019484b3          	add	s1,s1,s9
4002d488:	00c49c93          	slli	s9,s1,0xc
4002d48c:	0144d493          	srli	s1,s1,0x14
4002d490:	009cecb3          	or	s9,s9,s1
    P( local.C, local.D, local.A, local.B, 10, 17, 0xFFFF5BB1 );
4002d494:	ffff6d37          	lui	s10,0xffff6
    P( local.D, local.A, local.B, local.C,  9, 12, 0x8B44F7AF );
4002d498:	014c8cb3          	add	s9,s9,s4
    P( local.C, local.D, local.A, local.B, 10, 17, 0xFFFF5BB1 );
4002d49c:	0149c4b3          	xor	s1,s3,s4
4002d4a0:	bb1d0d13          	addi	s10,s10,-1103 # ffff5bb1 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff5bb2>
4002d4a4:	01ae8d33          	add	s10,t4,s10
4002d4a8:	0194f4b3          	and	s1,s1,s9
4002d4ac:	015d0ab3          	add	s5,s10,s5
4002d4b0:	0134c4b3          	xor	s1,s1,s3
4002d4b4:	015484b3          	add	s1,s1,s5
4002d4b8:	00f4da93          	srli	s5,s1,0xf
4002d4bc:	01149493          	slli	s1,s1,0x11
4002d4c0:	009aeab3          	or	s5,s5,s1
    P( local.B, local.C, local.D, local.A, 11, 22, 0x895CD7BE );
4002d4c4:	895cdd37          	lui	s10,0x895cd
    P( local.C, local.D, local.A, local.B, 10, 17, 0xFFFF5BB1 );
4002d4c8:	019a8ab3          	add	s5,s5,s9
    P( local.B, local.C, local.D, local.A, 11, 22, 0x895CD7BE );
4002d4cc:	019a44b3          	xor	s1,s4,s9
4002d4d0:	7bed0d13          	addi	s10,s10,1982 # 895cd7be <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x895cd7bf>
4002d4d4:	01a68d33          	add	s10,a3,s10
4002d4d8:	0154f4b3          	and	s1,s1,s5
4002d4dc:	013d09b3          	add	s3,s10,s3
4002d4e0:	0144c4b3          	xor	s1,s1,s4
4002d4e4:	013484b3          	add	s1,s1,s3
4002d4e8:	00a4d993          	srli	s3,s1,0xa
4002d4ec:	01649493          	slli	s1,s1,0x16
4002d4f0:	0099e9b3          	or	s3,s3,s1
    P( local.A, local.B, local.C, local.D, 12,  7, 0x6B901122 );
4002d4f4:	6b901d37          	lui	s10,0x6b901
    P( local.B, local.C, local.D, local.A, 11, 22, 0x895CD7BE );
4002d4f8:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D, 12,  7, 0x6B901122 );
4002d4fc:	015cc4b3          	xor	s1,s9,s5
4002d500:	122d0d13          	addi	s10,s10,290 # 6b901122 <__data_region_end+0x2b8bc65a>
4002d504:	01af8d33          	add	s10,t6,s10
4002d508:	0134f4b3          	and	s1,s1,s3
4002d50c:	014d0a33          	add	s4,s10,s4
4002d510:	0194c4b3          	xor	s1,s1,s9
4002d514:	014484b3          	add	s1,s1,s4
4002d518:	00749a13          	slli	s4,s1,0x7
4002d51c:	0194d493          	srli	s1,s1,0x19
4002d520:	009a6a33          	or	s4,s4,s1
    P( local.D, local.A, local.B, local.C, 13, 12, 0xFD987193 );
4002d524:	fd987d37          	lui	s10,0xfd987
    P( local.A, local.B, local.C, local.D, 12,  7, 0x6B901122 );
4002d528:	013a0a33          	add	s4,s4,s3
    P( local.D, local.A, local.B, local.C, 13, 12, 0xFD987193 );
4002d52c:	013ac4b3          	xor	s1,s5,s3
4002d530:	193d0d13          	addi	s10,s10,403 # fd987193 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfd987194>
4002d534:	01a80d33          	add	s10,a6,s10
4002d538:	0144f4b3          	and	s1,s1,s4
4002d53c:	019d0cb3          	add	s9,s10,s9
4002d540:	0154c4b3          	xor	s1,s1,s5
4002d544:	019484b3          	add	s1,s1,s9
4002d548:	00c49d13          	slli	s10,s1,0xc
4002d54c:	0144d493          	srli	s1,s1,0x14
4002d550:	009d6d33          	or	s10,s10,s1
    P( local.C, local.D, local.A, local.B, 14, 17, 0xA679438E );
4002d554:	a6794cb7          	lui	s9,0xa6794
    P( local.D, local.A, local.B, local.C, 13, 12, 0xFD987193 );
4002d558:	014d0d33          	add	s10,s10,s4
    P( local.C, local.D, local.A, local.B, 14, 17, 0xA679438E );
4002d55c:	0149c4b3          	xor	s1,s3,s4
4002d560:	38ec8c93          	addi	s9,s9,910 # a679438e <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xa679438f>
4002d564:	01938cb3          	add	s9,t2,s9
4002d568:	01a4f4b3          	and	s1,s1,s10
4002d56c:	015c8ab3          	add	s5,s9,s5
4002d570:	0134c4b3          	xor	s1,s1,s3
4002d574:	015484b3          	add	s1,s1,s5
4002d578:	00f4da93          	srli	s5,s1,0xf
4002d57c:	01149493          	slli	s1,s1,0x11
4002d580:	009aeab3          	or	s5,s5,s1
    P( local.B, local.C, local.D, local.A, 15, 22, 0x49B40821 );
4002d584:	49b41cb7          	lui	s9,0x49b41
    P( local.C, local.D, local.A, local.B, 14, 17, 0xA679438E );
4002d588:	01aa8ab3          	add	s5,s5,s10
    P( local.B, local.C, local.D, local.A, 15, 22, 0x49B40821 );
4002d58c:	01aa44b3          	xor	s1,s4,s10
4002d590:	821c8c93          	addi	s9,s9,-2015 # 49b40821 <__data_region_end+0x9afbd59>
4002d594:	01958cb3          	add	s9,a1,s9
4002d598:	0154f4b3          	and	s1,s1,s5
4002d59c:	013c89b3          	add	s3,s9,s3
4002d5a0:	0144c4b3          	xor	s1,s1,s4
4002d5a4:	013484b3          	add	s1,s1,s3
4002d5a8:	00a4d993          	srli	s3,s1,0xa
4002d5ac:	01649493          	slli	s1,s1,0x16
4002d5b0:	0099e9b3          	or	s3,s3,s1
4002d5b4:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  1,  5, 0xF61E2562 );
4002d5b8:	f61e2cb7          	lui	s9,0xf61e2
4002d5bc:	013ac4b3          	xor	s1,s5,s3
4002d5c0:	562c8c93          	addi	s9,s9,1378 # f61e2562 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf61e2563>
4002d5c4:	019e0cb3          	add	s9,t3,s9
4002d5c8:	01a4f4b3          	and	s1,s1,s10
4002d5cc:	014c8a33          	add	s4,s9,s4
4002d5d0:	0154c4b3          	xor	s1,s1,s5
4002d5d4:	014484b3          	add	s1,s1,s4
4002d5d8:	00549c93          	slli	s9,s1,0x5
4002d5dc:	01b4d493          	srli	s1,s1,0x1b
4002d5e0:	009cecb3          	or	s9,s9,s1
4002d5e4:	013c8cb3          	add	s9,s9,s3
    P( local.D, local.A, local.B, local.C,  6,  9, 0xC040B340 );
4002d5e8:	c040ba37          	lui	s4,0xc040b
4002d5ec:	0199c4b3          	xor	s1,s3,s9
4002d5f0:	340a0a13          	addi	s4,s4,832 # c040b340 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xc040b341>
4002d5f4:	0154f4b3          	and	s1,s1,s5
4002d5f8:	01488a33          	add	s4,a7,s4
4002d5fc:	01aa0a33          	add	s4,s4,s10
4002d600:	0134c4b3          	xor	s1,s1,s3
4002d604:	014484b3          	add	s1,s1,s4
4002d608:	00949a13          	slli	s4,s1,0x9
4002d60c:	0174d493          	srli	s1,s1,0x17
4002d610:	009a6a33          	or	s4,s4,s1
4002d614:	019a0a33          	add	s4,s4,s9
    P( local.C, local.D, local.A, local.B, 11, 14, 0x265E5A51 );
4002d618:	265e6d37          	lui	s10,0x265e6
4002d61c:	014cc4b3          	xor	s1,s9,s4
4002d620:	a51d0d13          	addi	s10,s10,-1455 # 265e5a51 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x20687951>
4002d624:	01a68d33          	add	s10,a3,s10
4002d628:	0134f4b3          	and	s1,s1,s3
4002d62c:	015d0ab3          	add	s5,s10,s5
4002d630:	0194c4b3          	xor	s1,s1,s9
4002d634:	015484b3          	add	s1,s1,s5
4002d638:	00e49a93          	slli	s5,s1,0xe
4002d63c:	0124d493          	srli	s1,s1,0x12
4002d640:	009aeab3          	or	s5,s5,s1
4002d644:	014a8ab3          	add	s5,s5,s4
    P( local.B, local.C, local.D, local.A,  0, 20, 0xE9B6C7AA );
4002d648:	e9b6cd37          	lui	s10,0xe9b6c
4002d64c:	015a44b3          	xor	s1,s4,s5
4002d650:	7aad0d13          	addi	s10,s10,1962 # e9b6c7aa <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe9b6c7ab>
4002d654:	01a40d33          	add	s10,s0,s10
4002d658:	0194f4b3          	and	s1,s1,s9
4002d65c:	013d09b3          	add	s3,s10,s3
4002d660:	0144c4b3          	xor	s1,s1,s4
4002d664:	013484b3          	add	s1,s1,s3
4002d668:	00c4d993          	srli	s3,s1,0xc
4002d66c:	01449493          	slli	s1,s1,0x14
4002d670:	0099e9b3          	or	s3,s3,s1
4002d674:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  5,  5, 0xD62F105D );
4002d678:	d62f1d37          	lui	s10,0xd62f1
4002d67c:	013ac4b3          	xor	s1,s5,s3
4002d680:	05dd0d13          	addi	s10,s10,93 # d62f105d <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd62f105e>
4002d684:	01a28d33          	add	s10,t0,s10
4002d688:	0144f4b3          	and	s1,s1,s4
4002d68c:	019d0cb3          	add	s9,s10,s9
4002d690:	0154c4b3          	xor	s1,s1,s5
4002d694:	019484b3          	add	s1,s1,s9
4002d698:	00549c93          	slli	s9,s1,0x5
4002d69c:	01b4d493          	srli	s1,s1,0x1b
4002d6a0:	009cecb3          	or	s9,s9,s1
4002d6a4:	013c8cb3          	add	s9,s9,s3
    P( local.D, local.A, local.B, local.C, 10,  9, 0x02441453 );
4002d6a8:	02441d37          	lui	s10,0x2441
4002d6ac:	0199c4b3          	xor	s1,s3,s9
4002d6b0:	453d0d13          	addi	s10,s10,1107 # 2441453 <__rom_region_size+0x2408497>
4002d6b4:	01ae8d33          	add	s10,t4,s10
4002d6b8:	0154f4b3          	and	s1,s1,s5
4002d6bc:	014d0a33          	add	s4,s10,s4
4002d6c0:	0134c4b3          	xor	s1,s1,s3
4002d6c4:	014484b3          	add	s1,s1,s4
4002d6c8:	00949a13          	slli	s4,s1,0x9
4002d6cc:	0174d493          	srli	s1,s1,0x17
4002d6d0:	009a6a33          	or	s4,s4,s1
4002d6d4:	019a0a33          	add	s4,s4,s9
    P( local.C, local.D, local.A, local.B, 15, 14, 0xD8A1E681 );
4002d6d8:	d8a1ed37          	lui	s10,0xd8a1e
4002d6dc:	014cc4b3          	xor	s1,s9,s4
4002d6e0:	681d0d13          	addi	s10,s10,1665 # d8a1e681 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd8a1e682>
4002d6e4:	01a58d33          	add	s10,a1,s10
4002d6e8:	0134f4b3          	and	s1,s1,s3
4002d6ec:	015d0ab3          	add	s5,s10,s5
4002d6f0:	0194c4b3          	xor	s1,s1,s9
4002d6f4:	015484b3          	add	s1,s1,s5
4002d6f8:	00e49a93          	slli	s5,s1,0xe
4002d6fc:	0124d493          	srli	s1,s1,0x12
4002d700:	009aeab3          	or	s5,s5,s1
4002d704:	014a8ab3          	add	s5,s5,s4
    P( local.B, local.C, local.D, local.A,  4, 20, 0xE7D3FBC8 );
4002d708:	e7d40d37          	lui	s10,0xe7d40
4002d70c:	015a44b3          	xor	s1,s4,s5
4002d710:	bc8d0d13          	addi	s10,s10,-1080 # e7d3fbc8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe7d3fbc9>
4002d714:	01a60d33          	add	s10,a2,s10
4002d718:	0194f4b3          	and	s1,s1,s9
4002d71c:	013d09b3          	add	s3,s10,s3
4002d720:	0144c4b3          	xor	s1,s1,s4
4002d724:	013484b3          	add	s1,s1,s3
4002d728:	00c4d993          	srli	s3,s1,0xc
4002d72c:	01449493          	slli	s1,s1,0x14
4002d730:	0099e9b3          	or	s3,s3,s1
4002d734:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  9,  5, 0x21E1CDE6 );
4002d738:	21e1dd37          	lui	s10,0x21e1d
4002d73c:	013ac4b3          	xor	s1,s5,s3
4002d740:	de6d0d13          	addi	s10,s10,-538 # 21e1cde6 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1bebece6>
4002d744:	01a78d33          	add	s10,a5,s10
4002d748:	0144f4b3          	and	s1,s1,s4
4002d74c:	019d0cb3          	add	s9,s10,s9
4002d750:	0154c4b3          	xor	s1,s1,s5
4002d754:	019484b3          	add	s1,s1,s9
4002d758:	00549c93          	slli	s9,s1,0x5
4002d75c:	01b4d493          	srli	s1,s1,0x1b
4002d760:	009cecb3          	or	s9,s9,s1
4002d764:	013c8cb3          	add	s9,s9,s3
    P( local.D, local.A, local.B, local.C, 14,  9, 0xC33707D6 );
4002d768:	c3370d37          	lui	s10,0xc3370
4002d76c:	0199c4b3          	xor	s1,s3,s9
4002d770:	7d6d0d13          	addi	s10,s10,2006 # c33707d6 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xc33707d7>
4002d774:	01a38d33          	add	s10,t2,s10
4002d778:	0154f4b3          	and	s1,s1,s5
4002d77c:	014d0a33          	add	s4,s10,s4
4002d780:	0134c4b3          	xor	s1,s1,s3
4002d784:	014484b3          	add	s1,s1,s4
4002d788:	00949a13          	slli	s4,s1,0x9
4002d78c:	0174d493          	srli	s1,s1,0x17
4002d790:	009a6a33          	or	s4,s4,s1
4002d794:	019a0a33          	add	s4,s4,s9
    P( local.C, local.D, local.A, local.B,  3, 14, 0xF4D50D87 );
4002d798:	f4d51d37          	lui	s10,0xf4d51
4002d79c:	014cc4b3          	xor	s1,s9,s4
4002d7a0:	d87d0d13          	addi	s10,s10,-633 # f4d50d87 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf4d50d88>
4002d7a4:	01af0d33          	add	s10,t5,s10
4002d7a8:	0134f4b3          	and	s1,s1,s3
4002d7ac:	015d0ab3          	add	s5,s10,s5
4002d7b0:	0194c4b3          	xor	s1,s1,s9
4002d7b4:	015484b3          	add	s1,s1,s5
4002d7b8:	00e49a93          	slli	s5,s1,0xe
4002d7bc:	0124d493          	srli	s1,s1,0x12
4002d7c0:	009aeab3          	or	s5,s5,s1
4002d7c4:	014a8ab3          	add	s5,s5,s4
    P( local.B, local.C, local.D, local.A,  8, 20, 0x455A14ED );
4002d7c8:	455a1d37          	lui	s10,0x455a1
4002d7cc:	015a44b3          	xor	s1,s4,s5
4002d7d0:	4edd0d13          	addi	s10,s10,1261 # 455a14ed <__data_region_end+0x555ca25>
4002d7d4:	01a30d33          	add	s10,t1,s10
4002d7d8:	0194f4b3          	and	s1,s1,s9
4002d7dc:	013d09b3          	add	s3,s10,s3
4002d7e0:	0144c4b3          	xor	s1,s1,s4
4002d7e4:	013484b3          	add	s1,s1,s3
4002d7e8:	00c4d993          	srli	s3,s1,0xc
4002d7ec:	01449493          	slli	s1,s1,0x14
4002d7f0:	0099e4b3          	or	s1,s3,s1
4002d7f4:	015484b3          	add	s1,s1,s5
    P( local.A, local.B, local.C, local.D, 13,  5, 0xA9E3E905 );
4002d7f8:	a9e3fd37          	lui	s10,0xa9e3f
4002d7fc:	009ac9b3          	xor	s3,s5,s1
4002d800:	905d0d13          	addi	s10,s10,-1787 # a9e3e905 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xa9e3e906>
4002d804:	01a80d33          	add	s10,a6,s10
4002d808:	0149f9b3          	and	s3,s3,s4
4002d80c:	019d0cb3          	add	s9,s10,s9
4002d810:	0159c9b3          	xor	s3,s3,s5
4002d814:	019989b3          	add	s3,s3,s9
4002d818:	00599d13          	slli	s10,s3,0x5
4002d81c:	01b9d993          	srli	s3,s3,0x1b
4002d820:	013d6d33          	or	s10,s10,s3
4002d824:	009d0d33          	add	s10,s10,s1
    P( local.D, local.A, local.B, local.C,  2,  9, 0xFCEFA3F8 );
4002d828:	fcefacb7          	lui	s9,0xfcefa
4002d82c:	01a4c9b3          	xor	s3,s1,s10
4002d830:	3f8c8c93          	addi	s9,s9,1016 # fcefa3f8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfcefa3f9>
4002d834:	01970cb3          	add	s9,a4,s9
4002d838:	0159f9b3          	and	s3,s3,s5
4002d83c:	014c8a33          	add	s4,s9,s4
4002d840:	0099c9b3          	xor	s3,s3,s1
4002d844:	014989b3          	add	s3,s3,s4
4002d848:	00999a13          	slli	s4,s3,0x9
4002d84c:	0179d993          	srli	s3,s3,0x17
4002d850:	013a6a33          	or	s4,s4,s3
4002d854:	01aa0a33          	add	s4,s4,s10
    P( local.C, local.D, local.A, local.B,  7, 14, 0x676F02D9 );
4002d858:	676f0cb7          	lui	s9,0x676f0
4002d85c:	014d49b3          	xor	s3,s10,s4
4002d860:	2d9c8c93          	addi	s9,s9,729 # 676f02d9 <__data_region_end+0x276ab811>
4002d864:	01908cb3          	add	s9,ra,s9
4002d868:	0099f9b3          	and	s3,s3,s1
4002d86c:	015c8ab3          	add	s5,s9,s5
4002d870:	01a9c9b3          	xor	s3,s3,s10
4002d874:	015989b3          	add	s3,s3,s5
4002d878:	00e99a93          	slli	s5,s3,0xe
4002d87c:	0129d993          	srli	s3,s3,0x12
4002d880:	013aeab3          	or	s5,s5,s3
4002d884:	014a8ab3          	add	s5,s5,s4
    P( local.B, local.C, local.D, local.A, 12, 20, 0x8D2A4C8A );
4002d888:	015a4cb3          	xor	s9,s4,s5
4002d88c:	019d79b3          	and	s3,s10,s9
4002d890:	009d84b3          	add	s1,s11,s1
4002d894:	0149c9b3          	xor	s3,s3,s4
4002d898:	009989b3          	add	s3,s3,s1
4002d89c:	00c9d493          	srli	s1,s3,0xc
4002d8a0:	01499993          	slli	s3,s3,0x14
4002d8a4:	0134e9b3          	or	s3,s1,s3

#undef F

#define F(x,y,z) ((x) ^ (y) ^ (z))

    P( local.A, local.B, local.C, local.D,  5,  4, 0xFFFA3942 );
4002d8a8:	fffa44b7          	lui	s1,0xfffa4
4002d8ac:	94248493          	addi	s1,s1,-1726 # fffa3942 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfffa3943>
    P( local.B, local.C, local.D, local.A, 12, 20, 0x8D2A4C8A );
4002d8b0:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  5,  4, 0xFFFA3942 );
4002d8b4:	009284b3          	add	s1,t0,s1
4002d8b8:	013cccb3          	xor	s9,s9,s3
4002d8bc:	01a484b3          	add	s1,s1,s10
4002d8c0:	019484b3          	add	s1,s1,s9
4002d8c4:	00449c93          	slli	s9,s1,0x4
    P( local.D, local.A, local.B, local.C,  8, 11, 0x8771F681 );
4002d8c8:	8771fd37          	lui	s10,0x8771f
    P( local.A, local.B, local.C, local.D,  5,  4, 0xFFFA3942 );
4002d8cc:	01c4d493          	srli	s1,s1,0x1c
4002d8d0:	009ce4b3          	or	s1,s9,s1
    P( local.D, local.A, local.B, local.C,  8, 11, 0x8771F681 );
4002d8d4:	681d0d13          	addi	s10,s10,1665 # 8771f681 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8771f682>
    P( local.A, local.B, local.C, local.D,  5,  4, 0xFFFA3942 );
4002d8d8:	013484b3          	add	s1,s1,s3
    P( local.D, local.A, local.B, local.C,  8, 11, 0x8771F681 );
4002d8dc:	013accb3          	xor	s9,s5,s3
4002d8e0:	01a30d33          	add	s10,t1,s10
4002d8e4:	014d0a33          	add	s4,s10,s4
4002d8e8:	009cccb3          	xor	s9,s9,s1
4002d8ec:	014c8cb3          	add	s9,s9,s4
4002d8f0:	00bc9a13          	slli	s4,s9,0xb
    P( local.C, local.D, local.A, local.B, 11, 16, 0x6D9D6122 );
4002d8f4:	6d9d6d37          	lui	s10,0x6d9d6
    P( local.D, local.A, local.B, local.C,  8, 11, 0x8771F681 );
4002d8f8:	015cdc93          	srli	s9,s9,0x15
4002d8fc:	019a6cb3          	or	s9,s4,s9
    P( local.C, local.D, local.A, local.B, 11, 16, 0x6D9D6122 );
4002d900:	122d0d13          	addi	s10,s10,290 # 6d9d6122 <__data_region_end+0x2d99165a>
    P( local.D, local.A, local.B, local.C,  8, 11, 0x8771F681 );
4002d904:	009c8cb3          	add	s9,s9,s1
    P( local.C, local.D, local.A, local.B, 11, 16, 0x6D9D6122 );
4002d908:	0099ca33          	xor	s4,s3,s1
4002d90c:	01a68d33          	add	s10,a3,s10
4002d910:	015d0ab3          	add	s5,s10,s5
4002d914:	019a4a33          	xor	s4,s4,s9
4002d918:	015a0a33          	add	s4,s4,s5
4002d91c:	010a1a93          	slli	s5,s4,0x10
    P( local.B, local.C, local.D, local.A, 14, 23, 0xFDE5380C );
4002d920:	fde54d37          	lui	s10,0xfde54
    P( local.C, local.D, local.A, local.B, 11, 16, 0x6D9D6122 );
4002d924:	010a5a13          	srli	s4,s4,0x10
4002d928:	014aea33          	or	s4,s5,s4
    P( local.B, local.C, local.D, local.A, 14, 23, 0xFDE5380C );
4002d92c:	80cd0d13          	addi	s10,s10,-2036 # fde5380c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfde5380d>
    P( local.C, local.D, local.A, local.B, 11, 16, 0x6D9D6122 );
4002d930:	019a0a33          	add	s4,s4,s9
    P( local.B, local.C, local.D, local.A, 14, 23, 0xFDE5380C );
4002d934:	0194cab3          	xor	s5,s1,s9
4002d938:	01a38d33          	add	s10,t2,s10
4002d93c:	013d09b3          	add	s3,s10,s3
4002d940:	014acab3          	xor	s5,s5,s4
4002d944:	013a8ab3          	add	s5,s5,s3
4002d948:	009ad993          	srli	s3,s5,0x9
    P( local.A, local.B, local.C, local.D,  1,  4, 0xA4BEEA44 );
4002d94c:	a4befd37          	lui	s10,0xa4bef
    P( local.B, local.C, local.D, local.A, 14, 23, 0xFDE5380C );
4002d950:	017a9a93          	slli	s5,s5,0x17
4002d954:	0159e9b3          	or	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  1,  4, 0xA4BEEA44 );
4002d958:	a44d0d13          	addi	s10,s10,-1468 # a4beea44 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xa4beea45>
    P( local.B, local.C, local.D, local.A, 14, 23, 0xFDE5380C );
4002d95c:	014989b3          	add	s3,s3,s4
    P( local.A, local.B, local.C, local.D,  1,  4, 0xA4BEEA44 );
4002d960:	014ccab3          	xor	s5,s9,s4
4002d964:	01ae0d33          	add	s10,t3,s10
4002d968:	009d04b3          	add	s1,s10,s1
4002d96c:	013acab3          	xor	s5,s5,s3
4002d970:	009a8ab3          	add	s5,s5,s1
4002d974:	004a9493          	slli	s1,s5,0x4
    P( local.D, local.A, local.B, local.C,  4, 11, 0x4BDECFA9 );
4002d978:	4bdedd37          	lui	s10,0x4bded
    P( local.A, local.B, local.C, local.D,  1,  4, 0xA4BEEA44 );
4002d97c:	01cada93          	srli	s5,s5,0x1c
4002d980:	0154e4b3          	or	s1,s1,s5
    P( local.D, local.A, local.B, local.C,  4, 11, 0x4BDECFA9 );
4002d984:	fa9d0d13          	addi	s10,s10,-87 # 4bdecfa9 <__data_region_end+0xbda84e1>
    P( local.A, local.B, local.C, local.D,  1,  4, 0xA4BEEA44 );
4002d988:	013484b3          	add	s1,s1,s3
    P( local.D, local.A, local.B, local.C,  4, 11, 0x4BDECFA9 );
4002d98c:	013a4ab3          	xor	s5,s4,s3
4002d990:	01a60d33          	add	s10,a2,s10
4002d994:	019d0cb3          	add	s9,s10,s9
4002d998:	009acab3          	xor	s5,s5,s1
4002d99c:	019a8ab3          	add	s5,s5,s9
4002d9a0:	00ba9c93          	slli	s9,s5,0xb
    P( local.C, local.D, local.A, local.B,  7, 16, 0xF6BB4B60 );
4002d9a4:	f6bb5d37          	lui	s10,0xf6bb5
    P( local.D, local.A, local.B, local.C,  4, 11, 0x4BDECFA9 );
4002d9a8:	015ada93          	srli	s5,s5,0x15
4002d9ac:	015ceab3          	or	s5,s9,s5
    P( local.C, local.D, local.A, local.B,  7, 16, 0xF6BB4B60 );
4002d9b0:	b60d0d13          	addi	s10,s10,-1184 # f6bb4b60 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf6bb4b61>
    P( local.D, local.A, local.B, local.C,  4, 11, 0x4BDECFA9 );
4002d9b4:	009a8ab3          	add	s5,s5,s1
    P( local.C, local.D, local.A, local.B,  7, 16, 0xF6BB4B60 );
4002d9b8:	0099ccb3          	xor	s9,s3,s1
4002d9bc:	01a08d33          	add	s10,ra,s10
4002d9c0:	014d0a33          	add	s4,s10,s4
4002d9c4:	015cccb3          	xor	s9,s9,s5
4002d9c8:	014c8cb3          	add	s9,s9,s4
4002d9cc:	010c9a13          	slli	s4,s9,0x10
    P( local.B, local.C, local.D, local.A, 10, 23, 0xBEBFBC70 );
4002d9d0:	bebfcd37          	lui	s10,0xbebfc
    P( local.C, local.D, local.A, local.B,  7, 16, 0xF6BB4B60 );
4002d9d4:	010cdc93          	srli	s9,s9,0x10
4002d9d8:	019a6a33          	or	s4,s4,s9
    P( local.B, local.C, local.D, local.A, 10, 23, 0xBEBFBC70 );
4002d9dc:	c70d0d13          	addi	s10,s10,-912 # bebfbc70 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xbebfbc71>
    P( local.C, local.D, local.A, local.B,  7, 16, 0xF6BB4B60 );
4002d9e0:	015a0a33          	add	s4,s4,s5
    P( local.B, local.C, local.D, local.A, 10, 23, 0xBEBFBC70 );
4002d9e4:	0154ccb3          	xor	s9,s1,s5
4002d9e8:	01ae8d33          	add	s10,t4,s10
4002d9ec:	013d09b3          	add	s3,s10,s3
4002d9f0:	014cccb3          	xor	s9,s9,s4
4002d9f4:	013c8cb3          	add	s9,s9,s3
4002d9f8:	009cd993          	srli	s3,s9,0x9
    P( local.A, local.B, local.C, local.D, 13,  4, 0x289B7EC6 );
4002d9fc:	289b8d37          	lui	s10,0x289b8
    P( local.B, local.C, local.D, local.A, 10, 23, 0xBEBFBC70 );
4002da00:	017c9c93          	slli	s9,s9,0x17
4002da04:	0199e9b3          	or	s3,s3,s9
    P( local.A, local.B, local.C, local.D, 13,  4, 0x289B7EC6 );
4002da08:	ec6d0d13          	addi	s10,s10,-314 # 289b7ec6 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x22a59dc6>
    P( local.B, local.C, local.D, local.A, 10, 23, 0xBEBFBC70 );
4002da0c:	014989b3          	add	s3,s3,s4
    P( local.A, local.B, local.C, local.D, 13,  4, 0x289B7EC6 );
4002da10:	014accb3          	xor	s9,s5,s4
4002da14:	01a80d33          	add	s10,a6,s10
4002da18:	009d04b3          	add	s1,s10,s1
4002da1c:	013cccb3          	xor	s9,s9,s3
4002da20:	009c8cb3          	add	s9,s9,s1
4002da24:	004c9493          	slli	s1,s9,0x4
    P( local.D, local.A, local.B, local.C,  0, 11, 0xEAA127FA );
4002da28:	eaa12d37          	lui	s10,0xeaa12
    P( local.A, local.B, local.C, local.D, 13,  4, 0x289B7EC6 );
4002da2c:	01ccdc93          	srli	s9,s9,0x1c
4002da30:	0194e4b3          	or	s1,s1,s9
    P( local.D, local.A, local.B, local.C,  0, 11, 0xEAA127FA );
4002da34:	7fad0d13          	addi	s10,s10,2042 # eaa127fa <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xeaa127fb>
    P( local.A, local.B, local.C, local.D, 13,  4, 0x289B7EC6 );
4002da38:	013484b3          	add	s1,s1,s3
    P( local.D, local.A, local.B, local.C,  0, 11, 0xEAA127FA );
4002da3c:	013a4cb3          	xor	s9,s4,s3
4002da40:	01a40d33          	add	s10,s0,s10
4002da44:	015d0ab3          	add	s5,s10,s5
4002da48:	009cccb3          	xor	s9,s9,s1
4002da4c:	015c8cb3          	add	s9,s9,s5
4002da50:	00bc9a93          	slli	s5,s9,0xb
    P( local.C, local.D, local.A, local.B,  3, 16, 0xD4EF3085 );
4002da54:	d4ef3d37          	lui	s10,0xd4ef3
    P( local.D, local.A, local.B, local.C,  0, 11, 0xEAA127FA );
4002da58:	015cdc93          	srli	s9,s9,0x15
4002da5c:	019aeab3          	or	s5,s5,s9
    P( local.C, local.D, local.A, local.B,  3, 16, 0xD4EF3085 );
4002da60:	085d0d13          	addi	s10,s10,133 # d4ef3085 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd4ef3086>
    P( local.D, local.A, local.B, local.C,  0, 11, 0xEAA127FA );
4002da64:	009a8ab3          	add	s5,s5,s1
    P( local.C, local.D, local.A, local.B,  3, 16, 0xD4EF3085 );
4002da68:	0099ccb3          	xor	s9,s3,s1
4002da6c:	01af0d33          	add	s10,t5,s10
4002da70:	014d0a33          	add	s4,s10,s4
4002da74:	015cccb3          	xor	s9,s9,s5
4002da78:	014c8cb3          	add	s9,s9,s4
4002da7c:	010c9a13          	slli	s4,s9,0x10
    P( local.B, local.C, local.D, local.A,  6, 23, 0x04881D05 );
4002da80:	04882d37          	lui	s10,0x4882
    P( local.C, local.D, local.A, local.B,  3, 16, 0xD4EF3085 );
4002da84:	010cdc93          	srli	s9,s9,0x10
4002da88:	019a6a33          	or	s4,s4,s9
    P( local.B, local.C, local.D, local.A,  6, 23, 0x04881D05 );
4002da8c:	d05d0d13          	addi	s10,s10,-763 # 4881d05 <__rom_region_size+0x4848d49>
    P( local.C, local.D, local.A, local.B,  3, 16, 0xD4EF3085 );
4002da90:	015a0a33          	add	s4,s4,s5
    P( local.B, local.C, local.D, local.A,  6, 23, 0x04881D05 );
4002da94:	0154ccb3          	xor	s9,s1,s5
4002da98:	01a88d33          	add	s10,a7,s10
4002da9c:	013d09b3          	add	s3,s10,s3
4002daa0:	014cccb3          	xor	s9,s9,s4
4002daa4:	013c8cb3          	add	s9,s9,s3
4002daa8:	009cd993          	srli	s3,s9,0x9
    P( local.A, local.B, local.C, local.D,  9,  4, 0xD9D4D039 );
4002daac:	d9d4dd37          	lui	s10,0xd9d4d
    P( local.B, local.C, local.D, local.A,  6, 23, 0x04881D05 );
4002dab0:	017c9c93          	slli	s9,s9,0x17
4002dab4:	0199e9b3          	or	s3,s3,s9
    P( local.A, local.B, local.C, local.D,  9,  4, 0xD9D4D039 );
4002dab8:	039d0d13          	addi	s10,s10,57 # d9d4d039 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd9d4d03a>
    P( local.B, local.C, local.D, local.A,  6, 23, 0x04881D05 );
4002dabc:	014989b3          	add	s3,s3,s4
    P( local.A, local.B, local.C, local.D,  9,  4, 0xD9D4D039 );
4002dac0:	014accb3          	xor	s9,s5,s4
4002dac4:	01a78d33          	add	s10,a5,s10
4002dac8:	009d04b3          	add	s1,s10,s1
4002dacc:	013cccb3          	xor	s9,s9,s3
4002dad0:	009c8cb3          	add	s9,s9,s1
4002dad4:	004c9493          	slli	s1,s9,0x4
    P( local.D, local.A, local.B, local.C, 12, 11, 0xE6DB99E5 );
4002dad8:	e6dbad37          	lui	s10,0xe6dba
    P( local.A, local.B, local.C, local.D,  9,  4, 0xD9D4D039 );
4002dadc:	01ccdc93          	srli	s9,s9,0x1c
4002dae0:	0194e4b3          	or	s1,s1,s9
    P( local.D, local.A, local.B, local.C, 12, 11, 0xE6DB99E5 );
4002dae4:	9e5d0d13          	addi	s10,s10,-1563 # e6db99e5 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe6db99e6>
    P( local.A, local.B, local.C, local.D,  9,  4, 0xD9D4D039 );
4002dae8:	013484b3          	add	s1,s1,s3
    P( local.D, local.A, local.B, local.C, 12, 11, 0xE6DB99E5 );
4002daec:	013a4cb3          	xor	s9,s4,s3
4002daf0:	01af8d33          	add	s10,t6,s10
4002daf4:	015d0ab3          	add	s5,s10,s5
4002daf8:	009cccb3          	xor	s9,s9,s1
4002dafc:	015c8cb3          	add	s9,s9,s5
4002db00:	00bc9a93          	slli	s5,s9,0xb
    P( local.C, local.D, local.A, local.B, 15, 16, 0x1FA27CF8 );
4002db04:	1fa28d37          	lui	s10,0x1fa28
    P( local.D, local.A, local.B, local.C, 12, 11, 0xE6DB99E5 );
4002db08:	015cdc93          	srli	s9,s9,0x15
4002db0c:	019aeab3          	or	s5,s5,s9
    P( local.C, local.D, local.A, local.B, 15, 16, 0x1FA27CF8 );
4002db10:	cf8d0d13          	addi	s10,s10,-776 # 1fa27cf8 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x19ac9bf8>
    P( local.D, local.A, local.B, local.C, 12, 11, 0xE6DB99E5 );
4002db14:	009a8ab3          	add	s5,s5,s1
    P( local.C, local.D, local.A, local.B, 15, 16, 0x1FA27CF8 );
4002db18:	0099ccb3          	xor	s9,s3,s1
4002db1c:	01a58d33          	add	s10,a1,s10
4002db20:	014d0a33          	add	s4,s10,s4
4002db24:	015cccb3          	xor	s9,s9,s5
4002db28:	014c8cb3          	add	s9,s9,s4
4002db2c:	010c9a13          	slli	s4,s9,0x10
    P( local.B, local.C, local.D, local.A,  2, 23, 0xC4AC5665 );
4002db30:	c4ac5d37          	lui	s10,0xc4ac5
    P( local.C, local.D, local.A, local.B, 15, 16, 0x1FA27CF8 );
4002db34:	010cdc93          	srli	s9,s9,0x10
4002db38:	019a6a33          	or	s4,s4,s9
    P( local.B, local.C, local.D, local.A,  2, 23, 0xC4AC5665 );
4002db3c:	665d0d13          	addi	s10,s10,1637 # c4ac5665 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xc4ac5666>
    P( local.C, local.D, local.A, local.B, 15, 16, 0x1FA27CF8 );
4002db40:	015a0a33          	add	s4,s4,s5
    P( local.B, local.C, local.D, local.A,  2, 23, 0xC4AC5665 );
4002db44:	0154ccb3          	xor	s9,s1,s5
4002db48:	01a70d33          	add	s10,a4,s10
4002db4c:	013d09b3          	add	s3,s10,s3
4002db50:	014cccb3          	xor	s9,s9,s4
4002db54:	013c8cb3          	add	s9,s9,s3
4002db58:	009cd993          	srli	s3,s9,0x9
4002db5c:	017c9c93          	slli	s9,s9,0x17
4002db60:	0199e9b3          	or	s3,s3,s9

#undef F

#define F(x,y,z) ((y) ^ ((x) | ~(z)))

    P( local.A, local.B, local.C, local.D,  0,  6, 0xF4292244 );
4002db64:	f4292d37          	lui	s10,0xf4292
    P( local.B, local.C, local.D, local.A,  2, 23, 0xC4AC5665 );
4002db68:	014989b3          	add	s3,s3,s4
    P( local.A, local.B, local.C, local.D,  0,  6, 0xF4292244 );
4002db6c:	fffacc93          	not	s9,s5
4002db70:	244d0d13          	addi	s10,s10,580 # f4292244 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf4292245>
4002db74:	013cecb3          	or	s9,s9,s3
4002db78:	01a40433          	add	s0,s0,s10
4002db7c:	014cccb3          	xor	s9,s9,s4
4002db80:	00940433          	add	s0,s0,s1
4002db84:	008c8433          	add	s0,s9,s0
4002db88:	00641493          	slli	s1,s0,0x6
4002db8c:	01a45413          	srli	s0,s0,0x1a
4002db90:	0084e4b3          	or	s1,s1,s0
    P( local.D, local.A, local.B, local.C,  7, 10, 0x432AFF97 );
4002db94:	432b0cb7          	lui	s9,0x432b0
    P( local.A, local.B, local.C, local.D,  0,  6, 0xF4292244 );
4002db98:	013484b3          	add	s1,s1,s3
    P( local.D, local.A, local.B, local.C,  7, 10, 0x432AFF97 );
4002db9c:	fffa4413          	not	s0,s4
4002dba0:	f97c8c93          	addi	s9,s9,-105 # 432aff97 <__data_region_end+0x326b4cf>
4002dba4:	00946433          	or	s0,s0,s1
4002dba8:	019080b3          	add	ra,ra,s9
4002dbac:	01344433          	xor	s0,s0,s3
4002dbb0:	015080b3          	add	ra,ra,s5
4002dbb4:	001400b3          	add	ra,s0,ra
4002dbb8:	00a09413          	slli	s0,ra,0xa
4002dbbc:	0160d093          	srli	ra,ra,0x16
4002dbc0:	00146433          	or	s0,s0,ra
    P( local.C, local.D, local.A, local.B, 14, 15, 0xAB9423A7 );
4002dbc4:	ab942ab7          	lui	s5,0xab942
    P( local.D, local.A, local.B, local.C,  7, 10, 0x432AFF97 );
4002dbc8:	00940433          	add	s0,s0,s1
    P( local.C, local.D, local.A, local.B, 14, 15, 0xAB9423A7 );
4002dbcc:	fff9c093          	not	ra,s3
4002dbd0:	3a7a8a93          	addi	s5,s5,935 # ab9423a7 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xab9423a8>
4002dbd4:	0080e0b3          	or	ra,ra,s0
4002dbd8:	015383b3          	add	t2,t2,s5
4002dbdc:	0090c0b3          	xor	ra,ra,s1
4002dbe0:	014383b3          	add	t2,t2,s4
4002dbe4:	007083b3          	add	t2,ra,t2
4002dbe8:	00f39093          	slli	ra,t2,0xf
4002dbec:	0113d393          	srli	t2,t2,0x11
4002dbf0:	0070e0b3          	or	ra,ra,t2
    P( local.B, local.C, local.D, local.A,  5, 21, 0xFC93A039 );
4002dbf4:	fc93aa37          	lui	s4,0xfc93a
    P( local.C, local.D, local.A, local.B, 14, 15, 0xAB9423A7 );
4002dbf8:	008080b3          	add	ra,ra,s0
    P( local.B, local.C, local.D, local.A,  5, 21, 0xFC93A039 );
4002dbfc:	fff4c393          	not	t2,s1
4002dc00:	039a0a13          	addi	s4,s4,57 # fc93a039 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfc93a03a>
4002dc04:	0013e3b3          	or	t2,t2,ra
4002dc08:	014282b3          	add	t0,t0,s4
4002dc0c:	0083c3b3          	xor	t2,t2,s0
4002dc10:	013282b3          	add	t0,t0,s3
4002dc14:	005382b3          	add	t0,t2,t0
4002dc18:	00b2d393          	srli	t2,t0,0xb
4002dc1c:	01529293          	slli	t0,t0,0x15
4002dc20:	0053e3b3          	or	t2,t2,t0
    P( local.A, local.B, local.C, local.D, 12,  6, 0x655B59C3 );
4002dc24:	655b69b7          	lui	s3,0x655b6
    P( local.B, local.C, local.D, local.A,  5, 21, 0xFC93A039 );
4002dc28:	001383b3          	add	t2,t2,ra
    P( local.A, local.B, local.C, local.D, 12,  6, 0x655B59C3 );
4002dc2c:	fff44293          	not	t0,s0
4002dc30:	9c398993          	addi	s3,s3,-1597 # 655b59c3 <__data_region_end+0x25570efb>
4002dc34:	0072e2b3          	or	t0,t0,t2
4002dc38:	013f8fb3          	add	t6,t6,s3
4002dc3c:	0012c2b3          	xor	t0,t0,ra
4002dc40:	009f8fb3          	add	t6,t6,s1
4002dc44:	01f28fb3          	add	t6,t0,t6
4002dc48:	006f9293          	slli	t0,t6,0x6
4002dc4c:	01afdf93          	srli	t6,t6,0x1a
4002dc50:	01f2e2b3          	or	t0,t0,t6
    P( local.D, local.A, local.B, local.C,  3, 10, 0x8F0CCC92 );
4002dc54:	8f0cd4b7          	lui	s1,0x8f0cd
    P( local.A, local.B, local.C, local.D, 12,  6, 0x655B59C3 );
4002dc58:	007282b3          	add	t0,t0,t2
    P( local.D, local.A, local.B, local.C,  3, 10, 0x8F0CCC92 );
4002dc5c:	fff0cf93          	not	t6,ra
4002dc60:	c9248493          	addi	s1,s1,-878 # 8f0ccc92 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8f0ccc93>
4002dc64:	005fefb3          	or	t6,t6,t0
4002dc68:	009f0f33          	add	t5,t5,s1
4002dc6c:	007fcfb3          	xor	t6,t6,t2
4002dc70:	008f0f33          	add	t5,t5,s0
4002dc74:	01ef8f33          	add	t5,t6,t5
4002dc78:	00af1f93          	slli	t6,t5,0xa
4002dc7c:	016f5f13          	srli	t5,t5,0x16
4002dc80:	01efefb3          	or	t6,t6,t5
    P( local.C, local.D, local.A, local.B, 10, 15, 0xFFEFF47D );
4002dc84:	ffeff437          	lui	s0,0xffeff
    P( local.D, local.A, local.B, local.C,  3, 10, 0x8F0CCC92 );
4002dc88:	005f8fb3          	add	t6,t6,t0
    P( local.C, local.D, local.A, local.B, 10, 15, 0xFFEFF47D );
4002dc8c:	fff3cf13          	not	t5,t2
4002dc90:	47d40413          	addi	s0,s0,1149 # ffeff47d <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffeff47e>
4002dc94:	01ff6f33          	or	t5,t5,t6
4002dc98:	008e8eb3          	add	t4,t4,s0
4002dc9c:	005f4f33          	xor	t5,t5,t0
4002dca0:	001e8eb3          	add	t4,t4,ra
4002dca4:	01df0eb3          	add	t4,t5,t4
4002dca8:	00fe9f13          	slli	t5,t4,0xf
4002dcac:	011ede93          	srli	t4,t4,0x11
4002dcb0:	01df6f33          	or	t5,t5,t4
    P( local.B, local.C, local.D, local.A,  1, 21, 0x85845DD1 );
4002dcb4:	858460b7          	lui	ra,0x85846
    P( local.C, local.D, local.A, local.B, 10, 15, 0xFFEFF47D );
4002dcb8:	01ff0f33          	add	t5,t5,t6
    P( local.B, local.C, local.D, local.A,  1, 21, 0x85845DD1 );
4002dcbc:	dd108093          	addi	ra,ra,-559 # 85845dd1 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x85845dd2>
4002dcc0:	fff2ce93          	not	t4,t0
4002dcc4:	001e0e33          	add	t3,t3,ra
4002dcc8:	01eeeeb3          	or	t4,t4,t5
4002dccc:	01feceb3          	xor	t4,t4,t6
4002dcd0:	007e0e33          	add	t3,t3,t2
4002dcd4:	01ce8e33          	add	t3,t4,t3
4002dcd8:	00be5e93          	srli	t4,t3,0xb
4002dcdc:	015e1e13          	slli	t3,t3,0x15
4002dce0:	01ceeeb3          	or	t4,t4,t3
    P( local.A, local.B, local.C, local.D,  8,  6, 0x6FA87E4F );
4002dce4:	6fa883b7          	lui	t2,0x6fa88
    P( local.B, local.C, local.D, local.A,  1, 21, 0x85845DD1 );
4002dce8:	01ee8eb3          	add	t4,t4,t5
    P( local.A, local.B, local.C, local.D,  8,  6, 0x6FA87E4F );
4002dcec:	ffffce13          	not	t3,t6
4002dcf0:	e4f38393          	addi	t2,t2,-433 # 6fa87e4f <__data_region_end+0x2fa43387>
4002dcf4:	01de6e33          	or	t3,t3,t4
4002dcf8:	00730333          	add	t1,t1,t2
4002dcfc:	01ee4e33          	xor	t3,t3,t5
4002dd00:	00530333          	add	t1,t1,t0
4002dd04:	006e0333          	add	t1,t3,t1
4002dd08:	00631e13          	slli	t3,t1,0x6
4002dd0c:	01a35313          	srli	t1,t1,0x1a
4002dd10:	006e6e33          	or	t3,t3,t1
    P( local.D, local.A, local.B, local.C, 15, 10, 0xFE2CE6E0 );
4002dd14:	fe2ce2b7          	lui	t0,0xfe2ce
    P( local.A, local.B, local.C, local.D,  8,  6, 0x6FA87E4F );
4002dd18:	01de0e33          	add	t3,t3,t4
    P( local.D, local.A, local.B, local.C, 15, 10, 0xFE2CE6E0 );
4002dd1c:	ffff4313          	not	t1,t5
4002dd20:	6e028293          	addi	t0,t0,1760 # fe2ce6e0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfe2ce6e1>
    local.X[15] = MBEDTLS_GET_UINT32_LE( data, 60 );
4002dd24:	02b12e23          	sw	a1,60(sp)
    P( local.D, local.A, local.B, local.C, 15, 10, 0xFE2CE6E0 );
4002dd28:	01c36333          	or	t1,t1,t3
4002dd2c:	005585b3          	add	a1,a1,t0
4002dd30:	01d34333          	xor	t1,t1,t4
4002dd34:	01f585b3          	add	a1,a1,t6
4002dd38:	00b305b3          	add	a1,t1,a1
4002dd3c:	00a59313          	slli	t1,a1,0xa
4002dd40:	0165d593          	srli	a1,a1,0x16
4002dd44:	00b36333          	or	t1,t1,a1
    P( local.C, local.D, local.A, local.B,  6, 15, 0xA3014314 );
4002dd48:	a3014fb7          	lui	t6,0xa3014
    P( local.D, local.A, local.B, local.C, 15, 10, 0xFE2CE6E0 );
4002dd4c:	01c30333          	add	t1,t1,t3
    P( local.C, local.D, local.A, local.B,  6, 15, 0xA3014314 );
4002dd50:	fffec593          	not	a1,t4
4002dd54:	314f8f93          	addi	t6,t6,788 # a3014314 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xa3014315>
4002dd58:	0065e5b3          	or	a1,a1,t1
4002dd5c:	01f888b3          	add	a7,a7,t6
4002dd60:	01e888b3          	add	a7,a7,t5
4002dd64:	01c5c5b3          	xor	a1,a1,t3
4002dd68:	011585b3          	add	a1,a1,a7
4002dd6c:	00f59893          	slli	a7,a1,0xf
4002dd70:	0115d593          	srli	a1,a1,0x11
4002dd74:	00b8e8b3          	or	a7,a7,a1
    P( local.B, local.C, local.D, local.A, 13, 21, 0x4E0811A1 );
4002dd78:	4e081f37          	lui	t5,0x4e081
    P( local.C, local.D, local.A, local.B,  6, 15, 0xA3014314 );
4002dd7c:	006888b3          	add	a7,a7,t1
    P( local.B, local.C, local.D, local.A, 13, 21, 0x4E0811A1 );
4002dd80:	fffe4593          	not	a1,t3
4002dd84:	1a1f0f13          	addi	t5,t5,417 # 4e0811a1 <__data_region_end+0xe03c6d9>
4002dd88:	0115e5b3          	or	a1,a1,a7
4002dd8c:	01e80833          	add	a6,a6,t5
4002dd90:	01d80833          	add	a6,a6,t4
4002dd94:	0065c5b3          	xor	a1,a1,t1
4002dd98:	010585b3          	add	a1,a1,a6
4002dd9c:	00b5d813          	srli	a6,a1,0xb
4002dda0:	01559593          	slli	a1,a1,0x15
4002dda4:	00b86833          	or	a6,a6,a1
    P( local.A, local.B, local.C, local.D,  4,  6, 0xF7537E82 );
4002dda8:	f7538eb7          	lui	t4,0xf7538
    P( local.B, local.C, local.D, local.A, 13, 21, 0x4E0811A1 );
4002ddac:	01180833          	add	a6,a6,a7
    P( local.A, local.B, local.C, local.D,  4,  6, 0xF7537E82 );
4002ddb0:	fff34593          	not	a1,t1
4002ddb4:	e82e8e93          	addi	t4,t4,-382 # f7537e82 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf7537e83>
4002ddb8:	0105e5b3          	or	a1,a1,a6
4002ddbc:	01d60633          	add	a2,a2,t4
4002ddc0:	01c60633          	add	a2,a2,t3
4002ddc4:	0115c5b3          	xor	a1,a1,a7
4002ddc8:	00c585b3          	add	a1,a1,a2
4002ddcc:	00659613          	slli	a2,a1,0x6
4002ddd0:	01a5d593          	srli	a1,a1,0x1a
4002ddd4:	00b66633          	or	a2,a2,a1
    P( local.D, local.A, local.B, local.C, 11, 10, 0xBD3AF235 );
4002ddd8:	bd3afe37          	lui	t3,0xbd3af
    P( local.A, local.B, local.C, local.D,  4,  6, 0xF7537E82 );
4002dddc:	01060633          	add	a2,a2,a6
    P( local.D, local.A, local.B, local.C, 11, 10, 0xBD3AF235 );
4002dde0:	fff8c593          	not	a1,a7
4002dde4:	235e0e13          	addi	t3,t3,565 # bd3af235 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xbd3af236>
4002dde8:	00c5e5b3          	or	a1,a1,a2
4002ddec:	01c686b3          	add	a3,a3,t3
4002ddf0:	0105c5b3          	xor	a1,a1,a6
4002ddf4:	006686b3          	add	a3,a3,t1
4002ddf8:	00d586b3          	add	a3,a1,a3
4002ddfc:	00a69593          	slli	a1,a3,0xa
4002de00:	0166d693          	srli	a3,a3,0x16
4002de04:	00d5e5b3          	or	a1,a1,a3
    P( local.C, local.D, local.A, local.B,  2, 15, 0x2AD7D2BB );
4002de08:	2ad7d337          	lui	t1,0x2ad7d
    P( local.D, local.A, local.B, local.C, 11, 10, 0xBD3AF235 );
4002de0c:	00c585b3          	add	a1,a1,a2
    P( local.C, local.D, local.A, local.B,  2, 15, 0x2AD7D2BB );
4002de10:	fff84693          	not	a3,a6
4002de14:	2bb30313          	addi	t1,t1,699 # 2ad7d2bb <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x24e1f1bb>
4002de18:	00b6e6b3          	or	a3,a3,a1
4002de1c:	00670733          	add	a4,a4,t1
4002de20:	00c6c6b3          	xor	a3,a3,a2
4002de24:	01170733          	add	a4,a4,a7
4002de28:	00e68733          	add	a4,a3,a4
4002de2c:	00f71693          	slli	a3,a4,0xf
4002de30:	01175713          	srli	a4,a4,0x11
4002de34:	00e6e6b3          	or	a3,a3,a4
    P( local.B, local.C, local.D, local.A,  9, 21, 0xEB86D391 );
4002de38:	eb86d8b7          	lui	a7,0xeb86d
    P( local.C, local.D, local.A, local.B,  2, 15, 0x2AD7D2BB );
4002de3c:	00b686b3          	add	a3,a3,a1
    P( local.B, local.C, local.D, local.A,  9, 21, 0xEB86D391 );
4002de40:	fff64713          	not	a4,a2
4002de44:	39188893          	addi	a7,a7,913 # eb86d391 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xeb86d392>
4002de48:	00d76733          	or	a4,a4,a3
4002de4c:	011787b3          	add	a5,a5,a7
4002de50:	00b74733          	xor	a4,a4,a1
4002de54:	010787b3          	add	a5,a5,a6
4002de58:	00f707b3          	add	a5,a4,a5
4002de5c:	00b7d713          	srli	a4,a5,0xb
4002de60:	01579793          	slli	a5,a5,0x15
4002de64:	00f767b3          	or	a5,a4,a5
4002de68:	00d787b3          	add	a5,a5,a3

#undef F

    ctx->state[0] += local.A;
4002de6c:	00cc0c33          	add	s8,s8,a2
    ctx->state[1] += local.B;
4002de70:	00f90933          	add	s2,s2,a5
    ctx->state[2] += local.C;
4002de74:	00db0b33          	add	s6,s6,a3
    ctx->state[3] += local.D;
4002de78:	00bb8bb3          	add	s7,s7,a1
    P( local.A, local.B, local.C, local.D,  4,  6, 0xF7537E82 );
4002de7c:	04c12023          	sw	a2,64(sp)
    P( local.D, local.A, local.B, local.C, 11, 10, 0xBD3AF235 );
4002de80:	04b12623          	sw	a1,76(sp)
    ctx->state[0] += local.A;
4002de84:	01852423          	sw	s8,8(a0)
    ctx->state[1] += local.B;
4002de88:	01252623          	sw	s2,12(a0)
    ctx->state[2] += local.C;
4002de8c:	01652823          	sw	s6,16(a0)
    ctx->state[3] += local.D;
4002de90:	01752a23          	sw	s7,20(a0)

    /* Zeroise variables to clear sensitive data from memory. */
    mbedtls_platform_zeroize( &local, sizeof( local ) );
4002de94:	05000593          	li	a1,80
4002de98:	00010513          	mv	a0,sp
    P( local.C, local.D, local.A, local.B,  2, 15, 0x2AD7D2BB );
4002de9c:	04d12423          	sw	a3,72(sp)
    P( local.B, local.C, local.D, local.A,  9, 21, 0xEB86D391 );
4002dea0:	04f12223          	sw	a5,68(sp)
    mbedtls_platform_zeroize( &local, sizeof( local ) );
4002dea4:	34c000ef          	jal	ra,4002e1f0 <mbedtls_platform_zeroize>

    return( 0 );
}
4002dea8:	08c12083          	lw	ra,140(sp)
4002deac:	08812403          	lw	s0,136(sp)
4002deb0:	08412483          	lw	s1,132(sp)
4002deb4:	08012903          	lw	s2,128(sp)
4002deb8:	07c12983          	lw	s3,124(sp)
4002debc:	07812a03          	lw	s4,120(sp)
4002dec0:	07412a83          	lw	s5,116(sp)
4002dec4:	07012b03          	lw	s6,112(sp)
4002dec8:	06c12b83          	lw	s7,108(sp)
4002decc:	06812c03          	lw	s8,104(sp)
4002ded0:	06412c83          	lw	s9,100(sp)
4002ded4:	06012d03          	lw	s10,96(sp)
4002ded8:	05c12d83          	lw	s11,92(sp)
4002dedc:	00000513          	li	a0,0
4002dee0:	09010113          	addi	sp,sp,144
4002dee4:	00008067          	ret

4002dee8 <mbedtls_md5_update>:
{
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t fill;
    uint32_t left;

    if( ilen == 0 )
4002dee8:	0e060e63          	beqz	a2,4002dfe4 <mbedtls_md5_update+0xfc>
{
4002deec:	fd010113          	addi	sp,sp,-48
4002def0:	02812423          	sw	s0,40(sp)
4002def4:	02912223          	sw	s1,36(sp)
4002def8:	03212023          	sw	s2,32(sp)
4002defc:	01312e23          	sw	s3,28(sp)
4002df00:	02112623          	sw	ra,44(sp)
4002df04:	01412c23          	sw	s4,24(sp)
4002df08:	01512a23          	sw	s5,20(sp)
        return( 0 );

    left = ctx->total[0] & 0x3F;
4002df0c:	00052783          	lw	a5,0(a0)
4002df10:	00050493          	mv	s1,a0
4002df14:	00058913          	mv	s2,a1
4002df18:	00c78733          	add	a4,a5,a2
    fill = 64 - left;

    ctx->total[0] += (uint32_t) ilen;
4002df1c:	00e52023          	sw	a4,0(a0)
4002df20:	00060413          	mv	s0,a2
    left = ctx->total[0] & 0x3F;
4002df24:	03f7f993          	andi	s3,a5,63
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < (uint32_t) ilen )
4002df28:	00f77863          	bgeu	a4,a5,4002df38 <mbedtls_md5_update+0x50>
        ctx->total[1]++;
4002df2c:	00452783          	lw	a5,4(a0)
4002df30:	00178793          	addi	a5,a5,1
4002df34:	00f52223          	sw	a5,4(a0)

    if( left && ilen >= fill )
4002df38:	04098263          	beqz	s3,4002df7c <mbedtls_md5_update+0x94>
    fill = 64 - left;
4002df3c:	04000a13          	li	s4,64
4002df40:	413a0a33          	sub	s4,s4,s3
    if( left && ilen >= fill )
4002df44:	03446c63          	bltu	s0,s4,4002df7c <mbedtls_md5_update+0x94>
    {
        memcpy( (void *) (ctx->buffer + left), input, fill );
4002df48:	01848a93          	addi	s5,s1,24
4002df4c:	00090593          	mv	a1,s2
4002df50:	000a0613          	mv	a2,s4
4002df54:	013a8533          	add	a0,s5,s3
4002df58:	da1de0ef          	jal	ra,4000ccf8 <memcpy>
        if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )
4002df5c:	000a8593          	mv	a1,s5
4002df60:	00048513          	mv	a0,s1
4002df64:	844ff0ef          	jal	ra,4002cfa8 <mbedtls_internal_md5_process>
4002df68:	04051c63          	bnez	a0,4002dfc0 <mbedtls_md5_update+0xd8>
            return( ret );

        input += fill;
4002df6c:	01340633          	add	a2,s0,s3
4002df70:	01490933          	add	s2,s2,s4
        ilen  -= fill;
4002df74:	fc060413          	addi	s0,a2,-64
        left = 0;
4002df78:	00000993          	li	s3,0
4002df7c:	00040613          	mv	a2,s0
4002df80:	00890933          	add	s2,s2,s0
    }

    while( ilen >= 64 )
4002df84:	03f00413          	li	s0,63
4002df88:	01c0006f          	j	4002dfa4 <mbedtls_md5_update+0xbc>
    {
        if( ( ret = mbedtls_internal_md5_process( ctx, input ) ) != 0 )
4002df8c:	00048513          	mv	a0,s1
4002df90:	00c12623          	sw	a2,12(sp)
4002df94:	814ff0ef          	jal	ra,4002cfa8 <mbedtls_internal_md5_process>
4002df98:	02051463          	bnez	a0,4002dfc0 <mbedtls_md5_update+0xd8>
            return( ret );

        input += 64;
        ilen  -= 64;
4002df9c:	00c12603          	lw	a2,12(sp)
4002dfa0:	fc060613          	addi	a2,a2,-64
4002dfa4:	40c905b3          	sub	a1,s2,a2
    while( ilen >= 64 )
4002dfa8:	fec462e3          	bltu	s0,a2,4002df8c <mbedtls_md5_update+0xa4>
    }

    if( ilen > 0 )
4002dfac:	00060863          	beqz	a2,4002dfbc <mbedtls_md5_update+0xd4>
    {
        memcpy( (void *) (ctx->buffer + left), input, ilen );
4002dfb0:	01848513          	addi	a0,s1,24
4002dfb4:	01350533          	add	a0,a0,s3
4002dfb8:	d41de0ef          	jal	ra,4000ccf8 <memcpy>
        return( 0 );
4002dfbc:	00000513          	li	a0,0
    }

    return( 0 );
}
4002dfc0:	02c12083          	lw	ra,44(sp)
4002dfc4:	02812403          	lw	s0,40(sp)
4002dfc8:	02412483          	lw	s1,36(sp)
4002dfcc:	02012903          	lw	s2,32(sp)
4002dfd0:	01c12983          	lw	s3,28(sp)
4002dfd4:	01812a03          	lw	s4,24(sp)
4002dfd8:	01412a83          	lw	s5,20(sp)
4002dfdc:	03010113          	addi	sp,sp,48
4002dfe0:	00008067          	ret
        return( 0 );
4002dfe4:	00000513          	li	a0,0
}
4002dfe8:	00008067          	ret

4002dfec <mbedtls_md5_finish>:
/*
 * MD5 final digest
 */
int mbedtls_md5_finish( mbedtls_md5_context *ctx,
                            unsigned char output[16] )
{
4002dfec:	ff010113          	addi	sp,sp,-16
4002dff0:	00812423          	sw	s0,8(sp)
4002dff4:	00912223          	sw	s1,4(sp)
4002dff8:	01212023          	sw	s2,0(sp)
4002dffc:	00112623          	sw	ra,12(sp)
    uint32_t high, low;

    /*
     * Add padding: 0x80 then 0x00 until 8 bytes remain for the length
     */
    used = ctx->total[0] & 0x3F;
4002e000:	00052783          	lw	a5,0(a0)

    ctx->buffer[used++] = 0x80;
4002e004:	f8000693          	li	a3,-128

    if( used <= 56 )
    {
        /* Enough room for padding + length in current block */
        memset( ctx->buffer + used, 0, 56 - used );
4002e008:	01850913          	addi	s2,a0,24
    used = ctx->total[0] & 0x3F;
4002e00c:	03f7f793          	andi	a5,a5,63
    ctx->buffer[used++] = 0x80;
4002e010:	00178713          	addi	a4,a5,1
4002e014:	00f507b3          	add	a5,a0,a5
4002e018:	00d78c23          	sb	a3,24(a5)
    if( used <= 56 )
4002e01c:	03800613          	li	a2,56
{
4002e020:	00050413          	mv	s0,a0
4002e024:	00058493          	mv	s1,a1
        memset( ctx->buffer + used, 0, 56 - used );
4002e028:	00e90533          	add	a0,s2,a4
    if( used <= 56 )
4002e02c:	0ee66463          	bltu	a2,a4,4002e114 <mbedtls_md5_finish+0x128>
        memset( ctx->buffer + used, 0, 56 - used );
4002e030:	40e60633          	sub	a2,a2,a4
4002e034:	00000593          	li	a1,0
        memset( ctx->buffer + used, 0, 64 - used );

        if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )
            return( ret );

        memset( ctx->buffer, 0, 56 );
4002e038:	ce5de0ef          	jal	ra,4000cd1c <memset>
    }

    /*
     * Add message length
     */
    high = ( ctx->total[0] >> 29 )
4002e03c:	00042703          	lw	a4,0(s0)
         | ( ctx->total[1] <<  3 );
4002e040:	00442783          	lw	a5,4(s0)
    low  = ( ctx->total[0] <<  3 );

    MBEDTLS_PUT_UINT32_LE( low,  ctx->buffer, 56 );
    MBEDTLS_PUT_UINT32_LE( high, ctx->buffer, 60 );

    if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )
4002e044:	00090593          	mv	a1,s2
    high = ( ctx->total[0] >> 29 )
4002e048:	01d75693          	srli	a3,a4,0x1d
         | ( ctx->total[1] <<  3 );
4002e04c:	00379793          	slli	a5,a5,0x3
    high = ( ctx->total[0] >> 29 )
4002e050:	00d7e7b3          	or	a5,a5,a3
    low  = ( ctx->total[0] <<  3 );
4002e054:	00371713          	slli	a4,a4,0x3
    MBEDTLS_PUT_UINT32_LE( low,  ctx->buffer, 56 );
4002e058:	04e42823          	sw	a4,80(s0)
    MBEDTLS_PUT_UINT32_LE( high, ctx->buffer, 60 );
4002e05c:	04f42a23          	sw	a5,84(s0)
    if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )
4002e060:	00040513          	mv	a0,s0
4002e064:	f45fe0ef          	jal	ra,4002cfa8 <mbedtls_internal_md5_process>
4002e068:	08051a63          	bnez	a0,4002e0fc <mbedtls_md5_finish+0x110>
        return( ret );

    /*
     * Output final state
     */
    MBEDTLS_PUT_UINT32_LE( ctx->state[0], output,  0 );
4002e06c:	00842783          	lw	a5,8(s0)
4002e070:	00f48023          	sb	a5,0(s1)
4002e074:	00842783          	lw	a5,8(s0)
4002e078:	0087d793          	srli	a5,a5,0x8
4002e07c:	00f480a3          	sb	a5,1(s1)
4002e080:	00a45783          	lhu	a5,10(s0)
4002e084:	00f48123          	sb	a5,2(s1)
4002e088:	00b44783          	lbu	a5,11(s0)
4002e08c:	00f481a3          	sb	a5,3(s1)
    MBEDTLS_PUT_UINT32_LE( ctx->state[1], output,  4 );
4002e090:	00c42783          	lw	a5,12(s0)
4002e094:	00f48223          	sb	a5,4(s1)
4002e098:	00c42783          	lw	a5,12(s0)
4002e09c:	0087d793          	srli	a5,a5,0x8
4002e0a0:	00f482a3          	sb	a5,5(s1)
4002e0a4:	00e45783          	lhu	a5,14(s0)
4002e0a8:	00f48323          	sb	a5,6(s1)
4002e0ac:	00f44783          	lbu	a5,15(s0)
4002e0b0:	00f483a3          	sb	a5,7(s1)
    MBEDTLS_PUT_UINT32_LE( ctx->state[2], output,  8 );
4002e0b4:	01042783          	lw	a5,16(s0)
4002e0b8:	00f48423          	sb	a5,8(s1)
4002e0bc:	01042783          	lw	a5,16(s0)
4002e0c0:	0087d793          	srli	a5,a5,0x8
4002e0c4:	00f484a3          	sb	a5,9(s1)
4002e0c8:	01245783          	lhu	a5,18(s0)
4002e0cc:	00f48523          	sb	a5,10(s1)
4002e0d0:	01344783          	lbu	a5,19(s0)
4002e0d4:	00f485a3          	sb	a5,11(s1)
    MBEDTLS_PUT_UINT32_LE( ctx->state[3], output, 12 );
4002e0d8:	01442783          	lw	a5,20(s0)
4002e0dc:	00f48623          	sb	a5,12(s1)
4002e0e0:	01442783          	lw	a5,20(s0)
4002e0e4:	0087d793          	srli	a5,a5,0x8
4002e0e8:	00f486a3          	sb	a5,13(s1)
4002e0ec:	01645783          	lhu	a5,22(s0)
4002e0f0:	00f48723          	sb	a5,14(s1)
4002e0f4:	01744783          	lbu	a5,23(s0)
4002e0f8:	00f487a3          	sb	a5,15(s1)

    return( 0 );
}
4002e0fc:	00c12083          	lw	ra,12(sp)
4002e100:	00812403          	lw	s0,8(sp)
4002e104:	00412483          	lw	s1,4(sp)
4002e108:	00012903          	lw	s2,0(sp)
4002e10c:	01010113          	addi	sp,sp,16
4002e110:	00008067          	ret
        memset( ctx->buffer + used, 0, 64 - used );
4002e114:	04000613          	li	a2,64
4002e118:	00000593          	li	a1,0
4002e11c:	40e60633          	sub	a2,a2,a4
4002e120:	bfdde0ef          	jal	ra,4000cd1c <memset>
        if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )
4002e124:	00090593          	mv	a1,s2
4002e128:	00040513          	mv	a0,s0
4002e12c:	e7dfe0ef          	jal	ra,4002cfa8 <mbedtls_internal_md5_process>
4002e130:	fc0516e3          	bnez	a0,4002e0fc <mbedtls_md5_finish+0x110>
        memset( ctx->buffer, 0, 56 );
4002e134:	03800613          	li	a2,56
4002e138:	00000593          	li	a1,0
4002e13c:	00090513          	mv	a0,s2
4002e140:	ef9ff06f          	j	4002e038 <mbedtls_md5_finish+0x4c>

4002e144 <mbedtls_md5>:
 * output = MD5( input buffer )
 */
int mbedtls_md5( const unsigned char *input,
                     size_t ilen,
                     unsigned char output[16] )
{
4002e144:	f9010113          	addi	sp,sp,-112
4002e148:	06812423          	sw	s0,104(sp)
4002e14c:	00050413          	mv	s0,a0
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    mbedtls_md5_context ctx;

    mbedtls_md5_init( &ctx );
4002e150:	00810513          	addi	a0,sp,8
{
4002e154:	06912223          	sw	s1,100(sp)
4002e158:	07212023          	sw	s2,96(sp)
4002e15c:	06112623          	sw	ra,108(sp)
4002e160:	00058913          	mv	s2,a1
4002e164:	00060493          	mv	s1,a2
    mbedtls_md5_init( &ctx );
4002e168:	e35fe0ef          	jal	ra,4002cf9c <mbedtls_md5_init>
    ctx->state[0] = 0x67452301;
4002e16c:	674527b7          	lui	a5,0x67452
4002e170:	30178793          	addi	a5,a5,769 # 67452301 <__data_region_end+0x2740d839>
4002e174:	00f12823          	sw	a5,16(sp)
    ctx->state[1] = 0xEFCDAB89;
4002e178:	efcdb7b7          	lui	a5,0xefcdb
4002e17c:	b8978793          	addi	a5,a5,-1143 # efcdab89 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xefcdab8a>
4002e180:	00f12a23          	sw	a5,20(sp)
    ctx->state[2] = 0x98BADCFE;
4002e184:	98bae7b7          	lui	a5,0x98bae
4002e188:	cfe78793          	addi	a5,a5,-770 # 98badcfe <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x98badcff>
4002e18c:	00f12c23          	sw	a5,24(sp)
    ctx->state[3] = 0x10325476;
4002e190:	103257b7          	lui	a5,0x10325
4002e194:	47678793          	addi	a5,a5,1142 # 10325476 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa3c7376>

    if( ( ret = mbedtls_md5_starts( &ctx ) ) != 0 )
        goto exit;

    if( ( ret = mbedtls_md5_update( &ctx, input, ilen ) ) != 0 )
4002e198:	00090613          	mv	a2,s2
4002e19c:	00040593          	mv	a1,s0
4002e1a0:	00810513          	addi	a0,sp,8
    ctx->total[0] = 0;
4002e1a4:	00012423          	sw	zero,8(sp)
    ctx->total[1] = 0;
4002e1a8:	00012623          	sw	zero,12(sp)
    ctx->state[3] = 0x10325476;
4002e1ac:	00f12e23          	sw	a5,28(sp)
    if( ( ret = mbedtls_md5_update( &ctx, input, ilen ) ) != 0 )
4002e1b0:	d39ff0ef          	jal	ra,4002dee8 <mbedtls_md5_update>
4002e1b4:	00051863          	bnez	a0,4002e1c4 <mbedtls_md5+0x80>
        goto exit;

    if( ( ret = mbedtls_md5_finish( &ctx, output ) ) != 0 )
4002e1b8:	00048593          	mv	a1,s1
4002e1bc:	00810513          	addi	a0,sp,8
4002e1c0:	e2dff0ef          	jal	ra,4002dfec <mbedtls_md5_finish>
4002e1c4:	00050413          	mv	s0,a0
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md5_context ) );
4002e1c8:	05800593          	li	a1,88
4002e1cc:	00810513          	addi	a0,sp,8
4002e1d0:	020000ef          	jal	ra,4002e1f0 <mbedtls_platform_zeroize>

exit:
    mbedtls_md5_free( &ctx );

    return( ret );
}
4002e1d4:	06c12083          	lw	ra,108(sp)
4002e1d8:	00040513          	mv	a0,s0
4002e1dc:	06812403          	lw	s0,104(sp)
4002e1e0:	06412483          	lw	s1,100(sp)
4002e1e4:	06012903          	lw	s2,96(sp)
4002e1e8:	07010113          	addi	sp,sp,112
4002e1ec:	00008067          	ret

4002e1f0 <mbedtls_platform_zeroize>:
 * platform and needs.
 */
void * (* const volatile memset_func)( void *, int, size_t ) = memset;

void mbedtls_platform_zeroize( void *buf, size_t len )
{
4002e1f0:	00058613          	mv	a2,a1
    MBEDTLS_INTERNAL_VALIDATE( len == 0 || buf != NULL );

    if( len > 0 )
4002e1f4:	00058a63          	beqz	a1,4002e208 <mbedtls_platform_zeroize+0x18>
        memset_func( buf, 0, len );
4002e1f8:	400447b7          	lui	a5,0x40044
4002e1fc:	6c87a783          	lw	a5,1736(a5) # 400446c8 <memset_func>
4002e200:	00000593          	li	a1,0
4002e204:	00078067          	jr	a5
}
4002e208:	00008067          	ret

4002e20c <device_visitor>:

static int device_visitor(const device_handle_t *handles,
			   size_t handle_count,
			   device_visitor_callback_t visitor_cb,
			   void *context)
{
4002e20c:	fd010113          	addi	sp,sp,-48
	size_t numdev = __device_end - __device_start;
4002e210:	400327b7          	lui	a5,0x40032
4002e214:	02812423          	sw	s0,40(sp)
4002e218:	40032437          	lui	s0,0x40032
4002e21c:	2fc78713          	addi	a4,a5,764 # 400322fc <__device_dts_ord_18>
4002e220:	37440413          	addi	s0,s0,884 # 40032374 <_sw_isr_table>
4002e224:	40e40433          	sub	s0,s0,a4
4002e228:	aaaab737          	lui	a4,0xaaaab
4002e22c:	40345413          	srai	s0,s0,0x3
4002e230:	aab70713          	addi	a4,a4,-1365 # aaaaaaab <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xaaaaaaac>
4002e234:	02e40433          	mul	s0,s0,a4
4002e238:	02912223          	sw	s1,36(sp)
4002e23c:	03212023          	sw	s2,32(sp)
4002e240:	01312e23          	sw	s3,28(sp)
4002e244:	01412c23          	sw	s4,24(sp)
4002e248:	01512a23          	sw	s5,20(sp)
4002e24c:	01612823          	sw	s6,16(sp)
4002e250:	01712623          	sw	s7,12(sp)
4002e254:	02112623          	sw	ra,44(sp)
4002e258:	00050a93          	mv	s5,a0
4002e25c:	00058a13          	mv	s4,a1
4002e260:	00060b13          	mv	s6,a2
4002e264:	00068913          	mv	s2,a3
	/* Iterate over fixed devices */
	for (size_t i = 0; i < handle_count; ++i) {
4002e268:	00000493          	li	s1,0
4002e26c:	2fc78993          	addi	s3,a5,764
		dev = &__device_start[dev_handle - 1];
4002e270:	01800b93          	li	s7,24
4002e274:	03449a63          	bne	s1,s4,4002e2a8 <device_visitor+0x9c>
		if (rc < 0) {
			return rc;
		}
	}

	return handle_count;
4002e278:	00048513          	mv	a0,s1
}
4002e27c:	02c12083          	lw	ra,44(sp)
4002e280:	02812403          	lw	s0,40(sp)
4002e284:	02412483          	lw	s1,36(sp)
4002e288:	02012903          	lw	s2,32(sp)
4002e28c:	01c12983          	lw	s3,28(sp)
4002e290:	01812a03          	lw	s4,24(sp)
4002e294:	01412a83          	lw	s5,20(sp)
4002e298:	01012b03          	lw	s6,16(sp)
4002e29c:	00c12b83          	lw	s7,12(sp)
4002e2a0:	03010113          	addi	sp,sp,48
4002e2a4:	00008067          	ret
		device_handle_t dh = handles[i];
4002e2a8:	00149793          	slli	a5,s1,0x1
4002e2ac:	00fa87b3          	add	a5,s5,a5
4002e2b0:	00079783          	lh	a5,0(a5)
	const struct device *dev = NULL;
4002e2b4:	00000513          	li	a0,0
	if ((dev_handle > 0) && ((size_t)dev_handle <= numdev)) {
4002e2b8:	00f05e63          	blez	a5,4002e2d4 <device_visitor+0xc8>
4002e2bc:	00f46c63          	bltu	s0,a5,4002e2d4 <device_visitor+0xc8>
		dev = &__device_start[dev_handle - 1];
4002e2c0:	fff78793          	addi	a5,a5,-1
4002e2c4:	01079793          	slli	a5,a5,0x10
4002e2c8:	4107d793          	srai	a5,a5,0x10
4002e2cc:	037787b3          	mul	a5,a5,s7
4002e2d0:	00f98533          	add	a0,s3,a5
		int rc = visitor_cb(rdev, context);
4002e2d4:	00090593          	mv	a1,s2
4002e2d8:	000b00e7          	jalr	s6
		if (rc < 0) {
4002e2dc:	fa0540e3          	bltz	a0,4002e27c <device_visitor+0x70>
	for (size_t i = 0; i < handle_count; ++i) {
4002e2e0:	00148493          	addi	s1,s1,1
4002e2e4:	f91ff06f          	j	4002e274 <device_visitor+0x68>

4002e2e8 <z_device_state_init>:
}
4002e2e8:	00008067          	ret

4002e2ec <z_device_get_all_static>:
	*devices = __device_start;
4002e2ec:	40032737          	lui	a4,0x40032
	return __device_end - __device_start;
4002e2f0:	400327b7          	lui	a5,0x40032
	*devices = __device_start;
4002e2f4:	2fc70713          	addi	a4,a4,764 # 400322fc <__device_dts_ord_18>
	return __device_end - __device_start;
4002e2f8:	37478793          	addi	a5,a5,884 # 40032374 <_sw_isr_table>
	*devices = __device_start;
4002e2fc:	00e52023          	sw	a4,0(a0)
	return __device_end - __device_start;
4002e300:	40e787b3          	sub	a5,a5,a4
}
4002e304:	aaaab537          	lui	a0,0xaaaab
	return __device_end - __device_start;
4002e308:	4037d793          	srai	a5,a5,0x3
}
4002e30c:	aab50513          	addi	a0,a0,-1365 # aaaaaaab <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xaaaaaaac>
4002e310:	02a78533          	mul	a0,a5,a0
4002e314:	00008067          	ret

4002e318 <z_device_is_ready>:
	if (dev == NULL) {
4002e318:	02050263          	beqz	a0,4002e33c <z_device_is_ready+0x24>
	return dev->state->initialized && (dev->state->init_res == 0U);
4002e31c:	00c52703          	lw	a4,12(a0)
4002e320:	00000513          	li	a0,0
4002e324:	00174783          	lbu	a5,1(a4)
4002e328:	0017f793          	andi	a5,a5,1
4002e32c:	00078a63          	beqz	a5,4002e340 <z_device_is_ready+0x28>
4002e330:	00074503          	lbu	a0,0(a4)
4002e334:	00153513          	seqz	a0,a0
4002e338:	00008067          	ret
		return false;
4002e33c:	00000513          	li	a0,0
}
4002e340:	00008067          	ret

4002e344 <device_required_foreach>:
int device_required_foreach(const struct device *dev,
			    device_visitor_callback_t visitor_cb,
			    void *context)
{
	size_t handle_count = 0;
	const device_handle_t *handles = device_required_handles_get(dev, &handle_count);
4002e344:	01452503          	lw	a0,20(a0)
{
4002e348:	00058713          	mv	a4,a1
4002e34c:	00060693          	mv	a3,a2
		size_t i = 0;
4002e350:	00000593          	li	a1,0
	if (rv != NULL) {
4002e354:	02050863          	beqz	a0,4002e384 <device_required_foreach+0x40>
		while ((rv[i] != DEVICE_HANDLE_ENDS) &&
4002e358:	00008837          	lui	a6,0x8
4002e35c:	00010637          	lui	a2,0x10
4002e360:	fff80813          	addi	a6,a6,-1 # 7fff <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3fff>
4002e364:	ffd60613          	addi	a2,a2,-3 # fffd <__kernel_ram_size+0x44f5>
4002e368:	00159793          	slli	a5,a1,0x1
4002e36c:	00f507b3          	add	a5,a0,a5
4002e370:	0007d783          	lhu	a5,0(a5)
4002e374:	010787b3          	add	a5,a5,a6
4002e378:	01079793          	slli	a5,a5,0x10
4002e37c:	0107d793          	srli	a5,a5,0x10
4002e380:	00f67663          	bgeu	a2,a5,4002e38c <device_required_foreach+0x48>

	return device_visitor(handles, handle_count, visitor_cb, context);
4002e384:	00070613          	mv	a2,a4
4002e388:	e85ff06f          	j	4002e20c <device_visitor>
			++i;
4002e38c:	00158593          	addi	a1,a1,1
4002e390:	fd9ff06f          	j	4002e368 <device_required_foreach+0x24>

4002e394 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
4002e394:	4003b7b7          	lui	a5,0x4003b
4002e398:	1cc7a503          	lw	a0,460(a5) # 4003b1cc <_kernel+0x8>
}
4002e39c:	0ac50513          	addi	a0,a0,172
4002e3a0:	00008067          	ret

4002e3a4 <arch_system_halt>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002e3a4:	300477f3          	csrrci	a5,mstatus,8
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
4002e3a8:	0000006f          	j	4002e3a8 <arch_system_halt+0x4>

4002e3ac <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
4002e3ac:	fd010113          	addi	sp,sp,-48
4002e3b0:	02812423          	sw	s0,40(sp)
4002e3b4:	02112623          	sw	ra,44(sp)
4002e3b8:	00050413          	mv	s0,a0
	z_impl_log_panic();
4002e3bc:	c4cd60ef          	jal	ra,40004808 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
4002e3c0:	40044537          	lui	a0,0x40044
4002e3c4:	7ac52783          	lw	a5,1964(a0) # 400447ac <log_dynamic_os>
4002e3c8:	0077f793          	andi	a5,a5,7
4002e3cc:	02078863          	beqz	a5,4002e3fc <k_sys_fatal_error_handler+0x50>
4002e3d0:	400397b7          	lui	a5,0x40039
4002e3d4:	df478793          	addi	a5,a5,-524 # 40038df4 <uart_liteuart_driver_api+0x14>
4002e3d8:	00f12e23          	sw	a5,28(sp)
4002e3dc:	00200793          	li	a5,2
4002e3e0:	00f12c23          	sw	a5,24(sp)
4002e3e4:	000015b7          	lui	a1,0x1
4002e3e8:	00000693          	li	a3,0
4002e3ec:	01810613          	addi	a2,sp,24
4002e3f0:	04058593          	addi	a1,a1,64 # 1040 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>
4002e3f4:	7ac50513          	addi	a0,a0,1964
4002e3f8:	b9dd60ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
	arch_system_halt(reason);
4002e3fc:	00040513          	mv	a0,s0
4002e400:	fa5ff0ef          	jal	ra,4002e3a4 <arch_system_halt>

4002e404 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
4002e404:	fe010113          	addi	sp,sp,-32
4002e408:	00812c23          	sw	s0,24(sp)
4002e40c:	01212823          	sw	s2,16(sp)
4002e410:	01412423          	sw	s4,8(sp)
4002e414:	00112e23          	sw	ra,28(sp)
4002e418:	00912a23          	sw	s1,20(sp)
4002e41c:	01312623          	sw	s3,12(sp)
4002e420:	01512223          	sw	s5,4(sp)
4002e424:	01612023          	sw	s6,0(sp)
4002e428:	02010413          	addi	s0,sp,32
4002e42c:	00050913          	mv	s2,a0
4002e430:	00058a13          	mv	s4,a1
4002e434:	300479f3          	csrrci	s3,mstatus,8
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
4002e438:	40044ab7          	lui	s5,0x40044
	return z_impl_z_current_get();
4002e43c:	309020ef          	jal	ra,40030f44 <z_impl_z_current_get>
4002e440:	7acaa783          	lw	a5,1964(s5) # 400447ac <log_dynamic_os>
4002e444:	00050493          	mv	s1,a0
4002e448:	0077f793          	andi	a5,a5,7
4002e44c:	0e078a63          	beqz	a5,4002e540 <z_fatal_error+0x13c>
	switch (reason) {
4002e450:	00400793          	li	a5,4
4002e454:	1327ea63          	bltu	a5,s2,4002e588 <z_fatal_error+0x184>
4002e458:	400397b7          	lui	a5,0x40039
4002e45c:	00291713          	slli	a4,s2,0x2
4002e460:	ea478793          	addi	a5,a5,-348 # 40038ea4 <CSWTCH.407>
4002e464:	00e787b3          	add	a5,a5,a4
4002e468:	0007a783          	lw	a5,0(a5)
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
4002e46c:	00010b13          	mv	s6,sp
4002e470:	fd010113          	addi	sp,sp,-48
4002e474:	00010613          	mv	a2,sp
4002e478:	00f62e23          	sw	a5,28(a2)
4002e47c:	30100793          	li	a5,769
4002e480:	02f61223          	sh	a5,36(a2)
4002e484:	40039737          	lui	a4,0x40039
4002e488:	010007b7          	lui	a5,0x1000
4002e48c:	e1470713          	addi	a4,a4,-492 # 40038e14 <uart_liteuart_driver_api+0x34>
4002e490:	00578793          	addi	a5,a5,5 # 1000005 <__rom_region_size+0xfc7049>
4002e494:	00e62a23          	sw	a4,20(a2)
4002e498:	01262c23          	sw	s2,24(a2)
4002e49c:	02062023          	sw	zero,32(a2)
4002e4a0:	00f62823          	sw	a5,16(a2)
4002e4a4:	000035b7          	lui	a1,0x3
4002e4a8:	00000693          	li	a3,0
4002e4ac:	01060613          	addi	a2,a2,16
4002e4b0:	c4058593          	addi	a1,a1,-960 # 2c40 <CONFIG_SRAM_SIZE+0xc40>
4002e4b4:	7aca8513          	addi	a0,s5,1964
4002e4b8:	addd60ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
4002e4bc:	7acaa783          	lw	a5,1964(s5)
4002e4c0:	000b0113          	mv	sp,s6
4002e4c4:	0077f793          	andi	a5,a5,7
4002e4c8:	06078c63          	beqz	a5,4002e540 <z_fatal_error+0x13c>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
4002e4cc:	00048e63          	beqz	s1,4002e4e8 <z_fatal_error+0xe4>
4002e4d0:	00048513          	mv	a0,s1
4002e4d4:	051000ef          	jal	ra,4002ed24 <k_thread_name_get>
4002e4d8:	00050793          	mv	a5,a0
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
4002e4dc:	00050663          	beqz	a0,4002e4e8 <z_fatal_error+0xe4>
4002e4e0:	00054703          	lbu	a4,0(a0)
4002e4e4:	00071663          	bnez	a4,4002e4f0 <z_fatal_error+0xec>
		thread_name = "unknown";
4002e4e8:	400347b7          	lui	a5,0x40034
4002e4ec:	76c78793          	addi	a5,a5,1900 # 4003476c <shell_m_sub_colors+0x194>
	LOG_ERR("Current thread: %p (%s)", thread,
4002e4f0:	00010b13          	mv	s6,sp
4002e4f4:	fd010113          	addi	sp,sp,-48
4002e4f8:	00010613          	mv	a2,sp
4002e4fc:	00f62e23          	sw	a5,28(a2)
4002e500:	30100793          	li	a5,769
4002e504:	02f61023          	sh	a5,32(a2)
4002e508:	40039737          	lui	a4,0x40039
4002e50c:	010007b7          	lui	a5,0x1000
4002e510:	e3c70713          	addi	a4,a4,-452 # 40038e3c <uart_liteuart_driver_api+0x5c>
4002e514:	00478793          	addi	a5,a5,4 # 1000004 <__rom_region_size+0xfc7048>
4002e518:	00e62a23          	sw	a4,20(a2)
4002e51c:	00962c23          	sw	s1,24(a2)
4002e520:	00f62823          	sw	a5,16(a2)
4002e524:	000025b7          	lui	a1,0x2
4002e528:	00000693          	li	a3,0
4002e52c:	01060613          	addi	a2,a2,16
4002e530:	44058593          	addi	a1,a1,1088 # 2440 <CONFIG_SRAM_SIZE+0x440>
4002e534:	7aca8513          	addi	a0,s5,1964
4002e538:	a5dd60ef          	jal	ra,40004f94 <z_impl_z_log_msg_static_create>
4002e53c:	000b0113          	mv	sp,s6

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
4002e540:	000a0593          	mv	a1,s4
4002e544:	00090513          	mv	a0,s2
4002e548:	e65ff0ef          	jal	ra,4002e3ac <k_sys_fatal_error_handler>
			  : "r" (key & MSTATUS_IEN)
4002e54c:	0089f993          	andi	s3,s3,8
	__asm__ volatile ("csrs mstatus, %0"
4002e550:	3009a073          	csrs	mstatus,s3
	z_impl_k_thread_abort(thread);
4002e554:	00048513          	mv	a0,s1
4002e558:	321020ef          	jal	ra,40031078 <z_impl_k_thread_abort>
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
4002e55c:	fe040113          	addi	sp,s0,-32
4002e560:	01c12083          	lw	ra,28(sp)
4002e564:	01812403          	lw	s0,24(sp)
4002e568:	01412483          	lw	s1,20(sp)
4002e56c:	01012903          	lw	s2,16(sp)
4002e570:	00c12983          	lw	s3,12(sp)
4002e574:	00812a03          	lw	s4,8(sp)
4002e578:	00412a83          	lw	s5,4(sp)
4002e57c:	00012b03          	lw	s6,0(sp)
4002e580:	02010113          	addi	sp,sp,32
4002e584:	00008067          	ret
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
4002e588:	400397b7          	lui	a5,0x40039
4002e58c:	e0478793          	addi	a5,a5,-508 # 40038e04 <uart_liteuart_driver_api+0x24>
4002e590:	eddff06f          	j	4002e46c <z_fatal_error+0x68>

4002e594 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
4002e594:	00251713          	slli	a4,a0,0x2
4002e598:	400397b7          	lui	a5,0x40039
4002e59c:	00150513          	addi	a0,a0,1
4002e5a0:	ec878793          	addi	a5,a5,-312 # 40038ec8 <levels.0>
4002e5a4:	00251513          	slli	a0,a0,0x2
{
4002e5a8:	fe010113          	addi	sp,sp,-32
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
4002e5ac:	00e78733          	add	a4,a5,a4
4002e5b0:	00a787b3          	add	a5,a5,a0
{
4002e5b4:	00812c23          	sw	s0,24(sp)
4002e5b8:	01212823          	sw	s2,16(sp)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
4002e5bc:	00072403          	lw	s0,0(a4)
4002e5c0:	0007a903          	lw	s2,0(a5)
{
4002e5c4:	01312623          	sw	s3,12(sp)
4002e5c8:	00112e23          	sw	ra,28(sp)
4002e5cc:	00912a23          	sw	s1,20(sp)
				 */
				if (rc != 0) {
					if (rc < 0) {
						rc = -rc;
					}
					if (rc > UINT8_MAX) {
4002e5d0:	0ff00993          	li	s3,255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
4002e5d4:	03246063          	bltu	s0,s2,4002e5f4 <z_sys_init_run_level+0x60>
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
4002e5d8:	01c12083          	lw	ra,28(sp)
4002e5dc:	01812403          	lw	s0,24(sp)
4002e5e0:	01412483          	lw	s1,20(sp)
4002e5e4:	01012903          	lw	s2,16(sp)
4002e5e8:	00c12983          	lw	s3,12(sp)
4002e5ec:	02010113          	addi	sp,sp,32
4002e5f0:	00008067          	ret
		const struct device *dev = entry->dev;
4002e5f4:	00442483          	lw	s1,4(s0)
			if (entry->init_fn.dev != NULL) {
4002e5f8:	00042783          	lw	a5,0(s0)
		if (dev != NULL) {
4002e5fc:	04048463          	beqz	s1,4002e644 <z_sys_init_run_level+0xb0>
			if (entry->init_fn.dev != NULL) {
4002e600:	02078663          	beqz	a5,4002e62c <z_sys_init_run_level+0x98>
				rc = entry->init_fn.dev(dev);
4002e604:	00048513          	mv	a0,s1
4002e608:	000780e7          	jalr	a5
				if (rc != 0) {
4002e60c:	02050063          	beqz	a0,4002e62c <z_sys_init_run_level+0x98>
					if (rc < 0) {
4002e610:	41f55793          	srai	a5,a0,0x1f
4002e614:	00a7c533          	xor	a0,a5,a0
4002e618:	40f50533          	sub	a0,a0,a5
					dev->state->init_res = rc;
4002e61c:	00c4a703          	lw	a4,12(s1)
					if (rc > UINT8_MAX) {
4002e620:	00a9d463          	bge	s3,a0,4002e628 <z_sys_init_run_level+0x94>
4002e624:	0ff00513          	li	a0,255
					dev->state->init_res = rc;
4002e628:	00a70023          	sb	a0,0(a4)
			dev->state->initialized = true;
4002e62c:	00c4a703          	lw	a4,12(s1)
4002e630:	00174783          	lbu	a5,1(a4)
4002e634:	0017e793          	ori	a5,a5,1
4002e638:	00f700a3          	sb	a5,1(a4)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
4002e63c:	00840413          	addi	s0,s0,8
4002e640:	f95ff06f          	j	4002e5d4 <z_sys_init_run_level+0x40>
			(void)entry->init_fn.sys();
4002e644:	000780e7          	jalr	a5
4002e648:	ff5ff06f          	j	4002e63c <z_sys_init_run_level+0xa8>

4002e64c <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
4002e64c:	ff010113          	addi	sp,sp,-16
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
4002e650:	400397b7          	lui	a5,0x40039
4002e654:	00100713          	li	a4,1

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
4002e658:	00300513          	li	a0,3
{
4002e65c:	00112623          	sw	ra,12(sp)
	z_sys_post_kernel = true;
4002e660:	10e786a3          	sb	a4,269(a5) # 4003910d <z_sys_post_kernel>
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
4002e664:	f31ff0ef          	jal	ra,4002e594 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
4002e668:	3c1030ef          	jal	ra,40032228 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
4002e66c:	00400513          	li	a0,4
4002e670:	f25ff0ef          	jal	ra,4002e594 <z_sys_init_run_level>

	z_init_static_threads();
4002e674:	1c1000ef          	jal	ra,4002f034 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
4002e678:	c58d20ef          	jal	ra,40000ad0 <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
4002e67c:	4003a7b7          	lui	a5,0x4003a
4002e680:	f2078793          	addi	a5,a5,-224 # 40039f20 <z_main_thread>
4002e684:	00c7c703          	lbu	a4,12(a5)
4002e688:	ffe77713          	andi	a4,a4,-2
4002e68c:	00e78623          	sb	a4,12(a5)

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
4002e690:	00c12083          	lw	ra,12(sp)
4002e694:	01010113          	addi	sp,sp,16
4002e698:	00008067          	ret

4002e69c <z_early_memset>:
	(void) memset(dst, c, n);
4002e69c:	e80de06f          	j	4000cd1c <memset>

4002e6a0 <z_bss_zero>:
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
4002e6a0:	40039537          	lui	a0,0x40039
4002e6a4:	4003b7b7          	lui	a5,0x4003b
4002e6a8:	fc050613          	addi	a2,a0,-64 # 40038fc0 <last_failure_report>
4002e6ac:	1e878793          	addi	a5,a5,488 # 4003b1e8 <sched_spinlock>
4002e6b0:	40c78633          	sub	a2,a5,a2
4002e6b4:	00000593          	li	a1,0
4002e6b8:	fc050513          	addi	a0,a0,-64
4002e6bc:	fe1ff06f          	j	4002e69c <z_early_memset>

4002e6c0 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
4002e6c0:	fe010113          	addi	sp,sp,-32
4002e6c4:	01212823          	sw	s2,16(sp)
	struct k_thread *thread = &z_idle_threads[i];
4002e6c8:	0c800913          	li	s2,200
4002e6cc:	03250933          	mul	s2,a0,s2
{
4002e6d0:	00912a23          	sw	s1,20(sp)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
4002e6d4:	01400493          	li	s1,20
	struct k_thread *thread = &z_idle_threads[i];
4002e6d8:	4003a7b7          	lui	a5,0x4003a
4002e6dc:	e5878793          	addi	a5,a5,-424 # 40039e58 <z_idle_threads>
	z_setup_new_thread(thread, stack,
4002e6e0:	4003d5b7          	lui	a1,0x4003d
{
4002e6e4:	00812c23          	sw	s0,24(sp)
	z_setup_new_thread(thread, stack,
4002e6e8:	4002f6b7          	lui	a3,0x4002f
{
4002e6ec:	00050413          	mv	s0,a0
	z_setup_new_thread(thread, stack,
4002e6f0:	1d058593          	addi	a1,a1,464 # 4003d1d0 <z_idle_stacks>
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
4002e6f4:	029504b3          	mul	s1,a0,s1
	struct k_thread *thread = &z_idle_threads[i];
4002e6f8:	00f90933          	add	s2,s2,a5
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
4002e6fc:	4003b7b7          	lui	a5,0x4003b
4002e700:	1c478793          	addi	a5,a5,452 # 4003b1c4 <_kernel>
	k_thread_stack_t *stack = z_idle_stacks[i];
4002e704:	00951513          	slli	a0,a0,0x9
	z_setup_new_thread(thread, stack,
4002e708:	00a585b3          	add	a1,a1,a0
4002e70c:	00f00893          	li	a7,15
4002e710:	00090513          	mv	a0,s2
4002e714:	00000813          	li	a6,0
4002e718:	19468693          	addi	a3,a3,404 # 4002f194 <idle>
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
4002e71c:	00f484b3          	add	s1,s1,a5
	z_setup_new_thread(thread, stack,
4002e720:	400397b7          	lui	a5,0x40039
4002e724:	eb878793          	addi	a5,a5,-328 # 40038eb8 <CSWTCH.407+0x14>
4002e728:	00f12223          	sw	a5,4(sp)
4002e72c:	00100793          	li	a5,1
4002e730:	00f12023          	sw	a5,0(sp)
4002e734:	00048713          	mv	a4,s1
4002e738:	00000793          	li	a5,0
4002e73c:	20000613          	li	a2,512
{
4002e740:	00112e23          	sw	ra,28(sp)
	z_setup_new_thread(thread, stack,
4002e744:	71c000ef          	jal	ra,4002ee60 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
4002e748:	00d94783          	lbu	a5,13(s2)
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
4002e74c:	00848823          	sb	s0,16(s1)
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
4002e750:	00140413          	addi	s0,s0,1
4002e754:	ffb7f793          	andi	a5,a5,-5
4002e758:	00f906a3          	sb	a5,13(s2)
4002e75c:	4003d7b7          	lui	a5,0x4003d
4002e760:	00b41413          	slli	s0,s0,0xb
4002e764:	9d078793          	addi	a5,a5,-1584 # 4003c9d0 <z_interrupt_stacks>
4002e768:	00f40433          	add	s0,s0,a5
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
4002e76c:	0124a623          	sw	s2,12(s1)
	_kernel.cpus[id].irq_stack =
4002e770:	0084a223          	sw	s0,4(s1)
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
4002e774:	01c12083          	lw	ra,28(sp)
4002e778:	01812403          	lw	s0,24(sp)
4002e77c:	01412483          	lw	s1,20(sp)
4002e780:	01012903          	lw	s2,16(sp)
4002e784:	02010113          	addi	sp,sp,32
4002e788:	00008067          	ret

4002e78c <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
4002e78c:	f0010113          	addi	sp,sp,-256
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
4002e790:	00000513          	li	a0,0
{
4002e794:	0e112e23          	sw	ra,252(sp)
4002e798:	0e812c23          	sw	s0,248(sp)
4002e79c:	0e912a23          	sw	s1,244(sp)
4002e7a0:	0f212823          	sw	s2,240(sp)
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif
#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
	k_thread_system_pool_assign(dummy_thread);
4002e7a4:	01810493          	addi	s1,sp,24
4002e7a8:	0f312623          	sw	s3,236(sp)

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
4002e7ac:	4003b437          	lui	s0,0x4003b
	z_sys_init_run_level(INIT_LEVEL_EARLY);
4002e7b0:	de5ff0ef          	jal	ra,4002e594 <z_sys_init_run_level>

	/* perform any architecture-specific initialization */
	arch_kernel_init();

	LOG_CORE_INIT();
4002e7b4:	e6dd50ef          	jal	ra,40004620 <log_core_init>
	dummy_thread->base.user_options = K_ESSENTIAL;
4002e7b8:	10100793          	li	a5,257
	k_thread_system_pool_assign(dummy_thread);
4002e7bc:	00048513          	mv	a0,s1
	_current_cpu->current = dummy_thread;
4002e7c0:	1c440413          	addi	s0,s0,452 # 4003b1c4 <_kernel>
	dummy_thread->base.user_options = K_ESSENTIAL;
4002e7c4:	02f11223          	sh	a5,36(sp)
	dummy_thread->stack_info.start = 0U;
4002e7c8:	0c012423          	sw	zero,200(sp)
	dummy_thread->stack_info.size = 0U;
4002e7cc:	0c012623          	sw	zero,204(sp)
	k_thread_system_pool_assign(dummy_thread);
4002e7d0:	1e9030ef          	jal	ra,400321b8 <k_thread_system_pool_assign>
	_current_cpu->current = dummy_thread;
4002e7d4:	00942423          	sw	s1,8(s0)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
4002e7d8:	b11ff0ef          	jal	ra,4002e2e8 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
4002e7dc:	00100513          	li	a0,1
4002e7e0:	db5ff0ef          	jal	ra,4002e594 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
4002e7e4:	00200513          	li	a0,2
4002e7e8:	dadff0ef          	jal	ra,4002e594 <z_sys_init_run_level>
	z_sched_init();
4002e7ec:	53c020ef          	jal	ra,40030d28 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
4002e7f0:	400397b7          	lui	a5,0x40039
4002e7f4:	ec078793          	addi	a5,a5,-320 # 40038ec0 <CSWTCH.407+0x1c>
	_kernel.ready_q.cache = &z_main_thread;
4002e7f8:	4003a4b7          	lui	s1,0x4003a
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
4002e7fc:	00f12223          	sw	a5,4(sp)
4002e800:	4002e6b7          	lui	a3,0x4002e
4002e804:	00100793          	li	a5,1
4002e808:	4003d5b7          	lui	a1,0x4003d
	_kernel.ready_q.cache = &z_main_thread;
4002e80c:	f2048913          	addi	s2,s1,-224 # 40039f20 <z_main_thread>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
4002e810:	00000893          	li	a7,0
4002e814:	00000813          	li	a6,0
4002e818:	00000713          	li	a4,0
4002e81c:	64c68693          	addi	a3,a3,1612 # 4002e64c <bg_thread_main>
4002e820:	40000613          	li	a2,1024
4002e824:	3d058593          	addi	a1,a1,976 # 4003d3d0 <z_main_stack>
4002e828:	00f12023          	sw	a5,0(sp)
4002e82c:	f2048513          	addi	a0,s1,-224
4002e830:	00000793          	li	a5,0
	_kernel.ready_q.cache = &z_main_thread;
4002e834:	01242a23          	sw	s2,20(s0)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
4002e838:	628000ef          	jal	ra,4002ee60 <z_setup_new_thread>
4002e83c:	00d94783          	lbu	a5,13(s2)
	z_ready_thread(&z_main_thread);
4002e840:	f2048513          	addi	a0,s1,-224
4002e844:	ffb7f793          	andi	a5,a5,-5
4002e848:	00f906a3          	sb	a5,13(s2)
4002e84c:	7a1010ef          	jal	ra,400307ec <z_ready_thread>
	z_init_cpu(0);
4002e850:	00000513          	li	a0,0
4002e854:	e6dff0ef          	jal	ra,4002e6c0 <z_init_cpu>
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002e858:	30047973          	csrrci	s2,mstatus,8
	old_thread = _current;
4002e85c:	00842983          	lw	s3,8(s0)
	old_thread->swap_retval = -EAGAIN;
4002e860:	ff500793          	li	a5,-11
4002e864:	0af9ae23          	sw	a5,188(s3)
4002e868:	300477f3          	csrrci	a5,mstatus,8
	new_thread = z_swap_next_thread();
4002e86c:	440020ef          	jal	ra,40030cac <z_swap_next_thread>
	if (new_thread != old_thread) {
4002e870:	00a98e63          	beq	s3,a0,4002e88c <z_cstart+0x100>
4002e874:	00050493          	mv	s1,a0
		_current_cpu->current = new_thread;
4002e878:	00a42423          	sw	a0,8(s0)
		z_reset_time_slice(new_thread);
4002e87c:	229010ef          	jal	ra,400302a4 <z_reset_time_slice>
	struct k_thread *old = CONTAINER_OF(switched_from, struct k_thread,
					    switch_handle);
#ifdef CONFIG_RISCV_ALWAYS_SWITCH_THROUGH_ECALL
	arch_syscall_invoke2((uintptr_t)new, (uintptr_t)old, RV_ECALL_SCHEDULE);
#else
	z_riscv_switch(new, old);
4002e880:	0c04a503          	lw	a0,192(s1)
4002e884:	00098593          	mv	a1,s3
4002e888:	e3ddd0ef          	jal	ra,4000c6c4 <z_riscv_switch>
			  : "r" (key & MSTATUS_IEN)
4002e88c:	00897913          	andi	s2,s2,8
	__asm__ volatile ("csrs mstatus, %0"
4002e890:	30092073          	csrs	mstatus,s2

4002e894 <k_heap_init>:
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
4002e894:	00c50713          	addi	a4,a0,12
	list->head = (sys_dnode_t *)list;
4002e898:	00e52623          	sw	a4,12(a0)
	list->tail = (sys_dnode_t *)list;
4002e89c:	00e52823          	sw	a4,16(a0)
#include <zephyr/linker/linker-defs.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
4002e8a0:	ea1d306f          	j	40002740 <sys_heap_init>

4002e8a4 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(void)
{
4002e8a4:	ff010113          	addi	sp,sp,-16
4002e8a8:	00812423          	sw	s0,8(sp)
4002e8ac:	00912223          	sw	s1,4(sp)
	STRUCT_SECTION_FOREACH(k_heap, h) {
4002e8b0:	40045437          	lui	s0,0x40045
4002e8b4:	400454b7          	lui	s1,0x40045
{
4002e8b8:	00112623          	sw	ra,12(sp)
	STRUCT_SECTION_FOREACH(k_heap, h) {
4002e8bc:	80c40413          	addi	s0,s0,-2036 # 4004480c <_system_heap>
4002e8c0:	82048493          	addi	s1,s1,-2016 # 40044820 <conn_lock>
4002e8c4:	00946e63          	bltu	s0,s1,4002e8e0 <statics_init+0x3c>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
4002e8c8:	00c12083          	lw	ra,12(sp)
4002e8cc:	00812403          	lw	s0,8(sp)
4002e8d0:	00412483          	lw	s1,4(sp)
4002e8d4:	00000513          	li	a0,0
4002e8d8:	01010113          	addi	sp,sp,16
4002e8dc:	00008067          	ret
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
4002e8e0:	00842603          	lw	a2,8(s0)
4002e8e4:	00442583          	lw	a1,4(s0)
4002e8e8:	00040513          	mv	a0,s0
	STRUCT_SECTION_FOREACH(k_heap, h) {
4002e8ec:	01440413          	addi	s0,s0,20
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
4002e8f0:	fa5ff0ef          	jal	ra,4002e894 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
4002e8f4:	fd1ff06f          	j	4002e8c4 <statics_init+0x20>

4002e8f8 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
4002e8f8:	fd010113          	addi	sp,sp,-48
4002e8fc:	01312e23          	sw	s3,28(sp)
4002e900:	01412c23          	sw	s4,24(sp)
4002e904:	00050993          	mv	s3,a0
4002e908:	00058a13          	mv	s4,a1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
4002e90c:	00068513          	mv	a0,a3
4002e910:	00070593          	mv	a1,a4
{
4002e914:	02812423          	sw	s0,40(sp)
4002e918:	02912223          	sw	s1,36(sp)
4002e91c:	03212023          	sw	s2,32(sp)
4002e920:	01512a23          	sw	s5,20(sp)
4002e924:	01612823          	sw	s6,16(sp)
4002e928:	02112623          	sw	ra,44(sp)
4002e92c:	01712623          	sw	s7,12(sp)
4002e930:	01812423          	sw	s8,8(sp)
4002e934:	00060a93          	mv	s5,a2
4002e938:	00068413          	mv	s0,a3
4002e93c:	00070b13          	mv	s6,a4
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
4002e940:	581020ef          	jal	ra,400316c0 <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
4002e944:	fff00793          	li	a5,-1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
4002e948:	00050913          	mv	s2,a0
4002e94c:	00058493          	mv	s1,a1
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
4002e950:	00f41a63          	bne	s0,a5,4002e964 <k_heap_aligned_alloc+0x6c>
4002e954:	008b1863          	bne	s6,s0,4002e964 <k_heap_aligned_alloc+0x6c>
4002e958:	800004b7          	lui	s1,0x80000
4002e95c:	fff00913          	li	s2,-1
4002e960:	fff48493          	addi	s1,s1,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>

	k_spinlock_key_t key = k_spin_lock(&h->lock);
4002e964:	01498b13          	addi	s6,s3,20
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002e968:	30047473          	csrrci	s0,mstatus,8
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
4002e96c:	00c98b93          	addi	s7,s3,12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
4002e970:	000a8613          	mv	a2,s5
4002e974:	000a0593          	mv	a1,s4
4002e978:	00098513          	mv	a0,s3
4002e97c:	bf5d30ef          	jal	ra,40002570 <sys_heap_aligned_alloc>
4002e980:	00050c13          	mv	s8,a0
		now = sys_clock_tick_get();
4002e984:	475020ef          	jal	ra,400315f8 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
4002e988:	040c0063          	beqz	s8,4002e9c8 <k_heap_aligned_alloc+0xd0>
			  : "r" (key & MSTATUS_IEN)
4002e98c:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrs mstatus, %0"
4002e990:	30042073          	csrs	mstatus,s0

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
4002e994:	02c12083          	lw	ra,44(sp)
4002e998:	02812403          	lw	s0,40(sp)
4002e99c:	02412483          	lw	s1,36(sp)
4002e9a0:	02012903          	lw	s2,32(sp)
4002e9a4:	01c12983          	lw	s3,28(sp)
4002e9a8:	01812a03          	lw	s4,24(sp)
4002e9ac:	01412a83          	lw	s5,20(sp)
4002e9b0:	01012b03          	lw	s6,16(sp)
4002e9b4:	00c12b83          	lw	s7,12(sp)
4002e9b8:	000c0513          	mv	a0,s8
4002e9bc:	00812c03          	lw	s8,8(sp)
4002e9c0:	03010113          	addi	sp,sp,48
4002e9c4:	00008067          	ret
		    (ret != NULL) || ((end - now) <= 0)) {
4002e9c8:	40a906b3          	sub	a3,s2,a0
4002e9cc:	00d937b3          	sltu	a5,s2,a3
4002e9d0:	40b48733          	sub	a4,s1,a1
4002e9d4:	40f70733          	sub	a4,a4,a5
4002e9d8:	00e04663          	bgtz	a4,4002e9e4 <k_heap_aligned_alloc+0xec>
4002e9dc:	fa0718e3          	bnez	a4,4002e98c <k_heap_aligned_alloc+0x94>
4002e9e0:	fa0686e3          	beqz	a3,4002e98c <k_heap_aligned_alloc+0x94>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
4002e9e4:	000b8613          	mv	a2,s7
4002e9e8:	00040593          	mv	a1,s0
4002e9ec:	000b0513          	mv	a0,s6
4002e9f0:	6dd010ef          	jal	ra,400308cc <z_pend_curr>
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002e9f4:	30047473          	csrrci	s0,mstatus,8
	z_spin_lock_set_owner(l);
#if defined(CONFIG_SPIN_LOCK_TIME_LIMIT) && (CONFIG_SPIN_LOCK_TIME_LIMIT != 0)
	l->lock_time = sys_clock_cycle_get_32();
#endif /* CONFIG_SPIN_LOCK_TIME_LIMIT */
#endif/* CONFIG_SPIN_VALIDATE */
	return k;
4002e9f8:	f79ff06f          	j	4002e970 <k_heap_aligned_alloc+0x78>

4002e9fc <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
4002e9fc:	ff010113          	addi	sp,sp,-16
4002ea00:	00912223          	sw	s1,4(sp)
4002ea04:	00112623          	sw	ra,12(sp)
4002ea08:	00812423          	sw	s0,8(sp)
4002ea0c:	00050493          	mv	s1,a0
4002ea10:	30047473          	csrrci	s0,mstatus,8
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
4002ea14:	a39d30ef          	jal	ra,4000244c <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
4002ea18:	00c48513          	addi	a0,s1,12
4002ea1c:	2bc020ef          	jal	ra,40030cd8 <z_unpend_all>
4002ea20:	02050063          	beqz	a0,4002ea40 <k_heap_free+0x44>
		z_reschedule(&h->lock, key);
4002ea24:	00040593          	mv	a1,s0
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
4002ea28:	00812403          	lw	s0,8(sp)
4002ea2c:	00c12083          	lw	ra,12(sp)
		z_reschedule(&h->lock, key);
4002ea30:	01448513          	addi	a0,s1,20
}
4002ea34:	00412483          	lw	s1,4(sp)
4002ea38:	01010113          	addi	sp,sp,16
		z_reschedule(&h->lock, key);
4002ea3c:	0bc0206f          	j	40030af8 <z_reschedule>
	__asm__ volatile ("csrs mstatus, %0"
4002ea40:	00847413          	andi	s0,s0,8
4002ea44:	30042073          	csrs	mstatus,s0
}
4002ea48:	00c12083          	lw	ra,12(sp)
4002ea4c:	00812403          	lw	s0,8(sp)
4002ea50:	00412483          	lw	s1,4(sp)
4002ea54:	01010113          	addi	sp,sp,16
4002ea58:	00008067          	ret

4002ea5c <create_free_list>:
{
	uint32_t j;
	char *p;

	/* blocks must be word aligned */
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
4002ea5c:	01052703          	lw	a4,16(a0)
4002ea60:	00c52783          	lw	a5,12(a0)
4002ea64:	00f767b3          	or	a5,a4,a5
4002ea68:	0037f793          	andi	a5,a5,3
4002ea6c:	02079a63          	bnez	a5,4002eaa0 <create_free_list+0x44>
				(sizeof(void *) - 1)) != 0U) {
		return -EINVAL;
	}

	slab->free_list = NULL;
4002ea70:	00052a23          	sw	zero,20(a0)
	p = slab->buffer;

	for (j = 0U; j < slab->num_blocks; j++) {
4002ea74:	00852683          	lw	a3,8(a0)
4002ea78:	00d7e663          	bltu	a5,a3,4002ea84 <create_free_list+0x28>
		*(char **)p = slab->free_list;
		slab->free_list = p;
		p += slab->block_size;
	}
	return 0;
4002ea7c:	00000513          	li	a0,0
4002ea80:	00008067          	ret
		*(char **)p = slab->free_list;
4002ea84:	01452683          	lw	a3,20(a0)
	for (j = 0U; j < slab->num_blocks; j++) {
4002ea88:	00178793          	addi	a5,a5,1
		*(char **)p = slab->free_list;
4002ea8c:	00d72023          	sw	a3,0(a4)
		p += slab->block_size;
4002ea90:	00c52683          	lw	a3,12(a0)
		slab->free_list = p;
4002ea94:	00e52a23          	sw	a4,20(a0)
		p += slab->block_size;
4002ea98:	00d70733          	add	a4,a4,a3
	for (j = 0U; j < slab->num_blocks; j++) {
4002ea9c:	fd9ff06f          	j	4002ea74 <create_free_list+0x18>
		return -EINVAL;
4002eaa0:	fea00513          	li	a0,-22
}
4002eaa4:	00008067          	ret

4002eaa8 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(void)
{
4002eaa8:	ff010113          	addi	sp,sp,-16
4002eaac:	00812423          	sw	s0,8(sp)
4002eab0:	00912223          	sw	s1,4(sp)
	int rc = 0;

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
4002eab4:	40044437          	lui	s0,0x40044
4002eab8:	400454b7          	lui	s1,0x40045
{
4002eabc:	00112623          	sw	ra,12(sp)
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
4002eac0:	7b840413          	addi	s0,s0,1976 # 400447b8 <rx_pkts>
	int rc = 0;
4002eac4:	00000513          	li	a0,0
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
4002eac8:	80c48493          	addi	s1,s1,-2036 # 4004480c <_system_heap>
4002eacc:	00946c63          	bltu	s0,s1,4002eae4 <init_mem_slab_module+0x3c>
		z_object_init(slab);
	}

out:
	return rc;
}
4002ead0:	00c12083          	lw	ra,12(sp)
4002ead4:	00812403          	lw	s0,8(sp)
4002ead8:	00412483          	lw	s1,4(sp)
4002eadc:	01010113          	addi	sp,sp,16
4002eae0:	00008067          	ret
		rc = create_free_list(slab);
4002eae4:	00040513          	mv	a0,s0
4002eae8:	f75ff0ef          	jal	ra,4002ea5c <create_free_list>
		if (rc < 0) {
4002eaec:	fe0542e3          	bltz	a0,4002ead0 <init_mem_slab_module+0x28>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
4002eaf0:	01c40413          	addi	s0,s0,28
4002eaf4:	fd9ff06f          	j	4002eacc <init_mem_slab_module+0x24>

4002eaf8 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
4002eaf8:	ff010113          	addi	sp,sp,-16
4002eafc:	00812423          	sw	s0,8(sp)
4002eb00:	00112623          	sw	ra,12(sp)
4002eb04:	00058413          	mv	s0,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002eb08:	300475f3          	csrrci	a1,mstatus,8
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
4002eb0c:	01452783          	lw	a5,20(a0)
4002eb10:	02078663          	beqz	a5,4002eb3c <k_mem_slab_alloc+0x44>
		/* take a free block */
		*mem = slab->free_list;
4002eb14:	00f42023          	sw	a5,0(s0)
		slab->free_list = *(char **)(slab->free_list);
4002eb18:	0007a783          	lw	a5,0(a5)
4002eb1c:	00f52a23          	sw	a5,20(a0)
		slab->num_used++;
4002eb20:	01852783          	lw	a5,24(a0)
4002eb24:	00178793          	addi	a5,a5,1
4002eb28:	00f52c23          	sw	a5,24(a0)

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
4002eb2c:	00000513          	li	a0,0
	__asm__ volatile ("csrs mstatus, %0"
4002eb30:	0085f593          	andi	a1,a1,8
4002eb34:	3005a073          	csrs	mstatus,a1

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
4002eb38:	0400006f          	j	4002eb78 <k_mem_slab_alloc+0x80>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
4002eb3c:	00d667b3          	or	a5,a2,a3
4002eb40:	00068713          	mv	a4,a3
4002eb44:	00079863          	bnez	a5,4002eb54 <k_mem_slab_alloc+0x5c>
		*mem = NULL;
4002eb48:	00042023          	sw	zero,0(s0)
		result = -ENOMEM;
4002eb4c:	ff400513          	li	a0,-12
4002eb50:	fe1ff06f          	j	4002eb30 <k_mem_slab_alloc+0x38>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
4002eb54:	00060693          	mv	a3,a2
4002eb58:	00050613          	mv	a2,a0
4002eb5c:	00850513          	addi	a0,a0,8
4002eb60:	56d010ef          	jal	ra,400308cc <z_pend_curr>
		if (result == 0) {
4002eb64:	00051a63          	bnez	a0,4002eb78 <k_mem_slab_alloc+0x80>
			*mem = _current->base.swap_data;
4002eb68:	4003b7b7          	lui	a5,0x4003b
4002eb6c:	1cc7a783          	lw	a5,460(a5) # 4003b1cc <_kernel+0x8>
4002eb70:	0147a783          	lw	a5,20(a5)
4002eb74:	00f42023          	sw	a5,0(s0)
}
4002eb78:	00c12083          	lw	ra,12(sp)
4002eb7c:	00812403          	lw	s0,8(sp)
4002eb80:	01010113          	addi	sp,sp,16
4002eb84:	00008067          	ret

4002eb88 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
4002eb88:	ff010113          	addi	sp,sp,-16
4002eb8c:	00812423          	sw	s0,8(sp)
4002eb90:	00912223          	sw	s1,4(sp)
4002eb94:	00112623          	sw	ra,12(sp)
4002eb98:	01212023          	sw	s2,0(sp)
4002eb9c:	00050413          	mv	s0,a0
4002eba0:	00058493          	mv	s1,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002eba4:	30047973          	csrrci	s2,mstatus,8
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
4002eba8:	01452783          	lw	a5,20(a0)
4002ebac:	02079e63          	bnez	a5,4002ebe8 <k_mem_slab_free+0x60>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
4002ebb0:	5b1010ef          	jal	ra,40030960 <z_unpend_first_thread>

		if (pending_thread != NULL) {
4002ebb4:	02050a63          	beqz	a0,4002ebe8 <k_mem_slab_free+0x60>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
4002ebb8:	0004a703          	lw	a4,0(s1)
 * z_swap() is in use it's a simple inline provided by the kernel.
 */
static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->swap_retval = value;
4002ebbc:	0a052e23          	sw	zero,188(a0)
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
4002ebc0:	00e52a23          	sw	a4,20(a0)
			z_ready_thread(pending_thread);
4002ebc4:	429010ef          	jal	ra,400307ec <z_ready_thread>
			z_reschedule(&slab->lock, key);
4002ebc8:	00840513          	addi	a0,s0,8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
4002ebcc:	00812403          	lw	s0,8(sp)
4002ebd0:	00c12083          	lw	ra,12(sp)
4002ebd4:	00412483          	lw	s1,4(sp)
			z_reschedule(&slab->lock, key);
4002ebd8:	00090593          	mv	a1,s2
}
4002ebdc:	00012903          	lw	s2,0(sp)
4002ebe0:	01010113          	addi	sp,sp,16
			z_reschedule(&slab->lock, key);
4002ebe4:	7150106f          	j	40030af8 <z_reschedule>
	**(char ***) mem = slab->free_list;
4002ebe8:	0004a783          	lw	a5,0(s1)
4002ebec:	01442703          	lw	a4,20(s0)
	__asm__ volatile ("csrs mstatus, %0"
4002ebf0:	00897913          	andi	s2,s2,8
4002ebf4:	00e7a023          	sw	a4,0(a5)
	slab->free_list = *(char **) mem;
4002ebf8:	0004a783          	lw	a5,0(s1)
4002ebfc:	00f42a23          	sw	a5,20(s0)
	slab->num_used--;
4002ec00:	01842783          	lw	a5,24(s0)
4002ec04:	fff78793          	addi	a5,a5,-1
4002ec08:	00f42c23          	sw	a5,24(s0)
4002ec0c:	30092073          	csrs	mstatus,s2
}
4002ec10:	00c12083          	lw	ra,12(sp)
4002ec14:	00812403          	lw	s0,8(sp)
4002ec18:	00412483          	lw	s1,4(sp)
4002ec1c:	00012903          	lw	s2,0(sp)
4002ec20:	01010113          	addi	sp,sp,16
4002ec24:	00008067          	ret

4002ec28 <k_thread_foreach>:

#define _FOREACH_STATIC_THREAD(thread_data)              \
	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data)

void k_thread_foreach(k_thread_user_cb_t user_cb, void *user_data)
{
4002ec28:	fe010113          	addi	sp,sp,-32
4002ec2c:	01212823          	sw	s2,16(sp)
4002ec30:	01312623          	sw	s3,12(sp)
4002ec34:	00112e23          	sw	ra,28(sp)
4002ec38:	00812c23          	sw	s0,24(sp)
4002ec3c:	00912a23          	sw	s1,20(sp)
4002ec40:	00050913          	mv	s2,a0
4002ec44:	00058993          	mv	s3,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002ec48:	300474f3          	csrrci	s1,mstatus,8
	 */
	key = k_spin_lock(&z_thread_monitor_lock);

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, foreach);

	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
4002ec4c:	4003b7b7          	lui	a5,0x4003b
4002ec50:	1e47a403          	lw	s0,484(a5) # 4003b1e4 <_kernel+0x20>
4002ec54:	02041463          	bnez	s0,4002ec7c <k_thread_foreach+0x54>
	__asm__ volatile ("csrs mstatus, %0"
4002ec58:	0084f493          	andi	s1,s1,8
4002ec5c:	3004a073          	csrs	mstatus,s1

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, foreach);

	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
}
4002ec60:	01c12083          	lw	ra,28(sp)
4002ec64:	01812403          	lw	s0,24(sp)
4002ec68:	01412483          	lw	s1,20(sp)
4002ec6c:	01012903          	lw	s2,16(sp)
4002ec70:	00c12983          	lw	s3,12(sp)
4002ec74:	02010113          	addi	sp,sp,32
4002ec78:	00008067          	ret
		user_cb(thread, user_data);
4002ec7c:	00040513          	mv	a0,s0
4002ec80:	00098593          	mv	a1,s3
4002ec84:	000900e7          	jalr	s2
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
4002ec88:	08842403          	lw	s0,136(s0)
4002ec8c:	fc9ff06f          	j	4002ec54 <k_thread_foreach+0x2c>

4002ec90 <k_is_in_isr>:
	bool ret = arch_curr_cpu()->nested != 0U;

	arch_irq_unlock(key);
	return ret;
#else
	return _kernel.cpus[0].nested != 0U;
4002ec90:	4003b7b7          	lui	a5,0x4003b
4002ec94:	1c47a503          	lw	a0,452(a5) # 4003b1c4 <_kernel>
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
4002ec98:	00a03533          	snez	a0,a0
4002ec9c:	00008067          	ret

4002eca0 <z_thread_monitor_exit>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002eca0:	300476f3          	csrrci	a3,mstatus,8
 */
void z_thread_monitor_exit(struct k_thread *thread)
{
	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	if (thread == _kernel.threads) {
4002eca4:	4003b737          	lui	a4,0x4003b
4002eca8:	1c470713          	addi	a4,a4,452 # 4003b1c4 <_kernel>
4002ecac:	02072783          	lw	a5,32(a4)
4002ecb0:	00a79e63          	bne	a5,a0,4002eccc <z_thread_monitor_exit+0x2c>
		_kernel.threads = _kernel.threads->next_thread;
4002ecb4:	0887a783          	lw	a5,136(a5)
4002ecb8:	02f72023          	sw	a5,32(a4)
	__asm__ volatile ("csrs mstatus, %0"
4002ecbc:	0086f693          	andi	a3,a3,8
4002ecc0:	3006a073          	csrs	mstatus,a3
			prev_thread->next_thread = thread->next_thread;
		}
	}

	k_spin_unlock(&z_thread_monitor_lock, key);
}
4002ecc4:	00008067          	ret
4002ecc8:	00070793          	mv	a5,a4
		while ((prev_thread != NULL) &&
4002eccc:	fe0788e3          	beqz	a5,4002ecbc <z_thread_monitor_exit+0x1c>
			(thread != prev_thread->next_thread)) {
4002ecd0:	0887a703          	lw	a4,136(a5)
		while ((prev_thread != NULL) &&
4002ecd4:	fea71ae3          	bne	a4,a0,4002ecc8 <z_thread_monitor_exit+0x28>
			prev_thread->next_thread = thread->next_thread;
4002ecd8:	08852703          	lw	a4,136(a0)
4002ecdc:	08e7a423          	sw	a4,136(a5)
4002ece0:	fddff06f          	j	4002ecbc <z_thread_monitor_exit+0x1c>

4002ece4 <z_impl_k_thread_name_set>:
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
4002ece4:	ff010113          	addi	sp,sp,-16
4002ece8:	00812423          	sw	s0,8(sp)
4002ecec:	00112623          	sw	ra,12(sp)
4002ecf0:	00050413          	mv	s0,a0
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
4002ecf4:	00051663          	bnez	a0,4002ed00 <z_impl_k_thread_name_set+0x1c>
		thread = _current;
4002ecf8:	4003b7b7          	lui	a5,0x4003b
4002ecfc:	1cc7a403          	lw	s0,460(a5) # 4003b1cc <_kernel+0x8>
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN - 1);
4002ed00:	08c40513          	addi	a0,s0,140
4002ed04:	01f00613          	li	a2,31
4002ed08:	e49dd0ef          	jal	ra,4000cb50 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
4002ed0c:	0a0405a3          	sb	zero,171(s0)

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
4002ed10:	00c12083          	lw	ra,12(sp)
4002ed14:	00812403          	lw	s0,8(sp)
4002ed18:	00000513          	li	a0,0
4002ed1c:	01010113          	addi	sp,sp,16
4002ed20:	00008067          	ret

4002ed24 <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
4002ed24:	08c50513          	addi	a0,a0,140
4002ed28:	00008067          	ret

4002ed2c <k_thread_state_str>:
	static const char  *states_str[8] = {"dummy", "pending", "prestart",
					     "dead", "suspended", "aborting",
					     "", "queued"};
	static const size_t states_sz[8] = {5, 7, 8, 4, 9, 8, 0, 6};

	if ((buf == NULL) || (buf_size == 0)) {
4002ed2c:	12058263          	beqz	a1,4002ee50 <k_thread_state_str+0x124>
4002ed30:	12060063          	beqz	a2,4002ee50 <k_thread_state_str+0x124>
{
4002ed34:	fd010113          	addi	sp,sp,-48
4002ed38:	02812423          	sw	s0,40(sp)
4002ed3c:	03212023          	sw	s2,32(sp)
4002ed40:	02112623          	sw	ra,44(sp)
4002ed44:	02912223          	sw	s1,36(sp)
4002ed48:	01312e23          	sw	s3,28(sp)
4002ed4c:	01412c23          	sw	s4,24(sp)
4002ed50:	01512a23          	sw	s5,20(sp)
4002ed54:	01612823          	sw	s6,16(sp)
4002ed58:	01712623          	sw	s7,12(sp)
4002ed5c:	01812423          	sw	s8,8(sp)
4002ed60:	01912223          	sw	s9,4(sp)
4002ed64:	01a12023          	sw	s10,0(sp)
	uint8_t     thread_state = thread_id->base.thread_state;
4002ed68:	00d54d03          	lbu	s10,13(a0)
		return "";
	}

	buf_size--;   /* Reserve 1 byte for end-of-string character */
4002ed6c:	00058413          	mv	s0,a1
4002ed70:	fff60913          	addi	s2,a2,-1
		bit = BIT(index);
		if ((thread_state & bit) == 0) {
			continue;
		}

		off += copy_bytes(buf + off, buf_size - off,
4002ed74:	00058513          	mv	a0,a1
	for (uint8_t index = 0; thread_state != 0; index++) {
4002ed78:	080d0c63          	beqz	s10,4002ee10 <k_thread_state_str+0xe4>
				  states_str[index], states_sz[index]);
4002ed7c:	40039ab7          	lui	s5,0x40039
		off += copy_bytes(buf + off, buf_size - off,
4002ed80:	40039b37          	lui	s6,0x40039
	for (uint8_t index = 0; thread_state != 0; index++) {
4002ed84:	00000993          	li	s3,0
	size_t      off = 0;
4002ed88:	00000493          	li	s1,0
		bit = BIT(index);
4002ed8c:	00100b93          	li	s7,1
				  states_str[index], states_sz[index]);
4002ed90:	ee8a8a93          	addi	s5,s5,-280 # 40038ee8 <states_sz.0>
		off += copy_bytes(buf + off, buf_size - off,
4002ed94:	f4cb0b13          	addi	s6,s6,-180 # 40038f4c <states_str.1>
	memcpy(dest, src, bytes_to_copy);
4002ed98:	40039c37          	lui	s8,0x40039
		bit = BIT(index);
4002ed9c:	013b9a33          	sll	s4,s7,s3
		if ((thread_state & bit) == 0) {
4002eda0:	014d77b3          	and	a5,s10,s4
4002eda4:	04078e63          	beqz	a5,4002ee00 <k_thread_state_str+0xd4>
				  states_str[index], states_sz[index]);
4002eda8:	00299793          	slli	a5,s3,0x2
4002edac:	00fa8733          	add	a4,s5,a5
	bytes_to_copy = MIN(dest_size, src_size);
4002edb0:	00072703          	lw	a4,0(a4)
4002edb4:	40990cb3          	sub	s9,s2,s1
4002edb8:	01977463          	bgeu	a4,s9,4002edc0 <k_thread_state_str+0x94>
4002edbc:	00070c93          	mv	s9,a4
		off += copy_bytes(buf + off, buf_size - off,
4002edc0:	00fb07b3          	add	a5,s6,a5
	memcpy(dest, src, bytes_to_copy);
4002edc4:	0007a583          	lw	a1,0(a5)
4002edc8:	000c8613          	mv	a2,s9

		thread_state &= ~bit;
4002edcc:	fffa4a13          	not	s4,s4
	memcpy(dest, src, bytes_to_copy);
4002edd0:	f29dd0ef          	jal	ra,4000ccf8 <memcpy>
		off += copy_bytes(buf + off, buf_size - off,
4002edd4:	009c84b3          	add	s1,s9,s1
		thread_state &= ~bit;
4002edd8:	014d7d33          	and	s10,s10,s4

		if (thread_state != 0) {
4002eddc:	00940533          	add	a0,s0,s1
4002ede0:	020d0863          	beqz	s10,4002ee10 <k_thread_state_str+0xe4>
			off += copy_bytes(buf + off, buf_size - off, "+", 1);
4002ede4:	40990a33          	sub	s4,s2,s1
	bytes_to_copy = MIN(dest_size, src_size);
4002ede8:	00990463          	beq	s2,s1,4002edf0 <k_thread_state_str+0xc4>
4002edec:	00100a13          	li	s4,1
	memcpy(dest, src, bytes_to_copy);
4002edf0:	000a0613          	mv	a2,s4
4002edf4:	ee4c0593          	addi	a1,s8,-284 # 40038ee4 <levels.0+0x1c>
4002edf8:	f01dd0ef          	jal	ra,4000ccf8 <memcpy>
			off += copy_bytes(buf + off, buf_size - off, "+", 1);
4002edfc:	014484b3          	add	s1,s1,s4
	for (uint8_t index = 0; thread_state != 0; index++) {
4002ee00:	00198993          	addi	s3,s3,1
4002ee04:	0ff9f993          	zext.b	s3,s3
		off += copy_bytes(buf + off, buf_size - off,
4002ee08:	00940533          	add	a0,s0,s1
4002ee0c:	f91ff06f          	j	4002ed9c <k_thread_state_str+0x70>
		}
	}

	buf[off] = '\0';
4002ee10:	00050023          	sb	zero,0(a0)

	return (const char *)buf;
}
4002ee14:	02c12083          	lw	ra,44(sp)
	return (const char *)buf;
4002ee18:	00040513          	mv	a0,s0
}
4002ee1c:	02812403          	lw	s0,40(sp)
4002ee20:	02412483          	lw	s1,36(sp)
4002ee24:	02012903          	lw	s2,32(sp)
4002ee28:	01c12983          	lw	s3,28(sp)
4002ee2c:	01812a03          	lw	s4,24(sp)
4002ee30:	01412a83          	lw	s5,20(sp)
4002ee34:	01012b03          	lw	s6,16(sp)
4002ee38:	00c12b83          	lw	s7,12(sp)
4002ee3c:	00812c03          	lw	s8,8(sp)
4002ee40:	00412c83          	lw	s9,4(sp)
4002ee44:	00012d03          	lw	s10,0(sp)
4002ee48:	03010113          	addi	sp,sp,48
4002ee4c:	00008067          	ret
		return "";
4002ee50:	40033537          	lui	a0,0x40033
4002ee54:	1e850513          	addi	a0,a0,488 # 400331e8 <severity_lvls+0xf0>
}
4002ee58:	00008067          	ret

4002ee5c <z_impl_k_thread_start>:

void z_impl_k_thread_start(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
4002ee5c:	4cd0106f          	j	40030b28 <z_sched_start>

4002ee60 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
4002ee60:	fd010113          	addi	sp,sp,-48
4002ee64:	02112623          	sw	ra,44(sp)
4002ee68:	02812423          	sw	s0,40(sp)
4002ee6c:	02912223          	sw	s1,36(sp)
4002ee70:	03212023          	sw	s2,32(sp)
4002ee74:	01312e23          	sw	s3,28(sp)
4002ee78:	01412c23          	sw	s4,24(sp)
4002ee7c:	01512a23          	sw	s5,20(sp)
4002ee80:	01612823          	sw	s6,16(sp)
4002ee84:	01712623          	sw	s7,12(sp)
4002ee88:	00078a13          	mv	s4,a5
4002ee8c:	06c50793          	addi	a5,a0,108
	list->head = (sys_dnode_t *)list;
4002ee90:	06f52623          	sw	a5,108(a0)
	list->tail = (sys_dnode_t *)list;
4002ee94:	06f52823          	sw	a5,112(a0)
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
4002ee98:	03012783          	lw	a5,48(sp)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
4002ee9c:	00f60613          	addi	a2,a2,15
{
4002eea0:	00058913          	mv	s2,a1
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
4002eea4:	ff067493          	andi	s1,a2,-16
	thread_base->user_options = (uint8_t)options;
4002eea8:	00f50623          	sb	a5,12(a0)
	thread_base->thread_state = (uint8_t)initial_state;
4002eeac:	00400793          	li	a5,4
{
4002eeb0:	00050413          	mv	s0,a0

	thread_base->prio = priority;
4002eeb4:	01150723          	sb	a7,14(a0)
	thread_base->thread_state = (uint8_t)initial_state;
4002eeb8:	00f506a3          	sb	a5,13(a0)
	stack_ptr = (char *)stack + stack_obj_size;
4002eebc:	00958bb3          	add	s7,a1,s1
	memset(stack_buf_start, 0xaa, stack_buf_size);
4002eec0:	00048613          	mv	a2,s1
	thread_base->pended_on = NULL;
4002eec4:	00052423          	sw	zero,8(a0)

	thread_base->sched_locked = 0U;
4002eec8:	000507a3          	sb	zero,15(a0)
	node->next = NULL;
4002eecc:	00052c23          	sw	zero,24(a0)
	node->prev = NULL;
4002eed0:	00052e23          	sw	zero,28(a0)
	memset(stack_buf_start, 0xaa, stack_buf_size);
4002eed4:	0aa00593          	li	a1,170
4002eed8:	00090513          	mv	a0,s2
{
4002eedc:	00068b13          	mv	s6,a3
4002eee0:	00070a93          	mv	s5,a4
4002eee4:	00080993          	mv	s3,a6
	memset(stack_buf_start, 0xaa, stack_buf_size);
4002eee8:	e35dd0ef          	jal	ra,4000cd1c <memset>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
4002eeec:	00098813          	mv	a6,s3
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
4002eef0:	0b242823          	sw	s2,176(s0)
	new_thread->stack_info.size = stack_buf_size;
4002eef4:	0a942a23          	sw	s1,180(s0)
	new_thread->stack_info.delta = delta;
4002eef8:	0a042c23          	sw	zero,184(s0)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
4002eefc:	000a0793          	mv	a5,s4
4002ef00:	000a8713          	mv	a4,s5
4002ef04:	000b0693          	mv	a3,s6
4002ef08:	000b8613          	mv	a2,s7
4002ef0c:	00090593          	mv	a1,s2
4002ef10:	00040513          	mv	a0,s0
4002ef14:	829dd0ef          	jal	ra,4000c73c <arch_new_thread>
	new_thread->init_data = NULL;
4002ef18:	06042423          	sw	zero,104(s0)
	new_thread->entry.pEntry = entry;
4002ef1c:	07642c23          	sw	s6,120(s0)
	new_thread->entry.parameter1 = p1;
4002ef20:	07542e23          	sw	s5,124(s0)
	new_thread->entry.parameter2 = p2;
4002ef24:	09442023          	sw	s4,128(s0)
	new_thread->entry.parameter3 = p3;
4002ef28:	09342223          	sw	s3,132(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002ef2c:	30047773          	csrrci	a4,mstatus,8
	new_thread->next_thread = _kernel.threads;
4002ef30:	4003b7b7          	lui	a5,0x4003b
4002ef34:	1c478693          	addi	a3,a5,452 # 4003b1c4 <_kernel>
4002ef38:	0206a603          	lw	a2,32(a3)
	__asm__ volatile ("csrs mstatus, %0"
4002ef3c:	00877713          	andi	a4,a4,8
	_kernel.threads = new_thread;
4002ef40:	0286a023          	sw	s0,32(a3)
	new_thread->next_thread = _kernel.threads;
4002ef44:	08c42423          	sw	a2,136(s0)
4002ef48:	30072073          	csrs	mstatus,a4
	if (name != NULL) {
4002ef4c:	1c478493          	addi	s1,a5,452
4002ef50:	03412783          	lw	a5,52(sp)
4002ef54:	04078a63          	beqz	a5,4002efa8 <z_setup_new_thread+0x148>
		strncpy(new_thread->name, name,
4002ef58:	01f00613          	li	a2,31
4002ef5c:	00078593          	mv	a1,a5
4002ef60:	08c40513          	addi	a0,s0,140
4002ef64:	beddd0ef          	jal	ra,4000cb50 <strncpy>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
4002ef68:	0a0405a3          	sb	zero,171(s0)
	new_thread->resource_pool = _current->resource_pool;
4002ef6c:	0084a783          	lw	a5,8(s1)
}
4002ef70:	000b8513          	mv	a0,s7
	new_thread->resource_pool = _current->resource_pool;
4002ef74:	0c47a783          	lw	a5,196(a5)
4002ef78:	0cf42223          	sw	a5,196(s0)
}
4002ef7c:	02c12083          	lw	ra,44(sp)
4002ef80:	02812403          	lw	s0,40(sp)
4002ef84:	02412483          	lw	s1,36(sp)
4002ef88:	02012903          	lw	s2,32(sp)
4002ef8c:	01c12983          	lw	s3,28(sp)
4002ef90:	01812a03          	lw	s4,24(sp)
4002ef94:	01412a83          	lw	s5,20(sp)
4002ef98:	01012b03          	lw	s6,16(sp)
4002ef9c:	00c12b83          	lw	s7,12(sp)
4002efa0:	03010113          	addi	sp,sp,48
4002efa4:	00008067          	ret
		new_thread->name[0] = '\0';
4002efa8:	08040623          	sb	zero,140(s0)
4002efac:	fc1ff06f          	j	4002ef6c <z_setup_new_thread+0x10c>

4002efb0 <z_impl_k_thread_create>:
{
4002efb0:	fe010113          	addi	sp,sp,-32
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
4002efb4:	02012303          	lw	t1,32(sp)
{
4002efb8:	01212823          	sw	s2,16(sp)
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
4002efbc:	00012223          	sw	zero,4(sp)
{
4002efc0:	02812903          	lw	s2,40(sp)
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
4002efc4:	00612023          	sw	t1,0(sp)
{
4002efc8:	00812c23          	sw	s0,24(sp)
4002efcc:	00912a23          	sw	s1,20(sp)
4002efd0:	00112e23          	sw	ra,28(sp)
4002efd4:	02c12483          	lw	s1,44(sp)
4002efd8:	00050413          	mv	s0,a0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
4002efdc:	e85ff0ef          	jal	ra,4002ee60 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
4002efe0:	fff00693          	li	a3,-1
4002efe4:	00d91463          	bne	s2,a3,4002efec <z_impl_k_thread_create+0x3c>
4002efe8:	01248a63          	beq	s1,s2,4002effc <z_impl_k_thread_create+0x4c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
4002efec:	0124e7b3          	or	a5,s1,s2
4002eff0:	02079463          	bnez	a5,4002f018 <z_impl_k_thread_create+0x68>
	z_sched_start(thread);
4002eff4:	00040513          	mv	a0,s0
4002eff8:	331010ef          	jal	ra,40030b28 <z_sched_start>
}
4002effc:	01c12083          	lw	ra,28(sp)
4002f000:	00040513          	mv	a0,s0
4002f004:	01812403          	lw	s0,24(sp)
4002f008:	01412483          	lw	s1,20(sp)
4002f00c:	01012903          	lw	s2,16(sp)
4002f010:	02010113          	addi	sp,sp,32
4002f014:	00008067          	ret

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
4002f018:	400315b7          	lui	a1,0x40031
4002f01c:	00090613          	mv	a2,s2
4002f020:	00048693          	mv	a3,s1
4002f024:	8c058593          	addi	a1,a1,-1856 # 400308c0 <z_thread_timeout>
4002f028:	01840513          	addi	a0,s0,24
4002f02c:	27c020ef          	jal	ra,400312a8 <z_add_timeout>
4002f030:	fcdff06f          	j	4002effc <z_impl_k_thread_create+0x4c>

4002f034 <z_init_static_threads>:
{
4002f034:	fd010113          	addi	sp,sp,-48
	_FOREACH_STATIC_THREAD(thread_data) {
4002f038:	400327b7          	lui	a5,0x40032
{
4002f03c:	03212023          	sw	s2,32(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
4002f040:	40032937          	lui	s2,0x40032
{
4002f044:	02812423          	sw	s0,40(sp)
4002f048:	02912223          	sw	s1,36(sp)
4002f04c:	02112623          	sw	ra,44(sp)
4002f050:	01312e23          	sw	s3,28(sp)
4002f054:	01412c23          	sw	s4,24(sp)
4002f058:	01512a23          	sw	s5,20(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
4002f05c:	3d478413          	addi	s0,a5,980 # 400323d4 <__devicehdl_dts_ord_12>
4002f060:	3d478493          	addi	s1,a5,980
4002f064:	3d490913          	addi	s2,s2,980 # 400323d4 <__devicehdl_dts_ord_12>
4002f068:	05246063          	bltu	s0,s2,4002f0a8 <z_init_static_threads+0x74>
	k_sched_lock();
4002f06c:	3d9010ef          	jal	ra,40030c44 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
4002f070:	00048413          	mv	s0,s1
		if (thread_data->init_delay != K_TICKS_FOREVER) {
4002f074:	fff00993          	li	s3,-1
		t += off;
4002f078:	00900a13          	li	s4,9
4002f07c:	40031ab7          	lui	s5,0x40031
	_FOREACH_STATIC_THREAD(thread_data) {
4002f080:	07246663          	bltu	s0,s2,4002f0ec <z_init_static_threads+0xb8>
}
4002f084:	02812403          	lw	s0,40(sp)
4002f088:	02c12083          	lw	ra,44(sp)
4002f08c:	02412483          	lw	s1,36(sp)
4002f090:	02012903          	lw	s2,32(sp)
4002f094:	01c12983          	lw	s3,28(sp)
4002f098:	01812a03          	lw	s4,24(sp)
4002f09c:	01412a83          	lw	s5,20(sp)
4002f0a0:	03010113          	addi	sp,sp,48
	k_sched_unlock();
4002f0a4:	3c50106f          	j	40030c68 <k_sched_unlock>
		z_setup_new_thread(
4002f0a8:	02842783          	lw	a5,40(s0)
4002f0ac:	00f12223          	sw	a5,4(sp)
4002f0b0:	02042783          	lw	a5,32(s0)
4002f0b4:	00f12023          	sw	a5,0(sp)
4002f0b8:	01442783          	lw	a5,20(s0)
4002f0bc:	01c42883          	lw	a7,28(s0)
4002f0c0:	01842803          	lw	a6,24(s0)
4002f0c4:	01042703          	lw	a4,16(s0)
4002f0c8:	00c42683          	lw	a3,12(s0)
4002f0cc:	00842603          	lw	a2,8(s0)
4002f0d0:	00442583          	lw	a1,4(s0)
4002f0d4:	00042503          	lw	a0,0(s0)
4002f0d8:	d89ff0ef          	jal	ra,4002ee60 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
4002f0dc:	00042783          	lw	a5,0(s0)
4002f0e0:	0687a423          	sw	s0,104(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
4002f0e4:	02c40413          	addi	s0,s0,44
4002f0e8:	f81ff06f          	j	4002f068 <z_init_static_threads+0x34>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
4002f0ec:	02442783          	lw	a5,36(s0)
4002f0f0:	03378863          	beq	a5,s3,4002f120 <z_init_static_threads+0xec>
			schedule_new_thread(thread_data->init_thread,
4002f0f4:	00042483          	lw	s1,0(s0)
					    K_MSEC(thread_data->init_delay));
4002f0f8:	0007d463          	bgez	a5,4002f100 <z_init_static_threads+0xcc>
4002f0fc:	00000793          	li	a5,0
4002f100:	00978513          	addi	a0,a5,9
4002f104:	41f7d713          	srai	a4,a5,0x1f
4002f108:	00f535b3          	sltu	a1,a0,a5
4002f10c:	00e585b3          	add	a1,a1,a4
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
4002f110:	01451c63          	bne	a0,s4,4002f128 <z_init_static_threads+0xf4>
4002f114:	00059a63          	bnez	a1,4002f128 <z_init_static_threads+0xf4>
	z_sched_start(thread);
4002f118:	00048513          	mv	a0,s1
4002f11c:	20d010ef          	jal	ra,40030b28 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
4002f120:	02c40413          	addi	s0,s0,44
4002f124:	f5dff06f          	j	4002f080 <z_init_static_threads+0x4c>
			return t / ((uint64_t)from_hz / to_hz);
4002f128:	00a00613          	li	a2,10
4002f12c:	00000693          	li	a3,0
4002f130:	988d10ef          	jal	ra,400002b8 <__udivdi3>
4002f134:	00050613          	mv	a2,a0
4002f138:	00058693          	mv	a3,a1
4002f13c:	01848513          	addi	a0,s1,24
4002f140:	8c0a8593          	addi	a1,s5,-1856 # 400308c0 <z_thread_timeout>
4002f144:	164020ef          	jal	ra,400312a8 <z_add_timeout>
4002f148:	fd9ff06f          	j	4002f120 <z_init_static_threads+0xec>

4002f14c <z_stack_space_get>:
#error "Unsupported configuration for stack analysis"
#endif

int z_stack_space_get(const uint8_t *stack_start, size_t size, size_t *unused_ptr)
{
	size_t unused = 0;
4002f14c:	00000793          	li	a5,0
		checked_stack += 4;
		size -= 4;
	}

	for (size_t i = 0; i < size; i++) {
		if ((checked_stack[i]) == 0xaaU) {
4002f150:	0aa00713          	li	a4,170
	for (size_t i = 0; i < size; i++) {
4002f154:	00b79863          	bne	a5,a1,4002f164 <z_stack_space_get+0x18>
		} else {
			break;
		}
	}

	*unused_ptr = unused;
4002f158:	00f62023          	sw	a5,0(a2)

	return 0;
}
4002f15c:	00000513          	li	a0,0
4002f160:	00008067          	ret
		if ((checked_stack[i]) == 0xaaU) {
4002f164:	00f506b3          	add	a3,a0,a5
4002f168:	0006c683          	lbu	a3,0(a3)
4002f16c:	fee696e3          	bne	a3,a4,4002f158 <z_stack_space_get+0xc>
			unused++;
4002f170:	00178793          	addi	a5,a5,1
	for (size_t i = 0; i < size; i++) {
4002f174:	fe1ff06f          	j	4002f154 <z_stack_space_get+0x8>

4002f178 <z_impl_k_thread_stack_space_get>:

int z_impl_k_thread_stack_space_get(const struct k_thread *thread,
				    size_t *unused_ptr)
{
4002f178:	00058613          	mv	a2,a1
	return z_stack_space_get((const uint8_t *)thread->stack_info.start,
4002f17c:	0b452583          	lw	a1,180(a0)
4002f180:	0b052503          	lw	a0,176(a0)
4002f184:	fc9ff06f          	j	4002f14c <z_stack_space_get>

4002f188 <sys_kernel_version_get>:
 * @return kernel version
 */
uint32_t sys_kernel_version_get(void)
{
	return KERNELVERSION;
}
4002f188:	03036537          	lui	a0,0x3036
4002f18c:	30050513          	addi	a0,a0,768 # 3036300 <__rom_region_size+0x2ffd344>
4002f190:	00008067          	ret

4002f194 <idle>:
	sys_clock_idle_exit();
#endif
}

void idle(void *unused1, void *unused2, void *unused3)
{
4002f194:	ff010113          	addi	sp,sp,-16
4002f198:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002f19c:	300477f3          	csrrci	a5,mstatus,8
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
4002f1a0:	f51dc0ef          	jal	ra,4000c0f0 <arch_cpu_idle>
4002f1a4:	ff9ff06f          	j	4002f19c <idle+0x8>

4002f1a8 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
4002f1a8:	fd010113          	addi	sp,sp,-48
4002f1ac:	02812423          	sw	s0,40(sp)
4002f1b0:	01312e23          	sw	s3,28(sp)
4002f1b4:	02112623          	sw	ra,44(sp)
4002f1b8:	02912223          	sw	s1,36(sp)
4002f1bc:	03212023          	sw	s2,32(sp)
4002f1c0:	00050413          	mv	s0,a0
4002f1c4:	00068713          	mv	a4,a3

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
4002f1c8:	00850993          	addi	s3,a0,8
4002f1cc:	30047973          	csrrci	s2,mstatus,8

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
4002f1d0:	02052683          	lw	a3,32(a0)
4002f1d4:	00c52783          	lw	a5,12(a0)
4002f1d8:	0af6f663          	bgeu	a3,a5,4002f284 <z_impl_k_msgq_put+0xdc>
4002f1dc:	00b12623          	sw	a1,12(sp)
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
4002f1e0:	780010ef          	jal	ra,40030960 <z_unpend_first_thread>
4002f1e4:	00842603          	lw	a2,8(s0)
		if (pending_thread != NULL) {
4002f1e8:	00c12583          	lw	a1,12(sp)
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
4002f1ec:	00050493          	mv	s1,a0
		if (pending_thread != NULL) {
4002f1f0:	04050263          	beqz	a0,4002f234 <z_impl_k_msgq_put+0x8c>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, 0);

			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
4002f1f4:	01452503          	lw	a0,20(a0)
4002f1f8:	b01dd0ef          	jal	ra,4000ccf8 <memcpy>
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
4002f1fc:	00048513          	mv	a0,s1
	thread->swap_retval = value;
4002f200:	0a04ae23          	sw	zero,188(s1)
4002f204:	5e8010ef          	jal	ra,400307ec <z_ready_thread>
			z_reschedule(&msgq->lock, key);
4002f208:	00098513          	mv	a0,s3
4002f20c:	00090593          	mv	a1,s2
4002f210:	0e9010ef          	jal	ra,40030af8 <z_reschedule>
			return 0;
4002f214:	00000513          	li	a0,0
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
4002f218:	02c12083          	lw	ra,44(sp)
4002f21c:	02812403          	lw	s0,40(sp)
4002f220:	02412483          	lw	s1,36(sp)
4002f224:	02012903          	lw	s2,32(sp)
4002f228:	01c12983          	lw	s3,28(sp)
4002f22c:	03010113          	addi	sp,sp,48
4002f230:	00008067          	ret
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
4002f234:	01c42503          	lw	a0,28(s0)
4002f238:	ac1dd0ef          	jal	ra,4000ccf8 <memcpy>
			msgq->write_ptr += msgq->msg_size;
4002f23c:	01c42783          	lw	a5,28(s0)
4002f240:	00842703          	lw	a4,8(s0)
4002f244:	00e787b3          	add	a5,a5,a4
			if (msgq->write_ptr == msgq->buffer_end) {
4002f248:	01442703          	lw	a4,20(s0)
			msgq->write_ptr += msgq->msg_size;
4002f24c:	00f42e23          	sw	a5,28(s0)
			if (msgq->write_ptr == msgq->buffer_end) {
4002f250:	00e79663          	bne	a5,a4,4002f25c <z_impl_k_msgq_put+0xb4>
				msgq->write_ptr = msgq->buffer_start;
4002f254:	01042783          	lw	a5,16(s0)
4002f258:	00f42e23          	sw	a5,28(s0)
			msgq->used_msgs++;
4002f25c:	02042783          	lw	a5,32(s0)
	z_handle_obj_poll_events(&msgq->poll_events, state);
4002f260:	02440513          	addi	a0,s0,36
4002f264:	01000593          	li	a1,16
			msgq->used_msgs++;
4002f268:	00178793          	addi	a5,a5,1
4002f26c:	02f42023          	sw	a5,32(s0)
	z_handle_obj_poll_events(&msgq->poll_events, state);
4002f270:	5fd020ef          	jal	ra,4003206c <z_handle_obj_poll_events>
		result = 0;
4002f274:	00000513          	li	a0,0
	__asm__ volatile ("csrs mstatus, %0"
4002f278:	00897913          	andi	s2,s2,8
4002f27c:	30092073          	csrs	mstatus,s2
	return result;
4002f280:	f99ff06f          	j	4002f218 <z_impl_k_msgq_put+0x70>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
4002f284:	00e667b3          	or	a5,a2,a4
		result = -ENOMSG;
4002f288:	fdd00513          	li	a0,-35
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
4002f28c:	fe0786e3          	beqz	a5,4002f278 <z_impl_k_msgq_put+0xd0>
		_current->base.swap_data = (void *) data;
4002f290:	4003b7b7          	lui	a5,0x4003b
4002f294:	1cc7a783          	lw	a5,460(a5) # 4003b1cc <_kernel+0x8>
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
4002f298:	00060693          	mv	a3,a2
4002f29c:	00040613          	mv	a2,s0
		_current->base.swap_data = (void *) data;
4002f2a0:	00b7aa23          	sw	a1,20(a5)
}
4002f2a4:	02812403          	lw	s0,40(sp)
4002f2a8:	02c12083          	lw	ra,44(sp)
4002f2ac:	02412483          	lw	s1,36(sp)
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
4002f2b0:	00090593          	mv	a1,s2
4002f2b4:	00098513          	mv	a0,s3
}
4002f2b8:	02012903          	lw	s2,32(sp)
4002f2bc:	01c12983          	lw	s3,28(sp)
4002f2c0:	03010113          	addi	sp,sp,48
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
4002f2c4:	6080106f          	j	400308cc <z_pend_curr>

4002f2c8 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
4002f2c8:	fe010113          	addi	sp,sp,-32
4002f2cc:	00812c23          	sw	s0,24(sp)
4002f2d0:	00050413          	mv	s0,a0
4002f2d4:	01312623          	sw	s3,12(sp)
4002f2d8:	00112e23          	sw	ra,28(sp)
4002f2dc:	00912a23          	sw	s1,20(sp)
4002f2e0:	01212823          	sw	s2,16(sp)
4002f2e4:	00058513          	mv	a0,a1

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
4002f2e8:	00840993          	addi	s3,s0,8
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002f2ec:	30047973          	csrrci	s2,mstatus,8

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
4002f2f0:	02042783          	lw	a5,32(s0)
4002f2f4:	0c078463          	beqz	a5,4002f3bc <z_impl_k_msgq_get+0xf4>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
4002f2f8:	00842603          	lw	a2,8(s0)
4002f2fc:	01842583          	lw	a1,24(s0)
4002f300:	9f9dd0ef          	jal	ra,4000ccf8 <memcpy>
		msgq->read_ptr += msgq->msg_size;
4002f304:	01842783          	lw	a5,24(s0)
4002f308:	00842703          	lw	a4,8(s0)
4002f30c:	00e787b3          	add	a5,a5,a4
		if (msgq->read_ptr == msgq->buffer_end) {
4002f310:	01442703          	lw	a4,20(s0)
		msgq->read_ptr += msgq->msg_size;
4002f314:	00f42c23          	sw	a5,24(s0)
		if (msgq->read_ptr == msgq->buffer_end) {
4002f318:	00e79663          	bne	a5,a4,4002f324 <z_impl_k_msgq_get+0x5c>
			msgq->read_ptr = msgq->buffer_start;
4002f31c:	01042783          	lw	a5,16(s0)
4002f320:	00f42c23          	sw	a5,24(s0)
		}
		msgq->used_msgs--;
4002f324:	02042783          	lw	a5,32(s0)

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
4002f328:	00040513          	mv	a0,s0
		msgq->used_msgs--;
4002f32c:	fff78793          	addi	a5,a5,-1
4002f330:	02f42023          	sw	a5,32(s0)
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
4002f334:	62c010ef          	jal	ra,40030960 <z_unpend_first_thread>
4002f338:	00050493          	mv	s1,a0

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
		}
		result = 0;
4002f33c:	00000793          	li	a5,0
		if (pending_thread != NULL) {
4002f340:	0c050263          	beqz	a0,4002f404 <z_impl_k_msgq_get+0x13c>
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
4002f344:	01452583          	lw	a1,20(a0)
4002f348:	00842603          	lw	a2,8(s0)
4002f34c:	01c42503          	lw	a0,28(s0)
4002f350:	9a9dd0ef          	jal	ra,4000ccf8 <memcpy>
			msgq->write_ptr += msgq->msg_size;
4002f354:	01c42783          	lw	a5,28(s0)
4002f358:	00842703          	lw	a4,8(s0)
4002f35c:	00e787b3          	add	a5,a5,a4
			if (msgq->write_ptr == msgq->buffer_end) {
4002f360:	01442703          	lw	a4,20(s0)
			msgq->write_ptr += msgq->msg_size;
4002f364:	00f42e23          	sw	a5,28(s0)
			if (msgq->write_ptr == msgq->buffer_end) {
4002f368:	00e79663          	bne	a5,a4,4002f374 <z_impl_k_msgq_get+0xac>
				msgq->write_ptr = msgq->buffer_start;
4002f36c:	01042783          	lw	a5,16(s0)
4002f370:	00f42e23          	sw	a5,28(s0)
			msgq->used_msgs++;
4002f374:	02042783          	lw	a5,32(s0)
			z_ready_thread(pending_thread);
4002f378:	00048513          	mv	a0,s1
			msgq->used_msgs++;
4002f37c:	00178793          	addi	a5,a5,1
4002f380:	02f42023          	sw	a5,32(s0)
4002f384:	0a04ae23          	sw	zero,188(s1)
			z_ready_thread(pending_thread);
4002f388:	464010ef          	jal	ra,400307ec <z_ready_thread>
			z_reschedule(&msgq->lock, key);
4002f38c:	00090593          	mv	a1,s2
4002f390:	00098513          	mv	a0,s3
4002f394:	764010ef          	jal	ra,40030af8 <z_reschedule>
			return 0;
4002f398:	00000793          	li	a5,0
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
4002f39c:	01c12083          	lw	ra,28(sp)
4002f3a0:	01812403          	lw	s0,24(sp)
4002f3a4:	01412483          	lw	s1,20(sp)
4002f3a8:	01012903          	lw	s2,16(sp)
4002f3ac:	00c12983          	lw	s3,12(sp)
4002f3b0:	00078513          	mv	a0,a5
4002f3b4:	02010113          	addi	sp,sp,32
4002f3b8:	00008067          	ret
4002f3bc:	00068713          	mv	a4,a3
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
4002f3c0:	00d666b3          	or	a3,a2,a3
		result = -ENOMSG;
4002f3c4:	fdd00793          	li	a5,-35
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
4002f3c8:	02068e63          	beqz	a3,4002f404 <z_impl_k_msgq_get+0x13c>
		_current->base.swap_data = data;
4002f3cc:	4003b7b7          	lui	a5,0x4003b
4002f3d0:	1cc7a783          	lw	a5,460(a5) # 4003b1cc <_kernel+0x8>
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
4002f3d4:	00060693          	mv	a3,a2
4002f3d8:	00040613          	mv	a2,s0
		_current->base.swap_data = data;
4002f3dc:	00b7aa23          	sw	a1,20(a5)
}
4002f3e0:	01812403          	lw	s0,24(sp)
4002f3e4:	01c12083          	lw	ra,28(sp)
4002f3e8:	01412483          	lw	s1,20(sp)
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
4002f3ec:	00090593          	mv	a1,s2
4002f3f0:	00098513          	mv	a0,s3
}
4002f3f4:	01012903          	lw	s2,16(sp)
4002f3f8:	00c12983          	lw	s3,12(sp)
4002f3fc:	02010113          	addi	sp,sp,32
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
4002f400:	4cc0106f          	j	400308cc <z_pend_curr>
	__asm__ volatile ("csrs mstatus, %0"
4002f404:	00897913          	andi	s2,s2,8
4002f408:	30092073          	csrs	mstatus,s2
	return result;
4002f40c:	f91ff06f          	j	4002f39c <z_impl_k_msgq_get+0xd4>

4002f410 <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
4002f410:	00e50783          	lb	a5,14(a0)
4002f414:	00b78463          	beq	a5,a1,4002f41c <adjust_owner_prio.isra.0+0xc>
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
4002f418:	5e40106f          	j	400309fc <z_set_prio>
	}
	return false;
}
4002f41c:	00000513          	li	a0,0
4002f420:	00008067          	ret

4002f424 <z_impl_k_mutex_init>:
	mutex->owner = NULL;
4002f424:	00052423          	sw	zero,8(a0)
	mutex->lock_count = 0U;
4002f428:	00052623          	sw	zero,12(a0)
	list->head = (sys_dnode_t *)list;
4002f42c:	00a52023          	sw	a0,0(a0)
	list->tail = (sys_dnode_t *)list;
4002f430:	00a52223          	sw	a0,4(a0)
}
4002f434:	00000513          	li	a0,0
4002f438:	00008067          	ret

4002f43c <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
4002f43c:	fd010113          	addi	sp,sp,-48
4002f440:	02812423          	sw	s0,40(sp)
4002f444:	02112623          	sw	ra,44(sp)
4002f448:	02912223          	sw	s1,36(sp)
4002f44c:	03212023          	sw	s2,32(sp)
4002f450:	01312e23          	sw	s3,28(sp)
4002f454:	00050413          	mv	s0,a0
4002f458:	00060713          	mv	a4,a2
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002f45c:	300474f3          	csrrci	s1,mstatus,8

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
4002f460:	00c52603          	lw	a2,12(a0)
4002f464:	4003b7b7          	lui	a5,0x4003b
4002f468:	1c478793          	addi	a5,a5,452 # 4003b1c4 <_kernel>
4002f46c:	04060263          	beqz	a2,4002f4b0 <z_impl_k_mutex_lock+0x74>
4002f470:	00058693          	mv	a3,a1
4002f474:	00852503          	lw	a0,8(a0)
4002f478:	0087a583          	lw	a1,8(a5)
4002f47c:	06b50063          	beq	a0,a1,4002f4dc <z_impl_k_mutex_lock+0xa0>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
4002f480:	00e6e7b3          	or	a5,a3,a4
4002f484:	06079063          	bnez	a5,4002f4e4 <z_impl_k_mutex_lock+0xa8>
	__asm__ volatile ("csrs mstatus, %0"
4002f488:	0084f493          	andi	s1,s1,8
4002f48c:	3004a073          	csrs	mstatus,s1
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
4002f490:	ff000513          	li	a0,-16
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
4002f494:	02c12083          	lw	ra,44(sp)
4002f498:	02812403          	lw	s0,40(sp)
4002f49c:	02412483          	lw	s1,36(sp)
4002f4a0:	02012903          	lw	s2,32(sp)
4002f4a4:	01c12983          	lw	s3,28(sp)
4002f4a8:	03010113          	addi	sp,sp,48
4002f4ac:	00008067          	ret
					_current->base.prio :
4002f4b0:	0087a703          	lw	a4,8(a5)
4002f4b4:	00e70703          	lb	a4,14(a4)
		mutex->owner = _current;
4002f4b8:	0087a783          	lw	a5,8(a5)
		mutex->lock_count++;
4002f4bc:	00160613          	addi	a2,a2,1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
4002f4c0:	00e42823          	sw	a4,16(s0)
		mutex->lock_count++;
4002f4c4:	00c42623          	sw	a2,12(s0)
		mutex->owner = _current;
4002f4c8:	00f42423          	sw	a5,8(s0)
4002f4cc:	0084f493          	andi	s1,s1,8
4002f4d0:	3004a073          	csrs	mstatus,s1
		return 0;
4002f4d4:	00000513          	li	a0,0
4002f4d8:	fbdff06f          	j	4002f494 <z_impl_k_mutex_lock+0x58>
					_current->base.prio :
4002f4dc:	01042703          	lw	a4,16(s0)
4002f4e0:	fd9ff06f          	j	4002f4b8 <z_impl_k_mutex_lock+0x7c>
	new_prio = new_prio_for_inheritance(_current->base.prio,
4002f4e4:	00e50783          	lb	a5,14(a0)
4002f4e8:	00e58583          	lb	a1,14(a1)
	return prio >= CONFIG_PRIORITY_CEILING;
}

static inline int z_get_new_prio_with_ceiling(int prio)
{
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
4002f4ec:	00b7d463          	bge	a5,a1,4002f4f4 <z_impl_k_mutex_lock+0xb8>
4002f4f0:	00078593          	mv	a1,a5
4002f4f4:	f8100613          	li	a2,-127
4002f4f8:	00c5d463          	bge	a1,a2,4002f500 <z_impl_k_mutex_lock+0xc4>
4002f4fc:	f8100593          	li	a1,-127
	bool resched = false;
4002f500:	00000913          	li	s2,0
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
4002f504:	00f5de63          	bge	a1,a5,4002f520 <z_impl_k_mutex_lock+0xe4>
4002f508:	00e12623          	sw	a4,12(sp)
4002f50c:	00d12423          	sw	a3,8(sp)
		resched = adjust_owner_prio(mutex, new_prio);
4002f510:	f01ff0ef          	jal	ra,4002f410 <adjust_owner_prio.isra.0>
4002f514:	00c12703          	lw	a4,12(sp)
4002f518:	00812683          	lw	a3,8(sp)
4002f51c:	00050913          	mv	s2,a0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
4002f520:	4003b9b7          	lui	s3,0x4003b
4002f524:	00040613          	mv	a2,s0
4002f528:	00048593          	mv	a1,s1
4002f52c:	1e898513          	addi	a0,s3,488 # 4003b1e8 <sched_spinlock>
4002f530:	39c010ef          	jal	ra,400308cc <z_pend_curr>
	if (got_mutex == 0) {
4002f534:	fa0500e3          	beqz	a0,4002f4d4 <z_impl_k_mutex_lock+0x98>
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002f538:	300474f3          	csrrci	s1,mstatus,8
	if (likely(mutex->owner != NULL)) {
4002f53c:	00842503          	lw	a0,8(s0)
4002f540:	04050463          	beqz	a0,4002f588 <z_impl_k_mutex_lock+0x14c>
	return list->head == list;
4002f544:	00042783          	lw	a5,0(s0)
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
4002f548:	01042583          	lw	a1,16(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002f54c:	02f40063          	beq	s0,a5,4002f56c <z_impl_k_mutex_lock+0x130>
4002f550:	00078e63          	beqz	a5,4002f56c <z_impl_k_mutex_lock+0x130>
4002f554:	00e78783          	lb	a5,14(a5)
4002f558:	00b7d463          	bge	a5,a1,4002f560 <z_impl_k_mutex_lock+0x124>
4002f55c:	00078593          	mv	a1,a5
4002f560:	f8100793          	li	a5,-127
4002f564:	00f5d463          	bge	a1,a5,4002f56c <z_impl_k_mutex_lock+0x130>
4002f568:	f8100593          	li	a1,-127
		resched = adjust_owner_prio(mutex, new_prio) || resched;
4002f56c:	ea5ff0ef          	jal	ra,4002f410 <adjust_owner_prio.isra.0>
4002f570:	00050c63          	beqz	a0,4002f588 <z_impl_k_mutex_lock+0x14c>
		z_reschedule(&lock, key);
4002f574:	00048593          	mv	a1,s1
4002f578:	1e898513          	addi	a0,s3,488
4002f57c:	57c010ef          	jal	ra,40030af8 <z_reschedule>
	return -EAGAIN;
4002f580:	ff500513          	li	a0,-11
4002f584:	f11ff06f          	j	4002f494 <z_impl_k_mutex_lock+0x58>
	if (resched) {
4002f588:	fe0916e3          	bnez	s2,4002f574 <z_impl_k_mutex_lock+0x138>
	__asm__ volatile ("csrs mstatus, %0"
4002f58c:	0084f493          	andi	s1,s1,8
4002f590:	3004a073          	csrs	mstatus,s1
4002f594:	fedff06f          	j	4002f580 <z_impl_k_mutex_lock+0x144>

4002f598 <z_impl_k_mutex_unlock>:

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
4002f598:	00852783          	lw	a5,8(a0)
4002f59c:	0a078463          	beqz	a5,4002f644 <z_impl_k_mutex_unlock+0xac>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
4002f5a0:	4003b737          	lui	a4,0x4003b
4002f5a4:	1cc72703          	lw	a4,460(a4) # 4003b1cc <_kernel+0x8>
{
4002f5a8:	ff010113          	addi	sp,sp,-16
4002f5ac:	00812423          	sw	s0,8(sp)
4002f5b0:	00112623          	sw	ra,12(sp)
4002f5b4:	00912223          	sw	s1,4(sp)
4002f5b8:	00050413          	mv	s0,a0
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EPERM);

		return -EPERM;
4002f5bc:	fff00513          	li	a0,-1
	CHECKIF(mutex->owner != _current) {
4002f5c0:	00e79e63          	bne	a5,a4,4002f5dc <z_impl_k_mutex_unlock+0x44>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
4002f5c4:	00c42783          	lw	a5,12(s0)
4002f5c8:	00100713          	li	a4,1
4002f5cc:	02f77263          	bgeu	a4,a5,4002f5f0 <z_impl_k_mutex_unlock+0x58>
		mutex->lock_count--;
4002f5d0:	fff78793          	addi	a5,a5,-1
4002f5d4:	00f42623          	sw	a5,12(s0)


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
4002f5d8:	00000513          	li	a0,0
}
4002f5dc:	00c12083          	lw	ra,12(sp)
4002f5e0:	00812403          	lw	s0,8(sp)
4002f5e4:	00412483          	lw	s1,4(sp)
4002f5e8:	01010113          	addi	sp,sp,16
4002f5ec:	00008067          	ret
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002f5f0:	300474f3          	csrrci	s1,mstatus,8
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
4002f5f4:	01042583          	lw	a1,16(s0)
4002f5f8:	00842503          	lw	a0,8(s0)
4002f5fc:	e15ff0ef          	jal	ra,4002f410 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
4002f600:	00040513          	mv	a0,s0
4002f604:	35c010ef          	jal	ra,40030960 <z_unpend_first_thread>
	mutex->owner = new_owner;
4002f608:	00a42423          	sw	a0,8(s0)
	if (new_owner != NULL) {
4002f60c:	02050463          	beqz	a0,4002f634 <z_impl_k_mutex_unlock+0x9c>
		mutex->owner_orig_prio = new_owner->base.prio;
4002f610:	00e50703          	lb	a4,14(a0)
4002f614:	00e42823          	sw	a4,16(s0)
4002f618:	0a052e23          	sw	zero,188(a0)
		z_ready_thread(new_owner);
4002f61c:	1d0010ef          	jal	ra,400307ec <z_ready_thread>
		z_reschedule(&lock, key);
4002f620:	4003b537          	lui	a0,0x4003b
4002f624:	00048593          	mv	a1,s1
4002f628:	1e850513          	addi	a0,a0,488 # 4003b1e8 <sched_spinlock>
4002f62c:	4cc010ef          	jal	ra,40030af8 <z_reschedule>
4002f630:	fa9ff06f          	j	4002f5d8 <z_impl_k_mutex_unlock+0x40>
		mutex->lock_count = 0U;
4002f634:	00042623          	sw	zero,12(s0)
	__asm__ volatile ("csrs mstatus, %0"
4002f638:	0084f493          	andi	s1,s1,8
4002f63c:	3004a073          	csrs	mstatus,s1
4002f640:	f99ff06f          	j	4002f5d8 <z_impl_k_mutex_unlock+0x40>
		return -EINVAL;
4002f644:	fea00513          	li	a0,-22
}
4002f648:	00008067          	ret

4002f64c <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
4002f64c:	fe010113          	addi	sp,sp,-32
4002f650:	00812c23          	sw	s0,24(sp)
4002f654:	01212823          	sw	s2,16(sp)
4002f658:	01412423          	sw	s4,8(sp)
4002f65c:	01512223          	sw	s5,4(sp)
4002f660:	00112e23          	sw	ra,28(sp)
4002f664:	00912a23          	sw	s1,20(sp)
4002f668:	01312623          	sw	s3,12(sp)
4002f66c:	00050413          	mv	s0,a0
4002f670:	00060913          	mv	s2,a2
4002f674:	00068a93          	mv	s5,a3
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
4002f678:	00850a13          	addi	s4,a0,8
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002f67c:	300479f3          	csrrci	s3,mstatus,8

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
4002f680:	00058493          	mv	s1,a1
4002f684:	00070463          	beqz	a4,4002f68c <queue_insert+0x40>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
4002f688:	00452483          	lw	s1,4(a0)
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
4002f68c:	000a0513          	mv	a0,s4
4002f690:	2d0010ef          	jal	ra,40030960 <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
4002f694:	02050263          	beqz	a0,4002f6b8 <queue_insert+0x6c>
4002f698:	0a052e23          	sw	zero,188(a0)
	thread->base.swap_data = data;
4002f69c:	01252a23          	sw	s2,20(a0)
	z_ready_thread(thread);
4002f6a0:	14c010ef          	jal	ra,400307ec <z_ready_thread>

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
4002f6a4:	000a0513          	mv	a0,s4
4002f6a8:	00098593          	mv	a1,s3
4002f6ac:	44c010ef          	jal	ra,40030af8 <z_reschedule>
		return 0;
4002f6b0:	00000513          	li	a0,0
4002f6b4:	0200006f          	j	4002f6d4 <queue_insert+0x88>
	if (alloc) {
4002f6b8:	060a8c63          	beqz	s5,4002f730 <queue_insert+0xe4>
	return z_thread_aligned_alloc(0, size);
4002f6bc:	00800593          	li	a1,8
4002f6c0:	309020ef          	jal	ra,400321c8 <z_thread_aligned_alloc>
		if (anode == NULL) {
4002f6c4:	02051a63          	bnez	a0,4002f6f8 <queue_insert+0xac>
	__asm__ volatile ("csrs mstatus, %0"
4002f6c8:	0089f993          	andi	s3,s3,8
4002f6cc:	3009a073          	csrs	mstatus,s3
			return -ENOMEM;
4002f6d0:	ff400513          	li	a0,-12

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
}
4002f6d4:	01c12083          	lw	ra,28(sp)
4002f6d8:	01812403          	lw	s0,24(sp)
4002f6dc:	01412483          	lw	s1,20(sp)
4002f6e0:	01012903          	lw	s2,16(sp)
4002f6e4:	00c12983          	lw	s3,12(sp)
4002f6e8:	00812a03          	lw	s4,8(sp)
4002f6ec:	00412a83          	lw	s5,4(sp)
4002f6f0:	02010113          	addi	sp,sp,32
4002f6f4:	00008067          	ret
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
4002f6f8:	00100793          	li	a5,1
		anode->data = data;
4002f6fc:	01252223          	sw	s2,4(a0)
4002f700:	00f52023          	sw	a5,0(a0)
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
4002f704:	00052703          	lw	a4,0(a0)
	parent->next_and_flags = cur_flags | (unative_t)child;
4002f708:	00377713          	andi	a4,a4,3
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
4002f70c:	02049863          	bnez	s1,4002f73c <queue_insert+0xf0>
	parent->next_and_flags = cur_flags | (unative_t)child;
4002f710:	00042783          	lw	a5,0(s0)
4002f714:	00e7e7b3          	or	a5,a5,a4
4002f718:	00f52023          	sw	a5,0(a0)
Z_GENLIST_PREPEND(sflist, sfnode)
4002f71c:	00442783          	lw	a5,4(s0)
	list->head = node;
4002f720:	00a42023          	sw	a0,0(s0)
Z_GENLIST_PREPEND(sflist, sfnode)
4002f724:	02079c63          	bnez	a5,4002f75c <queue_insert+0x110>
	list->tail = node;
4002f728:	00a42223          	sw	a0,4(s0)
}
4002f72c:	0300006f          	j	4002f75c <queue_insert+0x110>
	node->next_and_flags = flags;
4002f730:	00092023          	sw	zero,0(s2)
}
4002f734:	00090513          	mv	a0,s2
4002f738:	fcdff06f          	j	4002f704 <queue_insert+0xb8>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
4002f73c:	0004a783          	lw	a5,0(s1)
Z_GENLIST_INSERT(sflist, sfnode)
4002f740:	00300693          	li	a3,3
4002f744:	02f6ee63          	bltu	a3,a5,4002f780 <queue_insert+0x134>
	parent->next_and_flags = cur_flags | (unative_t)child;
4002f748:	00e52023          	sw	a4,0(a0)
	return list->tail;
4002f74c:	00442703          	lw	a4,4(s0)
Z_GENLIST_APPEND(sflist, sfnode)
4002f750:	00071e63          	bnez	a4,4002f76c <queue_insert+0x120>
	list->tail = node;
4002f754:	00a42223          	sw	a0,4(s0)
	list->head = node;
4002f758:	00a42023          	sw	a0,0(s0)
	z_handle_obj_poll_events(&queue->poll_events, state);
4002f75c:	00400593          	li	a1,4
4002f760:	01040513          	addi	a0,s0,16
4002f764:	109020ef          	jal	ra,4003206c <z_handle_obj_poll_events>
4002f768:	f3dff06f          	j	4002f6a4 <queue_insert+0x58>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
4002f76c:	00072783          	lw	a5,0(a4)
	parent->next_and_flags = cur_flags | (unative_t)child;
4002f770:	0037f793          	andi	a5,a5,3
4002f774:	00f567b3          	or	a5,a0,a5
4002f778:	00f72023          	sw	a5,0(a4)
4002f77c:	fadff06f          	j	4002f728 <queue_insert+0xdc>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
4002f780:	ffc7f793          	andi	a5,a5,-4
	parent->next_and_flags = cur_flags | (unative_t)child;
4002f784:	00e7e7b3          	or	a5,a5,a4
4002f788:	00f52023          	sw	a5,0(a0)
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
4002f78c:	0004a783          	lw	a5,0(s1)
	parent->next_and_flags = cur_flags | (unative_t)child;
4002f790:	0037f793          	andi	a5,a5,3
4002f794:	00f567b3          	or	a5,a0,a5
4002f798:	00f4a023          	sw	a5,0(s1)
}
4002f79c:	fc1ff06f          	j	4002f75c <queue_insert+0x110>

4002f7a0 <z_queue_node_peek>:
{
4002f7a0:	ff010113          	addi	sp,sp,-16
4002f7a4:	00812423          	sw	s0,8(sp)
4002f7a8:	00112623          	sw	ra,12(sp)
4002f7ac:	00050413          	mv	s0,a0
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
4002f7b0:	00050e63          	beqz	a0,4002f7cc <z_queue_node_peek+0x2c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
4002f7b4:	00052703          	lw	a4,0(a0)
4002f7b8:	00377713          	andi	a4,a4,3
4002f7bc:	00070863          	beqz	a4,4002f7cc <z_queue_node_peek+0x2c>
		ret = anode->data;
4002f7c0:	00452403          	lw	s0,4(a0)
		if (needs_free) {
4002f7c4:	00058463          	beqz	a1,4002f7cc <z_queue_node_peek+0x2c>
			k_free(anode);
4002f7c8:	1dd020ef          	jal	ra,400321a4 <k_free>
}
4002f7cc:	00c12083          	lw	ra,12(sp)
4002f7d0:	00040513          	mv	a0,s0
4002f7d4:	00812403          	lw	s0,8(sp)
4002f7d8:	01010113          	addi	sp,sp,16
4002f7dc:	00008067          	ret

4002f7e0 <z_impl_k_queue_init>:
4002f7e0:	00850793          	addi	a5,a0,8
	list->head = (sys_dnode_t *)list;
4002f7e4:	00f52423          	sw	a5,8(a0)
	list->tail = (sys_dnode_t *)list;
4002f7e8:	00f52623          	sw	a5,12(a0)
	sys_dlist_init(&queue->poll_events);
4002f7ec:	01050793          	addi	a5,a0,16
	list->head = NULL;
4002f7f0:	00052023          	sw	zero,0(a0)
	list->tail = NULL;
4002f7f4:	00052223          	sw	zero,4(a0)
	list->head = (sys_dnode_t *)list;
4002f7f8:	00f52823          	sw	a5,16(a0)
	list->tail = (sys_dnode_t *)list;
4002f7fc:	00f52a23          	sw	a5,20(a0)
}
4002f800:	00008067          	ret

4002f804 <k_queue_append>:

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, insert, queue);
}

void k_queue_append(struct k_queue *queue, void *data)
{
4002f804:	00058613          	mv	a2,a1
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, append, queue);

	(void)queue_insert(queue, NULL, data, false, true);
4002f808:	00100713          	li	a4,1
4002f80c:	00000693          	li	a3,0
4002f810:	00000593          	li	a1,0
4002f814:	e39ff06f          	j	4002f64c <queue_insert>

4002f818 <k_queue_prepend>:

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append, queue);
}

void k_queue_prepend(struct k_queue *queue, void *data)
{
4002f818:	00058613          	mv	a2,a1
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, prepend, queue);

	(void)queue_insert(queue, NULL, data, false, false);
4002f81c:	00000713          	li	a4,0
4002f820:	00000693          	li	a3,0
4002f824:	00000593          	li	a1,0
4002f828:	e25ff06f          	j	4002f64c <queue_insert>

4002f82c <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
4002f82c:	ff010113          	addi	sp,sp,-16
4002f830:	00112623          	sw	ra,12(sp)
4002f834:	00812423          	sw	s0,8(sp)
4002f838:	00912223          	sw	s1,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002f83c:	300474f3          	csrrci	s1,mstatus,8
	return list->head;
4002f840:	00052403          	lw	s0,0(a0)
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
4002f844:	04040663          	beqz	s0,4002f890 <z_impl_k_queue_get+0x64>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
4002f848:	00042783          	lw	a5,0(s0)
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
4002f84c:	00452703          	lw	a4,4(a0)
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
4002f850:	ffc7f793          	andi	a5,a5,-4
	list->head = node;
4002f854:	00f52023          	sw	a5,0(a0)
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
4002f858:	00e41463          	bne	s0,a4,4002f860 <z_impl_k_queue_get+0x34>
	list->tail = node;
4002f85c:	00f52223          	sw	a5,4(a0)
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
4002f860:	00040513          	mv	a0,s0
4002f864:	00100593          	li	a1,1
4002f868:	f39ff0ef          	jal	ra,4002f7a0 <z_queue_node_peek>
4002f86c:	00050413          	mv	s0,a0
	__asm__ volatile ("csrs mstatus, %0"
4002f870:	0084f493          	andi	s1,s1,8
4002f874:	3004a073          	csrs	mstatus,s1

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
4002f878:	00c12083          	lw	ra,12(sp)
4002f87c:	00040513          	mv	a0,s0
4002f880:	00812403          	lw	s0,8(sp)
4002f884:	00412483          	lw	s1,4(sp)
4002f888:	01010113          	addi	sp,sp,16
4002f88c:	00008067          	ret
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
4002f890:	00c5e7b3          	or	a5,a1,a2
4002f894:	00058693          	mv	a3,a1
4002f898:	00060713          	mv	a4,a2
4002f89c:	fc078ae3          	beqz	a5,4002f870 <z_impl_k_queue_get+0x44>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
4002f8a0:	00850613          	addi	a2,a0,8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
4002f8a4:	00048593          	mv	a1,s1
4002f8a8:	00060513          	mv	a0,a2
4002f8ac:	020010ef          	jal	ra,400308cc <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
4002f8b0:	fc0514e3          	bnez	a0,4002f878 <z_impl_k_queue_get+0x4c>
4002f8b4:	4003b7b7          	lui	a5,0x4003b
4002f8b8:	1cc7a783          	lw	a5,460(a5) # 4003b1cc <_kernel+0x8>
4002f8bc:	0147a403          	lw	s0,20(a5)
4002f8c0:	fb9ff06f          	j	4002f878 <z_impl_k_queue_get+0x4c>

4002f8c4 <k_queue_unique_append>:
	return list->head;
4002f8c4:	00052783          	lw	a5,0(a0)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, unique_append, queue);

	sys_sfnode_t *test;

	SYS_SFLIST_FOR_EACH_NODE(&queue->data_q, test) {
4002f8c8:	02079063          	bnez	a5,4002f8e8 <k_queue_unique_append+0x24>
{
4002f8cc:	ff010113          	addi	sp,sp,-16
4002f8d0:	00112623          	sw	ra,12(sp)

			return false;
		}
	}

	k_queue_append(queue, data);
4002f8d4:	f31ff0ef          	jal	ra,4002f804 <k_queue_append>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, unique_append, queue, true);

	return true;
}
4002f8d8:	00c12083          	lw	ra,12(sp)
	return true;
4002f8dc:	00100513          	li	a0,1
}
4002f8e0:	01010113          	addi	sp,sp,16
4002f8e4:	00008067          	ret
		if (test == (sys_sfnode_t *) data) {
4002f8e8:	00b78863          	beq	a5,a1,4002f8f8 <k_queue_unique_append+0x34>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
4002f8ec:	0007a783          	lw	a5,0(a5)
4002f8f0:	ffc7f793          	andi	a5,a5,-4
4002f8f4:	fd5ff06f          	j	4002f8c8 <k_queue_unique_append+0x4>
			return false;
4002f8f8:	00000513          	li	a0,0
}
4002f8fc:	00008067          	ret

4002f900 <z_impl_k_sem_init>:
 */
static struct k_spinlock lock;

int z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,
		      unsigned int limit)
{
4002f900:	00050793          	mv	a5,a0
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
		SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, -EINVAL);

		return -EINVAL;
4002f904:	fea00513          	li	a0,-22
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
4002f908:	02060663          	beqz	a2,4002f934 <z_impl_k_sem_init+0x34>
4002f90c:	02b66463          	bltu	a2,a1,4002f934 <z_impl_k_sem_init+0x34>

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);

	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
4002f910:	01078713          	addi	a4,a5,16
	sem->count = initial_count;
4002f914:	00b7a423          	sw	a1,8(a5)
	sem->limit = limit;
4002f918:	00c7a623          	sw	a2,12(a5)
	list->head = (sys_dnode_t *)list;
4002f91c:	00f7a023          	sw	a5,0(a5)
	list->tail = (sys_dnode_t *)list;
4002f920:	00f7a223          	sw	a5,4(a5)
	list->head = (sys_dnode_t *)list;
4002f924:	00e7a823          	sw	a4,16(a5)
	list->tail = (sys_dnode_t *)list;
4002f928:	00e7aa23          	sw	a4,20(a5)
#endif
	z_object_init(sem);

	return 0;
4002f92c:	00000513          	li	a0,0
4002f930:	00008067          	ret
}
4002f934:	00008067          	ret

4002f938 <z_impl_k_sem_give>:
	return false;
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
4002f938:	ff010113          	addi	sp,sp,-16
4002f93c:	00812423          	sw	s0,8(sp)
4002f940:	00112623          	sw	ra,12(sp)
4002f944:	00912223          	sw	s1,4(sp)
4002f948:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002f94c:	300474f3          	csrrci	s1,mstatus,8
	struct k_thread *thread;
	bool resched = true;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
4002f950:	010010ef          	jal	ra,40030960 <z_unpend_first_thread>

	if (thread != NULL) {
4002f954:	02050663          	beqz	a0,4002f980 <z_impl_k_sem_give+0x48>
	thread->swap_retval = value;
4002f958:	0a052e23          	sw	zero,188(a0)
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
4002f95c:	691000ef          	jal	ra,400307ec <z_ready_thread>
	} else {
		k_spin_unlock(&lock, key);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
4002f960:	00812403          	lw	s0,8(sp)
4002f964:	00c12083          	lw	ra,12(sp)
		z_reschedule(&lock, key);
4002f968:	00048593          	mv	a1,s1
}
4002f96c:	00412483          	lw	s1,4(sp)
		z_reschedule(&lock, key);
4002f970:	4003b537          	lui	a0,0x4003b
4002f974:	1e850513          	addi	a0,a0,488 # 4003b1e8 <sched_spinlock>
}
4002f978:	01010113          	addi	sp,sp,16
		z_reschedule(&lock, key);
4002f97c:	17c0106f          	j	40030af8 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
4002f980:	00842703          	lw	a4,8(s0)
4002f984:	00c42783          	lw	a5,12(s0)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
4002f988:	00200593          	li	a1,2
4002f98c:	01040513          	addi	a0,s0,16
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
4002f990:	40e787b3          	sub	a5,a5,a4
4002f994:	00f037b3          	snez	a5,a5
4002f998:	00e787b3          	add	a5,a5,a4
4002f99c:	00f42423          	sw	a5,8(s0)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
4002f9a0:	6cc020ef          	jal	ra,4003206c <z_handle_obj_poll_events>
	return true;
4002f9a4:	fbdff06f          	j	4002f960 <z_impl_k_sem_give+0x28>

4002f9a8 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
4002f9a8:	00058693          	mv	a3,a1
4002f9ac:	00060713          	mv	a4,a2
4002f9b0:	300475f3          	csrrci	a1,mstatus,8

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
4002f9b4:	00852783          	lw	a5,8(a0)
4002f9b8:	00078e63          	beqz	a5,4002f9d4 <z_impl_k_sem_take+0x2c>
		sem->count--;
4002f9bc:	fff78793          	addi	a5,a5,-1
4002f9c0:	00f52423          	sw	a5,8(a0)
	__asm__ volatile ("csrs mstatus, %0"
4002f9c4:	0085f593          	andi	a1,a1,8
4002f9c8:	3005a073          	csrs	mstatus,a1
		k_spin_unlock(&lock, key);
		ret = 0;
4002f9cc:	00000513          	li	a0,0
		goto out;
4002f9d0:	00008067          	ret
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
4002f9d4:	00c6e7b3          	or	a5,a3,a2
4002f9d8:	00079a63          	bnez	a5,4002f9ec <z_impl_k_sem_take+0x44>
4002f9dc:	0085f593          	andi	a1,a1,8
4002f9e0:	3005a073          	csrs	mstatus,a1
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
4002f9e4:	ff000513          	li	a0,-16

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
4002f9e8:	00008067          	ret
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
4002f9ec:	00050613          	mv	a2,a0
4002f9f0:	4003b537          	lui	a0,0x4003b
4002f9f4:	1e850513          	addi	a0,a0,488 # 4003b1e8 <sched_spinlock>
4002f9f8:	6d50006f          	j	400308cc <z_pend_curr>

4002f9fc <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
4002f9fc:	ff010113          	addi	sp,sp,-16
4002fa00:	00812423          	sw	s0,8(sp)
4002fa04:	00112623          	sw	ra,12(sp)
4002fa08:	00912223          	sw	s1,4(sp)
4002fa0c:	01212023          	sw	s2,0(sp)
4002fa10:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002fa14:	300474f3          	csrrci	s1,mstatus,8
4002fa18:	ff500913          	li	s2,-11
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
4002fa1c:	00040513          	mv	a0,s0
4002fa20:	741000ef          	jal	ra,40030960 <z_unpend_first_thread>
		if (thread == NULL) {
4002fa24:	00050863          	beqz	a0,4002fa34 <z_impl_k_sem_reset+0x38>
4002fa28:	0b252e23          	sw	s2,188(a0)
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
4002fa2c:	5c1000ef          	jal	ra,400307ec <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
4002fa30:	fedff06f          	j	4002fa1c <z_impl_k_sem_reset+0x20>
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
4002fa34:	01040513          	addi	a0,s0,16
	}
	sem->count = 0;
4002fa38:	00042423          	sw	zero,8(s0)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
4002fa3c:	00200593          	li	a1,2
4002fa40:	62c020ef          	jal	ra,4003206c <z_handle_obj_poll_events>
	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
}
4002fa44:	00812403          	lw	s0,8(sp)
4002fa48:	00c12083          	lw	ra,12(sp)
4002fa4c:	00012903          	lw	s2,0(sp)
	z_reschedule(&lock, key);
4002fa50:	00048593          	mv	a1,s1
}
4002fa54:	00412483          	lw	s1,4(sp)
	z_reschedule(&lock, key);
4002fa58:	4003b537          	lui	a0,0x4003b
4002fa5c:	1e850513          	addi	a0,a0,488 # 4003b1e8 <sched_spinlock>
}
4002fa60:	01010113          	addi	sp,sp,16
	z_reschedule(&lock, key);
4002fa64:	0940106f          	j	40030af8 <z_reschedule>

4002fa68 <flag_test_and_clear>:
}

static inline bool flag_test(const uint32_t *flagp,
			     uint32_t bit)
{
	return (*flagp & BIT(bit)) != 0U;
4002fa68:	00052703          	lw	a4,0(a0)
	*flagp &= ~BIT(bit);
4002fa6c:	00100793          	li	a5,1
4002fa70:	00b797b3          	sll	a5,a5,a1
4002fa74:	fff7c793          	not	a5,a5
4002fa78:	00e7f7b3          	and	a5,a5,a4
4002fa7c:	00f52023          	sw	a5,0(a0)
	return (*flagp & BIT(bit)) != 0U;
4002fa80:	00b75533          	srl	a0,a4,a1
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
4002fa84:	00157513          	andi	a0,a0,1
4002fa88:	00008067          	ret

4002fa8c <unschedule_locked>:
 *
 * @return true if and only if work had been delayed so the timeout
 * was cancelled.
 */
static inline bool unschedule_locked(struct k_work_delayable *dwork)
{
4002fa8c:	ff010113          	addi	sp,sp,-16
4002fa90:	00812423          	sw	s0,8(sp)
	/* If scheduled, try to cancel.  If it fails, that means the
	 * callback has been dequeued and will inevitably run (or has
	 * already run), so treat that as "undelayed" and return
	 * false.
	 */
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
4002fa94:	00300593          	li	a1,3
{
4002fa98:	00050413          	mv	s0,a0
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
4002fa9c:	00c50513          	addi	a0,a0,12
{
4002faa0:	00112623          	sw	ra,12(sp)
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
4002faa4:	fc5ff0ef          	jal	ra,4002fa68 <flag_test_and_clear>
4002faa8:	00050863          	beqz	a0,4002fab8 <unschedule_locked+0x2c>
		ret = z_abort_timeout(&dwork->timeout) == 0;
4002faac:	01040513          	addi	a0,s0,16
4002fab0:	199010ef          	jal	ra,40031448 <z_abort_timeout>
4002fab4:	00153513          	seqz	a0,a0
	}

	return ret;
}
4002fab8:	00c12083          	lw	ra,12(sp)
4002fabc:	00812403          	lw	s0,8(sp)
4002fac0:	01010113          	addi	sp,sp,16
4002fac4:	00008067          	ret

4002fac8 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
4002fac8:	00050a63          	beqz	a0,4002fadc <notify_queue_locked.isra.0+0x14>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
4002facc:	00000613          	li	a2,0
4002fad0:	00000593          	li	a1,0
4002fad4:	0d050513          	addi	a0,a0,208
4002fad8:	5a40106f          	j	4003107c <z_sched_wake>
}
4002fadc:	00008067          	ret

4002fae0 <cancel_async_locked>:
{
4002fae0:	ff010113          	addi	sp,sp,-16
4002fae4:	00812423          	sw	s0,8(sp)
4002fae8:	00112623          	sw	ra,12(sp)
4002faec:	00912223          	sw	s1,4(sp)
	return (*flagp & BIT(bit)) != 0U;
4002faf0:	00c52783          	lw	a5,12(a0)
{
4002faf4:	00050413          	mv	s0,a0
	return (*flagp & BIT(bit)) != 0U;
4002faf8:	0017d793          	srli	a5,a5,0x1
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
4002fafc:	0017f793          	andi	a5,a5,1
4002fb00:	04079263          	bnez	a5,4002fb44 <cancel_async_locked+0x64>
		queue_remove_locked(work->queue, work);
4002fb04:	00852483          	lw	s1,8(a0)
	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
4002fb08:	00200593          	li	a1,2
4002fb0c:	00c50513          	addi	a0,a0,12
4002fb10:	f59ff0ef          	jal	ra,4002fa68 <flag_test_and_clear>
4002fb14:	02050863          	beqz	a0,4002fb44 <cancel_async_locked+0x64>
	return list->head;
4002fb18:	0c84a783          	lw	a5,200(s1)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4002fb1c:	00000713          	li	a4,0
4002fb20:	02078263          	beqz	a5,4002fb44 <cancel_async_locked+0x64>
4002fb24:	06f41263          	bne	s0,a5,4002fb88 <cancel_async_locked+0xa8>
	return node->next;
4002fb28:	00042783          	lw	a5,0(s0)
Z_GENLIST_REMOVE(slist, snode)
4002fb2c:	04071463          	bnez	a4,4002fb74 <cancel_async_locked+0x94>
4002fb30:	0cc4a703          	lw	a4,204(s1)
	list->head = node;
4002fb34:	0cf4a423          	sw	a5,200(s1)
Z_GENLIST_REMOVE(slist, snode)
4002fb38:	00e41463          	bne	s0,a4,4002fb40 <cancel_async_locked+0x60>
	list->tail = node;
4002fb3c:	0cf4a623          	sw	a5,204(s1)
	parent->next = child;
4002fb40:	00042023          	sw	zero,0(s0)
	return *flagp;
4002fb44:	00c42783          	lw	a5,12(s0)
4002fb48:	00000513          	li	a0,0
4002fb4c:	00f7f713          	andi	a4,a5,15
	if (ret != 0) {
4002fb50:	00070863          	beqz	a4,4002fb60 <cancel_async_locked+0x80>
	*flagp |= BIT(bit);
4002fb54:	0027e793          	ori	a5,a5,2
4002fb58:	00f42623          	sw	a5,12(s0)
	return flags_get(&work->flags) & K_WORK_MASK;
4002fb5c:	00276513          	ori	a0,a4,2
}
4002fb60:	00c12083          	lw	ra,12(sp)
4002fb64:	00812403          	lw	s0,8(sp)
4002fb68:	00412483          	lw	s1,4(sp)
4002fb6c:	01010113          	addi	sp,sp,16
4002fb70:	00008067          	ret
4002fb74:	00f72023          	sw	a5,0(a4)
Z_GENLIST_REMOVE(slist, snode)
4002fb78:	0cc4a783          	lw	a5,204(s1)
4002fb7c:	fcf412e3          	bne	s0,a5,4002fb40 <cancel_async_locked+0x60>
	list->tail = node;
4002fb80:	0ce4a623          	sw	a4,204(s1)
}
4002fb84:	fbdff06f          	j	4002fb40 <cancel_async_locked+0x60>
	return node->next;
4002fb88:	00078713          	mv	a4,a5
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4002fb8c:	0007a783          	lw	a5,0(a5)
4002fb90:	f91ff06f          	j	4002fb20 <cancel_async_locked+0x40>

4002fb94 <work_queue_main>:
{
4002fb94:	fd010113          	addi	sp,sp,-48
4002fb98:	02812423          	sw	s0,40(sp)
4002fb9c:	03212023          	sw	s2,32(sp)
4002fba0:	01312e23          	sw	s3,28(sp)
4002fba4:	01412c23          	sw	s4,24(sp)
4002fba8:	01512a23          	sw	s5,20(sp)
4002fbac:	01612823          	sw	s6,16(sp)
4002fbb0:	02112623          	sw	ra,44(sp)
4002fbb4:	02912223          	sw	s1,36(sp)
4002fbb8:	01712623          	sw	s7,12(sp)
4002fbbc:	01812423          	sw	s8,8(sp)
4002fbc0:	01912223          	sw	s9,4(sp)
4002fbc4:	01a12023          	sw	s10,0(sp)
4002fbc8:	00050413          	mv	s0,a0
	return list->head;
4002fbcc:	40039937          	lui	s2,0x40039
		} else if (flag_test_and_clear(&queue->flags,
4002fbd0:	0e050993          	addi	s3,a0,224
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
4002fbd4:	0d850a13          	addi	s4,a0,216
			(void)z_sched_wait(&lock, key, &queue->notifyq,
4002fbd8:	0d050a93          	addi	s5,a0,208
4002fbdc:	4003bb37          	lui	s6,0x4003b
4002fbe0:	30047bf3          	csrrci	s7,mstatus,8
4002fbe4:	0c842483          	lw	s1,200(s0)
Z_GENLIST_GET(slist, snode)
4002fbe8:	02049a63          	bnez	s1,4002fc1c <work_queue_main+0x88>
		} else if (flag_test_and_clear(&queue->flags,
4002fbec:	00200593          	li	a1,2
4002fbf0:	00098513          	mv	a0,s3
4002fbf4:	e75ff0ef          	jal	ra,4002fa68 <flag_test_and_clear>
4002fbf8:	0a051663          	bnez	a0,4002fca4 <work_queue_main+0x110>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
4002fbfc:	00000793          	li	a5,0
4002fc00:	fff00693          	li	a3,-1
4002fc04:	fff00713          	li	a4,-1
4002fc08:	000a8613          	mv	a2,s5
4002fc0c:	000b8593          	mv	a1,s7
4002fc10:	1e8b0513          	addi	a0,s6,488 # 4003b1e8 <sched_spinlock>
4002fc14:	4d4010ef          	jal	ra,400310e8 <z_sched_wait>
			continue;
4002fc18:	fc9ff06f          	j	4002fbe0 <work_queue_main+0x4c>
	return node->next;
4002fc1c:	0004a783          	lw	a5,0(s1)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
4002fc20:	0cc42703          	lw	a4,204(s0)
	list->head = node;
4002fc24:	0cf42423          	sw	a5,200(s0)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
4002fc28:	00e49463          	bne	s1,a4,4002fc30 <work_queue_main+0x9c>
	list->tail = node;
4002fc2c:	0cf42623          	sw	a5,204(s0)
	*flagp |= BIT(bit);
4002fc30:	0e042783          	lw	a5,224(s0)
	__asm__ volatile ("csrs mstatus, %0"
4002fc34:	008bfb93          	andi	s7,s7,8
4002fc38:	0027e793          	ori	a5,a5,2
4002fc3c:	0ef42023          	sw	a5,224(s0)
	*flagp &= ~BIT(bit);
4002fc40:	00c4a783          	lw	a5,12(s1)
4002fc44:	ffb7f793          	andi	a5,a5,-5
4002fc48:	0017e793          	ori	a5,a5,1
4002fc4c:	00f4a623          	sw	a5,12(s1)
			handler = work->handler;
4002fc50:	0044a783          	lw	a5,4(s1)
4002fc54:	300ba073          	csrs	mstatus,s7
		handler(work);
4002fc58:	00048513          	mv	a0,s1
4002fc5c:	000780e7          	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002fc60:	30047d73          	csrrci	s10,mstatus,8
	*flagp &= ~BIT(bit);
4002fc64:	00c4a783          	lw	a5,12(s1)
	return (*flagp & BIT(bit)) != 0U;
4002fc68:	0017d713          	srli	a4,a5,0x1
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
4002fc6c:	00177713          	andi	a4,a4,1
	*flagp &= ~BIT(bit);
4002fc70:	ffe7f693          	andi	a3,a5,-2
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
4002fc74:	04071263          	bnez	a4,4002fcb8 <work_queue_main+0x124>
	*flagp &= ~BIT(bit);
4002fc78:	00d4a623          	sw	a3,12(s1)
4002fc7c:	0e042783          	lw	a5,224(s0)
	__asm__ volatile ("csrs mstatus, %0"
4002fc80:	008d7d13          	andi	s10,s10,8
4002fc84:	ffd7f793          	andi	a5,a5,-3
4002fc88:	0ef42023          	sw	a5,224(s0)
4002fc8c:	300d2073          	csrs	mstatus,s10
	return (*flagp & BIT(bit)) != 0U;
4002fc90:	0087d793          	srli	a5,a5,0x8
		if (yield) {
4002fc94:	0017f793          	andi	a5,a5,1
4002fc98:	f40794e3          	bnez	a5,4002fbe0 <work_queue_main+0x4c>
	z_impl_k_yield();
4002fc9c:	0a8010ef          	jal	ra,40030d44 <z_impl_k_yield>
}
4002fca0:	f41ff06f          	j	4002fbe0 <work_queue_main+0x4c>
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
4002fca4:	00000613          	li	a2,0
4002fca8:	00100593          	li	a1,1
4002fcac:	000a0513          	mv	a0,s4
4002fcb0:	3cc010ef          	jal	ra,4003107c <z_sched_wake>
4002fcb4:	f45ff06f          	j	4002fbf8 <work_queue_main+0x64>
	return list->head;
4002fcb8:	0ec92503          	lw	a0,236(s2) # 400390ec <pending_cancels>
	*flagp &= ~BIT(bit);
4002fcbc:	ffc7f793          	andi	a5,a5,-4
4002fcc0:	00f4a623          	sw	a5,12(s1)
4002fcc4:	0ec90c13          	addi	s8,s2,236
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
4002fcc8:	fa050ae3          	beqz	a0,4002fc7c <work_queue_main+0xe8>
	return node->next;
4002fccc:	00052c83          	lw	s9,0(a0)
4002fcd0:	00000b93          	li	s7,0
4002fcd4:	fa0504e3          	beqz	a0,4002fc7c <work_queue_main+0xe8>
		if (wc->work == work) {
4002fcd8:	00452783          	lw	a5,4(a0)
			sys_slist_remove(&pending_cancels, prev, &wc->node);
4002fcdc:	00050713          	mv	a4,a0
		if (wc->work == work) {
4002fce0:	02f49663          	bne	s1,a5,4002fd0c <work_queue_main+0x178>
4002fce4:	00052783          	lw	a5,0(a0)
Z_GENLIST_REMOVE(slist, snode)
4002fce8:	040b9063          	bnez	s7,4002fd28 <work_queue_main+0x194>
4002fcec:	004c2703          	lw	a4,4(s8)
	list->head = node;
4002fcf0:	00fc2023          	sw	a5,0(s8)
Z_GENLIST_REMOVE(slist, snode)
4002fcf4:	00e51463          	bne	a0,a4,4002fcfc <work_queue_main+0x168>
	list->tail = node;
4002fcf8:	00fc2223          	sw	a5,4(s8)
	parent->next = child;
4002fcfc:	00052023          	sw	zero,0(a0)
	z_impl_k_sem_give(sem);
4002fd00:	00850513          	addi	a0,a0,8
4002fd04:	c35ff0ef          	jal	ra,4002f938 <z_impl_k_sem_give>
}
4002fd08:	000b8713          	mv	a4,s7
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
4002fd0c:	00000793          	li	a5,0
4002fd10:	000c8463          	beqz	s9,4002fd18 <work_queue_main+0x184>
	return node->next;
4002fd14:	000ca783          	lw	a5,0(s9)
4002fd18:	000c8513          	mv	a0,s9
4002fd1c:	00070b93          	mv	s7,a4
4002fd20:	00078c93          	mv	s9,a5
4002fd24:	fb1ff06f          	j	4002fcd4 <work_queue_main+0x140>
	parent->next = child;
4002fd28:	00fba023          	sw	a5,0(s7)
Z_GENLIST_REMOVE(slist, snode)
4002fd2c:	004c2783          	lw	a5,4(s8)
4002fd30:	fcf516e3          	bne	a0,a5,4002fcfc <work_queue_main+0x168>
	list->tail = node;
4002fd34:	017c2223          	sw	s7,4(s8)
}
4002fd38:	fc5ff06f          	j	4002fcfc <work_queue_main+0x168>

4002fd3c <submit_to_queue_locked>:
{
4002fd3c:	fe010113          	addi	sp,sp,-32
4002fd40:	01212823          	sw	s2,16(sp)
4002fd44:	00112e23          	sw	ra,28(sp)
4002fd48:	00812c23          	sw	s0,24(sp)
4002fd4c:	00912a23          	sw	s1,20(sp)
4002fd50:	01312623          	sw	s3,12(sp)
	return (*flagp & BIT(bit)) != 0U;
4002fd54:	00c52783          	lw	a5,12(a0)
{
4002fd58:	00058913          	mv	s2,a1
	return (*flagp & BIT(bit)) != 0U;
4002fd5c:	0017d713          	srli	a4,a5,0x1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
4002fd60:	00177713          	andi	a4,a4,1
4002fd64:	0a071063          	bnez	a4,4002fe04 <submit_to_queue_locked+0xc8>
	return (*flagp & BIT(bit)) != 0U;
4002fd68:	0027d793          	srli	a5,a5,0x2
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
4002fd6c:	0017f793          	andi	a5,a5,1
4002fd70:	10079463          	bnez	a5,4002fe78 <submit_to_queue_locked+0x13c>
		if (*queuep == NULL) {
4002fd74:	0005a783          	lw	a5,0(a1)
4002fd78:	00050413          	mv	s0,a0
4002fd7c:	00079663          	bnez	a5,4002fd88 <submit_to_queue_locked+0x4c>
			*queuep = work->queue;
4002fd80:	00852783          	lw	a5,8(a0)
4002fd84:	00f5a023          	sw	a5,0(a1)
	return (*flagp & BIT(bit)) != 0U;
4002fd88:	00c42783          	lw	a5,12(s0)
		ret = 1;
4002fd8c:	00100993          	li	s3,1
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
4002fd90:	0017f793          	andi	a5,a5,1
4002fd94:	00078863          	beqz	a5,4002fda4 <submit_to_queue_locked+0x68>
			*queuep = work->queue;
4002fd98:	00842783          	lw	a5,8(s0)
			ret = 2;
4002fd9c:	00200993          	li	s3,2
			*queuep = work->queue;
4002fda0:	00f92023          	sw	a5,0(s2)
		int rc = queue_submit_locked(*queuep, work);
4002fda4:	00092483          	lw	s1,0(s2)
	if (queue == NULL) {
4002fda8:	0c048c63          	beqz	s1,4002fe80 <submit_to_queue_locked+0x144>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
4002fdac:	4003b7b7          	lui	a5,0x4003b
4002fdb0:	1cc7a783          	lw	a5,460(a5) # 4003b1cc <_kernel+0x8>
4002fdb4:	02978263          	beq	a5,s1,4002fdd8 <submit_to_queue_locked+0x9c>
	return (*flagp & BIT(bit)) != 0U;
4002fdb8:	0e04a783          	lw	a5,224(s1)
4002fdbc:	0027d713          	srli	a4,a5,0x2
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
4002fdc0:	0017f693          	andi	a3,a5,1
	return (*flagp & BIT(bit)) != 0U;
4002fdc4:	00177713          	andi	a4,a4,1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
4002fdc8:	04069263          	bnez	a3,4002fe0c <submit_to_queue_locked+0xd0>
		ret = -EBUSY;
4002fdcc:	fed00993          	li	s3,-19
		*queuep = NULL;
4002fdd0:	00092023          	sw	zero,0(s2)
	return ret;
4002fdd4:	0780006f          	j	4002fe4c <submit_to_queue_locked+0x110>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
4002fdd8:	eb9fe0ef          	jal	ra,4002ec90 <k_is_in_isr>
4002fddc:	0e04a783          	lw	a5,224(s1)
4002fde0:	fc051ee3          	bnez	a0,4002fdbc <submit_to_queue_locked+0x80>
	return (*flagp & BIT(bit)) != 0U;
4002fde4:	0037d713          	srli	a4,a5,0x3
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
4002fde8:	0017f693          	andi	a3,a5,1
	return (*flagp & BIT(bit)) != 0U;
4002fdec:	00177713          	andi	a4,a4,1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
4002fdf0:	fc068ee3          	beqz	a3,4002fdcc <submit_to_queue_locked+0x90>
	} else if (plugged && !draining) {
4002fdf4:	02070463          	beqz	a4,4002fe1c <submit_to_queue_locked+0xe0>
	return (*flagp & BIT(bit)) != 0U;
4002fdf8:	0027d793          	srli	a5,a5,0x2
	} else if (plugged && !draining) {
4002fdfc:	0017f793          	andi	a5,a5,1
4002fe00:	00079e63          	bnez	a5,4002fe1c <submit_to_queue_locked+0xe0>
		ret = -EBUSY;
4002fe04:	ff000993          	li	s3,-16
4002fe08:	fc9ff06f          	j	4002fdd0 <submit_to_queue_locked+0x94>
	} else if (draining && !chained) {
4002fe0c:	fe071ce3          	bnez	a4,4002fe04 <submit_to_queue_locked+0xc8>
	return (*flagp & BIT(bit)) != 0U;
4002fe10:	0037d793          	srli	a5,a5,0x3
4002fe14:	0017f793          	andi	a5,a5,1
	} else if (plugged && !draining) {
4002fe18:	fe0796e3          	bnez	a5,4002fe04 <submit_to_queue_locked+0xc8>
	parent->next = child;
4002fe1c:	00042023          	sw	zero,0(s0)
	return list->tail;
4002fe20:	0cc4a783          	lw	a5,204(s1)
Z_GENLIST_APPEND(slist, snode)
4002fe24:	04079463          	bnez	a5,4002fe6c <submit_to_queue_locked+0x130>
	list->tail = node;
4002fe28:	0c84a623          	sw	s0,204(s1)
	list->head = node;
4002fe2c:	0c84a423          	sw	s0,200(s1)
		(void)notify_queue_locked(queue);
4002fe30:	00048513          	mv	a0,s1
4002fe34:	c95ff0ef          	jal	ra,4002fac8 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
4002fe38:	00c42783          	lw	a5,12(s0)
4002fe3c:	0047e793          	ori	a5,a5,4
4002fe40:	00f42623          	sw	a5,12(s0)
			work->queue = *queuep;
4002fe44:	00092783          	lw	a5,0(s2)
4002fe48:	00f42423          	sw	a5,8(s0)
}
4002fe4c:	01c12083          	lw	ra,28(sp)
4002fe50:	01812403          	lw	s0,24(sp)
4002fe54:	01412483          	lw	s1,20(sp)
4002fe58:	01012903          	lw	s2,16(sp)
4002fe5c:	00098513          	mv	a0,s3
4002fe60:	00c12983          	lw	s3,12(sp)
4002fe64:	02010113          	addi	sp,sp,32
4002fe68:	00008067          	ret
	parent->next = child;
4002fe6c:	0087a023          	sw	s0,0(a5)
	list->tail = node;
4002fe70:	0c84a623          	sw	s0,204(s1)
}
4002fe74:	fbdff06f          	j	4002fe30 <submit_to_queue_locked+0xf4>
	int ret = 0;
4002fe78:	00000993          	li	s3,0
4002fe7c:	f55ff06f          	j	4002fdd0 <submit_to_queue_locked+0x94>
		return -EINVAL;
4002fe80:	fea00993          	li	s3,-22
4002fe84:	f4dff06f          	j	4002fdd0 <submit_to_queue_locked+0x94>

4002fe88 <work_timeout>:
{
4002fe88:	fe010113          	addi	sp,sp,-32
4002fe8c:	00812c23          	sw	s0,24(sp)
4002fe90:	00112e23          	sw	ra,28(sp)
4002fe94:	00912a23          	sw	s1,20(sp)
4002fe98:	01212823          	sw	s2,16(sp)
4002fe9c:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002fea0:	300474f3          	csrrci	s1,mstatus,8
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
4002fea4:	00300593          	li	a1,3
4002fea8:	ff050913          	addi	s2,a0,-16
4002feac:	ffc50513          	addi	a0,a0,-4
	struct k_work_q *queue = NULL;
4002feb0:	00012623          	sw	zero,12(sp)
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
4002feb4:	bb5ff0ef          	jal	ra,4002fa68 <flag_test_and_clear>
4002feb8:	00050c63          	beqz	a0,4002fed0 <work_timeout+0x48>
		queue = dw->queue;
4002febc:	01842783          	lw	a5,24(s0)
		(void)submit_to_queue_locked(wp, &queue);
4002fec0:	00c10593          	addi	a1,sp,12
4002fec4:	00090513          	mv	a0,s2
		queue = dw->queue;
4002fec8:	00f12623          	sw	a5,12(sp)
		(void)submit_to_queue_locked(wp, &queue);
4002fecc:	e71ff0ef          	jal	ra,4002fd3c <submit_to_queue_locked>
	__asm__ volatile ("csrs mstatus, %0"
4002fed0:	0084f493          	andi	s1,s1,8
4002fed4:	3004a073          	csrs	mstatus,s1
}
4002fed8:	01c12083          	lw	ra,28(sp)
4002fedc:	01812403          	lw	s0,24(sp)
4002fee0:	01412483          	lw	s1,20(sp)
4002fee4:	01012903          	lw	s2,16(sp)
4002fee8:	02010113          	addi	sp,sp,32
4002feec:	00008067          	ret

4002fef0 <k_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
4002fef0:	00052023          	sw	zero,0(a0)
4002fef4:	00052423          	sw	zero,8(a0)
4002fef8:	00052623          	sw	zero,12(a0)
4002fefc:	00b52223          	sw	a1,4(a0)
}
4002ff00:	00008067          	ret

4002ff04 <k_work_busy_get>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002ff04:	300477f3          	csrrci	a5,mstatus,8
	return flags_get(&work->flags) & K_WORK_MASK;
4002ff08:	00c52503          	lw	a0,12(a0)
	__asm__ volatile ("csrs mstatus, %0"
4002ff0c:	0087f793          	andi	a5,a5,8
4002ff10:	00f57513          	andi	a0,a0,15
4002ff14:	3007a073          	csrs	mstatus,a5
}
4002ff18:	00008067          	ret

4002ff1c <z_work_submit_to_queue>:
{
4002ff1c:	fe010113          	addi	sp,sp,-32
4002ff20:	00112e23          	sw	ra,28(sp)
4002ff24:	00812c23          	sw	s0,24(sp)
4002ff28:	00a12623          	sw	a0,12(sp)
4002ff2c:	00058513          	mv	a0,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002ff30:	30047473          	csrrci	s0,mstatus,8
	int ret = submit_to_queue_locked(work, &queue);
4002ff34:	00c10593          	addi	a1,sp,12
4002ff38:	e05ff0ef          	jal	ra,4002fd3c <submit_to_queue_locked>
	__asm__ volatile ("csrs mstatus, %0"
4002ff3c:	00847413          	andi	s0,s0,8
4002ff40:	30042073          	csrs	mstatus,s0
}
4002ff44:	01c12083          	lw	ra,28(sp)
4002ff48:	01812403          	lw	s0,24(sp)
4002ff4c:	02010113          	addi	sp,sp,32
4002ff50:	00008067          	ret

4002ff54 <k_work_queue_start>:
{
4002ff54:	fe010113          	addi	sp,sp,-32
4002ff58:	00812c23          	sw	s0,24(sp)
4002ff5c:	00912a23          	sw	s1,20(sp)
4002ff60:	00112e23          	sw	ra,28(sp)
4002ff64:	0d050793          	addi	a5,a0,208
	list->head = (sys_dnode_t *)list;
4002ff68:	0cf52823          	sw	a5,208(a0)
	list->tail = (sys_dnode_t *)list;
4002ff6c:	0cf52a23          	sw	a5,212(a0)
4002ff70:	0d850793          	addi	a5,a0,216
	list->head = (sys_dnode_t *)list;
4002ff74:	0cf52c23          	sw	a5,216(a0)
	list->tail = (sys_dnode_t *)list;
4002ff78:	0cf52e23          	sw	a5,220(a0)
	list->head = NULL;
4002ff7c:	0c052423          	sw	zero,200(a0)
	list->tail = NULL;
4002ff80:	0c052623          	sw	zero,204(a0)
4002ff84:	00050413          	mv	s0,a0
4002ff88:	00068893          	mv	a7,a3
4002ff8c:	00070493          	mv	s1,a4
	uint32_t flags = K_WORK_QUEUE_STARTED;
4002ff90:	00100793          	li	a5,1
	if ((cfg != NULL) && cfg->no_yield) {
4002ff94:	00070863          	beqz	a4,4002ffa4 <k_work_queue_start+0x50>
4002ff98:	00474703          	lbu	a4,4(a4)
4002ff9c:	00070463          	beqz	a4,4002ffa4 <k_work_queue_start+0x50>
		flags |= K_WORK_QUEUE_NO_YIELD;
4002ffa0:	10100793          	li	a5,257
	*flagp = flags;
4002ffa4:	0ef42023          	sw	a5,224(s0)
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
4002ffa8:	fff00713          	li	a4,-1
4002ffac:	fff00793          	li	a5,-1
4002ffb0:	400306b7          	lui	a3,0x40030
4002ffb4:	00e12423          	sw	a4,8(sp)
4002ffb8:	00f12623          	sw	a5,12(sp)
4002ffbc:	00012023          	sw	zero,0(sp)
4002ffc0:	00000813          	li	a6,0
4002ffc4:	00000793          	li	a5,0
4002ffc8:	00040713          	mv	a4,s0
4002ffcc:	b9468693          	addi	a3,a3,-1132 # 4002fb94 <work_queue_main>
4002ffd0:	00040513          	mv	a0,s0
4002ffd4:	fddfe0ef          	jal	ra,4002efb0 <z_impl_k_thread_create>
	if ((cfg != NULL) && (cfg->name != NULL)) {
4002ffd8:	00048a63          	beqz	s1,4002ffec <k_work_queue_start+0x98>
4002ffdc:	0004a583          	lw	a1,0(s1)
4002ffe0:	00058663          	beqz	a1,4002ffec <k_work_queue_start+0x98>
	return z_impl_k_thread_name_set(thread, str);
4002ffe4:	00040513          	mv	a0,s0
4002ffe8:	cfdfe0ef          	jal	ra,4002ece4 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
4002ffec:	00040513          	mv	a0,s0
}
4002fff0:	01812403          	lw	s0,24(sp)
4002fff4:	01c12083          	lw	ra,28(sp)
4002fff8:	01412483          	lw	s1,20(sp)
4002fffc:	02010113          	addi	sp,sp,32
40030000:	e5dfe06f          	j	4002ee5c <z_impl_k_thread_start>

40030004 <k_work_init_delayable>:
{
40030004:	ff010113          	addi	sp,sp,-16
40030008:	00912223          	sw	s1,4(sp)
	*dwork = (struct k_work_delayable){
4003000c:	03000613          	li	a2,48
{
40030010:	00058493          	mv	s1,a1
	*dwork = (struct k_work_delayable){
40030014:	00000593          	li	a1,0
{
40030018:	00812423          	sw	s0,8(sp)
4003001c:	00112623          	sw	ra,12(sp)
40030020:	00050413          	mv	s0,a0
	*dwork = (struct k_work_delayable){
40030024:	cf9dc0ef          	jal	ra,4000cd1c <memset>
40030028:	10000793          	li	a5,256
4003002c:	00942223          	sw	s1,4(s0)
40030030:	00f42623          	sw	a5,12(s0)
}
40030034:	00c12083          	lw	ra,12(sp)
40030038:	00812403          	lw	s0,8(sp)
4003003c:	00412483          	lw	s1,4(sp)
40030040:	01010113          	addi	sp,sp,16
40030044:	00008067          	ret

40030048 <k_work_delayable_busy_get>:
int k_work_delayable_busy_get(const struct k_work_delayable *dwork)
40030048:	ebdff06f          	j	4002ff04 <k_work_busy_get>

4003004c <k_work_schedule_for_queue>:
}

int k_work_schedule_for_queue(struct k_work_q *queue,
			       struct k_work_delayable *dwork,
			       k_timeout_t delay)
{
4003004c:	fe010113          	addi	sp,sp,-32
40030050:	00112e23          	sw	ra,28(sp)
40030054:	00812c23          	sw	s0,24(sp)
40030058:	00a12623          	sw	a0,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4003005c:	30047473          	csrrci	s0,mstatus,8
	return *flagp;
40030060:	00c5a783          	lw	a5,12(a1)
	__ASSERT_NO_MSG(dwork != NULL);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, schedule_for_queue, queue, dwork, delay);

	struct k_work *work = &dwork->work;
	int ret = 0;
40030064:	00000513          	li	a0,0
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Schedule the work item if it's idle or running. */
	if ((work_busy_get_locked(work) & ~K_WORK_RUNNING) == 0U) {
40030068:	00e7f713          	andi	a4,a5,14
4003006c:	00071c63          	bnez	a4,40030084 <k_work_schedule_for_queue+0x38>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
40030070:	00c6e733          	or	a4,a3,a2
40030074:	00058513          	mv	a0,a1
40030078:	02071263          	bnez	a4,4003009c <k_work_schedule_for_queue+0x50>
		return submit_to_queue_locked(work, queuep);
4003007c:	00c10593          	addi	a1,sp,12
40030080:	cbdff0ef          	jal	ra,4002fd3c <submit_to_queue_locked>
	__asm__ volatile ("csrs mstatus, %0"
40030084:	00847413          	andi	s0,s0,8
40030088:	30042073          	csrs	mstatus,s0
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
4003008c:	01c12083          	lw	ra,28(sp)
40030090:	01812403          	lw	s0,24(sp)
40030094:	02010113          	addi	sp,sp,32
40030098:	00008067          	ret
	*flagp |= BIT(bit);
4003009c:	0087e793          	ori	a5,a5,8
400300a0:	00f5a623          	sw	a5,12(a1)
	dwork->queue = *queuep;
400300a4:	00c12783          	lw	a5,12(sp)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
400300a8:	01050513          	addi	a0,a0,16
	dwork->queue = *queuep;
400300ac:	02f5a423          	sw	a5,40(a1)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
400300b0:	400305b7          	lui	a1,0x40030
400300b4:	e8858593          	addi	a1,a1,-376 # 4002fe88 <work_timeout>
400300b8:	1f0010ef          	jal	ra,400312a8 <z_add_timeout>
	return ret;
400300bc:	00100513          	li	a0,1
400300c0:	fc5ff06f          	j	40030084 <k_work_schedule_for_queue+0x38>

400300c4 <k_work_reschedule_for_queue>:
}

int k_work_reschedule_for_queue(struct k_work_q *queue,
				 struct k_work_delayable *dwork,
				 k_timeout_t delay)
{
400300c4:	fe010113          	addi	sp,sp,-32
400300c8:	00812c23          	sw	s0,24(sp)
400300cc:	00112e23          	sw	ra,28(sp)
400300d0:	00912a23          	sw	s1,20(sp)
400300d4:	00a12623          	sw	a0,12(sp)
400300d8:	00058413          	mv	s0,a1
400300dc:	00c12423          	sw	a2,8(sp)
400300e0:	00d12223          	sw	a3,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
400300e4:	300474f3          	csrrci	s1,mstatus,8

	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Remove any active scheduling. */
	(void)unschedule_locked(dwork);
400300e8:	00058513          	mv	a0,a1
400300ec:	9a1ff0ef          	jal	ra,4002fa8c <unschedule_locked>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
400300f0:	00412683          	lw	a3,4(sp)
400300f4:	00812603          	lw	a2,8(sp)
400300f8:	00c6e7b3          	or	a5,a3,a2
400300fc:	02079663          	bnez	a5,40030128 <k_work_reschedule_for_queue+0x64>
		return submit_to_queue_locked(work, queuep);
40030100:	00c10593          	addi	a1,sp,12
40030104:	00040513          	mv	a0,s0
40030108:	c35ff0ef          	jal	ra,4002fd3c <submit_to_queue_locked>
	__asm__ volatile ("csrs mstatus, %0"
4003010c:	0084f493          	andi	s1,s1,8
40030110:	3004a073          	csrs	mstatus,s1
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
40030114:	01c12083          	lw	ra,28(sp)
40030118:	01812403          	lw	s0,24(sp)
4003011c:	01412483          	lw	s1,20(sp)
40030120:	02010113          	addi	sp,sp,32
40030124:	00008067          	ret
	*flagp |= BIT(bit);
40030128:	00c42783          	lw	a5,12(s0)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
4003012c:	400305b7          	lui	a1,0x40030
40030130:	01040513          	addi	a0,s0,16
	*flagp |= BIT(bit);
40030134:	0087e793          	ori	a5,a5,8
40030138:	00f42623          	sw	a5,12(s0)
	dwork->queue = *queuep;
4003013c:	00c12783          	lw	a5,12(sp)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
40030140:	e8858593          	addi	a1,a1,-376 # 4002fe88 <work_timeout>
	dwork->queue = *queuep;
40030144:	02f42423          	sw	a5,40(s0)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
40030148:	160010ef          	jal	ra,400312a8 <z_add_timeout>
	return ret;
4003014c:	00100513          	li	a0,1
40030150:	fbdff06f          	j	4003010c <k_work_reschedule_for_queue+0x48>

40030154 <k_work_reschedule>:

int k_work_reschedule(struct k_work_delayable *dwork,
				     k_timeout_t delay)
{
40030154:	00060693          	mv	a3,a2
40030158:	00058613          	mv	a2,a1
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, reschedule, dwork, delay);

	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
4003015c:	00050593          	mv	a1,a0
40030160:	4003a537          	lui	a0,0x4003a
40030164:	00050513          	mv	a0,a0
40030168:	f5dff06f          	j	400300c4 <k_work_reschedule_for_queue>

4003016c <k_work_cancel_delayable>:

	return ret;
}

int k_work_cancel_delayable(struct k_work_delayable *dwork)
{
4003016c:	ff010113          	addi	sp,sp,-16
40030170:	00912223          	sw	s1,4(sp)
40030174:	00112623          	sw	ra,12(sp)
40030178:	00812423          	sw	s0,8(sp)
4003017c:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030180:	30047473          	csrrci	s0,mstatus,8
	(void)unschedule_locked(dwork);
40030184:	909ff0ef          	jal	ra,4002fa8c <unschedule_locked>
	return cancel_async_locked(&dwork->work);
40030188:	00048513          	mv	a0,s1
4003018c:	955ff0ef          	jal	ra,4002fae0 <cancel_async_locked>
	__asm__ volatile ("csrs mstatus, %0"
40030190:	00847793          	andi	a5,s0,8
40030194:	3007a073          	csrs	mstatus,a5
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable, dwork, ret);

	return ret;
}
40030198:	00c12083          	lw	ra,12(sp)
4003019c:	00812403          	lw	s0,8(sp)
400301a0:	00412483          	lw	s1,4(sp)
400301a4:	01010113          	addi	sp,sp,16
400301a8:	00008067          	ret

400301ac <sys_dlist_remove>:
	sys_dnode_t *const prev = node->prev;
400301ac:	00452703          	lw	a4,4(a0) # 4003a004 <k_sys_work_q+0x4>
	sys_dnode_t *const next = node->next;
400301b0:	00052783          	lw	a5,0(a0)
	prev->next = next;
400301b4:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
400301b8:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
400301bc:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
400301c0:	00052223          	sw	zero,4(a0)
	sys_dnode_init(node);
}
400301c4:	00008067          	ret

400301c8 <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
400301c8:	00e55703          	lhu	a4,14(a0)
400301cc:	07f00793          	li	a5,127
400301d0:	04e7e463          	bltu	a5,a4,40030218 <sliceable+0x50>
	int ret = slice_ticks;
400301d4:	400397b7          	lui	a5,0x40039
400301d8:	0fc7a783          	lw	a5,252(a5) # 400390fc <slice_ticks>
		&& slice_time(thread) != 0
400301dc:	02078a63          	beqz	a5,40030210 <sliceable+0x48>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
400301e0:	400397b7          	lui	a5,0x40039
400301e4:	0f87a703          	lw	a4,248(a5) # 400390f8 <slice_max_prio>
400301e8:	00e50683          	lb	a3,14(a0)
		&& !z_is_idle_thread_object(thread);
400301ec:	00000793          	li	a5,0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
400301f0:	02e6c063          	blt	a3,a4,40030210 <sliceable+0x48>
		&& !z_is_thread_prevented_from_running(thread)
400301f4:	00d54703          	lbu	a4,13(a0)
400301f8:	01f77713          	andi	a4,a4,31
400301fc:	00071a63          	bnez	a4,40030210 <sliceable+0x48>
		&& !z_is_idle_thread_object(thread);
40030200:	4003a7b7          	lui	a5,0x4003a
40030204:	e5878793          	addi	a5,a5,-424 # 40039e58 <z_idle_threads>
40030208:	40f50533          	sub	a0,a0,a5
4003020c:	00a037b3          	snez	a5,a0
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
40030210:	0017f513          	andi	a0,a5,1
40030214:	00008067          	ret
		&& !z_is_idle_thread_object(thread);
40030218:	00000793          	li	a5,0
4003021c:	ff5ff06f          	j	40030210 <sliceable+0x48>

40030220 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);
40030220:	4003a7b7          	lui	a5,0x4003a
40030224:	fe878793          	addi	a5,a5,-24 # 40039fe8 <slice_timeouts>
40030228:	40f507b3          	sub	a5,a0,a5
4003022c:	aaaab737          	lui	a4,0xaaaab
40030230:	aab70713          	addi	a4,a4,-1365 # aaaaaaab <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xaaaaaaac>
40030234:	4037d793          	srai	a5,a5,0x3
40030238:	02e787b3          	mul	a5,a5,a4

	slice_expired[cpu] = true;
4003023c:	40039737          	lui	a4,0x40039
40030240:	0f470713          	addi	a4,a4,244 # 400390f4 <slice_expired>
40030244:	00e787b3          	add	a5,a5,a4
40030248:	00100713          	li	a4,1
4003024c:	00e78023          	sb	a4,0(a5)
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
40030250:	00008067          	ret

40030254 <unpend_thread_no_timeout>:
		pend_locked(thread, wait_q, timeout);
	}
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
40030254:	ff010113          	addi	sp,sp,-16
40030258:	00812423          	sw	s0,8(sp)
4003025c:	00112623          	sw	ra,12(sp)
40030260:	00050413          	mv	s0,a0

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
40030264:	f49ff0ef          	jal	ra,400301ac <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
40030268:	00d44783          	lbu	a5,13(s0)
	thread->base.pended_on = NULL;
4003026c:	00042423          	sw	zero,8(s0)
40030270:	ffd7f793          	andi	a5,a5,-3
40030274:	00f406a3          	sb	a5,13(s0)
}
40030278:	00c12083          	lw	ra,12(sp)
4003027c:	00812403          	lw	s0,8(sp)
40030280:	01010113          	addi	sp,sp,16
40030284:	00008067          	ret

40030288 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
40030288:	00e50783          	lb	a5,14(a0)
	int32_t b2 = thread_2->base.prio;
4003028c:	00e58503          	lb	a0,14(a1)
	if (b1 != b2) {
40030290:	00a78663          	beq	a5,a0,4003029c <z_sched_prio_cmp+0x14>
		return b2 - b1;
40030294:	40f50533          	sub	a0,a0,a5
40030298:	00008067          	ret
	return 0;
4003029c:	00000513          	li	a0,0
}
400302a0:	00008067          	ret

400302a4 <z_reset_time_slice>:
{
400302a4:	ff010113          	addi	sp,sp,-16
	int cpu = _current_cpu->id;
400302a8:	4003b7b7          	lui	a5,0x4003b
{
400302ac:	00912223          	sw	s1,4(sp)
	int cpu = _current_cpu->id;
400302b0:	1d47c483          	lbu	s1,468(a5) # 4003b1d4 <_kernel+0x10>
{
400302b4:	00812423          	sw	s0,8(sp)
	z_abort_timeout(&slice_timeouts[cpu]);
400302b8:	01800413          	li	s0,24
400302bc:	02848433          	mul	s0,s1,s0
400302c0:	4003a7b7          	lui	a5,0x4003a
400302c4:	fe878793          	addi	a5,a5,-24 # 40039fe8 <slice_timeouts>
{
400302c8:	01212023          	sw	s2,0(sp)
400302cc:	00050913          	mv	s2,a0
400302d0:	00112623          	sw	ra,12(sp)
	z_abort_timeout(&slice_timeouts[cpu]);
400302d4:	00f40433          	add	s0,s0,a5
400302d8:	00040513          	mv	a0,s0
400302dc:	16c010ef          	jal	ra,40031448 <z_abort_timeout>
	slice_expired[cpu] = false;
400302e0:	400397b7          	lui	a5,0x40039
400302e4:	0f478793          	addi	a5,a5,244 # 400390f4 <slice_expired>
400302e8:	00f484b3          	add	s1,s1,a5
	if (sliceable(curr)) {
400302ec:	00090513          	mv	a0,s2
	slice_expired[cpu] = false;
400302f0:	00048023          	sb	zero,0(s1)
	if (sliceable(curr)) {
400302f4:	ed5ff0ef          	jal	ra,400301c8 <sliceable>
400302f8:	02050c63          	beqz	a0,40030330 <z_reset_time_slice+0x8c>
	int ret = slice_ticks;
400302fc:	400397b7          	lui	a5,0x40039
			      K_TICKS(slice_time(curr) - 1));
40030300:	0fc7a603          	lw	a2,252(a5) # 400390fc <slice_ticks>
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
40030304:	00040513          	mv	a0,s0
}
40030308:	00812403          	lw	s0,8(sp)
4003030c:	00c12083          	lw	ra,12(sp)
40030310:	00412483          	lw	s1,4(sp)
40030314:	00012903          	lw	s2,0(sp)
			      K_TICKS(slice_time(curr) - 1));
40030318:	fff60613          	addi	a2,a2,-1
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
4003031c:	400305b7          	lui	a1,0x40030
40030320:	41f65693          	srai	a3,a2,0x1f
40030324:	22058593          	addi	a1,a1,544 # 40030220 <slice_timeout>
}
40030328:	01010113          	addi	sp,sp,16
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
4003032c:	77d0006f          	j	400312a8 <z_add_timeout>
}
40030330:	00c12083          	lw	ra,12(sp)
40030334:	00812403          	lw	s0,8(sp)
40030338:	00412483          	lw	s1,4(sp)
4003033c:	00012903          	lw	s2,0(sp)
40030340:	01010113          	addi	sp,sp,16
40030344:	00008067          	ret

40030348 <z_swap_irqlock>:
{
40030348:	fe010113          	addi	sp,sp,-32
4003034c:	00812c23          	sw	s0,24(sp)
	old_thread = _current;
40030350:	4003b437          	lui	s0,0x4003b
{
40030354:	00912a23          	sw	s1,20(sp)
40030358:	00112e23          	sw	ra,28(sp)
4003035c:	01212823          	sw	s2,16(sp)
	old_thread = _current;
40030360:	1c440793          	addi	a5,s0,452 # 4003b1c4 <_kernel>
40030364:	0087a583          	lw	a1,8(a5)
	old_thread->swap_retval = -EAGAIN;
40030368:	ff500713          	li	a4,-11
{
4003036c:	00050493          	mv	s1,a0
	old_thread->swap_retval = -EAGAIN;
40030370:	0ae5ae23          	sw	a4,188(a1)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030374:	30047773          	csrrci	a4,mstatus,8
	return _kernel.ready_q.cache;
40030378:	0147a903          	lw	s2,20(a5)
	if (new_thread != old_thread) {
4003037c:	00b12623          	sw	a1,12(sp)
40030380:	1c440413          	addi	s0,s0,452
40030384:	01258e63          	beq	a1,s2,400303a0 <z_swap_irqlock+0x58>
		z_reset_time_slice(new_thread);
40030388:	00090513          	mv	a0,s2
		_current_cpu->current = new_thread;
4003038c:	01242423          	sw	s2,8(s0)
		z_reset_time_slice(new_thread);
40030390:	f15ff0ef          	jal	ra,400302a4 <z_reset_time_slice>
	z_riscv_switch(new, old);
40030394:	00c12583          	lw	a1,12(sp)
40030398:	0c092503          	lw	a0,192(s2)
4003039c:	b28dc0ef          	jal	ra,4000c6c4 <z_riscv_switch>
			  : "r" (key & MSTATUS_IEN)
400303a0:	0084f493          	andi	s1,s1,8
	__asm__ volatile ("csrs mstatus, %0"
400303a4:	3004a073          	csrs	mstatus,s1
	return _current->swap_retval;
400303a8:	00842783          	lw	a5,8(s0)
}
400303ac:	01c12083          	lw	ra,28(sp)
400303b0:	01812403          	lw	s0,24(sp)
400303b4:	0bc7a503          	lw	a0,188(a5)
400303b8:	01412483          	lw	s1,20(sp)
400303bc:	01012903          	lw	s2,16(sp)
400303c0:	02010113          	addi	sp,sp,32
400303c4:	00008067          	ret

400303c8 <z_swap>:
{
400303c8:	fe010113          	addi	sp,sp,-32
400303cc:	00812c23          	sw	s0,24(sp)
	old_thread = _current;
400303d0:	4003b437          	lui	s0,0x4003b
{
400303d4:	00912a23          	sw	s1,20(sp)
	old_thread = _current;
400303d8:	1c440793          	addi	a5,s0,452 # 4003b1c4 <_kernel>
{
400303dc:	00112e23          	sw	ra,28(sp)
400303e0:	01212823          	sw	s2,16(sp)
400303e4:	00058493          	mv	s1,a1
	old_thread = _current;
400303e8:	0087a583          	lw	a1,8(a5)
	old_thread->swap_retval = -EAGAIN;
400303ec:	ff500793          	li	a5,-11
400303f0:	1c440413          	addi	s0,s0,452
400303f4:	0af5ae23          	sw	a5,188(a1)
	if (!is_spinlock || lock != &sched_spinlock) {
400303f8:	4003b7b7          	lui	a5,0x4003b
400303fc:	1e878793          	addi	a5,a5,488 # 4003b1e8 <sched_spinlock>
40030400:	00a78463          	beq	a5,a0,40030408 <z_swap+0x40>
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030404:	300477f3          	csrrci	a5,mstatus,8
40030408:	01442903          	lw	s2,20(s0)
	if (new_thread != old_thread) {
4003040c:	00b12623          	sw	a1,12(sp)
40030410:	01258e63          	beq	a1,s2,4003042c <z_swap+0x64>
		z_reset_time_slice(new_thread);
40030414:	00090513          	mv	a0,s2
		_current_cpu->current = new_thread;
40030418:	01242423          	sw	s2,8(s0)
		z_reset_time_slice(new_thread);
4003041c:	e89ff0ef          	jal	ra,400302a4 <z_reset_time_slice>
40030420:	00c12583          	lw	a1,12(sp)
40030424:	0c092503          	lw	a0,192(s2)
40030428:	a9cdc0ef          	jal	ra,4000c6c4 <z_riscv_switch>
			  : "r" (key & MSTATUS_IEN)
4003042c:	0084f493          	andi	s1,s1,8
	__asm__ volatile ("csrs mstatus, %0"
40030430:	3004a073          	csrs	mstatus,s1
	return _current->swap_retval;
40030434:	00842783          	lw	a5,8(s0)
}
40030438:	01c12083          	lw	ra,28(sp)
4003043c:	01812403          	lw	s0,24(sp)
40030440:	0bc7a503          	lw	a0,188(a5)
40030444:	01412483          	lw	s1,20(sp)
40030448:	01012903          	lw	s2,16(sp)
4003044c:	02010113          	addi	sp,sp,32
40030450:	00008067          	ret

40030454 <update_cache>:
{
40030454:	ff010113          	addi	sp,sp,-16
40030458:	00812423          	sw	s0,8(sp)
	return list->head == list;
4003045c:	4003b437          	lui	s0,0x4003b
40030460:	1c440793          	addi	a5,s0,452 # 4003b1c4 <_kernel>
40030464:	00112623          	sw	ra,12(sp)
40030468:	00912223          	sw	s1,4(sp)
4003046c:	0187a483          	lw	s1,24(a5)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40030470:	4003b7b7          	lui	a5,0x4003b
40030474:	1dc78793          	addi	a5,a5,476 # 4003b1dc <_kernel+0x18>
40030478:	1c440413          	addi	s0,s0,452
4003047c:	00f48463          	beq	s1,a5,40030484 <update_cache+0x30>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
40030480:	00049463          	bnez	s1,40030488 <update_cache+0x34>
40030484:	00c42483          	lw	s1,12(s0)
	if (z_is_thread_prevented_from_running(_current)) {
40030488:	00842783          	lw	a5,8(s0)
	if (preempt_ok != 0) {
4003048c:	00051e63          	bnez	a0,400304a8 <update_cache+0x54>
	if (z_is_thread_prevented_from_running(_current)) {
40030490:	00d7c703          	lbu	a4,13(a5)
40030494:	01f77713          	andi	a4,a4,31
40030498:	00071863          	bnez	a4,400304a8 <update_cache+0x54>
	if (is_preempt(_current) || is_metairq(thread)) {
4003049c:	00e7d683          	lhu	a3,14(a5)
400304a0:	07f00713          	li	a4,127
400304a4:	00d76a63          	bltu	a4,a3,400304b8 <update_cache+0x64>
		if (thread != _current) {
400304a8:	00f48663          	beq	s1,a5,400304b4 <update_cache+0x60>
			z_reset_time_slice(thread);
400304ac:	00048513          	mv	a0,s1
400304b0:	df5ff0ef          	jal	ra,400302a4 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
400304b4:	00048793          	mv	a5,s1
400304b8:	00f42a23          	sw	a5,20(s0)
}
400304bc:	00c12083          	lw	ra,12(sp)
400304c0:	00812403          	lw	s0,8(sp)
400304c4:	00412483          	lw	s1,4(sp)
400304c8:	01010113          	addi	sp,sp,16
400304cc:	00008067          	ret

400304d0 <move_thread_to_end_of_prio_q>:
{
400304d0:	ff010113          	addi	sp,sp,-16
400304d4:	00812423          	sw	s0,8(sp)
400304d8:	00112623          	sw	ra,12(sp)
	return (thread->base.thread_state & state) != 0U;
400304dc:	00d54783          	lbu	a5,13(a0)
400304e0:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
400304e4:	01879713          	slli	a4,a5,0x18
400304e8:	41875713          	srai	a4,a4,0x18
400304ec:	00075863          	bgez	a4,400304fc <move_thread_to_end_of_prio_q+0x2c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
400304f0:	07f7f793          	andi	a5,a5,127
400304f4:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
400304f8:	cb5ff0ef          	jal	ra,400301ac <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
400304fc:	00d44783          	lbu	a5,13(s0)
	return list->head == list;
40030500:	4003b737          	lui	a4,0x4003b
40030504:	4003b6b7          	lui	a3,0x4003b
40030508:	f807e793          	ori	a5,a5,-128
4003050c:	00f406a3          	sb	a5,13(s0)
40030510:	1c470793          	addi	a5,a4,452 # 4003b1c4 <_kernel>
40030514:	0187a783          	lw	a5,24(a5)
40030518:	1dc68693          	addi	a3,a3,476 # 4003b1dc <_kernel+0x18>
4003051c:	1c470713          	addi	a4,a4,452
	return sys_dlist_is_empty(list) ? NULL : list->head;
40030520:	00d79463          	bne	a5,a3,40030528 <move_thread_to_end_of_prio_q+0x58>
40030524:	00000793          	li	a5,0
	return (node == list->tail) ? NULL : node->next;
40030528:	01c72603          	lw	a2,28(a4)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
4003052c:	00079c63          	bnez	a5,40030544 <move_thread_to_end_of_prio_q+0x74>
	node->next = list;
40030530:	00d42023          	sw	a3,0(s0)
	node->prev = tail;
40030534:	00c42223          	sw	a2,4(s0)
	tail->next = node;
40030538:	00862023          	sw	s0,0(a2)
	list->tail = node;
4003053c:	00872e23          	sw	s0,28(a4)
}
40030540:	0280006f          	j	40030568 <move_thread_to_end_of_prio_q+0x98>
	int32_t b1 = thread_1->base.prio;
40030544:	00e40583          	lb	a1,14(s0)
	int32_t b2 = thread_2->base.prio;
40030548:	00e78503          	lb	a0,14(a5)
	if (b1 != b2) {
4003054c:	02a58c63          	beq	a1,a0,40030584 <move_thread_to_end_of_prio_q+0xb4>
		if (z_sched_prio_cmp(thread, t) > 0) {
40030550:	02a5da63          	bge	a1,a0,40030584 <move_thread_to_end_of_prio_q+0xb4>
	sys_dnode_t *const prev = successor->prev;
40030554:	0047a683          	lw	a3,4(a5)
	node->next = successor;
40030558:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
4003055c:	00d42223          	sw	a3,4(s0)
	prev->next = node;
40030560:	0086a023          	sw	s0,0(a3)
	successor->prev = node;
40030564:	0087a223          	sw	s0,4(a5)
	update_cache(thread == _current);
40030568:	00872503          	lw	a0,8(a4)
}
4003056c:	00c12083          	lw	ra,12(sp)
	update_cache(thread == _current);
40030570:	40850533          	sub	a0,a0,s0
}
40030574:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
40030578:	00153513          	seqz	a0,a0
}
4003057c:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
40030580:	ed5ff06f          	j	40030454 <update_cache>
	return (node == list->tail) ? NULL : node->next;
40030584:	faf606e3          	beq	a2,a5,40030530 <move_thread_to_end_of_prio_q+0x60>
40030588:	0007a783          	lw	a5,0(a5)
4003058c:	fa1ff06f          	j	4003052c <move_thread_to_end_of_prio_q+0x5c>

40030590 <ready_thread>:
40030590:	00d54703          	lbu	a4,13(a0)
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
40030594:	01871793          	slli	a5,a4,0x18
40030598:	4187d793          	srai	a5,a5,0x18
4003059c:	0807c863          	bltz	a5,4003062c <ready_thread+0x9c>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
400305a0:	01f77793          	andi	a5,a4,31
400305a4:	08079463          	bnez	a5,4003062c <ready_thread+0x9c>
	return node->next != NULL;
400305a8:	01852783          	lw	a5,24(a0)
400305ac:	08079063          	bnez	a5,4003062c <ready_thread+0x9c>
	thread->base.thread_state |= _THREAD_QUEUED;
400305b0:	f8076713          	ori	a4,a4,-128
400305b4:	00e506a3          	sb	a4,13(a0)
	return list->head == list;
400305b8:	4003b737          	lui	a4,0x4003b
400305bc:	1c470693          	addi	a3,a4,452 # 4003b1c4 <_kernel>
400305c0:	0186a603          	lw	a2,24(a3)
400305c4:	4003b6b7          	lui	a3,0x4003b
400305c8:	1dc68693          	addi	a3,a3,476 # 4003b1dc <_kernel+0x18>
400305cc:	1c470713          	addi	a4,a4,452
	return sys_dlist_is_empty(list) ? NULL : list->head;
400305d0:	00d60463          	beq	a2,a3,400305d8 <ready_thread+0x48>
400305d4:	00060793          	mv	a5,a2
	return (node == list->tail) ? NULL : node->next;
400305d8:	01c72603          	lw	a2,28(a4)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
400305dc:	00079c63          	bnez	a5,400305f4 <ready_thread+0x64>
	node->next = list;
400305e0:	00d52023          	sw	a3,0(a0)
	node->prev = tail;
400305e4:	00c52223          	sw	a2,4(a0)
	tail->next = node;
400305e8:	00a62023          	sw	a0,0(a2)
	list->tail = node;
400305ec:	00a72e23          	sw	a0,28(a4)
}
400305f0:	0280006f          	j	40030618 <ready_thread+0x88>
	int32_t b1 = thread_1->base.prio;
400305f4:	00e50583          	lb	a1,14(a0)
	int32_t b2 = thread_2->base.prio;
400305f8:	00e78803          	lb	a6,14(a5)
	if (b1 != b2) {
400305fc:	03058263          	beq	a1,a6,40030620 <ready_thread+0x90>
		if (z_sched_prio_cmp(thread, t) > 0) {
40030600:	0305d063          	bge	a1,a6,40030620 <ready_thread+0x90>
	sys_dnode_t *const prev = successor->prev;
40030604:	0047a703          	lw	a4,4(a5)
	node->next = successor;
40030608:	00f52023          	sw	a5,0(a0)
	node->prev = prev;
4003060c:	00e52223          	sw	a4,4(a0)
	prev->next = node;
40030610:	00a72023          	sw	a0,0(a4)
	successor->prev = node;
40030614:	00a7a223          	sw	a0,4(a5)
		update_cache(0);
40030618:	00000513          	li	a0,0
4003061c:	e39ff06f          	j	40030454 <update_cache>
	return (node == list->tail) ? NULL : node->next;
40030620:	fcc780e3          	beq	a5,a2,400305e0 <ready_thread+0x50>
40030624:	0007a783          	lw	a5,0(a5)
40030628:	fb5ff06f          	j	400305dc <ready_thread+0x4c>
}
4003062c:	00008067          	ret

40030630 <unready_thread>:
{
40030630:	ff010113          	addi	sp,sp,-16
40030634:	00812423          	sw	s0,8(sp)
40030638:	00112623          	sw	ra,12(sp)
	return (thread->base.thread_state & state) != 0U;
4003063c:	00d54783          	lbu	a5,13(a0)
40030640:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
40030644:	01879713          	slli	a4,a5,0x18
40030648:	41875713          	srai	a4,a4,0x18
4003064c:	00075863          	bgez	a4,4003065c <unready_thread+0x2c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
40030650:	07f7f793          	andi	a5,a5,127
40030654:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
40030658:	b55ff0ef          	jal	ra,400301ac <sys_dlist_remove>
	update_cache(thread == _current);
4003065c:	4003b7b7          	lui	a5,0x4003b
40030660:	1cc7a503          	lw	a0,460(a5) # 4003b1cc <_kernel+0x8>
}
40030664:	00c12083          	lw	ra,12(sp)
	update_cache(thread == _current);
40030668:	40850533          	sub	a0,a0,s0
}
4003066c:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
40030670:	00153513          	seqz	a0,a0
}
40030674:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
40030678:	dddff06f          	j	40030454 <update_cache>

4003067c <add_to_waitq_locked>:
{
4003067c:	ff010113          	addi	sp,sp,-16
40030680:	00812423          	sw	s0,8(sp)
40030684:	00912223          	sw	s1,4(sp)
40030688:	00050413          	mv	s0,a0
4003068c:	00112623          	sw	ra,12(sp)
40030690:	00058493          	mv	s1,a1
	unready_thread(thread);
40030694:	f9dff0ef          	jal	ra,40030630 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
40030698:	00d44783          	lbu	a5,13(s0)
4003069c:	0027e793          	ori	a5,a5,2
400306a0:	00f406a3          	sb	a5,13(s0)
	if (wait_q != NULL) {
400306a4:	04048e63          	beqz	s1,40030700 <add_to_waitq_locked+0x84>
		thread->base.pended_on = wait_q;
400306a8:	00942423          	sw	s1,8(s0)
	return list->head == list;
400306ac:	0004a783          	lw	a5,0(s1)
	return sys_dlist_is_empty(list) ? NULL : list->head;
400306b0:	02f49463          	bne	s1,a5,400306d8 <add_to_waitq_locked+0x5c>
	sys_dnode_t *const tail = list->tail;
400306b4:	0044a783          	lw	a5,4(s1)
	node->next = list;
400306b8:	00942023          	sw	s1,0(s0)
	node->prev = tail;
400306bc:	00f42223          	sw	a5,4(s0)
	tail->next = node;
400306c0:	0087a023          	sw	s0,0(a5)
	list->tail = node;
400306c4:	0084a223          	sw	s0,4(s1)
}
400306c8:	0380006f          	j	40030700 <add_to_waitq_locked+0x84>
	return (node == list->tail) ? NULL : node->next;
400306cc:	0044a703          	lw	a4,4(s1)
400306d0:	fee782e3          	beq	a5,a4,400306b4 <add_to_waitq_locked+0x38>
400306d4:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
400306d8:	fc078ee3          	beqz	a5,400306b4 <add_to_waitq_locked+0x38>
	int32_t b1 = thread_1->base.prio;
400306dc:	00e40703          	lb	a4,14(s0)
	int32_t b2 = thread_2->base.prio;
400306e0:	00e78683          	lb	a3,14(a5)
	if (b1 != b2) {
400306e4:	fed704e3          	beq	a4,a3,400306cc <add_to_waitq_locked+0x50>
		if (z_sched_prio_cmp(thread, t) > 0) {
400306e8:	fed752e3          	bge	a4,a3,400306cc <add_to_waitq_locked+0x50>
	sys_dnode_t *const prev = successor->prev;
400306ec:	0047a703          	lw	a4,4(a5)
	node->next = successor;
400306f0:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
400306f4:	00e42223          	sw	a4,4(s0)
	prev->next = node;
400306f8:	00872023          	sw	s0,0(a4)
	successor->prev = node;
400306fc:	0087a223          	sw	s0,4(a5)
}
40030700:	00c12083          	lw	ra,12(sp)
40030704:	00812403          	lw	s0,8(sp)
40030708:	00412483          	lw	s1,4(sp)
4003070c:	01010113          	addi	sp,sp,16
40030710:	00008067          	ret

40030714 <pend_locked>:
{
40030714:	fe010113          	addi	sp,sp,-32
40030718:	00812c23          	sw	s0,24(sp)
4003071c:	00c12623          	sw	a2,12(sp)
40030720:	00d12423          	sw	a3,8(sp)
40030724:	00112e23          	sw	ra,28(sp)
40030728:	00050413          	mv	s0,a0
	add_to_waitq_locked(thread, wait_q);
4003072c:	f51ff0ef          	jal	ra,4003067c <add_to_waitq_locked>
	add_thread_timeout(thread, timeout);
40030730:	00c12603          	lw	a2,12(sp)
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
40030734:	fff00593          	li	a1,-1
40030738:	00812683          	lw	a3,8(sp)
4003073c:	00b61463          	bne	a2,a1,40030744 <pend_locked+0x30>
40030740:	02c68063          	beq	a3,a2,40030760 <pend_locked+0x4c>
40030744:	01840513          	addi	a0,s0,24
}
40030748:	01812403          	lw	s0,24(sp)
4003074c:	01c12083          	lw	ra,28(sp)
40030750:	400315b7          	lui	a1,0x40031
40030754:	8c058593          	addi	a1,a1,-1856 # 400308c0 <z_thread_timeout>
40030758:	02010113          	addi	sp,sp,32
4003075c:	34d0006f          	j	400312a8 <z_add_timeout>
40030760:	01c12083          	lw	ra,28(sp)
40030764:	01812403          	lw	s0,24(sp)
40030768:	02010113          	addi	sp,sp,32
4003076c:	00008067          	ret

40030770 <z_time_slice>:
{
40030770:	ff010113          	addi	sp,sp,-16
40030774:	00112623          	sw	ra,12(sp)
40030778:	00812423          	sw	s0,8(sp)
4003077c:	00912223          	sw	s1,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030780:	300474f3          	csrrci	s1,mstatus,8
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
40030784:	4003b7b7          	lui	a5,0x4003b
40030788:	1c478793          	addi	a5,a5,452 # 4003b1c4 <_kernel>
4003078c:	0107c703          	lbu	a4,16(a5)
40030790:	400396b7          	lui	a3,0x40039
40030794:	0f468693          	addi	a3,a3,244 # 400390f4 <slice_expired>
40030798:	00d70733          	add	a4,a4,a3
4003079c:	00074703          	lbu	a4,0(a4)
400307a0:	02070863          	beqz	a4,400307d0 <z_time_slice+0x60>
	struct k_thread *curr = _current;
400307a4:	0087a403          	lw	s0,8(a5)
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
400307a8:	00040513          	mv	a0,s0
400307ac:	a1dff0ef          	jal	ra,400301c8 <sliceable>
400307b0:	02050063          	beqz	a0,400307d0 <z_time_slice+0x60>
		if (!z_is_thread_prevented_from_running(curr)) {
400307b4:	00d44783          	lbu	a5,13(s0)
400307b8:	01f7f793          	andi	a5,a5,31
400307bc:	00079663          	bnez	a5,400307c8 <z_time_slice+0x58>
			move_thread_to_end_of_prio_q(curr);
400307c0:	00040513          	mv	a0,s0
400307c4:	d0dff0ef          	jal	ra,400304d0 <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
400307c8:	00040513          	mv	a0,s0
400307cc:	ad9ff0ef          	jal	ra,400302a4 <z_reset_time_slice>
	__asm__ volatile ("csrs mstatus, %0"
400307d0:	0084f493          	andi	s1,s1,8
400307d4:	3004a073          	csrs	mstatus,s1
}
400307d8:	00c12083          	lw	ra,12(sp)
400307dc:	00812403          	lw	s0,8(sp)
400307e0:	00412483          	lw	s1,4(sp)
400307e4:	01010113          	addi	sp,sp,16
400307e8:	00008067          	ret

400307ec <z_ready_thread>:
{
400307ec:	ff010113          	addi	sp,sp,-16
400307f0:	00112623          	sw	ra,12(sp)
400307f4:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
400307f8:	30047473          	csrrci	s0,mstatus,8
			ready_thread(thread);
400307fc:	d95ff0ef          	jal	ra,40030590 <ready_thread>
	__asm__ volatile ("csrs mstatus, %0"
40030800:	00847413          	andi	s0,s0,8
40030804:	30042073          	csrs	mstatus,s0
}
40030808:	00c12083          	lw	ra,12(sp)
4003080c:	00812403          	lw	s0,8(sp)
40030810:	01010113          	addi	sp,sp,16
40030814:	00008067          	ret

40030818 <z_unpend_thread_no_timeout>:
{
40030818:	ff010113          	addi	sp,sp,-16
4003081c:	00112623          	sw	ra,12(sp)
40030820:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030824:	30047473          	csrrci	s0,mstatus,8
		if (thread->base.pended_on != NULL) {
40030828:	00852783          	lw	a5,8(a0)
4003082c:	00078463          	beqz	a5,40030834 <z_unpend_thread_no_timeout+0x1c>
			unpend_thread_no_timeout(thread);
40030830:	a25ff0ef          	jal	ra,40030254 <unpend_thread_no_timeout>
	__asm__ volatile ("csrs mstatus, %0"
40030834:	00847413          	andi	s0,s0,8
40030838:	30042073          	csrs	mstatus,s0
}
4003083c:	00c12083          	lw	ra,12(sp)
40030840:	00812403          	lw	s0,8(sp)
40030844:	01010113          	addi	sp,sp,16
40030848:	00008067          	ret

4003084c <z_sched_wake_thread>:
{
4003084c:	ff010113          	addi	sp,sp,-16
40030850:	00112623          	sw	ra,12(sp)
40030854:	00812423          	sw	s0,8(sp)
40030858:	00912223          	sw	s1,4(sp)
4003085c:	01212023          	sw	s2,0(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030860:	300474f3          	csrrci	s1,mstatus,8
		if (!killed) {
40030864:	00d54783          	lbu	a5,13(a0)
40030868:	0287f793          	andi	a5,a5,40
4003086c:	02079a63          	bnez	a5,400308a0 <z_sched_wake_thread+0x54>
			if (thread->base.pended_on != NULL) {
40030870:	00852783          	lw	a5,8(a0)
40030874:	00050413          	mv	s0,a0
40030878:	00058913          	mv	s2,a1
4003087c:	00078463          	beqz	a5,40030884 <z_sched_wake_thread+0x38>
				unpend_thread_no_timeout(thread);
40030880:	9d5ff0ef          	jal	ra,40030254 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_PRESTART;
40030884:	00d44703          	lbu	a4,13(s0)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
40030888:	0eb77793          	andi	a5,a4,235
			if (is_timeout) {
4003088c:	00091463          	bnez	s2,40030894 <z_sched_wake_thread+0x48>
	thread->base.thread_state &= ~_THREAD_PRESTART;
40030890:	0fb77793          	andi	a5,a4,251
40030894:	00f406a3          	sb	a5,13(s0)
			ready_thread(thread);
40030898:	00040513          	mv	a0,s0
4003089c:	cf5ff0ef          	jal	ra,40030590 <ready_thread>
	__asm__ volatile ("csrs mstatus, %0"
400308a0:	0084f493          	andi	s1,s1,8
400308a4:	3004a073          	csrs	mstatus,s1
}
400308a8:	00c12083          	lw	ra,12(sp)
400308ac:	00812403          	lw	s0,8(sp)
400308b0:	00412483          	lw	s1,4(sp)
400308b4:	00012903          	lw	s2,0(sp)
400308b8:	01010113          	addi	sp,sp,16
400308bc:	00008067          	ret

400308c0 <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
400308c0:	00100593          	li	a1,1
400308c4:	fe850513          	addi	a0,a0,-24
400308c8:	f85ff06f          	j	4003084c <z_sched_wake_thread>

400308cc <z_pend_curr>:
{
400308cc:	ff010113          	addi	sp,sp,-16
400308d0:	00812423          	sw	s0,8(sp)
400308d4:	00112623          	sw	ra,12(sp)
400308d8:	00058413          	mv	s0,a1
400308dc:	00060593          	mv	a1,a2
400308e0:	00068613          	mv	a2,a3
400308e4:	00070693          	mv	a3,a4
	__asm__ volatile ("csrrc %0, mstatus, %1"
400308e8:	300477f3          	csrrci	a5,mstatus,8
	pend_locked(_current, wait_q, timeout);
400308ec:	4003b7b7          	lui	a5,0x4003b
400308f0:	1cc7a503          	lw	a0,460(a5) # 4003b1cc <_kernel+0x8>
400308f4:	e21ff0ef          	jal	ra,40030714 <pend_locked>
	return z_swap(&sched_spinlock, key);
400308f8:	00040593          	mv	a1,s0
}
400308fc:	00812403          	lw	s0,8(sp)
40030900:	00c12083          	lw	ra,12(sp)
	return z_swap(&sched_spinlock, key);
40030904:	4003b537          	lui	a0,0x4003b
40030908:	1e850513          	addi	a0,a0,488 # 4003b1e8 <sched_spinlock>
}
4003090c:	01010113          	addi	sp,sp,16
	return z_swap(&sched_spinlock, key);
40030910:	ab9ff06f          	j	400303c8 <z_swap>

40030914 <z_unpend1_no_timeout>:
{
40030914:	fe010113          	addi	sp,sp,-32
40030918:	00112e23          	sw	ra,28(sp)
4003091c:	00812c23          	sw	s0,24(sp)
40030920:	00050793          	mv	a5,a0
40030924:	30047473          	csrrci	s0,mstatus,8
	return list->head == list;
40030928:	00052503          	lw	a0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
4003092c:	02a78663          	beq	a5,a0,40030958 <z_unpend1_no_timeout+0x44>
		if (thread != NULL) {
40030930:	00050863          	beqz	a0,40030940 <z_unpend1_no_timeout+0x2c>
			unpend_thread_no_timeout(thread);
40030934:	00a12623          	sw	a0,12(sp)
40030938:	91dff0ef          	jal	ra,40030254 <unpend_thread_no_timeout>
4003093c:	00c12503          	lw	a0,12(sp)
	__asm__ volatile ("csrs mstatus, %0"
40030940:	00847413          	andi	s0,s0,8
40030944:	30042073          	csrs	mstatus,s0
}
40030948:	01c12083          	lw	ra,28(sp)
4003094c:	01812403          	lw	s0,24(sp)
40030950:	02010113          	addi	sp,sp,32
40030954:	00008067          	ret
40030958:	00000513          	li	a0,0
4003095c:	fe5ff06f          	j	40030940 <z_unpend1_no_timeout+0x2c>

40030960 <z_unpend_first_thread>:
{
40030960:	ff010113          	addi	sp,sp,-16
40030964:	00112623          	sw	ra,12(sp)
40030968:	00812423          	sw	s0,8(sp)
4003096c:	00912223          	sw	s1,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030970:	300474f3          	csrrci	s1,mstatus,8
	return list->head == list;
40030974:	00052403          	lw	s0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40030978:	02850c63          	beq	a0,s0,400309b0 <z_unpend_first_thread+0x50>
		if (thread != NULL) {
4003097c:	00040a63          	beqz	s0,40030990 <z_unpend_first_thread+0x30>
			unpend_thread_no_timeout(thread);
40030980:	00040513          	mv	a0,s0
40030984:	8d1ff0ef          	jal	ra,40030254 <unpend_thread_no_timeout>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
40030988:	01840513          	addi	a0,s0,24
4003098c:	2bd000ef          	jal	ra,40031448 <z_abort_timeout>
	__asm__ volatile ("csrs mstatus, %0"
40030990:	0084f493          	andi	s1,s1,8
40030994:	3004a073          	csrs	mstatus,s1
}
40030998:	00c12083          	lw	ra,12(sp)
4003099c:	00040513          	mv	a0,s0
400309a0:	00812403          	lw	s0,8(sp)
400309a4:	00412483          	lw	s1,4(sp)
400309a8:	01010113          	addi	sp,sp,16
400309ac:	00008067          	ret
400309b0:	00000413          	li	s0,0
400309b4:	fddff06f          	j	40030990 <z_unpend_first_thread+0x30>

400309b8 <z_unpend_thread>:
{
400309b8:	ff010113          	addi	sp,sp,-16
400309bc:	00812423          	sw	s0,8(sp)
400309c0:	00112623          	sw	ra,12(sp)
400309c4:	00912223          	sw	s1,4(sp)
400309c8:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
400309cc:	300474f3          	csrrci	s1,mstatus,8
		if (thread->base.pended_on != NULL) {
400309d0:	00852783          	lw	a5,8(a0)
400309d4:	00078463          	beqz	a5,400309dc <z_unpend_thread+0x24>
			unpend_thread_no_timeout(thread);
400309d8:	87dff0ef          	jal	ra,40030254 <unpend_thread_no_timeout>
	__asm__ volatile ("csrs mstatus, %0"
400309dc:	0084f493          	andi	s1,s1,8
400309e0:	3004a073          	csrs	mstatus,s1
400309e4:	01840513          	addi	a0,s0,24
}
400309e8:	00812403          	lw	s0,8(sp)
400309ec:	00c12083          	lw	ra,12(sp)
400309f0:	00412483          	lw	s1,4(sp)
400309f4:	01010113          	addi	sp,sp,16
400309f8:	2510006f          	j	40031448 <z_abort_timeout>

400309fc <z_set_prio>:
{
400309fc:	fe010113          	addi	sp,sp,-32
40030a00:	00812c23          	sw	s0,24(sp)
40030a04:	00112e23          	sw	ra,28(sp)
40030a08:	00912a23          	sw	s1,20(sp)
40030a0c:	01212823          	sw	s2,16(sp)
40030a10:	01312623          	sw	s3,12(sp)
40030a14:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030a18:	300479f3          	csrrci	s3,mstatus,8
	uint8_t state = thread->base.thread_state;
40030a1c:	00d54783          	lbu	a5,13(a0)
				thread->base.prio = prio;
40030a20:	01859913          	slli	s2,a1,0x18
40030a24:	41895913          	srai	s2,s2,0x18
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
40030a28:	01f7f713          	andi	a4,a5,31
40030a2c:	06071263          	bnez	a4,40030a90 <z_set_prio+0x94>
	return node->next != NULL;
40030a30:	01852483          	lw	s1,24(a0)
40030a34:	04049e63          	bnez	s1,40030a90 <z_set_prio+0x94>
	thread->base.thread_state &= ~_THREAD_QUEUED;
40030a38:	07f7f793          	andi	a5,a5,127
40030a3c:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
40030a40:	f6cff0ef          	jal	ra,400301ac <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
40030a44:	00d44783          	lbu	a5,13(s0)
				thread->base.prio = prio;
40030a48:	01240723          	sb	s2,14(s0)
	thread->base.thread_state |= _THREAD_QUEUED;
40030a4c:	f807e793          	ori	a5,a5,-128
40030a50:	00f406a3          	sb	a5,13(s0)
	return list->head == list;
40030a54:	4003b7b7          	lui	a5,0x4003b
40030a58:	1c478713          	addi	a4,a5,452 # 4003b1c4 <_kernel>
40030a5c:	01872683          	lw	a3,24(a4)
40030a60:	4003b737          	lui	a4,0x4003b
40030a64:	1dc70713          	addi	a4,a4,476 # 4003b1dc <_kernel+0x18>
40030a68:	1c478793          	addi	a5,a5,452
	return sys_dlist_is_empty(list) ? NULL : list->head;
40030a6c:	00e68463          	beq	a3,a4,40030a74 <z_set_prio+0x78>
40030a70:	00068493          	mv	s1,a3
	return (node == list->tail) ? NULL : node->next;
40030a74:	01c7a683          	lw	a3,28(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40030a78:	04049263          	bnez	s1,40030abc <z_set_prio+0xc0>
	node->next = list;
40030a7c:	00e42023          	sw	a4,0(s0)
	node->prev = tail;
40030a80:	00d42223          	sw	a3,4(s0)
	tail->next = node;
40030a84:	0086a023          	sw	s0,0(a3)
	list->tail = node;
40030a88:	0087ae23          	sw	s0,28(a5)
}
40030a8c:	0500006f          	j	40030adc <z_set_prio+0xe0>
			thread->base.prio = prio;
40030a90:	01240723          	sb	s2,14(s0)
40030a94:	00000513          	li	a0,0
	__asm__ volatile ("csrs mstatus, %0"
40030a98:	0089f993          	andi	s3,s3,8
40030a9c:	3009a073          	csrs	mstatus,s3
}
40030aa0:	01c12083          	lw	ra,28(sp)
40030aa4:	01812403          	lw	s0,24(sp)
40030aa8:	01412483          	lw	s1,20(sp)
40030aac:	01012903          	lw	s2,16(sp)
40030ab0:	00c12983          	lw	s3,12(sp)
40030ab4:	02010113          	addi	sp,sp,32
40030ab8:	00008067          	ret
	int32_t b2 = thread_2->base.prio;
40030abc:	00e48603          	lb	a2,14(s1)
	if (b1 != b2) {
40030ac0:	02c90663          	beq	s2,a2,40030aec <z_set_prio+0xf0>
		if (z_sched_prio_cmp(thread, t) > 0) {
40030ac4:	02c95463          	bge	s2,a2,40030aec <z_set_prio+0xf0>
	sys_dnode_t *const prev = successor->prev;
40030ac8:	0044a783          	lw	a5,4(s1)
	node->next = successor;
40030acc:	00942023          	sw	s1,0(s0)
	node->prev = prev;
40030ad0:	00f42223          	sw	a5,4(s0)
	prev->next = node;
40030ad4:	0087a023          	sw	s0,0(a5)
	successor->prev = node;
40030ad8:	0084a223          	sw	s0,4(s1)
			update_cache(1);
40030adc:	00100513          	li	a0,1
40030ae0:	975ff0ef          	jal	ra,40030454 <update_cache>
40030ae4:	00100513          	li	a0,1
40030ae8:	fb1ff06f          	j	40030a98 <z_set_prio+0x9c>
	return (node == list->tail) ? NULL : node->next;
40030aec:	f8d488e3          	beq	s1,a3,40030a7c <z_set_prio+0x80>
40030af0:	0004a483          	lw	s1,0(s1)
40030af4:	f85ff06f          	j	40030a78 <z_set_prio+0x7c>

40030af8 <z_reschedule>:
	return (key & MSTATUS_IEN) != 0;
40030af8:	0085f713          	andi	a4,a1,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
40030afc:	02070263          	beqz	a4,40030b20 <z_reschedule+0x28>
	return _kernel.cpus[0].nested != 0U;
40030b00:	4003b7b7          	lui	a5,0x4003b
40030b04:	1c478793          	addi	a5,a5,452 # 4003b1c4 <_kernel>
40030b08:	0007a683          	lw	a3,0(a5)
40030b0c:	00069a63          	bnez	a3,40030b20 <z_reschedule+0x28>
	if (resched(key.key) && need_swap()) {
40030b10:	0147a683          	lw	a3,20(a5)
40030b14:	0087a783          	lw	a5,8(a5)
40030b18:	00f68463          	beq	a3,a5,40030b20 <z_reschedule+0x28>
		z_swap(lock, key);
40030b1c:	8adff06f          	j	400303c8 <z_swap>
	__asm__ volatile ("csrs mstatus, %0"
40030b20:	30072073          	csrs	mstatus,a4
}
40030b24:	00008067          	ret

40030b28 <z_sched_start>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030b28:	300475f3          	csrrci	a1,mstatus,8
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
40030b2c:	00d54703          	lbu	a4,13(a0)
	if (z_has_thread_started(thread)) {
40030b30:	00477693          	andi	a3,a4,4
40030b34:	00069863          	bnez	a3,40030b44 <z_sched_start+0x1c>
	__asm__ volatile ("csrs mstatus, %0"
40030b38:	0085f593          	andi	a1,a1,8
40030b3c:	3005a073          	csrs	mstatus,a1
		return;
40030b40:	00008067          	ret
{
40030b44:	fe010113          	addi	sp,sp,-32
40030b48:	00112e23          	sw	ra,28(sp)
	thread->base.thread_state &= ~_THREAD_PRESTART;
40030b4c:	ffb77713          	andi	a4,a4,-5
40030b50:	00e506a3          	sb	a4,13(a0)
40030b54:	00b12623          	sw	a1,12(sp)
	ready_thread(thread);
40030b58:	a39ff0ef          	jal	ra,40030590 <ready_thread>
	z_reschedule(&sched_spinlock, key);
40030b5c:	00c12583          	lw	a1,12(sp)
}
40030b60:	01c12083          	lw	ra,28(sp)
	z_reschedule(&sched_spinlock, key);
40030b64:	4003b537          	lui	a0,0x4003b
40030b68:	1e850513          	addi	a0,a0,488 # 4003b1e8 <sched_spinlock>
}
40030b6c:	02010113          	addi	sp,sp,32
	z_reschedule(&sched_spinlock, key);
40030b70:	f89ff06f          	j	40030af8 <z_reschedule>

40030b74 <z_reschedule_irqlock>:
	return (key & MSTATUS_IEN) != 0;
40030b74:	00857793          	andi	a5,a0,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
40030b78:	00078a63          	beqz	a5,40030b8c <z_reschedule_irqlock+0x18>
40030b7c:	4003b737          	lui	a4,0x4003b
40030b80:	1c472703          	lw	a4,452(a4) # 4003b1c4 <_kernel>
40030b84:	00071463          	bnez	a4,40030b8c <z_reschedule_irqlock+0x18>
		z_swap_irqlock(key);
40030b88:	fc0ff06f          	j	40030348 <z_swap_irqlock>
	__asm__ volatile ("csrs mstatus, %0"
40030b8c:	3007a073          	csrs	mstatus,a5
}
40030b90:	00008067          	ret

40030b94 <z_reschedule_unlocked>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030b94:	30047573          	csrrci	a0,mstatus,8
	(void) z_reschedule_irqlock(arch_irq_lock());
40030b98:	fddff06f          	j	40030b74 <z_reschedule_irqlock>

40030b9c <z_impl_k_thread_suspend>:
{
40030b9c:	ff010113          	addi	sp,sp,-16
40030ba0:	00812423          	sw	s0,8(sp)
40030ba4:	00050413          	mv	s0,a0
40030ba8:	01850513          	addi	a0,a0,24
40030bac:	00112623          	sw	ra,12(sp)
40030bb0:	00912223          	sw	s1,4(sp)
40030bb4:	01212023          	sw	s2,0(sp)
40030bb8:	091000ef          	jal	ra,40031448 <z_abort_timeout>
40030bbc:	30047973          	csrrci	s2,mstatus,8
	return (thread->base.thread_state & state) != 0U;
40030bc0:	00d44783          	lbu	a5,13(s0)
		if (z_is_thread_queued(thread)) {
40030bc4:	01879713          	slli	a4,a5,0x18
40030bc8:	41875713          	srai	a4,a4,0x18
40030bcc:	00075a63          	bgez	a4,40030be0 <z_impl_k_thread_suspend+0x44>
	thread->base.thread_state &= ~_THREAD_QUEUED;
40030bd0:	07f7f793          	andi	a5,a5,127
40030bd4:	00f406a3          	sb	a5,13(s0)
	sys_dlist_remove(&thread->base.qnode_dlist);
40030bd8:	00040513          	mv	a0,s0
40030bdc:	dd0ff0ef          	jal	ra,400301ac <sys_dlist_remove>
		update_cache(thread == _current);
40030be0:	4003b4b7          	lui	s1,0x4003b
40030be4:	1c448493          	addi	s1,s1,452 # 4003b1c4 <_kernel>
	thread->base.thread_state |= _THREAD_SUSPENDED;
40030be8:	00d44783          	lbu	a5,13(s0)
40030bec:	0084a503          	lw	a0,8(s1)
	__asm__ volatile ("csrs mstatus, %0"
40030bf0:	00897913          	andi	s2,s2,8
40030bf4:	0107e793          	ori	a5,a5,16
40030bf8:	40850533          	sub	a0,a0,s0
40030bfc:	00f406a3          	sb	a5,13(s0)
40030c00:	00153513          	seqz	a0,a0
40030c04:	851ff0ef          	jal	ra,40030454 <update_cache>
40030c08:	30092073          	csrs	mstatus,s2
	if (thread == _current) {
40030c0c:	0084a783          	lw	a5,8(s1)
40030c10:	00879e63          	bne	a5,s0,40030c2c <z_impl_k_thread_suspend+0x90>
}
40030c14:	00812403          	lw	s0,8(sp)
40030c18:	00c12083          	lw	ra,12(sp)
40030c1c:	00412483          	lw	s1,4(sp)
40030c20:	00012903          	lw	s2,0(sp)
40030c24:	01010113          	addi	sp,sp,16
		z_reschedule_unlocked();
40030c28:	f6dff06f          	j	40030b94 <z_reschedule_unlocked>
}
40030c2c:	00c12083          	lw	ra,12(sp)
40030c30:	00812403          	lw	s0,8(sp)
40030c34:	00412483          	lw	s1,4(sp)
40030c38:	00012903          	lw	s2,0(sp)
40030c3c:	01010113          	addi	sp,sp,16
40030c40:	00008067          	ret

40030c44 <k_sched_lock>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030c44:	300477f3          	csrrci	a5,mstatus,8
	--_current->base.sched_locked;
40030c48:	4003b737          	lui	a4,0x4003b
40030c4c:	1cc72683          	lw	a3,460(a4) # 4003b1cc <_kernel+0x8>
40030c50:	00f6c703          	lbu	a4,15(a3)
40030c54:	fff70713          	addi	a4,a4,-1
40030c58:	00e687a3          	sb	a4,15(a3)
	__asm__ volatile ("csrs mstatus, %0"
40030c5c:	0087f793          	andi	a5,a5,8
40030c60:	3007a073          	csrs	mstatus,a5
}
40030c64:	00008067          	ret

40030c68 <k_sched_unlock>:
{
40030c68:	ff010113          	addi	sp,sp,-16
40030c6c:	00112623          	sw	ra,12(sp)
40030c70:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030c74:	30047473          	csrrci	s0,mstatus,8
		++_current->base.sched_locked;
40030c78:	4003b7b7          	lui	a5,0x4003b
40030c7c:	1cc7a703          	lw	a4,460(a5) # 4003b1cc <_kernel+0x8>
		update_cache(0);
40030c80:	00000513          	li	a0,0
	__asm__ volatile ("csrs mstatus, %0"
40030c84:	00847413          	andi	s0,s0,8
		++_current->base.sched_locked;
40030c88:	00f74783          	lbu	a5,15(a4)
40030c8c:	00178793          	addi	a5,a5,1
40030c90:	00f707a3          	sb	a5,15(a4)
		update_cache(0);
40030c94:	fc0ff0ef          	jal	ra,40030454 <update_cache>
40030c98:	30042073          	csrs	mstatus,s0
}
40030c9c:	00812403          	lw	s0,8(sp)
40030ca0:	00c12083          	lw	ra,12(sp)
40030ca4:	01010113          	addi	sp,sp,16
	z_reschedule_unlocked();
40030ca8:	eedff06f          	j	40030b94 <z_reschedule_unlocked>

40030cac <z_swap_next_thread>:
}
40030cac:	4003b7b7          	lui	a5,0x4003b
40030cb0:	1d87a503          	lw	a0,472(a5) # 4003b1d8 <_kernel+0x14>
40030cb4:	00008067          	ret

40030cb8 <z_get_next_switch_handle>:
	z_sched_usage_switch(_kernel.ready_q.cache);
40030cb8:	4003b7b7          	lui	a5,0x4003b
40030cbc:	1c478793          	addi	a5,a5,452 # 4003b1c4 <_kernel>
	_current->switch_handle = interrupted;
40030cc0:	0087a683          	lw	a3,8(a5)
	z_sched_usage_switch(_kernel.ready_q.cache);
40030cc4:	0147a703          	lw	a4,20(a5)
	_current->switch_handle = interrupted;
40030cc8:	0ca6a023          	sw	a0,192(a3)
}
40030ccc:	0c072503          	lw	a0,192(a4)
	_current_cpu->current = new_thread;
40030cd0:	00e7a423          	sw	a4,8(a5)
}
40030cd4:	00008067          	ret

40030cd8 <z_unpend_all>:
	}
	return thread;
}

int z_unpend_all(_wait_q_t *wait_q)
{
40030cd8:	ff010113          	addi	sp,sp,-16
40030cdc:	00912223          	sw	s1,4(sp)
40030ce0:	00112623          	sw	ra,12(sp)
40030ce4:	00050493          	mv	s1,a0
40030ce8:	00812423          	sw	s0,8(sp)
	int need_sched = 0;
40030cec:	00000513          	li	a0,0
	return list->head == list;
40030cf0:	0004a403          	lw	s0,0(s1)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40030cf4:	00848463          	beq	s1,s0,40030cfc <z_unpend_all+0x24>
	struct k_thread *thread;

	while ((thread = z_waitq_head(wait_q)) != NULL) {
40030cf8:	00041c63          	bnez	s0,40030d10 <z_unpend_all+0x38>
		z_ready_thread(thread);
		need_sched = 1;
	}

	return need_sched;
}
40030cfc:	00c12083          	lw	ra,12(sp)
40030d00:	00812403          	lw	s0,8(sp)
40030d04:	00412483          	lw	s1,4(sp)
40030d08:	01010113          	addi	sp,sp,16
40030d0c:	00008067          	ret
		z_unpend_thread(thread);
40030d10:	00040513          	mv	a0,s0
40030d14:	ca5ff0ef          	jal	ra,400309b8 <z_unpend_thread>
		z_ready_thread(thread);
40030d18:	00040513          	mv	a0,s0
40030d1c:	ad1ff0ef          	jal	ra,400307ec <z_ready_thread>
		need_sched = 1;
40030d20:	00100513          	li	a0,1
40030d24:	fcdff06f          	j	40030cf0 <z_unpend_all+0x18>

40030d28 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
40030d28:	4003b7b7          	lui	a5,0x4003b
40030d2c:	4003b737          	lui	a4,0x4003b
40030d30:	1c478793          	addi	a5,a5,452 # 4003b1c4 <_kernel>
40030d34:	1dc70713          	addi	a4,a4,476 # 4003b1dc <_kernel+0x18>
40030d38:	00e7ac23          	sw	a4,24(a5)
	list->tail = (sys_dnode_t *)list;
40030d3c:	00e7ae23          	sw	a4,28(a5)
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
#endif
}
40030d40:	00008067          	ret

40030d44 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
40030d44:	ff010113          	addi	sp,sp,-16
40030d48:	00112623          	sw	ra,12(sp)
40030d4c:	00812423          	sw	s0,8(sp)
40030d50:	00912223          	sw	s1,4(sp)
40030d54:	01212023          	sw	s2,0(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40030d58:	30047973          	csrrci	s2,mstatus,8

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
40030d5c:	4003b437          	lui	s0,0x4003b
40030d60:	1c440493          	addi	s1,s0,452 # 4003b1c4 <_kernel>
40030d64:	0084a503          	lw	a0,8(s1)
	thread->base.thread_state &= ~_THREAD_QUEUED;
40030d68:	1c440413          	addi	s0,s0,452
40030d6c:	00d54783          	lbu	a5,13(a0)
40030d70:	07f7f793          	andi	a5,a5,127
40030d74:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
40030d78:	c34ff0ef          	jal	ra,400301ac <sys_dlist_remove>
	}
	queue_thread(_current);
40030d7c:	0084a783          	lw	a5,8(s1)
	thread->base.thread_state |= _THREAD_QUEUED;
40030d80:	4003b6b7          	lui	a3,0x4003b
40030d84:	1dc68693          	addi	a3,a3,476 # 4003b1dc <_kernel+0x18>
40030d88:	00d7c703          	lbu	a4,13(a5)
40030d8c:	f8076713          	ori	a4,a4,-128
40030d90:	00e786a3          	sb	a4,13(a5)
	return list->head == list;
40030d94:	0184a703          	lw	a4,24(s1)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40030d98:	00d71463          	bne	a4,a3,40030da0 <z_impl_k_yield+0x5c>
40030d9c:	00000713          	li	a4,0
	return (node == list->tail) ? NULL : node->next;
40030da0:	01c42603          	lw	a2,28(s0)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40030da4:	00071c63          	bnez	a4,40030dbc <z_impl_k_yield+0x78>
	node->next = list;
40030da8:	00d7a023          	sw	a3,0(a5)
	node->prev = tail;
40030dac:	00c7a223          	sw	a2,4(a5)
	tail->next = node;
40030db0:	00f62023          	sw	a5,0(a2)
	list->tail = node;
40030db4:	00f42e23          	sw	a5,28(s0)
}
40030db8:	0280006f          	j	40030de0 <z_impl_k_yield+0x9c>
	int32_t b1 = thread_1->base.prio;
40030dbc:	00e78583          	lb	a1,14(a5)
	int32_t b2 = thread_2->base.prio;
40030dc0:	00e70503          	lb	a0,14(a4)
	if (b1 != b2) {
40030dc4:	04a58463          	beq	a1,a0,40030e0c <z_impl_k_yield+0xc8>
		if (z_sched_prio_cmp(thread, t) > 0) {
40030dc8:	04a5d263          	bge	a1,a0,40030e0c <z_impl_k_yield+0xc8>
	sys_dnode_t *const prev = successor->prev;
40030dcc:	00472683          	lw	a3,4(a4)
	node->next = successor;
40030dd0:	00e7a023          	sw	a4,0(a5)
	node->prev = prev;
40030dd4:	00d7a223          	sw	a3,4(a5)
	prev->next = node;
40030dd8:	00f6a023          	sw	a5,0(a3)
	successor->prev = node;
40030ddc:	00f72223          	sw	a5,4(a4)
	update_cache(1);
40030de0:	00100513          	li	a0,1
40030de4:	e70ff0ef          	jal	ra,40030454 <update_cache>
	z_swap(&sched_spinlock, key);
}
40030de8:	00812403          	lw	s0,8(sp)
40030dec:	00c12083          	lw	ra,12(sp)
40030df0:	00412483          	lw	s1,4(sp)
	z_swap(&sched_spinlock, key);
40030df4:	00090593          	mv	a1,s2
}
40030df8:	00012903          	lw	s2,0(sp)
	z_swap(&sched_spinlock, key);
40030dfc:	4003b537          	lui	a0,0x4003b
40030e00:	1e850513          	addi	a0,a0,488 # 4003b1e8 <sched_spinlock>
}
40030e04:	01010113          	addi	sp,sp,16
	z_swap(&sched_spinlock, key);
40030e08:	dc0ff06f          	j	400303c8 <z_swap>
	return (node == list->tail) ? NULL : node->next;
40030e0c:	f8c70ee3          	beq	a4,a2,40030da8 <z_impl_k_yield+0x64>
40030e10:	00072703          	lw	a4,0(a4)
40030e14:	f91ff06f          	j	40030da4 <z_impl_k_yield+0x60>

40030e18 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
40030e18:	fe010113          	addi	sp,sp,-32
40030e1c:	00112e23          	sw	ra,28(sp)
40030e20:	00812c23          	sw	s0,24(sp)
40030e24:	00912a23          	sw	s1,20(sp)
40030e28:	01212823          	sw	s2,16(sp)
40030e2c:	01312623          	sw	s3,12(sp)
40030e30:	01412423          	sw	s4,8(sp)
	__ASSERT(!arch_is_in_isr(), "");

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
40030e34:	00b567b3          	or	a5,a0,a1
40030e38:	00079863          	bnez	a5,40030e48 <z_tick_sleep+0x30>
	z_impl_k_yield();
40030e3c:	f09ff0ef          	jal	ra,40030d44 <z_impl_k_yield>
		k_yield();
		return 0;
40030e40:	00000513          	li	a0,0
40030e44:	0940006f          	j	40030ed8 <z_tick_sleep+0xc0>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
40030e48:	fff00793          	li	a5,-1
40030e4c:	00050493          	mv	s1,a0
40030e50:	00058913          	mv	s2,a1
40030e54:	0af5c263          	blt	a1,a5,40030ef8 <z_tick_sleep+0xe0>
40030e58:	00f59663          	bne	a1,a5,40030e64 <z_tick_sleep+0x4c>
40030e5c:	ffe00793          	li	a5,-2
40030e60:	08f56c63          	bltu	a0,a5,40030ef8 <z_tick_sleep+0xe0>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
40030e64:	7e4000ef          	jal	ra,40031648 <sys_clock_tick_get_32>
40030e68:	00a48433          	add	s0,s1,a0
40030e6c:	30047a73          	csrrci	s4,mstatus,8
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	unready_thread(_current);
40030e70:	4003b9b7          	lui	s3,0x4003b
40030e74:	1c498993          	addi	s3,s3,452 # 4003b1c4 <_kernel>
40030e78:	0089a503          	lw	a0,8(s3)
40030e7c:	fb4ff0ef          	jal	ra,40030630 <unready_thread>
	z_add_thread_timeout(_current, timeout);
40030e80:	0089a503          	lw	a0,8(s3)
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
40030e84:	400315b7          	lui	a1,0x40031
40030e88:	00048613          	mv	a2,s1
40030e8c:	00090693          	mv	a3,s2
40030e90:	8c058593          	addi	a1,a1,-1856 # 400308c0 <z_thread_timeout>
40030e94:	01850513          	addi	a0,a0,24
40030e98:	410000ef          	jal	ra,400312a8 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
40030e9c:	0089a703          	lw	a4,8(s3)

	(void)z_swap(&sched_spinlock, key);
40030ea0:	4003b537          	lui	a0,0x4003b
40030ea4:	000a0593          	mv	a1,s4
	thread->base.thread_state |= _THREAD_SUSPENDED;
40030ea8:	00d74783          	lbu	a5,13(a4)
40030eac:	1e850513          	addi	a0,a0,488 # 4003b1e8 <sched_spinlock>
40030eb0:	0107e793          	ori	a5,a5,16
40030eb4:	00f706a3          	sb	a5,13(a4)
40030eb8:	d10ff0ef          	jal	ra,400303c8 <z_swap>

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
40030ebc:	78c000ef          	jal	ra,40031648 <sys_clock_tick_get_32>
40030ec0:	40a407b3          	sub	a5,s0,a0
40030ec4:	00f43433          	sltu	s0,s0,a5
40030ec8:	40800433          	neg	s0,s0
	if (ticks > 0) {
40030ecc:	f6041ae3          	bnez	s0,40030e40 <z_tick_sleep+0x28>
		return ticks;
40030ed0:	00078513          	mv	a0,a5
	if (ticks > 0) {
40030ed4:	f60786e3          	beqz	a5,40030e40 <z_tick_sleep+0x28>
	}
#endif

	return 0;
}
40030ed8:	01c12083          	lw	ra,28(sp)
40030edc:	01812403          	lw	s0,24(sp)
40030ee0:	01412483          	lw	s1,20(sp)
40030ee4:	01012903          	lw	s2,16(sp)
40030ee8:	00c12983          	lw	s3,12(sp)
40030eec:	00812a03          	lw	s4,8(sp)
40030ef0:	02010113          	addi	sp,sp,32
40030ef4:	00008067          	ret
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
40030ef8:	ffe00413          	li	s0,-2
40030efc:	40940433          	sub	s0,s0,s1
40030f00:	f6dff06f          	j	40030e6c <z_tick_sleep+0x54>

40030f04 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
40030f04:	ff010113          	addi	sp,sp,-16
40030f08:	00112623          	sw	ra,12(sp)
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
40030f0c:	fff00693          	li	a3,-1
40030f10:	02d51263          	bne	a0,a3,40030f34 <z_impl_k_sleep+0x30>
40030f14:	02a59063          	bne	a1,a0,40030f34 <z_impl_k_sleep+0x30>
		k_thread_suspend(_current);
40030f18:	4003b7b7          	lui	a5,0x4003b
40030f1c:	1cc7a503          	lw	a0,460(a5) # 4003b1cc <_kernel+0x8>
	z_impl_k_thread_suspend(thread);
40030f20:	c7dff0ef          	jal	ra,40030b9c <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
40030f24:	fff00513          	li	a0,-1
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
40030f28:	00c12083          	lw	ra,12(sp)
40030f2c:	01010113          	addi	sp,sp,16
40030f30:	00008067          	ret
	ticks = z_tick_sleep(ticks);
40030f34:	ee5ff0ef          	jal	ra,40030e18 <z_tick_sleep>
			return t * ((uint64_t)to_hz / from_hz);
40030f38:	00a00793          	li	a5,10
40030f3c:	02f50533          	mul	a0,a0,a5
	return ret;
40030f40:	fe9ff06f          	j	40030f28 <z_impl_k_sleep+0x24>

40030f44 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
40030f44:	4003b7b7          	lui	a5,0x4003b
40030f48:	1cc7a503          	lw	a0,460(a5) # 4003b1cc <_kernel+0x8>
40030f4c:	00008067          	ret

40030f50 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
40030f50:	fe010113          	addi	sp,sp,-32
40030f54:	00112e23          	sw	ra,28(sp)
40030f58:	00812c23          	sw	s0,24(sp)
40030f5c:	00912a23          	sw	s1,20(sp)
40030f60:	01212823          	sw	s2,16(sp)
40030f64:	01312623          	sw	s3,12(sp)
40030f68:	01412423          	sw	s4,8(sp)
40030f6c:	300479f3          	csrrci	s3,mstatus,8
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
40030f70:	00c54783          	lbu	a5,12(a0)
40030f74:	0089f913          	andi	s2,s3,8
40030f78:	0017f793          	andi	a5,a5,1
40030f7c:	02078a63          	beqz	a5,40030fb0 <z_thread_abort+0x60>
	__asm__ volatile ("csrs mstatus, %0"
40030f80:	30092073          	csrs	mstatus,s2
	return a0;
}

static inline uintptr_t arch_syscall_invoke1(uintptr_t arg1, uintptr_t call_id)
{
	register unsigned long a0 __asm__ ("a0") = arg1;
40030f84:	00400513          	li	a0,4
	register unsigned long t0 __asm__ ("t0") = call_id;
40030f88:	00000293          	li	t0,0

	__asm__ volatile ("ecall"
40030f8c:	00000073          	ecall
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
40030f90:	01c12083          	lw	ra,28(sp)
40030f94:	01812403          	lw	s0,24(sp)
40030f98:	01412483          	lw	s1,20(sp)
40030f9c:	01012903          	lw	s2,16(sp)
40030fa0:	00c12983          	lw	s3,12(sp)
40030fa4:	00812a03          	lw	s4,8(sp)
40030fa8:	02010113          	addi	sp,sp,32
40030fac:	00008067          	ret
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
40030fb0:	00d54783          	lbu	a5,13(a0)
40030fb4:	00050413          	mv	s0,a0
40030fb8:	0087f713          	andi	a4,a5,8
40030fbc:	00070663          	beqz	a4,40030fc8 <z_thread_abort+0x78>
40030fc0:	30092073          	csrs	mstatus,s2
40030fc4:	fcdff06f          	j	40030f90 <z_thread_abort+0x40>
		thread->base.thread_state &= ~_THREAD_ABORTING;
40030fc8:	fdf7f713          	andi	a4,a5,-33
40030fcc:	00876713          	ori	a4,a4,8
		if (z_is_thread_queued(thread)) {
40030fd0:	01871693          	slli	a3,a4,0x18
40030fd4:	4186d693          	srai	a3,a3,0x18
40030fd8:	0606c663          	bltz	a3,40031044 <z_thread_abort+0xf4>
		thread->base.thread_state &= ~_THREAD_ABORTING;
40030fdc:	00e506a3          	sb	a4,13(a0)
		if (thread->base.pended_on != NULL) {
40030fe0:	00842783          	lw	a5,8(s0)
40030fe4:	00078663          	beqz	a5,40030ff0 <z_thread_abort+0xa0>
			unpend_thread_no_timeout(thread);
40030fe8:	00040513          	mv	a0,s0
40030fec:	a68ff0ef          	jal	ra,40030254 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
40030ff0:	01840513          	addi	a0,s0,24
40030ff4:	454000ef          	jal	ra,40031448 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
40030ff8:	06c40a13          	addi	s4,s0,108
	return list->head == list;
40030ffc:	06c42483          	lw	s1,108(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40031000:	01448463          	beq	s1,s4,40031008 <z_thread_abort+0xb8>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
40031004:	04049a63          	bnez	s1,40031058 <z_thread_abort+0x108>
		update_cache(1);
40031008:	00100513          	li	a0,1
4003100c:	c48ff0ef          	jal	ra,40030454 <update_cache>
		z_thread_monitor_exit(thread);
40031010:	00040513          	mv	a0,s0
40031014:	c8dfd0ef          	jal	ra,4002eca0 <z_thread_monitor_exit>
	if (thread == _current && !arch_is_in_isr()) {
40031018:	4003b7b7          	lui	a5,0x4003b
4003101c:	1c478793          	addi	a5,a5,452 # 4003b1c4 <_kernel>
40031020:	0087a703          	lw	a4,8(a5)
40031024:	f8871ee3          	bne	a4,s0,40030fc0 <z_thread_abort+0x70>
40031028:	0007a783          	lw	a5,0(a5)
4003102c:	f8079ae3          	bnez	a5,40030fc0 <z_thread_abort+0x70>
		z_swap(&sched_spinlock, key);
40031030:	4003b537          	lui	a0,0x4003b
40031034:	00098593          	mv	a1,s3
40031038:	1e850513          	addi	a0,a0,488 # 4003b1e8 <sched_spinlock>
4003103c:	b8cff0ef          	jal	ra,400303c8 <z_swap>
40031040:	f81ff06f          	j	40030fc0 <z_thread_abort+0x70>
	thread->base.thread_state &= ~_THREAD_QUEUED;
40031044:	05f7f793          	andi	a5,a5,95
40031048:	0087e793          	ori	a5,a5,8
4003104c:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
40031050:	95cff0ef          	jal	ra,400301ac <sys_dlist_remove>
}
40031054:	f8dff06f          	j	40030fe0 <z_thread_abort+0x90>
		unpend_thread_no_timeout(thread);
40031058:	00048513          	mv	a0,s1
4003105c:	9f8ff0ef          	jal	ra,40030254 <unpend_thread_no_timeout>
40031060:	01848513          	addi	a0,s1,24
40031064:	3e4000ef          	jal	ra,40031448 <z_abort_timeout>
		ready_thread(thread);
40031068:	00048513          	mv	a0,s1
4003106c:	0a04ae23          	sw	zero,188(s1)
40031070:	d20ff0ef          	jal	ra,40030590 <ready_thread>
40031074:	f89ff06f          	j	40030ffc <z_thread_abort+0xac>

40031078 <z_impl_k_thread_abort>:
#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
40031078:	ed9ff06f          	j	40030f50 <z_thread_abort>

4003107c <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
4003107c:	ff010113          	addi	sp,sp,-16
40031080:	00112623          	sw	ra,12(sp)
40031084:	00812423          	sw	s0,8(sp)
40031088:	00912223          	sw	s1,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4003108c:	300474f3          	csrrci	s1,mstatus,8
	return list->head == list;
40031090:	00052403          	lw	s0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40031094:	04850663          	beq	a0,s0,400310e0 <z_sched_wake+0x64>
	struct k_thread *thread;
	bool ret = false;
40031098:	00000513          	li	a0,0

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);

		if (thread != NULL) {
4003109c:	02040463          	beqz	s0,400310c4 <z_sched_wake+0x48>
400310a0:	0ab42e23          	sw	a1,188(s0)
	thread->base.swap_data = data;
400310a4:	00c42a23          	sw	a2,20(s0)
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
400310a8:	00040513          	mv	a0,s0
400310ac:	9a8ff0ef          	jal	ra,40030254 <unpend_thread_no_timeout>
400310b0:	01840513          	addi	a0,s0,24
400310b4:	394000ef          	jal	ra,40031448 <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
400310b8:	00040513          	mv	a0,s0
400310bc:	cd4ff0ef          	jal	ra,40030590 <ready_thread>
			ret = true;
400310c0:	00100513          	li	a0,1
	__asm__ volatile ("csrs mstatus, %0"
400310c4:	0084f493          	andi	s1,s1,8
400310c8:	3004a073          	csrs	mstatus,s1
		}
	}

	return ret;
}
400310cc:	00c12083          	lw	ra,12(sp)
400310d0:	00812403          	lw	s0,8(sp)
400310d4:	00412483          	lw	s1,4(sp)
400310d8:	01010113          	addi	sp,sp,16
400310dc:	00008067          	ret
	bool ret = false;
400310e0:	00000513          	li	a0,0
400310e4:	fe1ff06f          	j	400310c4 <z_sched_wake+0x48>

400310e8 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
400310e8:	ff010113          	addi	sp,sp,-16
400310ec:	00812423          	sw	s0,8(sp)
400310f0:	00078413          	mv	s0,a5
400310f4:	00112623          	sw	ra,12(sp)
	int ret = z_pend_curr(lock, key, wait_q, timeout);
400310f8:	fd4ff0ef          	jal	ra,400308cc <z_pend_curr>

	if (data != NULL) {
400310fc:	00040a63          	beqz	s0,40031110 <z_sched_wait+0x28>
		*data = _current->base.swap_data;
40031100:	4003b7b7          	lui	a5,0x4003b
40031104:	1cc7a783          	lw	a5,460(a5) # 4003b1cc <_kernel+0x8>
40031108:	0147a783          	lw	a5,20(a5)
4003110c:	00f42023          	sw	a5,0(s0)
	}
	return ret;
}
40031110:	00c12083          	lw	ra,12(sp)
40031114:	00812403          	lw	s0,8(sp)
40031118:	01010113          	addi	sp,sp,16
4003111c:	00008067          	ret

40031120 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
40031120:	400397b7          	lui	a5,0x40039
40031124:	1007a783          	lw	a5,256(a5) # 40039100 <announce_remaining>
40031128:	00079463          	bnez	a5,40031130 <elapsed+0x10>
4003112c:	e61fb06f          	j	4002cf8c <sys_clock_elapsed>
}
40031130:	00000513          	li	a0,0
40031134:	00008067          	ret

40031138 <next_timeout>:

static int32_t next_timeout(void)
{
40031138:	ff010113          	addi	sp,sp,-16
	return list->head == list;
4003113c:	400447b7          	lui	a5,0x40044
40031140:	00112623          	sw	ra,12(sp)
40031144:	00812423          	sw	s0,8(sp)
40031148:	6cc78793          	addi	a5,a5,1740 # 400446cc <timeout_list>
4003114c:	0007a403          	lw	s0,0(a5)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40031150:	02f41063          	bne	s0,a5,40031170 <next_timeout+0x38>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
40031154:	fcdff0ef          	jal	ra,40031120 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
40031158:	80000537          	lui	a0,0x80000
4003115c:	fff50513          	addi	a0,a0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

	return ret;
}
40031160:	00c12083          	lw	ra,12(sp)
40031164:	00812403          	lw	s0,8(sp)
40031168:	01010113          	addi	sp,sp,16
4003116c:	00008067          	ret
	int32_t ticks_elapsed = elapsed();
40031170:	fb1ff0ef          	jal	ra,40031120 <elapsed>
	if ((to == NULL) ||
40031174:	fe0402e3          	beqz	s0,40031158 <next_timeout+0x20>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
40031178:	01042703          	lw	a4,16(s0)
4003117c:	01442783          	lw	a5,20(s0)
40031180:	41f55693          	srai	a3,a0,0x1f
40031184:	40a70533          	sub	a0,a4,a0
40031188:	00a73733          	sltu	a4,a4,a0
4003118c:	40d787b3          	sub	a5,a5,a3
40031190:	40e787b3          	sub	a5,a5,a4
	if ((to == NULL) ||
40031194:	fcf042e3          	bgtz	a5,40031158 <next_timeout+0x20>
40031198:	00079463          	bnez	a5,400311a0 <next_timeout+0x68>
4003119c:	fa054ee3          	bltz	a0,40031158 <next_timeout+0x20>
		ret = MAX(0, to->dticks - ticks_elapsed);
400311a0:	fc07d0e3          	bgez	a5,40031160 <next_timeout+0x28>
400311a4:	00000513          	li	a0,0
	return ret;
400311a8:	fb9ff06f          	j	40031160 <next_timeout+0x28>

400311ac <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
400311ac:	04050063          	beqz	a0,400311ec <remove_timeout+0x40>
	return (node == list->tail) ? NULL : node->next;
400311b0:	400447b7          	lui	a5,0x40044
400311b4:	6d07a783          	lw	a5,1744(a5) # 400446d0 <timeout_list+0x4>
400311b8:	02f50a63          	beq	a0,a5,400311ec <remove_timeout+0x40>
400311bc:	00052703          	lw	a4,0(a0)
	if (next(t) != NULL) {
400311c0:	02070663          	beqz	a4,400311ec <remove_timeout+0x40>
		next(t)->dticks += t->dticks;
400311c4:	01072783          	lw	a5,16(a4)
400311c8:	01052683          	lw	a3,16(a0)
400311cc:	01452583          	lw	a1,20(a0)
400311d0:	01472603          	lw	a2,20(a4)
400311d4:	00d786b3          	add	a3,a5,a3
400311d8:	00f6b7b3          	sltu	a5,a3,a5
400311dc:	00b60633          	add	a2,a2,a1
400311e0:	00c787b3          	add	a5,a5,a2
400311e4:	00d72823          	sw	a3,16(a4)
400311e8:	00f72a23          	sw	a5,20(a4)
	sys_dnode_t *const prev = node->prev;
400311ec:	00452703          	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
400311f0:	00052783          	lw	a5,0(a0)
	prev->next = next;
400311f4:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
400311f8:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
400311fc:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
40031200:	00052223          	sw	zero,4(a0)
}
40031204:	00008067          	ret

40031208 <timeout_rem>:
/* must be locked */
static k_ticks_t timeout_rem(const struct _timeout *timeout)
{
	k_ticks_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
40031208:	00052783          	lw	a5,0(a0)
4003120c:	08078863          	beqz	a5,4003129c <timeout_rem+0x94>
	return list->head == list;
40031210:	40044737          	lui	a4,0x40044
40031214:	6cc72783          	lw	a5,1740(a4) # 400446cc <timeout_list>
{
40031218:	ff010113          	addi	sp,sp,-16
4003121c:	00112623          	sw	ra,12(sp)
40031220:	00812423          	sw	s0,8(sp)
40031224:	00912223          	sw	s1,4(sp)
40031228:	6cc70713          	addi	a4,a4,1740
	return sys_dlist_is_empty(list) ? NULL : list->head;
4003122c:	00e79463          	bne	a5,a4,40031234 <timeout_rem+0x2c>
40031230:	00000793          	li	a5,0
	return (node == list->tail) ? NULL : node->next;
40031234:	00472683          	lw	a3,4(a4)
40031238:	00000493          	li	s1,0
4003123c:	00000413          	li	s0,0
		return 0;
	}

	for (struct _timeout *t = first(); t != NULL; t = next(t)) {
40031240:	02079863          	bnez	a5,40031270 <timeout_rem+0x68>
		if (timeout == t) {
			break;
		}
	}

	return ticks - elapsed();
40031244:	eddff0ef          	jal	ra,40031120 <elapsed>
40031248:	41f55793          	srai	a5,a0,0x1f
}
4003124c:	00c12083          	lw	ra,12(sp)
	return ticks - elapsed();
40031250:	40f405b3          	sub	a1,s0,a5
}
40031254:	00812403          	lw	s0,8(sp)
	return ticks - elapsed();
40031258:	40a48533          	sub	a0,s1,a0
4003125c:	00a4b4b3          	sltu	s1,s1,a0
40031260:	409585b3          	sub	a1,a1,s1
}
40031264:	00412483          	lw	s1,4(sp)
40031268:	01010113          	addi	sp,sp,16
4003126c:	00008067          	ret
		ticks += t->dticks;
40031270:	0107a703          	lw	a4,16(a5)
40031274:	0147a583          	lw	a1,20(a5)
40031278:	00e48733          	add	a4,s1,a4
4003127c:	00973633          	sltu	a2,a4,s1
40031280:	00b40433          	add	s0,s0,a1
40031284:	00070493          	mv	s1,a4
40031288:	00860433          	add	s0,a2,s0
		if (timeout == t) {
4003128c:	faa78ce3          	beq	a5,a0,40031244 <timeout_rem+0x3c>
40031290:	faf68ae3          	beq	a3,a5,40031244 <timeout_rem+0x3c>
40031294:	0007a783          	lw	a5,0(a5)
40031298:	fa9ff06f          	j	40031240 <timeout_rem+0x38>
		return 0;
4003129c:	00000513          	li	a0,0
400312a0:	00000593          	li	a1,0
}
400312a4:	00008067          	ret

400312a8 <z_add_timeout>:
{
400312a8:	fe010113          	addi	sp,sp,-32
400312ac:	00812c23          	sw	s0,24(sp)
400312b0:	01212823          	sw	s2,16(sp)
400312b4:	01312623          	sw	s3,12(sp)
400312b8:	00068713          	mv	a4,a3
400312bc:	00068993          	mv	s3,a3
400312c0:	00112e23          	sw	ra,28(sp)
400312c4:	00912a23          	sw	s1,20(sp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
400312c8:	fff00693          	li	a3,-1
{
400312cc:	00050413          	mv	s0,a0
400312d0:	00060913          	mv	s2,a2
400312d4:	00060793          	mv	a5,a2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
400312d8:	00d61463          	bne	a2,a3,400312e0 <z_add_timeout+0x38>
400312dc:	12c98663          	beq	s3,a2,40031408 <z_add_timeout+0x160>
	to->fn = fn;
400312e0:	00b42423          	sw	a1,8(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
400312e4:	300474f3          	csrrci	s1,mstatus,8
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
400312e8:	08075863          	bgez	a4,40031378 <z_add_timeout+0xd0>
400312ec:	fff00693          	li	a3,-1
400312f0:	00d71663          	bne	a4,a3,400312fc <z_add_timeout+0x54>
400312f4:	ffe00713          	li	a4,-2
400312f8:	08f76063          	bltu	a4,a5,40031378 <z_add_timeout+0xd0>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
400312fc:	400397b7          	lui	a5,0x40039
40031300:	fc87a703          	lw	a4,-56(a5) # 40038fc8 <curr_tick>
40031304:	fcc7a783          	lw	a5,-52(a5)
40031308:	ffe00693          	li	a3,-2
4003130c:	40e68733          	sub	a4,a3,a4
40031310:	00e6b6b3          	sltu	a3,a3,a4
40031314:	fff7c793          	not	a5,a5
40031318:	40d787b3          	sub	a5,a5,a3
4003131c:	41270533          	sub	a0,a4,s2
40031320:	00a73733          	sltu	a4,a4,a0
40031324:	413787b3          	sub	a5,a5,s3
40031328:	40e787b3          	sub	a5,a5,a4
			to->dticks = MAX(1, ticks);
4003132c:	00f04a63          	bgtz	a5,40031340 <z_add_timeout+0x98>
40031330:	00079463          	bnez	a5,40031338 <z_add_timeout+0x90>
40031334:	00051663          	bnez	a0,40031340 <z_add_timeout+0x98>
40031338:	00100513          	li	a0,1
4003133c:	00000793          	li	a5,0
	return list->head == list;
40031340:	40044737          	lui	a4,0x40044
40031344:	00f42a23          	sw	a5,20(s0)
40031348:	6cc72783          	lw	a5,1740(a4) # 400446cc <timeout_list>
4003134c:	00a42823          	sw	a0,16(s0)
40031350:	6cc70713          	addi	a4,a4,1740
	return sys_dlist_is_empty(list) ? NULL : list->head;
40031354:	00e79463          	bne	a5,a4,4003135c <z_add_timeout+0xb4>
40031358:	00000793          	li	a5,0
	return (node == list->tail) ? NULL : node->next;
4003135c:	00472803          	lw	a6,4(a4)
		for (t = first(); t != NULL; t = next(t)) {
40031360:	04079063          	bnez	a5,400313a0 <z_add_timeout+0xf8>
	node->next = list;
40031364:	00e42023          	sw	a4,0(s0)
	node->prev = tail;
40031368:	01042223          	sw	a6,4(s0)
	tail->next = node;
4003136c:	00882023          	sw	s0,0(a6)
	list->tail = node;
40031370:	00872223          	sw	s0,4(a4)
}
40031374:	0740006f          	j	400313e8 <z_add_timeout+0x140>
			to->dticks = timeout.ticks + 1 + elapsed();
40031378:	da9ff0ef          	jal	ra,40031120 <elapsed>
4003137c:	00190793          	addi	a5,s2,1
40031380:	0127b933          	sltu	s2,a5,s2
40031384:	41f55713          	srai	a4,a0,0x1f
40031388:	01390933          	add	s2,s2,s3
4003138c:	00a78533          	add	a0,a5,a0
40031390:	00f537b3          	sltu	a5,a0,a5
40031394:	00e90933          	add	s2,s2,a4
40031398:	012787b3          	add	a5,a5,s2
4003139c:	fa5ff06f          	j	40031340 <z_add_timeout+0x98>
			if (t->dticks > to->dticks) {
400313a0:	0147a503          	lw	a0,20(a5)
400313a4:	01442583          	lw	a1,20(s0)
400313a8:	0107a683          	lw	a3,16(a5)
400313ac:	01042603          	lw	a2,16(s0)
400313b0:	00a5c663          	blt	a1,a0,400313bc <z_add_timeout+0x114>
400313b4:	06b51863          	bne	a0,a1,40031424 <z_add_timeout+0x17c>
400313b8:	06d67663          	bgeu	a2,a3,40031424 <z_add_timeout+0x17c>
				t->dticks -= to->dticks;
400313bc:	40c68633          	sub	a2,a3,a2
400313c0:	00c6b6b3          	sltu	a3,a3,a2
400313c4:	40b50533          	sub	a0,a0,a1
400313c8:	40d50533          	sub	a0,a0,a3
	sys_dnode_t *const prev = successor->prev;
400313cc:	0047a683          	lw	a3,4(a5)
400313d0:	00c7a823          	sw	a2,16(a5)
400313d4:	00a7aa23          	sw	a0,20(a5)
	node->prev = prev;
400313d8:	00d42223          	sw	a3,4(s0)
	node->next = successor;
400313dc:	00f42023          	sw	a5,0(s0)
	prev->next = node;
400313e0:	0086a023          	sw	s0,0(a3)
	successor->prev = node;
400313e4:	0087a223          	sw	s0,4(a5)
	return list->head == list;
400313e8:	00072783          	lw	a5,0(a4)
	return sys_dlist_is_empty(list) ? NULL : list->head;
400313ec:	00e78a63          	beq	a5,a4,40031400 <z_add_timeout+0x158>
		if (to == first()) {
400313f0:	00f41863          	bne	s0,a5,40031400 <z_add_timeout+0x158>
			sys_clock_set_timeout(next_timeout(), false);
400313f4:	d45ff0ef          	jal	ra,40031138 <next_timeout>
400313f8:	00000593          	li	a1,0
400313fc:	addfb0ef          	jal	ra,4002ced8 <sys_clock_set_timeout>
	__asm__ volatile ("csrs mstatus, %0"
40031400:	0084f493          	andi	s1,s1,8
40031404:	3004a073          	csrs	mstatus,s1
}
40031408:	01c12083          	lw	ra,28(sp)
4003140c:	01812403          	lw	s0,24(sp)
40031410:	01412483          	lw	s1,20(sp)
40031414:	01012903          	lw	s2,16(sp)
40031418:	00c12983          	lw	s3,12(sp)
4003141c:	02010113          	addi	sp,sp,32
40031420:	00008067          	ret
			to->dticks -= t->dticks;
40031424:	40d606b3          	sub	a3,a2,a3
40031428:	00d63633          	sltu	a2,a2,a3
4003142c:	40a585b3          	sub	a1,a1,a0
40031430:	40c585b3          	sub	a1,a1,a2
40031434:	00d42823          	sw	a3,16(s0)
40031438:	00b42a23          	sw	a1,20(s0)
	return (node == list->tail) ? NULL : node->next;
4003143c:	f30784e3          	beq	a5,a6,40031364 <z_add_timeout+0xbc>
40031440:	0007a783          	lw	a5,0(a5)
40031444:	f1dff06f          	j	40031360 <z_add_timeout+0xb8>

40031448 <z_abort_timeout>:
{
40031448:	ff010113          	addi	sp,sp,-16
4003144c:	00112623          	sw	ra,12(sp)
40031450:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031454:	30047473          	csrrci	s0,mstatus,8
		if (sys_dnode_is_linked(&to->node)) {
40031458:	00052783          	lw	a5,0(a0)
4003145c:	02078263          	beqz	a5,40031480 <z_abort_timeout+0x38>
			remove_timeout(to);
40031460:	d4dff0ef          	jal	ra,400311ac <remove_timeout>
			ret = 0;
40031464:	00000513          	li	a0,0
	__asm__ volatile ("csrs mstatus, %0"
40031468:	00847413          	andi	s0,s0,8
4003146c:	30042073          	csrs	mstatus,s0
}
40031470:	00c12083          	lw	ra,12(sp)
40031474:	00812403          	lw	s0,8(sp)
40031478:	01010113          	addi	sp,sp,16
4003147c:	00008067          	ret
	int ret = -EINVAL;
40031480:	fea00513          	li	a0,-22
40031484:	fe5ff06f          	j	40031468 <z_abort_timeout+0x20>

40031488 <z_timeout_remaining>:

k_ticks_t z_timeout_remaining(const struct _timeout *timeout)
{
40031488:	ff010113          	addi	sp,sp,-16
4003148c:	00112623          	sw	ra,12(sp)
40031490:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031494:	30047473          	csrrci	s0,mstatus,8
	k_ticks_t ticks = 0;

	LOCKED(&timeout_lock) {
		ticks = timeout_rem(timeout);
40031498:	d71ff0ef          	jal	ra,40031208 <timeout_rem>
	__asm__ volatile ("csrs mstatus, %0"
4003149c:	00847793          	andi	a5,s0,8
400314a0:	3007a073          	csrs	mstatus,a5
	}

	return ticks;
}
400314a4:	00c12083          	lw	ra,12(sp)
400314a8:	00812403          	lw	s0,8(sp)
400314ac:	01010113          	addi	sp,sp,16
400314b0:	00008067          	ret

400314b4 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
400314b4:	fd010113          	addi	sp,sp,-48
400314b8:	02112623          	sw	ra,44(sp)
400314bc:	02812423          	sw	s0,40(sp)
400314c0:	02912223          	sw	s1,36(sp)
400314c4:	03212023          	sw	s2,32(sp)
400314c8:	01312e23          	sw	s3,28(sp)
400314cc:	01412c23          	sw	s4,24(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
400314d0:	300474f3          	csrrci	s1,mstatus,8
	return list->head == list;
400314d4:	400449b7          	lui	s3,0x40044
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
400314d8:	40039a37          	lui	s4,0x40039
400314dc:	10aa2023          	sw	a0,256(s4) # 40039100 <announce_remaining>
400314e0:	6cc9a503          	lw	a0,1740(s3) # 400446cc <timeout_list>
400314e4:	6cc98993          	addi	s3,s3,1740
	return sys_dlist_is_empty(list) ? NULL : list->head;
400314e8:	01351463          	bne	a0,s3,400314f0 <sys_clock_announce+0x3c>
400314ec:	00000513          	li	a0,0
	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
400314f0:	40039937          	lui	s2,0x40039
400314f4:	fc892703          	lw	a4,-56(s2) # 40038fc8 <curr_tick>
400314f8:	fcc92583          	lw	a1,-52(s2)
	     (t != NULL) && (t->dticks <= announce_remaining);
400314fc:	100a2783          	lw	a5,256(s4)
			  : "r" (key & MSTATUS_IEN)
40031500:	0084f493          	andi	s1,s1,8
40031504:	0a050263          	beqz	a0,400315a8 <sys_clock_announce+0xf4>
40031508:	01452683          	lw	a3,20(a0)
4003150c:	41f7d613          	srai	a2,a5,0x1f
40031510:	01052403          	lw	s0,16(a0)
40031514:	00d64663          	blt	a2,a3,40031520 <sys_clock_announce+0x6c>
40031518:	02c69263          	bne	a3,a2,4003153c <sys_clock_announce+0x88>
4003151c:	0287f063          	bgeu	a5,s0,4003153c <sys_clock_announce+0x88>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
40031520:	40f40833          	sub	a6,s0,a5
40031524:	01043433          	sltu	s0,s0,a6
40031528:	40c686b3          	sub	a3,a3,a2
4003152c:	408686b3          	sub	a3,a3,s0
40031530:	01052823          	sw	a6,16(a0)
40031534:	00d52a23          	sw	a3,20(a0)
40031538:	0700006f          	j	400315a8 <sys_clock_announce+0xf4>
		curr_tick += dt;
4003153c:	00e40733          	add	a4,s0,a4
40031540:	41f45693          	srai	a3,s0,0x1f
40031544:	008737b3          	sltu	a5,a4,s0
40031548:	00b686b3          	add	a3,a3,a1
4003154c:	00d787b3          	add	a5,a5,a3
40031550:	fcf92623          	sw	a5,-52(s2)
		t->dticks = 0;
40031554:	00000813          	li	a6,0
40031558:	00000793          	li	a5,0
4003155c:	00f52823          	sw	a5,16(a0)
40031560:	01052a23          	sw	a6,20(a0)
		curr_tick += dt;
40031564:	fce92423          	sw	a4,-56(s2)
		remove_timeout(t);
40031568:	00a12623          	sw	a0,12(sp)
4003156c:	c41ff0ef          	jal	ra,400311ac <remove_timeout>
	__asm__ volatile ("csrs mstatus, %0"
40031570:	3004a073          	csrs	mstatus,s1
		t->fn(t);
40031574:	00c12503          	lw	a0,12(sp)
40031578:	00852783          	lw	a5,8(a0)
4003157c:	000780e7          	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031580:	300476f3          	csrrci	a3,mstatus,8
		announce_remaining -= dt;
40031584:	100a2783          	lw	a5,256(s4)
	return list->head == list;
40031588:	0009a503          	lw	a0,0(s3)
	k.key = arch_irq_lock();
4003158c:	00068493          	mv	s1,a3
40031590:	408787b3          	sub	a5,a5,s0
40031594:	10fa2023          	sw	a5,256(s4)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40031598:	f5351ee3          	bne	a0,s3,400314f4 <sys_clock_announce+0x40>
		curr_tick += dt;
4003159c:	fc892703          	lw	a4,-56(s2)
400315a0:	fcc92583          	lw	a1,-52(s2)
400315a4:	0086f493          	andi	s1,a3,8
	}

	curr_tick += announce_remaining;
400315a8:	00e78733          	add	a4,a5,a4
400315ac:	41f7d693          	srai	a3,a5,0x1f
400315b0:	00b686b3          	add	a3,a3,a1
400315b4:	00f737b3          	sltu	a5,a4,a5
400315b8:	00d787b3          	add	a5,a5,a3
400315bc:	fce92423          	sw	a4,-56(s2)
400315c0:	fcf92623          	sw	a5,-52(s2)
	announce_remaining = 0;
400315c4:	100a2023          	sw	zero,256(s4)

	sys_clock_set_timeout(next_timeout(), false);
400315c8:	b71ff0ef          	jal	ra,40031138 <next_timeout>
400315cc:	00000593          	li	a1,0
400315d0:	909fb0ef          	jal	ra,4002ced8 <sys_clock_set_timeout>
	__asm__ volatile ("csrs mstatus, %0"
400315d4:	3004a073          	csrs	mstatus,s1
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
400315d8:	02812403          	lw	s0,40(sp)
400315dc:	02c12083          	lw	ra,44(sp)
400315e0:	02412483          	lw	s1,36(sp)
400315e4:	02012903          	lw	s2,32(sp)
400315e8:	01c12983          	lw	s3,28(sp)
400315ec:	01812a03          	lw	s4,24(sp)
400315f0:	03010113          	addi	sp,sp,48
	z_time_slice();
400315f4:	97cff06f          	j	40030770 <z_time_slice>

400315f8 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
400315f8:	ff010113          	addi	sp,sp,-16
400315fc:	00112623          	sw	ra,12(sp)
40031600:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031604:	30047473          	csrrci	s0,mstatus,8
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
40031608:	b19ff0ef          	jal	ra,40031120 <elapsed>
4003160c:	40039737          	lui	a4,0x40039
40031610:	00050593          	mv	a1,a0
40031614:	41f55793          	srai	a5,a0,0x1f
40031618:	fc872503          	lw	a0,-56(a4) # 40038fc8 <curr_tick>
4003161c:	fcc72703          	lw	a4,-52(a4)
	__asm__ volatile ("csrs mstatus, %0"
40031620:	00847413          	andi	s0,s0,8
40031624:	00a58533          	add	a0,a1,a0
40031628:	00b535b3          	sltu	a1,a0,a1
4003162c:	00e787b3          	add	a5,a5,a4
40031630:	00f585b3          	add	a1,a1,a5
40031634:	30042073          	csrs	mstatus,s0
	}
	return t;
}
40031638:	00c12083          	lw	ra,12(sp)
4003163c:	00812403          	lw	s0,8(sp)
40031640:	01010113          	addi	sp,sp,16
40031644:	00008067          	ret

40031648 <sys_clock_tick_get_32>:
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
#else
	return (uint32_t)curr_tick;
#endif
}
40031648:	400397b7          	lui	a5,0x40039
4003164c:	fc87a503          	lw	a0,-56(a5) # 40038fc8 <curr_tick>
40031650:	00008067          	ret

40031654 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
40031654:	fa5ff06f          	j	400315f8 <sys_clock_tick_get>

40031658 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
40031658:	06050263          	beqz	a0,400316bc <z_impl_k_busy_wait+0x64>
{
4003165c:	ff010113          	addi	sp,sp,-16
40031660:	00112623          	sw	ra,12(sp)
40031664:	00812423          	sw	s0,8(sp)
40031668:	00912223          	sw	s1,4(sp)
4003166c:	00050413          	mv	s0,a0
	return sys_clock_cycle_get_32();
40031670:	8f9fb0ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>
#if !defined(CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT)
	uint32_t start_cycles = k_cycle_get_32();

	/* use 64-bit math to prevent overflow when multiplying */
	uint32_t cycles_to_wait = (uint32_t)(
		(uint64_t)usec_to_wait *
40031674:	05f5e7b7          	lui	a5,0x5f5e
40031678:	10078793          	addi	a5,a5,256 # 5f5e100 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC>
4003167c:	02f435b3          	mulhu	a1,s0,a5
40031680:	00050493          	mv	s1,a0
		(uint64_t)sys_clock_hw_cycles_per_sec() /
40031684:	000f4637          	lui	a2,0xf4
40031688:	24060613          	addi	a2,a2,576 # f4240 <__rom_region_size+0xbb284>
4003168c:	00000693          	li	a3,0
40031690:	02f40533          	mul	a0,s0,a5
40031694:	c25ce0ef          	jal	ra,400002b8 <__udivdi3>
40031698:	00050413          	mv	s0,a0
4003169c:	8cdfb0ef          	jal	ra,4002cf68 <sys_clock_cycle_get_32>

	for (;;) {
		uint32_t current_cycles = k_cycle_get_32();

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
400316a0:	409507b3          	sub	a5,a0,s1
400316a4:	fe87ece3          	bltu	a5,s0,4003169c <z_impl_k_busy_wait+0x44>
	}
#else
	arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
400316a8:	00c12083          	lw	ra,12(sp)
400316ac:	00812403          	lw	s0,8(sp)
400316b0:	00412483          	lw	s1,4(sp)
400316b4:	01010113          	addi	sp,sp,16
400316b8:	00008067          	ret
400316bc:	00008067          	ret

400316c0 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
400316c0:	ff010113          	addi	sp,sp,-16
400316c4:	00812423          	sw	s0,8(sp)
400316c8:	00912223          	sw	s1,4(sp)
400316cc:	00112623          	sw	ra,12(sp)
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
400316d0:	fff00693          	li	a3,-1
{
400316d4:	00050493          	mv	s1,a0
400316d8:	00058413          	mv	s0,a1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
400316dc:	00d51463          	bne	a0,a3,400316e4 <sys_clock_timeout_end_calc+0x24>
400316e0:	06a58263          	beq	a1,a0,40031744 <sys_clock_timeout_end_calc+0x84>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
400316e4:	009467b3          	or	a5,s0,s1
400316e8:	00079c63          	bnez	a5,40031700 <sys_clock_timeout_end_calc+0x40>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
400316ec:	00812403          	lw	s0,8(sp)
400316f0:	00c12083          	lw	ra,12(sp)
400316f4:	00412483          	lw	s1,4(sp)
400316f8:	01010113          	addi	sp,sp,16
		return sys_clock_tick_get();
400316fc:	efdff06f          	j	400315f8 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
40031700:	ffe00793          	li	a5,-2
40031704:	40978533          	sub	a0,a5,s1
40031708:	00a7b7b3          	sltu	a5,a5,a0
4003170c:	fff44593          	not	a1,s0
40031710:	40f585b3          	sub	a1,a1,a5
40031714:	0005de63          	bgez	a1,40031730 <sys_clock_timeout_end_calc+0x70>
		return sys_clock_tick_get() + MAX(1, dt);
40031718:	ee1ff0ef          	jal	ra,400315f8 <sys_clock_tick_get>
4003171c:	00050793          	mv	a5,a0
40031720:	00950533          	add	a0,a0,s1
40031724:	00f537b3          	sltu	a5,a0,a5
40031728:	008585b3          	add	a1,a1,s0
4003172c:	00b785b3          	add	a1,a5,a1
}
40031730:	00c12083          	lw	ra,12(sp)
40031734:	00812403          	lw	s0,8(sp)
40031738:	00412483          	lw	s1,4(sp)
4003173c:	01010113          	addi	sp,sp,16
40031740:	00008067          	ret
		return UINT64_MAX;
40031744:	fff00513          	li	a0,-1
40031748:	fff00593          	li	a1,-1
4003174c:	fe5ff06f          	j	40031730 <sys_clock_timeout_end_calc+0x70>

40031750 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
40031750:	fd010113          	addi	sp,sp,-48
40031754:	02112623          	sw	ra,44(sp)
40031758:	02812423          	sw	s0,40(sp)
4003175c:	02912223          	sw	s1,36(sp)
40031760:	03212023          	sw	s2,32(sp)
40031764:	01312e23          	sw	s3,28(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031768:	300474f3          	csrrci	s1,mstatus,8
	 * interrupt. Then, the timeout structure for this timer will turn out
	 * to be linked to the timeout list. And in such case, since the timer
	 * was restarted, its expiration handler should not be executed then,
	 * so the function exits immediately.
	 */
	if (sys_dnode_is_linked(&t->node)) {
4003176c:	00052783          	lw	a5,0(a0)
40031770:	02078463          	beqz	a5,40031798 <z_timer_expiration_handler+0x48>
	__asm__ volatile ("csrs mstatus, %0"
40031774:	0084f493          	andi	s1,s1,8
40031778:	3004a073          	csrs	mstatus,s1
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
4003177c:	02c12083          	lw	ra,44(sp)
40031780:	02812403          	lw	s0,40(sp)
40031784:	02412483          	lw	s1,36(sp)
40031788:	02012903          	lw	s2,32(sp)
4003178c:	01c12983          	lw	s3,28(sp)
40031790:	03010113          	addi	sp,sp,48
40031794:	00008067          	ret
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
40031798:	02852783          	lw	a5,40(a0)
4003179c:	02c52983          	lw	s3,44(a0)
400317a0:	00050413          	mv	s0,a0
400317a4:	00178693          	addi	a3,a5,1
400317a8:	00f6b733          	sltu	a4,a3,a5
400317ac:	01370733          	add	a4,a4,s3
400317b0:	00100613          	li	a2,1
400317b4:	00071463          	bnez	a4,400317bc <z_timer_expiration_handler+0x6c>
400317b8:	08d67a63          	bgeu	a2,a3,4003184c <z_timer_expiration_handler+0xfc>
		next.ticks = MAX(next.ticks - 1, 0);
400317bc:	01304a63          	bgtz	s3,400317d0 <z_timer_expiration_handler+0x80>
400317c0:	00099463          	bnez	s3,400317c8 <z_timer_expiration_handler+0x78>
400317c4:	00079663          	bnez	a5,400317d0 <z_timer_expiration_handler+0x80>
400317c8:	00100793          	li	a5,1
400317cc:	00000993          	li	s3,0
400317d0:	fff78913          	addi	s2,a5,-1
400317d4:	0017b793          	seqz	a5,a5
400317d8:	40f989b3          	sub	s3,s3,a5
	return z_impl_k_uptime_ticks();
400317dc:	e79ff0ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
400317e0:	00150793          	addi	a5,a0,1
400317e4:	00a7b533          	sltu	a0,a5,a0
400317e8:	00b50533          	add	a0,a0,a1
400317ec:	01278733          	add	a4,a5,s2
400317f0:	00f737b3          	sltu	a5,a4,a5
400317f4:	01350533          	add	a0,a0,s3
400317f8:	00a787b3          	add	a5,a5,a0
400317fc:	00f04663          	bgtz	a5,40031808 <z_timer_expiration_handler+0xb8>
40031800:	0a079e63          	bnez	a5,400318bc <z_timer_expiration_handler+0x16c>
40031804:	0a070c63          	beqz	a4,400318bc <z_timer_expiration_handler+0x16c>
40031808:	e4dff0ef          	jal	ra,40031654 <z_impl_k_uptime_ticks>
4003180c:	00150793          	addi	a5,a0,1
40031810:	00a7b533          	sltu	a0,a5,a0
40031814:	01278633          	add	a2,a5,s2
40031818:	00b50533          	add	a0,a0,a1
4003181c:	00f636b3          	sltu	a3,a2,a5
40031820:	01350533          	add	a0,a0,s3
40031824:	ffe00793          	li	a5,-2
40031828:	00a686b3          	add	a3,a3,a0
4003182c:	40c78633          	sub	a2,a5,a2
40031830:	00c7b7b3          	sltu	a5,a5,a2
40031834:	fff6c693          	not	a3,a3
40031838:	40f686b3          	sub	a3,a3,a5
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
4003183c:	400315b7          	lui	a1,0x40031
40031840:	75058593          	addi	a1,a1,1872 # 40031750 <z_timer_expiration_handler>
40031844:	00040513          	mv	a0,s0
40031848:	a61ff0ef          	jal	ra,400312a8 <z_add_timeout>
	timer->status += 1U;
4003184c:	03042783          	lw	a5,48(s0)
40031850:	00178793          	addi	a5,a5,1
40031854:	02f42823          	sw	a5,48(s0)
	if (timer->expiry_fn != NULL) {
40031858:	02042783          	lw	a5,32(s0)
4003185c:	00078e63          	beqz	a5,40031878 <z_timer_expiration_handler+0x128>
40031860:	0084f493          	andi	s1,s1,8
40031864:	3004a073          	csrs	mstatus,s1
		timer->expiry_fn(timer);
40031868:	02042783          	lw	a5,32(s0)
4003186c:	00040513          	mv	a0,s0
40031870:	000780e7          	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031874:	300474f3          	csrrci	s1,mstatus,8
	return list->head == list;
40031878:	01842503          	lw	a0,24(s0)
4003187c:	01840413          	addi	s0,s0,24
			  : "r" (key & MSTATUS_IEN)
40031880:	0084f493          	andi	s1,s1,8
	return sys_dlist_is_empty(list) ? NULL : list->head;
40031884:	ee850ae3          	beq	a0,s0,40031778 <z_timer_expiration_handler+0x28>
	if (thread == NULL) {
40031888:	ee0508e3          	beqz	a0,40031778 <z_timer_expiration_handler+0x28>
	z_unpend_thread_no_timeout(thread);
4003188c:	00a12623          	sw	a0,12(sp)
40031890:	f89fe0ef          	jal	ra,40030818 <z_unpend_thread_no_timeout>
	thread->swap_retval = value;
40031894:	00c12503          	lw	a0,12(sp)
40031898:	0a052e23          	sw	zero,188(a0)
	__asm__ volatile ("csrs mstatus, %0"
4003189c:	3004a073          	csrs	mstatus,s1
}
400318a0:	02812403          	lw	s0,40(sp)
400318a4:	02c12083          	lw	ra,44(sp)
400318a8:	02412483          	lw	s1,36(sp)
400318ac:	02012903          	lw	s2,32(sp)
400318b0:	01c12983          	lw	s3,28(sp)
400318b4:	03010113          	addi	sp,sp,48
	z_ready_thread(thread);
400318b8:	f35fe06f          	j	400307ec <z_ready_thread>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
400318bc:	ffe00613          	li	a2,-2
400318c0:	fff00693          	li	a3,-1
400318c4:	f79ff06f          	j	4003183c <z_timer_expiration_handler+0xec>

400318c8 <k_timer_init>:
	sys_dlist_init(&w->waitq);
400318c8:	01850793          	addi	a5,a0,24

void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
	timer->expiry_fn = expiry_fn;
400318cc:	02b52023          	sw	a1,32(a0)
	timer->stop_fn = stop_fn;
400318d0:	02c52223          	sw	a2,36(a0)
	timer->status = 0U;
400318d4:	02052823          	sw	zero,48(a0)
	list->head = (sys_dnode_t *)list;
400318d8:	00f52c23          	sw	a5,24(a0)
	list->tail = (sys_dnode_t *)list;
400318dc:	00f52e23          	sw	a5,28(a0)
	node->next = NULL;
400318e0:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
400318e4:	00052223          	sw	zero,4(a0)

	z_init_timeout(&timer->timeout);

	SYS_PORT_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
400318e8:	02052a23          	sw	zero,52(a0)

	z_object_init(timer);
}
400318ec:	00008067          	ret

400318f0 <z_impl_k_timer_start>:


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
400318f0:	fd010113          	addi	sp,sp,-48
400318f4:	00060793          	mv	a5,a2
400318f8:	02812423          	sw	s0,40(sp)
400318fc:	02912223          	sw	s1,36(sp)
40031900:	03212023          	sw	s2,32(sp)
40031904:	01312e23          	sw	s3,28(sp)
40031908:	00070913          	mv	s2,a4
4003190c:	02112623          	sw	ra,44(sp)
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer, duration, period);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
40031910:	fff00713          	li	a4,-1
{
40031914:	00050413          	mv	s0,a0
40031918:	00068993          	mv	s3,a3
4003191c:	00058613          	mv	a2,a1
40031920:	00078493          	mv	s1,a5
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
40031924:	00e59463          	bne	a1,a4,4003192c <z_impl_k_timer_start+0x3c>
40031928:	08b78063          	beq	a5,a1,400319a8 <z_impl_k_timer_start+0xb8>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (Z_TICK_ABS(duration.ticks) < 0) {
4003192c:	0007da63          	bgez	a5,40031940 <z_impl_k_timer_start+0x50>
40031930:	fff00713          	li	a4,-1
40031934:	02e79663          	bne	a5,a4,40031960 <z_impl_k_timer_start+0x70>
40031938:	ffe00713          	li	a4,-2
4003193c:	02b77263          	bgeu	a4,a1,40031960 <z_impl_k_timer_start+0x70>
		duration.ticks = MAX(duration.ticks - 1, 0);
40031940:	00f04a63          	bgtz	a5,40031954 <z_impl_k_timer_start+0x64>
40031944:	00079463          	bnez	a5,4003194c <z_impl_k_timer_start+0x5c>
40031948:	00059663          	bnez	a1,40031954 <z_impl_k_timer_start+0x64>
4003194c:	00100593          	li	a1,1
40031950:	00000793          	li	a5,0
40031954:	0015b493          	seqz	s1,a1
40031958:	fff58613          	addi	a2,a1,-1
4003195c:	409784b3          	sub	s1,a5,s1
	}

	(void)z_abort_timeout(&timer->timeout);
40031960:	00040513          	mv	a0,s0
40031964:	00c12623          	sw	a2,12(sp)
40031968:	ae1ff0ef          	jal	ra,40031448 <z_abort_timeout>
	timer->period = period;
4003196c:	03342423          	sw	s3,40(s0)
40031970:	03242623          	sw	s2,44(s0)
	timer->status = 0U;
40031974:	02042823          	sw	zero,48(s0)

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
40031978:	00040513          	mv	a0,s0
		     duration);
}
4003197c:	02812403          	lw	s0,40(sp)
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
40031980:	00c12603          	lw	a2,12(sp)
}
40031984:	02c12083          	lw	ra,44(sp)
40031988:	02012903          	lw	s2,32(sp)
4003198c:	01c12983          	lw	s3,28(sp)
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
40031990:	00048693          	mv	a3,s1
}
40031994:	02412483          	lw	s1,36(sp)
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
40031998:	400315b7          	lui	a1,0x40031
4003199c:	75058593          	addi	a1,a1,1872 # 40031750 <z_timer_expiration_handler>
}
400319a0:	03010113          	addi	sp,sp,48
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
400319a4:	905ff06f          	j	400312a8 <z_add_timeout>
}
400319a8:	02c12083          	lw	ra,44(sp)
400319ac:	02812403          	lw	s0,40(sp)
400319b0:	02412483          	lw	s1,36(sp)
400319b4:	02012903          	lw	s2,32(sp)
400319b8:	01c12983          	lw	s3,28(sp)
400319bc:	03010113          	addi	sp,sp,48
400319c0:	00008067          	ret

400319c4 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
400319c4:	ff010113          	addi	sp,sp,-16
400319c8:	00812423          	sw	s0,8(sp)
400319cc:	00112623          	sw	ra,12(sp)
400319d0:	00050413          	mv	s0,a0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	bool inactive = (z_abort_timeout(&timer->timeout) != 0);
400319d4:	a75ff0ef          	jal	ra,40031448 <z_abort_timeout>

	if (inactive) {
400319d8:	02051c63          	bnez	a0,40031a10 <z_impl_k_timer_stop+0x4c>
		return;
	}

	if (timer->stop_fn != NULL) {
400319dc:	02442783          	lw	a5,36(s0)
400319e0:	00078663          	beqz	a5,400319ec <z_impl_k_timer_stop+0x28>
		timer->stop_fn(timer);
400319e4:	00040513          	mv	a0,s0
400319e8:	000780e7          	jalr	a5
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
400319ec:	01840513          	addi	a0,s0,24
400319f0:	f25fe0ef          	jal	ra,40030914 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
400319f4:	00050e63          	beqz	a0,40031a10 <z_impl_k_timer_stop+0x4c>
			z_ready_thread(pending_thread);
400319f8:	df5fe0ef          	jal	ra,400307ec <z_ready_thread>
	__asm__ volatile ("csrrc %0, mstatus, %1"
400319fc:	30047573          	csrrci	a0,mstatus,8
			z_reschedule_unlocked();
		}
	}
}
40031a00:	00812403          	lw	s0,8(sp)
40031a04:	00c12083          	lw	ra,12(sp)
40031a08:	01010113          	addi	sp,sp,16
	(void) z_reschedule_irqlock(arch_irq_lock());
40031a0c:	968ff06f          	j	40030b74 <z_reschedule_irqlock>
40031a10:	00c12083          	lw	ra,12(sp)
40031a14:	00812403          	lw	s0,8(sp)
40031a18:	01010113          	addi	sp,sp,16
40031a1c:	00008067          	ret

40031a20 <z_impl_atomic_cas>:
40031a20:	300477f3          	csrrci	a5,mstatus,8
	k_spinlock_key_t key;
	int ret = false;

	key = k_spin_lock(&lock);

	if (*target == old_value) {
40031a24:	00052703          	lw	a4,0(a0)
40031a28:	00b71c63          	bne	a4,a1,40031a40 <z_impl_atomic_cas+0x20>
		*target = new_value;
40031a2c:	00c52023          	sw	a2,0(a0)
		ret = true;
40031a30:	00100513          	li	a0,1
	__asm__ volatile ("csrs mstatus, %0"
40031a34:	0087f793          	andi	a5,a5,8
40031a38:	3007a073          	csrs	mstatus,a5
	}

	k_spin_unlock(&lock, key);

	return ret;
}
40031a3c:	00008067          	ret
	int ret = false;
40031a40:	00000513          	li	a0,0
40031a44:	ff1ff06f          	j	40031a34 <z_impl_atomic_cas+0x14>

40031a48 <z_impl_atomic_add>:
 * @param value the value to add
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_add(atomic_t *target, atomic_val_t value)
{
40031a48:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031a4c:	30047773          	csrrci	a4,mstatus,8
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
40031a50:	00052503          	lw	a0,0(a0)
	*target += value;
40031a54:	00b505b3          	add	a1,a0,a1
40031a58:	00b7a023          	sw	a1,0(a5)
	__asm__ volatile ("csrs mstatus, %0"
40031a5c:	00877793          	andi	a5,a4,8
40031a60:	3007a073          	csrs	mstatus,a5

	k_spin_unlock(&lock, key);

	return ret;
}
40031a64:	00008067          	ret

40031a68 <z_impl_atomic_sub>:
 * @param value the value to subtract
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_sub(atomic_t *target, atomic_val_t value)
{
40031a68:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031a6c:	30047773          	csrrci	a4,mstatus,8
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
40031a70:	00052503          	lw	a0,0(a0)
	*target -= value;
40031a74:	40b505b3          	sub	a1,a0,a1
40031a78:	00b7a023          	sw	a1,0(a5)
	__asm__ volatile ("csrs mstatus, %0"
40031a7c:	00877793          	andi	a5,a4,8
40031a80:	3007a073          	csrs	mstatus,a5

	k_spin_unlock(&lock, key);

	return ret;
}
40031a84:	00008067          	ret

40031a88 <atomic_get>:
 * @return The value read from <target>
 */
atomic_val_t atomic_get(const atomic_t *target)
{
	return *target;
}
40031a88:	00052503          	lw	a0,0(a0)
40031a8c:	00008067          	ret

40031a90 <z_impl_atomic_set>:
 * @param value the value to write
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_set(atomic_t *target, atomic_val_t value)
{
40031a90:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031a94:	30047773          	csrrci	a4,mstatus,8
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
40031a98:	00052503          	lw	a0,0(a0)
	*target = value;
40031a9c:	00b7a023          	sw	a1,0(a5)
	__asm__ volatile ("csrs mstatus, %0"
40031aa0:	00877793          	andi	a5,a4,8
40031aa4:	3007a073          	csrs	mstatus,a5

	k_spin_unlock(&lock, key);

	return ret;
}
40031aa8:	00008067          	ret

40031aac <z_impl_atomic_or>:
 * @param value the value to OR
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_or(atomic_t *target, atomic_val_t value)
{
40031aac:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031ab0:	30047773          	csrrci	a4,mstatus,8
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
40031ab4:	00052503          	lw	a0,0(a0)
	*target |= value;
40031ab8:	00b565b3          	or	a1,a0,a1
40031abc:	00b7a023          	sw	a1,0(a5)
	__asm__ volatile ("csrs mstatus, %0"
40031ac0:	00877793          	andi	a5,a4,8
40031ac4:	3007a073          	csrs	mstatus,a5

	k_spin_unlock(&lock, key);

	return ret;
}
40031ac8:	00008067          	ret

40031acc <z_impl_atomic_and>:
 * @param value the value to AND
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_and(atomic_t *target, atomic_val_t value)
{
40031acc:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031ad0:	30047773          	csrrci	a4,mstatus,8
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
40031ad4:	00052503          	lw	a0,0(a0)
	*target &= value;
40031ad8:	00b575b3          	and	a1,a0,a1
40031adc:	00b7a023          	sw	a1,0(a5)
	__asm__ volatile ("csrs mstatus, %0"
40031ae0:	00877793          	andi	a5,a4,8
40031ae4:	3007a073          	csrs	mstatus,a5

	k_spin_unlock(&lock, key);

	return ret;
}
40031ae8:	00008067          	ret

40031aec <add_event>:
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
}

static inline void add_event(sys_dlist_t *events, struct k_poll_event *event,
			     struct z_poller *poller)
{
40031aec:	fe010113          	addi	sp,sp,-32
40031af0:	00812c23          	sw	s0,24(sp)
40031af4:	00912a23          	sw	s1,20(sp)
40031af8:	00112e23          	sw	ra,28(sp)
40031afc:	01212823          	sw	s2,16(sp)
40031b00:	01312623          	sw	s3,12(sp)
	return sys_dlist_is_empty(list) ? NULL : list->tail;
40031b04:	00052703          	lw	a4,0(a0)
40031b08:	00452783          	lw	a5,4(a0)
40031b0c:	00050413          	mv	s0,a0
40031b10:	00058493          	mv	s1,a1
40031b14:	00e51e63          	bne	a0,a4,40031b30 <add_event+0x44>
	sys_dnode_t *const tail = list->tail;
40031b18:	00442783          	lw	a5,4(s0)
	node->next = list;
40031b1c:	0084a023          	sw	s0,0(s1)
	node->prev = tail;
40031b20:	00f4a223          	sw	a5,4(s1)
	tail->next = node;
40031b24:	0097a023          	sw	s1,0(a5)
	list->tail = node;
40031b28:	00942223          	sw	s1,4(s0)
40031b2c:	05c0006f          	j	40031b88 <add_event+0x9c>
	struct k_poll_event *pending;

	pending = (struct k_poll_event *)sys_dlist_peek_tail(events);
	if ((pending == NULL) ||
40031b30:	fe0784e3          	beqz	a5,40031b18 <add_event+0x2c>
		(z_sched_prio_cmp(poller_thread(pending->poller),
40031b34:	0087a503          	lw	a0,8(a5)
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
40031b38:	00050463          	beqz	a0,40031b40 <add_event+0x54>
40031b3c:	f8c50513          	addi	a0,a0,-116
40031b40:	f8c60993          	addi	s3,a2,-116
		(z_sched_prio_cmp(poller_thread(pending->poller),
40031b44:	00098593          	mv	a1,s3
40031b48:	f40fe0ef          	jal	ra,40030288 <z_sched_prio_cmp>
	if ((pending == NULL) ||
40031b4c:	fca046e3          	bgtz	a0,40031b18 <add_event+0x2c>
	return list->head == list;
40031b50:	00042903          	lw	s2,0(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40031b54:	fd2402e3          	beq	s0,s2,40031b18 <add_event+0x2c>
							   poller_thread(poller)) > 0)) {
		sys_dlist_append(events, &event->_node);
		return;
	}

	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
40031b58:	fc0900e3          	beqz	s2,40031b18 <add_event+0x2c>
		if (z_sched_prio_cmp(poller_thread(poller),
40031b5c:	00892583          	lw	a1,8(s2)
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
40031b60:	00058463          	beqz	a1,40031b68 <add_event+0x7c>
40031b64:	f8c58593          	addi	a1,a1,-116
		if (z_sched_prio_cmp(poller_thread(poller),
40031b68:	00098513          	mv	a0,s3
40031b6c:	f1cfe0ef          	jal	ra,40030288 <z_sched_prio_cmp>
40031b70:	02a05a63          	blez	a0,40031ba4 <add_event+0xb8>
	sys_dnode_t *const prev = successor->prev;
40031b74:	00492783          	lw	a5,4(s2)
	node->next = successor;
40031b78:	0124a023          	sw	s2,0(s1)
	node->prev = prev;
40031b7c:	00f4a223          	sw	a5,4(s1)
	prev->next = node;
40031b80:	0097a023          	sw	s1,0(a5)
	successor->prev = node;
40031b84:	00992223          	sw	s1,4(s2)
			return;
		}
	}

	sys_dlist_append(events, &event->_node);
}
40031b88:	01c12083          	lw	ra,28(sp)
40031b8c:	01812403          	lw	s0,24(sp)
40031b90:	01412483          	lw	s1,20(sp)
40031b94:	01012903          	lw	s2,16(sp)
40031b98:	00c12983          	lw	s3,12(sp)
40031b9c:	02010113          	addi	sp,sp,32
40031ba0:	00008067          	ret
	return (node == list->tail) ? NULL : node->next;
40031ba4:	00442783          	lw	a5,4(s0)
40031ba8:	f6f908e3          	beq	s2,a5,40031b18 <add_event+0x2c>
40031bac:	00092903          	lw	s2,0(s2)
40031bb0:	fa9ff06f          	j	40031b58 <add_event+0x6c>

40031bb4 <register_events>:

static inline int register_events(struct k_poll_event *events,
				  int num_events,
				  struct z_poller *poller,
				  bool just_check)
{
40031bb4:	fc010113          	addi	sp,sp,-64
40031bb8:	03612023          	sw	s6,32(sp)
	event->state |= state;
40031bbc:	ffe04b37          	lui	s6,0xffe04
{
40031bc0:	02812c23          	sw	s0,56(sp)
40031bc4:	02912a23          	sw	s1,52(sp)
40031bc8:	03212823          	sw	s2,48(sp)
40031bcc:	03312623          	sw	s3,44(sp)
40031bd0:	03412423          	sw	s4,40(sp)
40031bd4:	03512223          	sw	s5,36(sp)
40031bd8:	01812c23          	sw	s8,24(sp)
40031bdc:	01912a23          	sw	s9,20(sp)
40031be0:	01a12823          	sw	s10,16(sp)
40031be4:	01b12623          	sw	s11,12(sp)
40031be8:	02112e23          	sw	ra,60(sp)
40031bec:	01712e23          	sw	s7,28(sp)
40031bf0:	00058993          	mv	s3,a1
40031bf4:	00060493          	mv	s1,a2
40031bf8:	00068a93          	mv	s5,a3
40031bfc:	00050413          	mv	s0,a0
	int events_registered = 0;

	for (int ii = 0; ii < num_events; ii++) {
40031c00:	00000a13          	li	s4,0
	int events_registered = 0;
40031c04:	00000913          	li	s2,0
	switch (event->type) {
40031c08:	00400c13          	li	s8,4
	event->state |= state;
40031c0c:	fffb0b13          	addi	s6,s6,-1 # ffe03fff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffe04000>
	switch (event->type) {
40031c10:	00800c93          	li	s9,8
40031c14:	00100d13          	li	s10,1
40031c18:	00200d93          	li	s11,2
	for (int ii = 0; ii < num_events; ii++) {
40031c1c:	053a4263          	blt	s4,s3,40031c60 <register_events+0xac>
		}
		k_spin_unlock(&lock, key);
	}

	return events_registered;
}
40031c20:	03c12083          	lw	ra,60(sp)
40031c24:	03812403          	lw	s0,56(sp)
40031c28:	03412483          	lw	s1,52(sp)
40031c2c:	02c12983          	lw	s3,44(sp)
40031c30:	02812a03          	lw	s4,40(sp)
40031c34:	02412a83          	lw	s5,36(sp)
40031c38:	02012b03          	lw	s6,32(sp)
40031c3c:	01c12b83          	lw	s7,28(sp)
40031c40:	01812c03          	lw	s8,24(sp)
40031c44:	01412c83          	lw	s9,20(sp)
40031c48:	01012d03          	lw	s10,16(sp)
40031c4c:	00c12d83          	lw	s11,12(sp)
40031c50:	00090513          	mv	a0,s2
40031c54:	03012903          	lw	s2,48(sp)
40031c58:	04010113          	addi	sp,sp,64
40031c5c:	00008067          	ret
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031c60:	30047bf3          	csrrci	s7,mstatus,8
	switch (event->type) {
40031c64:	00c42783          	lw	a5,12(s0)
40031c68:	0087d793          	srli	a5,a5,0x8
40031c6c:	03f7f793          	andi	a5,a5,63
40031c70:	07878e63          	beq	a5,s8,40031cec <register_events+0x138>
40031c74:	04fc6663          	bltu	s8,a5,40031cc0 <register_events+0x10c>
40031c78:	0da78063          	beq	a5,s10,40031d38 <register_events+0x184>
40031c7c:	05b78e63          	beq	a5,s11,40031cd8 <register_events+0x124>
		} else if (!just_check && poller->is_polling) {
40031c80:	0a0a9263          	bnez	s5,40031d24 <register_events+0x170>
40031c84:	0004c783          	lbu	a5,0(s1)
40031c88:	08078e63          	beqz	a5,40031d24 <register_events+0x170>
	switch (event->type) {
40031c8c:	00c42783          	lw	a5,12(s0)
40031c90:	00400713          	li	a4,4
40031c94:	0087d793          	srli	a5,a5,0x8
40031c98:	03f7f793          	andi	a5,a5,63
40031c9c:	0ce78663          	beq	a5,a4,40031d68 <register_events+0x1b4>
40031ca0:	0af76663          	bltu	a4,a5,40031d4c <register_events+0x198>
40031ca4:	00100713          	li	a4,1
40031ca8:	0ce78c63          	beq	a5,a4,40031d80 <register_events+0x1cc>
40031cac:	00200713          	li	a4,2
40031cb0:	0ae78c63          	beq	a5,a4,40031d68 <register_events+0x1b4>
	event->poller = poller;
40031cb4:	00942423          	sw	s1,8(s0)
			events_registered += 1;
40031cb8:	00190913          	addi	s2,s2,1
40031cbc:	0680006f          	j	40031d24 <register_events+0x170>
	switch (event->type) {
40031cc0:	fd9790e3          	bne	a5,s9,40031c80 <register_events+0xcc>
		if (event->msgq->used_msgs > 0) {
40031cc4:	01042783          	lw	a5,16(s0)
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
40031cc8:	01000693          	li	a3,16
		if (event->msgq->used_msgs > 0) {
40031ccc:	0207a783          	lw	a5,32(a5)
40031cd0:	fa0788e3          	beqz	a5,40031c80 <register_events+0xcc>
40031cd4:	0280006f          	j	40031cfc <register_events+0x148>
		if (k_sem_count_get(event->sem) > 0U) {
40031cd8:	01042783          	lw	a5,16(s0)
40031cdc:	0087a783          	lw	a5,8(a5)
40031ce0:	fa0780e3          	beqz	a5,40031c80 <register_events+0xcc>
			*state = K_POLL_STATE_SEM_AVAILABLE;
40031ce4:	00200693          	li	a3,2
40031ce8:	0140006f          	j	40031cfc <register_events+0x148>
		if (!k_queue_is_empty(event->queue)) {
40031cec:	01042783          	lw	a5,16(s0)
40031cf0:	0007a783          	lw	a5,0(a5)
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
40031cf4:	00400693          	li	a3,4
		if (!k_queue_is_empty(event->queue)) {
40031cf8:	f80784e3          	beqz	a5,40031c80 <register_events+0xcc>
	event->state |= state;
40031cfc:	00c42703          	lw	a4,12(s0)
	event->poller = NULL;
40031d00:	00042423          	sw	zero,8(s0)
	event->state |= state;
40031d04:	00e75793          	srli	a5,a4,0xe
40031d08:	07f7f793          	andi	a5,a5,127
40031d0c:	00d7e7b3          	or	a5,a5,a3
40031d10:	00e79793          	slli	a5,a5,0xe
40031d14:	01677733          	and	a4,a4,s6
40031d18:	00f76733          	or	a4,a4,a5
40031d1c:	00e42623          	sw	a4,12(s0)
			poller->is_polling = false;
40031d20:	00048023          	sb	zero,0(s1)
	__asm__ volatile ("csrs mstatus, %0"
40031d24:	008bfb93          	andi	s7,s7,8
40031d28:	300ba073          	csrs	mstatus,s7
	for (int ii = 0; ii < num_events; ii++) {
40031d2c:	001a0a13          	addi	s4,s4,1
40031d30:	01440413          	addi	s0,s0,20
40031d34:	ee9ff06f          	j	40031c1c <register_events+0x68>
		if (event->signal->signaled != 0U) {
40031d38:	01042783          	lw	a5,16(s0)
40031d3c:	0087a783          	lw	a5,8(a5)
40031d40:	f40780e3          	beqz	a5,40031c80 <register_events+0xcc>
			*state = K_POLL_STATE_SIGNALED;
40031d44:	00100693          	li	a3,1
40031d48:	fb5ff06f          	j	40031cfc <register_events+0x148>
	switch (event->type) {
40031d4c:	00800713          	li	a4,8
40031d50:	f6e792e3          	bne	a5,a4,40031cb4 <register_events+0x100>
		add_event(&event->msgq->poll_events, event, poller);
40031d54:	01042503          	lw	a0,16(s0)
40031d58:	00048613          	mv	a2,s1
40031d5c:	00040593          	mv	a1,s0
40031d60:	02450513          	addi	a0,a0,36
40031d64:	0140006f          	j	40031d78 <register_events+0x1c4>
		add_event(&event->queue->poll_events, event, poller);
40031d68:	01042503          	lw	a0,16(s0)
40031d6c:	00048613          	mv	a2,s1
40031d70:	00040593          	mv	a1,s0
40031d74:	01050513          	addi	a0,a0,16
		add_event(&event->msgq->poll_events, event, poller);
40031d78:	d75ff0ef          	jal	ra,40031aec <add_event>
		break;
40031d7c:	f39ff06f          	j	40031cb4 <register_events+0x100>
		add_event(&event->signal->poll_events, event, poller);
40031d80:	01042503          	lw	a0,16(s0)
40031d84:	00048613          	mv	a2,s1
40031d88:	00040593          	mv	a1,s0
40031d8c:	fedff06f          	j	40031d78 <register_events+0x1c4>

40031d90 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
40031d90:	fd010113          	addi	sp,sp,-48
40031d94:	02912223          	sw	s1,36(sp)
40031d98:	03212023          	sw	s2,32(sp)
40031d9c:	02112623          	sw	ra,44(sp)
40031da0:	02812423          	sw	s0,40(sp)
40031da4:	01312e23          	sw	s3,28(sp)
	struct z_poller *poller = event->poller;
40031da8:	00852403          	lw	s0,8(a0)
{
40031dac:	00050913          	mv	s2,a0
40031db0:	00058493          	mv	s1,a1
	int retcode = 0;

	if (poller != NULL) {
40031db4:	02040063          	beqz	s0,40031dd4 <signal_poll_event+0x44>
		if (poller->mode == MODE_POLL) {
40031db8:	00144783          	lbu	a5,1(s0)
40031dbc:	00100713          	li	a4,1
40031dc0:	0ae79063          	bne	a5,a4,40031e60 <signal_poll_event+0xd0>
	if (!z_is_thread_pending(thread)) {
40031dc4:	f9944783          	lbu	a5,-103(s0)
40031dc8:	0027f793          	andi	a5,a5,2
40031dcc:	02079e63          	bnez	a5,40031e08 <signal_poll_event+0x78>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
40031dd0:	00040023          	sb	zero,0(s0)
	event->state |= state;
40031dd4:	00c92783          	lw	a5,12(s2)
	event->poller = NULL;
40031dd8:	00092423          	sw	zero,8(s2)
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
40031ddc:	00000513          	li	a0,0
	event->state |= state;
40031de0:	00e7d713          	srli	a4,a5,0xe
40031de4:	00e4e4b3          	or	s1,s1,a4
40031de8:	ffe04737          	lui	a4,0xffe04
40031dec:	07f4f493          	andi	s1,s1,127
40031df0:	fff70713          	addi	a4,a4,-1 # ffe03fff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffe04000>
40031df4:	00e49493          	slli	s1,s1,0xe
40031df8:	00e7f7b3          	and	a5,a5,a4
40031dfc:	0097e7b3          	or	a5,a5,s1
40031e00:	00f92623          	sw	a5,12(s2)
	return retcode;
40031e04:	0a00006f          	j	40031ea4 <signal_poll_event+0x114>
	if (z_is_thread_timeout_expired(thread)) {
40031e08:	fb442703          	lw	a4,-76(s0)
40031e0c:	ffe00793          	li	a5,-2
40031e10:	00f71863          	bne	a4,a5,40031e20 <signal_poll_event+0x90>
40031e14:	fb842703          	lw	a4,-72(s0)
40031e18:	fff00793          	li	a5,-1
40031e1c:	08f70063          	beq	a4,a5,40031e9c <signal_poll_event+0x10c>
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
40031e20:	f8c40513          	addi	a0,s0,-116
	z_unpend_thread(thread);
40031e24:	00a12623          	sw	a0,12(sp)
40031e28:	b91fe0ef          	jal	ra,400309b8 <z_unpend_thread>
	arch_thread_return_value_set(thread,
40031e2c:	00800713          	li	a4,8
40031e30:	00c12503          	lw	a0,12(sp)
40031e34:	ffc00793          	li	a5,-4
40031e38:	00e48463          	beq	s1,a4,40031e40 <signal_poll_event+0xb0>
40031e3c:	00000793          	li	a5,0
40031e40:	04f42423          	sw	a5,72(s0)
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
40031e44:	f9944783          	lbu	a5,-103(s0)
40031e48:	01f7f793          	andi	a5,a5,31
40031e4c:	f80792e3          	bnez	a5,40031dd0 <signal_poll_event+0x40>
40031e50:	fa442783          	lw	a5,-92(s0)
40031e54:	f6079ee3          	bnez	a5,40031dd0 <signal_poll_event+0x40>
	z_ready_thread(thread);
40031e58:	995fe0ef          	jal	ra,400307ec <z_ready_thread>
		poller->is_polling = false;
40031e5c:	f75ff06f          	j	40031dd0 <signal_poll_event+0x40>
		} else if (poller->mode == MODE_TRIGGERED) {
40031e60:	00200713          	li	a4,2
40031e64:	f6e796e3          	bne	a5,a4,40031dd0 <signal_poll_event+0x40>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
40031e68:	00044783          	lbu	a5,0(s0)
40031e6c:	f60784e3          	beqz	a5,40031dd4 <signal_poll_event+0x44>
40031e70:	ffc42983          	lw	s3,-4(s0)
40031e74:	f4098ee3          	beqz	s3,40031dd0 <signal_poll_event+0x40>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
40031e78:	fec40593          	addi	a1,s0,-20
40031e7c:	01440513          	addi	a0,s0,20
40031e80:	00b12623          	sw	a1,12(sp)
40031e84:	dc4ff0ef          	jal	ra,40031448 <z_abort_timeout>
		twork->poll_result = 0;
		z_work_submit_to_queue(work_q, &twork->work);
40031e88:	00c12583          	lw	a1,12(sp)
		twork->poll_result = 0;
40031e8c:	02042623          	sw	zero,44(s0)
		z_work_submit_to_queue(work_q, &twork->work);
40031e90:	00098513          	mv	a0,s3
40031e94:	888fe0ef          	jal	ra,4002ff1c <z_work_submit_to_queue>
40031e98:	f39ff06f          	j	40031dd0 <signal_poll_event+0x40>
		poller->is_polling = false;
40031e9c:	00040023          	sb	zero,0(s0)
		return -EAGAIN;
40031ea0:	ff500513          	li	a0,-11
}
40031ea4:	02c12083          	lw	ra,44(sp)
40031ea8:	02812403          	lw	s0,40(sp)
40031eac:	02412483          	lw	s1,36(sp)
40031eb0:	02012903          	lw	s2,32(sp)
40031eb4:	01c12983          	lw	s3,28(sp)
40031eb8:	03010113          	addi	sp,sp,48
40031ebc:	00008067          	ret

40031ec0 <clear_event_registrations>:
	while (num_events--) {
40031ec0:	01400793          	li	a5,20
40031ec4:	02f587b3          	mul	a5,a1,a5
	switch (event->type) {
40031ec8:	00800693          	li	a3,8
40031ecc:	11600813          	li	a6,278
40031ed0:	fec78793          	addi	a5,a5,-20
40031ed4:	00f50533          	add	a0,a0,a5
	while (num_events--) {
40031ed8:	00059463          	bnez	a1,40031ee0 <clear_event_registrations+0x20>
}
40031edc:	00008067          	ret
	switch (event->type) {
40031ee0:	00c52783          	lw	a5,12(a0)
	event->poller = NULL;
40031ee4:	00052423          	sw	zero,8(a0)
	switch (event->type) {
40031ee8:	0087d793          	srli	a5,a5,0x8
40031eec:	03f7f793          	andi	a5,a5,63
40031ef0:	02f6e663          	bltu	a3,a5,40031f1c <clear_event_registrations+0x5c>
40031ef4:	00f857b3          	srl	a5,a6,a5
40031ef8:	0017f793          	andi	a5,a5,1
40031efc:	02078063          	beqz	a5,40031f1c <clear_event_registrations+0x5c>
	return node->next != NULL;
40031f00:	00052783          	lw	a5,0(a0)
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
40031f04:	00078c63          	beqz	a5,40031f1c <clear_event_registrations+0x5c>
	sys_dnode_t *const prev = node->prev;
40031f08:	00452703          	lw	a4,4(a0)
	prev->next = next;
40031f0c:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
40031f10:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
40031f14:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
40031f18:	00052223          	sw	zero,4(a0)
			  : "r" (key & MSTATUS_IEN)
40031f1c:	00867613          	andi	a2,a2,8
	__asm__ volatile ("csrs mstatus, %0"
40031f20:	30062073          	csrs	mstatus,a2
	__asm__ volatile ("csrrc %0, mstatus, %1"
40031f24:	30047673          	csrrci	a2,mstatus,8
	return k;
40031f28:	fff58593          	addi	a1,a1,-1
40031f2c:	fec50513          	addi	a0,a0,-20
40031f30:	fa9ff06f          	j	40031ed8 <clear_event_registrations+0x18>

40031f34 <k_poll_event_init>:
	event->type = type;
40031f34:	002007b7          	lui	a5,0x200
40031f38:	01561613          	slli	a2,a2,0x15
40031f3c:	00f67633          	and	a2,a2,a5
40031f40:	000047b7          	lui	a5,0x4
40031f44:	f0078793          	addi	a5,a5,-256 # 3f00 <CONFIG_SRAM_SIZE+0x1f00>
40031f48:	00859593          	slli	a1,a1,0x8
40031f4c:	00f5f5b3          	and	a1,a1,a5
40031f50:	00c54783          	lbu	a5,12(a0)
40031f54:	00b66633          	or	a2,a2,a1
	event->poller = NULL;
40031f58:	00052423          	sw	zero,8(a0)
	event->type = type;
40031f5c:	00f66633          	or	a2,a2,a5
40031f60:	00c52623          	sw	a2,12(a0)
	event->obj = obj;
40031f64:	00d52823          	sw	a3,16(a0)
}
40031f68:	00008067          	ret

40031f6c <z_impl_k_poll>:
{
40031f6c:	fd010113          	addi	sp,sp,-48
	struct z_poller *poller = &_current->poller;
40031f70:	4003b7b7          	lui	a5,0x4003b
{
40031f74:	02912223          	sw	s1,36(sp)
	struct z_poller *poller = &_current->poller;
40031f78:	1cc7a483          	lw	s1,460(a5) # 4003b1cc <_kernel+0x8>
{
40031f7c:	03212023          	sw	s2,32(sp)
40031f80:	01312e23          	sw	s3,28(sp)
40031f84:	01412c23          	sw	s4,24(sp)
40031f88:	01512a23          	sw	s5,20(sp)
40031f8c:	02112623          	sw	ra,44(sp)
40031f90:	02812423          	sw	s0,40(sp)
	poller->is_polling = true;
40031f94:	00100793          	li	a5,1
	events_registered = register_events(events, num_events, poller,
40031f98:	00d66ab3          	or	s5,a2,a3
40031f9c:	00d12623          	sw	a3,12(sp)
{
40031fa0:	00060a13          	mv	s4,a2
	poller->is_polling = true;
40031fa4:	06f48a23          	sb	a5,116(s1)
	poller->mode = MODE_POLL;
40031fa8:	06f48aa3          	sb	a5,117(s1)
	events_registered = register_events(events, num_events, poller,
40031fac:	001ab693          	seqz	a3,s5
40031fb0:	07448613          	addi	a2,s1,116
{
40031fb4:	00050913          	mv	s2,a0
	events_registered = register_events(events, num_events, poller,
40031fb8:	bfdff0ef          	jal	ra,40031bb4 <register_events>
40031fbc:	00050993          	mv	s3,a0
40031fc0:	30047473          	csrrci	s0,mstatus,8
	if (!poller->is_polling) {
40031fc4:	0744c783          	lbu	a5,116(s1)
40031fc8:	00c12703          	lw	a4,12(sp)
40031fcc:	04079463          	bnez	a5,40032014 <z_impl_k_poll+0xa8>
		clear_event_registrations(events, events_registered, key);
40031fd0:	00040613          	mv	a2,s0
40031fd4:	00050593          	mv	a1,a0
40031fd8:	00090513          	mv	a0,s2
40031fdc:	ee5ff0ef          	jal	ra,40031ec0 <clear_event_registrations>
	__asm__ volatile ("csrs mstatus, %0"
40031fe0:	00847413          	andi	s0,s0,8
40031fe4:	30042073          	csrs	mstatus,s0
		return 0;
40031fe8:	00000413          	li	s0,0
}
40031fec:	02c12083          	lw	ra,44(sp)
40031ff0:	00040513          	mv	a0,s0
40031ff4:	02812403          	lw	s0,40(sp)
40031ff8:	02412483          	lw	s1,36(sp)
40031ffc:	02012903          	lw	s2,32(sp)
40032000:	01c12983          	lw	s3,28(sp)
40032004:	01812a03          	lw	s4,24(sp)
40032008:	01412a83          	lw	s5,20(sp)
4003200c:	03010113          	addi	sp,sp,48
40032010:	00008067          	ret
	poller->is_polling = false;
40032014:	06048a23          	sb	zero,116(s1)
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
40032018:	000a9a63          	bnez	s5,4003202c <z_impl_k_poll+0xc0>
4003201c:	00847413          	andi	s0,s0,8
40032020:	30042073          	csrs	mstatus,s0
		return -EAGAIN;
40032024:	ff500413          	li	s0,-11
40032028:	fc5ff06f          	j	40031fec <z_impl_k_poll+0x80>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
4003202c:	40044637          	lui	a2,0x40044
40032030:	4003b537          	lui	a0,0x4003b
40032034:	00040593          	mv	a1,s0
40032038:	000a0693          	mv	a3,s4
4003203c:	6d460613          	addi	a2,a2,1748 # 400446d4 <wait_q.0>
40032040:	1e850513          	addi	a0,a0,488 # 4003b1e8 <sched_spinlock>
40032044:	889fe0ef          	jal	ra,400308cc <z_pend_curr>
40032048:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
4003204c:	300474f3          	csrrci	s1,mstatus,8
	clear_event_registrations(events, events_registered, key);
40032050:	00048613          	mv	a2,s1
40032054:	00098593          	mv	a1,s3
40032058:	00090513          	mv	a0,s2
4003205c:	e65ff0ef          	jal	ra,40031ec0 <clear_event_registrations>
	__asm__ volatile ("csrs mstatus, %0"
40032060:	0084f493          	andi	s1,s1,8
40032064:	3004a073          	csrs	mstatus,s1
	return swap_rc;
40032068:	f85ff06f          	j	40031fec <z_impl_k_poll+0x80>

4003206c <z_handle_obj_poll_events>:
{
4003206c:	00050793          	mv	a5,a0
	return list->head == list;
40032070:	00052503          	lw	a0,0(a0)

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
40032074:	02a78063          	beq	a5,a0,40032094 <z_handle_obj_poll_events+0x28>
	sys_dnode_t *const prev = node->prev;
40032078:	00452703          	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
4003207c:	00052783          	lw	a5,0(a0)
	prev->next = next;
40032080:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
40032084:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
40032088:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
4003208c:	00052223          	sw	zero,4(a0)
		(void) signal_poll_event(poll_event, state);
40032090:	d01ff06f          	j	40031d90 <signal_poll_event>
}
40032094:	00008067          	ret

40032098 <z_impl_k_poll_signal_init>:
	list->head = (sys_dnode_t *)list;
40032098:	00a52023          	sw	a0,0(a0)
	list->tail = (sys_dnode_t *)list;
4003209c:	00a52223          	sw	a0,4(a0)
	sig->signaled = 0U;
400320a0:	00052423          	sw	zero,8(a0)
}
400320a4:	00008067          	ret

400320a8 <z_impl_k_poll_signal_reset>:
	sig->signaled = 0U;
400320a8:	00052423          	sw	zero,8(a0)
}
400320ac:	00008067          	ret

400320b0 <z_impl_k_poll_signal_check>:
	*signaled = sig->signaled;
400320b0:	00852783          	lw	a5,8(a0)
400320b4:	00f5a023          	sw	a5,0(a1)
	*result = sig->result;
400320b8:	00c52783          	lw	a5,12(a0)
400320bc:	00f62023          	sw	a5,0(a2)
}
400320c0:	00008067          	ret

400320c4 <z_impl_k_poll_signal_raise>:
{
400320c4:	ff010113          	addi	sp,sp,-16
400320c8:	00112623          	sw	ra,12(sp)
400320cc:	00812423          	sw	s0,8(sp)
400320d0:	00912223          	sw	s1,4(sp)
400320d4:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
400320d8:	300474f3          	csrrci	s1,mstatus,8
	sig->signaled = 1U;
400320dc:	00100713          	li	a4,1
	sig->result = result;
400320e0:	00b52623          	sw	a1,12(a0)
	sig->signaled = 1U;
400320e4:	00e52423          	sw	a4,8(a0)
	return list->head == list;
400320e8:	00052503          	lw	a0,0(a0)
	if (!sys_dlist_is_empty(list)) {
400320ec:	02a79463          	bne	a5,a0,40032114 <z_impl_k_poll_signal_raise+0x50>
	__asm__ volatile ("csrs mstatus, %0"
400320f0:	0084f493          	andi	s1,s1,8
400320f4:	3004a073          	csrs	mstatus,s1
		return 0;
400320f8:	00000413          	li	s0,0
}
400320fc:	00c12083          	lw	ra,12(sp)
40032100:	00040513          	mv	a0,s0
40032104:	00812403          	lw	s0,8(sp)
40032108:	00412483          	lw	s1,4(sp)
4003210c:	01010113          	addi	sp,sp,16
40032110:	00008067          	ret
	sys_dnode_t *const prev = node->prev;
40032114:	00452703          	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
40032118:	00052783          	lw	a5,0(a0)
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
4003211c:	00100593          	li	a1,1
	prev->next = next;
40032120:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
40032124:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
40032128:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
4003212c:	00052223          	sw	zero,4(a0)
40032130:	c61ff0ef          	jal	ra,40031d90 <signal_poll_event>
40032134:	00050413          	mv	s0,a0
	z_reschedule(&lock, key);
40032138:	4003b537          	lui	a0,0x4003b
4003213c:	00048593          	mv	a1,s1
40032140:	1e850513          	addi	a0,a0,488 # 4003b1e8 <sched_spinlock>
40032144:	9b5fe0ef          	jal	ra,40030af8 <z_reschedule>
	return rc;
40032148:	fb5ff06f          	j	400320fc <z_impl_k_poll_signal_raise+0x38>

4003214c <z_heap_aligned_alloc>:
#include <string.h>
#include <zephyr/sys/math_extras.h>
#include <zephyr/sys/util.h>

static void *z_heap_aligned_alloc(struct k_heap *heap, size_t align, size_t size)
{
4003214c:	00060793          	mv	a5,a2
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
40032150:	00460613          	addi	a2,a2,4
40032154:	02f67063          	bgeu	a2,a5,40032174 <z_heap_aligned_alloc+0x28>
	 * Merge a rewind bit with align value (see sys_heap_aligned_alloc()).
	 * This allows for storing the heap pointer right below the aligned
	 * boundary without wasting any memory.
	 */
	if (size_add_overflow(size, sizeof(heap_ref), &size)) {
		return NULL;
40032158:	00000513          	li	a0,0
	mem = ++heap_ref;
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
		 "misaligned memory at %p (align = %zu)", mem, align);

	return mem;
}
4003215c:	00008067          	ret
		return NULL;
40032160:	00000513          	li	a0,0
}
40032164:	00c12083          	lw	ra,12(sp)
40032168:	00812403          	lw	s0,8(sp)
4003216c:	01010113          	addi	sp,sp,16
40032170:	00008067          	ret
{
40032174:	ff010113          	addi	sp,sp,-16
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
40032178:	00000693          	li	a3,0
4003217c:	00000713          	li	a4,0
40032180:	0045e593          	ori	a1,a1,4
{
40032184:	00812423          	sw	s0,8(sp)
40032188:	00112623          	sw	ra,12(sp)
4003218c:	00050413          	mv	s0,a0
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
40032190:	f68fc0ef          	jal	ra,4002e8f8 <k_heap_aligned_alloc>
	if (mem == NULL) {
40032194:	fc0506e3          	beqz	a0,40032160 <z_heap_aligned_alloc+0x14>
	*heap_ref = heap;
40032198:	00852023          	sw	s0,0(a0)
	mem = ++heap_ref;
4003219c:	00450513          	addi	a0,a0,4
	return mem;
400321a0:	fc5ff06f          	j	40032164 <z_heap_aligned_alloc+0x18>

400321a4 <k_free>:

void k_free(void *ptr)
{
	struct k_heap **heap_ref;

	if (ptr != NULL) {
400321a4:	00050863          	beqz	a0,400321b4 <k_free+0x10>
		heap_ref = ptr;
		ptr = --heap_ref;

		SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref, heap_ref);

		k_heap_free(*heap_ref, ptr);
400321a8:	ffc50593          	addi	a1,a0,-4
400321ac:	ffc52503          	lw	a0,-4(a0)
400321b0:	84dfc06f          	j	4002e9fc <k_heap_free>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref, heap_ref);
	}
}
400321b4:	00008067          	ret

400321b8 <k_thread_system_pool_assign>:
	return ret;
}

void k_thread_system_pool_assign(struct k_thread *thread)
{
	thread->resource_pool = _SYSTEM_HEAP;
400321b8:	400457b7          	lui	a5,0x40045
400321bc:	80c78793          	addi	a5,a5,-2036 # 4004480c <_system_heap>
400321c0:	0cf52223          	sw	a5,196(a0)
}
400321c4:	00008067          	ret

400321c8 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
400321c8:	fe010113          	addi	sp,sp,-32
400321cc:	00812c23          	sw	s0,24(sp)
400321d0:	00112e23          	sw	ra,28(sp)
400321d4:	00050413          	mv	s0,a0
400321d8:	00b12623          	sw	a1,12(sp)
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
400321dc:	ab5fc0ef          	jal	ra,4002ec90 <k_is_in_isr>
400321e0:	00c12603          	lw	a2,12(sp)
400321e4:	02051263          	bnez	a0,40032208 <z_thread_aligned_alloc+0x40>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
400321e8:	4003b7b7          	lui	a5,0x4003b
400321ec:	1cc7a783          	lw	a5,460(a5) # 4003b1cc <_kernel+0x8>
400321f0:	0c47a783          	lw	a5,196(a5)
	}

	if (heap != NULL) {
400321f4:	00079e63          	bnez	a5,40032210 <z_thread_aligned_alloc+0x48>
	} else {
		ret = NULL;
	}

	return ret;
}
400321f8:	01c12083          	lw	ra,28(sp)
400321fc:	01812403          	lw	s0,24(sp)
40032200:	02010113          	addi	sp,sp,32
40032204:	00008067          	ret
		heap = _SYSTEM_HEAP;
40032208:	400457b7          	lui	a5,0x40045
4003220c:	80c78793          	addi	a5,a5,-2036 # 4004480c <_system_heap>
		ret = z_heap_aligned_alloc(heap, align, size);
40032210:	00040593          	mv	a1,s0
}
40032214:	01812403          	lw	s0,24(sp)
40032218:	01c12083          	lw	ra,28(sp)
		ret = z_heap_aligned_alloc(heap, align, size);
4003221c:	00078513          	mv	a0,a5
}
40032220:	02010113          	addi	sp,sp,32
		ret = z_heap_aligned_alloc(heap, align, size);
40032224:	f29ff06f          	j	4003214c <z_heap_aligned_alloc>

40032228 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
40032228:	40039537          	lui	a0,0x40039
4003222c:	f6c50513          	addi	a0,a0,-148 # 40038f6c <states_str.1+0x20>
40032230:	a5dcf06f          	j	40001c8c <printk>

40032234 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(void)
{
40032234:	fe010113          	addi	sp,sp,-32
	struct k_work_queue_config cfg = {
40032238:	400397b7          	lui	a5,0x40039
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
4003223c:	4003d5b7          	lui	a1,0x4003d
40032240:	4003a537          	lui	a0,0x4003a
	struct k_work_queue_config cfg = {
40032244:	fb078793          	addi	a5,a5,-80 # 40038fb0 <states_str.1+0x64>
	k_work_queue_start(&k_sys_work_q,
40032248:	00810713          	addi	a4,sp,8
4003224c:	00050513          	mv	a0,a0
40032250:	fff00693          	li	a3,-1
40032254:	40000613          	li	a2,1024
40032258:	7d058593          	addi	a1,a1,2000 # 4003d7d0 <sys_work_q_stack>
{
4003225c:	00112e23          	sw	ra,28(sp)
	struct k_work_queue_config cfg = {
40032260:	00f12423          	sw	a5,8(sp)
40032264:	00010623          	sb	zero,12(sp)
	k_work_queue_start(&k_sys_work_q,
40032268:	cedfd0ef          	jal	ra,4002ff54 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
4003226c:	01c12083          	lw	ra,28(sp)
40032270:	00000513          	li	a0,0
40032274:	02010113          	addi	sp,sp,32
40032278:	00008067          	ret
