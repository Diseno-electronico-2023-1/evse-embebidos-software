
zephyr.elf:     file format elf32-littleriscv


Disassembly of section rom_start:

40000000 <__start>:
#else
	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to _isr_wrapper.
	 */
	la t0, _isr_wrapper
40000000:	00000297          	auipc	t0,0x0
40000004:	01428293          	addi	t0,t0,20 # 40000014 <_isr_wrapper>
#endif

	csrw mtvec, t0
40000008:	30529073          	csrw	mtvec,t0

	/* Jump to __reset */
	tail __reset
4000000c:	0040006f          	j	40000010 <__reset>

Disassembly of section reset:

40000010 <__reset>:
	/*
	 * jump to __initialize
	 * use call opcode in case __initialize is far away.
	 * This will be dependent on linker.ld configuration.
	 */
	call __initialize
40000010:	1ad080ef          	jal	ra,400089bc <__initialize>

Disassembly of section exceptions:

40000014 <_isr_wrapper>:

#ifdef CONFIG_RISCV_SOC_HAS_ISR_STACKING
	SOC_ISR_SW_STACKING
#else
	/* Save caller-saved registers on current thread stack. */
	addi sp, sp, -__z_arch_esf_t_SIZEOF
40000014:	fb010113          	addi	sp,sp,-80
	DO_CALLER_SAVED(sr)		;
40000018:	00512223          	sw	t0,4(sp)
4000001c:	00612423          	sw	t1,8(sp)
40000020:	00712623          	sw	t2,12(sp)
40000024:	01c12823          	sw	t3,16(sp)
40000028:	01d12a23          	sw	t4,20(sp)
4000002c:	01e12c23          	sw	t5,24(sp)
40000030:	01f12e23          	sw	t6,28(sp)
40000034:	02a12023          	sw	a0,32(sp)
40000038:	02b12223          	sw	a1,36(sp)
4000003c:	02c12423          	sw	a2,40(sp)
40000040:	02d12623          	sw	a3,44(sp)
40000044:	02e12823          	sw	a4,48(sp)
40000048:	02f12a23          	sw	a5,52(sp)
4000004c:	03012c23          	sw	a6,56(sp)
40000050:	03112e23          	sw	a7,60(sp)
40000054:	00112023          	sw	ra,0(sp)
#endif /* CONFIG_RISCV_SOC_HAS_ISR_STACKING */

	/* Save s0 in the esf and load it with &_current_cpu. */
	sr s0, __z_arch_esf_t_s0_OFFSET(sp)
40000058:	04812423          	sw	s0,72(sp)
	get_current_cpu s0
4000005c:	00033417          	auipc	s0,0x33
40000060:	80c40413          	addi	s0,s0,-2036 # 40032868 <_kernel>

	/* Save MEPC register */
	csrr t0, mepc
40000064:	341022f3          	csrr	t0,mepc
	sr t0, __z_arch_esf_t_mepc_OFFSET(sp)
40000068:	04512023          	sw	t0,64(sp)

	/* Save MSTATUS register */
	csrr t2, mstatus
4000006c:	300023f3          	csrr	t2,mstatus
	sr t2, __z_arch_esf_t_mstatus_OFFSET(sp)
40000070:	04712223          	sw	t2,68(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
40000074:	154000ef          	jal	ra,400001c8 <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	bnez a0, is_interrupt
40000078:	04051a63          	bnez	a0,400000cc <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
4000007c:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
40000080:	800003b7          	lui	t2,0x80000
40000084:	fff38393          	addi	t2,t2,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and t0, t0, t2
40000088:	0072f2b3          	and	t0,t0,t2

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call from
	 * kernel thread.
	 */
	li t1, SOC_MCAUSE_ECALL_EXP
4000008c:	00b00313          	li	t1,11
	beq t0, t1, is_kernel_syscall
40000090:	00628a63          	beq	t0,t1,400000a4 <is_kernel_syscall>
	 * Stack pointer is pointing to a z_arch_esf_t structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to
	 * no_reschedule to restore stack.
	 */
	mv a0, sp
40000094:	00010513          	mv	a0,sp
	la ra, no_reschedule
40000098:	00000097          	auipc	ra,0x0
4000009c:	0c408093          	addi	ra,ra,196 # 4000015c <no_reschedule>
	tail _Fault
400000a0:	0d90806f          	j	40008978 <_Fault>

400000a4 <is_kernel_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	lr t0, __z_arch_esf_t_mepc_OFFSET(sp)
400000a4:	04012283          	lw	t0,64(sp)
	addi t0, t0, 4
400000a8:	00428293          	addi	t0,t0,4
	sr t0, __z_arch_esf_t_mepc_OFFSET(sp)
400000ac:	04512023          	sw	t0,64(sp)
	li t1, MSTATUS_MPRV
	csrs mstatus, t1
#endif

	/* Determine what to do. Operation code is in t0. */
	lr t0, __z_arch_esf_t_t0_OFFSET(sp)
400000b0:	00412283          	lw	t0,4(sp)

	.if RV_ECALL_RUNTIME_EXCEPT != 0; .err; .endif
	beqz t0, do_fault
400000b4:	00028663          	beqz	t0,400000c0 <do_fault>
	j reschedule
skip_schedule:
#endif

	/* default fault code is K_ERR_KERNEL_OOPS */
	li a0, 3
400000b8:	00300513          	li	a0,3
	j 1f
400000bc:	0080006f          	j	400000c4 <do_fault+0x4>

400000c0 <do_fault>:

do_fault:
	/* Handle RV_ECALL_RUNTIME_EXCEPT. Retrieve reason in a0, esf in A1. */
	lr a0, __z_arch_esf_t_a0_OFFSET(sp)
400000c0:	02012503          	lw	a0,32(sp)
1:	mv a1, sp
400000c4:	00010593          	mv	a1,sp
	tail z_riscv_fatal_error
400000c8:	0a50806f          	j	4000896c <z_riscv_fatal_error>

400000cc <is_interrupt>:
	csrs mstatus, t1
2:
#endif

	/* Increment _current_cpu->nested */
	lw t1, ___cpu_t_nested_OFFSET(s0)
400000cc:	00042303          	lw	t1,0(s0)
	addi t2, t1, 1
400000d0:	00130393          	addi	t2,t1,1
	sw t2, ___cpu_t_nested_OFFSET(s0)
400000d4:	00742023          	sw	t2,0(s0)
	bnez t1, on_irq_stack
400000d8:	00031a63          	bnez	t1,400000ec <on_irq_stack>

	/* Switch to interrupt stack */
	mv t0, sp
400000dc:	00010293          	mv	t0,sp
	lr sp, ___cpu_t_irq_stack_OFFSET(s0)
400000e0:	00442103          	lw	sp,4(s0)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
400000e4:	ff010113          	addi	sp,sp,-16
	sr t0, 0(sp)
400000e8:	00512023          	sw	t0,0(sp)

400000ec <on_irq_stack>:
#ifdef CONFIG_TRACING_ISR
	call sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
400000ec:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
400000f0:	800002b7          	lui	t0,0x80000
400000f4:	fff28293          	addi	t0,t0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and a0, a0, t0
400000f8:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
400000fc:	0bc000ef          	jal	ra,400001b8 <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 2-word wide, we should shift index accordingly)
	 */
	la t0, _sw_isr_table
40000100:	0002b297          	auipc	t0,0x2b
40000104:	7d428293          	addi	t0,t0,2004 # 4002b8d4 <_sw_isr_table>
	slli a0, a0, (RV_REGSHIFT + 1)
40000108:	00351513          	slli	a0,a0,0x3
	add t0, t0, a0
4000010c:	00a282b3          	add	t0,t0,a0

	/* Load argument in a0 register */
	lr a0, 0(t0)
40000110:	0002a503          	lw	a0,0(t0)

	/* Load ISR function address in register t1 */
	lr t1, RV_REGSIZE(t0)
40000114:	0042a303          	lw	t1,4(t0)

	/* Call ISR function */
	jalr ra, t1, 0
40000118:	000300e7          	jalr	t1

4000011c <irq_done>:
	call sys_trace_isr_exit
#endif

irq_done:
	/* Decrement _current_cpu->nested */
	lw t2, ___cpu_t_nested_OFFSET(s0)
4000011c:	00042383          	lw	t2,0(s0)
	addi t2, t2, -1
40000120:	fff38393          	addi	t2,t2,-1
	sw t2, ___cpu_t_nested_OFFSET(s0)
40000124:	00742023          	sw	t2,0(s0)
	bnez t2, no_reschedule
40000128:	02039a63          	bnez	t2,4000015c <no_reschedule>

	/* nested count is back to 0: Return to thread stack */
	lr sp, 0(sp)
4000012c:	00012103          	lw	sp,0(sp)

40000130 <check_reschedule>:
#endif

check_reschedule:

	/* Get pointer to current thread on this CPU */
	lr a1, ___cpu_t_current_OFFSET(s0)
40000130:	00842583          	lw	a1,8(s0)
	/*
	 * Get next thread to schedule with z_get_next_switch_handle().
	 * We pass it a NULL as we didn't save the whole thread context yet.
	 * If no scheduling is necessary then NULL will be returned.
	 */
	addi sp, sp, -16
40000134:	ff010113          	addi	sp,sp,-16
	sr a1, 0(sp)
40000138:	00b12023          	sw	a1,0(sp)
	mv a0, zero
4000013c:	00000513          	li	a0,0
	call z_get_next_switch_handle
40000140:	0d82a0ef          	jal	ra,4002a218 <z_get_next_switch_handle>
	lr a1, 0(sp)
40000144:	00012583          	lw	a1,0(sp)
	addi sp, sp, 16
40000148:	01010113          	addi	sp,sp,16
	beqz a0, no_reschedule
4000014c:	00050863          	beqz	a0,4000015c <no_reschedule>

40000150 <reschedule>:
	/*
	 * Perform context switch:
	 * a0 = new thread
	 * a1 = old thread
	 */
	call z_riscv_switch
40000150:	0c9080ef          	jal	ra,40008a18 <z_riscv_switch>

40000154 <z_riscv_thread_start>:

z_riscv_thread_start:
might_have_rescheduled:
	/* reload s0 with &_current_cpu as it might have changed or be unset */
	get_current_cpu s0
40000154:	00032417          	auipc	s0,0x32
40000158:	71440413          	addi	s0,s0,1812 # 40032868 <_kernel>

4000015c <no_reschedule>:
	sb t1, _thread_offset_to_exception_depth(t0)
fp_trap_exit:
#endif

	/* Restore MEPC and MSTATUS registers */
	lr t0, __z_arch_esf_t_mepc_OFFSET(sp)
4000015c:	04012283          	lw	t0,64(sp)
	lr t2, __z_arch_esf_t_mstatus_OFFSET(sp)
40000160:	04412383          	lw	t2,68(sp)
	csrw mepc, t0
40000164:	34129073          	csrw	mepc,t0
	csrw mstatus, t2
40000168:	30039073          	csrw	mstatus,t2
	sr t0, __z_arch_esf_t_sp_OFFSET(sp)
2:
#endif

	/* Restore s0 (it is no longer ours) */
	lr s0, __z_arch_esf_t_s0_OFFSET(sp)
4000016c:	04812403          	lw	s0,72(sp)

#ifdef CONFIG_RISCV_SOC_HAS_ISR_STACKING
	SOC_ISR_SW_UNSTACKING
#else
	/* Restore caller-saved registers from thread stack */
	DO_CALLER_SAVED(lr)
40000170:	00412283          	lw	t0,4(sp)
40000174:	00812303          	lw	t1,8(sp)
40000178:	00c12383          	lw	t2,12(sp)
4000017c:	01012e03          	lw	t3,16(sp)
40000180:	01412e83          	lw	t4,20(sp)
40000184:	01812f03          	lw	t5,24(sp)
40000188:	01c12f83          	lw	t6,28(sp)
4000018c:	02012503          	lw	a0,32(sp)
40000190:	02412583          	lw	a1,36(sp)
40000194:	02812603          	lw	a2,40(sp)
40000198:	02c12683          	lw	a3,44(sp)
4000019c:	03012703          	lw	a4,48(sp)
400001a0:	03412783          	lw	a5,52(sp)
400001a4:	03812803          	lw	a6,56(sp)
400001a8:	03c12883          	lw	a7,60(sp)
400001ac:	00012083          	lw	ra,0(sp)
#ifdef CONFIG_USERSPACE
	/* retrieve saved stack pointer */
	lr sp, __z_arch_esf_t_sp_OFFSET(sp)
#else
	/* remove esf from the stack */
	addi sp, sp, __z_arch_esf_t_SIZEOF
400001b0:	05010113          	addi	sp,sp,80
#endif

#endif /* CONFIG_RISCV_SOC_HAS_ISR_STACKING */

	mret
400001b4:	30200073          	mret

400001b8 <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
400001b8:	00100313          	li	t1,1
	sll t0, t1, a0
400001bc:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
400001c0:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	ret
400001c4:	00008067          	ret

400001c8 <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
400001c8:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
400001cc:	80000337          	lui	t1,0x80000
	and t0, t0, t1
400001d0:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
400001d4:	00000513          	li	a0,0
	beqz t0, not_interrupt
400001d8:	00028463          	beqz	t0,400001e0 <not_interrupt>
	addi a0, a0, 1
400001dc:	00150513          	addi	a0,a0,1

400001e0 <not_interrupt>:

not_interrupt:
	/* return */
	ret
400001e0:	00008067          	ret

Disassembly of section text:

400001e4 <__ashldi3>:
400001e4:	02060063          	beqz	a2,40000204 <__ashldi3+0x20>
400001e8:	02000793          	li	a5,32
400001ec:	40c787b3          	sub	a5,a5,a2
400001f0:	00f04c63          	bgtz	a5,40000208 <__ashldi3+0x24>
400001f4:	fe060613          	addi	a2,a2,-32
400001f8:	00c515b3          	sll	a1,a0,a2
400001fc:	00000713          	li	a4,0
40000200:	00070513          	mv	a0,a4
40000204:	00008067          	ret
40000208:	00c51733          	sll	a4,a0,a2
4000020c:	00c595b3          	sll	a1,a1,a2
40000210:	00f55533          	srl	a0,a0,a5
40000214:	00a5e5b3          	or	a1,a1,a0
40000218:	fe9ff06f          	j	40000200 <__ashldi3+0x1c>

4000021c <__clzsi2>:
4000021c:	000107b7          	lui	a5,0x10
40000220:	02f57a63          	bgeu	a0,a5,40000254 <__clzsi2+0x38>
40000224:	10053793          	sltiu	a5,a0,256
40000228:	0017c793          	xori	a5,a5,1
4000022c:	00379793          	slli	a5,a5,0x3
40000230:	4002c737          	lui	a4,0x4002c
40000234:	02000693          	li	a3,32
40000238:	40f686b3          	sub	a3,a3,a5
4000023c:	00f55533          	srl	a0,a0,a5
40000240:	c2c70793          	addi	a5,a4,-980 # 4002bc2c <__clz_tab>
40000244:	00a787b3          	add	a5,a5,a0
40000248:	0007c503          	lbu	a0,0(a5) # 10000 <__kernel_ram_size+0x3d6c>
4000024c:	40a68533          	sub	a0,a3,a0
40000250:	00008067          	ret
40000254:	01000737          	lui	a4,0x1000
40000258:	01000793          	li	a5,16
4000025c:	fce56ae3          	bltu	a0,a4,40000230 <__clzsi2+0x14>
40000260:	01800793          	li	a5,24
40000264:	fcdff06f          	j	40000230 <__clzsi2+0x14>

40000268 <__ctzsi2>:
40000268:	40a007b3          	neg	a5,a0
4000026c:	00a7f533          	and	a0,a5,a0
40000270:	000107b7          	lui	a5,0x10
40000274:	02f57863          	bgeu	a0,a5,400002a4 <__ctzsi2+0x3c>
40000278:	10053793          	sltiu	a5,a0,256
4000027c:	0017c793          	xori	a5,a5,1
40000280:	00379793          	slli	a5,a5,0x3
40000284:	4002c737          	lui	a4,0x4002c
40000288:	00f55533          	srl	a0,a0,a5
4000028c:	c2c70713          	addi	a4,a4,-980 # 4002bc2c <__clz_tab>
40000290:	00a70733          	add	a4,a4,a0
40000294:	00074503          	lbu	a0,0(a4)
40000298:	fff78793          	addi	a5,a5,-1 # ffff <__kernel_ram_size+0x3d6b>
4000029c:	00f50533          	add	a0,a0,a5
400002a0:	00008067          	ret
400002a4:	01000737          	lui	a4,0x1000
400002a8:	01000793          	li	a5,16
400002ac:	fce56ce3          	bltu	a0,a4,40000284 <__ctzsi2+0x1c>
400002b0:	01800793          	li	a5,24
400002b4:	fd1ff06f          	j	40000284 <__ctzsi2+0x1c>

400002b8 <__udivdi3>:
400002b8:	00050893          	mv	a7,a0
400002bc:	00058313          	mv	t1,a1
400002c0:	00060713          	mv	a4,a2
400002c4:	00050813          	mv	a6,a0
400002c8:	00058793          	mv	a5,a1
400002cc:	28069263          	bnez	a3,40000550 <__udivdi3+0x298>
400002d0:	4002c5b7          	lui	a1,0x4002c
400002d4:	c2c58593          	addi	a1,a1,-980 # 4002bc2c <__clz_tab>
400002d8:	0ec37663          	bgeu	t1,a2,400003c4 <__udivdi3+0x10c>
400002dc:	000106b7          	lui	a3,0x10
400002e0:	0cd67863          	bgeu	a2,a3,400003b0 <__udivdi3+0xf8>
400002e4:	10063693          	sltiu	a3,a2,256
400002e8:	0016c693          	xori	a3,a3,1
400002ec:	00369693          	slli	a3,a3,0x3
400002f0:	00d65533          	srl	a0,a2,a3
400002f4:	00a585b3          	add	a1,a1,a0
400002f8:	0005c583          	lbu	a1,0(a1)
400002fc:	02000513          	li	a0,32
40000300:	00d586b3          	add	a3,a1,a3
40000304:	40d505b3          	sub	a1,a0,a3
40000308:	00d50c63          	beq	a0,a3,40000320 <__udivdi3+0x68>
4000030c:	00b317b3          	sll	a5,t1,a1
40000310:	00d8d6b3          	srl	a3,a7,a3
40000314:	00b61733          	sll	a4,a2,a1
40000318:	00f6e7b3          	or	a5,a3,a5
4000031c:	00b89833          	sll	a6,a7,a1
40000320:	01075593          	srli	a1,a4,0x10
40000324:	02b7d333          	divu	t1,a5,a1
40000328:	01071613          	slli	a2,a4,0x10
4000032c:	01065613          	srli	a2,a2,0x10
40000330:	02b7f7b3          	remu	a5,a5,a1
40000334:	00030513          	mv	a0,t1
40000338:	026608b3          	mul	a7,a2,t1
4000033c:	01079693          	slli	a3,a5,0x10
40000340:	01085793          	srli	a5,a6,0x10
40000344:	00d7e7b3          	or	a5,a5,a3
40000348:	0117fe63          	bgeu	a5,a7,40000364 <__udivdi3+0xac>
4000034c:	00f707b3          	add	a5,a4,a5
40000350:	fff30513          	addi	a0,t1,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
40000354:	00e7e863          	bltu	a5,a4,40000364 <__udivdi3+0xac>
40000358:	0117f663          	bgeu	a5,a7,40000364 <__udivdi3+0xac>
4000035c:	ffe30513          	addi	a0,t1,-2
40000360:	00e787b3          	add	a5,a5,a4
40000364:	411787b3          	sub	a5,a5,a7
40000368:	02b7d8b3          	divu	a7,a5,a1
4000036c:	01081813          	slli	a6,a6,0x10
40000370:	01085813          	srli	a6,a6,0x10
40000374:	02b7f7b3          	remu	a5,a5,a1
40000378:	031606b3          	mul	a3,a2,a7
4000037c:	01079793          	slli	a5,a5,0x10
40000380:	00f86833          	or	a6,a6,a5
40000384:	00088793          	mv	a5,a7
40000388:	00d87c63          	bgeu	a6,a3,400003a0 <__udivdi3+0xe8>
4000038c:	01070833          	add	a6,a4,a6
40000390:	fff88793          	addi	a5,a7,-1
40000394:	00e86663          	bltu	a6,a4,400003a0 <__udivdi3+0xe8>
40000398:	00d87463          	bgeu	a6,a3,400003a0 <__udivdi3+0xe8>
4000039c:	ffe88793          	addi	a5,a7,-2
400003a0:	01051513          	slli	a0,a0,0x10
400003a4:	00f56533          	or	a0,a0,a5
400003a8:	00000593          	li	a1,0
400003ac:	00008067          	ret
400003b0:	01000537          	lui	a0,0x1000
400003b4:	01000693          	li	a3,16
400003b8:	f2a66ce3          	bltu	a2,a0,400002f0 <__udivdi3+0x38>
400003bc:	01800693          	li	a3,24
400003c0:	f31ff06f          	j	400002f0 <__udivdi3+0x38>
400003c4:	00000693          	li	a3,0
400003c8:	00060c63          	beqz	a2,400003e0 <__udivdi3+0x128>
400003cc:	000107b7          	lui	a5,0x10
400003d0:	0cf67063          	bgeu	a2,a5,40000490 <__udivdi3+0x1d8>
400003d4:	10063693          	sltiu	a3,a2,256
400003d8:	0016c693          	xori	a3,a3,1
400003dc:	00369693          	slli	a3,a3,0x3
400003e0:	00d657b3          	srl	a5,a2,a3
400003e4:	00f585b3          	add	a1,a1,a5
400003e8:	0005c783          	lbu	a5,0(a1)
400003ec:	00d787b3          	add	a5,a5,a3
400003f0:	02000693          	li	a3,32
400003f4:	40f685b3          	sub	a1,a3,a5
400003f8:	0af69663          	bne	a3,a5,400004a4 <__udivdi3+0x1ec>
400003fc:	40c307b3          	sub	a5,t1,a2
40000400:	00100593          	li	a1,1
40000404:	01075893          	srli	a7,a4,0x10
40000408:	0317de33          	divu	t3,a5,a7
4000040c:	01071613          	slli	a2,a4,0x10
40000410:	01065613          	srli	a2,a2,0x10
40000414:	01085693          	srli	a3,a6,0x10
40000418:	0317f7b3          	remu	a5,a5,a7
4000041c:	000e0513          	mv	a0,t3
40000420:	03c60333          	mul	t1,a2,t3
40000424:	01079793          	slli	a5,a5,0x10
40000428:	00f6e7b3          	or	a5,a3,a5
4000042c:	0067fe63          	bgeu	a5,t1,40000448 <__udivdi3+0x190>
40000430:	00f707b3          	add	a5,a4,a5
40000434:	fffe0513          	addi	a0,t3,-1
40000438:	00e7e863          	bltu	a5,a4,40000448 <__udivdi3+0x190>
4000043c:	0067f663          	bgeu	a5,t1,40000448 <__udivdi3+0x190>
40000440:	ffee0513          	addi	a0,t3,-2
40000444:	00e787b3          	add	a5,a5,a4
40000448:	406787b3          	sub	a5,a5,t1
4000044c:	0317d333          	divu	t1,a5,a7
40000450:	01081813          	slli	a6,a6,0x10
40000454:	01085813          	srli	a6,a6,0x10
40000458:	0317f7b3          	remu	a5,a5,a7
4000045c:	026606b3          	mul	a3,a2,t1
40000460:	01079793          	slli	a5,a5,0x10
40000464:	00f86833          	or	a6,a6,a5
40000468:	00030793          	mv	a5,t1
4000046c:	00d87c63          	bgeu	a6,a3,40000484 <__udivdi3+0x1cc>
40000470:	01070833          	add	a6,a4,a6
40000474:	fff30793          	addi	a5,t1,-1
40000478:	00e86663          	bltu	a6,a4,40000484 <__udivdi3+0x1cc>
4000047c:	00d87463          	bgeu	a6,a3,40000484 <__udivdi3+0x1cc>
40000480:	ffe30793          	addi	a5,t1,-2
40000484:	01051513          	slli	a0,a0,0x10
40000488:	00f56533          	or	a0,a0,a5
4000048c:	00008067          	ret
40000490:	010007b7          	lui	a5,0x1000
40000494:	01000693          	li	a3,16
40000498:	f4f664e3          	bltu	a2,a5,400003e0 <__udivdi3+0x128>
4000049c:	01800693          	li	a3,24
400004a0:	f41ff06f          	j	400003e0 <__udivdi3+0x128>
400004a4:	00b61733          	sll	a4,a2,a1
400004a8:	00f356b3          	srl	a3,t1,a5
400004ac:	01075513          	srli	a0,a4,0x10
400004b0:	00b31333          	sll	t1,t1,a1
400004b4:	00f8d7b3          	srl	a5,a7,a5
400004b8:	0067e7b3          	or	a5,a5,t1
400004bc:	02a6d333          	divu	t1,a3,a0
400004c0:	01071613          	slli	a2,a4,0x10
400004c4:	01065613          	srli	a2,a2,0x10
400004c8:	00b89833          	sll	a6,a7,a1
400004cc:	02a6f6b3          	remu	a3,a3,a0
400004d0:	026608b3          	mul	a7,a2,t1
400004d4:	01069593          	slli	a1,a3,0x10
400004d8:	0107d693          	srli	a3,a5,0x10
400004dc:	00b6e6b3          	or	a3,a3,a1
400004e0:	00030593          	mv	a1,t1
400004e4:	0116fe63          	bgeu	a3,a7,40000500 <__udivdi3+0x248>
400004e8:	00d706b3          	add	a3,a4,a3
400004ec:	fff30593          	addi	a1,t1,-1
400004f0:	00e6e863          	bltu	a3,a4,40000500 <__udivdi3+0x248>
400004f4:	0116f663          	bgeu	a3,a7,40000500 <__udivdi3+0x248>
400004f8:	ffe30593          	addi	a1,t1,-2
400004fc:	00e686b3          	add	a3,a3,a4
40000500:	411686b3          	sub	a3,a3,a7
40000504:	02a6d8b3          	divu	a7,a3,a0
40000508:	01079793          	slli	a5,a5,0x10
4000050c:	0107d793          	srli	a5,a5,0x10
40000510:	02a6f6b3          	remu	a3,a3,a0
40000514:	03160633          	mul	a2,a2,a7
40000518:	01069693          	slli	a3,a3,0x10
4000051c:	00d7e7b3          	or	a5,a5,a3
40000520:	00088693          	mv	a3,a7
40000524:	00c7fe63          	bgeu	a5,a2,40000540 <__udivdi3+0x288>
40000528:	00f707b3          	add	a5,a4,a5
4000052c:	fff88693          	addi	a3,a7,-1
40000530:	00e7e863          	bltu	a5,a4,40000540 <__udivdi3+0x288>
40000534:	00c7f663          	bgeu	a5,a2,40000540 <__udivdi3+0x288>
40000538:	ffe88693          	addi	a3,a7,-2
4000053c:	00e787b3          	add	a5,a5,a4
40000540:	01059593          	slli	a1,a1,0x10
40000544:	40c787b3          	sub	a5,a5,a2
40000548:	00d5e5b3          	or	a1,a1,a3
4000054c:	eb9ff06f          	j	40000404 <__udivdi3+0x14c>
40000550:	18d5e663          	bltu	a1,a3,400006dc <__udivdi3+0x424>
40000554:	000107b7          	lui	a5,0x10
40000558:	04f6f463          	bgeu	a3,a5,400005a0 <__udivdi3+0x2e8>
4000055c:	1006b713          	sltiu	a4,a3,256
40000560:	00174713          	xori	a4,a4,1
40000564:	00371713          	slli	a4,a4,0x3
40000568:	4002c7b7          	lui	a5,0x4002c
4000056c:	00e6d5b3          	srl	a1,a3,a4
40000570:	c2c78793          	addi	a5,a5,-980 # 4002bc2c <__clz_tab>
40000574:	00b787b3          	add	a5,a5,a1
40000578:	0007c783          	lbu	a5,0(a5)
4000057c:	00e787b3          	add	a5,a5,a4
40000580:	02000713          	li	a4,32
40000584:	40f705b3          	sub	a1,a4,a5
40000588:	02f71663          	bne	a4,a5,400005b4 <__udivdi3+0x2fc>
4000058c:	00100513          	li	a0,1
40000590:	e066eee3          	bltu	a3,t1,400003ac <__udivdi3+0xf4>
40000594:	00c8b533          	sltu	a0,a7,a2
40000598:	00154513          	xori	a0,a0,1
4000059c:	00008067          	ret
400005a0:	010007b7          	lui	a5,0x1000
400005a4:	01000713          	li	a4,16
400005a8:	fcf6e0e3          	bltu	a3,a5,40000568 <__udivdi3+0x2b0>
400005ac:	01800713          	li	a4,24
400005b0:	fb9ff06f          	j	40000568 <__udivdi3+0x2b0>
400005b4:	00f65733          	srl	a4,a2,a5
400005b8:	00b696b3          	sll	a3,a3,a1
400005bc:	00d766b3          	or	a3,a4,a3
400005c0:	00f35733          	srl	a4,t1,a5
400005c4:	00b31333          	sll	t1,t1,a1
400005c8:	00f8d7b3          	srl	a5,a7,a5
400005cc:	0067e7b3          	or	a5,a5,t1
400005d0:	0106d313          	srli	t1,a3,0x10
400005d4:	02675eb3          	divu	t4,a4,t1
400005d8:	01069813          	slli	a6,a3,0x10
400005dc:	01085813          	srli	a6,a6,0x10
400005e0:	00b61633          	sll	a2,a2,a1
400005e4:	02677733          	remu	a4,a4,t1
400005e8:	03d80e33          	mul	t3,a6,t4
400005ec:	01071513          	slli	a0,a4,0x10
400005f0:	0107d713          	srli	a4,a5,0x10
400005f4:	00a76733          	or	a4,a4,a0
400005f8:	000e8513          	mv	a0,t4
400005fc:	01c77e63          	bgeu	a4,t3,40000618 <__udivdi3+0x360>
40000600:	00e68733          	add	a4,a3,a4
40000604:	fffe8513          	addi	a0,t4,-1
40000608:	00d76863          	bltu	a4,a3,40000618 <__udivdi3+0x360>
4000060c:	01c77663          	bgeu	a4,t3,40000618 <__udivdi3+0x360>
40000610:	ffee8513          	addi	a0,t4,-2
40000614:	00d70733          	add	a4,a4,a3
40000618:	41c70733          	sub	a4,a4,t3
4000061c:	02675e33          	divu	t3,a4,t1
40000620:	01079793          	slli	a5,a5,0x10
40000624:	0107d793          	srli	a5,a5,0x10
40000628:	02677733          	remu	a4,a4,t1
4000062c:	03c80833          	mul	a6,a6,t3
40000630:	01071713          	slli	a4,a4,0x10
40000634:	00e7e7b3          	or	a5,a5,a4
40000638:	000e0713          	mv	a4,t3
4000063c:	0107fe63          	bgeu	a5,a6,40000658 <__udivdi3+0x3a0>
40000640:	00f687b3          	add	a5,a3,a5
40000644:	fffe0713          	addi	a4,t3,-1
40000648:	00d7e863          	bltu	a5,a3,40000658 <__udivdi3+0x3a0>
4000064c:	0107f663          	bgeu	a5,a6,40000658 <__udivdi3+0x3a0>
40000650:	ffee0713          	addi	a4,t3,-2
40000654:	00d787b3          	add	a5,a5,a3
40000658:	01051513          	slli	a0,a0,0x10
4000065c:	00010e37          	lui	t3,0x10
40000660:	00e56533          	or	a0,a0,a4
40000664:	fffe0693          	addi	a3,t3,-1 # ffff <__kernel_ram_size+0x3d6b>
40000668:	00d57733          	and	a4,a0,a3
4000066c:	410787b3          	sub	a5,a5,a6
40000670:	00d676b3          	and	a3,a2,a3
40000674:	01055813          	srli	a6,a0,0x10
40000678:	01065613          	srli	a2,a2,0x10
4000067c:	02d70333          	mul	t1,a4,a3
40000680:	02d806b3          	mul	a3,a6,a3
40000684:	02c70733          	mul	a4,a4,a2
40000688:	02c80833          	mul	a6,a6,a2
4000068c:	00d70633          	add	a2,a4,a3
40000690:	01035713          	srli	a4,t1,0x10
40000694:	00c70733          	add	a4,a4,a2
40000698:	00d77463          	bgeu	a4,a3,400006a0 <__udivdi3+0x3e8>
4000069c:	01c80833          	add	a6,a6,t3
400006a0:	01075693          	srli	a3,a4,0x10
400006a4:	010686b3          	add	a3,a3,a6
400006a8:	02d7e663          	bltu	a5,a3,400006d4 <__udivdi3+0x41c>
400006ac:	ced79ee3          	bne	a5,a3,400003a8 <__udivdi3+0xf0>
400006b0:	000107b7          	lui	a5,0x10
400006b4:	fff78793          	addi	a5,a5,-1 # ffff <__kernel_ram_size+0x3d6b>
400006b8:	00f77733          	and	a4,a4,a5
400006bc:	01071713          	slli	a4,a4,0x10
400006c0:	00f37333          	and	t1,t1,a5
400006c4:	00b898b3          	sll	a7,a7,a1
400006c8:	00670733          	add	a4,a4,t1
400006cc:	00000593          	li	a1,0
400006d0:	cce8fee3          	bgeu	a7,a4,400003ac <__udivdi3+0xf4>
400006d4:	fff50513          	addi	a0,a0,-1 # ffffff <__rom_region_size+0xfcf623>
400006d8:	cd1ff06f          	j	400003a8 <__udivdi3+0xf0>
400006dc:	00000593          	li	a1,0
400006e0:	00000513          	li	a0,0
400006e4:	00008067          	ret

400006e8 <__umoddi3>:
400006e8:	00060813          	mv	a6,a2
400006ec:	00050793          	mv	a5,a0
400006f0:	00058713          	mv	a4,a1
400006f4:	20069663          	bnez	a3,40000900 <__umoddi3+0x218>
400006f8:	4002c8b7          	lui	a7,0x4002c
400006fc:	c2c88893          	addi	a7,a7,-980 # 4002bc2c <__clz_tab>
40000700:	0cc5fc63          	bgeu	a1,a2,400007d8 <__umoddi3+0xf0>
40000704:	000106b7          	lui	a3,0x10
40000708:	0ad67e63          	bgeu	a2,a3,400007c4 <__umoddi3+0xdc>
4000070c:	10063693          	sltiu	a3,a2,256
40000710:	0016c693          	xori	a3,a3,1
40000714:	00369693          	slli	a3,a3,0x3
40000718:	00d65333          	srl	t1,a2,a3
4000071c:	006888b3          	add	a7,a7,t1
40000720:	0008c883          	lbu	a7,0(a7)
40000724:	02000313          	li	t1,32
40000728:	00d886b3          	add	a3,a7,a3
4000072c:	40d308b3          	sub	a7,t1,a3
40000730:	00d30c63          	beq	t1,a3,40000748 <__umoddi3+0x60>
40000734:	01159733          	sll	a4,a1,a7
40000738:	00d556b3          	srl	a3,a0,a3
4000073c:	01161833          	sll	a6,a2,a7
40000740:	00e6e733          	or	a4,a3,a4
40000744:	011517b3          	sll	a5,a0,a7
40000748:	01085613          	srli	a2,a6,0x10
4000074c:	02c756b3          	divu	a3,a4,a2
40000750:	01081513          	slli	a0,a6,0x10
40000754:	01055513          	srli	a0,a0,0x10
40000758:	02c77733          	remu	a4,a4,a2
4000075c:	02a686b3          	mul	a3,a3,a0
40000760:	01071593          	slli	a1,a4,0x10
40000764:	0107d713          	srli	a4,a5,0x10
40000768:	00b76733          	or	a4,a4,a1
4000076c:	00d77a63          	bgeu	a4,a3,40000780 <__umoddi3+0x98>
40000770:	00e80733          	add	a4,a6,a4
40000774:	01076663          	bltu	a4,a6,40000780 <__umoddi3+0x98>
40000778:	00d77463          	bgeu	a4,a3,40000780 <__umoddi3+0x98>
4000077c:	01070733          	add	a4,a4,a6
40000780:	40d70733          	sub	a4,a4,a3
40000784:	02c756b3          	divu	a3,a4,a2
40000788:	02c77733          	remu	a4,a4,a2
4000078c:	02a686b3          	mul	a3,a3,a0
40000790:	01079793          	slli	a5,a5,0x10
40000794:	01071713          	slli	a4,a4,0x10
40000798:	0107d793          	srli	a5,a5,0x10
4000079c:	00e7e7b3          	or	a5,a5,a4
400007a0:	00d7fa63          	bgeu	a5,a3,400007b4 <__umoddi3+0xcc>
400007a4:	00f807b3          	add	a5,a6,a5
400007a8:	0107e663          	bltu	a5,a6,400007b4 <__umoddi3+0xcc>
400007ac:	00d7f463          	bgeu	a5,a3,400007b4 <__umoddi3+0xcc>
400007b0:	010787b3          	add	a5,a5,a6
400007b4:	40d787b3          	sub	a5,a5,a3
400007b8:	0117d533          	srl	a0,a5,a7
400007bc:	00000593          	li	a1,0
400007c0:	00008067          	ret
400007c4:	01000337          	lui	t1,0x1000
400007c8:	01000693          	li	a3,16
400007cc:	f46666e3          	bltu	a2,t1,40000718 <__umoddi3+0x30>
400007d0:	01800693          	li	a3,24
400007d4:	f45ff06f          	j	40000718 <__umoddi3+0x30>
400007d8:	00000693          	li	a3,0
400007dc:	00060c63          	beqz	a2,400007f4 <__umoddi3+0x10c>
400007e0:	00010737          	lui	a4,0x10
400007e4:	06e67e63          	bgeu	a2,a4,40000860 <__umoddi3+0x178>
400007e8:	10063693          	sltiu	a3,a2,256
400007ec:	0016c693          	xori	a3,a3,1
400007f0:	00369693          	slli	a3,a3,0x3
400007f4:	00d65733          	srl	a4,a2,a3
400007f8:	00e888b3          	add	a7,a7,a4
400007fc:	0008c703          	lbu	a4,0(a7)
40000800:	00d70733          	add	a4,a4,a3
40000804:	02000693          	li	a3,32
40000808:	40e688b3          	sub	a7,a3,a4
4000080c:	06e69463          	bne	a3,a4,40000874 <__umoddi3+0x18c>
40000810:	40c58733          	sub	a4,a1,a2
40000814:	01085593          	srli	a1,a6,0x10
40000818:	02b75633          	divu	a2,a4,a1
4000081c:	01081513          	slli	a0,a6,0x10
40000820:	01055513          	srli	a0,a0,0x10
40000824:	0107d693          	srli	a3,a5,0x10
40000828:	02b77733          	remu	a4,a4,a1
4000082c:	02a60633          	mul	a2,a2,a0
40000830:	01071713          	slli	a4,a4,0x10
40000834:	00e6e733          	or	a4,a3,a4
40000838:	00c77a63          	bgeu	a4,a2,4000084c <__umoddi3+0x164>
4000083c:	00e80733          	add	a4,a6,a4
40000840:	01076663          	bltu	a4,a6,4000084c <__umoddi3+0x164>
40000844:	00c77463          	bgeu	a4,a2,4000084c <__umoddi3+0x164>
40000848:	01070733          	add	a4,a4,a6
4000084c:	40c70733          	sub	a4,a4,a2
40000850:	02b756b3          	divu	a3,a4,a1
40000854:	02b77733          	remu	a4,a4,a1
40000858:	02a686b3          	mul	a3,a3,a0
4000085c:	f35ff06f          	j	40000790 <__umoddi3+0xa8>
40000860:	01000737          	lui	a4,0x1000
40000864:	01000693          	li	a3,16
40000868:	f8e666e3          	bltu	a2,a4,400007f4 <__umoddi3+0x10c>
4000086c:	01800693          	li	a3,24
40000870:	f85ff06f          	j	400007f4 <__umoddi3+0x10c>
40000874:	01161833          	sll	a6,a2,a7
40000878:	00e5d6b3          	srl	a3,a1,a4
4000087c:	011517b3          	sll	a5,a0,a7
40000880:	011595b3          	sll	a1,a1,a7
40000884:	00e55733          	srl	a4,a0,a4
40000888:	01085513          	srli	a0,a6,0x10
4000088c:	00b76733          	or	a4,a4,a1
40000890:	02a6d5b3          	divu	a1,a3,a0
40000894:	01081313          	slli	t1,a6,0x10
40000898:	01035313          	srli	t1,t1,0x10
4000089c:	02a6f6b3          	remu	a3,a3,a0
400008a0:	026585b3          	mul	a1,a1,t1
400008a4:	01069613          	slli	a2,a3,0x10
400008a8:	01075693          	srli	a3,a4,0x10
400008ac:	00c6e6b3          	or	a3,a3,a2
400008b0:	00b6fa63          	bgeu	a3,a1,400008c4 <__umoddi3+0x1dc>
400008b4:	00d806b3          	add	a3,a6,a3
400008b8:	0106e663          	bltu	a3,a6,400008c4 <__umoddi3+0x1dc>
400008bc:	00b6f463          	bgeu	a3,a1,400008c4 <__umoddi3+0x1dc>
400008c0:	010686b3          	add	a3,a3,a6
400008c4:	40b686b3          	sub	a3,a3,a1
400008c8:	02a6d633          	divu	a2,a3,a0
400008cc:	01071713          	slli	a4,a4,0x10
400008d0:	01075713          	srli	a4,a4,0x10
400008d4:	02a6f6b3          	remu	a3,a3,a0
400008d8:	02660633          	mul	a2,a2,t1
400008dc:	01069693          	slli	a3,a3,0x10
400008e0:	00d76733          	or	a4,a4,a3
400008e4:	00c77a63          	bgeu	a4,a2,400008f8 <__umoddi3+0x210>
400008e8:	00e80733          	add	a4,a6,a4
400008ec:	01076663          	bltu	a4,a6,400008f8 <__umoddi3+0x210>
400008f0:	00c77463          	bgeu	a4,a2,400008f8 <__umoddi3+0x210>
400008f4:	01070733          	add	a4,a4,a6
400008f8:	40c70733          	sub	a4,a4,a2
400008fc:	f19ff06f          	j	40000814 <__umoddi3+0x12c>
40000900:	1cd5e463          	bltu	a1,a3,40000ac8 <__umoddi3+0x3e0>
40000904:	00010837          	lui	a6,0x10
40000908:	0506fe63          	bgeu	a3,a6,40000964 <__umoddi3+0x27c>
4000090c:	1006b813          	sltiu	a6,a3,256
40000910:	00184813          	xori	a6,a6,1
40000914:	00381813          	slli	a6,a6,0x3
40000918:	4002c8b7          	lui	a7,0x4002c
4000091c:	0106d333          	srl	t1,a3,a6
40000920:	c2c88893          	addi	a7,a7,-980 # 4002bc2c <__clz_tab>
40000924:	006888b3          	add	a7,a7,t1
40000928:	0008c883          	lbu	a7,0(a7)
4000092c:	02000313          	li	t1,32
40000930:	010888b3          	add	a7,a7,a6
40000934:	41130833          	sub	a6,t1,a7
40000938:	05131063          	bne	t1,a7,40000978 <__umoddi3+0x290>
4000093c:	00b6e463          	bltu	a3,a1,40000944 <__umoddi3+0x25c>
40000940:	00c56c63          	bltu	a0,a2,40000958 <__umoddi3+0x270>
40000944:	40c50633          	sub	a2,a0,a2
40000948:	40d586b3          	sub	a3,a1,a3
4000094c:	00c53733          	sltu	a4,a0,a2
40000950:	00060793          	mv	a5,a2
40000954:	40e68733          	sub	a4,a3,a4
40000958:	00078513          	mv	a0,a5
4000095c:	00070593          	mv	a1,a4
40000960:	00008067          	ret
40000964:	010008b7          	lui	a7,0x1000
40000968:	01000813          	li	a6,16
4000096c:	fb16e6e3          	bltu	a3,a7,40000918 <__umoddi3+0x230>
40000970:	01800813          	li	a6,24
40000974:	fa5ff06f          	j	40000918 <__umoddi3+0x230>
40000978:	011657b3          	srl	a5,a2,a7
4000097c:	010696b3          	sll	a3,a3,a6
40000980:	00d7e6b3          	or	a3,a5,a3
40000984:	0115d733          	srl	a4,a1,a7
40000988:	0106de13          	srli	t3,a3,0x10
4000098c:	03c75f33          	divu	t5,a4,t3
40000990:	01069313          	slli	t1,a3,0x10
40000994:	01035313          	srli	t1,t1,0x10
40000998:	010597b3          	sll	a5,a1,a6
4000099c:	011555b3          	srl	a1,a0,a7
400009a0:	00f5e5b3          	or	a1,a1,a5
400009a4:	0105d793          	srli	a5,a1,0x10
400009a8:	01061633          	sll	a2,a2,a6
400009ac:	01051533          	sll	a0,a0,a6
400009b0:	03c77733          	remu	a4,a4,t3
400009b4:	03e30eb3          	mul	t4,t1,t5
400009b8:	01071713          	slli	a4,a4,0x10
400009bc:	00e7e7b3          	or	a5,a5,a4
400009c0:	000f0713          	mv	a4,t5
400009c4:	01d7fe63          	bgeu	a5,t4,400009e0 <__umoddi3+0x2f8>
400009c8:	00f687b3          	add	a5,a3,a5
400009cc:	ffff0713          	addi	a4,t5,-1
400009d0:	00d7e863          	bltu	a5,a3,400009e0 <__umoddi3+0x2f8>
400009d4:	01d7f663          	bgeu	a5,t4,400009e0 <__umoddi3+0x2f8>
400009d8:	ffef0713          	addi	a4,t5,-2
400009dc:	00d787b3          	add	a5,a5,a3
400009e0:	41d787b3          	sub	a5,a5,t4
400009e4:	03c7deb3          	divu	t4,a5,t3
400009e8:	01059593          	slli	a1,a1,0x10
400009ec:	0105d593          	srli	a1,a1,0x10
400009f0:	03c7f7b3          	remu	a5,a5,t3
400009f4:	000e8e13          	mv	t3,t4
400009f8:	03d30333          	mul	t1,t1,t4
400009fc:	01079793          	slli	a5,a5,0x10
40000a00:	00f5e5b3          	or	a1,a1,a5
40000a04:	0065fe63          	bgeu	a1,t1,40000a20 <__umoddi3+0x338>
40000a08:	00b685b3          	add	a1,a3,a1
40000a0c:	fffe8e13          	addi	t3,t4,-1
40000a10:	00d5e863          	bltu	a1,a3,40000a20 <__umoddi3+0x338>
40000a14:	0065f663          	bgeu	a1,t1,40000a20 <__umoddi3+0x338>
40000a18:	ffee8e13          	addi	t3,t4,-2
40000a1c:	00d585b3          	add	a1,a1,a3
40000a20:	01071793          	slli	a5,a4,0x10
40000a24:	00010f37          	lui	t5,0x10
40000a28:	01c7e7b3          	or	a5,a5,t3
40000a2c:	406585b3          	sub	a1,a1,t1
40000a30:	ffff0313          	addi	t1,t5,-1 # ffff <__kernel_ram_size+0x3d6b>
40000a34:	0067f733          	and	a4,a5,t1
40000a38:	01065e13          	srli	t3,a2,0x10
40000a3c:	0107d793          	srli	a5,a5,0x10
40000a40:	00667333          	and	t1,a2,t1
40000a44:	02670eb3          	mul	t4,a4,t1
40000a48:	02678333          	mul	t1,a5,t1
40000a4c:	03c70733          	mul	a4,a4,t3
40000a50:	03c787b3          	mul	a5,a5,t3
40000a54:	00670e33          	add	t3,a4,t1
40000a58:	010ed713          	srli	a4,t4,0x10
40000a5c:	01c70733          	add	a4,a4,t3
40000a60:	00677463          	bgeu	a4,t1,40000a68 <__umoddi3+0x380>
40000a64:	01e787b3          	add	a5,a5,t5
40000a68:	01075313          	srli	t1,a4,0x10
40000a6c:	00f307b3          	add	a5,t1,a5
40000a70:	00010337          	lui	t1,0x10
40000a74:	fff30313          	addi	t1,t1,-1 # ffff <__kernel_ram_size+0x3d6b>
40000a78:	00677733          	and	a4,a4,t1
40000a7c:	01071713          	slli	a4,a4,0x10
40000a80:	006efeb3          	and	t4,t4,t1
40000a84:	01d70733          	add	a4,a4,t4
40000a88:	00f5e663          	bltu	a1,a5,40000a94 <__umoddi3+0x3ac>
40000a8c:	00f59e63          	bne	a1,a5,40000aa8 <__umoddi3+0x3c0>
40000a90:	00e57c63          	bgeu	a0,a4,40000aa8 <__umoddi3+0x3c0>
40000a94:	40c70633          	sub	a2,a4,a2
40000a98:	00c73333          	sltu	t1,a4,a2
40000a9c:	00d306b3          	add	a3,t1,a3
40000aa0:	00060713          	mv	a4,a2
40000aa4:	40d787b3          	sub	a5,a5,a3
40000aa8:	40e50733          	sub	a4,a0,a4
40000aac:	00e53533          	sltu	a0,a0,a4
40000ab0:	40f585b3          	sub	a1,a1,a5
40000ab4:	40a585b3          	sub	a1,a1,a0
40000ab8:	011598b3          	sll	a7,a1,a7
40000abc:	01075733          	srl	a4,a4,a6
40000ac0:	00e8e533          	or	a0,a7,a4
40000ac4:	0105d5b3          	srl	a1,a1,a6
40000ac8:	00008067          	ret

40000acc <_OffsetAbsSyms>:
GEN_OFFSET_SYM(_cpu_arch_t, user_exc_sp);
GEN_OFFSET_SYM(_cpu_arch_t, user_exc_tmp0);
GEN_OFFSET_SYM(_cpu_arch_t, user_exc_tmp1);
#endif

GEN_ABS_SYM_END
40000acc:	00008067          	ret

40000ad0 <main>:
#else
#define setup_ipv6(...)
#endif /* CONFIG_NET_IPV6 */

int main(void)
{
40000ad0:	fe010113          	addi	sp,sp,-32
40000ad4:	00812c23          	sw	s0,24(sp)
40000ad8:	00112e23          	sw	ra,28(sp)
	struct net_if *iface = net_if_get_default();
40000adc:	0e00c0ef          	jal	ra,4000cbbc <net_if_get_default>
40000ae0:	00050413          	mv	s0,a0
		union { uintptr_t x; void * val; } parm2 = { .val = dst };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_NET_ADDR_PTON);
	}
#endif
	compiler_barrier();
	return z_impl_net_addr_pton(family, src, dst);
40000ae4:	4002c5b7          	lui	a1,0x4002c
40000ae8:	00010613          	mv	a2,sp
40000aec:	d2c58593          	addi	a1,a1,-724 # 4002bd2c <__clz_tab+0x100>
40000af0:	00100513          	li	a0,1
40000af4:	6580f0ef          	jal	ra,4001014c <z_impl_net_addr_pton>
	if (net_addr_pton(AF_INET, CONFIG_NET_CONFIG_MY_IPV4_ADDR, &addr)) {
40000af8:	00051c63          	bnez	a0,40000b10 <main+0x40>
	net_if_ipv4_addr_add(iface, &addr, NET_ADDR_MANUAL, 0);
40000afc:	00000693          	li	a3,0
40000b00:	00300613          	li	a2,3
40000b04:	00010593          	mv	a1,sp
40000b08:	00040513          	mv	a0,s0
40000b0c:	4580e0ef          	jal	ra,4000ef64 <net_if_ipv4_addr_add>
40000b10:	4002c5b7          	lui	a1,0x4002c
40000b14:	00010613          	mv	a2,sp
40000b18:	d3858593          	addi	a1,a1,-712 # 4002bd38 <__clz_tab+0x10c>
40000b1c:	00200513          	li	a0,2
40000b20:	62c0f0ef          	jal	ra,4001014c <z_impl_net_addr_pton>
	if (net_addr_pton(AF_INET6, CONFIG_NET_CONFIG_MY_IPV6_ADDR, &addr)) {
40000b24:	02051e63          	bnez	a0,40000b60 <main+0x90>
	net_if_ipv6_addr_add(iface, &addr, NET_ADDR_MANUAL, 0);
40000b28:	00000693          	li	a3,0
40000b2c:	00300613          	li	a2,3
40000b30:	00010593          	mv	a1,sp
40000b34:	00040513          	mv	a0,s0
40000b38:	7940c0ef          	jal	ra,4000d2cc <net_if_ipv6_addr_add>
40000b3c:	4002c5b7          	lui	a1,0x4002c
40000b40:	00010613          	mv	a2,sp
40000b44:	d4458593          	addi	a1,a1,-700 # 4002bd44 <__clz_tab+0x118>
40000b48:	00200513          	li	a0,2
40000b4c:	6000f0ef          	jal	ra,4001014c <z_impl_net_addr_pton>
	if (net_addr_pton(AF_INET6, MCAST_IP6ADDR, &addr)) {
40000b50:	00051863          	bnez	a0,40000b60 <main+0x90>
	net_if_ipv6_maddr_add(iface, &addr);
40000b54:	00010593          	mv	a1,sp
40000b58:	00040513          	mv	a0,s0
40000b5c:	3380d0ef          	jal	ra,4000de94 <net_if_ipv6_maddr_add>

	setup_dhcpv4(iface);

	setup_ipv6(iface);
	return 0;
}
40000b60:	01c12083          	lw	ra,28(sp)
40000b64:	01812403          	lw	s0,24(sp)
40000b68:	00000513          	li	a0,0
40000b6c:	02010113          	addi	sp,sp,32
40000b70:	00008067          	ret

40000b74 <getopt>:
/*
 * getopt --
 *	Parse argc/argv argument vector.
 */
int getopt(int nargc, char *const nargv[], const char *ostr)
{
40000b74:	fe010113          	addi	sp,sp,-32
40000b78:	00812c23          	sw	s0,24(sp)
40000b7c:	00912a23          	sw	s1,20(sp)
40000b80:	01212823          	sw	s2,16(sp)
40000b84:	01312623          	sw	s3,12(sp)
40000b88:	00112e23          	sw	ra,28(sp)
40000b8c:	01412423          	sw	s4,8(sp)
40000b90:	00050993          	mv	s3,a0
40000b94:	00058493          	mv	s1,a1
40000b98:	00060913          	mv	s2,a2
	struct getopt_state *state;
	char *oli; /* option letter list index */

	/* get getopt state of the current thread */
	state = getopt_state_get();
40000b9c:	1ec000ef          	jal	ra,40000d88 <getopt_state_get>

	if (state->optreset || *state->place == 0) { /* update scanning pointer */
40000ba0:	00c52783          	lw	a5,12(a0)
	state = getopt_state_get();
40000ba4:	00050413          	mv	s0,a0
	if (state->optreset || *state->place == 0) { /* update scanning pointer */
40000ba8:	00079863          	bnez	a5,40000bb8 <getopt+0x44>
40000bac:	01452783          	lw	a5,20(a0)
40000bb0:	0007c703          	lbu	a4,0(a5)
40000bb4:	0e071e63          	bnez	a4,40000cb0 <getopt+0x13c>
		state->optreset = 0;
		state->place = nargv[state->optind];
40000bb8:	00442783          	lw	a5,4(s0)
		state->optreset = 0;
40000bbc:	00042623          	sw	zero,12(s0)
		state->place = nargv[state->optind];
40000bc0:	00279713          	slli	a4,a5,0x2
40000bc4:	00e48733          	add	a4,s1,a4
40000bc8:	00072703          	lw	a4,0(a4) # 1000000 <__rom_region_size+0xfcf624>
		if (state->optind >= nargc || *state->place++ != '-') {
40000bcc:	0337ce63          	blt	a5,s3,40000c08 <getopt+0x94>
		}
		state->optopt = *state->place++;
		if (state->optopt == '-' && *state->place == 0) {
			/* "--" => end of options */
			++state->optind;
			state->place = EMSG;
40000bd0:	4002c7b7          	lui	a5,0x4002c
40000bd4:	ed878793          	addi	a5,a5,-296 # 4002bed8 <__clz_tab+0x2ac>
40000bd8:	00f42a23          	sw	a5,20(s0)
			z_getopt_global_state_update(state);
40000bdc:	00040513          	mv	a0,s0
40000be0:	168000ef          	jal	ra,40000d48 <z_getopt_global_state_update>
			return -1;
40000be4:	fff00513          	li	a0,-1
		state->place = EMSG;
		++state->optind;
	}
	z_getopt_global_state_update(state);
	return state->optopt;	/* return option letter */
}
40000be8:	01c12083          	lw	ra,28(sp)
40000bec:	01812403          	lw	s0,24(sp)
40000bf0:	01412483          	lw	s1,20(sp)
40000bf4:	01012903          	lw	s2,16(sp)
40000bf8:	00c12983          	lw	s3,12(sp)
40000bfc:	00812a03          	lw	s4,8(sp)
40000c00:	02010113          	addi	sp,sp,32
40000c04:	00008067          	ret
		if (state->optind >= nargc || *state->place++ != '-') {
40000c08:	00170693          	addi	a3,a4,1
40000c0c:	00d42a23          	sw	a3,20(s0)
40000c10:	00074a03          	lbu	s4,0(a4)
40000c14:	02d00693          	li	a3,45
40000c18:	fada1ce3          	bne	s4,a3,40000bd0 <getopt+0x5c>
		state->optopt = *state->place++;
40000c1c:	00270693          	addi	a3,a4,2
40000c20:	00d42a23          	sw	a3,20(s0)
40000c24:	00174683          	lbu	a3,1(a4)
40000c28:	00d42423          	sw	a3,8(s0)
		if (state->optopt == '-' && *state->place == 0) {
40000c2c:	01469c63          	bne	a3,s4,40000c44 <getopt+0xd0>
40000c30:	00274703          	lbu	a4,2(a4)
40000c34:	02071a63          	bnez	a4,40000c68 <getopt+0xf4>
			++state->optind;
40000c38:	00178793          	addi	a5,a5,1
40000c3c:	00f42223          	sw	a5,4(s0)
40000c40:	f91ff06f          	j	40000bd0 <getopt+0x5c>
		if (state->optopt == 0) {
40000c44:	02069263          	bnez	a3,40000c68 <getopt+0xf4>
			state->place = EMSG;
40000c48:	4002c7b7          	lui	a5,0x4002c
40000c4c:	ed878793          	addi	a5,a5,-296 # 4002bed8 <__clz_tab+0x2ac>
40000c50:	00f42a23          	sw	a5,20(s0)
			if (strchr(ostr, '-') == NULL) {
40000c54:	02d00593          	li	a1,45
40000c58:	00090513          	mv	a0,s2
40000c5c:	284080ef          	jal	ra,40008ee0 <strchr>
40000c60:	f6050ee3          	beqz	a0,40000bdc <getopt+0x68>
			state->optopt = '-';
40000c64:	01442423          	sw	s4,8(s0)
	oli = strchr(ostr, state->optopt);
40000c68:	00842583          	lw	a1,8(s0)
40000c6c:	00090513          	mv	a0,s2
40000c70:	270080ef          	jal	ra,40008ee0 <strchr>
	if (state->optopt == ':' || oli == NULL) {
40000c74:	00842683          	lw	a3,8(s0)
40000c78:	03a00713          	li	a4,58
40000c7c:	01442783          	lw	a5,20(s0)
40000c80:	00e68663          	beq	a3,a4,40000c8c <getopt+0x118>
		if (*state->place == 0) {
40000c84:	00078693          	mv	a3,a5
	if (state->optopt == ':' || oli == NULL) {
40000c88:	02051e63          	bnez	a0,40000cc4 <getopt+0x150>
		if (*state->place == 0) {
40000c8c:	0007c783          	lbu	a5,0(a5)
40000c90:	00079863          	bnez	a5,40000ca0 <getopt+0x12c>
			++state->optind;
40000c94:	00442783          	lw	a5,4(s0)
40000c98:	00178793          	addi	a5,a5,1
40000c9c:	00f42223          	sw	a5,4(s0)
		z_getopt_global_state_update(state);
40000ca0:	00040513          	mv	a0,s0
			z_getopt_global_state_update(state);
40000ca4:	0a4000ef          	jal	ra,40000d48 <z_getopt_global_state_update>
		return BADCH;
40000ca8:	03f00513          	li	a0,63
40000cac:	f3dff06f          	j	40000be8 <getopt+0x74>
		state->optopt = *state->place++;
40000cb0:	00178713          	addi	a4,a5,1
40000cb4:	00e52a23          	sw	a4,20(a0)
40000cb8:	0007c783          	lbu	a5,0(a5)
40000cbc:	00f52423          	sw	a5,8(a0)
40000cc0:	fa9ff06f          	j	40000c68 <getopt+0xf4>
	if (oli[1] != ':') {
40000cc4:	00154603          	lbu	a2,1(a0)
40000cc8:	02e60663          	beq	a2,a4,40000cf4 <getopt+0x180>
		state->optarg = NULL;
40000ccc:	00042823          	sw	zero,16(s0)
		if (*state->place == 0) {
40000cd0:	0007c783          	lbu	a5,0(a5)
40000cd4:	00079863          	bnez	a5,40000ce4 <getopt+0x170>
		++state->optind;
40000cd8:	00442783          	lw	a5,4(s0)
40000cdc:	00178793          	addi	a5,a5,1
40000ce0:	00f42223          	sw	a5,4(s0)
	z_getopt_global_state_update(state);
40000ce4:	00040513          	mv	a0,s0
40000ce8:	060000ef          	jal	ra,40000d48 <z_getopt_global_state_update>
	return state->optopt;	/* return option letter */
40000cec:	00842503          	lw	a0,8(s0)
40000cf0:	ef9ff06f          	j	40000be8 <getopt+0x74>
		if (*state->place) {
40000cf4:	0006c583          	lbu	a1,0(a3) # 10000 <__kernel_ram_size+0x3d6c>
40000cf8:	4002c737          	lui	a4,0x4002c
			++state->optind;
40000cfc:	00442783          	lw	a5,4(s0)
40000d00:	ed870713          	addi	a4,a4,-296 # 4002bed8 <__clz_tab+0x2ac>
		if (*state->place) {
40000d04:	00059e63          	bnez	a1,40000d20 <getopt+0x1ac>
		} else if (nargc > ++state->optind) {
40000d08:	00178793          	addi	a5,a5,1
40000d0c:	00f42223          	sw	a5,4(s0)
40000d10:	0137de63          	bge	a5,s3,40000d2c <getopt+0x1b8>
			state->optarg = nargv[state->optind];
40000d14:	00279793          	slli	a5,a5,0x2
40000d18:	00f484b3          	add	s1,s1,a5
40000d1c:	0004a683          	lw	a3,0(s1)
			state->optarg = state->place;
40000d20:	00d42823          	sw	a3,16(s0)
		state->place = EMSG;
40000d24:	00e42a23          	sw	a4,20(s0)
40000d28:	fb1ff06f          	j	40000cd8 <getopt+0x164>
			state->place = EMSG;
40000d2c:	00e42a23          	sw	a4,20(s0)
			if (*ostr == ':') {
40000d30:	00094783          	lbu	a5,0(s2)
				z_getopt_global_state_update(state);
40000d34:	00040513          	mv	a0,s0
			if (*ostr == ':') {
40000d38:	f6c796e3          	bne	a5,a2,40000ca4 <getopt+0x130>
				z_getopt_global_state_update(state);
40000d3c:	00c000ef          	jal	ra,40000d48 <z_getopt_global_state_update>
				return BADARG;
40000d40:	03a00513          	li	a0,58
40000d44:	ea5ff06f          	j	40000be8 <getopt+0x74>

40000d48 <z_getopt_global_state_update>:
/* This function is not thread safe. All threads using getopt are calling
 * this function.
 */
void z_getopt_global_state_update(struct getopt_state *state)
{
	opterr = state->opterr;
40000d48:	00052703          	lw	a4,0(a0)
40000d4c:	4003d7b7          	lui	a5,0x4003d
40000d50:	9ee7a423          	sw	a4,-1560(a5) # 4003c9e8 <opterr>
	optind = state->optind;
40000d54:	00452703          	lw	a4,4(a0)
40000d58:	4003d7b7          	lui	a5,0x4003d
40000d5c:	9ee7a223          	sw	a4,-1564(a5) # 4003c9e4 <optind>
	optopt = state->optopt;
40000d60:	00852703          	lw	a4,8(a0)
40000d64:	400317b7          	lui	a5,0x40031
40000d68:	9ee7a823          	sw	a4,-1552(a5) # 400309f0 <optopt>
	optreset = state->optreset;
40000d6c:	00c52703          	lw	a4,12(a0)
40000d70:	400317b7          	lui	a5,0x40031
40000d74:	9ee7a623          	sw	a4,-1556(a5) # 400309ec <optreset>
	optarg = state->optarg;
40000d78:	01052703          	lw	a4,16(a0)
40000d7c:	400317b7          	lui	a5,0x40031
40000d80:	9ee7a423          	sw	a4,-1560(a5) # 400309e8 <optarg>
}
40000d84:	00008067          	ret

40000d88 <getopt_state_get>:
			return &sh->ctx->getopt;
		}
	}
#endif
	/* If not a shell thread return a common pointer */
	return &m_getopt_common_state;
40000d88:	4003c537          	lui	a0,0x4003c
}
40000d8c:	2f850513          	addi	a0,a0,760 # 4003c2f8 <m_getopt_common_state>
40000d90:	00008067          	ret

40000d94 <char2hex>:
#include <errno.h>
#include <zephyr/sys/util.h>

int char2hex(char c, uint8_t *x)
{
	if (c >= '0' && c <= '9') {
40000d94:	fd050713          	addi	a4,a0,-48
40000d98:	0ff77713          	zext.b	a4,a4
40000d9c:	00900693          	li	a3,9
{
40000da0:	00050793          	mv	a5,a0
	if (c >= '0' && c <= '9') {
40000da4:	00e6e863          	bltu	a3,a4,40000db4 <char2hex+0x20>
		*x = c - '0';
40000da8:	00e58023          	sb	a4,0(a1)
		*x = c - 'A' + 10;
	} else {
		return -EINVAL;
	}

	return 0;
40000dac:	00000513          	li	a0,0
40000db0:	00008067          	ret
	} else if (c >= 'a' && c <= 'f') {
40000db4:	f9f50713          	addi	a4,a0,-97
40000db8:	0ff77713          	zext.b	a4,a4
40000dbc:	00500693          	li	a3,5
40000dc0:	00e6e863          	bltu	a3,a4,40000dd0 <char2hex+0x3c>
		*x = c - 'a' + 10;
40000dc4:	fa950793          	addi	a5,a0,-87
		*x = c - 'A' + 10;
40000dc8:	0ff7f713          	zext.b	a4,a5
40000dcc:	fddff06f          	j	40000da8 <char2hex+0x14>
	} else if (c >= 'A' && c <= 'F') {
40000dd0:	fbf50713          	addi	a4,a0,-65
40000dd4:	0ff77713          	zext.b	a4,a4
		return -EINVAL;
40000dd8:	fea00513          	li	a0,-22
	} else if (c >= 'A' && c <= 'F') {
40000ddc:	00e6e663          	bltu	a3,a4,40000de8 <char2hex+0x54>
		*x = c - 'A' + 10;
40000de0:	fc978793          	addi	a5,a5,-55
40000de4:	fe5ff06f          	j	40000dc8 <char2hex+0x34>
}
40000de8:	00008067          	ret

40000dec <hex2bin>:
	hex[2 * buflen] = '\0';
	return 2 * buflen;
}

size_t hex2bin(const char *hex, size_t hexlen, uint8_t *buf, size_t buflen)
{
40000dec:	fd010113          	addi	sp,sp,-48
40000df0:	01312e23          	sw	s3,28(sp)
	uint8_t dec;

	if (buflen < hexlen / 2 + hexlen % 2) {
40000df4:	0015d993          	srli	s3,a1,0x1
40000df8:	0015f593          	andi	a1,a1,1
{
40000dfc:	01412c23          	sw	s4,24(sp)
40000e00:	02112623          	sw	ra,44(sp)
40000e04:	02812423          	sw	s0,40(sp)
40000e08:	02912223          	sw	s1,36(sp)
40000e0c:	03212023          	sw	s2,32(sp)
	if (buflen < hexlen / 2 + hexlen % 2) {
40000e10:	00b98a33          	add	s4,s3,a1
40000e14:	0346f663          	bgeu	a3,s4,40000e40 <hex2bin+0x54>
		return 0;
40000e18:	00000a13          	li	s4,0
		}
		buf[i] += dec;
	}

	return hexlen / 2 + hexlen % 2;
}
40000e1c:	02c12083          	lw	ra,44(sp)
40000e20:	02812403          	lw	s0,40(sp)
40000e24:	02412483          	lw	s1,36(sp)
40000e28:	02012903          	lw	s2,32(sp)
40000e2c:	01c12983          	lw	s3,28(sp)
40000e30:	000a0513          	mv	a0,s4
40000e34:	01812a03          	lw	s4,24(sp)
40000e38:	03010113          	addi	sp,sp,48
40000e3c:	00008067          	ret
40000e40:	00050493          	mv	s1,a0
40000e44:	00060413          	mv	s0,a2
	if (hexlen % 2) {
40000e48:	02058263          	beqz	a1,40000e6c <hex2bin+0x80>
		if (char2hex(hex[0], &dec) < 0) {
40000e4c:	00054503          	lbu	a0,0(a0)
40000e50:	00f10593          	addi	a1,sp,15
40000e54:	f41ff0ef          	jal	ra,40000d94 <char2hex>
40000e58:	fc0540e3          	bltz	a0,40000e18 <hex2bin+0x2c>
		buf[0] = dec;
40000e5c:	00f14783          	lbu	a5,15(sp)
		hex++;
40000e60:	00148493          	addi	s1,s1,1
		buf++;
40000e64:	00140413          	addi	s0,s0,1
		buf[0] = dec;
40000e68:	fef40fa3          	sb	a5,-1(s0)
	for (size_t i = 0; i < hexlen / 2; i++) {
40000e6c:	013409b3          	add	s3,s0,s3
40000e70:	fb3406e3          	beq	s0,s3,40000e1c <hex2bin+0x30>
		if (char2hex(hex[2 * i], &dec) < 0) {
40000e74:	0004c503          	lbu	a0,0(s1)
40000e78:	00f10593          	addi	a1,sp,15
40000e7c:	f19ff0ef          	jal	ra,40000d94 <char2hex>
40000e80:	f8054ce3          	bltz	a0,40000e18 <hex2bin+0x2c>
		buf[i] = dec << 4;
40000e84:	00f14903          	lbu	s2,15(sp)
		if (char2hex(hex[2 * i + 1], &dec) < 0) {
40000e88:	00f10593          	addi	a1,sp,15
40000e8c:	00248493          	addi	s1,s1,2
		buf[i] = dec << 4;
40000e90:	00491913          	slli	s2,s2,0x4
40000e94:	0ff97913          	zext.b	s2,s2
40000e98:	01240023          	sb	s2,0(s0)
		if (char2hex(hex[2 * i + 1], &dec) < 0) {
40000e9c:	fff4c503          	lbu	a0,-1(s1)
40000ea0:	ef5ff0ef          	jal	ra,40000d94 <char2hex>
40000ea4:	f6054ae3          	bltz	a0,40000e18 <hex2bin+0x2c>
		buf[i] += dec;
40000ea8:	00f14783          	lbu	a5,15(sp)
40000eac:	00140413          	addi	s0,s0,1
40000eb0:	00f90933          	add	s2,s2,a5
40000eb4:	ff240fa3          	sb	s2,-1(s0)
	for (size_t i = 0; i < hexlen / 2; i++) {
40000eb8:	fb9ff06f          	j	40000e70 <hex2bin+0x84>

40000ebc <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
40000ebc:	00000513          	li	a0,0
40000ec0:	00008067          	ret

40000ec4 <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
40000ec4:	4003d7b7          	lui	a5,0x4003d
40000ec8:	9ec7a783          	lw	a5,-1556(a5) # 4003c9ec <_char_out>
40000ecc:	00078067          	jr	a5

40000ed0 <str_out>:
	int count;
};

static int str_out(int c, struct str_context *ctx)
{
	if (ctx->str == NULL || ctx->count >= ctx->max) {
40000ed0:	0085a703          	lw	a4,8(a1)
40000ed4:	0005a783          	lw	a5,0(a1)
		ctx->count++;
		return c;
	}

	if (ctx->count == ctx->max - 1) {
		ctx->str[ctx->count++] = '\0';
40000ed8:	00170613          	addi	a2,a4,1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
40000edc:	00078663          	beqz	a5,40000ee8 <str_out+0x18>
40000ee0:	0045a683          	lw	a3,4(a1)
40000ee4:	00d74663          	blt	a4,a3,40000ef0 <str_out+0x20>
		ctx->count++;
40000ee8:	00c5a423          	sw	a2,8(a1)
		return c;
40000eec:	00008067          	ret
	if (ctx->count == ctx->max - 1) {
40000ef0:	fff68693          	addi	a3,a3,-1
		ctx->str[ctx->count++] = '\0';
40000ef4:	00c5a423          	sw	a2,8(a1)
40000ef8:	00e787b3          	add	a5,a5,a4
	if (ctx->count == ctx->max - 1) {
40000efc:	00e69663          	bne	a3,a4,40000f08 <str_out+0x38>
		ctx->str[ctx->count++] = '\0';
40000f00:	00078023          	sb	zero,0(a5)
40000f04:	00008067          	ret
	} else {
		ctx->str[ctx->count++] = c;
40000f08:	00a78023          	sb	a0,0(a5)
	}

	return c;
}
40000f0c:	00008067          	ret

40000f10 <__printk_hook_install>:
	_char_out = fn;
40000f10:	4003d7b7          	lui	a5,0x4003d
40000f14:	9ea7a623          	sw	a0,-1556(a5) # 4003c9ec <_char_out>
}
40000f18:	00008067          	ret

40000f1c <vprintk>:
{
40000f1c:	00050613          	mv	a2,a0
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
40000f20:	40001537          	lui	a0,0x40001
40000f24:	00058693          	mv	a3,a1
40000f28:	00000713          	li	a4,0
40000f2c:	00000593          	li	a1,0
40000f30:	ec450513          	addi	a0,a0,-316 # 40000ec4 <char_out>
40000f34:	6150006f          	j	40001d48 <z_cbvprintf_impl>

40000f38 <printk>:
{
40000f38:	fc010113          	addi	sp,sp,-64
40000f3c:	02b12223          	sw	a1,36(sp)
	va_start(ap, fmt);
40000f40:	02410593          	addi	a1,sp,36
{
40000f44:	00112e23          	sw	ra,28(sp)
40000f48:	02c12423          	sw	a2,40(sp)
40000f4c:	02d12623          	sw	a3,44(sp)
40000f50:	02e12823          	sw	a4,48(sp)
40000f54:	02f12a23          	sw	a5,52(sp)
40000f58:	03012c23          	sw	a6,56(sp)
40000f5c:	03112e23          	sw	a7,60(sp)
	va_start(ap, fmt);
40000f60:	00b12623          	sw	a1,12(sp)
	vprintk(fmt, ap);
40000f64:	fb9ff0ef          	jal	ra,40000f1c <vprintk>
}
40000f68:	01c12083          	lw	ra,28(sp)
40000f6c:	04010113          	addi	sp,sp,64
40000f70:	00008067          	ret

40000f74 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
40000f74:	fe010113          	addi	sp,sp,-32
40000f78:	00812c23          	sw	s0,24(sp)
	struct str_context ctx = { str, size, 0 };
40000f7c:	00a12223          	sw	a0,4(sp)
{
40000f80:	00050413          	mv	s0,a0
40000f84:	40001537          	lui	a0,0x40001
	struct str_context ctx = { str, size, 0 };
40000f88:	00b12423          	sw	a1,8(sp)
40000f8c:	00000713          	li	a4,0
40000f90:	00410593          	addi	a1,sp,4
40000f94:	ed050513          	addi	a0,a0,-304 # 40000ed0 <str_out>
{
40000f98:	00112e23          	sw	ra,28(sp)
	struct str_context ctx = { str, size, 0 };
40000f9c:	00012623          	sw	zero,12(sp)
40000fa0:	5a9000ef          	jal	ra,40001d48 <z_cbvprintf_impl>

	cbvprintf(str_out, &ctx, fmt, ap);

	if (ctx.count < ctx.max) {
40000fa4:	00c12503          	lw	a0,12(sp)
40000fa8:	00812783          	lw	a5,8(sp)
40000fac:	00f55663          	bge	a0,a5,40000fb8 <vsnprintk+0x44>
		str[ctx.count] = '\0';
40000fb0:	00a40433          	add	s0,s0,a0
40000fb4:	00040023          	sb	zero,0(s0)
	}

	return ctx.count;
}
40000fb8:	01c12083          	lw	ra,28(sp)
40000fbc:	01812403          	lw	s0,24(sp)
40000fc0:	02010113          	addi	sp,sp,32
40000fc4:	00008067          	ret

40000fc8 <snprintk>:
{
40000fc8:	fc010113          	addi	sp,sp,-64
40000fcc:	02d12623          	sw	a3,44(sp)
	va_start(ap, fmt);
40000fd0:	02c10693          	addi	a3,sp,44
{
40000fd4:	00112e23          	sw	ra,28(sp)
40000fd8:	02e12823          	sw	a4,48(sp)
40000fdc:	02f12a23          	sw	a5,52(sp)
40000fe0:	03012c23          	sw	a6,56(sp)
40000fe4:	03112e23          	sw	a7,60(sp)
	va_start(ap, fmt);
40000fe8:	00d12623          	sw	a3,12(sp)
	ret = vsnprintk(str, size, fmt, ap);
40000fec:	f89ff0ef          	jal	ra,40000f74 <vsnprintk>
}
40000ff0:	01c12083          	lw	ra,28(sp)
40000ff4:	04010113          	addi	sp,sp,64
40000ff8:	00008067          	ret

40000ffc <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
40000ffc:	ff010113          	addi	sp,sp,-16
40001000:	00050793          	mv	a5,a0
40001004:	00058513          	mv	a0,a1
40001008:	00060593          	mv	a1,a2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
4000100c:	00068613          	mv	a2,a3
{
40001010:	00112623          	sw	ra,12(sp)
	entry(p1, p2, p3);
40001014:	000780e7          	jalr	a5
	if (z_syscall_trap()) {
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
40001018:	48c290ef          	jal	ra,4002a4a4 <z_impl_z_current_get>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
4000101c:	5bc290ef          	jal	ra,4002a5d8 <z_impl_k_thread_abort>

40001020 <chunk_field>:
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
40001020:	00852703          	lw	a4,8(a0)
	void *cmem = &buf[c];
40001024:	00359593          	slli	a1,a1,0x3
	if (big_heap(h)) {
40001028:	000087b7          	lui	a5,0x8
	void *cmem = &buf[c];
4000102c:	00b505b3          	add	a1,a0,a1
	if (big_heap(h)) {
40001030:	00f76a63          	bltu	a4,a5,40001044 <chunk_field+0x24>
		return ((uint32_t *)cmem)[f];
40001034:	00261613          	slli	a2,a2,0x2
40001038:	00c585b3          	add	a1,a1,a2
4000103c:	0005a503          	lw	a0,0(a1)
40001040:	00008067          	ret
	} else {
		return ((uint16_t *)cmem)[f];
40001044:	00161613          	slli	a2,a2,0x1
40001048:	00c585b3          	add	a1,a1,a2
4000104c:	0005d503          	lhu	a0,0(a1)
	}
}
40001050:	00008067          	ret

40001054 <chunk_set>:
	CHECK(c <= h->end_chunk);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
40001054:	00852703          	lw	a4,8(a0)
	void *cmem = &buf[c];
40001058:	00359593          	slli	a1,a1,0x3
	if (big_heap(h)) {
4000105c:	000087b7          	lui	a5,0x8
	void *cmem = &buf[c];
40001060:	00b505b3          	add	a1,a0,a1
	if (big_heap(h)) {
40001064:	00f76a63          	bltu	a4,a5,40001078 <chunk_set+0x24>
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
40001068:	00261613          	slli	a2,a2,0x2
4000106c:	00c585b3          	add	a1,a1,a2
40001070:	00d5a023          	sw	a3,0(a1)
40001074:	00008067          	ret
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
40001078:	00161613          	slli	a2,a2,0x1
4000107c:	00c585b3          	add	a1,a1,a2
40001080:	00d59023          	sh	a3,0(a1)
	}
}
40001084:	00008067          	ret

40001088 <chunk_size>:
{
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
40001088:	ff010113          	addi	sp,sp,-16
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
4000108c:	00100613          	li	a2,1
{
40001090:	00112623          	sw	ra,12(sp)
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
40001094:	f8dff0ef          	jal	ra,40001020 <chunk_field>
}
40001098:	00c12083          	lw	ra,12(sp)
4000109c:	00155513          	srli	a0,a0,0x1
400010a0:	01010113          	addi	sp,sp,16
400010a4:	00008067          	ret

400010a8 <set_chunk_used>:
static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
400010a8:	00852703          	lw	a4,8(a0)
	void *cmem = &buf[c];
400010ac:	00359593          	slli	a1,a1,0x3
	if (big_heap(h)) {
400010b0:	000087b7          	lui	a5,0x8
	void *cmem = &buf[c];
400010b4:	00b505b3          	add	a1,a0,a1
	if (big_heap(h)) {
400010b8:	02f76063          	bltu	a4,a5,400010d8 <set_chunk_used+0x30>
		if (used) {
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
400010bc:	0045a783          	lw	a5,4(a1)
		if (used) {
400010c0:	00060863          	beqz	a2,400010d0 <set_chunk_used+0x28>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
400010c4:	0017e793          	ori	a5,a5,1
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
400010c8:	00f5a223          	sw	a5,4(a1)
400010cc:	00008067          	ret
400010d0:	ffe7f793          	andi	a5,a5,-2
400010d4:	ff5ff06f          	j	400010c8 <set_chunk_used+0x20>
		}
	} else {
		if (used) {
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
400010d8:	0025d783          	lhu	a5,2(a1)
		if (used) {
400010dc:	00060863          	beqz	a2,400010ec <set_chunk_used+0x44>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
400010e0:	0017e793          	ori	a5,a5,1
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
400010e4:	00f59123          	sh	a5,2(a1)
		}
	}
}
400010e8:	00008067          	ret
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
400010ec:	ffe7f793          	andi	a5,a5,-2
400010f0:	ff5ff06f          	j	400010e4 <set_chunk_used+0x3c>

400010f4 <set_chunk_size>:
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, chunksz_t size)
{
	chunk_set(h, c, SIZE_AND_USED, size << 1);
400010f4:	00161693          	slli	a3,a2,0x1
400010f8:	00100613          	li	a2,1
400010fc:	f59ff06f          	j	40001054 <chunk_set>

40001100 <mem_to_chunkid>:
	return big_heap(h) && chunk_size(h, c) == 1U;
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
40001100:	00852703          	lw	a4,8(a0)
40001104:	000087b7          	lui	a5,0x8
40001108:	00f76c63          	bltu	a4,a5,40001120 <mem_to_chunkid+0x20>
4000110c:	00800793          	li	a5,8
 * boundary.
 */
static chunkid_t mem_to_chunkid(struct z_heap *h, void *p)
{
	uint8_t *mem = p, *base = (uint8_t *)chunk_buf(h);
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
40001110:	40f585b3          	sub	a1,a1,a5
40001114:	40a58533          	sub	a0,a1,a0
}
40001118:	00355513          	srli	a0,a0,0x3
4000111c:	00008067          	ret
40001120:	00400793          	li	a5,4
40001124:	fedff06f          	j	40001110 <mem_to_chunkid+0x10>

40001128 <bucket_idx.isra.0>:
static inline size_t chunksz_to_bytes(struct z_heap *h, chunksz_t chunksz_in)
{
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
40001128:	ff010113          	addi	sp,sp,-16
4000112c:	00112623          	sw	ra,12(sp)
	return big_heap(h) ? 8 : 4;
40001130:	000087b7          	lui	a5,0x8
40001134:	02f56863          	bltu	a0,a5,40001164 <bucket_idx.isra.0+0x3c>
40001138:	00800793          	li	a5,8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
4000113c:	00878793          	addi	a5,a5,8 # 8008 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4008>
40001140:	0037d793          	srli	a5,a5,0x3
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
40001144:	00158593          	addi	a1,a1,1
	return 31 - __builtin_clz(usable_sz);
40001148:	40f58533          	sub	a0,a1,a5
4000114c:	8d0ff0ef          	jal	ra,4000021c <__clzsi2>
}
40001150:	00c12083          	lw	ra,12(sp)
40001154:	01f00793          	li	a5,31
40001158:	40a78533          	sub	a0,a5,a0
4000115c:	01010113          	addi	sp,sp,16
40001160:	00008067          	ret
	return big_heap(h) ? 8 : 4;
40001164:	00400793          	li	a5,4
40001168:	fd5ff06f          	j	4000113c <bucket_idx.isra.0+0x14>

4000116c <free_list_remove_bidx>:
{
4000116c:	fe010113          	addi	sp,sp,-32
40001170:	01412423          	sw	s4,8(sp)
40001174:	00060a13          	mv	s4,a2
	return chunk_field(h, c, FREE_NEXT);
40001178:	00300613          	li	a2,3
4000117c:	00812c23          	sw	s0,24(sp)
40001180:	00912a23          	sw	s1,20(sp)
40001184:	01312623          	sw	s3,12(sp)
40001188:	00112e23          	sw	ra,28(sp)
4000118c:	01212823          	sw	s2,16(sp)
40001190:	00050413          	mv	s0,a0
40001194:	00058993          	mv	s3,a1
40001198:	e89ff0ef          	jal	ra,40001020 <chunk_field>
4000119c:	004a0493          	addi	s1,s4,4
	if (next_free_chunk(h, c) == c) {
400011a0:	04a99463          	bne	s3,a0,400011e8 <free_list_remove_bidx+0x7c>
		h->avail_buckets &= ~BIT(bidx);
400011a4:	00c42783          	lw	a5,12(s0)
400011a8:	00100613          	li	a2,1
400011ac:	01461633          	sll	a2,a2,s4
400011b0:	fff64613          	not	a2,a2
		b->next = 0;
400011b4:	00249493          	slli	s1,s1,0x2
		h->avail_buckets &= ~BIT(bidx);
400011b8:	00c7f7b3          	and	a5,a5,a2
400011bc:	00f42623          	sw	a5,12(s0)
		b->next = 0;
400011c0:	00940433          	add	s0,s0,s1
400011c4:	00042023          	sw	zero,0(s0)
}
400011c8:	01c12083          	lw	ra,28(sp)
400011cc:	01812403          	lw	s0,24(sp)
400011d0:	01412483          	lw	s1,20(sp)
400011d4:	01012903          	lw	s2,16(sp)
400011d8:	00c12983          	lw	s3,12(sp)
400011dc:	00812a03          	lw	s4,8(sp)
400011e0:	02010113          	addi	sp,sp,32
400011e4:	00008067          	ret
400011e8:	00050913          	mv	s2,a0
	return chunk_field(h, c, FREE_PREV);
400011ec:	00098593          	mv	a1,s3
400011f0:	00200613          	li	a2,2
400011f4:	00040513          	mv	a0,s0
		b->next = second;
400011f8:	00249493          	slli	s1,s1,0x2
400011fc:	e25ff0ef          	jal	ra,40001020 <chunk_field>
40001200:	009404b3          	add	s1,s0,s1
40001204:	00050993          	mv	s3,a0
40001208:	0124a023          	sw	s2,0(s1)
	chunk_set(h, c, FREE_NEXT, next);
4000120c:	00090693          	mv	a3,s2
40001210:	00050593          	mv	a1,a0
40001214:	00300613          	li	a2,3
40001218:	00040513          	mv	a0,s0
4000121c:	e39ff0ef          	jal	ra,40001054 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
40001220:	00040513          	mv	a0,s0
}
40001224:	01812403          	lw	s0,24(sp)
40001228:	01c12083          	lw	ra,28(sp)
4000122c:	01412483          	lw	s1,20(sp)
40001230:	00812a03          	lw	s4,8(sp)
40001234:	00098693          	mv	a3,s3
40001238:	00090593          	mv	a1,s2
4000123c:	00c12983          	lw	s3,12(sp)
40001240:	01012903          	lw	s2,16(sp)
40001244:	00200613          	li	a2,2
40001248:	02010113          	addi	sp,sp,32
4000124c:	e09ff06f          	j	40001054 <chunk_set>

40001250 <free_list_remove>:
{
40001250:	ff010113          	addi	sp,sp,-16
40001254:	00812423          	sw	s0,8(sp)
40001258:	00912223          	sw	s1,4(sp)
4000125c:	00112623          	sw	ra,12(sp)
40001260:	01212023          	sw	s2,0(sp)
	return big_heap_chunks(h->end_chunk);
40001264:	00852903          	lw	s2,8(a0)
40001268:	00058493          	mv	s1,a1
4000126c:	00050413          	mv	s0,a0
	return big_heap(h) && chunk_size(h, c) == 1U;
40001270:	e19ff0ef          	jal	ra,40001088 <chunk_size>
40001274:	000087b7          	lui	a5,0x8
40001278:	00050593          	mv	a1,a0
4000127c:	00f96663          	bltu	s2,a5,40001288 <free_list_remove+0x38>
40001280:	00100793          	li	a5,1
40001284:	02f50863          	beq	a0,a5,400012b4 <free_list_remove+0x64>
		int bidx = bucket_idx(h, chunk_size(h, c));
40001288:	00090513          	mv	a0,s2
4000128c:	e9dff0ef          	jal	ra,40001128 <bucket_idx.isra.0>
40001290:	00050613          	mv	a2,a0
		free_list_remove_bidx(h, c, bidx);
40001294:	00040513          	mv	a0,s0
}
40001298:	00812403          	lw	s0,8(sp)
4000129c:	00c12083          	lw	ra,12(sp)
400012a0:	00012903          	lw	s2,0(sp)
		free_list_remove_bidx(h, c, bidx);
400012a4:	00048593          	mv	a1,s1
}
400012a8:	00412483          	lw	s1,4(sp)
400012ac:	01010113          	addi	sp,sp,16
		free_list_remove_bidx(h, c, bidx);
400012b0:	ebdff06f          	j	4000116c <free_list_remove_bidx>
}
400012b4:	00c12083          	lw	ra,12(sp)
400012b8:	00812403          	lw	s0,8(sp)
400012bc:	00412483          	lw	s1,4(sp)
400012c0:	00012903          	lw	s2,0(sp)
400012c4:	01010113          	addi	sp,sp,16
400012c8:	00008067          	ret

400012cc <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
400012cc:	fe010113          	addi	sp,sp,-32
400012d0:	00912a23          	sw	s1,20(sp)
400012d4:	01212823          	sw	s2,16(sp)
400012d8:	01312623          	sw	s3,12(sp)
400012dc:	01512223          	sw	s5,4(sp)
400012e0:	01612023          	sw	s6,0(sp)
400012e4:	00112e23          	sw	ra,28(sp)
400012e8:	00812c23          	sw	s0,24(sp)
400012ec:	01412423          	sw	s4,8(sp)
400012f0:	00050493          	mv	s1,a0
	int bi = bucket_idx(h, sz);
400012f4:	00852503          	lw	a0,8(a0)
{
400012f8:	00058a93          	mv	s5,a1
	int bi = bucket_idx(h, sz);
400012fc:	e2dff0ef          	jal	ra,40001128 <bucket_idx.isra.0>
40001300:	00251993          	slli	s3,a0,0x2
40001304:	013489b3          	add	s3,s1,s3
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
40001308:	0109ab03          	lw	s6,16(s3)
	int bi = bucket_idx(h, sz);
4000130c:	00050913          	mv	s2,a0
	if (b->next) {
40001310:	060b0c63          	beqz	s6,40001388 <alloc_chunk+0xbc>
40001314:	00300a13          	li	s4,3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
40001318:	0109a403          	lw	s0,16(s3)
			if (chunk_size(h, c) >= sz) {
4000131c:	00048513          	mv	a0,s1
40001320:	00040593          	mv	a1,s0
40001324:	d65ff0ef          	jal	ra,40001088 <chunk_size>
40001328:	05556063          	bltu	a0,s5,40001368 <alloc_chunk+0x9c>
				free_list_remove_bidx(h, c, bi);
4000132c:	00090613          	mv	a2,s2

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
40001330:	00040593          	mv	a1,s0
40001334:	00048513          	mv	a0,s1
40001338:	e35ff0ef          	jal	ra,4000116c <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
4000133c:	01c12083          	lw	ra,28(sp)
40001340:	00040513          	mv	a0,s0
40001344:	01812403          	lw	s0,24(sp)
40001348:	01412483          	lw	s1,20(sp)
4000134c:	01012903          	lw	s2,16(sp)
40001350:	00c12983          	lw	s3,12(sp)
40001354:	00812a03          	lw	s4,8(sp)
40001358:	00412a83          	lw	s5,4(sp)
4000135c:	00012b03          	lw	s6,0(sp)
40001360:	02010113          	addi	sp,sp,32
40001364:	00008067          	ret
	return chunk_field(h, c, FREE_NEXT);
40001368:	00300613          	li	a2,3
4000136c:	00040593          	mv	a1,s0
40001370:	00048513          	mv	a0,s1
40001374:	cadff0ef          	jal	ra,40001020 <chunk_field>
			b->next = next_free_chunk(h, c);
40001378:	00a9a823          	sw	a0,16(s3)
		} while (--i && b->next != first);
4000137c:	fffa0a13          	addi	s4,s4,-1
40001380:	000a0463          	beqz	s4,40001388 <alloc_chunk+0xbc>
40001384:	f8ab1ae3          	bne	s6,a0,40001318 <alloc_chunk+0x4c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
40001388:	00c4a783          	lw	a5,12(s1)
4000138c:	00190913          	addi	s2,s2,1
40001390:	fff00413          	li	s0,-1
40001394:	01241433          	sll	s0,s0,s2
40001398:	00f47433          	and	s0,s0,a5
	if (bmask != 0U) {
4000139c:	fa0400e3          	beqz	s0,4000133c <alloc_chunk+0x70>
		int minbucket = __builtin_ctz(bmask);
400013a0:	00040513          	mv	a0,s0
400013a4:	ec5fe0ef          	jal	ra,40000268 <__ctzsi2>
		chunkid_t c = h->buckets[minbucket].next;
400013a8:	00450793          	addi	a5,a0,4
400013ac:	00279793          	slli	a5,a5,0x2
400013b0:	00f487b3          	add	a5,s1,a5
400013b4:	0007a403          	lw	s0,0(a5) # 8000 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4000>
		int minbucket = __builtin_ctz(bmask);
400013b8:	00050613          	mv	a2,a0
		chunkid_t c = h->buckets[minbucket].next;
400013bc:	f75ff06f          	j	40001330 <alloc_chunk+0x64>

400013c0 <split_chunks>:
{
400013c0:	fd010113          	addi	sp,sp,-48
400013c4:	02112623          	sw	ra,44(sp)
400013c8:	02812423          	sw	s0,40(sp)
400013cc:	02912223          	sw	s1,36(sp)
400013d0:	03212023          	sw	s2,32(sp)
400013d4:	01312e23          	sw	s3,28(sp)
400013d8:	00060413          	mv	s0,a2
400013dc:	00050493          	mv	s1,a0
400013e0:	00058913          	mv	s2,a1
	chunksz_t sz0 = chunk_size(h, lc);
400013e4:	ca5ff0ef          	jal	ra,40001088 <chunk_size>
	chunksz_t lsz = rc - lc;
400013e8:	412406b3          	sub	a3,s0,s2
	chunksz_t rsz = sz0 - lsz;
400013ec:	408909b3          	sub	s3,s2,s0
400013f0:	00a989b3          	add	s3,s3,a0
	set_chunk_size(h, lc, lsz);
400013f4:	00068613          	mv	a2,a3
400013f8:	00090593          	mv	a1,s2
400013fc:	00048513          	mv	a0,s1
40001400:	00d12623          	sw	a3,12(sp)
40001404:	cf1ff0ef          	jal	ra,400010f4 <set_chunk_size>
	set_chunk_size(h, rc, rsz);
40001408:	00098613          	mv	a2,s3
4000140c:	00040593          	mv	a1,s0
40001410:	00048513          	mv	a0,s1
40001414:	ce1ff0ef          	jal	ra,400010f4 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
40001418:	00c12683          	lw	a3,12(sp)
4000141c:	00000613          	li	a2,0
40001420:	00040593          	mv	a1,s0
40001424:	00048513          	mv	a0,s1
40001428:	c2dff0ef          	jal	ra,40001054 <chunk_set>
	return c + chunk_size(h, c);
4000142c:	00040593          	mv	a1,s0
40001430:	00048513          	mv	a0,s1
40001434:	c55ff0ef          	jal	ra,40001088 <chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
40001438:	00a405b3          	add	a1,s0,a0
}
4000143c:	02812403          	lw	s0,40(sp)
40001440:	02c12083          	lw	ra,44(sp)
40001444:	02012903          	lw	s2,32(sp)
40001448:	00098693          	mv	a3,s3
4000144c:	00048513          	mv	a0,s1
40001450:	01c12983          	lw	s3,28(sp)
40001454:	02412483          	lw	s1,36(sp)
40001458:	00000613          	li	a2,0
4000145c:	03010113          	addi	sp,sp,48
40001460:	bf5ff06f          	j	40001054 <chunk_set>

40001464 <merge_chunks>:
{
40001464:	fe010113          	addi	sp,sp,-32
40001468:	00112e23          	sw	ra,28(sp)
4000146c:	00812c23          	sw	s0,24(sp)
40001470:	00912a23          	sw	s1,20(sp)
40001474:	01212823          	sw	s2,16(sp)
40001478:	01312623          	sw	s3,12(sp)
4000147c:	00060913          	mv	s2,a2
40001480:	00050413          	mv	s0,a0
40001484:	00058993          	mv	s3,a1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
40001488:	c01ff0ef          	jal	ra,40001088 <chunk_size>
4000148c:	00090593          	mv	a1,s2
40001490:	00050493          	mv	s1,a0
40001494:	00040513          	mv	a0,s0
40001498:	bf1ff0ef          	jal	ra,40001088 <chunk_size>
4000149c:	00a484b3          	add	s1,s1,a0
	set_chunk_size(h, lc, newsz);
400014a0:	00048613          	mv	a2,s1
400014a4:	00098593          	mv	a1,s3
400014a8:	00040513          	mv	a0,s0
400014ac:	c49ff0ef          	jal	ra,400010f4 <set_chunk_size>
	return c + chunk_size(h, c);
400014b0:	00090593          	mv	a1,s2
400014b4:	00040513          	mv	a0,s0
400014b8:	bd1ff0ef          	jal	ra,40001088 <chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
400014bc:	00a905b3          	add	a1,s2,a0
400014c0:	00040513          	mv	a0,s0
}
400014c4:	01812403          	lw	s0,24(sp)
400014c8:	01c12083          	lw	ra,28(sp)
400014cc:	01012903          	lw	s2,16(sp)
400014d0:	00c12983          	lw	s3,12(sp)
400014d4:	00048693          	mv	a3,s1
400014d8:	01412483          	lw	s1,20(sp)
400014dc:	00000613          	li	a2,0
400014e0:	02010113          	addi	sp,sp,32
400014e4:	b71ff06f          	j	40001054 <chunk_set>

400014e8 <free_list_add>:
{
400014e8:	fe010113          	addi	sp,sp,-32
400014ec:	00812c23          	sw	s0,24(sp)
400014f0:	00912a23          	sw	s1,20(sp)
400014f4:	00112e23          	sw	ra,28(sp)
400014f8:	01212823          	sw	s2,16(sp)
400014fc:	01312623          	sw	s3,12(sp)
	return big_heap_chunks(h->end_chunk);
40001500:	00852903          	lw	s2,8(a0)
40001504:	00058493          	mv	s1,a1
40001508:	00050413          	mv	s0,a0
	return big_heap(h) && chunk_size(h, c) == 1U;
4000150c:	b7dff0ef          	jal	ra,40001088 <chunk_size>
40001510:	000087b7          	lui	a5,0x8
40001514:	00050593          	mv	a1,a0
40001518:	00f96663          	bltu	s2,a5,40001524 <free_list_add+0x3c>
4000151c:	00100793          	li	a5,1
40001520:	0cf50a63          	beq	a0,a5,400015f4 <free_list_add+0x10c>
		int bidx = bucket_idx(h, chunk_size(h, c));
40001524:	00090513          	mv	a0,s2
40001528:	c01ff0ef          	jal	ra,40001128 <bucket_idx.isra.0>
	if (b->next == 0U) {
4000152c:	00251793          	slli	a5,a0,0x2
40001530:	00f407b3          	add	a5,s0,a5
40001534:	0107a903          	lw	s2,16(a5) # 8010 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4010>
40001538:	04091e63          	bnez	s2,40001594 <free_list_add+0xac>
		h->avail_buckets |= BIT(bidx);
4000153c:	00c42703          	lw	a4,12(s0)
40001540:	00100693          	li	a3,1
40001544:	00a696b3          	sll	a3,a3,a0
40001548:	00d76733          	or	a4,a4,a3
4000154c:	00e42623          	sw	a4,12(s0)
	chunk_set(h, c, FREE_PREV, prev);
40001550:	00048693          	mv	a3,s1
40001554:	00200613          	li	a2,2
40001558:	00048593          	mv	a1,s1
		b->next = c;
4000155c:	0097a823          	sw	s1,16(a5)
40001560:	00040513          	mv	a0,s0
40001564:	af1ff0ef          	jal	ra,40001054 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
40001568:	00048693          	mv	a3,s1
4000156c:	00300613          	li	a2,3
40001570:	00048593          	mv	a1,s1
	chunk_set(h, c, FREE_PREV, prev);
40001574:	00040513          	mv	a0,s0
}
40001578:	01812403          	lw	s0,24(sp)
4000157c:	01c12083          	lw	ra,28(sp)
40001580:	01412483          	lw	s1,20(sp)
40001584:	01012903          	lw	s2,16(sp)
40001588:	00c12983          	lw	s3,12(sp)
4000158c:	02010113          	addi	sp,sp,32
40001590:	ac5ff06f          	j	40001054 <chunk_set>
	return chunk_field(h, c, FREE_PREV);
40001594:	00200613          	li	a2,2
40001598:	00090593          	mv	a1,s2
4000159c:	00040513          	mv	a0,s0
400015a0:	a81ff0ef          	jal	ra,40001020 <chunk_field>
	chunk_set(h, c, FREE_PREV, prev);
400015a4:	00050693          	mv	a3,a0
	return chunk_field(h, c, FREE_PREV);
400015a8:	00050993          	mv	s3,a0
	chunk_set(h, c, FREE_PREV, prev);
400015ac:	00200613          	li	a2,2
400015b0:	00048593          	mv	a1,s1
400015b4:	00040513          	mv	a0,s0
400015b8:	a9dff0ef          	jal	ra,40001054 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
400015bc:	00090693          	mv	a3,s2
400015c0:	00300613          	li	a2,3
400015c4:	00048593          	mv	a1,s1
400015c8:	00040513          	mv	a0,s0
400015cc:	a89ff0ef          	jal	ra,40001054 <chunk_set>
400015d0:	00048693          	mv	a3,s1
400015d4:	00300613          	li	a2,3
400015d8:	00098593          	mv	a1,s3
400015dc:	00040513          	mv	a0,s0
400015e0:	a75ff0ef          	jal	ra,40001054 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
400015e4:	00048693          	mv	a3,s1
400015e8:	00200613          	li	a2,2
400015ec:	00090593          	mv	a1,s2
400015f0:	f85ff06f          	j	40001574 <free_list_add+0x8c>
400015f4:	01c12083          	lw	ra,28(sp)
400015f8:	01812403          	lw	s0,24(sp)
400015fc:	01412483          	lw	s1,20(sp)
40001600:	01012903          	lw	s2,16(sp)
40001604:	00c12983          	lw	s3,12(sp)
40001608:	02010113          	addi	sp,sp,32
4000160c:	00008067          	ret

40001610 <free_chunk>:
{
40001610:	fe010113          	addi	sp,sp,-32
40001614:	00112e23          	sw	ra,28(sp)
40001618:	00812c23          	sw	s0,24(sp)
4000161c:	00912a23          	sw	s1,20(sp)
40001620:	00058413          	mv	s0,a1
40001624:	00050493          	mv	s1,a0
	return c + chunk_size(h, c);
40001628:	a61ff0ef          	jal	ra,40001088 <chunk_size>
4000162c:	00a405b3          	add	a1,s0,a0
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
40001630:	00100613          	li	a2,1
40001634:	00048513          	mv	a0,s1
40001638:	00b12623          	sw	a1,12(sp)
4000163c:	9e5ff0ef          	jal	ra,40001020 <chunk_field>
	if (!chunk_used(h, right_chunk(h, c))) {
40001640:	00157513          	andi	a0,a0,1
40001644:	00c12583          	lw	a1,12(sp)
40001648:	02051463          	bnez	a0,40001670 <free_chunk+0x60>
		free_list_remove(h, right_chunk(h, c));
4000164c:	00048513          	mv	a0,s1
40001650:	c01ff0ef          	jal	ra,40001250 <free_list_remove>
	return c + chunk_size(h, c);
40001654:	00040593          	mv	a1,s0
40001658:	00048513          	mv	a0,s1
4000165c:	a2dff0ef          	jal	ra,40001088 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
40001660:	00a40633          	add	a2,s0,a0
40001664:	00040593          	mv	a1,s0
40001668:	00048513          	mv	a0,s1
4000166c:	df9ff0ef          	jal	ra,40001464 <merge_chunks>
	return c - chunk_field(h, c, LEFT_SIZE);
40001670:	00000613          	li	a2,0
40001674:	00040593          	mv	a1,s0
40001678:	00048513          	mv	a0,s1
4000167c:	9a5ff0ef          	jal	ra,40001020 <chunk_field>
40001680:	40a405b3          	sub	a1,s0,a0
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
40001684:	00100613          	li	a2,1
40001688:	00048513          	mv	a0,s1
4000168c:	00b12623          	sw	a1,12(sp)
40001690:	991ff0ef          	jal	ra,40001020 <chunk_field>
	if (!chunk_used(h, left_chunk(h, c))) {
40001694:	00157513          	andi	a0,a0,1
40001698:	00c12583          	lw	a1,12(sp)
4000169c:	04051063          	bnez	a0,400016dc <free_chunk+0xcc>
		free_list_remove(h, left_chunk(h, c));
400016a0:	00048513          	mv	a0,s1
400016a4:	badff0ef          	jal	ra,40001250 <free_list_remove>
	return c - chunk_field(h, c, LEFT_SIZE);
400016a8:	00040593          	mv	a1,s0
400016ac:	00000613          	li	a2,0
400016b0:	00048513          	mv	a0,s1
400016b4:	96dff0ef          	jal	ra,40001020 <chunk_field>
		merge_chunks(h, left_chunk(h, c), c);
400016b8:	40a405b3          	sub	a1,s0,a0
400016bc:	00040613          	mv	a2,s0
400016c0:	00048513          	mv	a0,s1
400016c4:	da1ff0ef          	jal	ra,40001464 <merge_chunks>
400016c8:	00040593          	mv	a1,s0
400016cc:	00000613          	li	a2,0
400016d0:	00048513          	mv	a0,s1
400016d4:	94dff0ef          	jal	ra,40001020 <chunk_field>
400016d8:	40a40433          	sub	s0,s0,a0
	free_list_add(h, c);
400016dc:	00040593          	mv	a1,s0
}
400016e0:	01812403          	lw	s0,24(sp)
400016e4:	01c12083          	lw	ra,28(sp)
	free_list_add(h, c);
400016e8:	00048513          	mv	a0,s1
}
400016ec:	01412483          	lw	s1,20(sp)
400016f0:	02010113          	addi	sp,sp,32
	free_list_add(h, c);
400016f4:	df5ff06f          	j	400014e8 <free_list_add>

400016f8 <sys_heap_free>:
	if (mem == NULL) {
400016f8:	04058463          	beqz	a1,40001740 <sys_heap_free+0x48>
{
400016fc:	fe010113          	addi	sp,sp,-32
40001700:	00112e23          	sw	ra,28(sp)
40001704:	00812c23          	sw	s0,24(sp)
40001708:	00052403          	lw	s0,0(a0)
	chunkid_t c = mem_to_chunkid(h, mem);
4000170c:	00040513          	mv	a0,s0
40001710:	9f1ff0ef          	jal	ra,40001100 <mem_to_chunkid>
40001714:	00050593          	mv	a1,a0
	set_chunk_used(h, c, false);
40001718:	00a12623          	sw	a0,12(sp)
4000171c:	00000613          	li	a2,0
40001720:	00040513          	mv	a0,s0
40001724:	985ff0ef          	jal	ra,400010a8 <set_chunk_used>
	free_chunk(h, c);
40001728:	00040513          	mv	a0,s0
}
4000172c:	01812403          	lw	s0,24(sp)
	free_chunk(h, c);
40001730:	00c12583          	lw	a1,12(sp)
}
40001734:	01c12083          	lw	ra,28(sp)
40001738:	02010113          	addi	sp,sp,32
	free_chunk(h, c);
4000173c:	ed5ff06f          	j	40001610 <free_chunk>
40001740:	00008067          	ret

40001744 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
40001744:	ff010113          	addi	sp,sp,-16
40001748:	00112623          	sw	ra,12(sp)
4000174c:	00812423          	sw	s0,8(sp)
40001750:	00912223          	sw	s1,4(sp)
40001754:	01212023          	sw	s2,0(sp)
	struct z_heap *h = heap->heap;
40001758:	00052903          	lw	s2,0(a0)
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
4000175c:	02059063          	bnez	a1,4000177c <sys_heap_alloc+0x38>
		return NULL;
40001760:	00000513          	li	a0,0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
40001764:	00c12083          	lw	ra,12(sp)
40001768:	00812403          	lw	s0,8(sp)
4000176c:	00412483          	lw	s1,4(sp)
40001770:	00012903          	lw	s2,0(sp)
40001774:	01010113          	addi	sp,sp,16
40001778:	00008067          	ret
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
4000177c:	00892703          	lw	a4,8(s2)
40001780:	0035d793          	srli	a5,a1,0x3
	if (bytes == 0U || size_too_big(h, bytes)) {
40001784:	fce7fee3          	bgeu	a5,a4,40001760 <sys_heap_alloc+0x1c>
	return big_heap(h) ? 8 : 4;
40001788:	000086b7          	lui	a3,0x8
4000178c:	00400793          	li	a5,4
40001790:	00d76463          	bltu	a4,a3,40001798 <sys_heap_alloc+0x54>
40001794:	00800793          	li	a5,8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
40001798:	00758413          	addi	s0,a1,7
4000179c:	00f40433          	add	s0,s0,a5
400017a0:	00345413          	srli	s0,s0,0x3
	chunkid_t c = alloc_chunk(h, chunk_sz);
400017a4:	00040593          	mv	a1,s0
400017a8:	00090513          	mv	a0,s2
400017ac:	b21ff0ef          	jal	ra,400012cc <alloc_chunk>
400017b0:	00050493          	mv	s1,a0
	if (c == 0U) {
400017b4:	fa0506e3          	beqz	a0,40001760 <sys_heap_alloc+0x1c>
	if (chunk_size(h, c) > chunk_sz) {
400017b8:	00050593          	mv	a1,a0
400017bc:	00090513          	mv	a0,s2
400017c0:	8c9ff0ef          	jal	ra,40001088 <chunk_size>
400017c4:	02a47263          	bgeu	s0,a0,400017e8 <sys_heap_alloc+0xa4>
		split_chunks(h, c, c + chunk_sz);
400017c8:	00848433          	add	s0,s1,s0
400017cc:	00048593          	mv	a1,s1
400017d0:	00090513          	mv	a0,s2
400017d4:	00040613          	mv	a2,s0
400017d8:	be9ff0ef          	jal	ra,400013c0 <split_chunks>
		free_list_add(h, c + chunk_sz);
400017dc:	00040593          	mv	a1,s0
400017e0:	00090513          	mv	a0,s2
400017e4:	d05ff0ef          	jal	ra,400014e8 <free_list_add>
	set_chunk_used(h, c, true);
400017e8:	00048593          	mv	a1,s1
400017ec:	00100613          	li	a2,1
400017f0:	00090513          	mv	a0,s2
400017f4:	8b5ff0ef          	jal	ra,400010a8 <set_chunk_used>
	return big_heap(h) ? 8 : 4;
400017f8:	00892683          	lw	a3,8(s2)
400017fc:	00008737          	lui	a4,0x8
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
40001800:	00349493          	slli	s1,s1,0x3
40001804:	00400793          	li	a5,4
40001808:	00e6e463          	bltu	a3,a4,40001810 <sys_heap_alloc+0xcc>
4000180c:	00800793          	li	a5,8
40001810:	00f484b3          	add	s1,s1,a5
40001814:	00990533          	add	a0,s2,s1
	return mem;
40001818:	f4dff06f          	j	40001764 <sys_heap_alloc+0x20>

4000181c <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
4000181c:	fe010113          	addi	sp,sp,-32
40001820:	00812c23          	sw	s0,24(sp)
40001824:	01212823          	sw	s2,16(sp)
40001828:	01512223          	sw	s5,4(sp)
4000182c:	00112e23          	sw	ra,28(sp)
40001830:	00912a23          	sw	s1,20(sp)
40001834:	01312623          	sw	s3,12(sp)
40001838:	01412423          	sw	s4,8(sp)
	struct z_heap *h = heap->heap;
4000183c:	00052983          	lw	s3,0(a0)
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
	if (align != rew) {
40001840:	fff58a93          	addi	s5,a1,-1
40001844:	00bafab3          	and	s5,s5,a1
	return big_heap_chunks(h->end_chunk);
40001848:	0089a683          	lw	a3,8(s3)
{
4000184c:	00058913          	mv	s2,a1
40001850:	00060413          	mv	s0,a2
	if (align != rew) {
40001854:	060a8063          	beqz	s5,400018b4 <sys_heap_aligned_alloc+0x98>
	return big_heap(h) ? 8 : 4;
40001858:	000087b7          	lui	a5,0x8
4000185c:	00400613          	li	a2,4
40001860:	00f6e463          	bltu	a3,a5,40001868 <sys_heap_aligned_alloc+0x4c>
40001864:	00800613          	li	a2,8
	rew = align & -align;
40001868:	41200733          	neg	a4,s2
4000186c:	01277733          	and	a4,a4,s2
40001870:	00070793          	mv	a5,a4
40001874:	00e67463          	bgeu	a2,a4,4000187c <sys_heap_aligned_alloc+0x60>
40001878:	00060793          	mv	a5,a2
4000187c:	000a8913          	mv	s2,s5
40001880:	00070a93          	mv	s5,a4
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
40001884:	06041663          	bnez	s0,400018f0 <sys_heap_aligned_alloc+0xd4>
		return NULL;
40001888:	00000493          	li	s1,0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
4000188c:	01c12083          	lw	ra,28(sp)
40001890:	01812403          	lw	s0,24(sp)
40001894:	01012903          	lw	s2,16(sp)
40001898:	00c12983          	lw	s3,12(sp)
4000189c:	00812a03          	lw	s4,8(sp)
400018a0:	00412a83          	lw	s5,4(sp)
400018a4:	00048513          	mv	a0,s1
400018a8:	01412483          	lw	s1,20(sp)
400018ac:	02010113          	addi	sp,sp,32
400018b0:	00008067          	ret
400018b4:	00008737          	lui	a4,0x8
400018b8:	00400793          	li	a5,4
400018bc:	00e6e463          	bltu	a3,a4,400018c4 <sys_heap_aligned_alloc+0xa8>
400018c0:	00800793          	li	a5,8
		if (align <= chunk_header_bytes(h)) {
400018c4:	fd27e0e3          	bltu	a5,s2,40001884 <sys_heap_aligned_alloc+0x68>
			return sys_heap_alloc(heap, bytes);
400018c8:	00040593          	mv	a1,s0
}
400018cc:	01812403          	lw	s0,24(sp)
400018d0:	01c12083          	lw	ra,28(sp)
400018d4:	01412483          	lw	s1,20(sp)
400018d8:	01012903          	lw	s2,16(sp)
400018dc:	00c12983          	lw	s3,12(sp)
400018e0:	00812a03          	lw	s4,8(sp)
400018e4:	00412a83          	lw	s5,4(sp)
400018e8:	02010113          	addi	sp,sp,32
			return sys_heap_alloc(heap, bytes);
400018ec:	e59ff06f          	j	40001744 <sys_heap_alloc>
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
400018f0:	00345713          	srli	a4,s0,0x3
	if (bytes == 0 || size_too_big(h, bytes)) {
400018f4:	f8d77ae3          	bgeu	a4,a3,40001888 <sys_heap_aligned_alloc+0x6c>
	chunksz_t padded_sz = bytes_to_chunksz(h, bytes + align - gap);
400018f8:	00740593          	addi	a1,s0,7
	return big_heap(h) ? 8 : 4;
400018fc:	00008637          	lui	a2,0x8
40001900:	012585b3          	add	a1,a1,s2
40001904:	00400713          	li	a4,4
40001908:	00c6e463          	bltu	a3,a2,40001910 <sys_heap_aligned_alloc+0xf4>
4000190c:	00800713          	li	a4,8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
40001910:	40f585b3          	sub	a1,a1,a5
40001914:	00e585b3          	add	a1,a1,a4
	chunkid_t c0 = alloc_chunk(h, padded_sz);
40001918:	0035d593          	srli	a1,a1,0x3
4000191c:	00098513          	mv	a0,s3
40001920:	9adff0ef          	jal	ra,400012cc <alloc_chunk>
40001924:	00050a13          	mv	s4,a0
	if (c0 == 0) {
40001928:	f60500e3          	beqz	a0,40001888 <sys_heap_aligned_alloc+0x6c>
	return big_heap(h) ? 8 : 4;
4000192c:	0089a683          	lw	a3,8(s3)
40001930:	00008737          	lui	a4,0x8
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
40001934:	00351493          	slli	s1,a0,0x3
40001938:	00400793          	li	a5,4
4000193c:	00e6e463          	bltu	a3,a4,40001944 <sys_heap_aligned_alloc+0x128>
40001940:	00800793          	li	a5,8
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
40001944:	009a84b3          	add	s1,s5,s1
40001948:	00f484b3          	add	s1,s1,a5
4000194c:	009984b3          	add	s1,s3,s1
40001950:	fff90793          	addi	a5,s2,-1
40001954:	00f484b3          	add	s1,s1,a5
40001958:	41200933          	neg	s2,s2
4000195c:	0124f4b3          	and	s1,s1,s2
40001960:	415484b3          	sub	s1,s1,s5
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
40001964:	00848433          	add	s0,s1,s0
40001968:	00740413          	addi	s0,s0,7
	chunkid_t c = mem_to_chunkid(h, mem);
4000196c:	00048593          	mv	a1,s1
40001970:	00098513          	mv	a0,s3
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
40001974:	ff847413          	andi	s0,s0,-8
	chunkid_t c = mem_to_chunkid(h, mem);
40001978:	f88ff0ef          	jal	ra,40001100 <mem_to_chunkid>
	chunkid_t c_end = end - chunk_buf(h);
4000197c:	41340433          	sub	s0,s0,s3
	chunkid_t c = mem_to_chunkid(h, mem);
40001980:	00050913          	mv	s2,a0
	chunkid_t c_end = end - chunk_buf(h);
40001984:	40345413          	srai	s0,s0,0x3
	if (c > c0) {
40001988:	02aa7063          	bgeu	s4,a0,400019a8 <sys_heap_aligned_alloc+0x18c>
		split_chunks(h, c0, c);
4000198c:	00050613          	mv	a2,a0
40001990:	000a0593          	mv	a1,s4
40001994:	00098513          	mv	a0,s3
40001998:	a29ff0ef          	jal	ra,400013c0 <split_chunks>
		free_list_add(h, c0);
4000199c:	000a0593          	mv	a1,s4
400019a0:	00098513          	mv	a0,s3
400019a4:	b45ff0ef          	jal	ra,400014e8 <free_list_add>
	return c + chunk_size(h, c);
400019a8:	00090593          	mv	a1,s2
400019ac:	00098513          	mv	a0,s3
400019b0:	ed8ff0ef          	jal	ra,40001088 <chunk_size>
400019b4:	00a90533          	add	a0,s2,a0
	if (right_chunk(h, c) > c_end) {
400019b8:	02a47063          	bgeu	s0,a0,400019d8 <sys_heap_aligned_alloc+0x1bc>
		split_chunks(h, c, c_end);
400019bc:	00090593          	mv	a1,s2
400019c0:	00098513          	mv	a0,s3
400019c4:	00040613          	mv	a2,s0
400019c8:	9f9ff0ef          	jal	ra,400013c0 <split_chunks>
		free_list_add(h, c_end);
400019cc:	00040593          	mv	a1,s0
400019d0:	00098513          	mv	a0,s3
400019d4:	b15ff0ef          	jal	ra,400014e8 <free_list_add>
	set_chunk_used(h, c, true);
400019d8:	00100613          	li	a2,1
400019dc:	00090593          	mv	a1,s2
400019e0:	00098513          	mv	a0,s3
400019e4:	ec4ff0ef          	jal	ra,400010a8 <set_chunk_used>
	return mem;
400019e8:	ea5ff06f          	j	4000188c <sys_heap_aligned_alloc+0x70>

400019ec <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
400019ec:	fe010113          	addi	sp,sp,-32
400019f0:	00112e23          	sw	ra,28(sp)
400019f4:	00812c23          	sw	s0,24(sp)
400019f8:	00912a23          	sw	s1,20(sp)
400019fc:	01212823          	sw	s2,16(sp)
40001a00:	01312623          	sw	s3,12(sp)
	return big_heap_bytes(size) ? 8 : 4;
40001a04:	00040737          	lui	a4,0x40
40001a08:	00400793          	li	a5,4
40001a0c:	00e66463          	bltu	a2,a4,40001a14 <sys_heap_init+0x28>
40001a10:	00800793          	li	a5,8
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
40001a14:	40f60633          	sub	a2,a2,a5

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
40001a18:	00c58433          	add	s0,a1,a2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
40001a1c:	00758493          	addi	s1,a1,7
40001a20:	ff84f493          	andi	s1,s1,-8
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
40001a24:	ff847413          	andi	s0,s0,-8
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
40001a28:	40940433          	sub	s0,s0,s1

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
40001a2c:	00952023          	sw	s1,0(a0)
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
40001a30:	00345413          	srli	s0,s0,0x3
	h->end_chunk = heap_sz;
40001a34:	0084a423          	sw	s0,8(s1)
	h->avail_buckets = 0;
40001a38:	0004a623          	sw	zero,12(s1)
	h->free_bytes = 0;
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
40001a3c:	00040593          	mv	a1,s0
40001a40:	00040513          	mv	a0,s0
40001a44:	ee4ff0ef          	jal	ra,40001128 <bucket_idx.isra.0>
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
40001a48:	00251913          	slli	s2,a0,0x2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
40001a4c:	01b90913          	addi	s2,s2,27
40001a50:	00395913          	srli	s2,s2,0x3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
40001a54:	01048713          	addi	a4,s1,16
40001a58:	00000793          	li	a5,0
40001a5c:	0af55c63          	bge	a0,a5,40001b14 <sys_heap_init+0x128>
		h->buckets[i].next = 0;
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
40001a60:	00090613          	mv	a2,s2
40001a64:	00048513          	mv	a0,s1
40001a68:	00000593          	li	a1,0
40001a6c:	e88ff0ef          	jal	ra,400010f4 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
40001a70:	00000693          	li	a3,0
40001a74:	00048513          	mv	a0,s1
40001a78:	00000613          	li	a2,0
40001a7c:	00000593          	li	a1,0
40001a80:	dd4ff0ef          	jal	ra,40001054 <chunk_set>
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);
40001a84:	00048513          	mv	a0,s1
40001a88:	00100613          	li	a2,1
40001a8c:	00000593          	li	a1,0
40001a90:	e18ff0ef          	jal	ra,400010a8 <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
40001a94:	412409b3          	sub	s3,s0,s2
40001a98:	00098613          	mv	a2,s3
40001a9c:	00090593          	mv	a1,s2
40001aa0:	00048513          	mv	a0,s1
40001aa4:	e50ff0ef          	jal	ra,400010f4 <set_chunk_size>
40001aa8:	00090693          	mv	a3,s2
40001aac:	00090593          	mv	a1,s2
40001ab0:	00048513          	mv	a0,s1
40001ab4:	00000613          	li	a2,0
40001ab8:	d9cff0ef          	jal	ra,40001054 <chunk_set>
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
40001abc:	00040593          	mv	a1,s0
40001ac0:	00048513          	mv	a0,s1
40001ac4:	00000613          	li	a2,0
40001ac8:	e2cff0ef          	jal	ra,400010f4 <set_chunk_size>
40001acc:	00098693          	mv	a3,s3
40001ad0:	00040593          	mv	a1,s0
40001ad4:	00048513          	mv	a0,s1
40001ad8:	00000613          	li	a2,0
40001adc:	d78ff0ef          	jal	ra,40001054 <chunk_set>
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
40001ae0:	00040593          	mv	a1,s0
40001ae4:	00048513          	mv	a0,s1
40001ae8:	00100613          	li	a2,1
40001aec:	dbcff0ef          	jal	ra,400010a8 <set_chunk_used>

	free_list_add(h, chunk0_size);
}
40001af0:	01812403          	lw	s0,24(sp)
40001af4:	01c12083          	lw	ra,28(sp)
40001af8:	00c12983          	lw	s3,12(sp)
	free_list_add(h, chunk0_size);
40001afc:	00090593          	mv	a1,s2
40001b00:	00048513          	mv	a0,s1
}
40001b04:	01012903          	lw	s2,16(sp)
40001b08:	01412483          	lw	s1,20(sp)
40001b0c:	02010113          	addi	sp,sp,32
	free_list_add(h, chunk0_size);
40001b10:	9d9ff06f          	j	400014e8 <free_list_add>
		h->buckets[i].next = 0;
40001b14:	00072023          	sw	zero,0(a4) # 40000 <__rom_region_size+0xf624>
	for (int i = 0; i < nb_buckets; i++) {
40001b18:	00178793          	addi	a5,a5,1 # 8001 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4001>
40001b1c:	00470713          	addi	a4,a4,4
40001b20:	f3dff06f          	j	40001a5c <sys_heap_init+0x70>

40001b24 <crc16_reflect>:

	return crc;
}

uint16_t crc16_reflect(uint16_t poly, uint16_t seed, const uint8_t *src, size_t len)
{
40001b24:	00050713          	mv	a4,a0
	uint16_t crc = seed;
	size_t i, j;

	for (i = 0; i < len; i++) {
40001b28:	00000793          	li	a5,0
	uint16_t crc = seed;
40001b2c:	00058513          	mv	a0,a1
	for (i = 0; i < len; i++) {
40001b30:	00d79463          	bne	a5,a3,40001b38 <crc16_reflect+0x14>
		}
	}


	return crc;
}
40001b34:	00008067          	ret
		crc ^= (uint16_t)src[i];
40001b38:	00f605b3          	add	a1,a2,a5
40001b3c:	0005c583          	lbu	a1,0(a1)
40001b40:	00800813          	li	a6,8
40001b44:	00b54533          	xor	a0,a0,a1
			if (crc & 0x0001UL) {
40001b48:	00157593          	andi	a1,a0,1
				crc = (crc >> 1U) ^ poly;
40001b4c:	00155513          	srli	a0,a0,0x1
			if (crc & 0x0001UL) {
40001b50:	00058863          	beqz	a1,40001b60 <crc16_reflect+0x3c>
				crc = (crc >> 1U) ^ poly;
40001b54:	00a745b3          	xor	a1,a4,a0
40001b58:	01059513          	slli	a0,a1,0x10
40001b5c:	01055513          	srli	a0,a0,0x10
		for (j = 0; j < 8; j++) {
40001b60:	fff80813          	addi	a6,a6,-1 # ffff <__kernel_ram_size+0x3d6b>
40001b64:	fe0812e3          	bnez	a6,40001b48 <crc16_reflect+0x24>
	for (i = 0; i < len; i++) {
40001b68:	00178793          	addi	a5,a5,1
40001b6c:	fc5ff06f          	j	40001b30 <crc16_reflect+0xc>

40001b70 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
40001b70:	fd010113          	addi	sp,sp,-48
40001b74:	02812423          	sw	s0,40(sp)
40001b78:	02912223          	sw	s1,36(sp)
40001b7c:	03212023          	sw	s2,32(sp)
40001b80:	01312e23          	sw	s3,28(sp)
40001b84:	01712623          	sw	s7,12(sp)
40001b88:	01812423          	sw	s8,8(sp)
40001b8c:	01912223          	sw	s9,4(sp)
40001b90:	02112623          	sw	ra,44(sp)
40001b94:	01412c23          	sw	s4,24(sp)
40001b98:	01512a23          	sw	s5,20(sp)
40001b9c:	01612823          	sw	s6,16(sp)
	bool upcase = isupper((int)conv->specifier) != 0;
40001ba0:	00364783          	lbu	a5,3(a2) # 8003 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4003>
{
40001ba4:	00070b93          	mv	s7,a4
	switch (specifier) {
40001ba8:	06f00713          	li	a4,111
{
40001bac:	00050413          	mv	s0,a0
40001bb0:	00058493          	mv	s1,a1
40001bb4:	00060c93          	mv	s9,a2
40001bb8:	00068913          	mv	s2,a3
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
40001bbc:	fbf78993          	addi	s3,a5,-65
	switch (specifier) {
40001bc0:	00800c13          	li	s8,8
40001bc4:	00e78c63          	beq	a5,a4,40001bdc <encode_uint+0x6c>
40001bc8:	0cf76263          	bltu	a4,a5,40001c8c <encode_uint+0x11c>
40001bcc:	05800713          	li	a4,88
		return 16;
40001bd0:	01000c13          	li	s8,16
	switch (specifier) {
40001bd4:	00e78463          	beq	a5,a4,40001bdc <encode_uint+0x6c>
		return 10;
40001bd8:	00a00c13          	li	s8,10
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
40001bdc:	00000a93          	li	s5,0

		*--bp = (lsv <= 9) ? ('0' + lsv)
40001be0:	00900a13          	li	s4,9
40001be4:	01900b13          	li	s6,25
		unsigned int lsv = (unsigned int)(value % radix);
40001be8:	000c0613          	mv	a2,s8
40001bec:	00000693          	li	a3,0
40001bf0:	00040513          	mv	a0,s0
40001bf4:	00048593          	mv	a1,s1
40001bf8:	af1fe0ef          	jal	ra,400006e8 <__umoddi3>
		*--bp = (lsv <= 9) ? ('0' + lsv)
40001bfc:	0ff57793          	zext.b	a5,a0
40001c00:	0aaa6263          	bltu	s4,a0,40001ca4 <encode_uint+0x134>
40001c04:	03078793          	addi	a5,a5,48
40001c08:	0ff7f793          	zext.b	a5,a5
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
40001c0c:	000c0613          	mv	a2,s8
40001c10:	00000693          	li	a3,0
40001c14:	00040513          	mv	a0,s0
40001c18:	00048593          	mv	a1,s1
		*--bp = (lsv <= 9) ? ('0' + lsv)
40001c1c:	fefb8fa3          	sb	a5,-1(s7)
40001c20:	fffb8b93          	addi	s7,s7,-1
		value /= radix;
40001c24:	e94fe0ef          	jal	ra,400002b8 <__udivdi3>
	} while ((value != 0) && (bps < bp));
40001c28:	009a9463          	bne	s5,s1,40001c30 <encode_uint+0xc0>
40001c2c:	01846463          	bltu	s0,s8,40001c34 <encode_uint+0xc4>
40001c30:	07796463          	bltu	s2,s7,40001c98 <encode_uint+0x128>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
40001c34:	000cd783          	lhu	a5,0(s9)
40001c38:	0207f793          	andi	a5,a5,32
40001c3c:	00078c63          	beqz	a5,40001c54 <encode_uint+0xe4>
		if (radix == 8) {
40001c40:	00800793          	li	a5,8
40001c44:	06fc1a63          	bne	s8,a5,40001cb8 <encode_uint+0x148>
			conv->altform_0 = true;
40001c48:	002cc783          	lbu	a5,2(s9)
40001c4c:	0087e793          	ori	a5,a5,8
		} else if (radix == 16) {
			conv->altform_0c = true;
40001c50:	00fc8123          	sb	a5,2(s9)
			;
		}
	}

	return bp;
}
40001c54:	02c12083          	lw	ra,44(sp)
40001c58:	02812403          	lw	s0,40(sp)
40001c5c:	02412483          	lw	s1,36(sp)
40001c60:	02012903          	lw	s2,32(sp)
40001c64:	01c12983          	lw	s3,28(sp)
40001c68:	01812a03          	lw	s4,24(sp)
40001c6c:	01412a83          	lw	s5,20(sp)
40001c70:	01012b03          	lw	s6,16(sp)
40001c74:	00812c03          	lw	s8,8(sp)
40001c78:	00412c83          	lw	s9,4(sp)
40001c7c:	000b8513          	mv	a0,s7
40001c80:	00c12b83          	lw	s7,12(sp)
40001c84:	03010113          	addi	sp,sp,48
40001c88:	00008067          	ret
	switch (specifier) {
40001c8c:	0f77f793          	andi	a5,a5,247
40001c90:	07000713          	li	a4,112
40001c94:	f3dff06f          	j	40001bd0 <encode_uint+0x60>
		value /= radix;
40001c98:	00050413          	mv	s0,a0
40001c9c:	00058493          	mv	s1,a1
40001ca0:	f49ff06f          	j	40001be8 <encode_uint+0x78>
		*--bp = (lsv <= 9) ? ('0' + lsv)
40001ca4:	013b6663          	bltu	s6,s3,40001cb0 <encode_uint+0x140>
40001ca8:	03778793          	addi	a5,a5,55
40001cac:	f5dff06f          	j	40001c08 <encode_uint+0x98>
40001cb0:	05778793          	addi	a5,a5,87
40001cb4:	f55ff06f          	j	40001c08 <encode_uint+0x98>
		} else if (radix == 16) {
40001cb8:	01000793          	li	a5,16
40001cbc:	f8fc1ce3          	bne	s8,a5,40001c54 <encode_uint+0xe4>
			conv->altform_0c = true;
40001cc0:	002cc783          	lbu	a5,2(s9)
40001cc4:	0107e793          	ori	a5,a5,16
40001cc8:	f89ff06f          	j	40001c50 <encode_uint+0xe0>

40001ccc <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
40001ccc:	fe010113          	addi	sp,sp,-32
40001cd0:	00812c23          	sw	s0,24(sp)
40001cd4:	00912a23          	sw	s1,20(sp)
40001cd8:	01212823          	sw	s2,16(sp)
40001cdc:	01312623          	sw	s3,12(sp)
40001ce0:	01412423          	sw	s4,8(sp)
40001ce4:	00112e23          	sw	ra,28(sp)
40001ce8:	00050993          	mv	s3,a0
40001cec:	00058a13          	mv	s4,a1
40001cf0:	00060493          	mv	s1,a2
40001cf4:	00068913          	mv	s2,a3
	size_t count = 0;

	while ((sp < ep) || ((ep == NULL) && *sp)) {
40001cf8:	00060413          	mv	s0,a2
40001cfc:	01246c63          	bltu	s0,s2,40001d14 <outs+0x48>
40001d00:	00090663          	beqz	s2,40001d0c <outs+0x40>
			return rc;
		}
		++count;
	}

	return (int)count;
40001d04:	40940533          	sub	a0,s0,s1
40001d08:	0200006f          	j	40001d28 <outs+0x5c>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
40001d0c:	00044783          	lbu	a5,0(s0)
40001d10:	fe078ae3          	beqz	a5,40001d04 <outs+0x38>
		int rc = out((int)*sp++, ctx);
40001d14:	00044503          	lbu	a0,0(s0)
40001d18:	000a0593          	mv	a1,s4
40001d1c:	00140413          	addi	s0,s0,1
40001d20:	000980e7          	jalr	s3
		if (rc < 0) {
40001d24:	fc055ce3          	bgez	a0,40001cfc <outs+0x30>
}
40001d28:	01c12083          	lw	ra,28(sp)
40001d2c:	01812403          	lw	s0,24(sp)
40001d30:	01412483          	lw	s1,20(sp)
40001d34:	01012903          	lw	s2,16(sp)
40001d38:	00c12983          	lw	s3,12(sp)
40001d3c:	00812a03          	lw	s4,8(sp)
40001d40:	02010113          	addi	sp,sp,32
40001d44:	00008067          	ret

40001d48 <z_cbvprintf_impl>:

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
40001d48:	f7010113          	addi	sp,sp,-144
40001d4c:	08812423          	sw	s0,136(sp)
40001d50:	08912223          	sw	s1,132(sp)
40001d54:	07412c23          	sw	s4,120(sp)
40001d58:	07912223          	sw	s9,100(sp)
40001d5c:	07a12023          	sw	s10,96(sp)
40001d60:	08112623          	sw	ra,140(sp)
40001d64:	09212023          	sw	s2,128(sp)
40001d68:	07312e23          	sw	s3,124(sp)
40001d6c:	07512a23          	sw	s5,116(sp)
40001d70:	07612823          	sw	s6,112(sp)
40001d74:	07712623          	sw	s7,108(sp)
40001d78:	07812423          	sw	s8,104(sp)
40001d7c:	05b12e23          	sw	s11,92(sp)
40001d80:	00050493          	mv	s1,a0
40001d84:	00b12423          	sw	a1,8(sp)
40001d88:	00060413          	mv	s0,a2
40001d8c:	00068c93          	mv	s9,a3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
40001d90:	00000d13          	li	s10,0
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
		if (*fp != '%') {
40001d94:	02500a13          	li	s4,37
	while (*fp != 0) {
40001d98:	00044503          	lbu	a0,0(s0)
40001d9c:	00051663          	bnez	a0,40001da8 <z_cbvprintf_impl+0x60>
			OUTC(' ');
			--width;
		}
	}

	return count;
40001da0:	000d0513          	mv	a0,s10
40001da4:	2890006f          	j	4000282c <z_cbvprintf_impl+0xae4>
			OUTC(*fp++);
40001da8:	00140993          	addi	s3,s0,1
		if (*fp != '%') {
40001dac:	01450c63          	beq	a0,s4,40001dc4 <z_cbvprintf_impl+0x7c>
			OUTC(*fp++);
40001db0:	00812583          	lw	a1,8(sp)
			OUTC('%');
40001db4:	000480e7          	jalr	s1
40001db8:	26054ae3          	bltz	a0,4000282c <z_cbvprintf_impl+0xae4>
40001dbc:	001d0d13          	addi	s10,s10,1
		if (bps == NULL) {
40001dc0:	6cc0006f          	j	4000248c <z_cbvprintf_impl+0x744>
		} state = {
40001dc4:	02000613          	li	a2,32
40001dc8:	00000593          	li	a1,0
40001dcc:	03010513          	addi	a0,sp,48
40001dd0:	2a0070ef          	jal	ra,40009070 <memset>
	if (*sp == '%') {
40001dd4:	00144783          	lbu	a5,1(s0)
40001dd8:	05479c63          	bne	a5,s4,40001e30 <z_cbvprintf_impl+0xe8>
		conv->specifier = *sp++;
40001ddc:	00240993          	addi	s3,s0,2
40001de0:	054101a3          	sb	s4,67(sp)
		if (conv->width_star) {
40001de4:	04015783          	lhu	a5,64(sp)
40001de8:	1007f713          	andi	a4,a5,256
40001dec:	50070c63          	beqz	a4,40002304 <z_cbvprintf_impl+0x5bc>
			width = va_arg(ap, int);
40001df0:	000caa83          	lw	s5,0(s9)
40001df4:	004c8713          	addi	a4,s9,4
			if (width < 0) {
40001df8:	000ad863          	bgez	s5,40001e08 <z_cbvprintf_impl+0xc0>
				conv->flag_dash = true;
40001dfc:	0047e793          	ori	a5,a5,4
40001e00:	04f11023          	sh	a5,64(sp)
				width = -width;
40001e04:	41500ab3          	neg	s5,s5
		if (conv->prec_star) {
40001e08:	04015783          	lhu	a5,64(sp)
40001e0c:	4007f693          	andi	a3,a5,1024
40001e10:	50068a63          	beqz	a3,40002324 <z_cbvprintf_impl+0x5dc>
			int arg = va_arg(ap, int);
40001e14:	00072b83          	lw	s7,0(a4)
40001e18:	00470c93          	addi	s9,a4,4
			if (arg < 0) {
40001e1c:	500bdc63          	bgez	s7,40002334 <z_cbvprintf_impl+0x5ec>
				conv->prec_present = false;
40001e20:	dff7f793          	andi	a5,a5,-513
40001e24:	04f11023          	sh	a5,64(sp)
		int precision = -1;
40001e28:	fff00b93          	li	s7,-1
40001e2c:	5080006f          	j	40002334 <z_cbvprintf_impl+0x5ec>
40001e30:	00000713          	li	a4,0
40001e34:	00000513          	li	a0,0
40001e38:	00000693          	li	a3,0
40001e3c:	00000593          	li	a1,0
40001e40:	00000613          	li	a2,0
		switch (*sp) {
40001e44:	02b00813          	li	a6,43
40001e48:	02d00893          	li	a7,45
40001e4c:	03000313          	li	t1,48
40001e50:	02000e13          	li	t3,32
40001e54:	02300e93          	li	t4,35
40001e58:	0009c783          	lbu	a5,0(s3)
40001e5c:	13078a63          	beq	a5,a6,40001f90 <z_cbvprintf_impl+0x248>
40001e60:	12f86063          	bltu	a6,a5,40001f80 <z_cbvprintf_impl+0x238>
40001e64:	13c78c63          	beq	a5,t3,40001f9c <z_cbvprintf_impl+0x254>
40001e68:	13d78e63          	beq	a5,t4,40001fa4 <z_cbvprintf_impl+0x25c>
40001e6c:	00070863          	beqz	a4,40001e7c <z_cbvprintf_impl+0x134>
40001e70:	04015703          	lhu	a4,64(sp)
40001e74:	04076713          	ori	a4,a4,64
40001e78:	04e11023          	sh	a4,64(sp)
40001e7c:	00050863          	beqz	a0,40001e8c <z_cbvprintf_impl+0x144>
40001e80:	04015703          	lhu	a4,64(sp)
40001e84:	02076713          	ori	a4,a4,32
40001e88:	04e11023          	sh	a4,64(sp)
40001e8c:	00068863          	beqz	a3,40001e9c <z_cbvprintf_impl+0x154>
40001e90:	04015703          	lhu	a4,64(sp)
40001e94:	01076713          	ori	a4,a4,16
40001e98:	04e11023          	sh	a4,64(sp)
40001e9c:	00058863          	beqz	a1,40001eac <z_cbvprintf_impl+0x164>
40001ea0:	04015703          	lhu	a4,64(sp)
40001ea4:	00876713          	ori	a4,a4,8
40001ea8:	04e11023          	sh	a4,64(sp)
40001eac:	00060863          	beqz	a2,40001ebc <z_cbvprintf_impl+0x174>
40001eb0:	04015703          	lhu	a4,64(sp)
40001eb4:	00476713          	ori	a4,a4,4
40001eb8:	04e11023          	sh	a4,64(sp)
	if (conv->flag_zero && conv->flag_dash) {
40001ebc:	04012703          	lw	a4,64(sp)
40001ec0:	04400693          	li	a3,68
40001ec4:	04477713          	andi	a4,a4,68
40001ec8:	00d71863          	bne	a4,a3,40001ed8 <z_cbvprintf_impl+0x190>
		conv->flag_zero = false;
40001ecc:	04015703          	lhu	a4,64(sp)
40001ed0:	fbf77713          	andi	a4,a4,-65
40001ed4:	04e11023          	sh	a4,64(sp)
	conv->width_present = true;
40001ed8:	04015703          	lhu	a4,64(sp)
40001edc:	08076713          	ori	a4,a4,128
40001ee0:	04e11023          	sh	a4,64(sp)
	if (*sp == '*') {
40001ee4:	02a00713          	li	a4,42
40001ee8:	10e79663          	bne	a5,a4,40001ff4 <z_cbvprintf_impl+0x2ac>
		conv->width_star = true;
40001eec:	04015703          	lhu	a4,64(sp)
		return ++sp;
40001ef0:	00198793          	addi	a5,s3,1
		conv->width_star = true;
40001ef4:	10076713          	ori	a4,a4,256
		conv->unsupported |= ((conv->width_value < 0)
40001ef8:	04e11023          	sh	a4,64(sp)
	conv->prec_present = (*sp == '.');
40001efc:	0007c603          	lbu	a2,0(a5)
40001f00:	04015703          	lhu	a4,64(sp)
40001f04:	fd260693          	addi	a3,a2,-46
40001f08:	0016b693          	seqz	a3,a3
40001f0c:	00969693          	slli	a3,a3,0x9
40001f10:	dff77713          	andi	a4,a4,-513
40001f14:	00d76733          	or	a4,a4,a3
40001f18:	04e11023          	sh	a4,64(sp)
	if (!conv->prec_present) {
40001f1c:	02e00713          	li	a4,46
40001f20:	0ee61c63          	bne	a2,a4,40002018 <z_cbvprintf_impl+0x2d0>
	if (*sp == '*') {
40001f24:	0017c683          	lbu	a3,1(a5)
40001f28:	02a00713          	li	a4,42
40001f2c:	0ce68e63          	beq	a3,a4,40002008 <z_cbvprintf_impl+0x2c0>
	++sp;
40001f30:	00178793          	addi	a5,a5,1
	size_t val = 0;
40001f34:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp) != 0) {
40001f38:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
40001f3c:	00a00813          	li	a6,10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
40001f40:	0007c683          	lbu	a3,0(a5)
40001f44:	00178513          	addi	a0,a5,1
40001f48:	fd068593          	addi	a1,a3,-48 # 7fd0 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3fd0>
	while (isdigit((int)(unsigned char)*sp) != 0) {
40001f4c:	14b67863          	bgeu	a2,a1,4000209c <z_cbvprintf_impl+0x354>
	conv->unsupported |= ((conv->prec_value < 0)
40001f50:	04012683          	lw	a3,64(sp)
	conv->prec_value = prec;
40001f54:	04e12423          	sw	a4,72(sp)
			      || (prec != (size_t)conv->prec_value));
40001f58:	01f75713          	srli	a4,a4,0x1f
	conv->unsupported |= ((conv->prec_value < 0)
40001f5c:	0016d693          	srli	a3,a3,0x1
40001f60:	0016f693          	andi	a3,a3,1
40001f64:	00d76733          	or	a4,a4,a3
40001f68:	04015683          	lhu	a3,64(sp)
40001f6c:	00171713          	slli	a4,a4,0x1
40001f70:	ffd6f693          	andi	a3,a3,-3
40001f74:	00e6e733          	or	a4,a3,a4
40001f78:	04e11023          	sh	a4,64(sp)
	return sp;
40001f7c:	09c0006f          	j	40002018 <z_cbvprintf_impl+0x2d0>
		switch (*sp) {
40001f80:	03178663          	beq	a5,a7,40001fac <z_cbvprintf_impl+0x264>
40001f84:	ee6794e3          	bne	a5,t1,40001e6c <z_cbvprintf_impl+0x124>
40001f88:	00100713          	li	a4,1
40001f8c:	0080006f          	j	40001f94 <z_cbvprintf_impl+0x24c>
40001f90:	00100593          	li	a1,1
			++sp;
40001f94:	00198993          	addi	s3,s3,1
	} while (loop);
40001f98:	ec1ff06f          	j	40001e58 <z_cbvprintf_impl+0x110>
		switch (*sp) {
40001f9c:	00100693          	li	a3,1
40001fa0:	ff5ff06f          	j	40001f94 <z_cbvprintf_impl+0x24c>
40001fa4:	00100513          	li	a0,1
40001fa8:	fedff06f          	j	40001f94 <z_cbvprintf_impl+0x24c>
40001fac:	00100613          	li	a2,1
40001fb0:	fe5ff06f          	j	40001f94 <z_cbvprintf_impl+0x24c>
		val = 10U * val + *sp++ - '0';
40001fb4:	03070733          	mul	a4,a4,a6
40001fb8:	00050793          	mv	a5,a0
40001fbc:	fd070713          	addi	a4,a4,-48
40001fc0:	00e68733          	add	a4,a3,a4
40001fc4:	0007c683          	lbu	a3,0(a5)
40001fc8:	00178513          	addi	a0,a5,1
40001fcc:	fd068593          	addi	a1,a3,-48
	while (isdigit((int)(unsigned char)*sp) != 0) {
40001fd0:	feb672e3          	bgeu	a2,a1,40001fb4 <z_cbvprintf_impl+0x26c>
	if (sp != wp) {
40001fd4:	f2f984e3          	beq	s3,a5,40001efc <z_cbvprintf_impl+0x1b4>
		conv->unsupported |= ((conv->width_value < 0)
40001fd8:	04015683          	lhu	a3,64(sp)
		conv->width_value = width;
40001fdc:	04e12223          	sw	a4,68(sp)
		conv->unsupported |= ((conv->width_value < 0)
40001fe0:	01f75713          	srli	a4,a4,0x1f
40001fe4:	00171713          	slli	a4,a4,0x1
40001fe8:	ffd6f693          	andi	a3,a3,-3
40001fec:	00e6e733          	or	a4,a3,a4
40001ff0:	f09ff06f          	j	40001ef8 <z_cbvprintf_impl+0x1b0>
40001ff4:	00098793          	mv	a5,s3
	size_t val = 0;
40001ff8:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp) != 0) {
40001ffc:	00900613          	li	a2,9
		val = 10U * val + *sp++ - '0';
40002000:	00a00813          	li	a6,10
40002004:	fc1ff06f          	j	40001fc4 <z_cbvprintf_impl+0x27c>
		conv->prec_star = true;
40002008:	04015703          	lhu	a4,64(sp)
		return ++sp;
4000200c:	00278793          	addi	a5,a5,2
		conv->prec_star = true;
40002010:	40076713          	ori	a4,a4,1024
40002014:	04e11023          	sh	a4,64(sp)
	switch (*sp) {
40002018:	0007c683          	lbu	a3,0(a5)
4000201c:	06c00713          	li	a4,108
40002020:	0ee68e63          	beq	a3,a4,4000211c <z_cbvprintf_impl+0x3d4>
40002024:	08d76663          	bltu	a4,a3,400020b0 <z_cbvprintf_impl+0x368>
40002028:	06800713          	li	a4,104
4000202c:	0ae68663          	beq	a3,a4,400020d8 <z_cbvprintf_impl+0x390>
40002030:	06a00713          	li	a4,106
40002034:	10e68a63          	beq	a3,a4,40002148 <z_cbvprintf_impl+0x400>
40002038:	04c00713          	li	a4,76
4000203c:	12e68e63          	beq	a3,a4,40002178 <z_cbvprintf_impl+0x430>
	conv->specifier = *sp++;
40002040:	00178993          	addi	s3,a5,1
40002044:	0007c783          	lbu	a5,0(a5)
	switch (conv->specifier) {
40002048:	07800713          	li	a4,120
	conv->specifier = *sp++;
4000204c:	04f101a3          	sb	a5,67(sp)
	switch (conv->specifier) {
40002050:	2af76263          	bltu	a4,a5,400022f4 <z_cbvprintf_impl+0x5ac>
40002054:	06d00713          	li	a4,109
40002058:	12f76e63          	bltu	a4,a5,40002194 <z_cbvprintf_impl+0x44c>
4000205c:	06900713          	li	a4,105
40002060:	28f76a63          	bltu	a4,a5,400022f4 <z_cbvprintf_impl+0x5ac>
40002064:	05700713          	li	a4,87
40002068:	18f76063          	bltu	a4,a5,400021e8 <z_cbvprintf_impl+0x4a0>
4000206c:	04100713          	li	a4,65
40002070:	00e78a63          	beq	a5,a4,40002084 <z_cbvprintf_impl+0x33c>
40002074:	fbb78793          	addi	a5,a5,-69
40002078:	0ff7f793          	zext.b	a5,a5
4000207c:	00200713          	li	a4,2
40002080:	26f76a63          	bltu	a4,a5,400022f4 <z_cbvprintf_impl+0x5ac>
		conv->specifier_cat = SPECIFIER_FP;
40002084:	04214783          	lbu	a5,66(sp)
40002088:	ff87f793          	andi	a5,a5,-8
4000208c:	0047e793          	ori	a5,a5,4
40002090:	04f10123          	sb	a5,66(sp)
			unsupported = true;
40002094:	00100793          	li	a5,1
			break;
40002098:	1b40006f          	j	4000224c <z_cbvprintf_impl+0x504>
		val = 10U * val + *sp++ - '0';
4000209c:	03070733          	mul	a4,a4,a6
400020a0:	00050793          	mv	a5,a0
400020a4:	fd070713          	addi	a4,a4,-48
400020a8:	00d70733          	add	a4,a4,a3
400020ac:	e95ff06f          	j	40001f40 <z_cbvprintf_impl+0x1f8>
	switch (*sp) {
400020b0:	07400713          	li	a4,116
400020b4:	0ae68663          	beq	a3,a4,40002160 <z_cbvprintf_impl+0x418>
400020b8:	07a00713          	li	a4,122
400020bc:	f8e692e3          	bne	a3,a4,40002040 <z_cbvprintf_impl+0x2f8>
		conv->length_mod = LENGTH_Z;
400020c0:	04015703          	lhu	a4,64(sp)
400020c4:	ffff86b7          	lui	a3,0xffff8
400020c8:	7ff68693          	addi	a3,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
400020cc:	00d77733          	and	a4,a4,a3
400020d0:	000036b7          	lui	a3,0x3
400020d4:	0380006f          	j	4000210c <z_cbvprintf_impl+0x3c4>
		if (*++sp == 'h') {
400020d8:	04015703          	lhu	a4,64(sp)
400020dc:	0017c583          	lbu	a1,1(a5)
400020e0:	ffff8637          	lui	a2,0xffff8
400020e4:	7ff60613          	addi	a2,a2,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_HH;
400020e8:	00c77733          	and	a4,a4,a2
		if (*++sp == 'h') {
400020ec:	00d59e63          	bne	a1,a3,40002108 <z_cbvprintf_impl+0x3c0>
			conv->length_mod = LENGTH_HH;
400020f0:	000016b7          	lui	a3,0x1
400020f4:	80068693          	addi	a3,a3,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
			conv->length_mod = LENGTH_LL;
400020f8:	00d76733          	or	a4,a4,a3
400020fc:	04e11023          	sh	a4,64(sp)
			++sp;
40002100:	00278793          	addi	a5,a5,2
40002104:	f3dff06f          	j	40002040 <z_cbvprintf_impl+0x2f8>
			conv->length_mod = LENGTH_H;
40002108:	000016b7          	lui	a3,0x1
4000210c:	00d76733          	or	a4,a4,a3
40002110:	04e11023          	sh	a4,64(sp)
		if (*++sp == 'h') {
40002114:	00178793          	addi	a5,a5,1
40002118:	f29ff06f          	j	40002040 <z_cbvprintf_impl+0x2f8>
		if (*++sp == 'l') {
4000211c:	04015703          	lhu	a4,64(sp)
40002120:	0017c583          	lbu	a1,1(a5)
40002124:	ffff8637          	lui	a2,0xffff8
40002128:	7ff60613          	addi	a2,a2,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_LL;
4000212c:	00c77733          	and	a4,a4,a2
		if (*++sp == 'l') {
40002130:	00d59663          	bne	a1,a3,4000213c <z_cbvprintf_impl+0x3f4>
			conv->length_mod = LENGTH_LL;
40002134:	000026b7          	lui	a3,0x2
40002138:	fc1ff06f          	j	400020f8 <z_cbvprintf_impl+0x3b0>
			conv->length_mod = LENGTH_L;
4000213c:	000026b7          	lui	a3,0x2
		conv->length_mod = LENGTH_T;
40002140:	80068693          	addi	a3,a3,-2048 # 1800 <CONFIG_HEAP_MEM_POOL_SIZE+0x800>
40002144:	fc9ff06f          	j	4000210c <z_cbvprintf_impl+0x3c4>
		conv->length_mod = LENGTH_J;
40002148:	04015703          	lhu	a4,64(sp)
4000214c:	ffff86b7          	lui	a3,0xffff8
40002150:	7ff68693          	addi	a3,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
40002154:	00d77733          	and	a4,a4,a3
40002158:	000036b7          	lui	a3,0x3
4000215c:	fe5ff06f          	j	40002140 <z_cbvprintf_impl+0x3f8>
		conv->length_mod = LENGTH_T;
40002160:	04015703          	lhu	a4,64(sp)
40002164:	ffff86b7          	lui	a3,0xffff8
40002168:	7ff68693          	addi	a3,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
4000216c:	00d77733          	and	a4,a4,a3
40002170:	000046b7          	lui	a3,0x4
40002174:	fcdff06f          	j	40002140 <z_cbvprintf_impl+0x3f8>
		conv->unsupported = true;
40002178:	04015703          	lhu	a4,64(sp)
4000217c:	ffff86b7          	lui	a3,0xffff8
40002180:	7fd68693          	addi	a3,a3,2045 # ffff87fd <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff87fe>
40002184:	00d77733          	and	a4,a4,a3
40002188:	000046b7          	lui	a3,0x4
4000218c:	00268693          	addi	a3,a3,2 # 4002 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x2>
40002190:	f7dff06f          	j	4000210c <z_cbvprintf_impl+0x3c4>
	switch (conv->specifier) {
40002194:	f9278713          	addi	a4,a5,-110
40002198:	00100793          	li	a5,1
4000219c:	00e797b3          	sll	a5,a5,a4
400021a0:	4827f713          	andi	a4,a5,1154
400021a4:	0c071863          	bnez	a4,40002274 <z_cbvprintf_impl+0x52c>
400021a8:	0247f713          	andi	a4,a5,36
400021ac:	12071a63          	bnez	a4,400022e0 <z_cbvprintf_impl+0x598>
400021b0:	0017f793          	andi	a5,a5,1
400021b4:	14078063          	beqz	a5,400022f4 <z_cbvprintf_impl+0x5ac>
		conv->specifier_cat = SPECIFIER_PTR;
400021b8:	04214783          	lbu	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
400021bc:	00008737          	lui	a4,0x8
400021c0:	80070713          	addi	a4,a4,-2048 # 7800 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3800>
		conv->specifier_cat = SPECIFIER_PTR;
400021c4:	ff87f793          	andi	a5,a5,-8
400021c8:	0037e793          	ori	a5,a5,3
400021cc:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
400021d0:	04015783          	lhu	a5,64(sp)
400021d4:	00e7f7b3          	and	a5,a5,a4
400021d8:	ffffc737          	lui	a4,0xffffc
400021dc:	00e787b3          	add	a5,a5,a4
400021e0:	0017b793          	seqz	a5,a5
400021e4:	0680006f          	j	4000224c <z_cbvprintf_impl+0x504>
	switch (conv->specifier) {
400021e8:	fa878693          	addi	a3,a5,-88
400021ec:	00100713          	li	a4,1
400021f0:	00d71733          	sll	a4,a4,a3
400021f4:	0000e6b7          	lui	a3,0xe
400021f8:	20068693          	addi	a3,a3,512 # e200 <__kernel_ram_size+0x1f6c>
400021fc:	00d776b3          	and	a3,a4,a3
40002200:	e80692e3          	bnez	a3,40002084 <z_cbvprintf_impl+0x33c>
40002204:	000016b7          	lui	a3,0x1
40002208:	80168693          	addi	a3,a3,-2047 # 801 <CONFIG_ISR_STACK_SIZE+0x1>
4000220c:	00d776b3          	and	a3,a4,a3
40002210:	08069063          	bnez	a3,40002290 <z_cbvprintf_impl+0x548>
40002214:	000217b7          	lui	a5,0x21
40002218:	00f77733          	and	a4,a4,a5
4000221c:	0c070c63          	beqz	a4,400022f4 <z_cbvprintf_impl+0x5ac>
		conv->specifier_cat = SPECIFIER_SINT;
40002220:	04214783          	lbu	a5,66(sp)
40002224:	ff87f793          	andi	a5,a5,-8
40002228:	0017e793          	ori	a5,a5,1
		if (conv->length_mod == LENGTH_UPPER_L) {
4000222c:	04015703          	lhu	a4,64(sp)
		conv->specifier_cat = SPECIFIER_SINT;
40002230:	04f10123          	sb	a5,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
40002234:	000087b7          	lui	a5,0x8
40002238:	80078793          	addi	a5,a5,-2048 # 7800 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3800>
4000223c:	00f777b3          	and	a5,a4,a5
40002240:	000046b7          	lui	a3,0x4
40002244:	04d78063          	beq	a5,a3,40002284 <z_cbvprintf_impl+0x53c>
	bool unsupported = false;
40002248:	00000793          	li	a5,0
	conv->unsupported |= unsupported;
4000224c:	04012703          	lw	a4,64(sp)
40002250:	00175713          	srli	a4,a4,0x1
40002254:	00177713          	andi	a4,a4,1
40002258:	00e7e7b3          	or	a5,a5,a4
4000225c:	04015703          	lhu	a4,64(sp)
40002260:	00179793          	slli	a5,a5,0x1
40002264:	ffd77713          	andi	a4,a4,-3
40002268:	00f767b3          	or	a5,a4,a5
4000226c:	04f11023          	sh	a5,64(sp)
	return sp;
40002270:	b75ff06f          	j	40001de4 <z_cbvprintf_impl+0x9c>
		conv->specifier_cat = SPECIFIER_UINT;
40002274:	04214783          	lbu	a5,66(sp)
40002278:	ff87f793          	andi	a5,a5,-8
4000227c:	0027e793          	ori	a5,a5,2
40002280:	fadff06f          	j	4000222c <z_cbvprintf_impl+0x4e4>
			conv->invalid = true;
40002284:	00176713          	ori	a4,a4,1
40002288:	04e11023          	sh	a4,64(sp)
		if (conv->specifier == 'c') {
4000228c:	fbdff06f          	j	40002248 <z_cbvprintf_impl+0x500>
		conv->specifier_cat = SPECIFIER_UINT;
40002290:	04214703          	lbu	a4,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
40002294:	04015683          	lhu	a3,64(sp)
40002298:	00004637          	lui	a2,0x4
		conv->specifier_cat = SPECIFIER_UINT;
4000229c:	ff877713          	andi	a4,a4,-8
400022a0:	00276713          	ori	a4,a4,2
400022a4:	04e10123          	sb	a4,66(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
400022a8:	00008737          	lui	a4,0x8
400022ac:	80070713          	addi	a4,a4,-2048 # 7800 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3800>
400022b0:	00e6f733          	and	a4,a3,a4
400022b4:	00c71663          	bne	a4,a2,400022c0 <z_cbvprintf_impl+0x578>
			conv->invalid = true;
400022b8:	0016e693          	ori	a3,a3,1
400022bc:	04d11023          	sh	a3,64(sp)
		if (conv->specifier == 'c') {
400022c0:	06300713          	li	a4,99
400022c4:	f8e792e3          	bne	a5,a4,40002248 <z_cbvprintf_impl+0x500>
		if (conv->length_mod != LENGTH_NONE) {
400022c8:	04015783          	lhu	a5,64(sp)
400022cc:	00008737          	lui	a4,0x8
400022d0:	80070713          	addi	a4,a4,-2048 # 7800 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3800>
400022d4:	00e7f7b3          	and	a5,a5,a4
400022d8:	00f037b3          	snez	a5,a5
400022dc:	f71ff06f          	j	4000224c <z_cbvprintf_impl+0x504>
		conv->specifier_cat = SPECIFIER_PTR;
400022e0:	04214783          	lbu	a5,66(sp)
400022e4:	ff87f793          	andi	a5,a5,-8
400022e8:	0037e793          	ori	a5,a5,3
400022ec:	04f10123          	sb	a5,66(sp)
400022f0:	fd9ff06f          	j	400022c8 <z_cbvprintf_impl+0x580>
		conv->invalid = true;
400022f4:	04015783          	lhu	a5,64(sp)
400022f8:	0017e793          	ori	a5,a5,1
400022fc:	04f11023          	sh	a5,64(sp)
		break;
40002300:	f49ff06f          	j	40002248 <z_cbvprintf_impl+0x500>
		} else if (conv->width_present) {
40002304:	0807f793          	andi	a5,a5,128
40002308:	00078863          	beqz	a5,40002318 <z_cbvprintf_impl+0x5d0>
			width = conv->width_value;
4000230c:	04412a83          	lw	s5,68(sp)
40002310:	000c8713          	mv	a4,s9
40002314:	af5ff06f          	j	40001e08 <z_cbvprintf_impl+0xc0>
40002318:	000c8713          	mv	a4,s9
		int width = -1;
4000231c:	fff00a93          	li	s5,-1
40002320:	ae9ff06f          	j	40001e08 <z_cbvprintf_impl+0xc0>
		} else if (conv->prec_present) {
40002324:	2007f793          	andi	a5,a5,512
40002328:	06078663          	beqz	a5,40002394 <z_cbvprintf_impl+0x64c>
			precision = conv->prec_value;
4000232c:	04812b83          	lw	s7,72(sp)
40002330:	00070c93          	mv	s9,a4
			= (enum specifier_cat_enum)conv->specifier_cat;
40002334:	04012603          	lw	a2,64(sp)
		conv->pad0_value = 0;
40002338:	04012223          	sw	zero,68(sp)
		conv->pad0_pre_exp = 0;
4000233c:	04012423          	sw	zero,72(sp)
			= (enum specifier_cat_enum)conv->specifier_cat;
40002340:	01065513          	srli	a0,a2,0x10
			= (enum length_mod_enum)conv->length_mod;
40002344:	00b65693          	srli	a3,a2,0xb
		enum specifier_cat_enum specifier_cat
40002348:	00757513          	andi	a0,a0,7
		if (specifier_cat == SPECIFIER_SINT) {
4000234c:	00100593          	li	a1,1
			= (enum length_mod_enum)conv->length_mod;
40002350:	00f6f693          	andi	a3,a3,15
		if (specifier_cat == SPECIFIER_SINT) {
40002354:	08b51a63          	bne	a0,a1,400023e8 <z_cbvprintf_impl+0x6a0>
			switch (length_mod) {
40002358:	00500793          	li	a5,5
4000235c:	18f68463          	beq	a3,a5,400024e4 <z_cbvprintf_impl+0x79c>
40002360:	02d7ee63          	bltu	a5,a3,4000239c <z_cbvprintf_impl+0x654>
40002364:	00300793          	li	a5,3
40002368:	04f68663          	beq	a3,a5,400023b4 <z_cbvprintf_impl+0x66c>
4000236c:	00400793          	li	a5,4
40002370:	16f68a63          	beq	a3,a5,400024e4 <z_cbvprintf_impl+0x79c>
				value->sint = va_arg(ap, int);
40002374:	000ca783          	lw	a5,0(s9)
40002378:	004c8713          	addi	a4,s9,4
4000237c:	41f7d593          	srai	a1,a5,0x1f
40002380:	02f12823          	sw	a5,48(sp)
40002384:	02b12a23          	sw	a1,52(sp)
			if (length_mod == LENGTH_HH) {
40002388:	04a69263          	bne	a3,a0,400023cc <z_cbvprintf_impl+0x684>
				value->sint = (signed char)value->sint;
4000238c:	03010783          	lb	a5,48(sp)
40002390:	0140006f          	j	400023a4 <z_cbvprintf_impl+0x65c>
40002394:	00070c93          	mv	s9,a4
40002398:	a91ff06f          	j	40001e28 <z_cbvprintf_impl+0xe0>
4000239c:	000ca783          	lw	a5,0(s9)
400023a0:	004c8713          	addi	a4,s9,4
				value->sint = (short)value->sint;
400023a4:	02f12823          	sw	a5,48(sp)
400023a8:	41f7d793          	srai	a5,a5,0x1f
400023ac:	02f12a23          	sw	a5,52(sp)
400023b0:	0240006f          	j	400023d4 <z_cbvprintf_impl+0x68c>
					value->sint = va_arg(ap, long);
400023b4:	000ca783          	lw	a5,0(s9)
400023b8:	02f12823          	sw	a5,48(sp)
400023bc:	41f7d793          	srai	a5,a5,0x1f
400023c0:	02f12a23          	sw	a5,52(sp)
			value->ptr = va_arg(ap, void *);
400023c4:	004c8c93          	addi	s9,s9,4
400023c8:	0a00006f          	j	40002468 <z_cbvprintf_impl+0x720>
			} else if (length_mod == LENGTH_H) {
400023cc:	00200593          	li	a1,2
400023d0:	00b68663          	beq	a3,a1,400023dc <z_cbvprintf_impl+0x694>
400023d4:	00070c93          	mv	s9,a4
400023d8:	0900006f          	j	40002468 <z_cbvprintf_impl+0x720>
				value->sint = (short)value->sint;
400023dc:	01079793          	slli	a5,a5,0x10
400023e0:	4107d793          	srai	a5,a5,0x10
400023e4:	fc1ff06f          	j	400023a4 <z_cbvprintf_impl+0x65c>
		} else if (specifier_cat == SPECIFIER_UINT) {
400023e8:	00200793          	li	a5,2
400023ec:	0cf51063          	bne	a0,a5,400024ac <z_cbvprintf_impl+0x764>
			switch (length_mod) {
400023f0:	00500793          	li	a5,5
400023f4:	0ef68863          	beq	a3,a5,400024e4 <z_cbvprintf_impl+0x79c>
400023f8:	02d7ee63          	bltu	a5,a3,40002434 <z_cbvprintf_impl+0x6ec>
400023fc:	00300793          	li	a5,3
40002400:	04f68463          	beq	a3,a5,40002448 <z_cbvprintf_impl+0x700>
40002404:	00400793          	li	a5,4
40002408:	0cf68e63          	beq	a3,a5,400024e4 <z_cbvprintf_impl+0x79c>
				value->uint = va_arg(ap, unsigned int);
4000240c:	000ca783          	lw	a5,0(s9)
40002410:	004c8713          	addi	a4,s9,4
			if (length_mod == LENGTH_HH) {
40002414:	08b68663          	beq	a3,a1,400024a0 <z_cbvprintf_impl+0x758>
				value->uint = va_arg(ap, unsigned int);
40002418:	02f12823          	sw	a5,48(sp)
4000241c:	02012a23          	sw	zero,52(sp)
			} else if (length_mod == LENGTH_H) {
40002420:	faa69ae3          	bne	a3,a0,400023d4 <z_cbvprintf_impl+0x68c>
				value->uint = (unsigned short)value->uint;
40002424:	01079793          	slli	a5,a5,0x10
40002428:	0107d793          	srli	a5,a5,0x10
4000242c:	02f12823          	sw	a5,48(sp)
40002430:	fa5ff06f          	j	400023d4 <z_cbvprintf_impl+0x68c>
40002434:	000ca503          	lw	a0,0(s9)
40002438:	004c8713          	addi	a4,s9,4
					(uint_value_type)va_arg(ap, size_t);
4000243c:	02a12823          	sw	a0,48(sp)
				value->uint = (unsigned char)value->uint;
40002440:	02012a23          	sw	zero,52(sp)
40002444:	f91ff06f          	j	400023d4 <z_cbvprintf_impl+0x68c>
				if ((!WCHAR_IS_SIGNED)
40002448:	04314703          	lbu	a4,67(sp)
4000244c:	06300793          	li	a5,99
40002450:	04f71263          	bne	a4,a5,40002494 <z_cbvprintf_impl+0x74c>
					value->uint = (wchar_t)va_arg(ap,
40002454:	000ca783          	lw	a5,0(s9)
40002458:	41f7d713          	srai	a4,a5,0x1f
				value->sint = va_arg(ap, int);
4000245c:	004c8c93          	addi	s9,s9,4
					value->uint = (wchar_t)va_arg(ap,
40002460:	02f12823          	sw	a5,48(sp)
40002464:	02e12a23          	sw	a4,52(sp)
		if (conv->invalid || conv->unsupported) {
40002468:	00367613          	andi	a2,a2,3
4000246c:	0a060663          	beqz	a2,40002518 <z_cbvprintf_impl+0x7d0>
			OUTS(sp, fp);
40002470:	00812583          	lw	a1,8(sp)
40002474:	00098693          	mv	a3,s3
40002478:	00040613          	mv	a2,s0
4000247c:	00048513          	mv	a0,s1
40002480:	84dff0ef          	jal	ra,40001ccc <outs>
40002484:	3a054463          	bltz	a0,4000282c <z_cbvprintf_impl+0xae4>
40002488:	00ad0d33          	add	s10,s10,a0
			continue;
4000248c:	00098413          	mv	s0,s3
40002490:	909ff06f          	j	40001d98 <z_cbvprintf_impl+0x50>
					value->uint = va_arg(ap, unsigned long);
40002494:	000ca783          	lw	a5,0(s9)
40002498:	00000713          	li	a4,0
			if (length_mod == LENGTH_HH) {
4000249c:	fc1ff06f          	j	4000245c <z_cbvprintf_impl+0x714>
				value->uint = (unsigned char)value->uint;
400024a0:	0ff7f793          	zext.b	a5,a5
400024a4:	02f12823          	sw	a5,48(sp)
400024a8:	f99ff06f          	j	40002440 <z_cbvprintf_impl+0x6f8>
		} else if (specifier_cat == SPECIFIER_FP) {
400024ac:	00400793          	li	a5,4
400024b0:	04f51a63          	bne	a0,a5,40002504 <z_cbvprintf_impl+0x7bc>
			if (length_mod == LENGTH_UPPER_L) {
400024b4:	00800793          	li	a5,8
400024b8:	02f69663          	bne	a3,a5,400024e4 <z_cbvprintf_impl+0x79c>
				value->ldbl = va_arg(ap, long double);
400024bc:	000ca783          	lw	a5,0(s9)
400024c0:	0007a703          	lw	a4,0(a5)
400024c4:	02e12823          	sw	a4,48(sp)
400024c8:	0047a703          	lw	a4,4(a5)
400024cc:	02e12a23          	sw	a4,52(sp)
400024d0:	0087a703          	lw	a4,8(a5)
400024d4:	00c7a783          	lw	a5,12(a5)
400024d8:	02e12c23          	sw	a4,56(sp)
400024dc:	02f12e23          	sw	a5,60(sp)
400024e0:	ee5ff06f          	j	400023c4 <z_cbvprintf_impl+0x67c>
				value->dbl = va_arg(ap, double);
400024e4:	007c8793          	addi	a5,s9,7
400024e8:	ff87f793          	andi	a5,a5,-8
400024ec:	0007a703          	lw	a4,0(a5)
400024f0:	00878c93          	addi	s9,a5,8
400024f4:	0047a783          	lw	a5,4(a5)
400024f8:	02e12823          	sw	a4,48(sp)
400024fc:	02f12a23          	sw	a5,52(sp)
40002500:	f69ff06f          	j	40002468 <z_cbvprintf_impl+0x720>
		} else if (specifier_cat == SPECIFIER_PTR) {
40002504:	00300793          	li	a5,3
40002508:	f6f510e3          	bne	a0,a5,40002468 <z_cbvprintf_impl+0x720>
			value->ptr = va_arg(ap, void *);
4000250c:	000ca783          	lw	a5,0(s9)
40002510:	02f12823          	sw	a5,48(sp)
40002514:	eb1ff06f          	j	400023c4 <z_cbvprintf_impl+0x67c>
		switch (conv->specifier) {
40002518:	04314783          	lbu	a5,67(sp)
4000251c:	07800713          	li	a4,120
40002520:	f6f766e3          	bltu	a4,a5,4000248c <z_cbvprintf_impl+0x744>
40002524:	06200713          	li	a4,98
40002528:	00f76e63          	bltu	a4,a5,40002544 <z_cbvprintf_impl+0x7fc>
4000252c:	02500713          	li	a4,37
40002530:	02e78e63          	beq	a5,a4,4000256c <z_cbvprintf_impl+0x824>
40002534:	05800713          	li	a4,88
40002538:	f4e79ae3          	bne	a5,a4,4000248c <z_cbvprintf_impl+0x744>
4000253c:	00000d93          	li	s11,0
40002540:	1b00006f          	j	400026f0 <z_cbvprintf_impl+0x9a8>
40002544:	f9d78793          	addi	a5,a5,-99
40002548:	0ff7f793          	zext.b	a5,a5
4000254c:	01500713          	li	a4,21
40002550:	f2f76ee3          	bltu	a4,a5,4000248c <z_cbvprintf_impl+0x744>
40002554:	4002c737          	lui	a4,0x4002c
40002558:	00279793          	slli	a5,a5,0x2
4000255c:	d8470713          	addi	a4,a4,-636 # 4002bd84 <__clz_tab+0x158>
40002560:	00e787b3          	add	a5,a5,a4
40002564:	0007a783          	lw	a5,0(a5)
40002568:	00078067          	jr	a5
			OUTC('%');
4000256c:	00812583          	lw	a1,8(sp)
40002570:	02500513          	li	a0,37
40002574:	841ff06f          	j	40001db4 <z_cbvprintf_impl+0x6c>
			bps = (const char *)value->ptr;
40002578:	03012403          	lw	s0,48(sp)
			if (precision >= 0) {
4000257c:	100bc663          	bltz	s7,40002688 <z_cbvprintf_impl+0x940>
				len = strnlen(bps, precision);
40002580:	000b8593          	mv	a1,s7
40002584:	00040513          	mv	a0,s0
40002588:	1c1060ef          	jal	ra,40008f48 <strnlen>
			bpe = bps + len;
4000258c:	00a40b33          	add	s6,s0,a0
		char sign = 0;
40002590:	00000d93          	li	s11,0
		if (bps == NULL) {
40002594:	ee040ce3          	beqz	s0,4000248c <z_cbvprintf_impl+0x744>
		if (conv->altform_0c) {
40002598:	04214783          	lbu	a5,66(sp)
4000259c:	0107fc13          	andi	s8,a5,16
400025a0:	260c0263          	beqz	s8,40002804 <z_cbvprintf_impl+0xabc>
			nj_len += 2U;
400025a4:	00250513          	addi	a0,a0,2
		nj_len += conv->pad0_value;
400025a8:	04412b83          	lw	s7,68(sp)
		if (conv->pad_fp) {
400025ac:	0407f793          	andi	a5,a5,64
		nj_len += conv->pad0_value;
400025b0:	01750533          	add	a0,a0,s7
		if (conv->pad_fp) {
400025b4:	00078663          	beqz	a5,400025c0 <z_cbvprintf_impl+0x878>
			nj_len += conv->pad0_pre_exp;
400025b8:	04812783          	lw	a5,72(sp)
400025bc:	00f50533          	add	a0,a0,a5
		if (width > 0) {
400025c0:	07505063          	blez	s5,40002620 <z_cbvprintf_impl+0x8d8>
			if (!conv->flag_dash) {
400025c4:	04012783          	lw	a5,64(sp)
			width -= (int)nj_len;
400025c8:	40aa8ab3          	sub	s5,s5,a0
			if (!conv->flag_dash) {
400025cc:	0027d793          	srli	a5,a5,0x2
400025d0:	0017f793          	andi	a5,a5,1
400025d4:	04079663          	bnez	a5,40002620 <z_cbvprintf_impl+0x8d8>
				if (conv->flag_zero) {
400025d8:	04015783          	lhu	a5,64(sp)
400025dc:	0407f793          	andi	a5,a5,64
400025e0:	28078463          	beqz	a5,40002868 <z_cbvprintf_impl+0xb20>
					if (sign != 0) {
400025e4:	280d8663          	beqz	s11,40002870 <z_cbvprintf_impl+0xb28>
						OUTC(sign);
400025e8:	00812583          	lw	a1,8(sp)
400025ec:	000d8513          	mv	a0,s11
400025f0:	000480e7          	jalr	s1
400025f4:	22054c63          	bltz	a0,4000282c <z_cbvprintf_impl+0xae4>
400025f8:	001d0d13          	addi	s10,s10,1
					pad = '0';
400025fc:	03000713          	li	a4,48
						OUTC(sign);
40002600:	00000d93          	li	s11,0
					pad = '0';
40002604:	000a8913          	mv	s2,s5
				while (width-- > 0) {
40002608:	00090693          	mv	a3,s2
4000260c:	fff90913          	addi	s2,s2,-1
40002610:	20d04263          	bgtz	a3,40002814 <z_cbvprintf_impl+0xacc>
40002614:	01aa8d33          	add	s10,s5,s10
40002618:	40dd0d33          	sub	s10,s10,a3
4000261c:	00090a93          	mv	s5,s2
		if (sign != 0) {
40002620:	000d8c63          	beqz	s11,40002638 <z_cbvprintf_impl+0x8f0>
			OUTC(sign);
40002624:	00812583          	lw	a1,8(sp)
40002628:	000d8513          	mv	a0,s11
4000262c:	000480e7          	jalr	s1
40002630:	1e054e63          	bltz	a0,4000282c <z_cbvprintf_impl+0xae4>
40002634:	001d0d13          	addi	s10,s10,1
			if (conv->altform_0c | conv->altform_0) {
40002638:	04012783          	lw	a5,64(sp)
4000263c:	0147d713          	srli	a4,a5,0x14
40002640:	00177713          	andi	a4,a4,1
40002644:	00071863          	bnez	a4,40002654 <z_cbvprintf_impl+0x90c>
40002648:	0137d793          	srli	a5,a5,0x13
4000264c:	0017f793          	andi	a5,a5,1
40002650:	00078c63          	beqz	a5,40002668 <z_cbvprintf_impl+0x920>
				OUTC('0');
40002654:	00812583          	lw	a1,8(sp)
40002658:	03000513          	li	a0,48
4000265c:	000480e7          	jalr	s1
40002660:	1c054663          	bltz	a0,4000282c <z_cbvprintf_impl+0xae4>
40002664:	001d0d13          	addi	s10,s10,1
			if (conv->altform_0c) {
40002668:	000c0c63          	beqz	s8,40002680 <z_cbvprintf_impl+0x938>
				OUTC(conv->specifier);
4000266c:	00812583          	lw	a1,8(sp)
40002670:	04314503          	lbu	a0,67(sp)
40002674:	000480e7          	jalr	s1
40002678:	1a054a63          	bltz	a0,4000282c <z_cbvprintf_impl+0xae4>
4000267c:	001d0d13          	addi	s10,s10,1
			while (pad_len-- > 0) {
40002680:	01ab8bb3          	add	s7,s7,s10
40002684:	2080006f          	j	4000288c <z_cbvprintf_impl+0xb44>
				len = strlen(bps);
40002688:	00040513          	mv	a0,s0
4000268c:	09d060ef          	jal	ra,40008f28 <strlen>
40002690:	efdff06f          	j	4000258c <z_cbvprintf_impl+0x844>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
40002694:	03012783          	lw	a5,48(sp)
			bps = buf;
40002698:	01810413          	addi	s0,sp,24
			bpe = buf + 1;
4000269c:	01910b13          	addi	s6,sp,25
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
400026a0:	00f10c23          	sb	a5,24(sp)
		char sign = 0;
400026a4:	00000d93          	li	s11,0
		size_t nj_len = (bpe - bps);
400026a8:	00100513          	li	a0,1
400026ac:	eedff06f          	j	40002598 <z_cbvprintf_impl+0x850>
			if (conv->flag_plus) {
400026b0:	04015783          	lhu	a5,64(sp)
				sign = '+';
400026b4:	02b00d93          	li	s11,43
			if (conv->flag_plus) {
400026b8:	0087f713          	andi	a4,a5,8
400026bc:	00071663          	bnez	a4,400026c8 <z_cbvprintf_impl+0x980>
			} else if (conv->flag_space) {
400026c0:	00179793          	slli	a5,a5,0x1
400026c4:	0207fd93          	andi	s11,a5,32
			sint = value->sint;
400026c8:	03412783          	lw	a5,52(sp)
400026cc:	03012703          	lw	a4,48(sp)
			if (sint < 0) {
400026d0:	0207d063          	bgez	a5,400026f0 <z_cbvprintf_impl+0x9a8>
				value->uint = (uint_value_type)-sint;
400026d4:	40e006b3          	neg	a3,a4
400026d8:	40f007b3          	neg	a5,a5
400026dc:	00e03733          	snez	a4,a4
400026e0:	40e787b3          	sub	a5,a5,a4
400026e4:	02d12823          	sw	a3,48(sp)
400026e8:	02f12a23          	sw	a5,52(sp)
				sign = '-';
400026ec:	02d00d93          	li	s11,45
			bps = encode_uint(value->uint, conv, buf, bpe);
400026f0:	03012503          	lw	a0,48(sp)
400026f4:	03412583          	lw	a1,52(sp)
400026f8:	02e10713          	addi	a4,sp,46
400026fc:	01810693          	addi	a3,sp,24
40002700:	04010613          	addi	a2,sp,64
40002704:	c6cff0ef          	jal	ra,40001b70 <encode_uint>
40002708:	00050413          	mv	s0,a0
			if (precision >= 0) {
4000270c:	020bc263          	bltz	s7,40002730 <z_cbvprintf_impl+0x9e8>
				conv->flag_zero = false;
40002710:	04015703          	lhu	a4,64(sp)
				size_t len = bpe - bps;
40002714:	02e10793          	addi	a5,sp,46
40002718:	408787b3          	sub	a5,a5,s0
				conv->flag_zero = false;
4000271c:	fbf77713          	andi	a4,a4,-65
40002720:	04e11023          	sh	a4,64(sp)
				if (len < (size_t)precision) {
40002724:	0177f663          	bgeu	a5,s7,40002730 <z_cbvprintf_impl+0x9e8>
					conv->pad0_value = precision - (int)len;
40002728:	40fb87b3          	sub	a5,s7,a5
4000272c:	04f12223          	sw	a5,68(sp)
		if (bps == NULL) {
40002730:	d4040ee3          	beqz	s0,4000248c <z_cbvprintf_impl+0x744>
		size_t nj_len = (bpe - bps);
40002734:	02e10793          	addi	a5,sp,46
40002738:	40878533          	sub	a0,a5,s0
		if (sign != 0) {
4000273c:	00078b13          	mv	s6,a5
40002740:	e40d8ce3          	beqz	s11,40002598 <z_cbvprintf_impl+0x850>
			nj_len += 1U;
40002744:	00150513          	addi	a0,a0,1
40002748:	e51ff06f          	j	40002598 <z_cbvprintf_impl+0x850>
			if (value->ptr != NULL) {
4000274c:	03012503          	lw	a0,48(sp)
40002750:	08050c63          	beqz	a0,400027e8 <z_cbvprintf_impl+0xaa0>
				bps = encode_uint((uintptr_t)value->ptr, conv,
40002754:	02e10b13          	addi	s6,sp,46
40002758:	000b0713          	mv	a4,s6
4000275c:	01810693          	addi	a3,sp,24
40002760:	04010613          	addi	a2,sp,64
40002764:	00000593          	li	a1,0
40002768:	c08ff0ef          	jal	ra,40001b70 <encode_uint>
				conv->altform_0c = true;
4000276c:	04215783          	lhu	a5,66(sp)
40002770:	00008737          	lui	a4,0x8
40002774:	81070713          	addi	a4,a4,-2032 # 7810 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3810>
40002778:	0ef7f793          	andi	a5,a5,239
4000277c:	00e7e7b3          	or	a5,a5,a4
40002780:	04f11123          	sh	a5,66(sp)
				bps = encode_uint((uintptr_t)value->ptr, conv,
40002784:	00050413          	mv	s0,a0
		char sign = 0;
40002788:	00000d93          	li	s11,0
			if (precision >= 0) {
4000278c:	f80bd2e3          	bgez	s7,40002710 <z_cbvprintf_impl+0x9c8>
		size_t nj_len = (bpe - bps);
40002790:	40ab0533          	sub	a0,s6,a0
		if (bps == NULL) {
40002794:	e00412e3          	bnez	s0,40002598 <z_cbvprintf_impl+0x850>
40002798:	cf5ff06f          	j	4000248c <z_cbvprintf_impl+0x744>
	switch ((enum length_mod_enum)conv->length_mod) {
4000279c:	00700713          	li	a4,7
				store_count(conv, value->ptr, count);
400027a0:	03012783          	lw	a5,48(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
400027a4:	ced764e3          	bltu	a4,a3,4000248c <z_cbvprintf_impl+0x744>
400027a8:	4002c737          	lui	a4,0x4002c
400027ac:	ddc70713          	addi	a4,a4,-548 # 4002bddc <__clz_tab+0x1b0>
400027b0:	00269693          	slli	a3,a3,0x2
400027b4:	00e686b3          	add	a3,a3,a4
400027b8:	0006a703          	lw	a4,0(a3) # 4000 <CONFIG_COVERAGE_GCOV_HEAP_SIZE>
400027bc:	00070067          	jr	a4
		*(signed char *)dp = (signed char)count;
400027c0:	01a78023          	sb	s10,0(a5)
		if (bps == NULL) {
400027c4:	cc9ff06f          	j	4000248c <z_cbvprintf_impl+0x744>
		*(short *)dp = (short)count;
400027c8:	01a79023          	sh	s10,0(a5)
		if (bps == NULL) {
400027cc:	cc1ff06f          	j	4000248c <z_cbvprintf_impl+0x744>
		*(intmax_t *)dp = (intmax_t)count;
400027d0:	41fd5713          	srai	a4,s10,0x1f
400027d4:	01a7a023          	sw	s10,0(a5)
400027d8:	00e7a223          	sw	a4,4(a5)
		if (bps == NULL) {
400027dc:	cb1ff06f          	j	4000248c <z_cbvprintf_impl+0x744>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
400027e0:	01a7a023          	sw	s10,0(a5)
		if (bps == NULL) {
400027e4:	ca9ff06f          	j	4000248c <z_cbvprintf_impl+0x744>
400027e8:	4002c437          	lui	s0,0x4002c
			bpe = bps + 5;
400027ec:	4002cb37          	lui	s6,0x4002c
400027f0:	d7c40413          	addi	s0,s0,-644 # 4002bd7c <__clz_tab+0x150>
400027f4:	d81b0b13          	addi	s6,s6,-639 # 4002bd81 <__clz_tab+0x155>
		char sign = 0;
400027f8:	00000d93          	li	s11,0
		size_t nj_len = (bpe - bps);
400027fc:	00500513          	li	a0,5
40002800:	d99ff06f          	j	40002598 <z_cbvprintf_impl+0x850>
		} else if (conv->altform_0) {
40002804:	0087f713          	andi	a4,a5,8
40002808:	da0700e3          	beqz	a4,400025a8 <z_cbvprintf_impl+0x860>
			nj_len += 1U;
4000280c:	00150513          	addi	a0,a0,1
40002810:	d99ff06f          	j	400025a8 <z_cbvprintf_impl+0x860>
					OUTC(pad);
40002814:	00812583          	lw	a1,8(sp)
40002818:	00070513          	mv	a0,a4
4000281c:	00e12623          	sw	a4,12(sp)
40002820:	000480e7          	jalr	s1
40002824:	00c12703          	lw	a4,12(sp)
40002828:	de0550e3          	bgez	a0,40002608 <z_cbvprintf_impl+0x8c0>
#undef OUTS
#undef OUTC
}
4000282c:	08c12083          	lw	ra,140(sp)
40002830:	08812403          	lw	s0,136(sp)
40002834:	08412483          	lw	s1,132(sp)
40002838:	08012903          	lw	s2,128(sp)
4000283c:	07c12983          	lw	s3,124(sp)
40002840:	07812a03          	lw	s4,120(sp)
40002844:	07412a83          	lw	s5,116(sp)
40002848:	07012b03          	lw	s6,112(sp)
4000284c:	06c12b83          	lw	s7,108(sp)
40002850:	06812c03          	lw	s8,104(sp)
40002854:	06412c83          	lw	s9,100(sp)
40002858:	06012d03          	lw	s10,96(sp)
4000285c:	05c12d83          	lw	s11,92(sp)
40002860:	09010113          	addi	sp,sp,144
40002864:	00008067          	ret
				char pad = ' ';
40002868:	02000713          	li	a4,32
4000286c:	d99ff06f          	j	40002604 <z_cbvprintf_impl+0x8bc>
					pad = '0';
40002870:	03000713          	li	a4,48
40002874:	d91ff06f          	j	40002604 <z_cbvprintf_impl+0x8bc>
				OUTC('0');
40002878:	00812583          	lw	a1,8(sp)
4000287c:	03000513          	li	a0,48
40002880:	000480e7          	jalr	s1
40002884:	fa0544e3          	bltz	a0,4000282c <z_cbvprintf_impl+0xae4>
40002888:	001d0d13          	addi	s10,s10,1
			while (pad_len-- > 0) {
4000288c:	41ab87b3          	sub	a5,s7,s10
40002890:	fef044e3          	bgtz	a5,40002878 <z_cbvprintf_impl+0xb30>
			OUTS(bps, bpe);
40002894:	00812583          	lw	a1,8(sp)
40002898:	000b0693          	mv	a3,s6
4000289c:	00040613          	mv	a2,s0
400028a0:	00048513          	mv	a0,s1
400028a4:	c28ff0ef          	jal	ra,40001ccc <outs>
400028a8:	f80542e3          	bltz	a0,4000282c <z_cbvprintf_impl+0xae4>
400028ac:	01a50d33          	add	s10,a0,s10
		while (width > 0) {
400028b0:	01aa8ab3          	add	s5,s5,s10
400028b4:	41aa87b3          	sub	a5,s5,s10
400028b8:	bcf05ae3          	blez	a5,4000248c <z_cbvprintf_impl+0x744>
			OUTC(' ');
400028bc:	00812583          	lw	a1,8(sp)
400028c0:	02000513          	li	a0,32
400028c4:	000480e7          	jalr	s1
400028c8:	f60542e3          	bltz	a0,4000282c <z_cbvprintf_impl+0xae4>
400028cc:	001d0d13          	addi	s10,s10,1
			--width;
400028d0:	fe5ff06f          	j	400028b4 <z_cbvprintf_impl+0xb6c>

400028d4 <ring_buf_put_claim>:

#include <zephyr/sys/ring_buffer.h>
#include <string.h>

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
400028d4:	00050713          	mv	a4,a0
	uint32_t free_space, wrap_size;
	int32_t base;

	base = buf->put_base;
400028d8:	00c52883          	lw	a7,12(a0)
	wrap_size = buf->put_head - base;
400028dc:	00452803          	lw	a6,4(a0)
	if (unlikely(wrap_size >= buf->size)) {
400028e0:	01c72783          	lw	a5,28(a4)
	wrap_size = buf->put_head - base;
400028e4:	41180533          	sub	a0,a6,a7
	if (unlikely(wrap_size >= buf->size)) {
400028e8:	00f56663          	bltu	a0,a5,400028f4 <ring_buf_put_claim+0x20>
		/* put_base is not yet adjusted */
		wrap_size -= buf->size;
400028ec:	40f50533          	sub	a0,a0,a5
		base += buf->size;
400028f0:	00f888b3          	add	a7,a7,a5
 *
 * @return Ring buffer free space (in bytes).
 */
static inline uint32_t ring_buf_space_get(struct ring_buf *buf)
{
	return buf->size - (buf->put_head - buf->get_tail);
400028f4:	01472683          	lw	a3,20(a4)
400028f8:	40d806b3          	sub	a3,a6,a3
400028fc:	40d786b3          	sub	a3,a5,a3
	}
	wrap_size = buf->size - wrap_size;

	free_space = ring_buf_space_get(buf);
	size = MIN(size, free_space);
40002900:	00d67463          	bgeu	a2,a3,40002908 <ring_buf_put_claim+0x34>
40002904:	00060693          	mv	a3,a2
	wrap_size = buf->size - wrap_size;
40002908:	40a78533          	sub	a0,a5,a0
	size = MIN(size, wrap_size);
4000290c:	00a6f463          	bgeu	a3,a0,40002914 <ring_buf_put_claim+0x40>
40002910:	00068513          	mv	a0,a3

	*data = &buf->buffer[buf->put_head - base];
40002914:	00072783          	lw	a5,0(a4)
40002918:	41180833          	sub	a6,a6,a7
4000291c:	010787b3          	add	a5,a5,a6
40002920:	00f5a023          	sw	a5,0(a1)
	buf->put_head += size;
40002924:	00472783          	lw	a5,4(a4)
40002928:	00a787b3          	add	a5,a5,a0
4000292c:	00f72223          	sw	a5,4(a4)

	return size;
}
40002930:	00008067          	ret

40002934 <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
	uint32_t finish_space, wrap_size;

	finish_space = buf->put_head - buf->put_tail;
40002934:	00852783          	lw	a5,8(a0)
40002938:	00452703          	lw	a4,4(a0)
4000293c:	40f70733          	sub	a4,a4,a5
	if (unlikely(size > finish_space)) {
40002940:	02b76a63          	bltu	a4,a1,40002974 <ring_buf_put_finish+0x40>
		return -EINVAL;
	}

	buf->put_tail += size;
40002944:	00b785b3          	add	a1,a5,a1
	buf->put_head = buf->put_tail;

	wrap_size = buf->put_tail - buf->put_base;
40002948:	00c52783          	lw	a5,12(a0)
	if (unlikely(wrap_size >= buf->size)) {
4000294c:	01c52703          	lw	a4,28(a0)
	buf->put_tail += size;
40002950:	00b52423          	sw	a1,8(a0)
	buf->put_head = buf->put_tail;
40002954:	00b52223          	sw	a1,4(a0)
	wrap_size = buf->put_tail - buf->put_base;
40002958:	40f585b3          	sub	a1,a1,a5
	if (unlikely(wrap_size >= buf->size)) {
4000295c:	00e5f663          	bgeu	a1,a4,40002968 <ring_buf_put_finish+0x34>
		/* we wrapped: adjust put_base */
		buf->put_base += buf->size;
	}

	return 0;
40002960:	00000513          	li	a0,0
40002964:	00008067          	ret
		buf->put_base += buf->size;
40002968:	00e787b3          	add	a5,a5,a4
4000296c:	00f52623          	sw	a5,12(a0)
40002970:	ff1ff06f          	j	40002960 <ring_buf_put_finish+0x2c>
		return -EINVAL;
40002974:	fea00513          	li	a0,-22
}
40002978:	00008067          	ret

4000297c <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
4000297c:	fd010113          	addi	sp,sp,-48
40002980:	02912223          	sw	s1,36(sp)
40002984:	03212023          	sw	s2,32(sp)
40002988:	01312e23          	sw	s3,28(sp)
4000298c:	01412c23          	sw	s4,24(sp)
40002990:	02112623          	sw	ra,44(sp)
40002994:	02812423          	sw	s0,40(sp)
40002998:	00050a13          	mv	s4,a0
4000299c:	00058913          	mv	s2,a1
400029a0:	00060493          	mv	s1,a2
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
400029a4:	00000993          	li	s3,0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
400029a8:	00048613          	mv	a2,s1
400029ac:	00c10593          	addi	a1,sp,12
400029b0:	000a0513          	mv	a0,s4
400029b4:	f21ff0ef          	jal	ra,400028d4 <ring_buf_put_claim>
400029b8:	00050413          	mv	s0,a0
		memcpy(dst, data, partial_size);
400029bc:	00050613          	mv	a2,a0
400029c0:	00c12503          	lw	a0,12(sp)
400029c4:	00090593          	mv	a1,s2
		total_size += partial_size;
		size -= partial_size;
400029c8:	408484b3          	sub	s1,s1,s0
		memcpy(dst, data, partial_size);
400029cc:	680060ef          	jal	ra,4000904c <memcpy>
		total_size += partial_size;
400029d0:	008989b3          	add	s3,s3,s0
		data += partial_size;
400029d4:	00890933          	add	s2,s2,s0
	} while (size && partial_size);
400029d8:	00048463          	beqz	s1,400029e0 <ring_buf_put+0x64>
400029dc:	fc0416e3          	bnez	s0,400029a8 <ring_buf_put+0x2c>

	err = ring_buf_put_finish(buf, total_size);
400029e0:	00098593          	mv	a1,s3
400029e4:	000a0513          	mv	a0,s4
400029e8:	f4dff0ef          	jal	ra,40002934 <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);
	ARG_UNUSED(err);

	return total_size;
}
400029ec:	02c12083          	lw	ra,44(sp)
400029f0:	02812403          	lw	s0,40(sp)
400029f4:	02412483          	lw	s1,36(sp)
400029f8:	02012903          	lw	s2,32(sp)
400029fc:	01812a03          	lw	s4,24(sp)
40002a00:	00098513          	mv	a0,s3
40002a04:	01c12983          	lw	s3,28(sp)
40002a08:	03010113          	addi	sp,sp,48
40002a0c:	00008067          	ret

40002a10 <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
40002a10:	00050713          	mv	a4,a0
	uint32_t available_size, wrap_size;
	int32_t base;

	base = buf->get_base;
40002a14:	01852883          	lw	a7,24(a0)
	wrap_size = buf->get_head - base;
40002a18:	01052803          	lw	a6,16(a0)
	if (unlikely(wrap_size >= buf->size)) {
40002a1c:	01c72783          	lw	a5,28(a4)
	wrap_size = buf->get_head - base;
40002a20:	41180533          	sub	a0,a6,a7
	if (unlikely(wrap_size >= buf->size)) {
40002a24:	00f56663          	bltu	a0,a5,40002a30 <ring_buf_get_claim+0x20>
		/* get_base is not yet adjusted */
		wrap_size -= buf->size;
40002a28:	40f50533          	sub	a0,a0,a5
		base += buf->size;
40002a2c:	00f888b3          	add	a7,a7,a5
 *
 * @return Ring buffer space used (in bytes).
 */
static inline uint32_t ring_buf_size_get(struct ring_buf *buf)
{
	return buf->put_tail - buf->get_head;
40002a30:	00872683          	lw	a3,8(a4)
40002a34:	410686b3          	sub	a3,a3,a6
	}
	wrap_size = buf->size - wrap_size;

	available_size = ring_buf_size_get(buf);
	size = MIN(size, available_size);
40002a38:	00d67463          	bgeu	a2,a3,40002a40 <ring_buf_get_claim+0x30>
40002a3c:	00060693          	mv	a3,a2
	wrap_size = buf->size - wrap_size;
40002a40:	40a78533          	sub	a0,a5,a0
	size = MIN(size, wrap_size);
40002a44:	00a6f463          	bgeu	a3,a0,40002a4c <ring_buf_get_claim+0x3c>
40002a48:	00068513          	mv	a0,a3

	*data = &buf->buffer[buf->get_head - base];
40002a4c:	00072783          	lw	a5,0(a4)
40002a50:	41180833          	sub	a6,a6,a7
40002a54:	010787b3          	add	a5,a5,a6
40002a58:	00f5a023          	sw	a5,0(a1)
	buf->get_head += size;
40002a5c:	01072783          	lw	a5,16(a4)
40002a60:	00a787b3          	add	a5,a5,a0
40002a64:	00f72823          	sw	a5,16(a4)

	return size;
}
40002a68:	00008067          	ret

40002a6c <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
	uint32_t finish_space, wrap_size;

	finish_space = buf->get_head - buf->get_tail;
40002a6c:	01452783          	lw	a5,20(a0)
40002a70:	01052703          	lw	a4,16(a0)
40002a74:	40f70733          	sub	a4,a4,a5
	if (unlikely(size > finish_space)) {
40002a78:	02b76a63          	bltu	a4,a1,40002aac <ring_buf_get_finish+0x40>
		return -EINVAL;
	}

	buf->get_tail += size;
40002a7c:	00b785b3          	add	a1,a5,a1
	buf->get_head = buf->get_tail;

	wrap_size = buf->get_tail - buf->get_base;
40002a80:	01852783          	lw	a5,24(a0)
	if (unlikely(wrap_size >= buf->size)) {
40002a84:	01c52703          	lw	a4,28(a0)
	buf->get_tail += size;
40002a88:	00b52a23          	sw	a1,20(a0)
	buf->get_head = buf->get_tail;
40002a8c:	00b52823          	sw	a1,16(a0)
	wrap_size = buf->get_tail - buf->get_base;
40002a90:	40f585b3          	sub	a1,a1,a5
	if (unlikely(wrap_size >= buf->size)) {
40002a94:	00e5f663          	bgeu	a1,a4,40002aa0 <ring_buf_get_finish+0x34>
		/* we wrapped: adjust get_base */
		buf->get_base += buf->size;
	}

	return 0;
40002a98:	00000513          	li	a0,0
40002a9c:	00008067          	ret
		buf->get_base += buf->size;
40002aa0:	00e787b3          	add	a5,a5,a4
40002aa4:	00f52c23          	sw	a5,24(a0)
40002aa8:	ff1ff06f          	j	40002a98 <ring_buf_get_finish+0x2c>
		return -EINVAL;
40002aac:	fea00513          	li	a0,-22
}
40002ab0:	00008067          	ret

40002ab4 <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
40002ab4:	fd010113          	addi	sp,sp,-48
40002ab8:	02912223          	sw	s1,36(sp)
40002abc:	03212023          	sw	s2,32(sp)
40002ac0:	01312e23          	sw	s3,28(sp)
40002ac4:	01412c23          	sw	s4,24(sp)
40002ac8:	02112623          	sw	ra,44(sp)
40002acc:	02812423          	sw	s0,40(sp)
40002ad0:	00050a13          	mv	s4,a0
40002ad4:	00058493          	mv	s1,a1
40002ad8:	00060913          	mv	s2,a2
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
40002adc:	00000993          	li	s3,0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
40002ae0:	00090613          	mv	a2,s2
40002ae4:	00c10593          	addi	a1,sp,12
40002ae8:	000a0513          	mv	a0,s4
40002aec:	f25ff0ef          	jal	ra,40002a10 <ring_buf_get_claim>
40002af0:	00050413          	mv	s0,a0
		if (data) {
40002af4:	00048c63          	beqz	s1,40002b0c <ring_buf_get+0x58>
			memcpy(data, src, partial_size);
40002af8:	00c12583          	lw	a1,12(sp)
40002afc:	00050613          	mv	a2,a0
40002b00:	00048513          	mv	a0,s1
40002b04:	548060ef          	jal	ra,4000904c <memcpy>
			data += partial_size;
40002b08:	008484b3          	add	s1,s1,s0
		}
		total_size += partial_size;
		size -= partial_size;
40002b0c:	40890933          	sub	s2,s2,s0
		total_size += partial_size;
40002b10:	008989b3          	add	s3,s3,s0
	} while (size && partial_size);
40002b14:	00090463          	beqz	s2,40002b1c <ring_buf_get+0x68>
40002b18:	fc0414e3          	bnez	s0,40002ae0 <ring_buf_get+0x2c>

	err = ring_buf_get_finish(buf, total_size);
40002b1c:	00098593          	mv	a1,s3
40002b20:	000a0513          	mv	a0,s4
40002b24:	f49ff0ef          	jal	ra,40002a6c <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);
	ARG_UNUSED(err);

	return total_size;
}
40002b28:	02c12083          	lw	ra,44(sp)
40002b2c:	02812403          	lw	s0,40(sp)
40002b30:	02412483          	lw	s1,36(sp)
40002b34:	02012903          	lw	s2,32(sp)
40002b38:	01812a03          	lw	s4,24(sp)
40002b3c:	00098513          	mv	a0,s3
40002b40:	01c12983          	lw	s3,28(sp)
40002b44:	03010113          	addi	sp,sp,48
40002b48:	00008067          	ret

40002b4c <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_EXPERIMENTAL, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
40002b4c:	00008067          	ret

40002b50 <cmd_kernel_version>:
#define THREAD_MAX_NAM_LEN 10
#endif

static int cmd_kernel_version(const struct shell *sh,
			      size_t argc, char **argv)
{
40002b50:	ff010113          	addi	sp,sp,-16
40002b54:	00112623          	sw	ra,12(sp)
40002b58:	00812423          	sw	s0,8(sp)
40002b5c:	00050413          	mv	s0,a0
	uint32_t version = sys_kernel_version_get();
40002b60:	269250ef          	jal	ra,400285c8 <sys_kernel_version_get>

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(sh, "Zephyr version %d.%d.%d",
40002b64:	00855793          	srli	a5,a0,0x8
40002b68:	01055713          	srli	a4,a0,0x10
40002b6c:	4002c637          	lui	a2,0x4002c
40002b70:	01855693          	srli	a3,a0,0x18
40002b74:	0ff7f793          	zext.b	a5,a5
40002b78:	00040513          	mv	a0,s0
40002b7c:	0ff77713          	zext.b	a4,a4
40002b80:	dfc60613          	addi	a2,a2,-516 # 4002bdfc <__clz_tab+0x1d0>
40002b84:	00800593          	li	a1,8
40002b88:	128030ef          	jal	ra,40005cb0 <shell_fprintf>
		      SYS_KERNEL_VER_MAJOR(version),
		      SYS_KERNEL_VER_MINOR(version),
		      SYS_KERNEL_VER_PATCHLEVEL(version));
	return 0;
}
40002b8c:	00c12083          	lw	ra,12(sp)
40002b90:	00812403          	lw	s0,8(sp)
40002b94:	00000513          	li	a0,0
40002b98:	01010113          	addi	sp,sp,16
40002b9c:	00008067          	ret

40002ba0 <cmd_kernel_uptime>:

static int cmd_kernel_uptime(const struct shell *sh,
			     size_t argc, char **argv)
{
40002ba0:	ff010113          	addi	sp,sp,-16
40002ba4:	00812423          	sw	s0,8(sp)
40002ba8:	00112623          	sw	ra,12(sp)
40002bac:	00050413          	mv	s0,a0
		(void) arch_syscall_invoke1((uintptr_t)&ret64, K_SYSCALL_K_UPTIME_TICKS);
		return (int64_t) ret64;
	}
#endif
	compiler_barrier();
	return z_impl_k_uptime_ticks();
40002bb0:	004280ef          	jal	ra,4002abb4 <z_impl_k_uptime_ticks>
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(sh, "Uptime: %u ms", k_uptime_get_32());
40002bb4:	00a00693          	li	a3,10
40002bb8:	02a686b3          	mul	a3,a3,a0
40002bbc:	4002c637          	lui	a2,0x4002c
40002bc0:	00040513          	mv	a0,s0
40002bc4:	e1860613          	addi	a2,a2,-488 # 4002be18 <__clz_tab+0x1ec>
40002bc8:	00800593          	li	a1,8
40002bcc:	0e4030ef          	jal	ra,40005cb0 <shell_fprintf>
	return 0;
}
40002bd0:	00c12083          	lw	ra,12(sp)
40002bd4:	00812403          	lw	s0,8(sp)
40002bd8:	00000513          	li	a0,0
40002bdc:	01010113          	addi	sp,sp,16
40002be0:	00008067          	ret

40002be4 <cmd_kernel_threads>:

}

static int cmd_kernel_threads(const struct shell *sh,
			      size_t argc, char **argv)
{
40002be4:	ff010113          	addi	sp,sp,-16
40002be8:	00112623          	sw	ra,12(sp)
40002bec:	00812423          	sw	s0,8(sp)
40002bf0:	00050413          	mv	s0,a0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(sh, "Scheduler: %u since last call", sys_clock_elapsed());
40002bf4:	161230ef          	jal	ra,40026554 <sys_clock_elapsed>
40002bf8:	4002c637          	lui	a2,0x4002c
40002bfc:	00050693          	mv	a3,a0
40002c00:	e2860613          	addi	a2,a2,-472 # 4002be28 <__clz_tab+0x1fc>
40002c04:	00040513          	mv	a0,s0
40002c08:	00800593          	li	a1,8
40002c0c:	0a4030ef          	jal	ra,40005cb0 <shell_fprintf>
	shell_print(sh, "Threads:");
40002c10:	4002c637          	lui	a2,0x4002c
40002c14:	00040513          	mv	a0,s0
40002c18:	e4860613          	addi	a2,a2,-440 # 4002be48 <__clz_tab+0x21c>
40002c1c:	00800593          	li	a1,8
40002c20:	090030ef          	jal	ra,40005cb0 <shell_fprintf>
	k_thread_foreach(shell_tdata_dump, (void *)sh);
40002c24:	40003537          	lui	a0,0x40003
40002c28:	00040593          	mv	a1,s0
40002c2c:	c4850513          	addi	a0,a0,-952 # 40002c48 <shell_tdata_dump>
40002c30:	438250ef          	jal	ra,40028068 <k_thread_foreach>
	return 0;
}
40002c34:	00c12083          	lw	ra,12(sp)
40002c38:	00812403          	lw	s0,8(sp)
40002c3c:	00000513          	li	a0,0
40002c40:	01010113          	addi	sp,sp,16
40002c44:	00008067          	ret

40002c48 <shell_tdata_dump>:
{
40002c48:	fb010113          	addi	sp,sp,-80
40002c4c:	04812423          	sw	s0,72(sp)
40002c50:	04912223          	sw	s1,68(sp)
40002c54:	04112623          	sw	ra,76(sp)
40002c58:	05212023          	sw	s2,64(sp)
	size_t size = thread->stack_info.size;
40002c5c:	0b452903          	lw	s2,180(a0)
{
40002c60:	00050413          	mv	s0,a0
40002c64:	00058493          	mv	s1,a1
	tname = k_thread_name_get(thread);
40002c68:	4fc250ef          	jal	ra,40028164 <k_thread_name_get>
40002c6c:	00a12623          	sw	a0,12(sp)
	return z_impl_z_current_get();
40002c70:	035270ef          	jal	ra,4002a4a4 <z_impl_z_current_get>
	shell_print(sh, "%s%p %-10s",
40002c74:	00c12783          	lw	a5,12(sp)
40002c78:	0ca40063          	beq	s0,a0,40002d38 <shell_tdata_dump+0xf0>
40002c7c:	4002e6b7          	lui	a3,0x4002e
40002c80:	6e068693          	addi	a3,a3,1760 # 4002e6e0 <CSWTCH.14405+0x1104>
40002c84:	00079663          	bnez	a5,40002c90 <shell_tdata_dump+0x48>
40002c88:	4002c7b7          	lui	a5,0x4002c
40002c8c:	e5878793          	addi	a5,a5,-424 # 4002be58 <__clz_tab+0x22c>
40002c90:	4002c637          	lui	a2,0x4002c
40002c94:	00040713          	mv	a4,s0
40002c98:	00048513          	mv	a0,s1
40002c9c:	e5c60613          	addi	a2,a2,-420 # 4002be5c <__clz_tab+0x230>
40002ca0:	00800593          	li	a1,8
40002ca4:	00c030ef          	jal	ra,40005cb0 <shell_fprintf>
	shell_print(sh, "\toptions: 0x%x, priority: %d timeout: %" PRId64,
40002ca8:	02842803          	lw	a6,40(s0)
40002cac:	02c42883          	lw	a7,44(s0)
40002cb0:	00e40703          	lb	a4,14(s0)
40002cb4:	00c44683          	lbu	a3,12(s0)
40002cb8:	4002c637          	lui	a2,0x4002c
40002cbc:	00048513          	mv	a0,s1
40002cc0:	e6860613          	addi	a2,a2,-408 # 4002be68 <__clz_tab+0x23c>
40002cc4:	00800593          	li	a1,8
40002cc8:	7e9020ef          	jal	ra,40005cb0 <shell_fprintf>
	shell_print(sh, "\tstate: %s, entry: %p",
40002ccc:	02010593          	addi	a1,sp,32
40002cd0:	02000613          	li	a2,32
40002cd4:	00040513          	mv	a0,s0
40002cd8:	494250ef          	jal	ra,4002816c <k_thread_state_str>
40002cdc:	07842703          	lw	a4,120(s0)
40002ce0:	4002c637          	lui	a2,0x4002c
40002ce4:	00050693          	mv	a3,a0
40002ce8:	e9460613          	addi	a2,a2,-364 # 4002be94 <__clz_tab+0x268>
40002cec:	00800593          	li	a1,8
40002cf0:	00048513          	mv	a0,s1
40002cf4:	7bd020ef          	jal	ra,40005cb0 <shell_fprintf>
	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
40002cf8:	01c10593          	addi	a1,sp,28
40002cfc:	00040513          	mv	a0,s0
40002d00:	0b9250ef          	jal	ra,400285b8 <z_impl_k_thread_stack_space_get>
40002d04:	00050693          	mv	a3,a0
	if (ret) {
40002d08:	02050e63          	beqz	a0,40002d44 <shell_tdata_dump+0xfc>
		shell_print(sh,
40002d0c:	4002c637          	lui	a2,0x4002c
40002d10:	eac60613          	addi	a2,a2,-340 # 4002beac <__clz_tab+0x280>
40002d14:	00800593          	li	a1,8
40002d18:	00048513          	mv	a0,s1
40002d1c:	795020ef          	jal	ra,40005cb0 <shell_fprintf>
}
40002d20:	04c12083          	lw	ra,76(sp)
40002d24:	04812403          	lw	s0,72(sp)
40002d28:	04412483          	lw	s1,68(sp)
40002d2c:	04012903          	lw	s2,64(sp)
40002d30:	05010113          	addi	sp,sp,80
40002d34:	00008067          	ret
	shell_print(sh, "%s%p %-10s",
40002d38:	4002c6b7          	lui	a3,0x4002c
40002d3c:	e5468693          	addi	a3,a3,-428 # 4002be54 <__clz_tab+0x228>
40002d40:	f45ff06f          	j	40002c84 <shell_tdata_dump+0x3c>
		pcnt = ((size - unused) * 100U) / size;
40002d44:	01c12703          	lw	a4,28(sp)
40002d48:	06400893          	li	a7,100
		shell_print(sh,
40002d4c:	4002c637          	lui	a2,0x4002c
		pcnt = ((size - unused) * 100U) / size;
40002d50:	40e907b3          	sub	a5,s2,a4
40002d54:	031788b3          	mul	a7,a5,a7
		shell_print(sh,
40002d58:	00090813          	mv	a6,s2
40002d5c:	00090693          	mv	a3,s2
40002d60:	edc60613          	addi	a2,a2,-292 # 4002bedc <__clz_tab+0x2b0>
40002d64:	00800593          	li	a1,8
40002d68:	00048513          	mv	a0,s1
40002d6c:	0328d8b3          	divu	a7,a7,s2
40002d70:	741020ef          	jal	ra,40005cb0 <shell_fprintf>
}
40002d74:	fadff06f          	j	40002d20 <shell_tdata_dump+0xd8>

40002d78 <cmd_kernel_stacks>:
K_KERNEL_STACK_ARRAY_DECLARE(z_interrupt_stacks, CONFIG_MP_MAX_NUM_CPUS,
			     CONFIG_ISR_STACK_SIZE);

static int cmd_kernel_stacks(const struct shell *sh,
			     size_t argc, char **argv)
{
40002d78:	fb010113          	addi	sp,sp,-80
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
	char pad[THREAD_MAX_NAM_LEN] = { 0 };
40002d7c:	01c00613          	li	a2,28
{
40002d80:	04912223          	sw	s1,68(sp)
	char pad[THREAD_MAX_NAM_LEN] = { 0 };
40002d84:	00000593          	li	a1,0
{
40002d88:	00050493          	mv	s1,a0
	char pad[THREAD_MAX_NAM_LEN] = { 0 };
40002d8c:	02410513          	addi	a0,sp,36
{
40002d90:	04112623          	sw	ra,76(sp)
40002d94:	04812423          	sw	s0,72(sp)
40002d98:	05212023          	sw	s2,64(sp)
	char pad[THREAD_MAX_NAM_LEN] = { 0 };
40002d9c:	02012023          	sw	zero,32(sp)

	memset(pad, ' ', MAX((THREAD_MAX_NAM_LEN - strlen("IRQ 00")), 1));
40002da0:	4002c937          	lui	s2,0x4002c
	char pad[THREAD_MAX_NAM_LEN] = { 0 };
40002da4:	2cc060ef          	jal	ra,40009070 <memset>
	memset(pad, ' ', MAX((THREAD_MAX_NAM_LEN - strlen("IRQ 00")), 1));
40002da8:	f1490513          	addi	a0,s2,-236 # 4002bf14 <__clz_tab+0x2e8>
40002dac:	17c060ef          	jal	ra,40008f28 <strlen>
40002db0:	02000413          	li	s0,32
40002db4:	40a40533          	sub	a0,s0,a0
40002db8:	00100793          	li	a5,1
40002dbc:	00100613          	li	a2,1
40002dc0:	00a7f863          	bgeu	a5,a0,40002dd0 <cmd_kernel_stacks+0x58>
40002dc4:	f1490513          	addi	a0,s2,-236
40002dc8:	160060ef          	jal	ra,40008f28 <strlen>
40002dcc:	40a40633          	sub	a2,s0,a0
40002dd0:	02000593          	li	a1,32
40002dd4:	02010513          	addi	a0,sp,32
40002dd8:	298060ef          	jal	ra,40009070 <memset>

	k_thread_foreach(shell_stack_dump, (void *)sh);
40002ddc:	40003537          	lui	a0,0x40003
40002de0:	00048593          	mv	a1,s1
40002de4:	f3c50513          	addi	a0,a0,-196 # 40002f3c <shell_stack_dump>
40002de8:	280250ef          	jal	ra,40028068 <k_thread_foreach>

	for (int i = 0; i < num_cpus; i++) {
		size_t unused;
		const uint8_t *buf = Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]);
		size_t size = K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[i]);
		int err = z_stack_space_get(buf, size, &unused);
40002dec:	00001437          	lui	s0,0x1
40002df0:	40034937          	lui	s2,0x40034
40002df4:	01c10613          	addi	a2,sp,28
40002df8:	80040593          	addi	a1,s0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
40002dfc:	57090513          	addi	a0,s2,1392 # 40034570 <z_interrupt_stacks>
40002e00:	78c250ef          	jal	ra,4002858c <z_stack_space_get>

		(void)err;
		__ASSERT_NO_MSG(err == 0);

		shell_print(sh,
40002e04:	01c12883          	lw	a7,28(sp)
40002e08:	80040813          	addi	a6,s0,-2048
40002e0c:	06400793          	li	a5,100
40002e10:	41180733          	sub	a4,a6,a7
40002e14:	02f707b3          	mul	a5,a4,a5
40002e18:	4002c637          	lui	a2,0x4002c
40002e1c:	00e12023          	sw	a4,0(sp)
40002e20:	00048513          	mv	a0,s1
40002e24:	01012223          	sw	a6,4(sp)
40002e28:	57090693          	addi	a3,s2,1392
40002e2c:	00000713          	li	a4,0
40002e30:	f1c60613          	addi	a2,a2,-228 # 4002bf1c <__clz_tab+0x2f0>
40002e34:	00800593          	li	a1,8
40002e38:	00b7d793          	srli	a5,a5,0xb
40002e3c:	00f12423          	sw	a5,8(sp)
40002e40:	02010793          	addi	a5,sp,32
40002e44:	66d020ef          	jal	ra,40005cb0 <shell_fprintf>
			    &z_interrupt_stacks[i], i, pad, size, unused, size - unused, size,
			    ((size - unused) * 100U) / size);
	}

	return 0;
}
40002e48:	04c12083          	lw	ra,76(sp)
40002e4c:	04812403          	lw	s0,72(sp)
40002e50:	04412483          	lw	s1,68(sp)
40002e54:	04012903          	lw	s2,64(sp)
40002e58:	00000513          	li	a0,0
40002e5c:	05010113          	addi	sp,sp,80
40002e60:	00008067          	ret

40002e64 <cmd_kernel_cycles>:
{
40002e64:	ff010113          	addi	sp,sp,-16
40002e68:	00112623          	sw	ra,12(sp)
40002e6c:	00812423          	sw	s0,8(sp)
40002e70:	00050413          	mv	s0,a0

extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
40002e74:	6bc230ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
	shell_print(sh, "cycles: %u hw cycles", k_cycle_get_32());
40002e78:	4002c637          	lui	a2,0x4002c
40002e7c:	00050693          	mv	a3,a0
40002e80:	f6860613          	addi	a2,a2,-152 # 4002bf68 <__clz_tab+0x33c>
40002e84:	00040513          	mv	a0,s0
40002e88:	00800593          	li	a1,8
40002e8c:	625020ef          	jal	ra,40005cb0 <shell_fprintf>
}
40002e90:	00c12083          	lw	ra,12(sp)
40002e94:	00812403          	lw	s0,8(sp)
40002e98:	00000513          	li	a0,0
40002e9c:	01010113          	addi	sp,sp,16
40002ea0:	00008067          	ret

40002ea4 <cmd_kernel_sleep>:
}
#endif

static int cmd_kernel_sleep(const struct shell *sh,
			    size_t argc, char **argv)
{
40002ea4:	fe010113          	addi	sp,sp,-32
40002ea8:	00812c23          	sw	s0,24(sp)
40002eac:	00912a23          	sw	s1,20(sp)
40002eb0:	00060793          	mv	a5,a2
40002eb4:	00112e23          	sw	ra,28(sp)
40002eb8:	00050493          	mv	s1,a0
	ARG_UNUSED(argc);

	uint32_t ms;
	int err = 0;

	ms = shell_strtoul(argv[1], 10, &err);
40002ebc:	0047a503          	lw	a0,4(a5)
40002ec0:	00c10613          	addi	a2,sp,12
40002ec4:	00a00593          	li	a1,10
	int err = 0;
40002ec8:	00012623          	sw	zero,12(sp)
	ms = shell_strtoul(argv[1], 10, &err);
40002ecc:	321030ef          	jal	ra,400069ec <shell_strtoul>

	if (!err) {
40002ed0:	00c12403          	lw	s0,12(sp)
40002ed4:	04041463          	bnez	s0,40002f1c <cmd_kernel_sleep+0x78>
40002ed8:	00050793          	mv	a5,a0
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline int32_t k_msleep(int32_t ms)
{
	return k_sleep(Z_TIMEOUT_MS(ms));
40002edc:	00055463          	bgez	a0,40002ee4 <cmd_kernel_sleep+0x40>
40002ee0:	00000793          	li	a5,0
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
40002ee4:	00978513          	addi	a0,a5,9
40002ee8:	41f7d593          	srai	a1,a5,0x1f
40002eec:	00f537b3          	sltu	a5,a0,a5
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
40002ef0:	00a00613          	li	a2,10
40002ef4:	00000693          	li	a3,0
40002ef8:	00b785b3          	add	a1,a5,a1
40002efc:	bbcfd0ef          	jal	ra,400002b8 <__udivdi3>
	return z_impl_k_sleep(timeout);
40002f00:	564270ef          	jal	ra,4002a464 <z_impl_k_sleep>
		shell_error(sh, "Unable to parse input (err %d)", err);
		return err;
	}

	return 0;
}
40002f04:	01c12083          	lw	ra,28(sp)
40002f08:	00040513          	mv	a0,s0
40002f0c:	01812403          	lw	s0,24(sp)
40002f10:	01412483          	lw	s1,20(sp)
40002f14:	02010113          	addi	sp,sp,32
40002f18:	00008067          	ret
		shell_error(sh, "Unable to parse input (err %d)", err);
40002f1c:	4002c637          	lui	a2,0x4002c
40002f20:	00040693          	mv	a3,s0
40002f24:	f8060613          	addi	a2,a2,-128 # 4002bf80 <__clz_tab+0x354>
40002f28:	00100593          	li	a1,1
40002f2c:	00048513          	mv	a0,s1
40002f30:	581020ef          	jal	ra,40005cb0 <shell_fprintf>
		return err;
40002f34:	00c12403          	lw	s0,12(sp)
40002f38:	fcdff06f          	j	40002f04 <cmd_kernel_sleep+0x60>

40002f3c <shell_stack_dump>:
{
40002f3c:	fd010113          	addi	sp,sp,-48
40002f40:	02812423          	sw	s0,40(sp)
40002f44:	02912223          	sw	s1,36(sp)
40002f48:	02112623          	sw	ra,44(sp)
40002f4c:	03212023          	sw	s2,32(sp)
	size_t size = thread->stack_info.size;
40002f50:	0b452903          	lw	s2,180(a0)
{
40002f54:	00050413          	mv	s0,a0
40002f58:	00058493          	mv	s1,a1
	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
40002f5c:	01c10593          	addi	a1,sp,28
40002f60:	658250ef          	jal	ra,400285b8 <z_impl_k_thread_stack_space_get>
	if (ret) {
40002f64:	02050a63          	beqz	a0,40002f98 <shell_stack_dump+0x5c>
		shell_print(sh,
40002f68:	4002c637          	lui	a2,0x4002c
40002f6c:	00050693          	mv	a3,a0
40002f70:	eac60613          	addi	a2,a2,-340 # 4002beac <__clz_tab+0x280>
40002f74:	00800593          	li	a1,8
40002f78:	00048513          	mv	a0,s1
40002f7c:	535020ef          	jal	ra,40005cb0 <shell_fprintf>
}
40002f80:	02c12083          	lw	ra,44(sp)
40002f84:	02812403          	lw	s0,40(sp)
40002f88:	02412483          	lw	s1,36(sp)
40002f8c:	02012903          	lw	s2,32(sp)
40002f90:	03010113          	addi	sp,sp,48
40002f94:	00008067          	ret
	tname = k_thread_name_get((struct k_thread *)thread);
40002f98:	00040513          	mv	a0,s0
40002f9c:	1c8250ef          	jal	ra,40028164 <k_thread_name_get>
	pcnt = ((size - unused) * 100U) / size;
40002fa0:	01c12803          	lw	a6,28(sp)
40002fa4:	06400693          	li	a3,100
	tname = k_thread_name_get((struct k_thread *)thread);
40002fa8:	00050713          	mv	a4,a0
	pcnt = ((size - unused) * 100U) / size;
40002fac:	410908b3          	sub	a7,s2,a6
40002fb0:	02d886b3          	mul	a3,a7,a3
40002fb4:	0326d6b3          	divu	a3,a3,s2
	shell_print(
40002fb8:	00051663          	bnez	a0,40002fc4 <shell_stack_dump+0x88>
40002fbc:	4002c737          	lui	a4,0x4002c
40002fc0:	e5870713          	addi	a4,a4,-424 # 4002be58 <__clz_tab+0x22c>
40002fc4:	4002c637          	lui	a2,0x4002c
40002fc8:	00d12223          	sw	a3,4(sp)
40002fcc:	01212023          	sw	s2,0(sp)
40002fd0:	00090793          	mv	a5,s2
40002fd4:	00040693          	mv	a3,s0
40002fd8:	fa060613          	addi	a2,a2,-96 # 4002bfa0 <__clz_tab+0x374>
40002fdc:	00800593          	li	a1,8
40002fe0:	00048513          	mv	a0,s1
40002fe4:	4cd020ef          	jal	ra,40005cb0 <shell_fprintf>
40002fe8:	f99ff06f          	j	40002f80 <shell_stack_dump+0x44>

40002fec <get_device_name>:
};

static const char *get_device_name(const struct device *dev,
				   char *buf,
				   size_t len)
{
40002fec:	ff010113          	addi	sp,sp,-16
40002ff0:	00812423          	sw	s0,8(sp)
40002ff4:	00112623          	sw	ra,12(sp)
40002ff8:	00050693          	mv	a3,a0
	const char *name = dev->name;
40002ffc:	00052503          	lw	a0,0(a0)
{
40003000:	00058413          	mv	s0,a1
40003004:	00060593          	mv	a1,a2

	if ((name == NULL) || (name[0] == 0)) {
40003008:	00050663          	beqz	a0,40003014 <get_device_name+0x28>
4000300c:	00054783          	lbu	a5,0(a0)
40003010:	00079c63          	bnez	a5,40003028 <get_device_name+0x3c>
		snprintf(buf, len, "[%p]", dev);
40003014:	4002c637          	lui	a2,0x4002c
40003018:	13060613          	addi	a2,a2,304 # 4002c130 <shell_sub_kernel+0x8c>
4000301c:	00040513          	mv	a0,s0
40003020:	0e4060ef          	jal	ra,40009104 <snprintf>
		name = buf;
40003024:	00040513          	mv	a0,s0
	}

	return name;
}
40003028:	00c12083          	lw	ra,12(sp)
4000302c:	00812403          	lw	s0,8(sp)
40003030:	01010113          	addi	sp,sp,16
40003034:	00008067          	ret

40003038 <cmd_device_list_visitor>:
	size_t buf_size;
};

static int cmd_device_list_visitor(const struct device *dev,
				   void *context)
{
40003038:	ff010113          	addi	sp,sp,-16
4000303c:	00112623          	sw	ra,12(sp)
40003040:	00812423          	sw	s0,8(sp)
	const struct cmd_device_list_visitor_context *ctx = context;

	shell_fprintf(ctx->sh, SHELL_NORMAL, "  requires: %s\n",
40003044:	0005a403          	lw	s0,0(a1)
40003048:	0085a603          	lw	a2,8(a1)
4000304c:	0045a583          	lw	a1,4(a1)
40003050:	f9dff0ef          	jal	ra,40002fec <get_device_name>
40003054:	4002c637          	lui	a2,0x4002c
40003058:	00050693          	mv	a3,a0
4000305c:	13860613          	addi	a2,a2,312 # 4002c138 <shell_sub_kernel+0x94>
40003060:	00040513          	mv	a0,s0
40003064:	00800593          	li	a1,8
40003068:	449020ef          	jal	ra,40005cb0 <shell_fprintf>
		      get_device_name(dev, ctx->buf, ctx->buf_size));

	return 0;
}
4000306c:	00c12083          	lw	ra,12(sp)
40003070:	00812403          	lw	s0,8(sp)
40003074:	00000513          	li	a0,0
40003078:	01010113          	addi	sp,sp,16
4000307c:	00008067          	ret

40003080 <cmd_device_list>:

static int cmd_device_list(const struct shell *sh,
			   size_t argc, char **argv)
{
40003080:	fa010113          	addi	sp,sp,-96
40003084:	04912a23          	sw	s1,84(sp)
40003088:	00050493          	mv	s1,a0
	const struct device *devlist;
	size_t devcnt = z_device_get_all_static(&devlist);
4000308c:	00c10513          	addi	a0,sp,12
{
40003090:	04112e23          	sw	ra,92(sp)
40003094:	04812c23          	sw	s0,88(sp)
40003098:	05212823          	sw	s2,80(sp)
4000309c:	05312623          	sw	s3,76(sp)
400030a0:	05412423          	sw	s4,72(sp)
400030a4:	05512223          	sw	s5,68(sp)
400030a8:	05612023          	sw	s6,64(sp)
400030ac:	03712e23          	sw	s7,60(sp)
400030b0:	03812c23          	sw	s8,56(sp)
	size_t devcnt = z_device_get_all_static(&devlist);
400030b4:	001240ef          	jal	ra,400278b4 <z_device_get_all_static>
	const struct device *devlist_end = devlist + devcnt;
400030b8:	01800793          	li	a5,24
400030bc:	02f50533          	mul	a0,a0,a5
400030c0:	00c12903          	lw	s2,12(sp)
	const struct device *dev;

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_fprintf(sh, SHELL_NORMAL, "devices:\n");
400030c4:	4002c637          	lui	a2,0x4002c
400030c8:	15c60613          	addi	a2,a2,348 # 4002c15c <shell_sub_kernel+0xb8>
400030cc:	00800593          	li	a1,8
		const char *name = get_device_name(dev, buf, sizeof(buf));
		const char *state = "READY";

		shell_fprintf(sh, SHELL_NORMAL, "- %s", name);
		if (!device_is_ready(dev)) {
			state = "DISABLED";
400030d0:	4002c9b7          	lui	s3,0x4002c
		const char *state = "READY";
400030d4:	4002ca37          	lui	s4,0x4002c
		const char *name = get_device_name(dev, buf, sizeof(buf));
400030d8:	01c10a93          	addi	s5,sp,28
		shell_fprintf(sh, SHELL_NORMAL, "- %s", name);
400030dc:	4002cb37          	lui	s6,0x4002c
			state = "DISABLED";
400030e0:	15098993          	addi	s3,s3,336 # 4002c150 <shell_sub_kernel+0xac>
	const struct device *devlist_end = devlist + devcnt;
400030e4:	00a90933          	add	s2,s2,a0
	shell_fprintf(sh, SHELL_NORMAL, "devices:\n");
400030e8:	00048513          	mv	a0,s1
400030ec:	3c5020ef          	jal	ra,40005cb0 <shell_fprintf>
	for (dev = devlist; dev < devlist_end; dev++) {
400030f0:	00c12403          	lw	s0,12(sp)
		const char *state = "READY";
400030f4:	148a0a13          	addi	s4,s4,328 # 4002c148 <shell_sub_kernel+0xa4>
				state = pm_device_state_str(st);
			}
#endif /* CONFIG_PM_DEVICE */
		}

		shell_fprintf(sh, SHELL_NORMAL, " (%s)\n", state);
400030f8:	4002cbb7          	lui	s7,0x4002c
				.sh = sh,
				.buf = buf,
				.buf_size = sizeof(buf),
			};

			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
400030fc:	40003c37          	lui	s8,0x40003
	for (dev = devlist; dev < devlist_end; dev++) {
40003100:	03246c63          	bltu	s0,s2,40003138 <cmd_device_list+0xb8>
		}
	}

	return 0;
}
40003104:	05c12083          	lw	ra,92(sp)
40003108:	05812403          	lw	s0,88(sp)
4000310c:	05412483          	lw	s1,84(sp)
40003110:	05012903          	lw	s2,80(sp)
40003114:	04c12983          	lw	s3,76(sp)
40003118:	04812a03          	lw	s4,72(sp)
4000311c:	04412a83          	lw	s5,68(sp)
40003120:	04012b03          	lw	s6,64(sp)
40003124:	03c12b83          	lw	s7,60(sp)
40003128:	03812c03          	lw	s8,56(sp)
4000312c:	00000513          	li	a0,0
40003130:	06010113          	addi	sp,sp,96
40003134:	00008067          	ret
		const char *name = get_device_name(dev, buf, sizeof(buf));
40003138:	000a8593          	mv	a1,s5
4000313c:	01400613          	li	a2,20
40003140:	00040513          	mv	a0,s0
40003144:	ea9ff0ef          	jal	ra,40002fec <get_device_name>
40003148:	00050693          	mv	a3,a0
		shell_fprintf(sh, SHELL_NORMAL, "- %s", name);
4000314c:	168b0613          	addi	a2,s6,360 # 4002c168 <shell_sub_kernel+0xc4>
40003150:	00800593          	li	a1,8
40003154:	00048513          	mv	a0,s1
40003158:	359020ef          	jal	ra,40005cb0 <shell_fprintf>
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
4000315c:	00040513          	mv	a0,s0
40003160:	780240ef          	jal	ra,400278e0 <z_device_is_ready>
			state = "DISABLED";
40003164:	00098693          	mv	a3,s3
		if (!device_is_ready(dev)) {
40003168:	00050463          	beqz	a0,40003170 <cmd_device_list+0xf0>
		const char *state = "READY";
4000316c:	000a0693          	mv	a3,s4
		shell_fprintf(sh, SHELL_NORMAL, " (%s)\n", state);
40003170:	170b8613          	addi	a2,s7,368 # 4002c170 <shell_sub_kernel+0xcc>
40003174:	00800593          	li	a1,8
40003178:	00048513          	mv	a0,s1
4000317c:	335020ef          	jal	ra,40005cb0 <shell_fprintf>
			struct cmd_device_list_visitor_context ctx = {
40003180:	01400793          	li	a5,20
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
40003184:	00040513          	mv	a0,s0
40003188:	01010613          	addi	a2,sp,16
4000318c:	038c0593          	addi	a1,s8,56 # 40003038 <cmd_device_list_visitor>
			struct cmd_device_list_visitor_context ctx = {
40003190:	00912823          	sw	s1,16(sp)
40003194:	01512a23          	sw	s5,20(sp)
40003198:	00f12c23          	sw	a5,24(sp)
	for (dev = devlist; dev < devlist_end; dev++) {
4000319c:	01840413          	addi	s0,s0,24
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
400031a0:	76c240ef          	jal	ra,4002790c <device_required_foreach>
	for (dev = devlist; dev < devlist_end; dev++) {
400031a4:	f5dff06f          	j	40003100 <cmd_device_list+0x80>

400031a8 <device_get_config_level>:
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
400031a8:	00259713          	slli	a4,a1,0x2
400031ac:	4002c7b7          	lui	a5,0x4002c
400031b0:	00158593          	addi	a1,a1,1
400031b4:	28478793          	addi	a5,a5,644 # 4002c284 <levels>
400031b8:	00259593          	slli	a1,a1,0x2
{
400031bc:	fc010113          	addi	sp,sp,-64
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
400031c0:	00e78733          	add	a4,a5,a4
400031c4:	00b787b3          	add	a5,a5,a1
{
400031c8:	02812c23          	sw	s0,56(sp)
400031cc:	03412423          	sw	s4,40(sp)
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
400031d0:	00072403          	lw	s0,0(a4)
400031d4:	0007aa03          	lw	s4,0(a5)
{
400031d8:	03212823          	sw	s2,48(sp)
400031dc:	03312623          	sw	s3,44(sp)
400031e0:	03512223          	sw	s5,36(sp)
400031e4:	02112e23          	sw	ra,60(sp)
400031e8:	02912a23          	sw	s1,52(sp)
400031ec:	00050913          	mv	s2,a0
	bool devices = false;
400031f0:	00000993          	li	s3,0
			shell_fprintf(sh, SHELL_NORMAL, "- %s\n",
400031f4:	4002cab7          	lui	s5,0x4002c
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
400031f8:	03446663          	bltu	s0,s4,40003224 <device_get_config_level+0x7c>
}
400031fc:	03c12083          	lw	ra,60(sp)
40003200:	03812403          	lw	s0,56(sp)
40003204:	03412483          	lw	s1,52(sp)
40003208:	03012903          	lw	s2,48(sp)
4000320c:	02812a03          	lw	s4,40(sp)
40003210:	02412a83          	lw	s5,36(sp)
40003214:	00098513          	mv	a0,s3
40003218:	02c12983          	lw	s3,44(sp)
4000321c:	04010113          	addi	sp,sp,64
40003220:	00008067          	ret
40003224:	00040513          	mv	a0,s0
40003228:	6b8240ef          	jal	ra,400278e0 <z_device_is_ready>
4000322c:	00050493          	mv	s1,a0
		if (device_is_ready(dev)) {
40003230:	02050663          	beqz	a0,4000325c <device_get_config_level+0xb4>
			shell_fprintf(sh, SHELL_NORMAL, "- %s\n",
40003234:	01400613          	li	a2,20
40003238:	00c10593          	addi	a1,sp,12
4000323c:	00040513          	mv	a0,s0
40003240:	dadff0ef          	jal	ra,40002fec <get_device_name>
40003244:	00050693          	mv	a3,a0
40003248:	178a8613          	addi	a2,s5,376 # 4002c178 <shell_sub_kernel+0xd4>
4000324c:	00800593          	li	a1,8
40003250:	00090513          	mv	a0,s2
40003254:	25d020ef          	jal	ra,40005cb0 <shell_fprintf>
			devices = true;
40003258:	00048993          	mv	s3,s1
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
4000325c:	01840413          	addi	s0,s0,24
40003260:	f99ff06f          	j	400031f8 <device_get_config_level+0x50>

40003264 <cmd_device_levels>:
	shell_fprintf(sh, SHELL_NORMAL, "EARLY:\n");
40003264:	4002c637          	lui	a2,0x4002c
{
40003268:	ff010113          	addi	sp,sp,-16
	shell_fprintf(sh, SHELL_NORMAL, "EARLY:\n");
4000326c:	00800593          	li	a1,8
40003270:	18060613          	addi	a2,a2,384 # 4002c180 <shell_sub_kernel+0xdc>
{
40003274:	00812423          	sw	s0,8(sp)
40003278:	00112623          	sw	ra,12(sp)
4000327c:	00050413          	mv	s0,a0
	shell_fprintf(sh, SHELL_NORMAL, "EARLY:\n");
40003280:	231020ef          	jal	ra,40005cb0 <shell_fprintf>
	ret = device_get_config_level(sh, INIT_LEVEL_EARLY);
40003284:	00000593          	li	a1,0
40003288:	00040513          	mv	a0,s0
4000328c:	f1dff0ef          	jal	ra,400031a8 <device_get_config_level>
	if (ret == false) {
40003290:	00051c63          	bnez	a0,400032a8 <cmd_device_levels+0x44>
		shell_fprintf(sh, SHELL_NORMAL, "- None\n");
40003294:	4002c637          	lui	a2,0x4002c
40003298:	18860613          	addi	a2,a2,392 # 4002c188 <shell_sub_kernel+0xe4>
4000329c:	00800593          	li	a1,8
400032a0:	00040513          	mv	a0,s0
400032a4:	20d020ef          	jal	ra,40005cb0 <shell_fprintf>
	shell_fprintf(sh, SHELL_NORMAL, "PRE KERNEL 1:\n");
400032a8:	4002c637          	lui	a2,0x4002c
400032ac:	00800593          	li	a1,8
400032b0:	00040513          	mv	a0,s0
400032b4:	19060613          	addi	a2,a2,400 # 4002c190 <shell_sub_kernel+0xec>
400032b8:	1f9020ef          	jal	ra,40005cb0 <shell_fprintf>
	ret = device_get_config_level(sh, INIT_LEVEL_PRE_KERNEL_1);
400032bc:	00100593          	li	a1,1
400032c0:	00040513          	mv	a0,s0
400032c4:	ee5ff0ef          	jal	ra,400031a8 <device_get_config_level>
	if (ret == false) {
400032c8:	00051c63          	bnez	a0,400032e0 <cmd_device_levels+0x7c>
		shell_fprintf(sh, SHELL_NORMAL, "- None\n");
400032cc:	4002c637          	lui	a2,0x4002c
400032d0:	18860613          	addi	a2,a2,392 # 4002c188 <shell_sub_kernel+0xe4>
400032d4:	00800593          	li	a1,8
400032d8:	00040513          	mv	a0,s0
400032dc:	1d5020ef          	jal	ra,40005cb0 <shell_fprintf>
	shell_fprintf(sh, SHELL_NORMAL, "PRE KERNEL 2:\n");
400032e0:	4002c637          	lui	a2,0x4002c
400032e4:	00800593          	li	a1,8
400032e8:	00040513          	mv	a0,s0
400032ec:	1a060613          	addi	a2,a2,416 # 4002c1a0 <shell_sub_kernel+0xfc>
400032f0:	1c1020ef          	jal	ra,40005cb0 <shell_fprintf>
	ret = device_get_config_level(sh, INIT_LEVEL_PRE_KERNEL_2);
400032f4:	00200593          	li	a1,2
400032f8:	00040513          	mv	a0,s0
400032fc:	eadff0ef          	jal	ra,400031a8 <device_get_config_level>
	if (ret == false) {
40003300:	00051c63          	bnez	a0,40003318 <cmd_device_levels+0xb4>
		shell_fprintf(sh, SHELL_NORMAL, "- None\n");
40003304:	4002c637          	lui	a2,0x4002c
40003308:	18860613          	addi	a2,a2,392 # 4002c188 <shell_sub_kernel+0xe4>
4000330c:	00800593          	li	a1,8
40003310:	00040513          	mv	a0,s0
40003314:	19d020ef          	jal	ra,40005cb0 <shell_fprintf>
	shell_fprintf(sh, SHELL_NORMAL, "POST_KERNEL:\n");
40003318:	4002c637          	lui	a2,0x4002c
4000331c:	00800593          	li	a1,8
40003320:	00040513          	mv	a0,s0
40003324:	1b060613          	addi	a2,a2,432 # 4002c1b0 <shell_sub_kernel+0x10c>
40003328:	189020ef          	jal	ra,40005cb0 <shell_fprintf>
	ret = device_get_config_level(sh, INIT_LEVEL_POST_KERNEL);
4000332c:	00300593          	li	a1,3
40003330:	00040513          	mv	a0,s0
40003334:	e75ff0ef          	jal	ra,400031a8 <device_get_config_level>
	if (ret == false) {
40003338:	00051c63          	bnez	a0,40003350 <cmd_device_levels+0xec>
		shell_fprintf(sh, SHELL_NORMAL, "- None\n");
4000333c:	4002c637          	lui	a2,0x4002c
40003340:	18860613          	addi	a2,a2,392 # 4002c188 <shell_sub_kernel+0xe4>
40003344:	00800593          	li	a1,8
40003348:	00040513          	mv	a0,s0
4000334c:	165020ef          	jal	ra,40005cb0 <shell_fprintf>
	shell_fprintf(sh, SHELL_NORMAL, "APPLICATION:\n");
40003350:	4002c637          	lui	a2,0x4002c
40003354:	00800593          	li	a1,8
40003358:	00040513          	mv	a0,s0
4000335c:	1c060613          	addi	a2,a2,448 # 4002c1c0 <shell_sub_kernel+0x11c>
40003360:	151020ef          	jal	ra,40005cb0 <shell_fprintf>
	ret = device_get_config_level(sh, INIT_LEVEL_APPLICATION);
40003364:	00400593          	li	a1,4
40003368:	00040513          	mv	a0,s0
4000336c:	e3dff0ef          	jal	ra,400031a8 <device_get_config_level>
	if (ret == false) {
40003370:	00051c63          	bnez	a0,40003388 <cmd_device_levels+0x124>
		shell_fprintf(sh, SHELL_NORMAL, "- None\n");
40003374:	4002c637          	lui	a2,0x4002c
40003378:	18860613          	addi	a2,a2,392 # 4002c188 <shell_sub_kernel+0xe4>
4000337c:	00800593          	li	a1,8
40003380:	00040513          	mv	a0,s0
40003384:	12d020ef          	jal	ra,40005cb0 <shell_fprintf>
}
40003388:	00c12083          	lw	ra,12(sp)
4000338c:	00812403          	lw	s0,8(sp)
40003390:	00000513          	li	a0,0
40003394:	01010113          	addi	sp,sp,16
40003398:	00008067          	ret

4000339c <cmd_devmem>:
	return err;
}

/* The syntax of the command is similar to busybox's devmem */
static int cmd_devmem(const struct shell *sh, size_t argc, char **argv)
{
4000339c:	fe010113          	addi	sp,sp,-32
400033a0:	01312623          	sw	s3,12(sp)
400033a4:	00112e23          	sw	ra,28(sp)
400033a8:	00812c23          	sw	s0,24(sp)
400033ac:	00912a23          	sw	s1,20(sp)
400033b0:	01212823          	sw	s2,16(sp)
400033b4:	01412423          	sw	s4,8(sp)
400033b8:	01512223          	sw	s5,4(sp)
	mem_addr_t phys_addr, addr;
	uint32_t value = 0;
	uint8_t width;

	if (argc < 2 || argc > 4) {
400033bc:	ffe58793          	addi	a5,a1,-2
400033c0:	00200993          	li	s3,2
400033c4:	0ef9ec63          	bltu	s3,a5,400034bc <cmd_devmem+0x120>
400033c8:	00060413          	mv	s0,a2
		return -EINVAL;
	}

	phys_addr = strtoul(argv[1], NULL, 16);
400033cc:	00050913          	mv	s2,a0
400033d0:	00442503          	lw	a0,4(s0)
400033d4:	00058a13          	mv	s4,a1
400033d8:	01000613          	li	a2,16
400033dc:	00000593          	li	a1,0
400033e0:	08d050ef          	jal	ra,40008c6c <strtoul>
400033e4:	00050493          	mv	s1,a0
	shell_print(sh, "Mapped 0x%lx to 0x%lx\n", phys_addr, addr);
#else
	addr = phys_addr;
#endif /* defined(CONFIG_MMU) || defined(CONFIG_PCIE) */

	if (argc < 3) {
400033e8:	4002cab7          	lui	s5,0x4002c
400033ec:	033a1063          	bne	s4,s3,4000340c <cmd_devmem+0x70>
		width = 32;
	} else {
		width = strtoul(argv[2], NULL, 10);
	}

	shell_fprintf(sh, SHELL_NORMAL, "Using data width %d\n", width);
400033f0:	02000693          	li	a3,32
400033f4:	29ca8613          	addi	a2,s5,668 # 4002c29c <levels+0x18>
400033f8:	00800593          	li	a1,8
400033fc:	00090513          	mv	a0,s2
40003400:	0b1020ef          	jal	ra,40005cb0 <shell_fprintf>
	*(volatile uint16_t *)addr = data;
}

static ALWAYS_INLINE uint32_t sys_read32(mem_addr_t addr)
{
	return *(volatile uint32_t *)addr;
40003404:	0004a683          	lw	a3,0(s1)
	if (err == 0) {
40003408:	0540006f          	j	4000345c <cmd_devmem+0xc0>
		width = strtoul(argv[2], NULL, 10);
4000340c:	00842503          	lw	a0,8(s0)
40003410:	00a00613          	li	a2,10
40003414:	00000593          	li	a1,0
40003418:	055050ef          	jal	ra,40008c6c <strtoul>
4000341c:	0ff57993          	zext.b	s3,a0
	shell_fprintf(sh, SHELL_NORMAL, "Using data width %d\n", width);
40003420:	00098693          	mv	a3,s3
40003424:	29ca8613          	addi	a2,s5,668
40003428:	00800593          	li	a1,8
4000342c:	00090513          	mv	a0,s2
40003430:	081020ef          	jal	ra,40005cb0 <shell_fprintf>

	if (argc <= 3) {
40003434:	00400793          	li	a5,4
40003438:	08fa0663          	beq	s4,a5,400034c4 <cmd_devmem+0x128>
	switch (width) {
4000343c:	01000793          	li	a5,16
40003440:	04f98c63          	beq	s3,a5,40003498 <cmd_devmem+0xfc>
40003444:	02000793          	li	a5,32
40003448:	faf98ee3          	beq	s3,a5,40003404 <cmd_devmem+0x68>
4000344c:	00800793          	li	a5,8
40003450:	04f99c63          	bne	s3,a5,400034a8 <cmd_devmem+0x10c>
	return *(volatile uint8_t *)addr;
40003454:	0004c683          	lbu	a3,0(s1)
40003458:	0ff6f693          	zext.b	a3,a3
		shell_fprintf(sh, SHELL_NORMAL, "Read value 0x%x\n", value);
4000345c:	4002c637          	lui	a2,0x4002c
40003460:	2cc60613          	addi	a2,a2,716 # 4002c2cc <levels+0x48>
40003464:	00800593          	li	a1,8
40003468:	00090513          	mv	a0,s2
4000346c:	045020ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
40003470:	00000513          	li	a0,0
	value = strtoul(argv[3], NULL, 16);

	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);

	return memory_write(sh, addr, width, value);
}
40003474:	01c12083          	lw	ra,28(sp)
40003478:	01812403          	lw	s0,24(sp)
4000347c:	01412483          	lw	s1,20(sp)
40003480:	01012903          	lw	s2,16(sp)
40003484:	00c12983          	lw	s3,12(sp)
40003488:	00812a03          	lw	s4,8(sp)
4000348c:	00412a83          	lw	s5,4(sp)
40003490:	02010113          	addi	sp,sp,32
40003494:	00008067          	ret
	return *(volatile uint16_t *)addr;
40003498:	0004d683          	lhu	a3,0(s1)
4000349c:	01069693          	slli	a3,a3,0x10
400034a0:	0106d693          	srli	a3,a3,0x10
	if (err == 0) {
400034a4:	fb9ff06f          	j	4000345c <cmd_devmem+0xc0>
		shell_fprintf(sh, SHELL_NORMAL, "Incorrect data width\n");
400034a8:	4002c637          	lui	a2,0x4002c
400034ac:	2b460613          	addi	a2,a2,692 # 4002c2b4 <levels+0x30>
400034b0:	00800593          	li	a1,8
400034b4:	00090513          	mv	a0,s2
400034b8:	7f8020ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
400034bc:	fea00513          	li	a0,-22
400034c0:	fb5ff06f          	j	40003474 <cmd_devmem+0xd8>
	value = strtoul(argv[3], NULL, 16);
400034c4:	00c42503          	lw	a0,12(s0)
400034c8:	01000613          	li	a2,16
400034cc:	00000593          	li	a1,0
400034d0:	79c050ef          	jal	ra,40008c6c <strtoul>
	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);
400034d4:	4002c637          	lui	a2,0x4002c
400034d8:	00050693          	mv	a3,a0
	value = strtoul(argv[3], NULL, 16);
400034dc:	00050413          	mv	s0,a0
	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);
400034e0:	2e060613          	addi	a2,a2,736 # 4002c2e0 <levels+0x5c>
400034e4:	00800593          	li	a1,8
400034e8:	00090513          	mv	a0,s2
400034ec:	7c4020ef          	jal	ra,40005cb0 <shell_fprintf>
	switch (width) {
400034f0:	01000793          	li	a5,16
400034f4:	02f98063          	beq	s3,a5,40003514 <cmd_devmem+0x178>
400034f8:	02000793          	li	a5,32
400034fc:	02f98463          	beq	s3,a5,40003524 <cmd_devmem+0x188>
40003500:	00800793          	li	a5,8
40003504:	faf992e3          	bne	s3,a5,400034a8 <cmd_devmem+0x10c>
		sys_write8(value, addr);
40003508:	0ff47413          	zext.b	s0,s0
	*(volatile uint8_t *)addr = data;
4000350c:	00848023          	sb	s0,0(s1)
}
40003510:	f61ff06f          	j	40003470 <cmd_devmem+0xd4>
		sys_write16(value, addr);
40003514:	01041413          	slli	s0,s0,0x10
40003518:	01045413          	srli	s0,s0,0x10
	*(volatile uint16_t *)addr = data;
4000351c:	00849023          	sh	s0,0(s1)
}
40003520:	f51ff06f          	j	40003470 <cmd_devmem+0xd4>
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	*(volatile uint32_t *)addr = data;
40003524:	0084a023          	sw	s0,0(s1)
}
40003528:	f49ff06f          	j	40003470 <cmd_devmem+0xd4>

4000352c <set_bypass.isra.0>:
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
4000352c:	ff010113          	addi	sp,sp,-16
40003530:	00812423          	sw	s0,8(sp)
40003534:	00912223          	sw	s1,4(sp)
40003538:	01212023          	sw	s2,0(sp)
4000353c:	00112623          	sw	ra,12(sp)
	if (bypass && in_use) {
40003540:	40031937          	lui	s2,0x40031
40003544:	b0094783          	lbu	a5,-1280(s2) # 40030b00 <in_use.0>
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
40003548:	00050413          	mv	s0,a0
4000354c:	00058493          	mv	s1,a1
	if (bypass && in_use) {
40003550:	04058a63          	beqz	a1,400035a4 <set_bypass.isra.0+0x78>
40003554:	02078463          	beqz	a5,4000357c <set_bypass.isra.0+0x50>
}
40003558:	00812403          	lw	s0,8(sp)
4000355c:	00c12083          	lw	ra,12(sp)
40003560:	00412483          	lw	s1,4(sp)
40003564:	00012903          	lw	s2,0(sp)
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
40003568:	4002c637          	lui	a2,0x4002c
4000356c:	2f460613          	addi	a2,a2,756 # 4002c2f4 <levels+0x70>
40003570:	00100593          	li	a1,1
}
40003574:	01010113          	addi	sp,sp,16
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
40003578:	7380206f          	j	40005cb0 <shell_fprintf>
	in_use = !in_use;
4000357c:	00100793          	li	a5,1
40003580:	b0f90023          	sb	a5,-1280(s2)
		shell_print(sh, "Loading...\npress ctrl-x ctrl-q to escape");
40003584:	4002c637          	lui	a2,0x4002c
40003588:	33060613          	addi	a2,a2,816 # 4002c330 <levels+0xac>
4000358c:	00800593          	li	a1,8
40003590:	00040513          	mv	a0,s0
40003594:	71c020ef          	jal	ra,40005cb0 <shell_fprintf>
		in_use = true;
40003598:	00100793          	li	a5,1
4000359c:	b0f90023          	sb	a5,-1280(s2)
400035a0:	0100006f          	j	400035b0 <set_bypass.isra.0+0x84>
	in_use = !in_use;
400035a4:	0017c793          	xori	a5,a5,1
400035a8:	b0f90023          	sb	a5,-1280(s2)
	if (in_use) {
400035ac:	fc079ce3          	bnez	a5,40003584 <set_bypass.isra.0+0x58>
	shell_set_bypass(sh, bypass);
400035b0:	00040513          	mv	a0,s0
}
400035b4:	00812403          	lw	s0,8(sp)
400035b8:	00c12083          	lw	ra,12(sp)
400035bc:	00012903          	lw	s2,0(sp)
	shell_set_bypass(sh, bypass);
400035c0:	00048593          	mv	a1,s1
}
400035c4:	00412483          	lw	s1,4(sp)
400035c8:	01010113          	addi	sp,sp,16
	shell_set_bypass(sh, bypass);
400035cc:	2290206f          	j	40005ff4 <shell_set_bypass>

400035d0 <bypass_cb>:
	if (tail == CHAR_CAN && recv[0] == CHAR_DC1) {
400035d0:	40031737          	lui	a4,0x40031
400035d4:	b0174683          	lbu	a3,-1279(a4) # 40030b01 <tail.1>
{
400035d8:	fe010113          	addi	sp,sp,-32
400035dc:	00112e23          	sw	ra,28(sp)
400035e0:	00812c23          	sw	s0,24(sp)
	if (tail == CHAR_CAN && recv[0] == CHAR_DC1) {
400035e4:	01800793          	li	a5,24
400035e8:	00f69863          	bne	a3,a5,400035f8 <bypass_cb+0x28>
400035ec:	0005c683          	lbu	a3,0(a1)
400035f0:	01100793          	li	a5,17
400035f4:	0cf68663          	beq	a3,a5,400036c0 <bypass_cb+0xf0>
400035f8:	00158793          	addi	a5,a1,1
400035fc:	00c58633          	add	a2,a1,a2
			if (recv[i] == CHAR_CAN && recv[i + 1] == CHAR_DC1) {
40003600:	01800693          	li	a3,24
40003604:	01100813          	li	a6,17
		for (int i = 0; i < (len - 1); i++) {
40003608:	0ac79063          	bne	a5,a2,400036a8 <bypass_cb+0xd8>
	tail = recv[len - 1];
4000360c:	fff7c783          	lbu	a5,-1(a5)
	if (is_ascii(*recv)) {
40003610:	0005c683          	lbu	a3,0(a1)
40003614:	40031437          	lui	s0,0x40031
	tail = recv[len - 1];
40003618:	b0f700a3          	sb	a5,-1279(a4)
	return (data >= 0x30 && data <= 0x39) || (data >= 0x61 && data <= 0x66) ||
4000361c:	fd068793          	addi	a5,a3,-48
40003620:	0ff7f793          	zext.b	a5,a5
40003624:	00900713          	li	a4,9
40003628:	00f77c63          	bgeu	a4,a5,40003640 <bypass_cb+0x70>
4000362c:	fdf6f793          	andi	a5,a3,-33
40003630:	fbf78793          	addi	a5,a5,-65
40003634:	0ff7f793          	zext.b	a5,a5
40003638:	00500713          	li	a4,5
4000363c:	02f76063          	bltu	a4,a5,4000365c <bypass_cb+0x8c>
		chunk[chunk_element] = *recv;
40003640:	9f842703          	lw	a4,-1544(s0) # 400309f8 <chunk_element>
40003644:	400317b7          	lui	a5,0x40031
40003648:	9f478793          	addi	a5,a5,-1548 # 400309f4 <chunk>
4000364c:	00f707b3          	add	a5,a4,a5
		chunk_element++;
40003650:	00170713          	addi	a4,a4,1
		chunk[chunk_element] = *recv;
40003654:	00d78023          	sb	a3,0(a5)
		chunk_element++;
40003658:	9ee42c23          	sw	a4,-1544(s0)
	if (chunk_element == 2) {
4000365c:	9f842703          	lw	a4,-1544(s0)
40003660:	00200793          	li	a5,2
40003664:	10f71063          	bne	a4,a5,40003764 <bypass_cb+0x194>
		byte = (uint8_t)strtoul(chunk, NULL, 16);
40003668:	40031537          	lui	a0,0x40031
4000366c:	01000613          	li	a2,16
40003670:	00000593          	li	a1,0
40003674:	9f450513          	addi	a0,a0,-1548 # 400309f4 <chunk>
40003678:	5f4050ef          	jal	ra,40008c6c <strtoul>
		*bytes = byte;
4000367c:	40031737          	lui	a4,0x40031
40003680:	a0472783          	lw	a5,-1532(a4) # 40030a04 <bytes>
		chunk_element = 0;
40003684:	9e042c23          	sw	zero,-1544(s0)
		byte = (uint8_t)strtoul(chunk, NULL, 16);
40003688:	00a78023          	sb	a0,0(a5)
		bytes++;
4000368c:	00178793          	addi	a5,a5,1
40003690:	a0f72223          	sw	a5,-1532(a4)
		sum++;
40003694:	40031737          	lui	a4,0x40031
40003698:	9fc72783          	lw	a5,-1540(a4) # 400309fc <sum>
4000369c:	00178793          	addi	a5,a5,1
400036a0:	9ef72e23          	sw	a5,-1540(a4)
		chunk_element = 0;
400036a4:	0c00006f          	j	40003764 <bypass_cb+0x194>
			if (recv[i] == CHAR_CAN && recv[i + 1] == CHAR_DC1) {
400036a8:	fff7c883          	lbu	a7,-1(a5)
400036ac:	00d89663          	bne	a7,a3,400036b8 <bypass_cb+0xe8>
400036b0:	0007c883          	lbu	a7,0(a5)
400036b4:	01088663          	beq	a7,a6,400036c0 <bypass_cb+0xf0>
		for (int i = 0; i < (len - 1); i++) {
400036b8:	00178793          	addi	a5,a5,1
400036bc:	f4dff06f          	j	40003608 <bypass_cb+0x38>
		shell_print(sh, "Number of bytes read: %d", sum);
400036c0:	40031437          	lui	s0,0x40031
400036c4:	9fc42683          	lw	a3,-1540(s0) # 400309fc <sum>
400036c8:	4002c637          	lui	a2,0x4002c
400036cc:	35c60613          	addi	a2,a2,860 # 4002c35c <levels+0xd8>
400036d0:	00800593          	li	a1,8
400036d4:	00a12623          	sw	a0,12(sp)
400036d8:	5d8020ef          	jal	ra,40005cb0 <shell_fprintf>
		set_bypass(sh, NULL);
400036dc:	00c12503          	lw	a0,12(sp)
400036e0:	00000593          	li	a1,0
400036e4:	e49ff0ef          	jal	ra,4000352c <set_bypass.isra.0>
		if (!littleendian) {
400036e8:	400317b7          	lui	a5,0x40031
400036ec:	b027c703          	lbu	a4,-1278(a5) # 40030b02 <littleendian>
400036f0:	06071a63          	bnez	a4,40003764 <bypass_cb+0x194>
400036f4:	40031637          	lui	a2,0x40031
400036f8:	a0062583          	lw	a1,-1536(a2) # 40030a00 <data>
400036fc:	9fc42783          	lw	a5,-1540(s0)
				*data = __bswap_32(*data);
40003700:	00010537          	lui	a0,0x10
			while (sum > 4) {
40003704:	00400893          	li	a7,4
				*data = __bswap_32(*data);
40003708:	f0050513          	addi	a0,a0,-256 # ff00 <__kernel_ram_size+0x3c6c>
4000370c:	00ff0337          	lui	t1,0xff0
			while (sum > 4) {
40003710:	06f8c263          	blt	a7,a5,40003774 <bypass_cb+0x1a4>
40003714:	00070663          	beqz	a4,40003720 <bypass_cb+0x150>
40003718:	a0b62023          	sw	a1,-1536(a2)
4000371c:	9ef42e23          	sw	a5,-1540(s0)
			if (sum % 4 == 0) {
40003720:	0037f713          	andi	a4,a5,3
40003724:	08071663          	bnez	a4,400037b0 <bypass_cb+0x1e0>
				*data = __bswap_32(*data);
40003728:	a0062583          	lw	a1,-1536(a2)
4000372c:	00010637          	lui	a2,0x10
40003730:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
40003734:	0005a783          	lw	a5,0(a1)
40003738:	01879693          	slli	a3,a5,0x18
4000373c:	0187d713          	srli	a4,a5,0x18
40003740:	00d76733          	or	a4,a4,a3
40003744:	0087d693          	srli	a3,a5,0x8
40003748:	00c6f6b3          	and	a3,a3,a2
4000374c:	00d76733          	or	a4,a4,a3
40003750:	00879793          	slli	a5,a5,0x8
40003754:	00ff06b7          	lui	a3,0xff0
40003758:	00d7f7b3          	and	a5,a5,a3
4000375c:	00f767b3          	or	a5,a4,a5
40003760:	00f5a023          	sw	a5,0(a1)
}
40003764:	01c12083          	lw	ra,28(sp)
40003768:	01812403          	lw	s0,24(sp)
4000376c:	02010113          	addi	sp,sp,32
40003770:	00008067          	ret
				*data = __bswap_32(*data);
40003774:	0005a703          	lw	a4,0(a1)
40003778:	ffc78793          	addi	a5,a5,-4
				data++;
4000377c:	00458593          	addi	a1,a1,4
				*data = __bswap_32(*data);
40003780:	01871813          	slli	a6,a4,0x18
40003784:	01875693          	srli	a3,a4,0x18
40003788:	0106e6b3          	or	a3,a3,a6
4000378c:	00875813          	srli	a6,a4,0x8
40003790:	00a87833          	and	a6,a6,a0
40003794:	00871713          	slli	a4,a4,0x8
40003798:	0106e6b3          	or	a3,a3,a6
4000379c:	00677733          	and	a4,a4,t1
400037a0:	00e6e733          	or	a4,a3,a4
400037a4:	fee5ae23          	sw	a4,-4(a1)
				data++;
400037a8:	00100713          	li	a4,1
400037ac:	f65ff06f          	j	40003710 <bypass_cb+0x140>
			} else if (sum % 4 == 2) {
400037b0:	00400713          	li	a4,4
400037b4:	02e7e7b3          	rem	a5,a5,a4
400037b8:	00200713          	li	a4,2
400037bc:	02e79463          	bne	a5,a4,400037e4 <bypass_cb+0x214>
				*data = __bswap_16(*data);
400037c0:	a0062683          	lw	a3,-1536(a2)
400037c4:	0006d703          	lhu	a4,0(a3) # ff0000 <__rom_region_size+0xfbf624>
400037c8:	00871793          	slli	a5,a4,0x8
400037cc:	00875713          	srli	a4,a4,0x8
400037d0:	00e7e7b3          	or	a5,a5,a4
400037d4:	01079793          	slli	a5,a5,0x10
400037d8:	0107d793          	srli	a5,a5,0x10
400037dc:	00f6a023          	sw	a5,0(a3)
400037e0:	f85ff06f          	j	40003764 <bypass_cb+0x194>
			} else if (sum % 4 == 3) {
400037e4:	00300713          	li	a4,3
400037e8:	f6e79ee3          	bne	a5,a4,40003764 <bypass_cb+0x194>
				*data = __bswap_24(*data);
400037ec:	a0062603          	lw	a2,-1536(a2)
400037f0:	00ff05b7          	lui	a1,0xff0
400037f4:	00062703          	lw	a4,0(a2)
400037f8:	01075793          	srli	a5,a4,0x10
400037fc:	01071693          	slli	a3,a4,0x10
40003800:	00b6f6b3          	and	a3,a3,a1
40003804:	0ff7f793          	zext.b	a5,a5
40003808:	00d7e7b3          	or	a5,a5,a3
4000380c:	000106b7          	lui	a3,0x10
40003810:	f0068693          	addi	a3,a3,-256 # ff00 <__kernel_ram_size+0x3c6c>
40003814:	00d77733          	and	a4,a4,a3
40003818:	00e7e7b3          	or	a5,a5,a4
4000381c:	00f62023          	sw	a5,0(a2)
40003820:	f45ff06f          	j	40003764 <bypass_cb+0x194>

40003824 <cmd_load>:
{
40003824:	fd010113          	addi	sp,sp,-48
	chunk_element = 0;
40003828:	400317b7          	lui	a5,0x40031
{
4000382c:	01512a23          	sw	s5,20(sp)
	chunk_element = 0;
40003830:	9e07ac23          	sw	zero,-1544(a5) # 400309f8 <chunk_element>
	littleendian = false;
40003834:	40031ab7          	lui	s5,0x40031
	sum = 0;
40003838:	400317b7          	lui	a5,0x40031
{
4000383c:	02812423          	sw	s0,40(sp)
40003840:	03212023          	sw	s2,32(sp)
40003844:	01312e23          	sw	s3,28(sp)
40003848:	01412c23          	sw	s4,24(sp)
4000384c:	01612823          	sw	s6,16(sp)
40003850:	01712623          	sw	s7,12(sp)
40003854:	01812423          	sw	s8,8(sp)
40003858:	01912223          	sw	s9,4(sp)
4000385c:	02112623          	sw	ra,44(sp)
40003860:	02912223          	sw	s1,36(sp)
40003864:	00050993          	mv	s3,a0
40003868:	00058913          	mv	s2,a1
4000386c:	00060413          	mv	s0,a2
	littleendian = false;
40003870:	b00a8123          	sb	zero,-1278(s5) # 40030b02 <littleendian>
	sum = 0;
40003874:	9e07ae23          	sw	zero,-1540(a5) # 400309fc <sum>
	while (argc >= 2) {
40003878:	00100a13          	li	s4,1
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
4000387c:	4002cb37          	lui	s6,0x4002c
		if (!strncmp(arg, "-e", 2)) {
40003880:	4002cbb7          	lui	s7,0x4002c
		} else if (arg[0] == '-' && arg[1]) {
40003884:	02d00c13          	li	s8,45
			shell_print(sh, "Unknown option \"%s\"", arg);
40003888:	4002ccb7          	lui	s9,0x4002c
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
4000388c:	00442483          	lw	s1,4(s0)
	while (argc >= 2) {
40003890:	072a7263          	bgeu	s4,s2,400038f4 <cmd_load+0xd0>
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
40003894:	00200613          	li	a2,2
40003898:	378b0593          	addi	a1,s6,888 # 4002c378 <levels+0xf4>
4000389c:	00048513          	mv	a0,s1
400038a0:	6f0050ef          	jal	ra,40008f90 <strncmp>
400038a4:	00000793          	li	a5,0
400038a8:	00051863          	bnez	a0,400038b8 <cmd_load+0x94>
400038ac:	00442783          	lw	a5,4(s0)
400038b0:	0027c783          	lbu	a5,2(a5)
400038b4:	00f037b3          	snez	a5,a5
400038b8:	00f484b3          	add	s1,s1,a5
		if (!strncmp(arg, "-e", 2)) {
400038bc:	00200613          	li	a2,2
400038c0:	37cb8593          	addi	a1,s7,892 # 4002c37c <levels+0xf8>
400038c4:	00048513          	mv	a0,s1
400038c8:	6c8050ef          	jal	ra,40008f90 <strncmp>
400038cc:	00051a63          	bnez	a0,400038e0 <cmd_load+0xbc>
			littleendian = true;
400038d0:	b14a8123          	sb	s4,-1278(s5)
		argv++;
400038d4:	00440413          	addi	s0,s0,4
		argc--;
400038d8:	fff90913          	addi	s2,s2,-1
400038dc:	fb1ff06f          	j	4000388c <cmd_load+0x68>
		} else if (!strcmp(arg, "--")) {
400038e0:	378b0593          	addi	a1,s6,888
400038e4:	00048513          	mv	a0,s1
400038e8:	684050ef          	jal	ra,40008f6c <strcmp>
400038ec:	08051063          	bnez	a0,4000396c <cmd_load+0x148>
			argv++;
400038f0:	00440413          	addi	s0,s0,4
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
400038f4:	00442503          	lw	a0,4(s0)
400038f8:	00000613          	li	a2,0
400038fc:	00000593          	li	a1,0
40003900:	1d8050ef          	jal	ra,40008ad8 <strtol>
40003904:	400317b7          	lui	a5,0x40031
40003908:	a0a7a223          	sw	a0,-1532(a5) # 40030a04 <bytes>
	data = (uint32_t *)strtol(argv[1], NULL, 0);
4000390c:	00442503          	lw	a0,4(s0)
40003910:	00000613          	li	a2,0
40003914:	00000593          	li	a1,0
40003918:	1c0050ef          	jal	ra,40008ad8 <strtol>
4000391c:	400317b7          	lui	a5,0x40031
	set_bypass(sh, bypass_cb);
40003920:	400035b7          	lui	a1,0x40003
	data = (uint32_t *)strtol(argv[1], NULL, 0);
40003924:	a0a7a023          	sw	a0,-1536(a5) # 40030a00 <data>
	set_bypass(sh, bypass_cb);
40003928:	5d058593          	addi	a1,a1,1488 # 400035d0 <bypass_cb>
4000392c:	00098513          	mv	a0,s3
40003930:	bfdff0ef          	jal	ra,4000352c <set_bypass.isra.0>
}
40003934:	02c12083          	lw	ra,44(sp)
40003938:	02812403          	lw	s0,40(sp)
4000393c:	02412483          	lw	s1,36(sp)
40003940:	02012903          	lw	s2,32(sp)
40003944:	01c12983          	lw	s3,28(sp)
40003948:	01812a03          	lw	s4,24(sp)
4000394c:	01412a83          	lw	s5,20(sp)
40003950:	01012b03          	lw	s6,16(sp)
40003954:	00c12b83          	lw	s7,12(sp)
40003958:	00812c03          	lw	s8,8(sp)
4000395c:	00412c83          	lw	s9,4(sp)
40003960:	00000513          	li	a0,0
40003964:	03010113          	addi	sp,sp,48
40003968:	00008067          	ret
		} else if (arg[0] == '-' && arg[1]) {
4000396c:	0004c783          	lbu	a5,0(s1)
40003970:	f98792e3          	bne	a5,s8,400038f4 <cmd_load+0xd0>
40003974:	0014c783          	lbu	a5,1(s1)
40003978:	f6078ee3          	beqz	a5,400038f4 <cmd_load+0xd0>
			shell_print(sh, "Unknown option \"%s\"", arg);
4000397c:	00048693          	mv	a3,s1
40003980:	380c8613          	addi	a2,s9,896 # 4002c380 <levels+0xfc>
40003984:	00800593          	li	a1,8
40003988:	00098513          	mv	a0,s3
4000398c:	324020ef          	jal	ra,40005cb0 <shell_fprintf>
40003990:	f45ff06f          	j	400038d4 <cmd_load+0xb0>

40003994 <cmd_dump>:
{
40003994:	fb010113          	addi	sp,sp,-80
	optind = 1;
40003998:	4003d7b7          	lui	a5,0x4003d
4000399c:	00100713          	li	a4,1
{
400039a0:	04812423          	sw	s0,72(sp)
400039a4:	04912223          	sw	s1,68(sp)
400039a8:	05212023          	sw	s2,64(sp)
400039ac:	03312e23          	sw	s3,60(sp)
400039b0:	03412c23          	sw	s4,56(sp)
400039b4:	03512a23          	sw	s5,52(sp)
400039b8:	03612823          	sw	s6,48(sp)
400039bc:	03712623          	sw	s7,44(sp)
400039c0:	03812423          	sw	s8,40(sp)
400039c4:	03912223          	sw	s9,36(sp)
400039c8:	03a12023          	sw	s10,32(sp)
400039cc:	04112623          	sw	ra,76(sp)
400039d0:	01b12e23          	sw	s11,28(sp)
400039d4:	00050993          	mv	s3,a0
400039d8:	00058a93          	mv	s5,a1
400039dc:	00060b13          	mv	s6,a2
	optind = 1;
400039e0:	9ee7a223          	sw	a4,-1564(a5) # 4003c9e4 <optind>
	mem_addr_t addr = -1;
400039e4:	fff00493          	li	s1,-1
	size_t width = 32;
400039e8:	02000913          	li	s2,32
	size_t size = -1;
400039ec:	fff00413          	li	s0,-1
	while ((rv = getopt(argc, argv, "a:s:w:")) != -1) {
400039f0:	4002cbb7          	lui	s7,0x4002c
400039f4:	fff00a13          	li	s4,-1
		switch (rv) {
400039f8:	07300c13          	li	s8,115
400039fc:	07700c93          	li	s9,119
40003a00:	06100d13          	li	s10,97
	while ((rv = getopt(argc, argv, "a:s:w:")) != -1) {
40003a04:	3d4b8613          	addi	a2,s7,980 # 4002c3d4 <levels+0x150>
40003a08:	000b0593          	mv	a1,s6
40003a0c:	000a8513          	mv	a0,s5
40003a10:	964fd0ef          	jal	ra,40000b74 <getopt>
40003a14:	03451063          	bne	a0,s4,40003a34 <cmd_dump+0xa0>
	if (addr == -1) {
40003a18:	13449263          	bne	s1,s4,40003b3c <cmd_dump+0x1a8>
		shell_error(sh, "'-a <address>' is mandatory");
40003a1c:	4002c637          	lui	a2,0x4002c
40003a20:	3dc60613          	addi	a2,a2,988 # 4002c3dc <levels+0x158>
		shell_error(sh, "'-s <size>' is mandatory");
40003a24:	00100593          	li	a1,1
				shell_fprintf(sh, SHELL_NORMAL, "Incorrect data width\n");
40003a28:	00098513          	mv	a0,s3
40003a2c:	284020ef          	jal	ra,40005cb0 <shell_fprintf>
40003a30:	0540006f          	j	40003a84 <cmd_dump+0xf0>
		switch (rv) {
40003a34:	09850863          	beq	a0,s8,40003ac4 <cmd_dump+0x130>
40003a38:	0d950463          	beq	a0,s9,40003b00 <cmd_dump+0x16c>
40003a3c:	05a51463          	bne	a0,s10,40003a84 <cmd_dump+0xf0>
			addr = (mem_addr_t)strtoul(optarg, NULL, 16);
40003a40:	40031db7          	lui	s11,0x40031
40003a44:	9e8da503          	lw	a0,-1560(s11) # 400309e8 <optarg>
40003a48:	01000613          	li	a2,16
40003a4c:	00000593          	li	a1,0
40003a50:	21c050ef          	jal	ra,40008c6c <strtoul>
40003a54:	00050493          	mv	s1,a0
			if (addr == 0 && errno == EINVAL) {
40003a58:	fa0516e3          	bnez	a0,40003a04 <cmd_dump+0x70>
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
40003a5c:	701230ef          	jal	ra,4002795c <z_impl_z_errno>
40003a60:	00052703          	lw	a4,0(a0)
40003a64:	01600793          	li	a5,22
40003a68:	f8f71ee3          	bne	a4,a5,40003a04 <cmd_dump+0x70>
				shell_error(sh, "invalid addr '%s'", optarg);
40003a6c:	9e8da683          	lw	a3,-1560(s11)
40003a70:	4002c637          	lui	a2,0x4002c
40003a74:	39860613          	addi	a2,a2,920 # 4002c398 <levels+0x114>
				shell_error(sh, "invalid size '%s'", optarg);
40003a78:	00100593          	li	a1,1
40003a7c:	00098513          	mv	a0,s3
40003a80:	230020ef          	jal	ra,40005cb0 <shell_fprintf>
				return -EINVAL;
40003a84:	fea00513          	li	a0,-22
}
40003a88:	04c12083          	lw	ra,76(sp)
40003a8c:	04812403          	lw	s0,72(sp)
40003a90:	04412483          	lw	s1,68(sp)
40003a94:	04012903          	lw	s2,64(sp)
40003a98:	03c12983          	lw	s3,60(sp)
40003a9c:	03812a03          	lw	s4,56(sp)
40003aa0:	03412a83          	lw	s5,52(sp)
40003aa4:	03012b03          	lw	s6,48(sp)
40003aa8:	02c12b83          	lw	s7,44(sp)
40003aac:	02812c03          	lw	s8,40(sp)
40003ab0:	02412c83          	lw	s9,36(sp)
40003ab4:	02012d03          	lw	s10,32(sp)
40003ab8:	01c12d83          	lw	s11,28(sp)
40003abc:	05010113          	addi	sp,sp,80
40003ac0:	00008067          	ret
			size = (size_t)strtoul(optarg, NULL, 0);
40003ac4:	40031db7          	lui	s11,0x40031
40003ac8:	9e8da503          	lw	a0,-1560(s11) # 400309e8 <optarg>
40003acc:	00000613          	li	a2,0
40003ad0:	00000593          	li	a1,0
40003ad4:	198050ef          	jal	ra,40008c6c <strtoul>
40003ad8:	00050413          	mv	s0,a0
			if (size == 0 && errno == EINVAL) {
40003adc:	f20514e3          	bnez	a0,40003a04 <cmd_dump+0x70>
40003ae0:	67d230ef          	jal	ra,4002795c <z_impl_z_errno>
40003ae4:	00052703          	lw	a4,0(a0)
40003ae8:	01600793          	li	a5,22
40003aec:	f0f71ce3          	bne	a4,a5,40003a04 <cmd_dump+0x70>
				shell_error(sh, "invalid size '%s'", optarg);
40003af0:	4002c637          	lui	a2,0x4002c
40003af4:	9e8da683          	lw	a3,-1560(s11)
40003af8:	3ac60613          	addi	a2,a2,940 # 4002c3ac <levels+0x128>
40003afc:	f7dff06f          	j	40003a78 <cmd_dump+0xe4>
			width = (size_t)strtoul(optarg, NULL, 0);
40003b00:	40031db7          	lui	s11,0x40031
40003b04:	9e8da503          	lw	a0,-1560(s11) # 400309e8 <optarg>
40003b08:	00000613          	li	a2,0
40003b0c:	00000593          	li	a1,0
40003b10:	15c050ef          	jal	ra,40008c6c <strtoul>
40003b14:	00050913          	mv	s2,a0
			if (width == 0 && errno == EINVAL) {
40003b18:	ee0516e3          	bnez	a0,40003a04 <cmd_dump+0x70>
40003b1c:	641230ef          	jal	ra,4002795c <z_impl_z_errno>
40003b20:	00052703          	lw	a4,0(a0)
40003b24:	01600793          	li	a5,22
40003b28:	ecf71ee3          	bne	a4,a5,40003a04 <cmd_dump+0x70>
				shell_error(sh, "invalid width '%s'", optarg);
40003b2c:	4002c637          	lui	a2,0x4002c
40003b30:	9e8da683          	lw	a3,-1560(s11)
40003b34:	3c060613          	addi	a2,a2,960 # 4002c3c0 <levels+0x13c>
40003b38:	f41ff06f          	j	40003a78 <cmd_dump+0xe4>
	if (size == -1) {
40003b3c:	01441863          	bne	s0,s4,40003b4c <cmd_dump+0x1b8>
		shell_error(sh, "'-s <size>' is mandatory");
40003b40:	4002c637          	lui	a2,0x4002c
40003b44:	3fc60613          	addi	a2,a2,1020 # 4002c3fc <levels+0x178>
40003b48:	eddff06f          	j	40003a24 <cmd_dump+0x90>
	return memory_dump(sh, addr, size, width);
40003b4c:	0ff97913          	zext.b	s2,s2
	const size_t vsize = width / BITS_PER_BYTE;
40003b50:	00395a13          	srli	s4,s2,0x3
		     size >= vsize && data_offset + vsize <= SHELL_HEXDUMP_BYTES_IN_LINE;
40003b54:	01000b13          	li	s6,16
			switch (width) {
40003b58:	02000b93          	li	s7,32
40003b5c:	00800c13          	li	s8,8
	for (; size > 0;
40003b60:	0a040e63          	beqz	s0,40003c1c <cmd_dump+0x288>
40003b64:	00010793          	mv	a5,sp
40003b68:	00048713          	mv	a4,s1
40003b6c:	00078613          	mv	a2,a5
		     size >= vsize && data_offset + vsize <= SHELL_HEXDUMP_BYTES_IN_LINE;
40003b70:	409a05b3          	sub	a1,s4,s1
40003b74:	0200006f          	j	40003b94 <cmd_dump+0x200>
			switch (width) {
40003b78:	05690a63          	beq	s2,s6,40003bcc <cmd_dump+0x238>
40003b7c:	07790663          	beq	s2,s7,40003be8 <cmd_dump+0x254>
40003b80:	09891663          	bne	s2,s8,40003c0c <cmd_dump+0x278>
	return *(volatile uint8_t *)addr;
40003b84:	00074683          	lbu	a3,0(a4)
				data[data_offset] = value;
40003b88:	00d78023          	sb	a3,0(a5)
				break;
40003b8c:	01470733          	add	a4,a4,s4
40003b90:	014787b3          	add	a5,a5,s4
		     size >= vsize && data_offset + vsize <= SHELL_HEXDUMP_BYTES_IN_LINE;
40003b94:	01446663          	bltu	s0,s4,40003ba0 <cmd_dump+0x20c>
40003b98:	00e586b3          	add	a3,a1,a4
40003b9c:	fcdb7ee3          	bgeu	s6,a3,40003b78 <cmd_dump+0x1e4>
		shell_hexdump_line(sh, addr, data, MIN(size, SHELL_HEXDUMP_BYTES_IN_LINE));
40003ba0:	01000793          	li	a5,16
40003ba4:	00040a93          	mv	s5,s0
40003ba8:	0087f463          	bgeu	a5,s0,40003bb0 <cmd_dump+0x21c>
40003bac:	01000a93          	li	s5,16
40003bb0:	00048593          	mv	a1,s1
40003bb4:	000a8693          	mv	a3,s5
40003bb8:	00098513          	mv	a0,s3
40003bbc:	1ac020ef          	jal	ra,40005d68 <shell_hexdump_line>
	     addr += SHELL_HEXDUMP_BYTES_IN_LINE, size -= MIN(size, SHELL_HEXDUMP_BYTES_IN_LINE)) {
40003bc0:	01048493          	addi	s1,s1,16
40003bc4:	41540433          	sub	s0,s0,s5
40003bc8:	f99ff06f          	j	40003b60 <cmd_dump+0x1cc>
	return *(volatile uint16_t *)addr;
40003bcc:	00075683          	lhu	a3,0(a4)
40003bd0:	01069693          	slli	a3,a3,0x10
40003bd4:	0106d693          	srli	a3,a3,0x10
				data[data_offset] = (uint8_t)value;
40003bd8:	00d78023          	sb	a3,0(a5)
				value >>= 8;
40003bdc:	0086d693          	srli	a3,a3,0x8
				data[data_offset + 1] = (uint8_t)value;
40003be0:	00d780a3          	sb	a3,1(a5)
				break;
40003be4:	fa9ff06f          	j	40003b8c <cmd_dump+0x1f8>
	return *(volatile uint32_t *)addr;
40003be8:	00072683          	lw	a3,0(a4)
				value >>= 8;
40003bec:	0086d513          	srli	a0,a3,0x8
				data[data_offset] = (uint8_t)value;
40003bf0:	00d78023          	sb	a3,0(a5)
				data[data_offset + 1] = (uint8_t)value;
40003bf4:	00a780a3          	sb	a0,1(a5)
				value >>= 8;
40003bf8:	0106d513          	srli	a0,a3,0x10
				value >>= 8;
40003bfc:	0186d693          	srli	a3,a3,0x18
				data[data_offset + 2] = (uint8_t)value;
40003c00:	00a78123          	sb	a0,2(a5)
				data[data_offset + 3] = (uint8_t)value;
40003c04:	00d781a3          	sb	a3,3(a5)
				break;
40003c08:	f85ff06f          	j	40003b8c <cmd_dump+0x1f8>
				shell_fprintf(sh, SHELL_NORMAL, "Incorrect data width\n");
40003c0c:	4002c637          	lui	a2,0x4002c
40003c10:	2b460613          	addi	a2,a2,692 # 4002c2b4 <levels+0x30>
40003c14:	00800593          	li	a1,8
40003c18:	e11ff06f          	j	40003a28 <cmd_dump+0x94>
	return 0;
40003c1c:	00000513          	li	a0,0
	return memory_dump(sh, addr, size, width);
40003c20:	e69ff06f          	j	40003a88 <cmd_dump+0xf4>

40003c24 <enable>:

static int enable(const struct shell_transport *transport, bool blocking_tx)
{
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
40003c24:	00452783          	lw	a5,4(a0)
		uart_irq_tx_disable(sh_uart->ctrl_blk->dev);
#endif
	}

	return 0;
}
40003c28:	00000513          	li	a0,0
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
40003c2c:	0007a783          	lw	a5,0(a5)
40003c30:	00b78823          	sb	a1,16(a5)
}
40003c34:	00008067          	ret

40003c38 <write>:
	}
}

static int write(const struct shell_transport *transport,
		 const void *data, size_t length, size_t *cnt)
{
40003c38:	fe010113          	addi	sp,sp,-32
40003c3c:	00812c23          	sw	s0,24(sp)
40003c40:	00912a23          	sw	s1,20(sp)
40003c44:	01212823          	sw	s2,16(sp)
40003c48:	01412423          	sw	s4,8(sp)
40003c4c:	00112e23          	sw	ra,28(sp)
40003c50:	01312623          	sw	s3,12(sp)
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
40003c54:	00452983          	lw	s3,4(a0)
{
40003c58:	00060493          	mv	s1,a2
40003c5c:	00068913          	mv	s2,a3
40003c60:	00058413          	mv	s0,a1
40003c64:	00c58a33          	add	s4,a1,a2

	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
		!sh_uart->ctrl_blk->blocking_tx) {
		irq_write(sh_uart, data, length, cnt);
	} else {
		for (size_t i = 0; i < length; i++) {
40003c68:	05441063          	bne	s0,s4,40003ca8 <write+0x70>
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
		}

		*cnt = length;
40003c6c:	00992023          	sw	s1,0(s2)

		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
40003c70:	0009a783          	lw	a5,0(s3)
40003c74:	00100513          	li	a0,1
40003c78:	0047a703          	lw	a4,4(a5)
40003c7c:	0087a583          	lw	a1,8(a5)
40003c80:	000700e7          	jalr	a4
					   sh_uart->ctrl_blk->context);
	}

	return 0;
}
40003c84:	01c12083          	lw	ra,28(sp)
40003c88:	01812403          	lw	s0,24(sp)
40003c8c:	01412483          	lw	s1,20(sp)
40003c90:	01012903          	lw	s2,16(sp)
40003c94:	00c12983          	lw	s3,12(sp)
40003c98:	00812a03          	lw	s4,8(sp)
40003c9c:	00000513          	li	a0,0
40003ca0:	02010113          	addi	sp,sp,32
40003ca4:	00008067          	ret
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
40003ca8:	0009a783          	lw	a5,0(s3)
40003cac:	00044583          	lbu	a1,0(s0)
40003cb0:	0007a503          	lw	a0,0(a5)
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
40003cb4:	00852783          	lw	a5,8(a0)
40003cb8:	00140413          	addi	s0,s0,1
40003cbc:	0047a783          	lw	a5,4(a5)
40003cc0:	000780e7          	jalr	a5
		for (size_t i = 0; i < length; i++) {
40003cc4:	fa5ff06f          	j	40003c68 <write+0x30>

40003cc8 <read>:

static int read(const struct shell_transport *transport,
		void *data, size_t length, size_t *cnt)
{
40003cc8:	ff010113          	addi	sp,sp,-16
40003ccc:	00812423          	sw	s0,8(sp)
40003cd0:	00112623          	sw	ra,12(sp)
	struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
40003cd4:	00452783          	lw	a5,4(a0)
{
40003cd8:	00068413          	mv	s0,a3
	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
40003cdc:	0107a503          	lw	a0,16(a5)
40003ce0:	dd5fe0ef          	jal	ra,40002ab4 <ring_buf_get>
40003ce4:	00a42023          	sw	a0,0(s0)

	return 0;
}
40003ce8:	00c12083          	lw	ra,12(sp)
40003cec:	00812403          	lw	s0,8(sp)
40003cf0:	00000513          	li	a0,0
40003cf4:	01010113          	addi	sp,sp,16
40003cf8:	00008067          	ret

40003cfc <uninit>:
{
40003cfc:	ff010113          	addi	sp,sp,-16
40003d00:	00112623          	sw	ra,12(sp)
		k_timer_stop(sh_uart->timer);
40003d04:	00452783          	lw	a5,4(a0)
40003d08:	0047a503          	lw	a0,4(a5)
	z_impl_k_timer_stop(timer);
40003d0c:	218270ef          	jal	ra,4002af24 <z_impl_k_timer_stop>
}
40003d10:	00c12083          	lw	ra,12(sp)
40003d14:	00000513          	li	a0,0
40003d18:	01010113          	addi	sp,sp,16
40003d1c:	00008067          	ret

40003d20 <timer_handler>:
{
40003d20:	fe010113          	addi	sp,sp,-32
40003d24:	00112e23          	sw	ra,28(sp)
40003d28:	00812c23          	sw	s0,24(sp)
 */
__syscall void *k_timer_user_data_get(const struct k_timer *timer);

static inline void *z_impl_k_timer_user_data_get(const struct k_timer *timer)
{
	return timer->user_data;
40003d2c:	03452403          	lw	s0,52(a0)
	while (uart_poll_in(sh_uart->ctrl_blk->dev, &c) == 0) {
40003d30:	00042783          	lw	a5,0(s0)
40003d34:	0007a503          	lw	a0,0(a5)
	if (api->poll_in == NULL) {
40003d38:	00852783          	lw	a5,8(a0)
40003d3c:	0007a783          	lw	a5,0(a5)
40003d40:	00078863          	beqz	a5,40003d50 <timer_handler+0x30>
	return api->poll_in(dev, p_char);
40003d44:	00f10593          	addi	a1,sp,15
40003d48:	000780e7          	jalr	a5
40003d4c:	00050a63          	beqz	a0,40003d60 <timer_handler+0x40>
}
40003d50:	01c12083          	lw	ra,28(sp)
40003d54:	01812403          	lw	s0,24(sp)
40003d58:	02010113          	addi	sp,sp,32
40003d5c:	00008067          	ret
		if (ring_buf_put(sh_uart->rx_ringbuf, &c, 1) == 0U) {
40003d60:	01042503          	lw	a0,16(s0)
40003d64:	00f10593          	addi	a1,sp,15
40003d68:	00100613          	li	a2,1
40003d6c:	c11fe0ef          	jal	ra,4000297c <ring_buf_put>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
40003d70:	00042783          	lw	a5,0(s0)
40003d74:	00000513          	li	a0,0
40003d78:	0047a703          	lw	a4,4(a5)
40003d7c:	0087a583          	lw	a1,8(a5)
40003d80:	000700e7          	jalr	a4
40003d84:	fadff06f          	j	40003d30 <timer_handler+0x10>

40003d88 <enable_shell_uart>:
	.update = update,
#endif /* CONFIG_MCUMGR_TRANSPORT_SHELL */
};

static int enable_shell_uart(void)
{
40003d88:	ff010113          	addi	sp,sp,-16
40003d8c:	00112623          	sw	ra,12(sp)
40003d90:	00812423          	sw	s0,8(sp)
40003d94:	4002c437          	lui	s0,0x4002c
40003d98:	87440513          	addi	a0,s0,-1932 # 4002b874 <__device_dts_ord_20>
40003d9c:	345230ef          	jal	ra,400278e0 <z_device_is_ready>
40003da0:	fed00793          	li	a5,-19
		(CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > LOG_LEVEL_DBG) ?
		CONFIG_LOG_MAX_LEVEL : CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL;
	static const struct shell_backend_config_flags cfg_flags =
					SHELL_DEFAULT_BACKEND_CONFIG_FLAGS;

	if (!device_is_ready(dev)) {
40003da4:	02050463          	beqz	a0,40003dcc <enable_shell_uart+0x44>

	if (IS_ENABLED(CONFIG_MCUMGR_TRANSPORT_SHELL)) {
		smp_shell_init();
	}

	shell_init(&shell_uart, dev, cfg_flags, log_backend, level);
40003da8:	4002c7b7          	lui	a5,0x4002c
40003dac:	af47a603          	lw	a2,-1292(a5) # 4002baf4 <cfg_flags.0>
40003db0:	4002c537          	lui	a0,0x4002c
40003db4:	00000713          	li	a4,0
40003db8:	00100693          	li	a3,1
40003dbc:	87440593          	addi	a1,s0,-1932
40003dc0:	a7850513          	addi	a0,a0,-1416 # 4002ba78 <shell_uart>
40003dc4:	299010ef          	jal	ra,4000585c <shell_init>

	return 0;
40003dc8:	00000793          	li	a5,0
}
40003dcc:	00c12083          	lw	ra,12(sp)
40003dd0:	00812403          	lw	s0,8(sp)
40003dd4:	00078513          	mv	a0,a5
40003dd8:	01010113          	addi	sp,sp,16
40003ddc:	00008067          	ret

40003de0 <init>:
{
40003de0:	ff010113          	addi	sp,sp,-16
40003de4:	00112623          	sw	ra,12(sp)
40003de8:	00812423          	sw	s0,8(sp)
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
40003dec:	00452403          	lw	s0,4(a0)
	sh_uart->ctrl_blk->dev = (const struct device *)config;
40003df0:	00042783          	lw	a5,0(s0)
40003df4:	00b7a023          	sw	a1,0(a5)
	sh_uart->ctrl_blk->handler = evt_handler;
40003df8:	00042783          	lw	a5,0(s0)
		k_timer_init(sh_uart->timer, timer_handler, NULL);
40003dfc:	400045b7          	lui	a1,0x40004
40003e00:	d2058593          	addi	a1,a1,-736 # 40003d20 <timer_handler>
	sh_uart->ctrl_blk->handler = evt_handler;
40003e04:	00c7a223          	sw	a2,4(a5)
	sh_uart->ctrl_blk->context = context;
40003e08:	00042783          	lw	a5,0(s0)
		k_timer_init(sh_uart->timer, timer_handler, NULL);
40003e0c:	00000613          	li	a2,0
	sh_uart->ctrl_blk->context = context;
40003e10:	00d7a423          	sw	a3,8(a5)
		k_timer_init(sh_uart->timer, timer_handler, NULL);
40003e14:	00442503          	lw	a0,4(s0)
40003e18:	010270ef          	jal	ra,4002ae28 <k_timer_init>
		k_timer_user_data_set(sh_uart->timer, (void *)sh_uart);
40003e1c:	00442783          	lw	a5,4(s0)
	timer->user_data = user_data;
40003e20:	0287aa23          	sw	s0,52(a5)
		k_timer_start(sh_uart->timer, RX_POLL_PERIOD, RX_POLL_PERIOD);
40003e24:	00442503          	lw	a0,4(s0)
	z_impl_k_timer_start(timer, duration, period);
40003e28:	00100693          	li	a3,1
40003e2c:	00000713          	li	a4,0
40003e30:	00100593          	li	a1,1
40003e34:	00000613          	li	a2,0
40003e38:	018270ef          	jal	ra,4002ae50 <z_impl_k_timer_start>
}
40003e3c:	00c12083          	lw	ra,12(sp)
40003e40:	00812403          	lw	s0,8(sp)
40003e44:	00000513          	li	a0,0
40003e48:	01010113          	addi	sp,sp,16
40003e4c:	00008067          	ret

40003e50 <uninit>:
	return 0;
}

static int uninit(const struct shell_transport *transport)
{
	if (sh_telnet == NULL) {
40003e50:	400317b7          	lui	a5,0x40031
40003e54:	a147a783          	lw	a5,-1516(a5) # 40030a14 <sh_telnet>
		return -ENODEV;
40003e58:	fed00513          	li	a0,-19
	if (sh_telnet == NULL) {
40003e5c:	00078463          	beqz	a5,40003e64 <uninit+0x14>
	}

	return 0;
40003e60:	00000513          	li	a0,0
}
40003e64:	00008067          	ret

40003e68 <enable>:

static int enable(const struct shell_transport *transport, bool blocking)
{
	if (sh_telnet == NULL) {
40003e68:	400317b7          	lui	a5,0x40031
40003e6c:	a147a783          	lw	a5,-1516(a5) # 40030a14 <sh_telnet>
		return -ENODEV;
40003e70:	fed00513          	li	a0,-19
	if (sh_telnet == NULL) {
40003e74:	00078463          	beqz	a5,40003e7c <enable+0x14>
	}

	return 0;
40003e78:	00000513          	li	a0,0
}
40003e7c:	00008067          	ret

40003e80 <enable_shell_telnet>:
	uint32_t level = (CONFIG_SHELL_TELNET_INIT_LOG_LEVEL > LOG_LEVEL_DBG) ?
		      CONFIG_LOG_MAX_LEVEL : CONFIG_SHELL_TELNET_INIT_LOG_LEVEL;
	static const struct shell_backend_config_flags cfg_flags =
					SHELL_DEFAULT_BACKEND_CONFIG_FLAGS;

	return shell_init(&shell_telnet, NULL, cfg_flags, log_backend, level);
40003e80:	4002c7b7          	lui	a5,0x4002c
40003e84:	af87a603          	lw	a2,-1288(a5) # 4002baf8 <cfg_flags.0>
40003e88:	4002c537          	lui	a0,0x4002c
40003e8c:	00000713          	li	a4,0
40003e90:	00100693          	li	a3,1
40003e94:	00000593          	li	a1,0
40003e98:	a4c50513          	addi	a0,a0,-1460 # 4002ba4c <shell_telnet>
40003e9c:	1c10106f          	j	4000585c <shell_init>

40003ea0 <telnet_accept>:
{
40003ea0:	ff010113          	addi	sp,sp,-16
40003ea4:	00812423          	sw	s0,8(sp)
40003ea8:	00112623          	sw	ra,12(sp)
40003eac:	00912223          	sw	s1,4(sp)
40003eb0:	00050413          	mv	s0,a0
	if (error) {
40003eb4:	06069063          	bnez	a3,40003f14 <telnet_accept+0x74>
	if (sh_telnet->client_ctx) {
40003eb8:	400314b7          	lui	s1,0x40031
40003ebc:	a144a783          	lw	a5,-1516(s1) # 40030a14 <sh_telnet>
40003ec0:	05c7a783          	lw	a5,92(a5)
40003ec4:	04079863          	bnez	a5,40003f14 <telnet_accept+0x74>
	if (net_context_recv(client, telnet_recv, K_NO_WAIT, NULL)) {
40003ec8:	400045b7          	lui	a1,0x40004
40003ecc:	00000713          	li	a4,0
40003ed0:	00000613          	li	a2,0
40003ed4:	00000693          	li	a3,0
40003ed8:	47858593          	addi	a1,a1,1144 # 40004478 <telnet_recv>
40003edc:	7c00e0ef          	jal	ra,4001269c <net_context_recv>
40003ee0:	02051a63          	bnez	a0,40003f14 <telnet_accept+0x74>
	NET_ASSERT(context);

	if (accepting) {
		context->flags |= NET_CONTEXT_ACCEPTING_SOCK;
	} else {
		context->flags &= ~NET_CONTEXT_ACCEPTING_SOCK;
40003ee4:	07445783          	lhu	a5,116(s0)
	ret = shell_echo_set(sh_telnet->shell_context, false);
40003ee8:	00000593          	li	a1,0
40003eec:	dff7f793          	andi	a5,a5,-513
40003ef0:	06f41a23          	sh	a5,116(s0)
	sh_telnet->client_ctx = client;
40003ef4:	a144a783          	lw	a5,-1516(s1)
40003ef8:	0487ae23          	sw	s0,92(a5)
}
40003efc:	00812403          	lw	s0,8(sp)
40003f00:	00c12083          	lw	ra,12(sp)
40003f04:	00412483          	lw	s1,4(sp)
	ret = shell_echo_set(sh_telnet->shell_context, false);
40003f08:	0047a503          	lw	a0,4(a5)
}
40003f0c:	01010113          	addi	sp,sp,16
	ret = shell_echo_set(sh_telnet->shell_context, false);
40003f10:	09c0206f          	j	40005fac <shell_echo_set>
	net_context_put(client);
40003f14:	00040513          	mv	a0,s0
}
40003f18:	00812403          	lw	s0,8(sp)
40003f1c:	00c12083          	lw	ra,12(sp)
40003f20:	00412483          	lw	s1,4(sp)
40003f24:	01010113          	addi	sp,sp,16
	net_context_put(client);
40003f28:	0950d06f          	j	400117bc <net_context_put>

40003f2c <telnet_setup_server.constprop.0>:
static void telnet_setup_server(struct net_context **ctx, sa_family_t family,
40003f2c:	ff010113          	addi	sp,sp,-16
40003f30:	00812423          	sw	s0,8(sp)
40003f34:	00050413          	mv	s0,a0
40003f38:	00912223          	sw	s1,4(sp)
40003f3c:	01212023          	sw	s2,0(sp)
40003f40:	00058513          	mv	a0,a1
40003f44:	00060493          	mv	s1,a2
40003f48:	00068913          	mv	s2,a3
	if (net_context_get(family, SOCK_STREAM, IPPROTO_TCP, ctx)) {
40003f4c:	00600613          	li	a2,6
40003f50:	00040693          	mv	a3,s0
40003f54:	00100593          	li	a1,1
static void telnet_setup_server(struct net_context **ctx, sa_family_t family,
40003f58:	00112623          	sw	ra,12(sp)
	if (net_context_get(family, SOCK_STREAM, IPPROTO_TCP, ctx)) {
40003f5c:	5840d0ef          	jal	ra,400114e0 <net_context_get>
40003f60:	04051463          	bnez	a0,40003fa8 <telnet_setup_server.constprop.0+0x7c>
	if (net_context_bind(*ctx, addr, addrlen)) {
40003f64:	00042503          	lw	a0,0(s0)
40003f68:	00090613          	mv	a2,s2
40003f6c:	00048593          	mv	a1,s1
40003f70:	0d90d0ef          	jal	ra,40011848 <net_context_bind>
40003f74:	02051a63          	bnez	a0,40003fa8 <telnet_setup_server.constprop.0+0x7c>
	if (net_context_listen(*ctx, 0)) {
40003f78:	00042503          	lw	a0,0(s0)
40003f7c:	00000593          	li	a1,0
40003f80:	3dd0d0ef          	jal	ra,40011b5c <net_context_listen>
40003f84:	02051263          	bnez	a0,40003fa8 <telnet_setup_server.constprop.0+0x7c>
	if (net_context_accept(*ctx, telnet_accept, K_NO_WAIT, NULL)) {
40003f88:	00042503          	lw	a0,0(s0)
40003f8c:	400045b7          	lui	a1,0x40004
40003f90:	00000713          	li	a4,0
40003f94:	00000613          	li	a2,0
40003f98:	00000693          	li	a3,0
40003f9c:	ea058593          	addi	a1,a1,-352 # 40003ea0 <telnet_accept>
40003fa0:	4d40e0ef          	jal	ra,40012474 <net_context_accept>
40003fa4:	00050a63          	beqz	a0,40003fb8 <telnet_setup_server.constprop.0+0x8c>
	if (*ctx) {
40003fa8:	00042503          	lw	a0,0(s0)
40003fac:	00050663          	beqz	a0,40003fb8 <telnet_setup_server.constprop.0+0x8c>
		(void)net_context_put(*ctx);
40003fb0:	00d0d0ef          	jal	ra,400117bc <net_context_put>
		*ctx = NULL;
40003fb4:	00042023          	sw	zero,0(s0)
}
40003fb8:	00c12083          	lw	ra,12(sp)
40003fbc:	00812403          	lw	s0,8(sp)
40003fc0:	00412483          	lw	s1,4(sp)
40003fc4:	00012903          	lw	s2,0(sp)
40003fc8:	01010113          	addi	sp,sp,16
40003fcc:	00008067          	ret

40003fd0 <init>:
{
40003fd0:	fd010113          	addi	sp,sp,-48
40003fd4:	02112623          	sw	ra,44(sp)
40003fd8:	02812423          	sw	s0,40(sp)
40003fdc:	02912223          	sw	s1,36(sp)
40003fe0:	03212023          	sw	s2,32(sp)
	sh_telnet = (struct shell_telnet *)transport->ctx;
40003fe4:	00452503          	lw	a0,4(a0)
40003fe8:	40031437          	lui	s0,0x40031
{
40003fec:	00060913          	mv	s2,a2
	memset(sh_telnet, 0, sizeof(struct shell_telnet));
40003ff0:	00000593          	li	a1,0
40003ff4:	0d800613          	li	a2,216
{
40003ff8:	00068493          	mv	s1,a3
	sh_telnet = (struct shell_telnet *)transport->ctx;
40003ffc:	a0a42a23          	sw	a0,-1516(s0) # 40030a14 <sh_telnet>
	memset(sh_telnet, 0, sizeof(struct shell_telnet));
40004000:	070050ef          	jal	ra,40009070 <memset>
	sh_telnet->shell_handler = evt_handler;
40004004:	a1442783          	lw	a5,-1516(s0)
		telnet_setup_server(&ctx4, AF_INET,
40004008:	40031537          	lui	a0,0x40031
4000400c:	00810613          	addi	a2,sp,8
	sh_telnet->shell_handler = evt_handler;
40004010:	0127a023          	sw	s2,0(a5)
	sh_telnet->shell_context = context;
40004014:	a1442783          	lw	a5,-1516(s0)
		telnet_setup_server(&ctx4, AF_INET,
40004018:	00800693          	li	a3,8
4000401c:	00100593          	li	a1,1
	sh_telnet->shell_context = context;
40004020:	0097a223          	sw	s1,4(a5)
		struct sockaddr_in any_addr4 = {
40004024:	170004b7          	lui	s1,0x17000
40004028:	00148793          	addi	a5,s1,1 # 17000001 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x110a1f01>
		telnet_setup_server(&ctx4, AF_INET,
4000402c:	a1050513          	addi	a0,a0,-1520 # 40030a10 <ctx4.3>
		struct sockaddr_in any_addr4 = {
40004030:	00f12423          	sw	a5,8(sp)
40004034:	00012623          	sw	zero,12(sp)
		telnet_setup_server(&ctx4, AF_INET,
40004038:	ef5ff0ef          	jal	ra,40003f2c <telnet_setup_server.constprop.0>
		telnet_setup_server(&ctx6, AF_INET6,
4000403c:	40031537          	lui	a0,0x40031
		struct sockaddr_in6 any_addr6 = {
40004040:	00248493          	addi	s1,s1,2
		telnet_setup_server(&ctx6, AF_INET6,
40004044:	01800693          	li	a3,24
40004048:	00810613          	addi	a2,sp,8
4000404c:	00200593          	li	a1,2
40004050:	a0c50513          	addi	a0,a0,-1524 # 40030a0c <ctx6.2>
		struct sockaddr_in6 any_addr6 = {
40004054:	00912423          	sw	s1,8(sp)
40004058:	00012623          	sw	zero,12(sp)
4000405c:	00012823          	sw	zero,16(sp)
40004060:	00012a23          	sw	zero,20(sp)
40004064:	00012c23          	sw	zero,24(sp)
40004068:	00012e23          	sw	zero,28(sp)
		telnet_setup_server(&ctx6, AF_INET6,
4000406c:	ec1ff0ef          	jal	ra,40003f2c <telnet_setup_server.constprop.0>
	k_fifo_init(&sh_telnet->rx_fifo);
40004070:	a1442503          	lw	a0,-1516(s0)
40004074:	06050513          	addi	a0,a0,96
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_QUEUE_INIT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_queue_init(queue);
40004078:	3a9240ef          	jal	ra,40028c20 <z_impl_k_queue_init>
	k_work_init_delayable(&sh_telnet->send_work, telnet_send_prematurely);
4000407c:	a1442503          	lw	a0,-1516(s0)
40004080:	400045b7          	lui	a1,0x40004
40004084:	40c58593          	addi	a1,a1,1036 # 4000440c <telnet_send_prematurely>
40004088:	07850513          	addi	a0,a0,120
4000408c:	448250ef          	jal	ra,400294d4 <k_work_init_delayable>
}
40004090:	02c12083          	lw	ra,44(sp)
40004094:	02812403          	lw	s0,40(sp)
40004098:	02412483          	lw	s1,36(sp)
4000409c:	02012903          	lw	s2,32(sp)
400040a0:	00000513          	li	a0,0
400040a4:	03010113          	addi	sp,sp,48
400040a8:	00008067          	ret

400040ac <read>:
{
400040ac:	fe010113          	addi	sp,sp,-32
400040b0:	01412423          	sw	s4,8(sp)
	if (sh_telnet == NULL) {
400040b4:	40031a37          	lui	s4,0x40031
400040b8:	a14a2783          	lw	a5,-1516(s4) # 40030a14 <sh_telnet>
{
400040bc:	00112e23          	sw	ra,28(sp)
400040c0:	00812c23          	sw	s0,24(sp)
400040c4:	00912a23          	sw	s1,20(sp)
400040c8:	01212823          	sw	s2,16(sp)
400040cc:	01312623          	sw	s3,12(sp)
400040d0:	01512223          	sw	s5,4(sp)
400040d4:	fed00513          	li	a0,-19
	if (sh_telnet == NULL) {
400040d8:	08078063          	beqz	a5,40004158 <read+0xac>
	if (sh_telnet->client_ctx == NULL) {
400040dc:	05c7a703          	lw	a4,92(a5)
400040e0:	00058993          	mv	s3,a1
400040e4:	00060913          	mv	s2,a2
400040e8:	00068413          	mv	s0,a3
400040ec:	08070863          	beqz	a4,4000417c <read+0xd0>
		union { uintptr_t x; struct k_queue * val; } parm0 = { .val = queue };
		return (void *) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_QUEUE_PEEK_HEAD);
	}
#endif
	compiler_barrier();
	return z_impl_k_queue_peek_head(queue);
400040f0:	06078513          	addi	a0,a5,96
400040f4:	44d240ef          	jal	ra,40028d40 <z_impl_k_queue_peek_head>
400040f8:	00050493          	mv	s1,a0
	if (pkt == NULL) {
400040fc:	08050063          	beqz	a0,4000417c <read+0xd0>
	read_len = net_pkt_remaining_data(pkt);
40004100:	2690f0ef          	jal	ra,40013b68 <net_pkt_remaining_data>
40004104:	00050613          	mv	a2,a0
	bool flush = true;
40004108:	00100a93          	li	s5,1
	if (read_len > length) {
4000410c:	00a97663          	bgeu	s2,a0,40004118 <read+0x6c>
40004110:	00090613          	mv	a2,s2
		flush = false;
40004114:	00000a93          	li	s5,0
	*cnt = read_len;
40004118:	00c42023          	sw	a2,0(s0)
	if (net_pkt_read(pkt, data, read_len) < 0) {
4000411c:	00098593          	mv	a1,s3
40004120:	00048513          	mv	a0,s1
40004124:	0a90f0ef          	jal	ra,400139cc <net_pkt_read>
40004128:	02055463          	bgez	a0,40004150 <read+0xa4>
		*cnt = 0;
4000412c:	00042023          	sw	zero,0(s0)
		(void)k_fifo_get(&sh_telnet->rx_fifo, K_NO_WAIT);
40004130:	a14a2503          	lw	a0,-1516(s4)
40004134:	06050513          	addi	a0,a0,96
	return z_impl_k_queue_get(queue, timeout);
40004138:	00000593          	li	a1,0
4000413c:	00000613          	li	a2,0
40004140:	32d240ef          	jal	ra,40028c6c <z_impl_k_queue_get>
		net_pkt_unref(pkt);
40004144:	00048513          	mv	a0,s1
40004148:	5d50e0ef          	jal	ra,40012f1c <net_pkt_unref>
4000414c:	0080006f          	j	40004154 <read+0xa8>
	if (flush) {
40004150:	fe0a90e3          	bnez	s5,40004130 <read+0x84>
	return 0;
40004154:	00000513          	li	a0,0
}
40004158:	01c12083          	lw	ra,28(sp)
4000415c:	01812403          	lw	s0,24(sp)
40004160:	01412483          	lw	s1,20(sp)
40004164:	01012903          	lw	s2,16(sp)
40004168:	00c12983          	lw	s3,12(sp)
4000416c:	00812a03          	lw	s4,8(sp)
40004170:	00412a83          	lw	s5,4(sp)
40004174:	02010113          	addi	sp,sp,32
40004178:	00008067          	ret
	*cnt = 0;
4000417c:	00042023          	sw	zero,0(s0)
	return 0;
40004180:	fd5ff06f          	j	40004154 <read+0xa8>

40004184 <telnet_end_client_connection>:
{
40004184:	ff010113          	addi	sp,sp,-16
40004188:	00812423          	sw	s0,8(sp)
	(void)net_context_put(sh_telnet->client_ctx);
4000418c:	40031437          	lui	s0,0x40031
40004190:	a1442783          	lw	a5,-1516(s0) # 40030a14 <sh_telnet>
{
40004194:	00112623          	sw	ra,12(sp)
	(void)net_context_put(sh_telnet->client_ctx);
40004198:	05c7a503          	lw	a0,92(a5)
4000419c:	6200d0ef          	jal	ra,400117bc <net_context_put>
	sh_telnet->client_ctx = NULL;
400041a0:	a1442503          	lw	a0,-1516(s0)
400041a4:	04052e23          	sw	zero,92(a0)
	sh_telnet->output_lock = false;
400041a8:	0c050823          	sb	zero,208(a0)
	k_work_cancel_delayable_sync(&sh_telnet->send_work,
400041ac:	0a850593          	addi	a1,a0,168
400041b0:	07850513          	addi	a0,a0,120
400041b4:	4c8250ef          	jal	ra,4002967c <k_work_cancel_delayable_sync>
	while ((pkt = k_fifo_get(&sh_telnet->rx_fifo, K_NO_WAIT)) != NULL) {
400041b8:	a1442503          	lw	a0,-1516(s0)
400041bc:	06050513          	addi	a0,a0,96
400041c0:	00000593          	li	a1,0
400041c4:	00000613          	li	a2,0
400041c8:	2a5240ef          	jal	ra,40028c6c <z_impl_k_queue_get>
400041cc:	00051a63          	bnez	a0,400041e0 <telnet_end_client_connection+0x5c>
}
400041d0:	00c12083          	lw	ra,12(sp)
400041d4:	00812403          	lw	s0,8(sp)
400041d8:	01010113          	addi	sp,sp,16
400041dc:	00008067          	ret
		net_pkt_unref(pkt);
400041e0:	53d0e0ef          	jal	ra,40012f1c <net_pkt_unref>
400041e4:	fd5ff06f          	j	400041b8 <telnet_end_client_connection+0x34>

400041e8 <telnet_send>:
{
400041e8:	ff010113          	addi	sp,sp,-16
400041ec:	00912223          	sw	s1,4(sp)
	if (sh_telnet->line_out.len == 0) {
400041f0:	400314b7          	lui	s1,0x40031
400041f4:	a144a583          	lw	a1,-1516(s1) # 40030a14 <sh_telnet>
{
400041f8:	00112623          	sw	ra,12(sp)
400041fc:	00812423          	sw	s0,8(sp)
	if (sh_telnet->line_out.len == 0) {
40004200:	0585d603          	lhu	a2,88(a1)
40004204:	04060c63          	beqz	a2,4000425c <telnet_send+0x74>
	if (sh_telnet->client_ctx == NULL) {
40004208:	05c5a503          	lw	a0,92(a1)
		return -ENOTCONN;
4000420c:	f8000413          	li	s0,-128
	if (sh_telnet->client_ctx == NULL) {
40004210:	02050663          	beqz	a0,4000423c <telnet_send+0x54>
	err = net_context_send(sh_telnet->client_ctx, sh_telnet->line_out.buf,
40004214:	400046b7          	lui	a3,0x40004
40004218:	00000813          	li	a6,0
4000421c:	fff00713          	li	a4,-1
40004220:	fff00793          	li	a5,-1
40004224:	41068693          	addi	a3,a3,1040 # 40004410 <telnet_sent_cb>
40004228:	00858593          	addi	a1,a1,8
4000422c:	30c0e0ef          	jal	ra,40012538 <net_context_send>
40004230:	00050413          	mv	s0,a0
	if (err < 0) {
40004234:	02055063          	bgez	a0,40004254 <telnet_send+0x6c>
		telnet_end_client_connection();
40004238:	f4dff0ef          	jal	ra,40004184 <telnet_end_client_connection>
}
4000423c:	00c12083          	lw	ra,12(sp)
40004240:	00040513          	mv	a0,s0
40004244:	00812403          	lw	s0,8(sp)
40004248:	00412483          	lw	s1,4(sp)
4000424c:	01010113          	addi	sp,sp,16
40004250:	00008067          	ret
	sh_telnet->line_out.len = 0;
40004254:	a144a783          	lw	a5,-1516(s1)
40004258:	04079c23          	sh	zero,88(a5)
		return 0;
4000425c:	00000413          	li	s0,0
40004260:	fddff06f          	j	4000423c <telnet_send+0x54>

40004264 <write>:
{
40004264:	fd010113          	addi	sp,sp,-48
40004268:	01412c23          	sw	s4,24(sp)
	if (sh_telnet == NULL) {
4000426c:	40031a37          	lui	s4,0x40031
40004270:	a14a2783          	lw	a5,-1516(s4) # 40030a14 <sh_telnet>
{
40004274:	02812423          	sw	s0,40(sp)
40004278:	02112623          	sw	ra,44(sp)
4000427c:	02912223          	sw	s1,36(sp)
40004280:	03212023          	sw	s2,32(sp)
40004284:	01312e23          	sw	s3,28(sp)
40004288:	01512a23          	sw	s5,20(sp)
4000428c:	01612823          	sw	s6,16(sp)
40004290:	01712623          	sw	s7,12(sp)
40004294:	01812423          	sw	s8,8(sp)
40004298:	01912223          	sw	s9,4(sp)
4000429c:	01a12023          	sw	s10,0(sp)
400042a0:	00068413          	mv	s0,a3
	if (sh_telnet == NULL) {
400042a4:	04079263          	bnez	a5,400042e8 <write+0x84>
		*cnt = 0;
400042a8:	0006a023          	sw	zero,0(a3)
		return -ENODEV;
400042ac:	fed00513          	li	a0,-19
}
400042b0:	02c12083          	lw	ra,44(sp)
400042b4:	02812403          	lw	s0,40(sp)
400042b8:	02412483          	lw	s1,36(sp)
400042bc:	02012903          	lw	s2,32(sp)
400042c0:	01c12983          	lw	s3,28(sp)
400042c4:	01812a03          	lw	s4,24(sp)
400042c8:	01412a83          	lw	s5,20(sp)
400042cc:	01012b03          	lw	s6,16(sp)
400042d0:	00c12b83          	lw	s7,12(sp)
400042d4:	00812c03          	lw	s8,8(sp)
400042d8:	00412c83          	lw	s9,4(sp)
400042dc:	00012d03          	lw	s10,0(sp)
400042e0:	03010113          	addi	sp,sp,48
400042e4:	00008067          	ret
	if (sh_telnet->client_ctx == NULL || sh_telnet->output_lock) {
400042e8:	05c7a703          	lw	a4,92(a5)
400042ec:	00060913          	mv	s2,a2
400042f0:	00070663          	beqz	a4,400042fc <write+0x98>
400042f4:	0d07c783          	lbu	a5,208(a5)
400042f8:	00078863          	beqz	a5,40004308 <write+0xa4>
		*cnt = length;
400042fc:	01242023          	sw	s2,0(s0)
		return 0;
40004300:	00000513          	li	a0,0
40004304:	fadff06f          	j	400042b0 <write+0x4c>
	*cnt = 0;
40004308:	0006a023          	sw	zero,0(a3)
	lb = &sh_telnet->line_out;
4000430c:	a14a2483          	lw	s1,-1516(s4)
40004310:	00058b93          	mv	s7,a1
		if (lb->len + length - *cnt > TELNET_LINE_SIZE) {
40004314:	05000d13          	li	s10,80
}

static inline k_ticks_t k_work_delayable_remaining_get(
	const struct k_work_delayable *dwork)
{
	return z_timeout_remaining(&dwork->timeout);
40004318:	08848513          	addi	a0,s1,136
4000431c:	6cc260ef          	jal	ra,4002a9e8 <z_timeout_remaining>
40004320:	00050a93          	mv	s5,a0
	was_running = k_work_cancel_delayable_sync(&sh_telnet->send_work,
40004324:	a14a2503          	lw	a0,-1516(s4)
		memcpy(lb->buf + lb->len, (uint8_t *)data + *cnt, copy_len);
40004328:	00848c13          	addi	s8,s1,8
		if (lb->buf[lb->len - 1] == '\n' ||
4000432c:	00a00c93          	li	s9,10
	was_running = k_work_cancel_delayable_sync(&sh_telnet->send_work,
40004330:	0a850593          	addi	a1,a0,168
40004334:	07850513          	addi	a0,a0,120
40004338:	344250ef          	jal	ra,4002967c <k_work_cancel_delayable_sync>
4000433c:	00050b13          	mv	s6,a0
		if (lb->len + length - *cnt > TELNET_LINE_SIZE) {
40004340:	0584d503          	lhu	a0,88(s1)
40004344:	00042583          	lw	a1,0(s0)
40004348:	012507b3          	add	a5,a0,s2
4000434c:	40b787b3          	sub	a5,a5,a1
			copy_len = length - *cnt;
40004350:	40b909b3          	sub	s3,s2,a1
		if (lb->len + length - *cnt > TELNET_LINE_SIZE) {
40004354:	00fd7463          	bgeu	s10,a5,4000435c <write+0xf8>
			copy_len = TELNET_LINE_SIZE - lb->len;
40004358:	40ad09b3          	sub	s3,s10,a0
		memcpy(lb->buf + lb->len, (uint8_t *)data + *cnt, copy_len);
4000435c:	00098613          	mv	a2,s3
40004360:	00bb85b3          	add	a1,s7,a1
40004364:	00ac0533          	add	a0,s8,a0
40004368:	4e5040ef          	jal	ra,4000904c <memcpy>
		lb->len += copy_len;
4000436c:	0584d783          	lhu	a5,88(s1)
40004370:	013787b3          	add	a5,a5,s3
40004374:	01079793          	slli	a5,a5,0x10
40004378:	0107d793          	srli	a5,a5,0x10
4000437c:	04f49c23          	sh	a5,88(s1)
		if (lb->buf[lb->len - 1] == '\n' ||
40004380:	00f48733          	add	a4,s1,a5
40004384:	00774703          	lbu	a4,7(a4)
40004388:	01970463          	beq	a4,s9,40004390 <write+0x12c>
4000438c:	01a79a63          	bne	a5,s10,400043a0 <write+0x13c>
			err = telnet_send();
40004390:	e59ff0ef          	jal	ra,400041e8 <telnet_send>
			if (err != 0) {
40004394:	00050663          	beqz	a0,400043a0 <write+0x13c>
				*cnt = length;
40004398:	01242023          	sw	s2,0(s0)
				return err;
4000439c:	f15ff06f          	j	400042b0 <write+0x4c>
		*cnt += copy_len;
400043a0:	00042783          	lw	a5,0(s0)
400043a4:	00f989b3          	add	s3,s3,a5
400043a8:	01342023          	sw	s3,0(s0)
	} while (*cnt < length);
400043ac:	f929eae3          	bltu	s3,s2,40004340 <write+0xdc>
	if (lb->len > 0) {
400043b0:	0584d783          	lhu	a5,88(s1)
400043b4:	04078063          	beqz	a5,400043f4 <write+0x190>
		timeout = was_running ? timeout : TELNET_TIMEOUT;
400043b8:	06400593          	li	a1,100
400043bc:	000b0663          	beqz	s6,400043c8 <write+0x164>
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
400043c0:	00a00593          	li	a1,10
400043c4:	035585b3          	mul	a1,a1,s5
		k_work_reschedule(&sh_telnet->send_work, K_MSEC(timeout));
400043c8:	a14a2403          	lw	s0,-1516(s4)
		t += off;
400043cc:	00958513          	addi	a0,a1,9
			return t / ((uint64_t)from_hz / to_hz);
400043d0:	00a00613          	li	a2,10
400043d4:	00000693          	li	a3,0
400043d8:	00b535b3          	sltu	a1,a0,a1
400043dc:	eddfb0ef          	jal	ra,400002b8 <__udivdi3>
400043e0:	07840413          	addi	s0,s0,120
400043e4:	00058613          	mv	a2,a1
400043e8:	00050593          	mv	a1,a0
400043ec:	00040513          	mv	a0,s0
400043f0:	234250ef          	jal	ra,40029624 <k_work_reschedule>
	sh_telnet->shell_handler(SHELL_TRANSPORT_EVT_TX_RDY,
400043f4:	a14a2783          	lw	a5,-1516(s4)
400043f8:	00100513          	li	a0,1
400043fc:	0007a703          	lw	a4,0(a5)
40004400:	0047a583          	lw	a1,4(a5)
40004404:	000700e7          	jalr	a4
	return 0;
40004408:	ef9ff06f          	j	40004300 <write+0x9c>

4000440c <telnet_send_prematurely>:
	(void)telnet_send();
4000440c:	dddff06f          	j	400041e8 <telnet_send>

40004410 <telnet_sent_cb>:
	if (status < 0) {
40004410:	0005d463          	bgez	a1,40004418 <telnet_sent_cb+0x8>
		telnet_end_client_connection();
40004414:	d71ff06f          	j	40004184 <telnet_end_client_connection>
}
40004418:	00008067          	ret

4000441c <telnet_command_send_reply>:
	if (sh_telnet->client_ctx == NULL) {
4000441c:	400317b7          	lui	a5,0x40031
40004420:	a147a783          	lw	a5,-1516(a5) # 40030a14 <sh_telnet>
{
40004424:	00050893          	mv	a7,a0
	if (sh_telnet->client_ctx == NULL) {
40004428:	05c7a503          	lw	a0,92(a5)
4000442c:	04050463          	beqz	a0,40004474 <telnet_command_send_reply+0x58>
	err = net_context_send(sh_telnet->client_ctx, msg, len, telnet_sent_cb,
40004430:	400046b7          	lui	a3,0x40004
{
40004434:	ff010113          	addi	sp,sp,-16
40004438:	00058613          	mv	a2,a1
	err = net_context_send(sh_telnet->client_ctx, msg, len, telnet_sent_cb,
4000443c:	00000813          	li	a6,0
40004440:	fff00713          	li	a4,-1
40004444:	fff00793          	li	a5,-1
40004448:	41068693          	addi	a3,a3,1040 # 40004410 <telnet_sent_cb>
4000444c:	00088593          	mv	a1,a7
{
40004450:	00112623          	sw	ra,12(sp)
	err = net_context_send(sh_telnet->client_ctx, msg, len, telnet_sent_cb,
40004454:	0e40e0ef          	jal	ra,40012538 <net_context_send>
	if (err < 0) {
40004458:	00055863          	bgez	a0,40004468 <telnet_command_send_reply+0x4c>
}
4000445c:	00c12083          	lw	ra,12(sp)
40004460:	01010113          	addi	sp,sp,16
		telnet_end_client_connection();
40004464:	d21ff06f          	j	40004184 <telnet_end_client_connection>
}
40004468:	00c12083          	lw	ra,12(sp)
4000446c:	01010113          	addi	sp,sp,16
40004470:	00008067          	ret
40004474:	00008067          	ret

40004478 <telnet_recv>:
	if (!pkt || status) {
40004478:	00058463          	beqz	a1,40004480 <telnet_recv+0x8>
4000447c:	00070463          	beqz	a4,40004484 <telnet_recv+0xc>
		telnet_end_client_connection();
40004480:	d05ff06f          	j	40004184 <telnet_end_client_connection>
{
40004484:	fc010113          	addi	sp,sp,-64
40004488:	03212823          	sw	s2,48(sp)
4000448c:	00050913          	mv	s2,a0
	len = net_pkt_remaining_data(pkt);
40004490:	00058513          	mv	a0,a1
{
40004494:	02112e23          	sw	ra,60(sp)
40004498:	02812c23          	sw	s0,56(sp)
4000449c:	02912a23          	sw	s1,52(sp)
400044a0:	03312623          	sw	s3,44(sp)
400044a4:	03412423          	sw	s4,40(sp)
400044a8:	03512223          	sw	s5,36(sp)
400044ac:	03612023          	sw	s6,32(sp)
400044b0:	01712e23          	sw	s7,28(sp)
400044b4:	01812c23          	sw	s8,24(sp)
400044b8:	00058413          	mv	s0,a1
400044bc:	01912a23          	sw	s9,20(sp)
	len = net_pkt_remaining_data(pkt);
400044c0:	6a80f0ef          	jal	ra,40013b68 <net_pkt_remaining_data>
	(void)net_context_update_recv_wnd(client, len);
400044c4:	00050593          	mv	a1,a0
	len = net_pkt_remaining_data(pkt);
400044c8:	00050493          	mv	s1,a0
	(void)net_context_update_recv_wnd(client, len);
400044cc:	00090513          	mv	a0,s2
400044d0:	4140e0ef          	jal	ra,400128e4 <net_context_update_recv_wnd>
	while (len >= TELNET_MIN_COMMAND_LEN) {
400044d4:	00100913          	li	s2,1
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(cmd_access, uint16_t);
400044d8:	00200993          	li	s3,2
	if (!cmd || cmd->iac != NVT_CMD_IAC) {
400044dc:	0ff00a13          	li	s4,255
	switch (cmd->op) {
400044e0:	0f600a93          	li	s5,246
400044e4:	0fd00b13          	li	s6,253
400044e8:	0f500b93          	li	s7,245
	if (cmd->op == NVT_CMD_SB) {
400044ec:	0fa00c13          	li	s8,250
	while (len >= TELNET_MIN_COMMAND_LEN) {
400044f0:	06996063          	bltu	s2,s1,40004550 <telnet_recv+0xd8>
	if (len == 0) {
400044f4:	12048663          	beqz	s1,40004620 <telnet_recv+0x1a8>
	k_fifo_put(&sh_telnet->rx_fifo, pkt);
400044f8:	400314b7          	lui	s1,0x40031
400044fc:	a144a503          	lw	a0,-1516(s1) # 40030a14 <sh_telnet>
40004500:	00040593          	mv	a1,s0
40004504:	06050513          	addi	a0,a0,96
40004508:	73c240ef          	jal	ra,40028c44 <k_queue_append>
	sh_telnet->shell_handler(SHELL_TRANSPORT_EVT_RX_RDY,
4000450c:	a144a783          	lw	a5,-1516(s1)
}
40004510:	03812403          	lw	s0,56(sp)
40004514:	03c12083          	lw	ra,60(sp)
40004518:	03412483          	lw	s1,52(sp)
4000451c:	03012903          	lw	s2,48(sp)
40004520:	02c12983          	lw	s3,44(sp)
40004524:	02812a03          	lw	s4,40(sp)
40004528:	02412a83          	lw	s5,36(sp)
4000452c:	02012b03          	lw	s6,32(sp)
40004530:	01c12b83          	lw	s7,28(sp)
40004534:	01812c03          	lw	s8,24(sp)
40004538:	01412c83          	lw	s9,20(sp)
	sh_telnet->shell_handler(SHELL_TRANSPORT_EVT_RX_RDY,
4000453c:	0007a703          	lw	a4,0(a5)
40004540:	0047a583          	lw	a1,4(a5)
40004544:	00000513          	li	a0,0
}
40004548:	04010113          	addi	sp,sp,64
	sh_telnet->shell_handler(SHELL_TRANSPORT_EVT_RX_RDY,
4000454c:	00070067          	jr	a4
	cmd = (struct telnet_simple_command *)net_pkt_get_data(pkt,
40004550:	00810593          	addi	a1,sp,8
40004554:	00040513          	mv	a0,s0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(cmd_access, uint16_t);
40004558:	00012423          	sw	zero,8(sp)
4000455c:	01312623          	sw	s3,12(sp)
	cmd = (struct telnet_simple_command *)net_pkt_get_data(pkt,
40004560:	21d0f0ef          	jal	ra,40013f7c <net_pkt_get_data>
40004564:	00050493          	mv	s1,a0
	if (!cmd || cmd->iac != NVT_CMD_IAC) {
40004568:	f80508e3          	beqz	a0,400044f8 <telnet_recv+0x80>
4000456c:	00054783          	lbu	a5,0(a0)
40004570:	f94794e3          	bne	a5,s4,400044f8 <telnet_recv+0x80>
	switch (cmd->op) {
40004574:	00154783          	lbu	a5,1(a0)
40004578:	07578263          	beq	a5,s5,400045dc <telnet_recv+0x164>
4000457c:	09678063          	beq	a5,s6,400045fc <telnet_recv+0x184>
40004580:	03779063          	bne	a5,s7,400045a0 <telnet_recv+0x128>
		sh_telnet->output_lock = true;
40004584:	400317b7          	lui	a5,0x40031
40004588:	a147a503          	lw	a0,-1516(a5) # 40030a14 <sh_telnet>
4000458c:	0d250823          	sb	s2,208(a0)
		sh_telnet->line_out.len = 0;
40004590:	04051c23          	sh	zero,88(a0)
		k_work_cancel_delayable_sync(&sh_telnet->send_work,
40004594:	0a850593          	addi	a1,a0,168
40004598:	07850513          	addi	a0,a0,120
4000459c:	0e0250ef          	jal	ra,4002967c <k_work_cancel_delayable_sync>
	if (cmd->op == NVT_CMD_SB) {
400045a0:	0014c783          	lbu	a5,1(s1)
400045a4:	07878e63          	beq	a5,s8,40004620 <telnet_recv+0x1a8>
	    cmd->op == NVT_CMD_DO || cmd->op == NVT_CMD_DONT) {
400045a8:	00578793          	addi	a5,a5,5
	if (cmd->op == NVT_CMD_WILL || cmd->op == NVT_CMD_WONT ||
400045ac:	0ff7f793          	zext.b	a5,a5
400045b0:	00300713          	li	a4,3
		return TELNET_WILL_DO_COMMAND_LEN;
400045b4:	00300593          	li	a1,3
	if (cmd->op == NVT_CMD_WILL || cmd->op == NVT_CMD_WONT ||
400045b8:	00f77463          	bgeu	a4,a5,400045c0 <telnet_recv+0x148>
	return TELNET_MIN_COMMAND_LEN;
400045bc:	00200593          	li	a1,2
			ret = net_pkt_skip(pkt, ret);
400045c0:	00040513          	mv	a0,s0
400045c4:	1a00f0ef          	jal	ra,40013764 <net_pkt_skip>
			if (ret < 0) {
400045c8:	04054c63          	bltz	a0,40004620 <telnet_recv+0x1a8>
		len = net_pkt_remaining_data(pkt);
400045cc:	00040513          	mv	a0,s0
400045d0:	5980f0ef          	jal	ra,40013b68 <net_pkt_remaining_data>
400045d4:	00050493          	mv	s1,a0
400045d8:	f19ff06f          	j	400044f0 <telnet_recv+0x78>
	telnet_command_send_reply((uint8_t *)alive, strlen(alive));
400045dc:	4002ccb7          	lui	s9,0x4002c
400045e0:	614c8513          	addi	a0,s9,1556 # 4002c614 <alive.1>
400045e4:	145040ef          	jal	ra,40008f28 <strlen>
400045e8:	01051593          	slli	a1,a0,0x10
400045ec:	0105d593          	srli	a1,a1,0x10
400045f0:	614c8513          	addi	a0,s9,1556
	telnet_command_send_reply((uint8_t *)cmd,
400045f4:	e29ff0ef          	jal	ra,4000441c <telnet_command_send_reply>
}
400045f8:	fa9ff06f          	j	400045a0 <telnet_recv+0x128>
	switch (cmd->opt) {
400045fc:	00254683          	lbu	a3,2(a0)
40004600:	00300713          	li	a4,3
		cmd->op = NVT_CMD_WONT;
40004604:	0fc00793          	li	a5,252
	switch (cmd->opt) {
40004608:	00e69463          	bne	a3,a4,40004610 <telnet_recv+0x198>
		cmd->op = NVT_CMD_WILL;
4000460c:	0fb00793          	li	a5,251
40004610:	00f480a3          	sb	a5,1(s1)
	telnet_command_send_reply((uint8_t *)cmd,
40004614:	00300593          	li	a1,3
40004618:	00048513          	mv	a0,s1
4000461c:	fd9ff06f          	j	400045f4 <telnet_recv+0x17c>
	net_pkt_unref(pkt);
40004620:	00040513          	mv	a0,s0
}
40004624:	03812403          	lw	s0,56(sp)
40004628:	03c12083          	lw	ra,60(sp)
4000462c:	03412483          	lw	s1,52(sp)
40004630:	03012903          	lw	s2,48(sp)
40004634:	02c12983          	lw	s3,44(sp)
40004638:	02812a03          	lw	s4,40(sp)
4000463c:	02412a83          	lw	s5,36(sp)
40004640:	02012b03          	lw	s6,32(sp)
40004644:	01c12b83          	lw	s7,28(sp)
40004648:	01812c03          	lw	s8,24(sp)
4000464c:	01412c83          	lw	s9,20(sp)
40004650:	04010113          	addi	sp,sp,64
	net_pkt_unref(pkt);
40004654:	0c90e06f          	j	40012f1c <net_pkt_unref>

40004658 <cmd_buffer_clear>:
	sh->ctx->receive_state = state;
}

static void cmd_buffer_clear(const struct shell *sh)
{
	sh->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
40004658:	00852783          	lw	a5,8(a0)
4000465c:	04078723          	sb	zero,78(a5)
	sh->ctx->cmd_buff_pos = 0;
40004660:	00852783          	lw	a5,8(a0)
40004664:	04079523          	sh	zero,74(a5)
	sh->ctx->cmd_buff_len = 0;
40004668:	00852783          	lw	a5,8(a0)
4000466c:	04079423          	sh	zero,72(a5)
}
40004670:	00008067          	ret

40004674 <atomic_or>:
		union { uintptr_t x; atomic_val_t val; } parm1 = { .val = value };
		return (atomic_val_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_ATOMIC_OR);
	}
#endif
	compiler_barrier();
	return z_impl_atomic_or(target, value);
40004674:	1992606f          	j	4002b00c <z_impl_atomic_or>

40004678 <atomic_and>:
		union { uintptr_t x; atomic_val_t val; } parm1 = { .val = value };
		return (atomic_val_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_ATOMIC_AND);
	}
#endif
	compiler_barrier();
	return z_impl_atomic_and(target, value);
40004678:	1b52606f          	j	4002b02c <z_impl_atomic_and>

4000467c <shell_signal_handle>:
typedef void (*shell_signal_handler_t)(const struct shell *sh);

static void shell_signal_handle(const struct shell *sh,
				enum shell_signal sig_idx,
				shell_signal_handler_t handler)
{
4000467c:	fd010113          	addi	sp,sp,-48
40004680:	02812423          	sw	s0,40(sp)
40004684:	02912223          	sw	s1,36(sp)
40004688:	02112623          	sw	ra,44(sp)
4000468c:	00050413          	mv	s0,a0
	struct k_poll_signal *sig = &sh->ctx->signals[sig_idx];
40004690:	00852503          	lw	a0,8(a0)
40004694:	00459593          	slli	a1,a1,0x4
40004698:	27458593          	addi	a1,a1,628
{
4000469c:	00060493          	mv	s1,a2
	struct k_poll_signal *sig = &sh->ctx->signals[sig_idx];
400046a0:	00b50533          	add	a0,a0,a1
		(void) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_K_POLL_SIGNAL_CHECK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_check(sig, signaled, result);
400046a4:	01c10613          	addi	a2,sp,28
400046a8:	01810593          	addi	a1,sp,24
400046ac:	00a12623          	sw	a0,12(sp)
400046b0:	761260ef          	jal	ra,4002b610 <z_impl_k_poll_signal_check>
	int set;
	int res;

	k_poll_signal_check(sig, &set, &res);

	if (set) {
400046b4:	01812783          	lw	a5,24(sp)
400046b8:	00c12503          	lw	a0,12(sp)
400046bc:	00078863          	beqz	a5,400046cc <shell_signal_handle+0x50>
	z_impl_k_poll_signal_reset(sig);
400046c0:	749260ef          	jal	ra,4002b608 <z_impl_k_poll_signal_reset>
		k_poll_signal_reset(sig);
		handler(sh);
400046c4:	00040513          	mv	a0,s0
400046c8:	000480e7          	jalr	s1
	}
}
400046cc:	02c12083          	lw	ra,44(sp)
400046d0:	02812403          	lw	s0,40(sp)
400046d4:	02412483          	lw	s1,36(sp)
400046d8:	03010113          	addi	sp,sp,48
400046dc:	00008067          	ret

400046e0 <z_shell_strlen>:
void z_shell_multiline_data_calc(struct shell_multiline_cons *cons,
				 uint16_t buff_pos, uint16_t buff_len);

static inline uint16_t z_shell_strlen(const char *str)
{
	return str == NULL ? 0U : (uint16_t)strlen(str);
400046e0:	02050263          	beqz	a0,40004704 <z_shell_strlen+0x24>
{
400046e4:	ff010113          	addi	sp,sp,-16
400046e8:	00112623          	sw	ra,12(sp)
	return str == NULL ? 0U : (uint16_t)strlen(str);
400046ec:	03d040ef          	jal	ra,40008f28 <strlen>
}
400046f0:	00c12083          	lw	ra,12(sp)
	return str == NULL ? 0U : (uint16_t)strlen(str);
400046f4:	01051513          	slli	a0,a0,0x10
400046f8:	01055513          	srli	a0,a0,0x10
}
400046fc:	01010113          	addi	sp,sp,16
40004700:	00008067          	ret
	return str == NULL ? 0U : (uint16_t)strlen(str);
40004704:	00000513          	li	a0,0
}
40004708:	00008067          	ret

4000470c <z_shell_raw_fprintf>:
extern "C" {
#endif

static inline void z_shell_raw_fprintf(const struct shell_fprintf *const ctx,
				       const char *fmt, ...)
{
4000470c:	fc010113          	addi	sp,sp,-64
40004710:	02c12423          	sw	a2,40(sp)
	va_list args;

	va_start(args, fmt);
40004714:	02810613          	addi	a2,sp,40
{
40004718:	00112e23          	sw	ra,28(sp)
4000471c:	02d12623          	sw	a3,44(sp)
40004720:	02e12823          	sw	a4,48(sp)
40004724:	02f12a23          	sw	a5,52(sp)
40004728:	03012c23          	sw	a6,56(sp)
4000472c:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
40004730:	00c12623          	sw	a2,12(sp)
	z_shell_fprintf_fmt(ctx, fmt, args);
40004734:	115010ef          	jal	ra,40006048 <z_shell_fprintf_fmt>
	va_end(args);
}
40004738:	01c12083          	lw	ra,28(sp)
4000473c:	04010113          	addi	sp,sp,64
40004740:	00008067          	ret

40004744 <shell_internal_help_print>:
{
40004744:	ff010113          	addi	sp,sp,-16
40004748:	00812423          	sw	s0,8(sp)
4000474c:	00112623          	sw	ra,12(sp)
	z_shell_help_cmd_print(sh, &sh->ctx->active_cmd);
40004750:	00852583          	lw	a1,8(a0)
{
40004754:	00050413          	mv	s0,a0
	z_shell_help_cmd_print(sh, &sh->ctx->active_cmd);
40004758:	00c58593          	addi	a1,a1,12
4000475c:	440030ef          	jal	ra,40007b9c <z_shell_help_cmd_print>
	z_shell_help_subcmd_print(sh, &sh->ctx->active_cmd,
40004760:	00842583          	lw	a1,8(s0)
40004764:	00040513          	mv	a0,s0
}
40004768:	00812403          	lw	s0,8(sp)
4000476c:	00c12083          	lw	ra,12(sp)
	z_shell_help_subcmd_print(sh, &sh->ctx->active_cmd,
40004770:	4002c637          	lui	a2,0x4002c
40004774:	67060613          	addi	a2,a2,1648 # 4002c670 <shell_telnet_fprintf+0x14>
40004778:	00c58593          	addi	a1,a1,12
}
4000477c:	01010113          	addi	sp,sp,16
	z_shell_help_subcmd_print(sh, &sh->ctx->active_cmd,
40004780:	2940306f          	j	40007a14 <z_shell_help_subcmd_print>

40004784 <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
40004784:	0f82406f          	j	4002887c <z_impl_k_mutex_lock>

40004788 <transport_evt_handler>:
			&sh->ctx->signals[SHELL_SIGNAL_RXRDY] :
40004788:	0085a703          	lw	a4,8(a1)
4000478c:	2a470793          	addi	a5,a4,676
40004790:	00051463          	bnez	a0,40004798 <transport_evt_handler+0x10>
40004794:	27470793          	addi	a5,a4,628
		union { uintptr_t x; int val; } parm1 = { .val = result };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
40004798:	00000593          	li	a1,0
4000479c:	00078513          	mv	a0,a5
400047a0:	6852606f          	j	4002b624 <z_impl_k_poll_signal_raise>

400047a4 <kill_handler>:

static void kill_handler(const struct shell *sh)
{
400047a4:	fe010113          	addi	sp,sp,-32
400047a8:	00812c23          	sw	s0,24(sp)
400047ac:	00112e23          	sw	ra,28(sp)
	return ret;
}

static inline bool z_flag_processing_get(const struct shell *sh)
{
	return sh->ctx->ctx.flags.processing == 1;
400047b0:	00852783          	lw	a5,8(a0)
400047b4:	00050413          	mv	s0,a0
		return -EBUSY;
400047b8:	ff000593          	li	a1,-16
400047bc:	2707a783          	lw	a5,624(a5)
400047c0:	0017f793          	andi	a5,a5,1
	if (z_flag_processing_get(sh)) {
400047c4:	02079a63          	bnez	a5,400047f8 <kill_handler+0x54>
	err = sh->iface->api->uninit(sh->iface);
400047c8:	00452503          	lw	a0,4(a0)
400047cc:	00052783          	lw	a5,0(a0)
400047d0:	0047a783          	lw	a5,4(a5)
400047d4:	000780e7          	jalr	a5
400047d8:	00050593          	mv	a1,a0
	if (err != 0) {
400047dc:	00051e63          	bnez	a0,400047f8 <kill_handler+0x54>
400047e0:	00a12623          	sw	a0,12(sp)
	z_shell_history_purge(sh->history);
400047e4:	00c42503          	lw	a0,12(s0)
400047e8:	4e5030ef          	jal	ra,400084cc <z_shell_history_purge>
	sh->ctx->state = state;
400047ec:	00842783          	lw	a5,8(s0)
400047f0:	00c12583          	lw	a1,12(sp)
400047f4:	0007a223          	sw	zero,4(a5)
	int err = instance_uninit(sh);

	if (sh->ctx->uninit_cb) {
400047f8:	00842783          	lw	a5,8(s0)
400047fc:	0407a783          	lw	a5,64(a5)
40004800:	00078663          	beqz	a5,4000480c <kill_handler+0x68>
		sh->ctx->uninit_cb(sh, err);
40004804:	00040513          	mv	a0,s0
40004808:	000780e7          	jalr	a5
	}

	sh->ctx->tid = NULL;
4000480c:	00842783          	lw	a5,8(s0)
40004810:	3007ac23          	sw	zero,792(a5)
	return z_impl_z_current_get();
40004814:	491250ef          	jal	ra,4002a4a4 <z_impl_z_current_get>
	k_thread_abort(k_current_get());
}
40004818:	01812403          	lw	s0,24(sp)
4000481c:	01c12083          	lw	ra,28(sp)
40004820:	02010113          	addi	sp,sp,32
	z_impl_k_thread_abort(thread);
40004824:	5b52506f          	j	4002a5d8 <z_impl_k_thread_abort>

40004828 <z_cursor_next_line_move.isra.0>:
/* Function forcing new line - cannot be replaced with function
 * cursor_down_move.
 */
static inline void z_cursor_next_line_move(const struct shell *sh)
{
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
40004828:	4002e5b7          	lui	a1,0x4002e
4000482c:	48c58593          	addi	a1,a1,1164 # 4002e48c <CSWTCH.14405+0xeb0>
40004830:	eddff06f          	j	4000470c <z_shell_raw_fprintf>

40004834 <z_flag_cmd_ctx_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, cmd_ctx, val, ret);
40004834:	27050513          	addi	a0,a0,624
40004838:	00058863          	beqz	a1,40004848 <z_flag_cmd_ctx_set.isra.0+0x14>
4000483c:	000015b7          	lui	a1,0x1
40004840:	80058593          	addi	a1,a1,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
40004844:	e31ff06f          	j	40004674 <atomic_or>
40004848:	fffff5b7          	lui	a1,0xfffff
4000484c:	7ff58593          	addi	a1,a1,2047 # fffff7ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfffff800>
40004850:	e29ff06f          	j	40004678 <atomic_and>

40004854 <z_flag_history_exit_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, history_exit, val, ret);
40004854:	27050513          	addi	a0,a0,624
40004858:	00058663          	beqz	a1,40004864 <z_flag_history_exit_set.isra.0+0x10>
4000485c:	00400593          	li	a1,4
40004860:	e15ff06f          	j	40004674 <atomic_or>
40004864:	ffb00593          	li	a1,-5
40004868:	e11ff06f          	j	40004678 <atomic_and>

4000486c <history_handle>:
{
4000486c:	fe010113          	addi	sp,sp,-32
40004870:	00812c23          	sw	s0,24(sp)
40004874:	00912a23          	sw	s1,20(sp)
40004878:	00112e23          	sw	ra,28(sp)
4000487c:	00050413          	mv	s0,a0
	return sh->ctx->ctx.flags.history_exit == 1;
40004880:	00852503          	lw	a0,8(a0)
40004884:	00058493          	mv	s1,a1
40004888:	27052783          	lw	a5,624(a0)
4000488c:	0027d793          	srli	a5,a5,0x2
40004890:	0017f793          	andi	a5,a5,1
	if (z_flag_history_exit_get(sh)) {
40004894:	00078a63          	beqz	a5,400048a8 <history_handle+0x3c>
		z_flag_history_exit_set(sh, false);
40004898:	00000593          	li	a1,0
4000489c:	fb9ff0ef          	jal	ra,40004854 <z_flag_history_exit_set.isra.0>
		z_shell_history_mode_exit(sh->history);
400048a0:	00c42503          	lw	a0,12(s0)
400048a4:	379030ef          	jal	ra,4000841c <z_shell_history_mode_exit>
 *
 * @return True if in browsing mode.
 */
static inline bool z_shell_history_active(struct shell_history *history)
{
	return (history->current) ? true : false;
400048a8:	00c42783          	lw	a5,12(s0)
	if (!z_shell_history_active(sh->history)) {
400048ac:	00c7a783          	lw	a5,12(a5)
400048b0:	02079463          	bnez	a5,400048d8 <history_handle+0x6c>
		if (up) {
400048b4:	0a048863          	beqz	s1,40004964 <history_handle+0xf8>
			uint16_t cmd_len = z_shell_strlen(sh->ctx->cmd_buff);
400048b8:	00842503          	lw	a0,8(s0)
400048bc:	04e50513          	addi	a0,a0,78
400048c0:	e21ff0ef          	jal	ra,400046e0 <z_shell_strlen>
			if (cmd_len) {
400048c4:	00842783          	lw	a5,8(s0)
400048c8:	0a050863          	beqz	a0,40004978 <history_handle+0x10c>
				strcpy(sh->ctx->temp_buff,
400048cc:	04e78593          	addi	a1,a5,78
400048d0:	14e78513          	addi	a0,a5,334
400048d4:	5ac040ef          	jal	ra,40008e80 <strcpy>
					   sh->ctx->cmd_buff, &len);
400048d8:	00842603          	lw	a2,8(s0)
	history_mode = z_shell_history_get(sh->history, up,
400048dc:	00c42503          	lw	a0,12(s0)
400048e0:	00e10693          	addi	a3,sp,14
400048e4:	04e60613          	addi	a2,a2,78
400048e8:	00048593          	mv	a1,s1
400048ec:	339030ef          	jal	ra,40008424 <z_shell_history_get>
	if (!history_mode) {
400048f0:	02051263          	bnez	a0,40004914 <history_handle+0xa8>
		strcpy(sh->ctx->cmd_buff, sh->ctx->temp_buff);
400048f4:	00842503          	lw	a0,8(s0)
400048f8:	14e50593          	addi	a1,a0,334
400048fc:	04e50513          	addi	a0,a0,78
40004900:	580040ef          	jal	ra,40008e80 <strcpy>
		len = z_shell_strlen(sh->ctx->cmd_buff);
40004904:	00842503          	lw	a0,8(s0)
40004908:	04e50513          	addi	a0,a0,78
4000490c:	dd5ff0ef          	jal	ra,400046e0 <z_shell_strlen>
40004910:	00a11723          	sh	a0,14(sp)
	z_shell_op_cursor_home_move(sh);
40004914:	00040513          	mv	a0,s0
40004918:	5d8020ef          	jal	ra,40006ef0 <z_shell_op_cursor_home_move>
	return sh->ctx->cfg.flags.use_vt100 == 1;
4000491c:	00842783          	lw	a5,8(s0)
40004920:	26c7a783          	lw	a5,620(a5)
40004924:	0057d793          	srli	a5,a5,0x5
40004928:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
4000492c:	00078a63          	beqz	a5,40004940 <history_handle+0xd4>
40004930:	01442503          	lw	a0,20(s0)
40004934:	4002c5b7          	lui	a1,0x4002c
40004938:	bdc58593          	addi	a1,a1,-1060 # 4002bbdc <eth_config+0x4>
4000493c:	dd1ff0ef          	jal	ra,4000470c <z_shell_raw_fprintf>
	z_shell_print_cmd(sh);
40004940:	00040513          	mv	a0,s0
40004944:	698020ef          	jal	ra,40006fdc <z_shell_print_cmd>
	sh->ctx->cmd_buff_pos = len;
40004948:	00842703          	lw	a4,8(s0)
4000494c:	00e15783          	lhu	a5,14(sp)
	z_shell_op_cond_next_line(sh);
40004950:	00040513          	mv	a0,s0
	sh->ctx->cmd_buff_pos = len;
40004954:	04f71523          	sh	a5,74(a4)
	sh->ctx->cmd_buff_len = len;
40004958:	00842703          	lw	a4,8(s0)
4000495c:	04f71423          	sh	a5,72(a4)
	z_shell_op_cond_next_line(sh);
40004960:	2f4020ef          	jal	ra,40006c54 <z_shell_op_cond_next_line>
}
40004964:	01c12083          	lw	ra,28(sp)
40004968:	01812403          	lw	s0,24(sp)
4000496c:	01412483          	lw	s1,20(sp)
40004970:	02010113          	addi	sp,sp,32
40004974:	00008067          	ret
				sh->ctx->temp_buff[0] = '\0';
40004978:	14078723          	sb	zero,334(a5)
4000497c:	f5dff06f          	j	400048d8 <history_handle+0x6c>

40004980 <z_flag_insert_mode_set.isra.0>:
static inline bool z_flag_insert_mode_set(const struct shell *sh, bool val)
40004980:	ff010113          	addi	sp,sp,-16
40004984:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
40004988:	26c50513          	addi	a0,a0,620
4000498c:	00058e63          	beqz	a1,400049a8 <z_flag_insert_mode_set.isra.0+0x28>
40004990:	00100593          	li	a1,1
40004994:	ce1ff0ef          	jal	ra,40004674 <atomic_or>
}
40004998:	00c12083          	lw	ra,12(sp)
4000499c:	00157513          	andi	a0,a0,1
400049a0:	01010113          	addi	sp,sp,16
400049a4:	00008067          	ret
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
400049a8:	ffe00593          	li	a1,-2
400049ac:	ccdff0ef          	jal	ra,40004678 <atomic_and>
400049b0:	fe9ff06f          	j	40004998 <z_flag_insert_mode_set.isra.0+0x18>

400049b4 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
400049b4:	0242406f          	j	400289d8 <z_impl_k_mutex_unlock>

400049b8 <execute>:
{
400049b8:	f2010113          	addi	sp,sp,-224
400049bc:	0c812c23          	sw	s0,216(sp)
	const char *argv[CONFIG_SHELL_ARGC_MAX + 1] = {0}; /* +1 reserved for NULL */
400049c0:	05400613          	li	a2,84
{
400049c4:	00050413          	mv	s0,a0
	const char *argv[CONFIG_SHELL_ARGC_MAX + 1] = {0}; /* +1 reserved for NULL */
400049c8:	00000593          	li	a1,0
400049cc:	04c10513          	addi	a0,sp,76
{
400049d0:	0c112e23          	sw	ra,220(sp)
400049d4:	0b712e23          	sw	s7,188(sp)
400049d8:	0c912a23          	sw	s1,212(sp)
400049dc:	0d212823          	sw	s2,208(sp)
400049e0:	0d312623          	sw	s3,204(sp)
400049e4:	0d412423          	sw	s4,200(sp)
400049e8:	0d512223          	sw	s5,196(sp)
400049ec:	0d612023          	sw	s6,192(sp)
400049f0:	0b812c23          	sw	s8,184(sp)
400049f4:	0b912a23          	sw	s9,180(sp)
400049f8:	0ba12823          	sw	s10,176(sp)
400049fc:	0bb12623          	sw	s11,172(sp)
	const char *argv[CONFIG_SHELL_ARGC_MAX + 1] = {0}; /* +1 reserved for NULL */
40004a00:	670040ef          	jal	ra,40009070 <memset>
	z_shell_op_cursor_end_move(sh);
40004a04:	00040513          	mv	a0,s0
	char *cmd_buf = sh->ctx->cmd_buff;
40004a08:	00842b83          	lw	s7,8(s0)
	size_t cmd_lvl = 0;
40004a0c:	00012e23          	sw	zero,28(sp)
	size_t argc = 0, args_left = SIZE_MAX;
40004a10:	02012023          	sw	zero,32(sp)
	z_shell_op_cursor_end_move(sh);
40004a14:	4f4020ef          	jal	ra,40006f08 <z_shell_op_cursor_end_move>
	if (!z_shell_cursor_in_empty_line(sh)) {
40004a18:	00040513          	mv	a0,s0
	char *cmd_buf = sh->ctx->cmd_buff;
40004a1c:	04eb8b93          	addi	s7,s7,78
	if (!z_shell_cursor_in_empty_line(sh)) {
40004a20:	1c8020ef          	jal	ra,40006be8 <z_shell_cursor_in_empty_line>
40004a24:	00051663          	bnez	a0,40004a30 <execute+0x78>
		z_cursor_next_line_move(sh);
40004a28:	01442503          	lw	a0,20(s0)
40004a2c:	dfdff0ef          	jal	ra,40004828 <z_cursor_next_line_move.isra.0>
	memset(&sh->ctx->active_cmd, 0, sizeof(sh->ctx->active_cmd));
40004a30:	00842503          	lw	a0,8(s0)
40004a34:	01400613          	li	a2,20
40004a38:	00000593          	li	a1,0
40004a3c:	00c50513          	addi	a0,a0,12
40004a40:	630040ef          	jal	ra,40009070 <memset>
		z_shell_cmd_trim(sh);
40004a44:	00040513          	mv	a0,s0
40004a48:	6c1010ef          	jal	ra,40006908 <z_shell_cmd_trim>
		history_put(sh, sh->ctx->cmd_buff,
40004a4c:	00842583          	lw	a1,8(s0)
	z_shell_history_put(sh->history, line, length);
40004a50:	00c42503          	lw	a0,12(s0)
		help_entry.help = NULL;
40004a54:	00000a13          	li	s4,0
	z_shell_history_put(sh->history, line, length);
40004a58:	0485d603          	lhu	a2,72(a1)
40004a5c:	04e58593          	addi	a1,a1,78
	size_t argc = 0, args_left = SIZE_MAX;
40004a60:	fff00913          	li	s2,-1
	z_shell_history_put(sh->history, line, length);
40004a64:	2a9030ef          	jal	ra,4000850c <z_shell_history_put>
		z_shell_wildcard_prepare(sh);
40004a68:	00040513          	mv	a0,s0
40004a6c:	495030ef          	jal	ra,40008700 <z_shell_wildcard_prepare>
	size_t cmd_with_handler_lvl = 0;
40004a70:	00000a93          	li	s5,0
		z_shell_wildcard_prepare(sh);
40004a74:	00000c93          	li	s9,0
40004a78:	04c10993          	addi	s3,sp,76
40004a7c:	00000c13          	li	s8,0
40004a80:	00000493          	li	s1,0
40004a84:	00000b13          	li	s6,0
		&& args_left > 0) {
40004a88:	00100d13          	li	s10,1
			if (status != SHELL_WILDCARD_NOT_FOUND) {
40004a8c:	00300d93          	li	s11,3
		&& args_left > 0) {
40004a90:	02012703          	lw	a4,32(sp)
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
40004a94:	01c12783          	lw	a5,28(sp)
		&& args_left > 0) {
40004a98:	19a70263          	beq	a4,s10,40004c1c <execute+0x264>
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
40004a9c:	01300713          	li	a4,19
40004aa0:	18f76463          	bltu	a4,a5,40004c28 <execute+0x270>
		&& args_left > 0) {
40004aa4:	08091463          	bnez	s2,40004b2c <execute+0x174>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {
40004aa8:	020c0263          	beqz	s8,40004acc <execute+0x114>
		z_shell_wildcard_finalize(sh);
40004aac:	00040513          	mv	a0,s0
40004ab0:	671030ef          	jal	ra,40008920 <z_shell_wildcard_finalize>
					sh->ctx->cmd_buff,
40004ab4:	00842603          	lw	a2,8(s0)
		(void)z_shell_make_argv(&cmd_lvl,
40004ab8:	01400693          	li	a3,20
40004abc:	04c10593          	addi	a1,sp,76
40004ac0:	04e60613          	addi	a2,a2,78
40004ac4:	01c10513          	addi	a0,sp,28
40004ac8:	734010ef          	jal	ra,400061fc <z_shell_make_argv>
	if (parent != NULL) {
40004acc:	020b0a63          	beqz	s6,40004b00 <execute+0x148>
		if (parent->args.optional == SHELL_OPT_ARG_RAW && argv[cmd_lvl] != NULL) {
40004ad0:	011b4703          	lbu	a4,17(s6)
40004ad4:	0fe00793          	li	a5,254
40004ad8:	02f71463          	bne	a4,a5,40004b00 <execute+0x148>
40004adc:	01c12783          	lw	a5,28(sp)
40004ae0:	01010693          	addi	a3,sp,16
40004ae4:	00279713          	slli	a4,a5,0x2
40004ae8:	09070713          	addi	a4,a4,144
40004aec:	00d70733          	add	a4,a4,a3
40004af0:	fac72703          	lw	a4,-84(a4)
40004af4:	00070663          	beqz	a4,40004b00 <execute+0x148>
			cmd_lvl++;
40004af8:	00178793          	addi	a5,a5,1
40004afc:	00f12e23          	sw	a5,28(sp)
	if (sh->ctx->active_cmd.handler == NULL) {
40004b00:	00842503          	lw	a0,8(s0)
	return exec_cmd(sh, cmd_lvl - cmd_with_handler_lvl,
40004b04:	01c12483          	lw	s1,28(sp)
	if (sh->ctx->active_cmd.handler == NULL) {
40004b08:	01852783          	lw	a5,24(a0)
40004b0c:	26079463          	bnez	a5,40004d74 <execute+0x3bc>
			if (help_entry->help == NULL) {
40004b10:	040a0e63          	beqz	s4,40004b6c <execute+0x1b4>
			if (help_entry->help != sh->ctx->active_cmd.help) {
40004b14:	01052783          	lw	a5,16(a0)
40004b18:	0afa1a63          	bne	s4,a5,40004bcc <execute+0x214>
			shell_internal_help_print(sh);
40004b1c:	00040513          	mv	a0,s0
40004b20:	c25ff0ef          	jal	ra,40004744 <shell_internal_help_print>
			return SHELL_CMD_HELP_PRINTED;
40004b24:	00100493          	li	s1,1
40004b28:	0480006f          	j	40004b70 <execute+0x1b8>
		quote = z_shell_make_argv(&argc, argvp, cmd_buf, 2);
40004b2c:	00200693          	li	a3,2
40004b30:	000b8613          	mv	a2,s7
40004b34:	00098593          	mv	a1,s3
40004b38:	02010513          	addi	a0,sp,32
40004b3c:	6c0010ef          	jal	ra,400061fc <z_shell_make_argv>
		if (argc == 0) {
40004b40:	02012783          	lw	a5,32(sp)
		cmd_buf = (char *)argvp[1];
40004b44:	0049ab83          	lw	s7,4(s3)
		quote = z_shell_make_argv(&argc, argvp, cmd_buf, 2);
40004b48:	00050693          	mv	a3,a0
		if (argc == 0) {
40004b4c:	02078063          	beqz	a5,40004b6c <execute+0x1b4>
		} else if ((argc == 1) && (quote != 0)) {
40004b50:	07a79063          	bne	a5,s10,40004bb0 <execute+0x1f8>
40004b54:	04050e63          	beqz	a0,40004bb0 <execute+0x1f8>
			z_shell_fprintf(sh, SHELL_ERROR,
40004b58:	4002c637          	lui	a2,0x4002c
40004b5c:	68060613          	addi	a2,a2,1664 # 4002c680 <shell_telnet_fprintf+0x24>
40004b60:	00100593          	li	a1,1
40004b64:	00040513          	mv	a0,s0
40004b68:	720020ef          	jal	ra,40007288 <z_shell_fprintf>
			return -ENOEXEC;
40004b6c:	ff800493          	li	s1,-8
}
40004b70:	0dc12083          	lw	ra,220(sp)
40004b74:	0d812403          	lw	s0,216(sp)
40004b78:	0d012903          	lw	s2,208(sp)
40004b7c:	0cc12983          	lw	s3,204(sp)
40004b80:	0c812a03          	lw	s4,200(sp)
40004b84:	0c412a83          	lw	s5,196(sp)
40004b88:	0c012b03          	lw	s6,192(sp)
40004b8c:	0bc12b83          	lw	s7,188(sp)
40004b90:	0b812c03          	lw	s8,184(sp)
40004b94:	0b412c83          	lw	s9,180(sp)
40004b98:	0b012d03          	lw	s10,176(sp)
40004b9c:	0ac12d83          	lw	s11,172(sp)
40004ba0:	00048513          	mv	a0,s1
40004ba4:	0d412483          	lw	s1,212(sp)
40004ba8:	0e010113          	addi	sp,sp,224
40004bac:	00008067          	ret
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
40004bb0:	01c12783          	lw	a5,28(sp)
40004bb4:	0a078663          	beqz	a5,40004c60 <execute+0x2a8>
		    z_shell_help_request(argvp[0])) {
40004bb8:	0009a503          	lw	a0,0(s3)
40004bbc:	074030ef          	jal	ra,40007c30 <z_shell_help_request>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
40004bc0:	02050e63          	beqz	a0,40004bfc <execute+0x244>
			if (help_entry.help) {
40004bc4:	020a0063          	beqz	s4,40004be4 <execute+0x22c>
				sh->ctx->active_cmd = help_entry;
40004bc8:	00842503          	lw	a0,8(s0)
				sh->ctx->active_cmd = *help_entry;
40004bcc:	01400613          	li	a2,20
40004bd0:	03810593          	addi	a1,sp,56
40004bd4:	00c50513          	addi	a0,a0,12
40004bd8:	03412e23          	sw	s4,60(sp)
40004bdc:	470040ef          	jal	ra,4000904c <memcpy>
40004be0:	f3dff06f          	j	40004b1c <execute+0x164>
			z_shell_fprintf(sh, SHELL_ERROR,
40004be4:	4002c637          	lui	a2,0x4002c
40004be8:	69460613          	addi	a2,a2,1684 # 4002c694 <shell_telnet_fprintf+0x38>
		z_shell_fprintf(sh, SHELL_ERROR,
40004bec:	00100593          	li	a1,1
40004bf0:	00040513          	mv	a0,s0
40004bf4:	694020ef          	jal	ra,40007288 <z_shell_fprintf>
		return false;
40004bf8:	f75ff06f          	j	40004b6c <execute+0x1b4>
		if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && (cmd_lvl > 0)) {
40004bfc:	01c12783          	lw	a5,28(sp)
40004c00:	06078063          	beqz	a5,40004c60 <execute+0x2a8>
			status = z_shell_wildcard_process(sh, entry,
40004c04:	0009a603          	lw	a2,0(s3)
40004c08:	00048593          	mv	a1,s1
40004c0c:	00040513          	mv	a0,s0
40004c10:	35d030ef          	jal	ra,4000876c <z_shell_wildcard_process>
			if (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {
40004c14:	00200793          	li	a5,2
40004c18:	02f51863          	bne	a0,a5,40004c48 <execute+0x290>
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
40004c1c:	01c12703          	lw	a4,28(sp)
40004c20:	01300793          	li	a5,19
40004c24:	e8e7f2e3          	bgeu	a5,a4,40004aa8 <execute+0xf0>
40004c28:	02012703          	lw	a4,32(sp)
40004c2c:	00200793          	li	a5,2
40004c30:	e6f71ce3          	bne	a4,a5,40004aa8 <execute+0xf0>
		z_shell_fprintf(sh, SHELL_ERROR, "%s\n",
40004c34:	4002c6b7          	lui	a3,0x4002c
40004c38:	4002e637          	lui	a2,0x4002e
40004c3c:	70068693          	addi	a3,a3,1792 # 4002c700 <shell_telnet_fprintf+0xa4>
40004c40:	9b860613          	addi	a2,a2,-1608 # 4002d9b8 <CSWTCH.14405+0x3dc>
40004c44:	f1dff06f          	j	40004b60 <execute+0x1a8>
			if (status != SHELL_WILDCARD_NOT_FOUND) {
40004c48:	01b50c63          	beq	a0,s11,40004c60 <execute+0x2a8>
				++cmd_lvl;
40004c4c:	01c12783          	lw	a5,28(sp)
				wildcard_found = true;
40004c50:	00100c13          	li	s8,1
				++cmd_lvl;
40004c54:	00178793          	addi	a5,a5,1
40004c58:	00f12e23          	sw	a5,28(sp)
				continue;
40004c5c:	e35ff06f          	j	40004a90 <execute+0xd8>
		if (has_last_handler == false) {
40004c60:	000c9c63          	bnez	s9,40004c78 <execute+0x2c0>
			entry = z_shell_find_cmd(parent, argvp[0], &dloc);
40004c64:	0009a583          	lw	a1,0(s3)
40004c68:	02410613          	addi	a2,sp,36
40004c6c:	000b0513          	mv	a0,s6
40004c70:	241010ef          	jal	ra,400066b0 <z_shell_find_cmd>
40004c74:	00050493          	mv	s1,a0
		argvp++;
40004c78:	00498993          	addi	s3,s3,4
		args_left--;
40004c7c:	fff90913          	addi	s2,s2,-1
		if (entry) {
40004c80:	0a048663          	beqz	s1,40004d2c <execute+0x374>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && found && entry->handler) {
40004c84:	00c4a783          	lw	a5,12(s1)
40004c88:	020c0263          	beqz	s8,40004cac <execute+0x2f4>
40004c8c:	04078c63          	beqz	a5,40004ce4 <execute+0x32c>
		z_shell_op_cursor_end_move(sh);
40004c90:	00040513          	mv	a0,s0
40004c94:	274020ef          	jal	ra,40006f08 <z_shell_op_cursor_end_move>
		z_shell_op_cond_next_line(sh);
40004c98:	00040513          	mv	a0,s0
40004c9c:	7b9010ef          	jal	ra,40006c54 <z_shell_op_cond_next_line>
		z_shell_fprintf(sh, SHELL_ERROR,
40004ca0:	4002c637          	lui	a2,0x4002c
40004ca4:	6b460613          	addi	a2,a2,1716 # 4002c6b4 <shell_telnet_fprintf+0x58>
40004ca8:	f45ff06f          	j	40004bec <execute+0x234>
	if (entry->handler) {
40004cac:	02078c63          	beqz	a5,40004ce4 <execute+0x32c>
			active_cmd_prepare(entry, &sh->ctx->active_cmd,
40004cb0:	00842503          	lw	a0,8(s0)
		*active_cmd = *entry;
40004cb4:	01400613          	li	a2,20
40004cb8:	00048593          	mv	a1,s1
40004cbc:	00c50513          	addi	a0,a0,12
		*handler_lvl = *lvl;
40004cc0:	01c12a83          	lw	s5,28(sp)
		*active_cmd = *entry;
40004cc4:	388040ef          	jal	ra,4000904c <memcpy>
		if ((entry->subcmd == NULL)
40004cc8:	0084a783          	lw	a5,8(s1)
40004ccc:	00079c63          	bnez	a5,40004ce4 <execute+0x32c>
		    && entry->args.optional == SHELL_OPT_ARG_RAW) {
40004cd0:	0114c703          	lbu	a4,17(s1)
40004cd4:	0fe00793          	li	a5,254
40004cd8:	00f71663          	bne	a4,a5,40004ce4 <execute+0x32c>
			*args_left = entry->args.mandatory - 1;
40004cdc:	0104c903          	lbu	s2,16(s1)
40004ce0:	fff90913          	addi	s2,s2,-1
	if (entry->help) {
40004ce4:	0044a783          	lw	a5,4(s1)
40004ce8:	00048b13          	mv	s6,s1
40004cec:	00f12623          	sw	a5,12(sp)
40004cf0:	00078e63          	beqz	a5,40004d0c <execute+0x354>
		*help_entry = *entry;
40004cf4:	01400613          	li	a2,20
40004cf8:	00048593          	mv	a1,s1
40004cfc:	03810513          	addi	a0,sp,56
40004d00:	34c040ef          	jal	ra,4000904c <memcpy>
40004d04:	00c12783          	lw	a5,12(sp)
40004d08:	00078a13          	mv	s4,a5
		if (args_left || (argc == 2)) {
40004d0c:	02012703          	lw	a4,32(sp)
40004d10:	00091663          	bnez	s2,40004d1c <execute+0x364>
40004d14:	00200793          	li	a5,2
40004d18:	d6f71ce3          	bne	a4,a5,40004a90 <execute+0xd8>
			cmd_lvl++;
40004d1c:	01c12783          	lw	a5,28(sp)
40004d20:	00178793          	addi	a5,a5,1
40004d24:	00f12e23          	sw	a5,28(sp)
40004d28:	d69ff06f          	j	40004a90 <execute+0xd8>
			if (cmd_lvl == 0 &&
40004d2c:	01c12783          	lw	a5,28(sp)
40004d30:	00078663          	beqz	a5,40004d3c <execute+0x384>
			has_last_handler = true;
40004d34:	00100c93          	li	s9,1
40004d38:	fd5ff06f          	j	40004d0c <execute+0x354>
	z_shell_fprintf_buffer_flush(sh->fprintf_ctx);
}

static inline bool z_shell_in_select_mode(const struct shell *sh)
{
	return sh->ctx->selected_cmd == NULL ? false : true;
40004d3c:	00842783          	lw	a5,8(s0)
40004d40:	0207a783          	lw	a5,32(a5)
			if (cmd_lvl == 0 &&
40004d44:	00078663          	beqz	a5,40004d50 <execute+0x398>
				(!z_shell_in_select_mode(sh) ||
40004d48:	00c7a783          	lw	a5,12(a5)
40004d4c:	fe0794e3          	bnez	a5,40004d34 <execute+0x37c>
				z_shell_fprintf(sh, SHELL_ERROR,
40004d50:	04c12683          	lw	a3,76(sp)
40004d54:	4002c737          	lui	a4,0x4002c
40004d58:	4002c637          	lui	a2,0x4002c
40004d5c:	6e470713          	addi	a4,a4,1764 # 4002c6e4 <shell_telnet_fprintf+0x88>
40004d60:	6f860613          	addi	a2,a2,1784 # 4002c6f8 <shell_telnet_fprintf+0x9c>
40004d64:	00100593          	li	a1,1
40004d68:	00040513          	mv	a0,s0
40004d6c:	51c020ef          	jal	ra,40007288 <z_shell_fprintf>
40004d70:	fc5ff06f          	j	40004d34 <execute+0x37c>
	if (sh->ctx->active_cmd.args.mandatory) {
40004d74:	01c54703          	lbu	a4,28(a0)
	return exec_cmd(sh, cmd_lvl - cmd_with_handler_lvl,
40004d78:	415484b3          	sub	s1,s1,s5
	if (sh->ctx->active_cmd.args.mandatory) {
40004d7c:	04070663          	beqz	a4,40004dc8 <execute+0x410>
		uint8_t opt8 = sh->ctx->active_cmd.args.optional;
40004d80:	01d54783          	lbu	a5,29(a0)
				UINT16_MAX : opt8;
40004d84:	0ff00693          	li	a3,255
40004d88:	00d79663          	bne	a5,a3,40004d94 <execute+0x3dc>
40004d8c:	000107b7          	lui	a5,0x10
40004d90:	fff78793          	addi	a5,a5,-1 # ffff <__kernel_ram_size+0x3d6b>
		const bool in_range = IN_RANGE(argc, mand, mand + opt);
40004d94:	00e4e663          	bltu	s1,a4,40004da0 <execute+0x3e8>
40004d98:	00f70733          	add	a4,a4,a5
40004d9c:	02977663          	bgeu	a4,s1,40004dc8 <execute+0x410>
		z_shell_fprintf(sh, SHELL_ERROR,
40004da0:	00c52683          	lw	a3,12(a0)
40004da4:	4002c637          	lui	a2,0x4002c
40004da8:	72460613          	addi	a2,a2,1828 # 4002c724 <shell_telnet_fprintf+0xc8>
40004dac:	00100593          	li	a1,1
40004db0:	00040513          	mv	a0,s0
40004db4:	4d4020ef          	jal	ra,40007288 <z_shell_fprintf>
			shell_internal_help_print(sh);
40004db8:	00040513          	mv	a0,s0
40004dbc:	989ff0ef          	jal	ra,40004744 <shell_internal_help_print>
		return -EINVAL;
40004dc0:	fea00493          	li	s1,-22
40004dc4:	dadff06f          	j	40004b70 <execute+0x1b8>
		z_flag_cmd_ctx_set(sh, true);
40004dc8:	00100593          	li	a1,1
40004dcc:	a69ff0ef          	jal	ra,40004834 <z_flag_cmd_ctx_set.isra.0>
		k_mutex_unlock(&sh->ctx->wr_mtx);
40004dd0:	00842503          	lw	a0,8(s0)
40004dd4:	30450513          	addi	a0,a0,772
40004dd8:	bddff0ef          	jal	ra,400049b4 <k_mutex_unlock.isra.0>
		ret_val = sh->ctx->active_cmd.handler(sh, argc,
40004ddc:	00842783          	lw	a5,8(s0)
40004de0:	04c10713          	addi	a4,sp,76
	return exec_cmd(sh, cmd_lvl - cmd_with_handler_lvl,
40004de4:	002a9613          	slli	a2,s5,0x2
		ret_val = sh->ctx->active_cmd.handler(sh, argc,
40004de8:	0187a783          	lw	a5,24(a5)
40004dec:	00c70633          	add	a2,a4,a2
40004df0:	00048593          	mv	a1,s1
40004df4:	00040513          	mv	a0,s0
40004df8:	000780e7          	jalr	a5
40004dfc:	00050493          	mv	s1,a0
		k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
40004e00:	00842503          	lw	a0,8(s0)
40004e04:	fff00593          	li	a1,-1
40004e08:	fff00613          	li	a2,-1
40004e0c:	30450513          	addi	a0,a0,772
40004e10:	975ff0ef          	jal	ra,40004784 <k_mutex_lock.constprop.0.isra.0>
		z_flag_cmd_ctx_set(sh, false);
40004e14:	00842503          	lw	a0,8(s0)
40004e18:	00000593          	li	a1,0
40004e1c:	a19ff0ef          	jal	ra,40004834 <z_flag_cmd_ctx_set.isra.0>
40004e20:	d51ff06f          	j	40004b70 <execute+0x1b8>

40004e24 <state_set.constprop.0>:
	sh->ctx->state = state;
40004e24:	00852783          	lw	a5,8(a0)
40004e28:	00200713          	li	a4,2
40004e2c:	00e7a223          	sw	a4,4(a5)
	if (state == SHELL_STATE_ACTIVE && !sh->ctx->bypass) {
40004e30:	00852783          	lw	a5,8(a0)
40004e34:	0447a783          	lw	a5,68(a5)
40004e38:	06079863          	bnez	a5,40004ea8 <state_set.constprop.0+0x84>
static inline void state_set(const struct shell *sh, enum shell_state state)
40004e3c:	ff010113          	addi	sp,sp,-16
40004e40:	00812423          	sw	s0,8(sp)
40004e44:	00112623          	sw	ra,12(sp)
40004e48:	00050413          	mv	s0,a0
		cmd_buffer_clear(sh);
40004e4c:	80dff0ef          	jal	ra,40004658 <cmd_buffer_clear>
	return sh->ctx->ctx.flags.print_noinit == 1;
40004e50:	00842783          	lw	a5,8(s0)
40004e54:	2707a783          	lw	a5,624(a5)
40004e58:	00c7d793          	srli	a5,a5,0xc
40004e5c:	0017f793          	andi	a5,a5,1
		if (z_flag_print_noinit_get(sh)) {
40004e60:	02078a63          	beqz	a5,40004e94 <state_set.constprop.0+0x70>
			z_shell_fprintf(sh, SHELL_WARNING, "%s",
40004e64:	4002c6b7          	lui	a3,0x4002c
40004e68:	4002c637          	lui	a2,0x4002c
40004e6c:	00300593          	li	a1,3
40004e70:	00040513          	mv	a0,s0
40004e74:	74068693          	addi	a3,a3,1856 # 4002c740 <shell_telnet_fprintf+0xe4>
40004e78:	78460613          	addi	a2,a2,1924 # 4002c784 <shell_telnet_fprintf+0x128>
40004e7c:	40c020ef          	jal	ra,40007288 <z_shell_fprintf>
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, print_noinit, val, ret);
40004e80:	00842503          	lw	a0,8(s0)
40004e84:	fffff5b7          	lui	a1,0xfffff
40004e88:	fff58593          	addi	a1,a1,-1 # ffffefff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfffff000>
40004e8c:	27050513          	addi	a0,a0,624
40004e90:	fe8ff0ef          	jal	ra,40004678 <atomic_and>
		z_shell_print_prompt_and_cmd(sh);
40004e94:	00040513          	mv	a0,s0
}
40004e98:	00812403          	lw	s0,8(sp)
40004e9c:	00c12083          	lw	ra,12(sp)
40004ea0:	01010113          	addi	sp,sp,16
		z_shell_print_prompt_and_cmd(sh);
40004ea4:	1090206f          	j	400077ac <z_shell_print_prompt_and_cmd>
40004ea8:	00008067          	ret

40004eac <shell_process>:

	return 0;
}

void shell_process(const struct shell *sh)
{
40004eac:	f0010113          	addi	sp,sp,-256
40004eb0:	0e812c23          	sw	s0,248(sp)
40004eb4:	0e112e23          	sw	ra,252(sp)
40004eb8:	0e912a23          	sw	s1,244(sp)
40004ebc:	0f212823          	sw	s2,240(sp)
40004ec0:	0f312623          	sw	s3,236(sp)
40004ec4:	0f412423          	sw	s4,232(sp)
40004ec8:	0f512223          	sw	s5,228(sp)
40004ecc:	0f612023          	sw	s6,224(sp)
40004ed0:	0d712e23          	sw	s7,220(sp)
40004ed4:	0d812c23          	sw	s8,216(sp)
40004ed8:	0d912a23          	sw	s9,212(sp)
40004edc:	0da12823          	sw	s10,208(sp)
40004ee0:	0db12623          	sw	s11,204(sp)
40004ee4:	00050413          	mv	s0,a0
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, processing, val, ret);
40004ee8:	00852503          	lw	a0,8(a0)
40004eec:	00100593          	li	a1,1
40004ef0:	27050513          	addi	a0,a0,624
40004ef4:	f80ff0ef          	jal	ra,40004674 <atomic_or>
	__ASSERT_NO_MSG(sh->ctx);

	/* atomically set the processing flag */
	z_flag_processing_set(sh, true);

	switch (sh->ctx->state) {
40004ef8:	00842783          	lw	a5,8(s0)
40004efc:	0047a703          	lw	a4,4(a5)
40004f00:	00200793          	li	a5,2
40004f04:	06f71c63          	bne	a4,a5,40004f7c <shell_process+0xd0>
	size_t count = 0;
40004f08:	02012223          	sw	zero,36(sp)
		switch (sh->ctx->receive_state) {
40004f0c:	00200b13          	li	s6,2
		shell_bypass_cb_t bypass = sh->ctx->bypass;
40004f10:	00842783          	lw	a5,8(s0)
			(void)sh->iface->api->read(sh->iface, buf,
40004f14:	00442503          	lw	a0,4(s0)
40004f18:	02410693          	addi	a3,sp,36
		shell_bypass_cb_t bypass = sh->ctx->bypass;
40004f1c:	0447a483          	lw	s1,68(a5)
			(void)sh->iface->api->read(sh->iface, buf,
40004f20:	00052783          	lw	a5,0(a0)
40004f24:	0107a783          	lw	a5,16(a5)
		if (bypass) {
40004f28:	08048e63          	beqz	s1,40004fc4 <shell_process+0x118>
			(void)sh->iface->api->read(sh->iface, buf,
40004f2c:	01000613          	li	a2,16
40004f30:	06c10593          	addi	a1,sp,108
40004f34:	000780e7          	jalr	a5
			if (count) {
40004f38:	02412783          	lw	a5,36(sp)
40004f3c:	04078063          	beqz	a5,40004f7c <shell_process+0xd0>
				z_flag_cmd_ctx_set(sh, true);
40004f40:	00842503          	lw	a0,8(s0)
40004f44:	00100593          	li	a1,1
40004f48:	8edff0ef          	jal	ra,40004834 <z_flag_cmd_ctx_set.isra.0>
				bypass(sh, buf, count);
40004f4c:	02412603          	lw	a2,36(sp)
40004f50:	06c10593          	addi	a1,sp,108
40004f54:	00040513          	mv	a0,s0
40004f58:	000480e7          	jalr	s1
				z_flag_cmd_ctx_set(sh, false);
40004f5c:	00842503          	lw	a0,8(s0)
40004f60:	00000593          	li	a1,0
40004f64:	8d1ff0ef          	jal	ra,40004834 <z_flag_cmd_ctx_set.isra.0>
				if (!(volatile shell_bypass_cb_t *)sh->ctx->bypass) {
40004f68:	00842783          	lw	a5,8(s0)
40004f6c:	0447a783          	lw	a5,68(a5)
40004f70:	fa0790e3          	bnez	a5,40004f10 <shell_process+0x64>
					state_set(sh, SHELL_STATE_ACTIVE);
40004f74:	00040513          	mv	a0,s0
40004f78:	eadff0ef          	jal	ra,40004e24 <state_set.constprop.0>
40004f7c:	00842503          	lw	a0,8(s0)
		break;
	}

	/* atomically clear the processing flag */
	z_flag_processing_set(sh, false);
}
40004f80:	0f812403          	lw	s0,248(sp)
40004f84:	0fc12083          	lw	ra,252(sp)
40004f88:	0f412483          	lw	s1,244(sp)
40004f8c:	0f012903          	lw	s2,240(sp)
40004f90:	0ec12983          	lw	s3,236(sp)
40004f94:	0e812a03          	lw	s4,232(sp)
40004f98:	0e412a83          	lw	s5,228(sp)
40004f9c:	0e012b03          	lw	s6,224(sp)
40004fa0:	0dc12b83          	lw	s7,220(sp)
40004fa4:	0d812c03          	lw	s8,216(sp)
40004fa8:	0d412c83          	lw	s9,212(sp)
40004fac:	0d012d03          	lw	s10,208(sp)
40004fb0:	0cc12d83          	lw	s11,204(sp)
40004fb4:	ffe00593          	li	a1,-2
40004fb8:	27050513          	addi	a0,a0,624
40004fbc:	10010113          	addi	sp,sp,256
40004fc0:	eb8ff06f          	j	40004678 <atomic_and>
		(void)sh->iface->api->read(sh->iface, &data,
40004fc4:	00100613          	li	a2,1
40004fc8:	02310593          	addi	a1,sp,35
40004fcc:	000780e7          	jalr	a5
		if (count == 0) {
40004fd0:	02412783          	lw	a5,36(sp)
40004fd4:	fa0784e3          	beqz	a5,40004f7c <shell_process+0xd0>
		if (ascii_filter(data) != 0) {
40004fd8:	02314783          	lbu	a5,35(sp)
		switch (sh->ctx->receive_state) {
40004fdc:	00842703          	lw	a4,8(s0)
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
40004fe0:	01879693          	slli	a3,a5,0x18
40004fe4:	4186d693          	srai	a3,a3,0x18
40004fe8:	f206c4e3          	bltz	a3,40004f10 <shell_process+0x64>
		switch (sh->ctx->receive_state) {
40004fec:	00872a83          	lw	s5,8(a4)
40004ff0:	7d6a8463          	beq	s5,s6,400057b8 <shell_process+0x90c>
40004ff4:	075b6e63          	bltu	s6,s5,40005070 <shell_process+0x1c4>
40004ff8:	760a9a63          	bnez	s5,4000576c <shell_process+0x8c0>
	if ((data != '\r') && (data != '\n')) {
40004ffc:	00d00693          	li	a3,13
40005000:	12d78063          	beq	a5,a3,40005120 <shell_process+0x274>
40005004:	00a00693          	li	a3,10
40005008:	0ad78063          	beq	a5,a3,400050a8 <shell_process+0x1fc>
	sh->ctx->ctx.flags.last_nl = val;
4000500c:	27075683          	lhu	a3,624(a4)
40005010:	8076f693          	andi	a3,a3,-2041
40005014:	26d71823          	sh	a3,624(a4)
			switch (data) {
40005018:	00900713          	li	a4,9
4000501c:	00842503          	lw	a0,8(s0)
40005020:	12e78e63          	beq	a5,a4,4000515c <shell_process+0x2b0>
40005024:	04f76a63          	bltu	a4,a5,40005078 <shell_process+0x1cc>
40005028:	ee0784e3          	beqz	a5,40004f10 <shell_process+0x64>
4000502c:	00800713          	li	a4,8
40005030:	5ce78663          	beq	a5,a4,400055fc <shell_process+0x750>
	return (int)((((unsigned)c) >= ' ') &&
40005034:	00050713          	mv	a4,a0
	return sh->ctx->cfg.flags.echo == 1;
40005038:	26c72683          	lw	a3,620(a4)
4000503c:	0016d693          	srli	a3,a3,0x1
40005040:	0016f693          	andi	a3,a3,1
				} else if (z_flag_echo_get(sh)) {
40005044:	ec0686e3          	beqz	a3,40004f10 <shell_process+0x64>
	switch (data) {
40005048:	fff78793          	addi	a5,a5,-1
4000504c:	0ff7f793          	zext.b	a5,a5
40005050:	01600693          	li	a3,22
40005054:	eaf6eee3          	bltu	a3,a5,40004f10 <shell_process+0x64>
40005058:	4002c6b7          	lui	a3,0x4002c
4000505c:	00279793          	slli	a5,a5,0x2
40005060:	79468693          	addi	a3,a3,1940 # 4002c794 <shell_telnet_fprintf+0x138>
40005064:	00d787b3          	add	a5,a5,a3
40005068:	0007a783          	lw	a5,0(a5)
4000506c:	00078067          	jr	a5
	sh->ctx->receive_state = state;
40005070:	00072423          	sw	zero,8(a4)
40005074:	e9dff06f          	j	40004f10 <shell_process+0x64>
40005078:	01b00713          	li	a4,27
4000507c:	0ce78a63          	beq	a5,a4,40005150 <shell_process+0x2a4>
40005080:	07f00713          	li	a4,127
40005084:	58e78e63          	beq	a5,a4,40005620 <shell_process+0x774>
40005088:	fe078693          	addi	a3,a5,-32
				if (isprint((int) data) != 0) {
4000508c:	05e00613          	li	a2,94
40005090:	00050713          	mv	a4,a0
40005094:	fad662e3          	bltu	a2,a3,40005038 <shell_process+0x18c>
					z_flag_history_exit_set(sh, true);
40005098:	00100593          	li	a1,1
4000509c:	fb8ff0ef          	jal	ra,40004854 <z_flag_history_exit_set.isra.0>
					z_shell_op_char_insert(sh, data);
400050a0:	02314583          	lbu	a1,35(sp)
400050a4:	2f00006f          	j	40005394 <shell_process+0x4e8>
	return sh->ctx->ctx.flags.last_nl;
400050a8:	27072683          	lw	a3,624(a4)
400050ac:	0036d693          	srli	a3,a3,0x3
400050b0:	0ff6f693          	zext.b	a3,a3
	if ((z_flag_last_nl_get(sh) == 0U) ||
400050b4:	02068463          	beqz	a3,400050dc <shell_process+0x230>
400050b8:	27072683          	lw	a3,624(a4)
400050bc:	0036d693          	srli	a3,a3,0x3
400050c0:	0ff6f693          	zext.b	a3,a3
400050c4:	f6f69ae3          	bne	a3,a5,40005038 <shell_process+0x18c>
	sh->ctx->ctx.flags.last_nl = val;
400050c8:	00379693          	slli	a3,a5,0x3
400050cc:	27075783          	lhu	a5,624(a4)
400050d0:	8077f793          	andi	a5,a5,-2041
400050d4:	00d7e7b3          	or	a5,a5,a3
400050d8:	0100006f          	j	400050e8 <shell_process+0x23c>
400050dc:	27075783          	lhu	a5,624(a4)
400050e0:	8077f793          	andi	a5,a5,-2041
400050e4:	0507e793          	ori	a5,a5,80
400050e8:	26f71823          	sh	a5,624(a4)
				if (!sh->ctx->cmd_buff_len) {
400050ec:	00842483          	lw	s1,8(s0)
400050f0:	0484d783          	lhu	a5,72(s1)
400050f4:	04079663          	bnez	a5,40005140 <shell_process+0x294>
	z_flag_history_exit_set(sh, false);
400050f8:	00000593          	li	a1,0
400050fc:	00048513          	mv	a0,s1
40005100:	f54ff0ef          	jal	ra,40004854 <z_flag_history_exit_set.isra.0>
	z_shell_history_mode_exit(sh->history);
40005104:	00c42503          	lw	a0,12(s0)
40005108:	314030ef          	jal	ra,4000841c <z_shell_history_mode_exit>
					z_cursor_next_line_move(sh);
4000510c:	01442503          	lw	a0,20(s0)
40005110:	f18ff0ef          	jal	ra,40004828 <z_cursor_next_line_move.isra.0>
		state_set(sh, SHELL_STATE_ACTIVE);
40005114:	00040513          	mv	a0,s0
40005118:	d0dff0ef          	jal	ra,40004e24 <state_set.constprop.0>
		break;
4000511c:	df5ff06f          	j	40004f10 <shell_process+0x64>
	return sh->ctx->ctx.flags.last_nl;
40005120:	27072683          	lw	a3,624(a4)
40005124:	0036d693          	srli	a3,a3,0x3
40005128:	0ff6f693          	zext.b	a3,a3
	if ((z_flag_last_nl_get(sh) == 0U) ||
4000512c:	f80696e3          	bnez	a3,400050b8 <shell_process+0x20c>
	sh->ctx->ctx.flags.last_nl = val;
40005130:	27075783          	lhu	a5,624(a4)
40005134:	8077f793          	andi	a5,a5,-2041
40005138:	0687e793          	ori	a5,a5,104
4000513c:	fadff06f          	j	400050e8 <shell_process+0x23c>
					sh->ctx->ret_val = execute(sh);
40005140:	00040513          	mv	a0,s0
40005144:	875ff0ef          	jal	ra,400049b8 <execute>
40005148:	30a4ae23          	sw	a0,796(s1)
				state_set(sh, SHELL_STATE_ACTIVE);
4000514c:	fc9ff06f          	j	40005114 <shell_process+0x268>
	sh->ctx->receive_state = state;
40005150:	00100793          	li	a5,1
40005154:	00f52423          	sw	a5,8(a0)
}
40005158:	db9ff06f          	j	40004f10 <shell_process+0x64>
	return sh->ctx->cfg.flags.echo == 1;
4000515c:	26c52783          	lw	a5,620(a0)
40005160:	0017d793          	srli	a5,a5,0x1
40005164:	0017f793          	andi	a5,a5,1
				if (z_flag_echo_get(sh) &&
40005168:	da0784e3          	beqz	a5,40004f10 <shell_process+0x64>
					z_flag_history_exit_set(sh, true);
4000516c:	00100593          	li	a1,1
40005170:	ee4ff0ef          	jal	ra,40004854 <z_flag_history_exit_set.isra.0>
			sh->ctx->cmd_buff_len;
40005174:	00842503          	lw	a0,8(s0)
	if (compl_space == 0U) {
40005178:	0ff00793          	li	a5,255
4000517c:	04855703          	lhu	a4,72(a0)
40005180:	d8f708e3          	beq	a4,a5,40004f10 <shell_process+0x64>
	memcpy(sh->ctx->temp_buff, sh->ctx->cmd_buff,
40005184:	04a55603          	lhu	a2,74(a0)
40005188:	04e50593          	addi	a1,a0,78
4000518c:	14e50513          	addi	a0,a0,334
40005190:	6bd030ef          	jal	ra,4000904c <memcpy>
	sh->ctx->temp_buff[sh->ctx->cmd_buff_pos] = '\0';
40005194:	00842783          	lw	a5,8(s0)
	(void)z_shell_make_argv(argc, *argv, sh->ctx->temp_buff,
40005198:	06c10593          	addi	a1,sp,108
4000519c:	01400693          	li	a3,20
	sh->ctx->temp_buff[sh->ctx->cmd_buff_pos] = '\0';
400051a0:	04a7d703          	lhu	a4,74(a5)
	(void)z_shell_make_argv(argc, *argv, sh->ctx->temp_buff,
400051a4:	02c10513          	addi	a0,sp,44
	sh->ctx->temp_buff[sh->ctx->cmd_buff_pos] = '\0';
400051a8:	00e787b3          	add	a5,a5,a4
400051ac:	14078723          	sb	zero,334(a5)
	(void)z_shell_make_argv(argc, *argv, sh->ctx->temp_buff,
400051b0:	00842603          	lw	a2,8(s0)
400051b4:	14e60613          	addi	a2,a2,334
400051b8:	044010ef          	jal	ra,400061fc <z_shell_make_argv>
	if (*argc > CONFIG_SHELL_ARGC_MAX) {
400051bc:	02c12583          	lw	a1,44(sp)
400051c0:	01400793          	li	a5,20
400051c4:	d4b7e6e3          	bltu	a5,a1,40004f10 <shell_process+0x64>
	(*argv)[*argc] = NULL;
400051c8:	00259793          	slli	a5,a1,0x2
400051cc:	02010713          	addi	a4,sp,32
400051d0:	0a078793          	addi	a5,a5,160
400051d4:	00e787b3          	add	a5,a5,a4
400051d8:	fa07a623          	sw	zero,-84(a5)
	int space = isspace((int)sh->ctx->cmd_buff[
400051dc:	00842783          	lw	a5,8(s0)
						sh->ctx->cmd_buff_pos - 1]);
400051e0:	04a7d703          	lhu	a4,74(a5)
	int space = isspace((int)sh->ctx->cmd_buff[
400051e4:	00e787b3          	add	a5,a5,a4
400051e8:	04d7c783          	lbu	a5,77(a5)
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
400051ec:	02000713          	li	a4,32
400051f0:	00e78863          	beq	a5,a4,40005200 <shell_process+0x354>
400051f4:	ff778793          	addi	a5,a5,-9
400051f8:	00400713          	li	a4,4
400051fc:	0ef76a63          	bltu	a4,a5,400052f0 <shell_process+0x444>
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
40005200:	0e059e63          	bnez	a1,400052fc <shell_process+0x450>
		*complete_arg_idx = Z_SHELL_CMD_ROOT_LVL;
40005204:	02012423          	sw	zero,40(sp)
		*cmd = selected_cmd_get(sh);
40005208:	00000493          	li	s1,0
	find_completion_candidates(sh, cmd, argv[arg_idx], &first, &cnt,
4000520c:	02812783          	lw	a5,40(sp)
40005210:	02010713          	addi	a4,sp,32
	*cnt = 0;
40005214:	00000913          	li	s2,0
	find_completion_candidates(sh, cmd, argv[arg_idx], &first, &cnt,
40005218:	00279793          	slli	a5,a5,0x2
4000521c:	0a078793          	addi	a5,a5,160
40005220:	00e787b3          	add	a5,a5,a4
40005224:	fac7ac83          	lw	s9,-84(a5)
	size_t first = 0;
40005228:	00000a13          	li	s4,0
	*longest = 0U;
4000522c:	00000993          	li	s3,0
	incompl_cmd_len = z_shell_strlen(incompl_cmd);
40005230:	000c8513          	mv	a0,s9
40005234:	cacff0ef          	jal	ra,400046e0 <z_shell_strlen>
40005238:	00050c13          	mv	s8,a0
	while ((candidate = z_shell_cmd_get(cmd, idx, &dloc)) != NULL) {
4000523c:	05810613          	addi	a2,sp,88
40005240:	000a8593          	mv	a1,s5
40005244:	00048513          	mv	a0,s1
40005248:	39c010ef          	jal	ra,400065e4 <z_shell_cmd_get>
4000524c:	00050b93          	mv	s7,a0
40005250:	0c051863          	bnez	a0,40005320 <shell_process+0x474>
	if (cnt == 1) {
40005254:	00100793          	li	a5,1
40005258:	14f91463          	bne	s2,a5,400053a0 <shell_process+0x4f4>
		autocomplete(sh, cmd, argv[arg_idx], first);
4000525c:	02812783          	lw	a5,40(sp)
40005260:	02010713          	addi	a4,sp,32
40005264:	00279793          	slli	a5,a5,0x2
40005268:	0a078793          	addi	a5,a5,160
4000526c:	00e787b3          	add	a5,a5,a4
	uint16_t arg_len = z_shell_strlen(arg);
40005270:	fac7a503          	lw	a0,-84(a5)
40005274:	c6cff0ef          	jal	ra,400046e0 <z_shell_strlen>
	match = z_shell_cmd_get(cmd, subcmd_idx, &sh->ctx->active_cmd);
40005278:	00842603          	lw	a2,8(s0)
	uint16_t arg_len = z_shell_strlen(arg);
4000527c:	00050913          	mv	s2,a0
	match = z_shell_cmd_get(cmd, subcmd_idx, &sh->ctx->active_cmd);
40005280:	000a0593          	mv	a1,s4
40005284:	00048513          	mv	a0,s1
40005288:	00c60613          	addi	a2,a2,12
4000528c:	358010ef          	jal	ra,400065e4 <z_shell_cmd_get>
40005290:	00050493          	mv	s1,a0
	cmd_len = z_shell_strlen(match->syntax);
40005294:	00052503          	lw	a0,0(a0)
40005298:	c48ff0ef          	jal	ra,400046e0 <z_shell_strlen>
	if (cmd_len != arg_len) {
4000529c:	02a90063          	beq	s2,a0,400052bc <shell_process+0x410>
		z_shell_op_completion_insert(sh,
400052a0:	0004a583          	lw	a1,0(s1)
400052a4:	41250633          	sub	a2,a0,s2
400052a8:	01061613          	slli	a2,a2,0x10
400052ac:	01065613          	srli	a2,a2,0x10
400052b0:	012585b3          	add	a1,a1,s2
400052b4:	00040513          	mv	a0,s0
400052b8:	41c020ef          	jal	ra,400076d4 <z_shell_op_completion_insert>
	if (isspace((int) sh->ctx->cmd_buff[
400052bc:	00842503          	lw	a0,8(s0)
400052c0:	02000713          	li	a4,32
					sh->ctx->cmd_buff_pos]) == 0) {
400052c4:	04a55783          	lhu	a5,74(a0)
	if (isspace((int) sh->ctx->cmd_buff[
400052c8:	00f507b3          	add	a5,a0,a5
400052cc:	04e7c783          	lbu	a5,78(a5)
400052d0:	00e78863          	beq	a5,a4,400052e0 <shell_process+0x434>
400052d4:	ff778793          	addi	a5,a5,-9
400052d8:	00400713          	li	a4,4
400052dc:	08f76263          	bltu	a4,a5,40005360 <shell_process+0x4b4>
		z_shell_op_cursor_move(sh, 1);
400052e0:	00100593          	li	a1,1
400052e4:	00040513          	mv	a0,s0
400052e8:	249010ef          	jal	ra,40006d30 <z_shell_op_cursor_move>
400052ec:	c25ff06f          	j	40004f10 <shell_process+0x64>
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
400052f0:	00100793          	li	a5,1
400052f4:	f0b7f8e3          	bgeu	a5,a1,40005204 <shell_process+0x358>
	search_argc = space ? *argc : *argc - 1;
400052f8:	fff58593          	addi	a1,a1,-1
	*cmd = z_shell_get_last_command(selected_cmd_get(sh), search_argc,
400052fc:	00000793          	li	a5,0
40005300:	03010713          	addi	a4,sp,48
40005304:	02810693          	addi	a3,sp,40
40005308:	06c10613          	addi	a2,sp,108
4000530c:	00000513          	li	a0,0
40005310:	434010ef          	jal	ra,40006744 <z_shell_get_last_command>
40005314:	00050493          	mv	s1,a0
	if ((*cmd == NULL) && (search_argc != 0)) {
40005318:	ee051ae3          	bnez	a0,4000520c <shell_process+0x360>
4000531c:	bf5ff06f          	j	40004f10 <shell_process+0x64>
	return (strncmp(candidate, str, len) == 0) ? true : false;
40005320:	000ba503          	lw	a0,0(s7)
40005324:	000c0613          	mv	a2,s8
40005328:	000c8593          	mv	a1,s9
4000532c:	465030ef          	jal	ra,40008f90 <strncmp>
		if (is_candidate) {
40005330:	02051463          	bnez	a0,40005358 <shell_process+0x4ac>
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
40005334:	000ba503          	lw	a0,0(s7)
40005338:	3f1030ef          	jal	ra,40008f28 <strlen>
4000533c:	00a9f463          	bgeu	s3,a0,40005344 <shell_process+0x498>
40005340:	00050993          	mv	s3,a0
40005344:	01099993          	slli	s3,s3,0x10
40005348:	0109d993          	srli	s3,s3,0x10
			if (*cnt == 0) {
4000534c:	00091463          	bnez	s2,40005354 <shell_process+0x4a8>
				*first_idx = idx;
40005350:	000a8a13          	mv	s4,s5
			(*cnt)++;
40005354:	00190913          	addi	s2,s2,1
		idx++;
40005358:	001a8a93          	addi	s5,s5,1
4000535c:	ee1ff06f          	j	4000523c <shell_process+0x390>
	return sh->ctx->cfg.flags.insert_mode == 1;
40005360:	26c52783          	lw	a5,620(a0)
40005364:	0017f793          	andi	a5,a5,1
		if (z_flag_insert_mode_get(sh)) {
40005368:	02078463          	beqz	a5,40005390 <shell_process+0x4e4>
			z_flag_insert_mode_set(sh, false);
4000536c:	00000593          	li	a1,0
40005370:	e10ff0ef          	jal	ra,40004980 <z_flag_insert_mode_set.isra.0>
			z_shell_op_char_insert(sh, ' ');
40005374:	02000593          	li	a1,32
40005378:	00040513          	mv	a0,s0
4000537c:	2a4020ef          	jal	ra,40007620 <z_shell_op_char_insert>
			z_flag_insert_mode_set(sh, true);
40005380:	00842503          	lw	a0,8(s0)
40005384:	00100593          	li	a1,1
				z_flag_insert_mode_set(sh, !status);
40005388:	df8ff0ef          	jal	ra,40004980 <z_flag_insert_mode_set.isra.0>
				break;
4000538c:	b85ff06f          	j	40004f10 <shell_process+0x64>
			z_shell_op_char_insert(sh, ' ');
40005390:	02000593          	li	a1,32
					z_shell_op_char_insert(sh, data);
40005394:	00040513          	mv	a0,s0
40005398:	288020ef          	jal	ra,40007620 <z_shell_op_char_insert>
4000539c:	b75ff06f          	j	40004f10 <shell_process+0x64>
	} else if (cnt > 1) {
400053a0:	b727f8e3          	bgeu	a5,s2,40004f10 <shell_process+0x64>
		tab_options_print(sh, cmd, argv[arg_idx], first, cnt,
400053a4:	02812783          	lw	a5,40(sp)
400053a8:	02010713          	addi	a4,sp,32
		sh->ctx->vt100_ctx.printed_cmd = 0;
400053ac:	00090b93          	mv	s7,s2
		tab_options_print(sh, cmd, argv[arg_idx], first, cnt,
400053b0:	00279793          	slli	a5,a5,0x2
400053b4:	0a078793          	addi	a5,a5,160
400053b8:	00e787b3          	add	a5,a5,a4
400053bc:	fac7a783          	lw	a5,-84(a5)
		sh->ctx->vt100_ctx.printed_cmd = 0;
400053c0:	000a0c13          	mv	s8,s4
	longest_option += z_shell_strlen(tab);
400053c4:	4002ccb7          	lui	s9,0x4002c
	size_t str_len = z_shell_strlen(str);
400053c8:	00078513          	mv	a0,a5
		tab_options_print(sh, cmd, argv[arg_idx], first, cnt,
400053cc:	00f12423          	sw	a5,8(sp)
	size_t str_len = z_shell_strlen(str);
400053d0:	b10ff0ef          	jal	ra,400046e0 <z_shell_strlen>
		sh->ctx->vt100_ctx.printed_cmd = 0;
400053d4:	00842783          	lw	a5,8(s0)
	size_t str_len = z_shell_strlen(str);
400053d8:	00a12623          	sw	a0,12(sp)
		z_shell_fprintf(sh, SHELL_OPTION, "%s", option);
400053dc:	4002cd37          	lui	s10,0x4002c
		sh->ctx->vt100_ctx.printed_cmd = 0;
400053e0:	02079e23          	sh	zero,60(a5)
		z_shell_fprintf(sh, SHELL_OPTION, "\n%s%s", tab, option);
400053e4:	4002cdb7          	lui	s11,0x4002c
		match = z_shell_cmd_get(cmd, idx, &sh->ctx->active_cmd);
400053e8:	00842603          	lw	a2,8(s0)
400053ec:	000c0593          	mv	a1,s8
400053f0:	00048513          	mv	a0,s1
400053f4:	00c60613          	addi	a2,a2,12
400053f8:	1ec010ef          	jal	ra,400065e4 <z_shell_cmd_get>
		if (str && match->syntax &&
400053fc:	00812783          	lw	a5,8(sp)
		match = z_shell_cmd_get(cmd, idx, &sh->ctx->active_cmd);
40005400:	00050a93          	mv	s5,a0
		idx++;
40005404:	001c0c13          	addi	s8,s8,1
		if (str && match->syntax &&
40005408:	0e079c63          	bnez	a5,40005500 <shell_process+0x654>
		tab_item_print(sh, match->syntax, longest);
4000540c:	000aa703          	lw	a4,0(s5)
	if (option == NULL) {
40005410:	10071663          	bnez	a4,4000551c <shell_process+0x670>
		sh->ctx->vt100_ctx.printed_cmd = 0;
40005414:	00842783          	lw	a5,8(s0)
40005418:	02079e23          	sh	zero,60(a5)
		cnt--;
4000541c:	fffb8b93          	addi	s7,s7,-1
	while (cnt) {
40005420:	fc0b94e3          	bnez	s7,400053e8 <shell_process+0x53c>
	z_cursor_next_line_move(sh);
40005424:	01442503          	lw	a0,20(s0)
	size_t idx = first + 1;
40005428:	001a0b93          	addi	s7,s4,1
	while (cnt > 1) {
4000542c:	00100d13          	li	s10,1
	z_cursor_next_line_move(sh);
40005430:	bf8ff0ef          	jal	ra,40004828 <z_cursor_next_line_move.isra.0>
	z_shell_print_prompt_and_cmd(sh);
40005434:	00040513          	mv	a0,s0
40005438:	374020ef          	jal	ra,400077ac <z_shell_print_prompt_and_cmd>
		partial_autocomplete(sh, cmd, argv[arg_idx], first, cnt);
4000543c:	02812783          	lw	a5,40(sp)
40005440:	02010713          	addi	a4,sp,32
40005444:	00279793          	slli	a5,a5,0x2
40005448:	0a078793          	addi	a5,a5,160
4000544c:	00e787b3          	add	a5,a5,a4
	uint16_t arg_len = z_shell_strlen(arg);
40005450:	fac7a503          	lw	a0,-84(a5)
40005454:	a8cff0ef          	jal	ra,400046e0 <z_shell_strlen>
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
40005458:	000a0593          	mv	a1,s4
4000545c:	04410613          	addi	a2,sp,68
	uint16_t arg_len = z_shell_strlen(arg);
40005460:	00050a93          	mv	s5,a0
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
40005464:	00048513          	mv	a0,s1
40005468:	17c010ef          	jal	ra,400065e4 <z_shell_cmd_get>
4000546c:	00050993          	mv	s3,a0
	strncpy(sh->ctx->temp_buff, match->syntax,
40005470:	00842503          	lw	a0,8(s0)
40005474:	0009a583          	lw	a1,0(s3)
40005478:	0ff00613          	li	a2,255
4000547c:	14e50513          	addi	a0,a0,334
40005480:	225030ef          	jal	ra,40008ea4 <strncpy>
	*str = match->syntax;
40005484:	0009aa03          	lw	s4,0(s3)
	uint16_t common = UINT16_MAX;
40005488:	000109b7          	lui	s3,0x10
4000548c:	fff98993          	addi	s3,s3,-1 # ffff <__kernel_ram_size+0x3d6b>
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
40005490:	00098c93          	mv	s9,s3
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
40005494:	05810613          	addi	a2,sp,88
40005498:	000b8593          	mv	a1,s7
4000549c:	00048513          	mv	a0,s1
400054a0:	001b8c13          	addi	s8,s7,1
400054a4:	140010ef          	jal	ra,400065e4 <z_shell_cmd_get>
		if (match2 == NULL) {
400054a8:	12050a63          	beqz	a0,400055dc <shell_process+0x730>
		curr_common = str_common(sh->ctx->temp_buff, match2->syntax,
400054ac:	00842683          	lw	a3,8(s0)
400054b0:	00052603          	lw	a2,0(a0)
	size_t common = 0;
400054b4:	00000793          	li	a5,0
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
400054b8:	00f68733          	add	a4,a3,a5
400054bc:	14e74583          	lbu	a1,334(a4)
400054c0:	00f60733          	add	a4,a2,a5
400054c4:	00074703          	lbu	a4,0(a4)
400054c8:	00b71863          	bne	a4,a1,400054d8 <shell_process+0x62c>
400054cc:	00070663          	beqz	a4,400054d8 <shell_process+0x62c>
		common++;
400054d0:	00178793          	addi	a5,a5,1
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
400054d4:	ff9792e3          	bne	a5,s9,400054b8 <shell_process+0x60c>
		if ((arg_len == 0U) || (curr_common >= arg_len)) {
400054d8:	000a8463          	beqz	s5,400054e0 <shell_process+0x634>
400054dc:	0157ce63          	blt	a5,s5,400054f8 <shell_process+0x64c>
			--cnt;
400054e0:	fff90913          	addi	s2,s2,-1
			common = (curr_common < common) ? curr_common : common;
400054e4:	0137d463          	bge	a5,s3,400054ec <shell_process+0x640>
400054e8:	00078993          	mv	s3,a5
400054ec:	01099993          	slli	s3,s3,0x10
400054f0:	0109d993          	srli	s3,s3,0x10
	while (cnt > 1) {
400054f4:	0fa90463          	beq	s2,s10,400055dc <shell_process+0x730>
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
400054f8:	000c0b93          	mv	s7,s8
400054fc:	f99ff06f          	j	40005494 <shell_process+0x5e8>
		if (str && match->syntax &&
40005500:	00052503          	lw	a0,0(a0)
40005504:	f00504e3          	beqz	a0,4000540c <shell_process+0x560>
	return (strncmp(candidate, str, len) == 0) ? true : false;
40005508:	00c12603          	lw	a2,12(sp)
4000550c:	00812583          	lw	a1,8(sp)
40005510:	281030ef          	jal	ra,40008f90 <strncmp>
		if (str && match->syntax &&
40005514:	ee050ce3          	beqz	a0,4000540c <shell_process+0x560>
40005518:	ed1ff06f          	j	400053e8 <shell_process+0x53c>
	longest_option += z_shell_strlen(tab);
4000551c:	788c8513          	addi	a0,s9,1928 # 4002c788 <shell_telnet_fprintf+0x12c>
40005520:	00e12823          	sw	a4,16(sp)
40005524:	9bcff0ef          	jal	ra,400046e0 <z_shell_strlen>
	columns = (sh->ctx->vt100_ctx.cons.terminal_wid
40005528:	00842783          	lw	a5,8(s0)
	longest_option += z_shell_strlen(tab);
4000552c:	013506b3          	add	a3,a0,s3
40005530:	01069693          	slli	a3,a3,0x10
	columns = (sh->ctx->vt100_ctx.cons.terminal_wid
40005534:	02e7d783          	lhu	a5,46(a5)
	longest_option += z_shell_strlen(tab);
40005538:	0106d693          	srli	a3,a3,0x10
			- z_shell_strlen(tab)) / longest_option;
4000553c:	788c8513          	addi	a0,s9,1928
	longest_option += z_shell_strlen(tab);
40005540:	00d12e23          	sw	a3,28(sp)
	columns = (sh->ctx->vt100_ctx.cons.terminal_wid
40005544:	00f12c23          	sw	a5,24(sp)
			- z_shell_strlen(tab)) / longest_option;
40005548:	998ff0ef          	jal	ra,400046e0 <z_shell_strlen>
	diff = longest_option - z_shell_strlen(option);
4000554c:	01012703          	lw	a4,16(sp)
			- z_shell_strlen(tab)) / longest_option;
40005550:	00a12a23          	sw	a0,20(sp)
	diff = longest_option - z_shell_strlen(option);
40005554:	00070513          	mv	a0,a4
40005558:	988ff0ef          	jal	ra,400046e0 <z_shell_strlen>
			- z_shell_strlen(tab)) / longest_option;
4000555c:	01412583          	lw	a1,20(sp)
40005560:	01812783          	lw	a5,24(sp)
	diff = longest_option - z_shell_strlen(option);
40005564:	01c12683          	lw	a3,28(sp)
	if (sh->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
40005568:	01012703          	lw	a4,16(sp)
			- z_shell_strlen(tab)) / longest_option;
4000556c:	40b787b3          	sub	a5,a5,a1
40005570:	02d7c7b3          	div	a5,a5,a3
	diff = longest_option - z_shell_strlen(option);
40005574:	40a68ab3          	sub	s5,a3,a0
	if (sh->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
40005578:	00842503          	lw	a0,8(s0)
	diff = longest_option - z_shell_strlen(option);
4000557c:	010a9a93          	slli	s5,s5,0x10
40005580:	010ada93          	srli	s5,s5,0x10
	if (sh->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
40005584:	03c55603          	lhu	a2,60(a0)
40005588:	00160813          	addi	a6,a2,1
4000558c:	03051e23          	sh	a6,60(a0)
40005590:	01079793          	slli	a5,a5,0x10
40005594:	0107d793          	srli	a5,a5,0x10
40005598:	02f67633          	remu	a2,a2,a5
4000559c:	02061463          	bnez	a2,400055c4 <shell_process+0x718>
		z_shell_fprintf(sh, SHELL_OPTION, "\n%s%s", tab, option);
400055a0:	788c8693          	addi	a3,s9,1928
400055a4:	78cd8613          	addi	a2,s11,1932 # 4002c78c <shell_telnet_fprintf+0x130>
400055a8:	00600593          	li	a1,6
400055ac:	00040513          	mv	a0,s0
400055b0:	4d9010ef          	jal	ra,40007288 <z_shell_fprintf>
	z_shell_op_cursor_horiz_move(sh, diff);
400055b4:	000a8593          	mv	a1,s5
400055b8:	00040513          	mv	a0,s0
400055bc:	5e8010ef          	jal	ra,40006ba4 <z_shell_op_cursor_horiz_move>
400055c0:	e5dff06f          	j	4000541c <shell_process+0x570>
		z_shell_fprintf(sh, SHELL_OPTION, "%s", option);
400055c4:	00070693          	mv	a3,a4
400055c8:	784d0613          	addi	a2,s10,1924 # 4002c784 <shell_telnet_fprintf+0x128>
400055cc:	00600593          	li	a1,6
400055d0:	00040513          	mv	a0,s0
400055d4:	4b5010ef          	jal	ra,40007288 <z_shell_fprintf>
400055d8:	fddff06f          	j	400055b4 <shell_process+0x708>
	if (common) {
400055dc:	92098ae3          	beqz	s3,40004f10 <shell_process+0x64>
		z_shell_op_completion_insert(sh, &completion[arg_len],
400055e0:	41598633          	sub	a2,s3,s5
400055e4:	01061613          	slli	a2,a2,0x10
400055e8:	01065613          	srli	a2,a2,0x10
400055ec:	015a05b3          	add	a1,s4,s5
400055f0:	00040513          	mv	a0,s0
400055f4:	0e0020ef          	jal	ra,400076d4 <z_shell_op_completion_insert>
400055f8:	919ff06f          	j	40004f10 <shell_process+0x64>
	return sh->ctx->cfg.flags.echo == 1;
400055fc:	26c52783          	lw	a5,620(a0)
40005600:	0017d793          	srli	a5,a5,0x1
40005604:	0017f793          	andi	a5,a5,1
				if (z_flag_echo_get(sh)) {
40005608:	900784e3          	beqz	a5,40004f10 <shell_process+0x64>
					z_flag_history_exit_set(sh, true);
4000560c:	00100593          	li	a1,1
40005610:	a44ff0ef          	jal	ra,40004854 <z_flag_history_exit_set.isra.0>
						z_shell_op_char_backspace(sh);
40005614:	00040513          	mv	a0,s0
40005618:	150020ef          	jal	ra,40007768 <z_shell_op_char_backspace>
4000561c:	8f5ff06f          	j	40004f10 <shell_process+0x64>
40005620:	26c52783          	lw	a5,620(a0)
40005624:	0017d793          	srli	a5,a5,0x1
40005628:	0017f793          	andi	a5,a5,1
				if (z_flag_echo_get(sh)) {
4000562c:	8e0782e3          	beqz	a5,40004f10 <shell_process+0x64>
					z_flag_history_exit_set(sh, true);
40005630:	00100593          	li	a1,1
40005634:	a20ff0ef          	jal	ra,40004854 <z_flag_history_exit_set.isra.0>
	return sh->ctx->cfg.flags.mode_delete == 1;
40005638:	00842783          	lw	a5,8(s0)
4000563c:	26c7a783          	lw	a5,620(a5)
40005640:	0037d793          	srli	a5,a5,0x3
40005644:	0017f793          	andi	a5,a5,1
					if (z_flag_mode_delete_get(sh)) {
40005648:	fc0796e3          	bnez	a5,40005614 <shell_process+0x768>
		z_shell_op_char_delete(sh);
4000564c:	00040513          	mv	a0,s0
40005650:	088020ef          	jal	ra,400076d8 <z_shell_op_char_delete>
		break;
40005654:	8bdff06f          	j	40004f10 <shell_process+0x64>
		z_shell_op_left_arrow(sh);
40005658:	00040513          	mv	a0,s0
4000565c:	0c9010ef          	jal	ra,40006f24 <z_shell_op_left_arrow>
		break;
40005660:	8b1ff06f          	j	40004f10 <shell_process+0x64>
		z_shell_op_cursor_end_move(sh);
40005664:	00040513          	mv	a0,s0
40005668:	0a1010ef          	jal	ra,40006f08 <z_shell_op_cursor_end_move>
		if (!z_shell_cursor_in_empty_line(sh)) {
4000566c:	00040513          	mv	a0,s0
40005670:	578010ef          	jal	ra,40006be8 <z_shell_cursor_in_empty_line>
40005674:	00051663          	bnez	a0,40005680 <shell_process+0x7d4>
			z_cursor_next_line_move(sh);
40005678:	01442503          	lw	a0,20(s0)
4000567c:	9acff0ef          	jal	ra,40004828 <z_cursor_next_line_move.isra.0>
		z_flag_history_exit_set(sh, true);
40005680:	00842503          	lw	a0,8(s0)
40005684:	00100593          	li	a1,1
40005688:	9ccff0ef          	jal	ra,40004854 <z_flag_history_exit_set.isra.0>
4000568c:	a89ff06f          	j	40005114 <shell_process+0x268>
		z_shell_op_right_arrow(sh);
40005690:	00040513          	mv	a0,s0
40005694:	0a9010ef          	jal	ra,40006f3c <z_shell_op_right_arrow>
		break;
40005698:	879ff06f          	j	40004f10 <shell_process+0x64>
		z_shell_op_delete_from_cursor(sh);
4000569c:	00040513          	mv	a0,s0
400056a0:	0b9010ef          	jal	ra,40006f58 <z_shell_op_delete_from_cursor>
		break;
400056a4:	86dff06f          	j	40004f10 <shell_process+0x64>
	return sh->ctx->cfg.flags.use_vt100 == 1;
400056a8:	26c72783          	lw	a5,620(a4)
400056ac:	0057d793          	srli	a5,a5,0x5
400056b0:	0017f793          	andi	a5,a5,1
		Z_SHELL_VT100_CMD(sh, SHELL_VT100_CURSORHOME);
400056b4:	00078a63          	beqz	a5,400056c8 <shell_process+0x81c>
400056b8:	01442503          	lw	a0,20(s0)
400056bc:	4002c5b7          	lui	a1,0x4002c
400056c0:	be458593          	addi	a1,a1,-1052 # 4002bbe4 <eth_config+0xc>
400056c4:	848ff0ef          	jal	ra,4000470c <z_shell_raw_fprintf>
400056c8:	00842783          	lw	a5,8(s0)
400056cc:	26c7a783          	lw	a5,620(a5)
400056d0:	0057d793          	srli	a5,a5,0x5
400056d4:	0017f793          	andi	a5,a5,1
		Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEARSCREEN);
400056d8:	00078a63          	beqz	a5,400056ec <shell_process+0x840>
400056dc:	01442503          	lw	a0,20(s0)
400056e0:	4002c5b7          	lui	a1,0x4002c
400056e4:	bec58593          	addi	a1,a1,-1044 # 4002bbec <eth_config+0x14>
400056e8:	824ff0ef          	jal	ra,4000470c <z_shell_raw_fprintf>
		z_shell_print_prompt_and_cmd(sh);
400056ec:	00040513          	mv	a0,s0
400056f0:	0bc020ef          	jal	ra,400077ac <z_shell_print_prompt_and_cmd>
		break;
400056f4:	81dff06f          	j	40004f10 <shell_process+0x64>
		history_handle(sh, false);
400056f8:	00000593          	li	a1,0
		history_handle(sh, true);
400056fc:	00040513          	mv	a0,s0
40005700:	96cff0ef          	jal	ra,4000486c <history_handle>
		break;
40005704:	80dff06f          	j	40004f10 <shell_process+0x64>
		history_handle(sh, true);
40005708:	00100593          	li	a1,1
4000570c:	ff1ff06f          	j	400056fc <shell_process+0x850>
		z_shell_op_cursor_home_move(sh);
40005710:	00040513          	mv	a0,s0
40005714:	7dc010ef          	jal	ra,40006ef0 <z_shell_op_cursor_home_move>
		cmd_buffer_clear(sh);
40005718:	00040513          	mv	a0,s0
4000571c:	f3dfe0ef          	jal	ra,40004658 <cmd_buffer_clear>
		z_flag_history_exit_set(sh, true);
40005720:	00842503          	lw	a0,8(s0)
40005724:	00100593          	li	a1,1
40005728:	92cff0ef          	jal	ra,40004854 <z_flag_history_exit_set.isra.0>
4000572c:	00842783          	lw	a5,8(s0)
40005730:	26c7a783          	lw	a5,620(a5)
40005734:	0057d793          	srli	a5,a5,0x5
40005738:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
4000573c:	fc078a63          	beqz	a5,40004f10 <shell_process+0x64>
40005740:	01442503          	lw	a0,20(s0)
40005744:	4002c5b7          	lui	a1,0x4002c
40005748:	bdc58593          	addi	a1,a1,-1060 # 4002bbdc <eth_config+0x4>
4000574c:	fc1fe0ef          	jal	ra,4000470c <z_shell_raw_fprintf>
40005750:	fc0ff06f          	j	40004f10 <shell_process+0x64>
		z_shell_op_word_remove(sh);
40005754:	00040513          	mv	a0,s0
40005758:	365010ef          	jal	ra,400072bc <z_shell_op_word_remove>
		z_flag_history_exit_set(sh, true);
4000575c:	00842503          	lw	a0,8(s0)
40005760:	00100593          	li	a1,1
40005764:	8f0ff0ef          	jal	ra,40004854 <z_flag_history_exit_set.isra.0>
		break;
40005768:	fa8ff06f          	j	40004f10 <shell_process+0x64>
			if (data == '[') {
4000576c:	05b00693          	li	a3,91
40005770:	00d79663          	bne	a5,a3,4000577c <shell_process+0x8d0>
	sh->ctx->receive_state = state;
40005774:	01672423          	sw	s6,8(a4)
}
40005778:	f98ff06f          	j	40004f10 <shell_process+0x64>
	return sh->ctx->cfg.flags.echo == 1;
4000577c:	26c72703          	lw	a4,620(a4)
40005780:	00175713          	srli	a4,a4,0x1
40005784:	00177713          	andi	a4,a4,1
			} else if (z_flag_echo_get(sh)) {
40005788:	02070263          	beqz	a4,400057ac <shell_process+0x900>
	if (data == SHELL_VT100_ASCII_ALT_B) {
4000578c:	06200713          	li	a4,98
		z_shell_op_cursor_word_move(sh, -1);
40005790:	fff00593          	li	a1,-1
	if (data == SHELL_VT100_ASCII_ALT_B) {
40005794:	00e78863          	beq	a5,a4,400057a4 <shell_process+0x8f8>
	} else if (data == SHELL_VT100_ASCII_ALT_F) {
40005798:	06600713          	li	a4,102
4000579c:	00e79863          	bne	a5,a4,400057ac <shell_process+0x900>
		z_shell_op_cursor_word_move(sh, 1);
400057a0:	00100593          	li	a1,1
400057a4:	00040513          	mv	a0,s0
400057a8:	634010ef          	jal	ra,40006ddc <z_shell_op_cursor_word_move>
	sh->ctx->receive_state = state;
400057ac:	00842783          	lw	a5,8(s0)
400057b0:	0007a423          	sw	zero,8(a5)
}
400057b4:	f5cff06f          	j	40004f10 <shell_process+0x64>
	sh->ctx->receive_state = state;
400057b8:	00072423          	sw	zero,8(a4)
400057bc:	00842703          	lw	a4,8(s0)
400057c0:	26c72683          	lw	a3,620(a4)
400057c4:	0016d693          	srli	a3,a3,0x1
400057c8:	0016f693          	andi	a3,a3,1
			if (!z_flag_echo_get(sh)) {
400057cc:	f4068263          	beqz	a3,40004f10 <shell_process+0x64>
			switch (data) {
400057d0:	fcf78793          	addi	a5,a5,-49
400057d4:	0ff7f793          	zext.b	a5,a5
400057d8:	01b00693          	li	a3,27
400057dc:	f2f6ea63          	bltu	a3,a5,40004f10 <shell_process+0x64>
400057e0:	4002c6b7          	lui	a3,0x4002c
400057e4:	00279793          	slli	a5,a5,0x2
400057e8:	7f068693          	addi	a3,a3,2032 # 4002c7f0 <shell_telnet_fprintf+0x194>
400057ec:	00d787b3          	add	a5,a5,a3
400057f0:	0007a783          	lw	a5,0(a5)
400057f4:	00078067          	jr	a5
	sh->ctx->receive_state = state;
400057f8:	00300793          	li	a5,3
400057fc:	00f72423          	sw	a5,8(a4)
		z_shell_op_cursor_end_move(sh);
40005800:	00040513          	mv	a0,s0
40005804:	704010ef          	jal	ra,40006f08 <z_shell_op_cursor_end_move>
		break;
40005808:	f08ff06f          	j	40004f10 <shell_process+0x64>
	sh->ctx->receive_state = state;
4000580c:	00300793          	li	a5,3
40005810:	00f72423          	sw	a5,8(a4)
		z_shell_op_cursor_home_move(sh);
40005814:	00040513          	mv	a0,s0
40005818:	6d8010ef          	jal	ra,40006ef0 <z_shell_op_cursor_home_move>
		break;
4000581c:	ef4ff06f          	j	40004f10 <shell_process+0x64>
	sh->ctx->receive_state = state;
40005820:	00300793          	li	a5,3
40005824:	00f72423          	sw	a5,8(a4)
	return sh->ctx->cfg.flags.insert_mode == 1;
40005828:	00842503          	lw	a0,8(s0)
4000582c:	26c52583          	lw	a1,620(a0)
40005830:	0015f593          	andi	a1,a1,1
				z_flag_insert_mode_set(sh, !status);
40005834:	0015c593          	xori	a1,a1,1
40005838:	b51ff06f          	j	40005388 <shell_process+0x4dc>
	sh->ctx->receive_state = state;
4000583c:	00300793          	li	a5,3
40005840:	00f72423          	sw	a5,8(a4)
	return sh->ctx->cfg.flags.echo == 1;
40005844:	00842783          	lw	a5,8(s0)
40005848:	26c7a783          	lw	a5,620(a5)
4000584c:	0017d793          	srli	a5,a5,0x1
40005850:	0017f793          	andi	a5,a5,1
				if (z_flag_echo_get(sh)) {
40005854:	ea078e63          	beqz	a5,40004f10 <shell_process+0x64>
40005858:	df5ff06f          	j	4000564c <shell_process+0x7a0>

4000585c <shell_init>:
{
4000585c:	fc010113          	addi	sp,sp,-64
40005860:	02812c23          	sw	s0,56(sp)
40005864:	02912a23          	sw	s1,52(sp)
40005868:	02112e23          	sw	ra,60(sp)
4000586c:	03212823          	sw	s2,48(sp)
40005870:	03312623          	sw	s3,44(sp)
40005874:	03412423          	sw	s4,40(sp)
40005878:	03512223          	sw	s5,36(sp)
4000587c:	03612023          	sw	s6,32(sp)
40005880:	01712e23          	sw	s7,28(sp)
40005884:	00050413          	mv	s0,a0
	if (sh->ctx->tid) {
40005888:	00852503          	lw	a0,8(a0)
		return -EALREADY;
4000588c:	f8800493          	li	s1,-120
	if (sh->ctx->tid) {
40005890:	31852783          	lw	a5,792(a0)
40005894:	14079863          	bnez	a5,400059e4 <shell_init+0x188>
40005898:	00058a93          	mv	s5,a1
4000589c:	00060493          	mv	s1,a2
	memset(sh->ctx, 0, sizeof(*sh->ctx));
400058a0:	00000593          	li	a1,0
400058a4:	32000613          	li	a2,800
400058a8:	00068993          	mv	s3,a3
400058ac:	00070a13          	mv	s4,a4
400058b0:	7c0030ef          	jal	ra,40009070 <memset>
	sh->ctx->prompt = sh->default_prompt;
400058b4:	00842783          	lw	a5,8(s0)
400058b8:	00042703          	lw	a4,0(s0)
400058bc:	00e7a023          	sw	a4,0(a5)
	z_shell_history_init(sh->history);
400058c0:	00c42503          	lw	a0,12(s0)
400058c4:	5bd020ef          	jal	ra,40008680 <z_shell_history_init>
	k_mutex_init(&sh->ctx->wr_mtx);
400058c8:	00842503          	lw	a0,8(s0)
400058cc:	30450513          	addi	a0,a0,772
	return z_impl_k_mutex_init(mutex);
400058d0:	2b400b13          	li	s6,692
400058d4:	791220ef          	jal	ra,40028864 <z_impl_k_mutex_init>
400058d8:	27400913          	li	s2,628
	for (int i = 0; i < SHELL_SIGNALS; i++) {
400058dc:	2b400b93          	li	s7,692
		k_poll_signal_init(&sh->ctx->signals[i]);
400058e0:	00842503          	lw	a0,8(s0)
400058e4:	01250533          	add	a0,a0,s2
	z_impl_k_poll_signal_init(sig);
400058e8:	511250ef          	jal	ra,4002b5f8 <z_impl_k_poll_signal_init>
		k_poll_event_init(&sh->ctx->events[i],
400058ec:	00842503          	lw	a0,8(s0)
400058f0:	00000613          	li	a2,0
400058f4:	00100593          	li	a1,1
400058f8:	012506b3          	add	a3,a0,s2
400058fc:	01650533          	add	a0,a0,s6
	for (int i = 0; i < SHELL_SIGNALS; i++) {
40005900:	01090913          	addi	s2,s2,16
		k_poll_event_init(&sh->ctx->events[i],
40005904:	391250ef          	jal	ra,4002b494 <k_poll_event_init>
	for (int i = 0; i < SHELL_SIGNALS; i++) {
40005908:	014b0b13          	addi	s6,s6,20
4000590c:	fd791ae3          	bne	s2,s7,400058e0 <shell_init+0x84>
		sh->stats->log_lost_cnt = 0;
40005910:	01842783          	lw	a5,24(s0)
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, tx_rdy, val, ret);
40005914:	00200593          	li	a1,2
	sh->ctx->cfg.flags = cfg_flags;
40005918:	ffb4f493          	andi	s1,s1,-5
		sh->stats->log_lost_cnt = 0;
4000591c:	0007a023          	sw	zero,0(a5)
40005920:	00842503          	lw	a0,8(s0)
40005924:	27050513          	addi	a0,a0,624
40005928:	d4dfe0ef          	jal	ra,40004674 <atomic_or>
	sh->ctx->vt100_ctx.cons.terminal_wid =
4000592c:	00842783          	lw	a5,8(s0)
40005930:	05000713          	li	a4,80
40005934:	02e79723          	sh	a4,46(a5)
	sh->ctx->vt100_ctx.cons.terminal_hei =
40005938:	00842783          	lw	a5,8(s0)
4000593c:	01800713          	li	a4,24
40005940:	02e79623          	sh	a4,44(a5)
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
40005944:	00842783          	lw	a5,8(s0)
40005948:	0007a503          	lw	a0,0(a5)
4000594c:	d95fe0ef          	jal	ra,400046e0 <z_shell_strlen>
40005950:	00842783          	lw	a5,8(s0)
	int ret = sh->iface->api->init(sh->iface, transport_config,
40005954:	40004637          	lui	a2,0x40004
40005958:	00040693          	mv	a3,s0
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
4000595c:	02a78823          	sb	a0,48(a5)
	sh->ctx->cfg.flags = cfg_flags;
40005960:	00842783          	lw	a5,8(s0)
	int ret = sh->iface->api->init(sh->iface, transport_config,
40005964:	78860613          	addi	a2,a2,1928 # 40004788 <transport_evt_handler>
40005968:	000a8593          	mv	a1,s5
	sh->ctx->cfg.flags = cfg_flags;
4000596c:	2697a623          	sw	s1,620(a5)
	int ret = sh->iface->api->init(sh->iface, transport_config,
40005970:	00442503          	lw	a0,4(s0)
40005974:	00052783          	lw	a5,0(a0)
40005978:	0007a783          	lw	a5,0(a5)
4000597c:	000780e7          	jalr	a5
40005980:	00050493          	mv	s1,a0
	if (ret == 0) {
40005984:	06051063          	bnez	a0,400059e4 <shell_init+0x188>
	sh->ctx->state = state;
40005988:	00842783          	lw	a5,8(s0)
4000598c:	00100713          	li	a4,1
40005990:	00e7a223          	sw	a4,4(a5)
	k_tid_t tid = k_thread_create(sh->thread,
40005994:	02442503          	lw	a0,36(s0)
				  sh->stack, CONFIG_SHELL_STACK_SIZE,
40005998:	02842583          	lw	a1,40(s0)
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
4000599c:	00000793          	li	a5,0
400059a0:	00000813          	li	a6,0
400059a4:	400066b7          	lui	a3,0x40006
400059a8:	00001637          	lui	a2,0x1
400059ac:	00f12423          	sw	a5,8(sp)
400059b0:	01012623          	sw	a6,12(sp)
400059b4:	00098793          	mv	a5,s3
400059b8:	00012023          	sw	zero,0(sp)
400059bc:	00e00893          	li	a7,14
400059c0:	000a0813          	mv	a6,s4
400059c4:	00040713          	mv	a4,s0
400059c8:	a9c68693          	addi	a3,a3,-1380 # 40005a9c <shell_thread>
400059cc:	80060613          	addi	a2,a2,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
400059d0:	221220ef          	jal	ra,400283f0 <z_impl_k_thread_create>
	sh->ctx->tid = tid;
400059d4:	00842783          	lw	a5,8(s0)
400059d8:	30a7ac23          	sw	a0,792(a5)
	k_thread_name_set(tid, sh->thread_name);
400059dc:	02042583          	lw	a1,32(s0)
	return z_impl_k_thread_name_set(thread, str);
400059e0:	744220ef          	jal	ra,40028124 <z_impl_k_thread_name_set>
}
400059e4:	03c12083          	lw	ra,60(sp)
400059e8:	03812403          	lw	s0,56(sp)
400059ec:	03012903          	lw	s2,48(sp)
400059f0:	02c12983          	lw	s3,44(sp)
400059f4:	02812a03          	lw	s4,40(sp)
400059f8:	02412a83          	lw	s5,36(sp)
400059fc:	02012b03          	lw	s6,32(sp)
40005a00:	01c12b83          	lw	s7,28(sp)
40005a04:	00048513          	mv	a0,s1
40005a08:	03412483          	lw	s1,52(sp)
40005a0c:	04010113          	addi	sp,sp,64
40005a10:	00008067          	ret

40005a14 <shell_start>:
{
40005a14:	ff010113          	addi	sp,sp,-16
40005a18:	00812423          	sw	s0,8(sp)
40005a1c:	00112623          	sw	ra,12(sp)
40005a20:	00050413          	mv	s0,a0
	return sh->ctx->state;
40005a24:	00852503          	lw	a0,8(a0)
	if (state_get(sh) != SHELL_STATE_INITIALIZED) {
40005a28:	00100793          	li	a5,1
40005a2c:	00452703          	lw	a4,4(a0)
40005a30:	06f71263          	bne	a4,a5,40005a94 <shell_start+0x80>
	k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
40005a34:	fff00593          	li	a1,-1
40005a38:	fff00613          	li	a2,-1
40005a3c:	30450513          	addi	a0,a0,772
40005a40:	d45fe0ef          	jal	ra,40004784 <k_mutex_lock.constprop.0.isra.0>
		z_shell_vt100_color_set(sh, SHELL_NORMAL);
40005a44:	00040513          	mv	a0,s0
40005a48:	00800593          	li	a1,8
40005a4c:	69c010ef          	jal	ra,400070e8 <z_shell_vt100_color_set>
	if (z_shell_strlen(sh->default_prompt) > 0) {
40005a50:	00042503          	lw	a0,0(s0)
40005a54:	c8dfe0ef          	jal	ra,400046e0 <z_shell_strlen>
40005a58:	00050a63          	beqz	a0,40005a6c <shell_start+0x58>
		z_shell_raw_fprintf(sh->fprintf_ctx, "\n\n");
40005a5c:	01442503          	lw	a0,20(s0)
40005a60:	4002c5b7          	lui	a1,0x4002c
40005a64:	f1058593          	addi	a1,a1,-240 # 4002bf10 <__clz_tab+0x2e4>
40005a68:	ca5fe0ef          	jal	ra,4000470c <z_shell_raw_fprintf>
	state_set(sh, SHELL_STATE_ACTIVE);
40005a6c:	00040513          	mv	a0,s0
40005a70:	bb4ff0ef          	jal	ra,40004e24 <state_set.constprop.0>
	k_mutex_unlock(&sh->ctx->wr_mtx);
40005a74:	00842503          	lw	a0,8(s0)
40005a78:	30450513          	addi	a0,a0,772
40005a7c:	f39fe0ef          	jal	ra,400049b4 <k_mutex_unlock.isra.0>
	return 0;
40005a80:	00000513          	li	a0,0
}
40005a84:	00c12083          	lw	ra,12(sp)
40005a88:	00812403          	lw	s0,8(sp)
40005a8c:	01010113          	addi	sp,sp,16
40005a90:	00008067          	ret
		return -ENOTSUP;
40005a94:	f7a00513          	li	a0,-134
40005a98:	fedff06f          	j	40005a84 <shell_start+0x70>

40005a9c <shell_thread>:
{
40005a9c:	fe010113          	addi	sp,sp,-32
40005aa0:	00812c23          	sw	s0,24(sp)
40005aa4:	00112e23          	sw	ra,28(sp)
40005aa8:	00912a23          	sw	s1,20(sp)
40005aac:	01212823          	sw	s2,16(sp)
40005ab0:	00050413          	mv	s0,a0
	err = sh->iface->api->enable(sh->iface, false);
40005ab4:	00452503          	lw	a0,4(a0)
40005ab8:	00000593          	li	a1,0
40005abc:	00052783          	lw	a5,0(a0)
40005ac0:	0087a783          	lw	a5,8(a5)
40005ac4:	000780e7          	jalr	a5
	if (err != 0) {
40005ac8:	0c051e63          	bnez	a0,40005ba4 <shell_thread+0x108>
		err = shell_start(sh);
40005acc:	00040513          	mv	a0,s0
40005ad0:	f45ff0ef          	jal	ra,40005a14 <shell_start>
		if (err != 0) {
40005ad4:	0c051863          	bnez	a0,40005ba4 <shell_thread+0x108>
		shell_signal_handle(sh, SHELL_SIGNAL_KILL, kill_handler);
40005ad8:	400044b7          	lui	s1,0x40004
		shell_signal_handle(sh, SHELL_SIGNAL_RXRDY, shell_process);
40005adc:	40005937          	lui	s2,0x40005
		err = k_poll(sh->ctx->events, SHELL_SIGNAL_TXDONE,
40005ae0:	00842503          	lw	a0,8(s0)
40005ae4:	2b450513          	addi	a0,a0,692
	return z_impl_k_poll(events, num_events, timeout);
40005ae8:	fff00693          	li	a3,-1
40005aec:	fff00613          	li	a2,-1
40005af0:	00300593          	li	a1,3
40005af4:	1d9250ef          	jal	ra,4002b4cc <z_impl_k_poll>
40005af8:	00050693          	mv	a3,a0
		if (err != 0) {
40005afc:	00842503          	lw	a0,8(s0)
40005b00:	04068863          	beqz	a3,40005b50 <shell_thread+0xb4>
			k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
40005b04:	fff00593          	li	a1,-1
40005b08:	fff00613          	li	a2,-1
40005b0c:	30450513          	addi	a0,a0,772
40005b10:	00d12623          	sw	a3,12(sp)
40005b14:	c71fe0ef          	jal	ra,40004784 <k_mutex_lock.constprop.0.isra.0>
			z_shell_fprintf(sh, SHELL_ERROR,
40005b18:	00c12683          	lw	a3,12(sp)
40005b1c:	4002d637          	lui	a2,0x4002d
40005b20:	00040513          	mv	a0,s0
40005b24:	86060613          	addi	a2,a2,-1952 # 4002c860 <shell_telnet_fprintf+0x204>
40005b28:	00100593          	li	a1,1
40005b2c:	75c010ef          	jal	ra,40007288 <z_shell_fprintf>
			k_mutex_unlock(&sh->ctx->wr_mtx);
40005b30:	00842503          	lw	a0,8(s0)
}
40005b34:	01812403          	lw	s0,24(sp)
40005b38:	01c12083          	lw	ra,28(sp)
40005b3c:	01412483          	lw	s1,20(sp)
40005b40:	01012903          	lw	s2,16(sp)
			k_mutex_unlock(&sh->ctx->wr_mtx);
40005b44:	30450513          	addi	a0,a0,772
}
40005b48:	02010113          	addi	sp,sp,32
			k_mutex_unlock(&sh->ctx->wr_mtx);
40005b4c:	e69fe06f          	j	400049b4 <k_mutex_unlock.isra.0>
		k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
40005b50:	fff00593          	li	a1,-1
40005b54:	fff00613          	li	a2,-1
40005b58:	30450513          	addi	a0,a0,772
40005b5c:	c29fe0ef          	jal	ra,40004784 <k_mutex_lock.constprop.0.isra.0>
		shell_signal_handle(sh, SHELL_SIGNAL_KILL, kill_handler);
40005b60:	7a448613          	addi	a2,s1,1956 # 400047a4 <kill_handler>
40005b64:	00200593          	li	a1,2
40005b68:	00040513          	mv	a0,s0
40005b6c:	b11fe0ef          	jal	ra,4000467c <shell_signal_handle>
		shell_signal_handle(sh, SHELL_SIGNAL_RXRDY, shell_process);
40005b70:	00040513          	mv	a0,s0
40005b74:	eac90613          	addi	a2,s2,-340 # 40004eac <shell_process>
40005b78:	00000593          	li	a1,0
40005b7c:	b01fe0ef          	jal	ra,4000467c <shell_signal_handle>
		if (sh->iface->api->update) {
40005b80:	00442503          	lw	a0,4(s0)
40005b84:	00052783          	lw	a5,0(a0)
40005b88:	0147a783          	lw	a5,20(a5)
40005b8c:	00078463          	beqz	a5,40005b94 <shell_thread+0xf8>
			sh->iface->api->update(sh->iface);
40005b90:	000780e7          	jalr	a5
		k_mutex_unlock(&sh->ctx->wr_mtx);
40005b94:	00842503          	lw	a0,8(s0)
40005b98:	30450513          	addi	a0,a0,772
40005b9c:	e19fe0ef          	jal	ra,400049b4 <k_mutex_unlock.isra.0>
	while (true) {
40005ba0:	f41ff06f          	j	40005ae0 <shell_thread+0x44>
}
40005ba4:	01c12083          	lw	ra,28(sp)
40005ba8:	01812403          	lw	s0,24(sp)
40005bac:	01412483          	lw	s1,20(sp)
40005bb0:	01012903          	lw	s2,16(sp)
40005bb4:	02010113          	addi	sp,sp,32
40005bb8:	00008067          	ret

40005bbc <shell_vfprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_vfprintf(const struct shell *sh, enum shell_vt100_color color,
		   const char *fmt, va_list args)
{
40005bbc:	fe010113          	addi	sp,sp,-32
40005bc0:	00812c23          	sw	s0,24(sp)
40005bc4:	00112e23          	sw	ra,28(sp)
40005bc8:	00912a23          	sw	s1,20(sp)
40005bcc:	01212823          	sw	s2,16(sp)
40005bd0:	01312623          	sw	s3,12(sp)
40005bd4:	00050413          	mv	s0,a0
	return sh->ctx->state;
40005bd8:	00852503          	lw	a0,8(a0)
			(k_current_get() != sh->ctx->tid));
	__ASSERT_NO_MSG(sh->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	/* Sending a message to a non-active shell leads to a dead lock. */
	if (state_get(sh) != SHELL_STATE_ACTIVE) {
40005bdc:	00200793          	li	a5,2
40005be0:	00452703          	lw	a4,4(a0)
40005be4:	02f70463          	beq	a4,a5,40005c0c <shell_vfprintf+0x50>
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
		z_shell_print_prompt_and_cmd(sh);
	}
	z_transport_buffer_flush(sh);
	k_mutex_unlock(&sh->ctx->wr_mtx);
}
40005be8:	01812403          	lw	s0,24(sp)
40005bec:	01c12083          	lw	ra,28(sp)
40005bf0:	01412483          	lw	s1,20(sp)
40005bf4:	01012903          	lw	s2,16(sp)
40005bf8:	00c12983          	lw	s3,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, print_noinit, val, ret);
40005bfc:	000015b7          	lui	a1,0x1
40005c00:	27050513          	addi	a0,a0,624
40005c04:	02010113          	addi	sp,sp,32
40005c08:	a6dfe06f          	j	40004674 <atomic_or>
40005c0c:	00058493          	mv	s1,a1
40005c10:	00060913          	mv	s2,a2
	k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
40005c14:	fff00593          	li	a1,-1
40005c18:	fff00613          	li	a2,-1
40005c1c:	30450513          	addi	a0,a0,772
40005c20:	00068993          	mv	s3,a3
40005c24:	b61fe0ef          	jal	ra,40004784 <k_mutex_lock.constprop.0.isra.0>
	return sh->ctx->ctx.flags.cmd_ctx == 1;
40005c28:	00842703          	lw	a4,8(s0)
40005c2c:	27072783          	lw	a5,624(a4)
40005c30:	00b7d793          	srli	a5,a5,0xb
40005c34:	0017f793          	andi	a5,a5,1
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
40005c38:	00079a63          	bnez	a5,40005c4c <shell_vfprintf+0x90>
40005c3c:	04472783          	lw	a5,68(a4)
40005c40:	00079663          	bnez	a5,40005c4c <shell_vfprintf+0x90>
		z_shell_cmd_line_erase(sh);
40005c44:	00040513          	mv	a0,s0
40005c48:	330010ef          	jal	ra,40006f78 <z_shell_cmd_line_erase>
	z_shell_vfprintf(sh, color, fmt, args);
40005c4c:	00098693          	mv	a3,s3
40005c50:	00090613          	mv	a2,s2
40005c54:	00048593          	mv	a1,s1
40005c58:	00040513          	mv	a0,s0
40005c5c:	56c010ef          	jal	ra,400071c8 <z_shell_vfprintf>
40005c60:	00842703          	lw	a4,8(s0)
40005c64:	27072783          	lw	a5,624(a4)
40005c68:	00b7d793          	srli	a5,a5,0xb
40005c6c:	0017f793          	andi	a5,a5,1
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
40005c70:	00079a63          	bnez	a5,40005c84 <shell_vfprintf+0xc8>
40005c74:	04472783          	lw	a5,68(a4)
40005c78:	00079663          	bnez	a5,40005c84 <shell_vfprintf+0xc8>
		z_shell_print_prompt_and_cmd(sh);
40005c7c:	00040513          	mv	a0,s0
40005c80:	32d010ef          	jal	ra,400077ac <z_shell_print_prompt_and_cmd>
	z_shell_fprintf_buffer_flush(sh->fprintf_ctx);
40005c84:	01442503          	lw	a0,20(s0)
40005c88:	380000ef          	jal	ra,40006008 <z_shell_fprintf_buffer_flush>
	k_mutex_unlock(&sh->ctx->wr_mtx);
40005c8c:	00842503          	lw	a0,8(s0)
}
40005c90:	01812403          	lw	s0,24(sp)
40005c94:	01c12083          	lw	ra,28(sp)
40005c98:	01412483          	lw	s1,20(sp)
40005c9c:	01012903          	lw	s2,16(sp)
40005ca0:	00c12983          	lw	s3,12(sp)
	k_mutex_unlock(&sh->ctx->wr_mtx);
40005ca4:	30450513          	addi	a0,a0,772
}
40005ca8:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&sh->ctx->wr_mtx);
40005cac:	d09fe06f          	j	400049b4 <k_mutex_unlock.isra.0>

40005cb0 <shell_fprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_fprintf(const struct shell *sh, enum shell_vt100_color color,
		   const char *fmt, ...)
{
40005cb0:	fc010113          	addi	sp,sp,-64
40005cb4:	02d12623          	sw	a3,44(sp)
	va_list args;

	va_start(args, fmt);
40005cb8:	02c10693          	addi	a3,sp,44
{
40005cbc:	00112e23          	sw	ra,28(sp)
40005cc0:	02e12823          	sw	a4,48(sp)
40005cc4:	02f12a23          	sw	a5,52(sp)
40005cc8:	03012c23          	sw	a6,56(sp)
40005ccc:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
40005cd0:	00d12623          	sw	a3,12(sp)
	shell_vfprintf(sh, color, fmt, args);
40005cd4:	ee9ff0ef          	jal	ra,40005bbc <shell_vfprintf>
	va_end(args);
}
40005cd8:	01c12083          	lw	ra,28(sp)
40005cdc:	04010113          	addi	sp,sp,64
40005ce0:	00008067          	ret

40005ce4 <cmd_help>:
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

#if defined(CONFIG_SHELL_TAB)
	shell_print(sh, "Please press the <Tab> button to see all available "
40005ce4:	4002d637          	lui	a2,0x4002d
{
40005ce8:	ff010113          	addi	sp,sp,-16
	shell_print(sh, "Please press the <Tab> button to see all available "
40005cec:	87860613          	addi	a2,a2,-1928 # 4002c878 <shell_telnet_fprintf+0x21c>
40005cf0:	00800593          	li	a1,8
{
40005cf4:	00112623          	sw	ra,12(sp)
40005cf8:	00812423          	sw	s0,8(sp)
40005cfc:	00050413          	mv	s0,a0
	shell_print(sh, "Please press the <Tab> button to see all available "
40005d00:	fb1ff0ef          	jal	ra,40005cb0 <shell_fprintf>
			   "commands.");
#endif

#if defined(CONFIG_SHELL_TAB_AUTOCOMPLETION)
	shell_print(sh,
40005d04:	4002d637          	lui	a2,0x4002d
40005d08:	00040513          	mv	a0,s0
40005d0c:	8b860613          	addi	a2,a2,-1864 # 4002c8b8 <shell_telnet_fprintf+0x25c>
40005d10:	00800593          	li	a1,8
40005d14:	f9dff0ef          	jal	ra,40005cb0 <shell_fprintf>
		"You can also use the <Tab> button to prompt or auto-complete"
		" all commands or its subcommands.");
#endif

#if defined(CONFIG_SHELL_HELP)
	shell_print(sh,
40005d18:	4002d637          	lui	a2,0x4002d
40005d1c:	00040513          	mv	a0,s0
40005d20:	91860613          	addi	a2,a2,-1768 # 4002c918 <shell_telnet_fprintf+0x2bc>
40005d24:	00800593          	li	a1,8
40005d28:	f89ff0ef          	jal	ra,40005cb0 <shell_fprintf>
		"You can try to call commands with <-h> or <--help> parameter"
		" for more information.");
#endif

#if defined(CONFIG_SHELL_METAKEYS)
	shell_print(sh,
40005d2c:	4002d637          	lui	a2,0x4002d
40005d30:	00040513          	mv	a0,s0
40005d34:	96c60613          	addi	a2,a2,-1684 # 4002c96c <shell_telnet_fprintf+0x310>
40005d38:	00800593          	li	a1,8
40005d3c:	f75ff0ef          	jal	ra,40005cb0 <shell_fprintf>
		"Please refer to shell documentation for more details.");
#endif

	if (IS_ENABLED(CONFIG_SHELL_HELP)) {
		/* For NULL argument function will print all root commands */
		z_shell_help_subcmd_print(sh, NULL,
40005d40:	4002d637          	lui	a2,0x4002d
40005d44:	00040513          	mv	a0,s0
40005d48:	a0860613          	addi	a2,a2,-1528 # 4002ca08 <shell_telnet_fprintf+0x3ac>
40005d4c:	00000593          	li	a1,0
40005d50:	4c5010ef          	jal	ra,40007a14 <z_shell_help_subcmd_print>
			shell_print(sh, "  %s", entry->syntax);
		}
	}

	return 0;
}
40005d54:	00c12083          	lw	ra,12(sp)
40005d58:	00812403          	lw	s0,8(sp)
40005d5c:	00000513          	li	a0,0
40005d60:	01010113          	addi	sp,sp,16
40005d64:	00008067          	ret

40005d68 <shell_hexdump_line>:
{
40005d68:	fe010113          	addi	sp,sp,-32
40005d6c:	01312623          	sw	s3,12(sp)
40005d70:	00060993          	mv	s3,a2
	shell_fprintf(sh, SHELL_NORMAL, "%08X: ", offset);
40005d74:	4002d637          	lui	a2,0x4002d
{
40005d78:	01212823          	sw	s2,16(sp)
	shell_fprintf(sh, SHELL_NORMAL, "%08X: ", offset);
40005d7c:	a2060613          	addi	a2,a2,-1504 # 4002ca20 <shell_telnet_fprintf+0x3c4>
{
40005d80:	00068913          	mv	s2,a3
	shell_fprintf(sh, SHELL_NORMAL, "%08X: ", offset);
40005d84:	00058693          	mv	a3,a1
40005d88:	00800593          	li	a1,8
{
40005d8c:	00812c23          	sw	s0,24(sp)
40005d90:	00112e23          	sw	ra,28(sp)
40005d94:	00912a23          	sw	s1,20(sp)
40005d98:	00050413          	mv	s0,a0
	shell_fprintf(sh, SHELL_NORMAL, "%08X: ", offset);
40005d9c:	f15ff0ef          	jal	ra,40005cb0 <shell_fprintf>
		if (i < len) {
40005da0:	08091263          	bnez	s2,40005e24 <shell_hexdump_line+0xbc>
			shell_fprintf(sh, SHELL_NORMAL, "   ");
40005da4:	4002d637          	lui	a2,0x4002d
40005da8:	a2860613          	addi	a2,a2,-1496 # 4002ca28 <shell_telnet_fprintf+0x3cc>
40005dac:	00800593          	li	a1,8
40005db0:	00040513          	mv	a0,s0
40005db4:	efdff0ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
40005db8:	00100493          	li	s1,1
			shell_fprintf(sh, SHELL_NORMAL, "   ");
40005dbc:	4002d637          	lui	a2,0x4002d
40005dc0:	a2860613          	addi	a2,a2,-1496 # 4002ca28 <shell_telnet_fprintf+0x3cc>
40005dc4:	00800593          	li	a1,8
40005dc8:	00040513          	mv	a0,s0
40005dcc:	ee5ff0ef          	jal	ra,40005cb0 <shell_fprintf>
40005dd0:	03c0006f          	j	40005e0c <shell_hexdump_line+0xa4>
			shell_fprintf(sh, SHELL_NORMAL, " ");
40005dd4:	4002e637          	lui	a2,0x4002e
40005dd8:	6e060613          	addi	a2,a2,1760 # 4002e6e0 <CSWTCH.14405+0x1104>
40005ddc:	00800593          	li	a1,8
40005de0:	00040513          	mv	a0,s0
40005de4:	ecdff0ef          	jal	ra,40005cb0 <shell_fprintf>
		if (i < len) {
40005de8:	00048793          	mv	a5,s1
40005dec:	fd24f8e3          	bgeu	s1,s2,40005dbc <shell_hexdump_line+0x54>
				      data[i] & 0xFF);
40005df0:	00f987b3          	add	a5,s3,a5
			shell_fprintf(sh, SHELL_NORMAL, "%02x ",
40005df4:	0007c683          	lbu	a3,0(a5)
40005df8:	4002d637          	lui	a2,0x4002d
40005dfc:	a2c60613          	addi	a2,a2,-1492 # 4002ca2c <shell_telnet_fprintf+0x3d0>
40005e00:	00800593          	li	a1,8
40005e04:	00040513          	mv	a0,s0
40005e08:	ea9ff0ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
40005e0c:	00148493          	addi	s1,s1,1
40005e10:	01000793          	li	a5,16
40005e14:	00f48e63          	beq	s1,a5,40005e30 <shell_hexdump_line+0xc8>
		if (i > 0 && !(i % 8)) {
40005e18:	0074f793          	andi	a5,s1,7
40005e1c:	fc0796e3          	bnez	a5,40005de8 <shell_hexdump_line+0x80>
40005e20:	fb5ff06f          	j	40005dd4 <shell_hexdump_line+0x6c>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
40005e24:	00000493          	li	s1,0
		if (i < len) {
40005e28:	00000793          	li	a5,0
40005e2c:	fc5ff06f          	j	40005df0 <shell_hexdump_line+0x88>
	shell_fprintf(sh, SHELL_NORMAL, "|");
40005e30:	4002d637          	lui	a2,0x4002d
40005e34:	a3460613          	addi	a2,a2,-1484 # 4002ca34 <shell_telnet_fprintf+0x3d8>
40005e38:	00800593          	li	a1,8
40005e3c:	00040513          	mv	a0,s0
40005e40:	e71ff0ef          	jal	ra,40005cb0 <shell_fprintf>
		if (i < len) {
40005e44:	02091e63          	bnez	s2,40005e80 <shell_hexdump_line+0x118>
			shell_fprintf(sh, SHELL_NORMAL, " ");
40005e48:	4002e637          	lui	a2,0x4002e
40005e4c:	6e060613          	addi	a2,a2,1760 # 4002e6e0 <CSWTCH.14405+0x1104>
40005e50:	00800593          	li	a1,8
40005e54:	00040513          	mv	a0,s0
40005e58:	e59ff0ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
40005e5c:	00100493          	li	s1,1
		if (i < len) {
40005e60:	00048793          	mv	a5,s1
40005e64:	0324e263          	bltu	s1,s2,40005e88 <shell_hexdump_line+0x120>
			shell_fprintf(sh, SHELL_NORMAL, " ");
40005e68:	4002e637          	lui	a2,0x4002e
40005e6c:	6e060613          	addi	a2,a2,1760 # 4002e6e0 <CSWTCH.14405+0x1104>
40005e70:	00800593          	li	a1,8
40005e74:	00040513          	mv	a0,s0
40005e78:	e39ff0ef          	jal	ra,40005cb0 <shell_fprintf>
40005e7c:	0380006f          	j	40005eb4 <shell_hexdump_line+0x14c>
		if (i < len) {
40005e80:	00000493          	li	s1,0
40005e84:	00000793          	li	a5,0
			char c = data[i];
40005e88:	00f987b3          	add	a5,s3,a5
40005e8c:	0007c683          	lbu	a3,0(a5)
			shell_fprintf(sh, SHELL_NORMAL, "%c",
40005e90:	05e00793          	li	a5,94
	return (int)((((unsigned)c) >= ' ') &&
40005e94:	fe068713          	addi	a4,a3,-32
40005e98:	00e7f463          	bgeu	a5,a4,40005ea0 <shell_hexdump_line+0x138>
40005e9c:	02e00693          	li	a3,46
40005ea0:	4002d637          	lui	a2,0x4002d
40005ea4:	a7860613          	addi	a2,a2,-1416 # 4002ca78 <_shell_help+0x18>
40005ea8:	00800593          	li	a1,8
40005eac:	00040513          	mv	a0,s0
40005eb0:	e01ff0ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
40005eb4:	00148493          	addi	s1,s1,1
40005eb8:	01000793          	li	a5,16
40005ebc:	02f48263          	beq	s1,a5,40005ee0 <shell_hexdump_line+0x178>
		if (i > 0 && !(i % 8)) {
40005ec0:	0074f793          	andi	a5,s1,7
40005ec4:	f8079ee3          	bnez	a5,40005e60 <shell_hexdump_line+0xf8>
			shell_fprintf(sh, SHELL_NORMAL, " ");
40005ec8:	4002e637          	lui	a2,0x4002e
40005ecc:	6e060613          	addi	a2,a2,1760 # 4002e6e0 <CSWTCH.14405+0x1104>
40005ed0:	00800593          	li	a1,8
40005ed4:	00040513          	mv	a0,s0
40005ed8:	dd9ff0ef          	jal	ra,40005cb0 <shell_fprintf>
40005edc:	f85ff06f          	j	40005e60 <shell_hexdump_line+0xf8>
	shell_print(sh, "|");
40005ee0:	00040513          	mv	a0,s0
}
40005ee4:	01812403          	lw	s0,24(sp)
40005ee8:	01c12083          	lw	ra,28(sp)
40005eec:	01412483          	lw	s1,20(sp)
40005ef0:	01012903          	lw	s2,16(sp)
40005ef4:	00c12983          	lw	s3,12(sp)
	shell_print(sh, "|");
40005ef8:	4002d637          	lui	a2,0x4002d
40005efc:	a3860613          	addi	a2,a2,-1480 # 4002ca38 <shell_telnet_fprintf+0x3dc>
40005f00:	00800593          	li	a1,8
}
40005f04:	02010113          	addi	sp,sp,32
	shell_print(sh, "|");
40005f08:	da9ff06f          	j	40005cb0 <shell_fprintf>

40005f0c <shell_hexdump>:
{
40005f0c:	fe010113          	addi	sp,sp,-32
40005f10:	00812c23          	sw	s0,24(sp)
40005f14:	00912a23          	sw	s1,20(sp)
40005f18:	01212823          	sw	s2,16(sp)
40005f1c:	01412423          	sw	s4,8(sp)
40005f20:	01512223          	sw	s5,4(sp)
40005f24:	00112e23          	sw	ra,28(sp)
40005f28:	01312623          	sw	s3,12(sp)
40005f2c:	00050a13          	mv	s4,a0
40005f30:	00058913          	mv	s2,a1
40005f34:	00060413          	mv	s0,a2
	const uint8_t *p = data;
40005f38:	00058493          	mv	s1,a1
		line_len = MIN(len, SHELL_HEXDUMP_BYTES_IN_LINE);
40005f3c:	01000a93          	li	s5,16
	while (len) {
40005f40:	02041463          	bnez	s0,40005f68 <shell_hexdump+0x5c>
}
40005f44:	01c12083          	lw	ra,28(sp)
40005f48:	01812403          	lw	s0,24(sp)
40005f4c:	01412483          	lw	s1,20(sp)
40005f50:	01012903          	lw	s2,16(sp)
40005f54:	00c12983          	lw	s3,12(sp)
40005f58:	00812a03          	lw	s4,8(sp)
40005f5c:	00412a83          	lw	s5,4(sp)
40005f60:	02010113          	addi	sp,sp,32
40005f64:	00008067          	ret
		line_len = MIN(len, SHELL_HEXDUMP_BYTES_IN_LINE);
40005f68:	00040993          	mv	s3,s0
40005f6c:	008af463          	bgeu	s5,s0,40005f74 <shell_hexdump+0x68>
40005f70:	01000993          	li	s3,16
		shell_hexdump_line(sh, p - data, p, line_len);
40005f74:	00048613          	mv	a2,s1
40005f78:	412485b3          	sub	a1,s1,s2
40005f7c:	00098693          	mv	a3,s3
40005f80:	000a0513          	mv	a0,s4
40005f84:	de5ff0ef          	jal	ra,40005d68 <shell_hexdump_line>
		len -= line_len;
40005f88:	41340433          	sub	s0,s0,s3
		p += line_len;
40005f8c:	013484b3          	add	s1,s1,s3
40005f90:	fb1ff06f          	j	40005f40 <shell_hexdump+0x34>

40005f94 <shell_get_return_value>:
	if (sh == NULL) {
40005f94:	00050863          	beqz	a0,40005fa4 <shell_get_return_value+0x10>
	return sh->ctx->ret_val;
40005f98:	00852783          	lw	a5,8(a0)
40005f9c:	31c7a503          	lw	a0,796(a5)
	return z_shell_get_return_value(sh);
40005fa0:	00008067          	ret
		return -EINVAL;
40005fa4:	fea00513          	li	a0,-22
}
40005fa8:	00008067          	ret

40005fac <shell_echo_set>:
	if (sh == NULL) {
40005fac:	04050063          	beqz	a0,40005fec <shell_echo_set+0x40>
{
40005fb0:	ff010113          	addi	sp,sp,-16
40005fb4:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, echo, val, ret);
40005fb8:	00852503          	lw	a0,8(a0)
40005fbc:	26c50513          	addi	a0,a0,620
40005fc0:	02058063          	beqz	a1,40005fe0 <shell_echo_set+0x34>
40005fc4:	00200593          	li	a1,2
40005fc8:	eacfe0ef          	jal	ra,40004674 <atomic_or>
}
40005fcc:	00c12083          	lw	ra,12(sp)
40005fd0:	00155513          	srli	a0,a0,0x1
40005fd4:	00157513          	andi	a0,a0,1
40005fd8:	01010113          	addi	sp,sp,16
40005fdc:	00008067          	ret
40005fe0:	ffd00593          	li	a1,-3
40005fe4:	e94fe0ef          	jal	ra,40004678 <atomic_and>
40005fe8:	fe5ff06f          	j	40005fcc <shell_echo_set+0x20>
		return -EINVAL;
40005fec:	fea00513          	li	a0,-22
}
40005ff0:	00008067          	ret

40005ff4 <shell_set_bypass>:
	sh->ctx->bypass = bypass;
40005ff4:	00852783          	lw	a5,8(a0)
40005ff8:	04b7a223          	sw	a1,68(a5)
	if (bypass == NULL) {
40005ffc:	00059463          	bnez	a1,40006004 <shell_set_bypass+0x10>
		cmd_buffer_clear(sh);
40006000:	e58fe06f          	j	40004658 <cmd_buffer_clear>
}
40006004:	00008067          	ret

40006008 <z_shell_fprintf_buffer_flush>:
	}
}


void z_shell_fprintf_buffer_flush(const struct shell_fprintf *sh_fprintf)
{
40006008:	ff010113          	addi	sp,sp,-16
4000600c:	00812423          	sw	s0,8(sp)
40006010:	00112623          	sw	ra,12(sp)
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
40006014:	01052703          	lw	a4,16(a0)
40006018:	00852783          	lw	a5,8(a0)
{
4000601c:	00050413          	mv	s0,a0
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
40006020:	00052583          	lw	a1,0(a0)
40006024:	00072603          	lw	a2,0(a4)
40006028:	00c52503          	lw	a0,12(a0)
4000602c:	000780e7          	jalr	a5
			   sh_fprintf->ctrl_blk->buffer_cnt);
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
40006030:	01042783          	lw	a5,16(s0)
40006034:	0007a023          	sw	zero,0(a5)
}
40006038:	00c12083          	lw	ra,12(sp)
4000603c:	00812403          	lw	s0,8(sp)
40006040:	01010113          	addi	sp,sp,16
40006044:	00008067          	ret

40006048 <z_shell_fprintf_fmt>:
{
40006048:	ff010113          	addi	sp,sp,-16
4000604c:	00812423          	sw	s0,8(sp)
40006050:	00060693          	mv	a3,a2
40006054:	00050413          	mv	s0,a0
40006058:	00058613          	mv	a2,a1
4000605c:	00050593          	mv	a1,a0
40006060:	40006537          	lui	a0,0x40006
40006064:	00000713          	li	a4,0
40006068:	0a450513          	addi	a0,a0,164 # 400060a4 <out_func>
4000606c:	00112623          	sw	ra,12(sp)
40006070:	cd9fb0ef          	jal	ra,40001d48 <z_cbvprintf_impl>
	if (sh_fprintf->ctrl_blk->autoflush) {
40006074:	01042783          	lw	a5,16(s0)
40006078:	0047c783          	lbu	a5,4(a5)
4000607c:	00078c63          	beqz	a5,40006094 <z_shell_fprintf_fmt+0x4c>
		z_shell_fprintf_buffer_flush(sh_fprintf);
40006080:	00040513          	mv	a0,s0
}
40006084:	00812403          	lw	s0,8(sp)
40006088:	00c12083          	lw	ra,12(sp)
4000608c:	01010113          	addi	sp,sp,16
		z_shell_fprintf_buffer_flush(sh_fprintf);
40006090:	f79ff06f          	j	40006008 <z_shell_fprintf_buffer_flush>
}
40006094:	00c12083          	lw	ra,12(sp)
40006098:	00812403          	lw	s0,8(sp)
4000609c:	01010113          	addi	sp,sp,16
400060a0:	00008067          	ret

400060a4 <out_func>:
	if ((sh->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
400060a4:	00c5a783          	lw	a5,12(a1) # 100c <CONFIG_HEAP_MEM_POOL_SIZE+0xc>
{
400060a8:	ff010113          	addi	sp,sp,-16
400060ac:	00812423          	sw	s0,8(sp)
400060b0:	00912223          	sw	s1,4(sp)
400060b4:	00112623          	sw	ra,12(sp)
	if ((sh->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
400060b8:	0107a703          	lw	a4,16(a5)
400060bc:	00200793          	li	a5,2
{
400060c0:	00050493          	mv	s1,a0
400060c4:	00058413          	mv	s0,a1
	if ((sh->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
400060c8:	00f71a63          	bne	a4,a5,400060dc <out_func+0x38>
400060cc:	00a00793          	li	a5,10
400060d0:	00f51663          	bne	a0,a5,400060dc <out_func+0x38>
		(void)out_func('\r', ctx);
400060d4:	00d00513          	li	a0,13
400060d8:	fcdff0ef          	jal	ra,400060a4 <out_func>
	sh_fprintf->buffer[sh_fprintf->ctrl_blk->buffer_cnt] = (uint8_t)c;
400060dc:	01042703          	lw	a4,16(s0)
400060e0:	00042783          	lw	a5,0(s0)
400060e4:	00072703          	lw	a4,0(a4)
400060e8:	00e787b3          	add	a5,a5,a4
400060ec:	00978023          	sb	s1,0(a5)
	sh_fprintf->ctrl_blk->buffer_cnt++;
400060f0:	01042703          	lw	a4,16(s0)
400060f4:	00072783          	lw	a5,0(a4)
400060f8:	00178793          	addi	a5,a5,1
400060fc:	00f72023          	sw	a5,0(a4)
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
40006100:	01042783          	lw	a5,16(s0)
40006104:	0007a703          	lw	a4,0(a5)
40006108:	00442783          	lw	a5,4(s0)
4000610c:	00f71663          	bne	a4,a5,40006118 <out_func+0x74>
		z_shell_fprintf_buffer_flush(sh_fprintf);
40006110:	00040513          	mv	a0,s0
40006114:	ef5ff0ef          	jal	ra,40006008 <z_shell_fprintf_buffer_flush>
}
40006118:	00c12083          	lw	ra,12(sp)
4000611c:	00812403          	lw	s0,8(sp)
40006120:	00412483          	lw	s1,4(sp)
40006124:	00000513          	li	a0,0
40006128:	01010113          	addi	sp,sp,16
4000612c:	00008067          	ret

40006130 <isspace>:
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
40006130:	02000793          	li	a5,32
40006134:	00f50863          	beq	a0,a5,40006144 <isspace+0x14>
40006138:	ff750513          	addi	a0,a0,-9
4000613c:	00553513          	sltiu	a0,a0,5
40006140:	00008067          	ret
40006144:	00100513          	li	a0,1
}
40006148:	00008067          	ret

4000614c <z_shell_strlen>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
4000614c:	02050263          	beqz	a0,40006170 <z_shell_strlen+0x24>
{
40006150:	ff010113          	addi	sp,sp,-16
40006154:	00112623          	sw	ra,12(sp)
	return str == NULL ? 0U : (uint16_t)strlen(str);
40006158:	5d1020ef          	jal	ra,40008f28 <strlen>
}
4000615c:	00c12083          	lw	ra,12(sp)
	return str == NULL ? 0U : (uint16_t)strlen(str);
40006160:	01051513          	slli	a0,a0,0x10
40006164:	01055513          	srli	a0,a0,0x10
}
40006168:	01010113          	addi	sp,sp,16
4000616c:	00008067          	ret
	return str == NULL ? 0U : (uint16_t)strlen(str);
40006170:	00000513          	li	a0,0
}
40006174:	00008067          	ret

40006178 <z_column_span_with_buffer_offsets_get>:
/* Calculates column number of given position in buffer */
static uint32_t col_num_with_buffer_offset_get(struct shell_multiline_cons *cons,
					    uint16_t buffer_pos)
{
	/* columns are counted from 1 */
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
40006178:	00c54703          	lbu	a4,12(a0)
4000617c:	00a55783          	lhu	a5,10(a0)
40006180:	00e585b3          	add	a1,a1,a4
40006184:	00e60533          	add	a0,a2,a4
40006188:	02f56533          	rem	a0,a0,a5
4000618c:	02f5e5b3          	rem	a1,a1,a5
					      uint16_t offset1,
					      uint16_t offset2)
{
	return col_num_with_buffer_offset_get(cons, offset2)
			- col_num_with_buffer_offset_get(cons, offset1);
}
40006190:	40b50533          	sub	a0,a0,a1
40006194:	00008067          	ret

40006198 <z_row_span_with_buffer_offsets_get>:
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
40006198:	00c54703          	lbu	a4,12(a0)
4000619c:	00a55783          	lhu	a5,10(a0)
400061a0:	00e585b3          	add	a1,a1,a4
400061a4:	00e60533          	add	a0,a2,a4
400061a8:	02f54533          	div	a0,a0,a5
400061ac:	02f5c5b3          	div	a1,a1,a5
					   uint16_t offset1,
					   uint16_t offset2)
{
	return line_num_with_buffer_offset_get(cons, offset2)
		- line_num_with_buffer_offset_get(cons, offset1);
}
400061b0:	40b50533          	sub	a0,a0,a1
400061b4:	00008067          	ret

400061b8 <z_shell_multiline_data_calc>:
				 uint16_t buff_pos, uint16_t buff_len)
{
	/* Current cursor position in command.
	 * +1 -> because home position is (1, 1)
	 */
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
400061b8:	00c54683          	lbu	a3,12(a0)
400061bc:	00a55783          	lhu	a5,10(a0)
400061c0:	00d585b3          	add	a1,a1,a3
400061c4:	02f5e733          	rem	a4,a1,a5
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;

	/* Extreme position when cursor is at the end of command. */
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
400061c8:	00d60633          	add	a2,a2,a3
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
400061cc:	00170713          	addi	a4,a4,1
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
400061d0:	02f5c5b3          	div	a1,a1,a5
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
400061d4:	00e51023          	sh	a4,0(a0)
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
400061d8:	02f64733          	div	a4,a2,a5
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
400061dc:	00158593          	addi	a1,a1,1
400061e0:	00b51223          	sh	a1,4(a0)
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
400061e4:	02f66633          	rem	a2,a2,a5
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
400061e8:	00170713          	addi	a4,a4,1
400061ec:	00e51323          	sh	a4,6(a0)
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
400061f0:	00160613          	addi	a2,a2,1
400061f4:	00c51123          	sh	a2,2(a0)
}
400061f8:	00008067          	ret

400061fc <z_shell_make_argv>:
}


char z_shell_make_argv(size_t *argc, const char **argv, char *cmd,
		       uint8_t max_argc)
{
400061fc:	fb010113          	addi	sp,sp,-80
40006200:	04812423          	sw	s0,72(sp)
40006204:	05212023          	sw	s2,64(sp)
40006208:	03312e23          	sw	s3,60(sp)
4000620c:	03512a23          	sw	s5,52(sp)
40006210:	03612823          	sw	s6,48(sp)
40006214:	03712623          	sw	s7,44(sp)
40006218:	04112623          	sw	ra,76(sp)
4000621c:	04912223          	sw	s1,68(sp)
40006220:	03412c23          	sw	s4,56(sp)
40006224:	03812423          	sw	s8,40(sp)
40006228:	03912223          	sw	s9,36(sp)
4000622c:	03a12023          	sw	s10,32(sp)
40006230:	01b12e23          	sw	s11,28(sp)
40006234:	00050993          	mv	s3,a0
40006238:	00b12423          	sw	a1,8(sp)
4000623c:	00060413          	mv	s0,a2
40006240:	00068a93          	mv	s5,a3
	char quote = 0;
	char c;

	*argc = 0;
40006244:	00052023          	sw	zero,0(a0)
	char quote = 0;
40006248:	00000913          	li	s2,0
			switch (c) {
4000624c:	05c00b13          	li	s6,92
40006250:	02200b93          	li	s7,34
	do {
		c = *cmd;
40006254:	00044503          	lbu	a0,0(s0)
		if (c == '\0') {
40006258:	28050463          	beqz	a0,400064e0 <z_shell_make_argv+0x2e4>
			break;
		}

		if (isspace((int) c) != 0) {
4000625c:	ed5ff0ef          	jal	ra,40006130 <isspace>
40006260:	00050c63          	beqz	a0,40006278 <z_shell_make_argv+0x7c>
			*cmd++ = '\0';
40006264:	00040023          	sb	zero,0(s0)
40006268:	00140413          	addi	s0,s0,1
			continue;
4000626c:	fe9ff06f          	j	40006254 <z_shell_make_argv+0x58>
40006270:	00000913          	li	s2,0
40006274:	fe1ff06f          	j	40006254 <z_shell_make_argv+0x58>
		}

		argv[(*argc)++] = cmd;
40006278:	0009a783          	lw	a5,0(s3)
4000627c:	00178713          	addi	a4,a5,1
40006280:	00e9a023          	sw	a4,0(s3)
40006284:	00812703          	lw	a4,8(sp)
40006288:	00279793          	slli	a5,a5,0x2
4000628c:	00f707b3          	add	a5,a4,a5
40006290:	0087a023          	sw	s0,0(a5)
		if (*argc == max_argc) {
40006294:	0009a783          	lw	a5,0(s3)
40006298:	25578463          	beq	a5,s5,400064e0 <z_shell_make_argv+0x2e4>
	char quote = 0;
4000629c:	00000913          	li	s2,0
			switch (c) {
400062a0:	02700c13          	li	s8,39
			if (t == '0') {
400062a4:	03000c93          	li	s9,48
			if (t == 'x') {
400062a8:	07800d13          	li	s10,120
		c = *cmd;
400062ac:	00044783          	lbu	a5,0(s0)
		if (c == '\0') {
400062b0:	fa0782e3          	beqz	a5,40006254 <z_shell_make_argv+0x58>
		if (!quote) {
400062b4:	02091e63          	bnez	s2,400062f0 <z_shell_make_argv+0xf4>
		c = *cmd;
400062b8:	00078913          	mv	s2,a5
		if (c == '\0') {
400062bc:	00040793          	mv	a5,s0
400062c0:	00078413          	mv	s0,a5
			switch (c) {
400062c4:	01890663          	beq	s2,s8,400062d0 <z_shell_make_argv+0xd4>
400062c8:	05690e63          	beq	s2,s6,40006324 <z_shell_make_argv+0x128>
400062cc:	1f791a63          	bne	s2,s7,400064c0 <z_shell_make_argv+0x2c4>
						z_shell_strlen(cmd));
400062d0:	00040513          	mv	a0,s0
400062d4:	e79ff0ef          	jal	ra,4000614c <z_shell_strlen>
400062d8:	00050613          	mv	a2,a0
				memmove(cmd, cmd + 1,
400062dc:	00140593          	addi	a1,s0,1
400062e0:	00040513          	mv	a0,s0
400062e4:	521020ef          	jal	ra,40009004 <memmove>
		c = *cmd;
400062e8:	00044783          	lbu	a5,0(s0)
		if (c == '\0') {
400062ec:	f60784e3          	beqz	a5,40006254 <z_shell_make_argv+0x58>
				cmd += 1;
400062f0:	00040a13          	mv	s4,s0
				memmove(cmd, cmd + 1,
400062f4:	00140413          	addi	s0,s0,1
		if (quote == c) {
400062f8:	05279c63          	bne	a5,s2,40006350 <z_shell_make_argv+0x154>
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
400062fc:	000a0513          	mv	a0,s4
40006300:	e4dff0ef          	jal	ra,4000614c <z_shell_strlen>
40006304:	00050613          	mv	a2,a0
40006308:	00040593          	mv	a1,s0
4000630c:	000a0513          	mv	a0,s4
40006310:	4f5020ef          	jal	ra,40009004 <memmove>
		c = *cmd;
40006314:	000a4903          	lbu	s2,0(s4)
		if (c == '\0') {
40006318:	000a0413          	mv	s0,s4
4000631c:	fa0910e3          	bnez	s2,400062bc <z_shell_make_argv+0xc0>
40006320:	f35ff06f          	j	40006254 <z_shell_make_argv+0x58>
						z_shell_strlen(cmd));
40006324:	00040513          	mv	a0,s0
40006328:	e25ff0ef          	jal	ra,4000614c <z_shell_strlen>
				memmove(cmd, cmd + 1,
4000632c:	00140493          	addi	s1,s0,1
						z_shell_strlen(cmd));
40006330:	00050613          	mv	a2,a0
				memmove(cmd, cmd + 1,
40006334:	00048593          	mv	a1,s1
40006338:	00040513          	mv	a0,s0
4000633c:	4c9020ef          	jal	ra,40009004 <memmove>
		c = *cmd;
40006340:	00144903          	lbu	s2,1(s0)
				cmd += 1;
40006344:	00048413          	mv	s0,s1
		if (c == '\0') {
40006348:	f6091ee3          	bnez	s2,400062c4 <z_shell_make_argv+0xc8>
4000634c:	f09ff06f          	j	40006254 <z_shell_make_argv+0x58>
		if (quote && c == '\\') {
40006350:	001a4703          	lbu	a4,1(s4)
40006354:	15679e63          	bne	a5,s6,400064b0 <z_shell_make_argv+0x2b4>
			char t = *(cmd + 1);
40006358:	00070593          	mv	a1,a4
			if (t == quote) {
4000635c:	03271063          	bne	a4,s2,4000637c <z_shell_make_argv+0x180>
						z_shell_strlen(cmd));
40006360:	000a0513          	mv	a0,s4
40006364:	de9ff0ef          	jal	ra,4000614c <z_shell_strlen>
40006368:	00050613          	mv	a2,a0
				memmove(cmd, cmd + 1,
4000636c:	00040593          	mv	a1,s0
40006370:	000a0513          	mv	a0,s4
40006374:	491020ef          	jal	ra,40009004 <memmove>
				continue;
40006378:	f35ff06f          	j	400062ac <z_shell_make_argv+0xb0>
			if (t == '0') {
4000637c:	09971063          	bne	a4,s9,400063fc <z_shell_make_argv+0x200>
40006380:	00200613          	li	a2,2
				uint8_t v = 0U;
40006384:	00000493          	li	s1,0
					if (t >= '0' && t <= '7') {
40006388:	00700813          	li	a6,7
				for (i = 2U; i < (2 + 3); i++) {
4000638c:	00500513          	li	a0,5
					t = *(cmd + i);
40006390:	00ca07b3          	add	a5,s4,a2
40006394:	0007c583          	lbu	a1,0(a5)
					if (t >= '0' && t <= '7') {
40006398:	fd058793          	addi	a5,a1,-48
4000639c:	0ff7f793          	zext.b	a5,a5
400063a0:	04f86863          	bltu	a6,a5,400063f0 <z_shell_make_argv+0x1f4>
						v = (v << 3) | (t - '0');
400063a4:	00349493          	slli	s1,s1,0x3
400063a8:	0ff4f493          	zext.b	s1,s1
				for (i = 2U; i < (2 + 3); i++) {
400063ac:	00160613          	addi	a2,a2,1
						v = (v << 3) | (t - '0');
400063b0:	0097e4b3          	or	s1,a5,s1
				for (i = 2U; i < (2 + 3); i++) {
400063b4:	fca61ee3          	bne	a2,a0,40006390 <z_shell_make_argv+0x194>
400063b8:	00500d93          	li	s11,5
					memmove(cmd, cmd + (i - 1),
400063bc:	fffd8593          	addi	a1,s11,-1
400063c0:	00ba05b3          	add	a1,s4,a1
						z_shell_strlen(cmd) - (i - 2));
400063c4:	000a0513          	mv	a0,s4
					memmove(cmd, cmd + (i - 1),
400063c8:	00b12623          	sw	a1,12(sp)
						z_shell_strlen(cmd) - (i - 2));
400063cc:	d81ff0ef          	jal	ra,4000614c <z_shell_strlen>
400063d0:	ffed8613          	addi	a2,s11,-2
					memmove(cmd, cmd + (i - 1),
400063d4:	40c50633          	sub	a2,a0,a2
					memmove(cmd, cmd + (i - 1),
400063d8:	00c12583          	lw	a1,12(sp)
400063dc:	000a0513          	mv	a0,s4
400063e0:	425020ef          	jal	ra,40009004 <memmove>
		c = *cmd;
400063e4:	001a4783          	lbu	a5,1(s4)
					*cmd++ = v;
400063e8:	009a0023          	sb	s1,0(s4)
		if (c == '\0') {
400063ec:	f01ff06f          	j	400062ec <z_shell_make_argv+0xf0>
400063f0:	0ff67d93          	zext.b	s11,a2
				if (i > 2) {
400063f4:	00200793          	li	a5,2
400063f8:	fcfd92e3          	bne	s11,a5,400063bc <z_shell_make_argv+0x1c0>
			if (t == 'x') {
400063fc:	0ba59863          	bne	a1,s10,400064ac <z_shell_make_argv+0x2b0>
40006400:	00200613          	li	a2,2
				uint8_t v = 0U;
40006404:	00000493          	li	s1,0
					if (t >= '0' && t <= '9') {
40006408:	00900813          	li	a6,9
				for (i = 2U; i < (2 + 2); i++) {
4000640c:	00200513          	li	a0,2
					t = *(cmd + i);
40006410:	00ca07b3          	add	a5,s4,a2
40006414:	0007c783          	lbu	a5,0(a5)
					if (t >= '0' && t <= '9') {
40006418:	fd078593          	addi	a1,a5,-48
4000641c:	0ff5f593          	zext.b	a1,a1
40006420:	04b86063          	bltu	a6,a1,40006460 <z_shell_make_argv+0x264>
						v = (v << 4) | (t - '0');
40006424:	00449493          	slli	s1,s1,0x4
40006428:	0ff4f493          	zext.b	s1,s1
4000642c:	0095e4b3          	or	s1,a1,s1
				for (i = 2U; i < (2 + 2); i++) {
40006430:	02a60463          	beq	a2,a0,40006458 <z_shell_make_argv+0x25c>
40006434:	00400d93          	li	s11,4
					memmove(cmd, cmd + (i - 1),
40006438:	fffd8593          	addi	a1,s11,-1
4000643c:	00ba05b3          	add	a1,s4,a1
						z_shell_strlen(cmd) - (i - 2));
40006440:	000a0513          	mv	a0,s4
					memmove(cmd, cmd + (i - 1),
40006444:	00b12623          	sw	a1,12(sp)
						z_shell_strlen(cmd) - (i - 2));
40006448:	ffed8d93          	addi	s11,s11,-2
4000644c:	d01ff0ef          	jal	ra,4000614c <z_shell_strlen>
					memmove(cmd, cmd + (i - 1),
40006450:	41b50633          	sub	a2,a0,s11
40006454:	f85ff06f          	j	400063d8 <z_shell_make_argv+0x1dc>
40006458:	00300613          	li	a2,3
4000645c:	fb5ff06f          	j	40006410 <z_shell_make_argv+0x214>
					} else if ((t >= 'a') &&
40006460:	f9f78593          	addi	a1,a5,-97
40006464:	0ff5f593          	zext.b	a1,a1
40006468:	00500893          	li	a7,5
4000646c:	00b8ee63          	bltu	a7,a1,40006488 <z_shell_make_argv+0x28c>
						v = (v << 4) | (t - 'a' + 10);
40006470:	00449493          	slli	s1,s1,0x4
40006474:	0ff4f493          	zext.b	s1,s1
40006478:	fa978793          	addi	a5,a5,-87
						v = (v << 4) | (t - 'A' + 10);
4000647c:	00f4e4b3          	or	s1,s1,a5
40006480:	0ff4f493          	zext.b	s1,s1
40006484:	fadff06f          	j	40006430 <z_shell_make_argv+0x234>
					} else if ((t >= 'A') && (t <= 'F')) {
40006488:	fbf78593          	addi	a1,a5,-65
4000648c:	0ff5f593          	zext.b	a1,a1
40006490:	00b8ea63          	bltu	a7,a1,400064a4 <z_shell_make_argv+0x2a8>
						v = (v << 4) | (t - 'A' + 10);
40006494:	00449493          	slli	s1,s1,0x4
40006498:	0ff4f493          	zext.b	s1,s1
4000649c:	fc978793          	addi	a5,a5,-55
400064a0:	fddff06f          	j	4000647c <z_shell_make_argv+0x280>
				if (i > 2) {
400064a4:	00200793          	li	a5,2
400064a8:	00f61863          	bne	a2,a5,400064b8 <z_shell_make_argv+0x2bc>
		cmd += 1;
400064ac:	001a0413          	addi	s0,s4,1
		c = *cmd;
400064b0:	00070793          	mv	a5,a4
		if (c == '\0') {
400064b4:	e39ff06f          	j	400062ec <z_shell_make_argv+0xf0>
400064b8:	00300d93          	li	s11,3
400064bc:	f7dff06f          	j	40006438 <z_shell_make_argv+0x23c>
		if (!quote && isspace((int) c) != 0) {
400064c0:	00090513          	mv	a0,s2
400064c4:	c6dff0ef          	jal	ra,40006130 <isspace>
400064c8:	da0514e3          	bnez	a0,40006270 <z_shell_make_argv+0x74>
		c = *cmd;
400064cc:	00144903          	lbu	s2,1(s0)
		cmd += 1;
400064d0:	00140793          	addi	a5,s0,1
		if (c == '\0') {
400064d4:	de0916e3          	bnez	s2,400062c0 <z_shell_make_argv+0xc4>
		cmd += 1;
400064d8:	00078413          	mv	s0,a5
400064dc:	d79ff06f          	j	40006254 <z_shell_make_argv+0x58>
		}
		quote = make_argv(&cmd, c);
	} while (true);

	return quote;
}
400064e0:	04c12083          	lw	ra,76(sp)
400064e4:	04812403          	lw	s0,72(sp)
400064e8:	04412483          	lw	s1,68(sp)
400064ec:	03c12983          	lw	s3,60(sp)
400064f0:	03812a03          	lw	s4,56(sp)
400064f4:	03412a83          	lw	s5,52(sp)
400064f8:	03012b03          	lw	s6,48(sp)
400064fc:	02c12b83          	lw	s7,44(sp)
40006500:	02812c03          	lw	s8,40(sp)
40006504:	02412c83          	lw	s9,36(sp)
40006508:	02012d03          	lw	s10,32(sp)
4000650c:	01c12d83          	lw	s11,28(sp)
40006510:	00090513          	mv	a0,s2
40006514:	04012903          	lw	s2,64(sp)
40006518:	05010113          	addi	sp,sp,80
4000651c:	00008067          	ret

40006520 <z_shell_pattern_remove>:

void z_shell_pattern_remove(char *buff, uint16_t *buff_len, const char *pattern)
{
40006520:	fe010113          	addi	sp,sp,-32
40006524:	01212823          	sw	s2,16(sp)
40006528:	00058913          	mv	s2,a1
	char *pattern_addr = strstr(buff, pattern);
4000652c:	00060593          	mv	a1,a2
{
40006530:	00812c23          	sw	s0,24(sp)
40006534:	00912a23          	sw	s1,20(sp)
40006538:	01312623          	sw	s3,12(sp)
4000653c:	00112e23          	sw	ra,28(sp)
40006540:	00060493          	mv	s1,a2
40006544:	00050993          	mv	s3,a0
	char *pattern_addr = strstr(buff, pattern);
40006548:	0a9020ef          	jal	ra,40008df0 <strstr>
4000654c:	00050413          	mv	s0,a0
	uint16_t shift;
	uint16_t pattern_len = z_shell_strlen(pattern);
40006550:	00048513          	mv	a0,s1
40006554:	bf9ff0ef          	jal	ra,4000614c <z_shell_strlen>

	if (!pattern_addr) {
40006558:	06040863          	beqz	s0,400065c8 <z_shell_pattern_remove+0xa8>
4000655c:	00050493          	mv	s1,a0
		return;
	}

	if (pattern_addr > buff) {
40006560:	0289f063          	bgeu	s3,s0,40006580 <z_shell_pattern_remove+0x60>
		if (*(pattern_addr - 1) == ' ') {
40006564:	fff44703          	lbu	a4,-1(s0)
40006568:	02000793          	li	a5,32
4000656c:	00f71a63          	bne	a4,a5,40006580 <z_shell_pattern_remove+0x60>
			pattern_len++; /* space needs to be removed as well */
40006570:	00150493          	addi	s1,a0,1
40006574:	01049493          	slli	s1,s1,0x10
40006578:	0104d493          	srli	s1,s1,0x10
			pattern_addr--; /* set pointer to space */
4000657c:	fff40413          	addi	s0,s0,-1
		}
	}

	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
40006580:	00040513          	mv	a0,s0
40006584:	bc9ff0ef          	jal	ra,4000614c <z_shell_strlen>
	*buff_len -= pattern_len;
40006588:	00095783          	lhu	a5,0(s2)
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
4000658c:	00150613          	addi	a2,a0,1

	memmove(pattern_addr, pattern_addr + pattern_len, shift);
40006590:	009405b3          	add	a1,s0,s1
	*buff_len -= pattern_len;
40006594:	409787b3          	sub	a5,a5,s1
40006598:	00f91023          	sh	a5,0(s2)
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
4000659c:	00040513          	mv	a0,s0
}
400065a0:	01812403          	lw	s0,24(sp)
400065a4:	01c12083          	lw	ra,28(sp)
400065a8:	01012903          	lw	s2,16(sp)
400065ac:	00c12983          	lw	s3,12(sp)
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
400065b0:	40960633          	sub	a2,a2,s1
}
400065b4:	01412483          	lw	s1,20(sp)
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
400065b8:	01061613          	slli	a2,a2,0x10
400065bc:	01065613          	srli	a2,a2,0x10
}
400065c0:	02010113          	addi	sp,sp,32
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
400065c4:	2410206f          	j	40009004 <memmove>
}
400065c8:	01c12083          	lw	ra,28(sp)
400065cc:	01812403          	lw	s0,24(sp)
400065d0:	01412483          	lw	s1,20(sp)
400065d4:	01012903          	lw	s2,16(sp)
400065d8:	00c12983          	lw	s3,12(sp)
400065dc:	02010113          	addi	sp,sp,32
400065e0:	00008067          	ret

400065e4 <z_shell_cmd_get>:

const struct shell_static_entry *z_shell_cmd_get(
					const struct shell_static_entry *parent,
					size_t idx,
					struct shell_static_entry *dloc)
{
400065e4:	ff010113          	addi	sp,sp,-16
400065e8:	00050793          	mv	a5,a0
400065ec:	00112623          	sw	ra,12(sp)
400065f0:	00812423          	sw	s0,8(sp)
400065f4:	00058513          	mv	a0,a1
	const struct shell_static_entry *res = NULL;

	if (parent == NULL) {
400065f8:	04079063          	bnez	a5,40006638 <z_shell_cmd_get+0x54>
	TYPE_SECTION_COUNT(union shell_cmd_entry, shell_root_cmds, &len);
400065fc:	4002c737          	lui	a4,0x4002c
40006600:	4002c7b7          	lui	a5,0x4002c
40006604:	aa470713          	addi	a4,a4,-1372 # 4002baa4 <shell_cmd_clear>
40006608:	acc78793          	addi	a5,a5,-1332 # 4002bacc <z_shell_subcmd_end_marker>
4000660c:	40e787b3          	sub	a5,a5,a4
40006610:	0027d793          	srli	a5,a5,0x2
		return  (idx < shell_root_cmd_count()) ?
				shell_root_cmd_get(idx)->entry : NULL;
40006614:	02f5f663          	bgeu	a1,a5,40006640 <z_shell_cmd_get+0x5c>
40006618:	00259513          	slli	a0,a1,0x2
4000661c:	00a70733          	add	a4,a4,a0
40006620:	00072403          	lw	s0,0(a4)
			}
		}
	}

	return res;
}
40006624:	00c12083          	lw	ra,12(sp)
40006628:	00040513          	mv	a0,s0
4000662c:	00812403          	lw	s0,8(sp)
40006630:	01010113          	addi	sp,sp,16
40006634:	00008067          	ret
	if (parent->subcmd) {
40006638:	0087a783          	lw	a5,8(a5)
4000663c:	00079663          	bnez	a5,40006648 <z_shell_cmd_get+0x64>
	const struct shell_static_entry *res = NULL;
40006640:	00000413          	li	s0,0
40006644:	fe1ff06f          	j	40006624 <z_shell_cmd_get+0x40>
	return (entry >= TYPE_SECTION_START(shell_dynamic_subcmds)) &&
40006648:	4002c737          	lui	a4,0x4002c
4000664c:	ae070713          	addi	a4,a4,-1312 # 4002bae0 <iface_index>
40006650:	02e7e663          	bltu	a5,a4,4000667c <z_shell_cmd_get+0x98>
40006654:	4002c737          	lui	a4,0x4002c
40006658:	ae870713          	addi	a4,a4,-1304 # 4002bae8 <sub_kernel>
4000665c:	02e7f063          	bgeu	a5,a4,4000667c <z_shell_cmd_get+0x98>
			parent->subcmd->dynamic_get(idx, dloc);
40006660:	0007a783          	lw	a5,0(a5)
40006664:	00060593          	mv	a1,a2
40006668:	00060413          	mv	s0,a2
4000666c:	000780e7          	jalr	a5
			if (entry_list[idx].syntax != NULL) {
40006670:	00042783          	lw	a5,0(s0)
40006674:	fa0798e3          	bnez	a5,40006624 <z_shell_cmd_get+0x40>
40006678:	fc9ff06f          	j	40006640 <z_shell_cmd_get+0x5c>
	return (entry >= TYPE_SECTION_START(shell_subcmds)) &&
4000667c:	4002c737          	lui	a4,0x4002c
40006680:	acc70713          	addi	a4,a4,-1332 # 4002bacc <z_shell_subcmd_end_marker>
40006684:	00e7e863          	bltu	a5,a4,40006694 <z_shell_cmd_get+0xb0>
40006688:	4002c737          	lui	a4,0x4002c
4000668c:	ae070713          	addi	a4,a4,-1312 # 4002bae0 <iface_index>
40006690:	00e7ec63          	bltu	a5,a4,400066a8 <z_shell_cmd_get+0xc4>
				entry_list = parent->subcmd->entry;
40006694:	0007a783          	lw	a5,0(a5)
			if (entry_list[idx].syntax != NULL) {
40006698:	01400713          	li	a4,20
4000669c:	02e50533          	mul	a0,a0,a4
400066a0:	00a78433          	add	s0,a5,a0
400066a4:	fcdff06f          	j	40006670 <z_shell_cmd_get+0x8c>
				idx++;
400066a8:	00150513          	addi	a0,a0,1
400066ac:	fedff06f          	j	40006698 <z_shell_cmd_get+0xb4>

400066b0 <z_shell_find_cmd>:
 */
const struct shell_static_entry *z_shell_find_cmd(
					const struct shell_static_entry *parent,
					const char *cmd_str,
					struct shell_static_entry *dloc)
{
400066b0:	fc010113          	addi	sp,sp,-64
400066b4:	02812c23          	sw	s0,56(sp)
400066b8:	03312623          	sw	s3,44(sp)
400066bc:	03412423          	sw	s4,40(sp)
400066c0:	02112e23          	sw	ra,60(sp)
400066c4:	02912a23          	sw	s1,52(sp)
400066c8:	03212823          	sw	s2,48(sp)
400066cc:	00050413          	mv	s0,a0
400066d0:	00058a13          	mv	s4,a1
400066d4:	00060993          	mv	s3,a2
	 * dynamic commands at the same time (current and subcommand) they
	 * will operate on the same memory region what can cause undefined
	 * behaviour.
	 * Hence we need a separate memory for each of them.
	 */
	if (parent) {
400066d8:	00050c63          	beqz	a0,400066f0 <z_shell_find_cmd+0x40>
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
400066dc:	00050593          	mv	a1,a0
400066e0:	01400613          	li	a2,20
400066e4:	00c10513          	addi	a0,sp,12
400066e8:	165020ef          	jal	ra,4000904c <memcpy>
		parent = &parent_cpy;
400066ec:	00c10413          	addi	s0,sp,12
400066f0:	00000913          	li	s2,0
	}

	while ((entry = z_shell_cmd_get(parent, idx++, dloc)) != NULL) {
400066f4:	00090593          	mv	a1,s2
400066f8:	00098613          	mv	a2,s3
400066fc:	00040513          	mv	a0,s0
40006700:	ee5ff0ef          	jal	ra,400065e4 <z_shell_cmd_get>
40006704:	00190913          	addi	s2,s2,1
40006708:	00050493          	mv	s1,a0
4000670c:	00050a63          	beqz	a0,40006720 <z_shell_find_cmd+0x70>
		if (strcmp(cmd_str, entry->syntax) == 0) {
40006710:	0004a583          	lw	a1,0(s1)
40006714:	000a0513          	mv	a0,s4
40006718:	055020ef          	jal	ra,40008f6c <strcmp>
4000671c:	fc051ce3          	bnez	a0,400066f4 <z_shell_find_cmd+0x44>
			return entry;
		}
	}

	return NULL;
}
40006720:	03c12083          	lw	ra,60(sp)
40006724:	03812403          	lw	s0,56(sp)
40006728:	03012903          	lw	s2,48(sp)
4000672c:	02c12983          	lw	s3,44(sp)
40006730:	02812a03          	lw	s4,40(sp)
40006734:	00048513          	mv	a0,s1
40006738:	03412483          	lw	s1,52(sp)
4000673c:	04010113          	addi	sp,sp,64
40006740:	00008067          	ret

40006744 <z_shell_get_last_command>:
					size_t argc,
					const char *argv[],
					size_t *match_arg,
					struct shell_static_entry *dloc,
					bool only_static)
{
40006744:	fe010113          	addi	sp,sp,-32
40006748:	00812c23          	sw	s0,24(sp)
4000674c:	01212823          	sw	s2,16(sp)
40006750:	01312623          	sw	s3,12(sp)
40006754:	01412423          	sw	s4,8(sp)
40006758:	01512223          	sw	s5,4(sp)
4000675c:	00112e23          	sw	ra,28(sp)
40006760:	00912a23          	sw	s1,20(sp)
40006764:	00058a13          	mv	s4,a1
40006768:	00060913          	mv	s2,a2
4000676c:	00068413          	mv	s0,a3
40006770:	00070993          	mv	s3,a4
40006774:	00078a93          	mv	s5,a5
	const struct shell_static_entry *prev_entry = NULL;

	*match_arg = Z_SHELL_CMD_ROOT_LVL;
40006778:	0006a023          	sw	zero,0(a3)

	while (*match_arg < argc) {
4000677c:	00042783          	lw	a5,0(s0)

		if (IS_ENABLED(CONFIG_SHELL_WILDCARD)) {
			/* ignore wildcard argument */
			if (z_shell_has_wildcard(argv[*match_arg])) {
				(*match_arg)++;
				continue;
40006780:	00050493          	mv	s1,a0
	while (*match_arg < argc) {
40006784:	0747f263          	bgeu	a5,s4,400067e8 <z_shell_get_last_command+0xa4>
			if (z_shell_has_wildcard(argv[*match_arg])) {
40006788:	00279793          	slli	a5,a5,0x2
4000678c:	00f907b3          	add	a5,s2,a5
40006790:	0007a503          	lw	a0,0(a5)
40006794:	701010ef          	jal	ra,40008694 <z_shell_has_wildcard>
40006798:	00042683          	lw	a3,0(s0)
4000679c:	00050a63          	beqz	a0,400067b0 <z_shell_get_last_command+0x6c>
				(*match_arg)++;
400067a0:	00168693          	addi	a3,a3,1
400067a4:	00d42023          	sw	a3,0(s0)
				continue;
400067a8:	00048513          	mv	a0,s1
400067ac:	fd1ff06f          	j	4000677c <z_shell_get_last_command+0x38>
			}
		}

		prev_entry = entry;
		entry = z_shell_find_cmd(entry, argv[*match_arg], dloc);
400067b0:	00269693          	slli	a3,a3,0x2
400067b4:	00d906b3          	add	a3,s2,a3
400067b8:	0006a583          	lw	a1,0(a3)
400067bc:	00098613          	mv	a2,s3
400067c0:	00048513          	mv	a0,s1
400067c4:	eedff0ef          	jal	ra,400066b0 <z_shell_find_cmd>
		if (entry) {
400067c8:	02050063          	beqz	a0,400067e8 <z_shell_get_last_command+0xa4>
			(*match_arg)++;
400067cc:	00042783          	lw	a5,0(s0)
400067d0:	00178713          	addi	a4,a5,1
400067d4:	00e42023          	sw	a4,0(s0)
		} else {
			entry = prev_entry;
			break;
		}

		if (only_static && (entry == dloc)) {
400067d8:	fa0a82e3          	beqz	s5,4000677c <z_shell_get_last_command+0x38>
400067dc:	faa990e3          	bne	s3,a0,4000677c <z_shell_get_last_command+0x38>
			(*match_arg)--;
400067e0:	00f42023          	sw	a5,0(s0)
			return NULL;
400067e4:	00000493          	li	s1,0
		}
	}

	return entry;
}
400067e8:	01c12083          	lw	ra,28(sp)
400067ec:	01812403          	lw	s0,24(sp)
400067f0:	01012903          	lw	s2,16(sp)
400067f4:	00c12983          	lw	s3,12(sp)
400067f8:	00812a03          	lw	s4,8(sp)
400067fc:	00412a83          	lw	s5,4(sp)
40006800:	00048513          	mv	a0,s1
40006804:	01412483          	lw	s1,20(sp)
40006808:	02010113          	addi	sp,sp,32
4000680c:	00008067          	ret

40006810 <z_shell_spaces_trim>:




void z_shell_spaces_trim(char *str)
{
40006810:	fd010113          	addi	sp,sp,-48
40006814:	01412c23          	sw	s4,24(sp)
40006818:	00050a13          	mv	s4,a0
4000681c:	02112623          	sw	ra,44(sp)
40006820:	02812423          	sw	s0,40(sp)
40006824:	02912223          	sw	s1,36(sp)
40006828:	03212023          	sw	s2,32(sp)
4000682c:	01312e23          	sw	s3,28(sp)
40006830:	01512a23          	sw	s5,20(sp)
	uint16_t len = z_shell_strlen(str);
40006834:	919ff0ef          	jal	ra,4000614c <z_shell_strlen>
	uint16_t shift = 0U;

	if (!str) {
40006838:	0c0a1263          	bnez	s4,400068fc <z_shell_spaces_trim+0xec>

				break;
			}
		}
	}
}
4000683c:	02c12083          	lw	ra,44(sp)
40006840:	02812403          	lw	s0,40(sp)
40006844:	02412483          	lw	s1,36(sp)
40006848:	02012903          	lw	s2,32(sp)
4000684c:	01c12983          	lw	s3,28(sp)
40006850:	01812a03          	lw	s4,24(sp)
40006854:	01412a83          	lw	s5,20(sp)
40006858:	03010113          	addi	sp,sp,48
4000685c:	00008067          	ret
		if (isspace((int)str[i]) != 0) {
40006860:	013a07b3          	add	a5,s4,s3
40006864:	0007c503          	lbu	a0,0(a5)
40006868:	00098a93          	mv	s5,s3
			for (uint16_t j = i + 1; j < len; j++) {
4000686c:	00198993          	addi	s3,s3,1
40006870:	01099993          	slli	s3,s3,0x10
40006874:	0109d993          	srli	s3,s3,0x10
		if (isspace((int)str[i]) != 0) {
40006878:	8b9ff0ef          	jal	ra,40006130 <isspace>
4000687c:	00098493          	mv	s1,s3
40006880:	02051c63          	bnez	a0,400068b8 <z_shell_spaces_trim+0xa8>
	for (uint16_t i = 0; i < len - 1; i++) {
40006884:	fff40793          	addi	a5,s0,-1
40006888:	fcf9cce3          	blt	s3,a5,40006860 <z_shell_spaces_trim+0x50>
4000688c:	fb1ff06f          	j	4000683c <z_shell_spaces_trim+0x2c>
				if (isspace((int)str[j]) != 0) {
40006890:	009a05b3          	add	a1,s4,s1
40006894:	0005c503          	lbu	a0,0(a1)
40006898:	00b12623          	sw	a1,12(sp)
4000689c:	895ff0ef          	jal	ra,40006130 <isspace>
400068a0:	00c12583          	lw	a1,12(sp)
400068a4:	02050263          	beqz	a0,400068c8 <z_shell_spaces_trim+0xb8>
					shift++;
400068a8:	00190913          	addi	s2,s2,1
400068ac:	01091913          	slli	s2,s2,0x10
				if (isspace((int)str[j]) != 0) {
400068b0:	00148493          	addi	s1,s1,1
					shift++;
400068b4:	01095913          	srli	s2,s2,0x10
			for (uint16_t j = i + 1; j < len; j++) {
400068b8:	01049793          	slli	a5,s1,0x10
400068bc:	0107d793          	srli	a5,a5,0x10
400068c0:	fc87e8e3          	bltu	a5,s0,40006890 <z_shell_spaces_trim+0x80>
400068c4:	fc1ff06f          	j	40006884 <z_shell_spaces_trim+0x74>
				if (shift > 0) {
400068c8:	fa090ee3          	beqz	s2,40006884 <z_shell_spaces_trim+0x74>
						len - j + 1);
400068cc:	01049613          	slli	a2,s1,0x10
400068d0:	01065613          	srli	a2,a2,0x10
400068d4:	40c40633          	sub	a2,s0,a2
					memmove(&str[i + 1],
400068d8:	001a8513          	addi	a0,s5,1
					len -= shift;
400068dc:	41240433          	sub	s0,s0,s2
					memmove(&str[i + 1],
400068e0:	00160613          	addi	a2,a2,1
400068e4:	00aa0533          	add	a0,s4,a0
					len -= shift;
400068e8:	01041413          	slli	s0,s0,0x10
					memmove(&str[i + 1],
400068ec:	718020ef          	jal	ra,40009004 <memmove>
					len -= shift;
400068f0:	01045413          	srli	s0,s0,0x10
	uint16_t shift = 0U;
400068f4:	00000913          	li	s2,0
400068f8:	f8dff06f          	j	40006884 <z_shell_spaces_trim+0x74>
400068fc:	00050413          	mv	s0,a0
	for (uint16_t i = 0; i < len - 1; i++) {
40006900:	00000993          	li	s3,0
40006904:	ff1ff06f          	j	400068f4 <z_shell_spaces_trim+0xe4>

40006908 <z_shell_cmd_trim>:
		*buff_len = *buff_len - i;
	}
}

void z_shell_cmd_trim(const struct shell *sh)
{
40006908:	fd010113          	addi	sp,sp,-48
4000690c:	03212023          	sw	s2,32(sp)
40006910:	01412c23          	sw	s4,24(sp)
40006914:	02112623          	sw	ra,44(sp)
40006918:	02812423          	sw	s0,40(sp)
4000691c:	02912223          	sw	s1,36(sp)
40006920:	01312e23          	sw	s3,28(sp)
	buffer_trim(sh->ctx->cmd_buff, &sh->ctx->cmd_buff_len);
40006924:	00852403          	lw	s0,8(a0)
{
40006928:	00050913          	mv	s2,a0
	if (buff[0] == '\0') {
4000692c:	04e44783          	lbu	a5,78(s0)
40006930:	04e40a13          	addi	s4,s0,78
40006934:	04079663          	bnez	a5,40006980 <z_shell_cmd_trim+0x78>
	sh->ctx->cmd_buff_pos = sh->ctx->cmd_buff_len;
40006938:	00892783          	lw	a5,8(s2)
4000693c:	0487d703          	lhu	a4,72(a5)
40006940:	04e79523          	sh	a4,74(a5)
}
40006944:	02c12083          	lw	ra,44(sp)
40006948:	02812403          	lw	s0,40(sp)
4000694c:	02412483          	lw	s1,36(sp)
40006950:	02012903          	lw	s2,32(sp)
40006954:	01c12983          	lw	s3,28(sp)
40006958:	01812a03          	lw	s4,24(sp)
4000695c:	03010113          	addi	sp,sp,48
40006960:	00008067          	ret
		*buff_len -= 1U;
40006964:	fff48493          	addi	s1,s1,-1
40006968:	01049493          	slli	s1,s1,0x10
4000696c:	0104d493          	srli	s1,s1,0x10
40006970:	04941423          	sh	s1,72(s0)
		if (*buff_len == 0U) {
40006974:	00049663          	bnez	s1,40006980 <z_shell_cmd_trim+0x78>
			buff[0] = '\0';
40006978:	04040723          	sb	zero,78(s0)
			return;
4000697c:	fbdff06f          	j	40006938 <z_shell_cmd_trim+0x30>
	while (isspace((int) buff[*buff_len - 1U]) != 0) {
40006980:	04845483          	lhu	s1,72(s0)
40006984:	009a09b3          	add	s3,s4,s1
40006988:	fff9c503          	lbu	a0,-1(s3)
4000698c:	fa4ff0ef          	jal	ra,40006130 <isspace>
40006990:	fc051ae3          	bnez	a0,40006964 <z_shell_cmd_trim+0x5c>
	buff[*buff_len] = '\0';
40006994:	00098023          	sb	zero,0(s3)
	uint16_t i = 0U;
40006998:	00000993          	li	s3,0
	while (isspace((int) buff[i++]) != 0) {
4000699c:	00098493          	mv	s1,s3
400069a0:	009a05b3          	add	a1,s4,s1
400069a4:	0005c503          	lbu	a0,0(a1)
400069a8:	00198993          	addi	s3,s3,1
400069ac:	00b12623          	sw	a1,12(sp)
400069b0:	01099993          	slli	s3,s3,0x10
400069b4:	f7cff0ef          	jal	ra,40006130 <isspace>
400069b8:	00c12583          	lw	a1,12(sp)
400069bc:	0109d993          	srli	s3,s3,0x10
400069c0:	fc051ee3          	bnez	a0,4000699c <z_shell_cmd_trim+0x94>
	if (--i > 0) {
400069c4:	f6048ae3          	beqz	s1,40006938 <z_shell_cmd_trim+0x30>
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
400069c8:	04845603          	lhu	a2,72(s0)
400069cc:	000a0513          	mv	a0,s4
400069d0:	00160613          	addi	a2,a2,1
400069d4:	40960633          	sub	a2,a2,s1
400069d8:	62c020ef          	jal	ra,40009004 <memmove>
		*buff_len = *buff_len - i;
400069dc:	04845783          	lhu	a5,72(s0)
400069e0:	409787b3          	sub	a5,a5,s1
400069e4:	04f41423          	sh	a5,72(s0)
400069e8:	f51ff06f          	j	40006938 <z_shell_cmd_trim+0x30>

400069ec <shell_strtoul>:

	return val;
}

unsigned long shell_strtoul(const char *str, int base, int *err)
{
400069ec:	fe010113          	addi	sp,sp,-32
400069f0:	01212823          	sw	s2,16(sp)
400069f4:	00112e23          	sw	ra,28(sp)
400069f8:	00812c23          	sw	s0,24(sp)
400069fc:	00912a23          	sw	s1,20(sp)
	unsigned long val;
	char *endptr = NULL;

	if (*str == '-') {
40006a00:	00054703          	lbu	a4,0(a0)
	char *endptr = NULL;
40006a04:	00012623          	sw	zero,12(sp)
	if (*str == '-') {
40006a08:	02d00793          	li	a5,45
{
40006a0c:	00060913          	mv	s2,a2
	if (*str == '-') {
40006a10:	02f71663          	bne	a4,a5,40006a3c <shell_strtoul+0x50>
		*err = -EINVAL;
		return 0;
40006a14:	fea00793          	li	a5,-22
	}

	errno = 0;
	val = strtoul(str, &endptr, base);
	if (errno == ERANGE) {
		*err = -ERANGE;
40006a18:	00f92023          	sw	a5,0(s2)
		return 0;
40006a1c:	00000493          	li	s1,0
		*err = -EINVAL;
		return 0;
	}

	return val;
}
40006a20:	01c12083          	lw	ra,28(sp)
40006a24:	01812403          	lw	s0,24(sp)
40006a28:	01012903          	lw	s2,16(sp)
40006a2c:	00048513          	mv	a0,s1
40006a30:	01412483          	lw	s1,20(sp)
40006a34:	02010113          	addi	sp,sp,32
40006a38:	00008067          	ret
40006a3c:	00050413          	mv	s0,a0
40006a40:	00058493          	mv	s1,a1
40006a44:	719200ef          	jal	ra,4002795c <z_impl_z_errno>
	val = strtoul(str, &endptr, base);
40006a48:	00048613          	mv	a2,s1
	errno = 0;
40006a4c:	00052023          	sw	zero,0(a0)
	val = strtoul(str, &endptr, base);
40006a50:	00c10593          	addi	a1,sp,12
40006a54:	00040513          	mv	a0,s0
40006a58:	214020ef          	jal	ra,40008c6c <strtoul>
40006a5c:	00050493          	mv	s1,a0
40006a60:	6fd200ef          	jal	ra,4002795c <z_impl_z_errno>
	if (errno == ERANGE) {
40006a64:	00052703          	lw	a4,0(a0)
40006a68:	02200793          	li	a5,34
40006a6c:	00f71663          	bne	a4,a5,40006a78 <shell_strtoul+0x8c>
40006a70:	fde00793          	li	a5,-34
40006a74:	fa5ff06f          	j	40006a18 <shell_strtoul+0x2c>
40006a78:	6e5200ef          	jal	ra,4002795c <z_impl_z_errno>
	} else if (errno || endptr == str || *endptr) {
40006a7c:	00052783          	lw	a5,0(a0)
40006a80:	f8079ae3          	bnez	a5,40006a14 <shell_strtoul+0x28>
40006a84:	00c12783          	lw	a5,12(sp)
40006a88:	f88786e3          	beq	a5,s0,40006a14 <shell_strtoul+0x28>
40006a8c:	0007c783          	lbu	a5,0(a5)
40006a90:	f80788e3          	beqz	a5,40006a20 <shell_strtoul+0x34>
40006a94:	f81ff06f          	j	40006a14 <shell_strtoul+0x28>

40006a98 <z_shell_raw_fprintf>:
{
40006a98:	fc010113          	addi	sp,sp,-64
40006a9c:	02c12423          	sw	a2,40(sp)
	va_start(args, fmt);
40006aa0:	02810613          	addi	a2,sp,40
{
40006aa4:	00112e23          	sw	ra,28(sp)
40006aa8:	02d12623          	sw	a3,44(sp)
40006aac:	02e12823          	sw	a4,48(sp)
40006ab0:	02f12a23          	sw	a5,52(sp)
40006ab4:	03012c23          	sw	a6,56(sp)
40006ab8:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
40006abc:	00c12623          	sw	a2,12(sp)
	z_shell_fprintf_fmt(ctx, fmt, args);
40006ac0:	d88ff0ef          	jal	ra,40006048 <z_shell_fprintf_fmt>
}
40006ac4:	01c12083          	lw	ra,28(sp)
40006ac8:	04010113          	addi	sp,sp,64
40006acc:	00008067          	ret

40006ad0 <z_clear_eos>:
	return sh->ctx->cfg.flags.use_vt100 == 1;
40006ad0:	00852783          	lw	a5,8(a0)
40006ad4:	26c7a783          	lw	a5,620(a5)
40006ad8:	0057d793          	srli	a5,a5,0x5
40006adc:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
40006ae0:	00078a63          	beqz	a5,40006af4 <z_clear_eos+0x24>
40006ae4:	01452503          	lw	a0,20(a0)
40006ae8:	4002c5b7          	lui	a1,0x4002c
40006aec:	bf458593          	addi	a1,a1,-1036 # 4002bbf4 <eth_config+0x1c>
40006af0:	fa9ff06f          	j	40006a98 <z_shell_raw_fprintf>
}
40006af4:	00008067          	ret

40006af8 <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
40006af8:	4002e5b7          	lui	a1,0x4002e
40006afc:	48c58593          	addi	a1,a1,1164 # 4002e48c <CSWTCH.14405+0xeb0>
40006b00:	f99ff06f          	j	40006a98 <z_shell_raw_fprintf>

40006b04 <full_line_cmd>:

/* Function returns true if command length is equal to multiplicity of terminal
 * width.
 */
static inline bool full_line_cmd(const struct shell *sh)
{
40006b04:	ff010113          	addi	sp,sp,-16
40006b08:	00812423          	sw	s0,8(sp)
40006b0c:	00112623          	sw	ra,12(sp)
40006b10:	00912223          	sw	s1,4(sp)
	return ((sh->ctx->cmd_buff_len + z_shell_strlen(sh->ctx->prompt))
40006b14:	00852783          	lw	a5,8(a0)
{
40006b18:	00050413          	mv	s0,a0
	return ((sh->ctx->cmd_buff_len + z_shell_strlen(sh->ctx->prompt))
40006b1c:	0007a503          	lw	a0,0(a5)
40006b20:	0487d483          	lhu	s1,72(a5)
	return str == NULL ? 0U : (uint16_t)strlen(str);
40006b24:	00000793          	li	a5,0
40006b28:	00050863          	beqz	a0,40006b38 <full_line_cmd+0x34>
40006b2c:	3fc020ef          	jal	ra,40008f28 <strlen>
40006b30:	01051793          	slli	a5,a0,0x10
40006b34:	0107d793          	srli	a5,a5,0x10
			% sh->ctx->vt100_ctx.cons.terminal_wid == 0U);
40006b38:	00842703          	lw	a4,8(s0)
	return ((sh->ctx->cmd_buff_len + z_shell_strlen(sh->ctx->prompt))
40006b3c:	009787b3          	add	a5,a5,s1
}
40006b40:	00c12083          	lw	ra,12(sp)
			% sh->ctx->vt100_ctx.cons.terminal_wid == 0U);
40006b44:	02e75703          	lhu	a4,46(a4)
}
40006b48:	00812403          	lw	s0,8(sp)
40006b4c:	00412483          	lw	s1,4(sp)
			% sh->ctx->vt100_ctx.cons.terminal_wid == 0U);
40006b50:	02e7e533          	rem	a0,a5,a4
}
40006b54:	01010113          	addi	sp,sp,16
40006b58:	00153513          	seqz	a0,a0
40006b5c:	00008067          	ret

40006b60 <z_shell_op_cursor_vert_move>:
	char dir = delta > 0 ? 'A' : 'B';
40006b60:	04100693          	li	a3,65
40006b64:	00b04663          	bgtz	a1,40006b70 <z_shell_op_cursor_vert_move+0x10>
	if (delta == 0) {
40006b68:	02058c63          	beqz	a1,40006ba0 <z_shell_op_cursor_vert_move+0x40>
	char dir = delta > 0 ? 'A' : 'B';
40006b6c:	04200693          	li	a3,66
	return sh->ctx->cfg.flags.use_vt100 == 1;
40006b70:	00852783          	lw	a5,8(a0)
40006b74:	26c7a783          	lw	a5,620(a5)
40006b78:	0057d793          	srli	a5,a5,0x5
40006b7c:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, "\e[%d%c", delta, dir);
40006b80:	02078063          	beqz	a5,40006ba0 <z_shell_op_cursor_vert_move+0x40>
	if (delta < 0) {
40006b84:	41f5d613          	srai	a2,a1,0x1f
40006b88:	00b645b3          	xor	a1,a2,a1
	Z_SHELL_VT100_CMD(sh, "\e[%d%c", delta, dir);
40006b8c:	01452503          	lw	a0,20(a0)
40006b90:	40c58633          	sub	a2,a1,a2
40006b94:	4002d5b7          	lui	a1,0x4002d
40006b98:	a7458593          	addi	a1,a1,-1420 # 4002ca74 <_shell_help+0x14>
40006b9c:	efdff06f          	j	40006a98 <z_shell_raw_fprintf>
}
40006ba0:	00008067          	ret

40006ba4 <z_shell_op_cursor_horiz_move>:
	char dir = delta > 0 ? 'C' : 'D';
40006ba4:	04300693          	li	a3,67
40006ba8:	00b04663          	bgtz	a1,40006bb4 <z_shell_op_cursor_horiz_move+0x10>
	if (delta == 0) {
40006bac:	02058c63          	beqz	a1,40006be4 <z_shell_op_cursor_horiz_move+0x40>
	char dir = delta > 0 ? 'C' : 'D';
40006bb0:	04400693          	li	a3,68
40006bb4:	00852783          	lw	a5,8(a0)
40006bb8:	26c7a783          	lw	a5,620(a5)
40006bbc:	0057d793          	srli	a5,a5,0x5
40006bc0:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, "\e[%d%c", delta, dir);
40006bc4:	02078063          	beqz	a5,40006be4 <z_shell_op_cursor_horiz_move+0x40>
	if (delta < 0) {
40006bc8:	41f5d613          	srai	a2,a1,0x1f
40006bcc:	00b645b3          	xor	a1,a2,a1
	Z_SHELL_VT100_CMD(sh, "\e[%d%c", delta, dir);
40006bd0:	01452503          	lw	a0,20(a0)
40006bd4:	40c58633          	sub	a2,a1,a2
40006bd8:	4002d5b7          	lui	a1,0x4002d
40006bdc:	a7458593          	addi	a1,a1,-1420 # 4002ca74 <_shell_help+0x14>
40006be0:	eb9ff06f          	j	40006a98 <z_shell_raw_fprintf>
}
40006be4:	00008067          	ret

40006be8 <z_shell_cursor_in_empty_line>:

/* Function returns true if cursor is at beginning of an empty line. */
bool z_shell_cursor_in_empty_line(const struct shell *sh)
{
40006be8:	ff010113          	addi	sp,sp,-16
40006bec:	00812423          	sw	s0,8(sp)
40006bf0:	00112623          	sw	ra,12(sp)
40006bf4:	00912223          	sw	s1,4(sp)
	return (((sh->ctx->cmd_buff_pos * sh->ctx->cfg.flags.echo) +
40006bf8:	00852703          	lw	a4,8(a0)
{
40006bfc:	00050413          	mv	s0,a0
	return (((sh->ctx->cmd_buff_pos * sh->ctx->cfg.flags.echo) +
40006c00:	26c72783          	lw	a5,620(a4)
40006c04:	04a75483          	lhu	s1,74(a4)
		 z_shell_strlen(sh->ctx->prompt)) %
40006c08:	00072503          	lw	a0,0(a4)
	return (((sh->ctx->cmd_buff_pos * sh->ctx->cfg.flags.echo) +
40006c0c:	0017d793          	srli	a5,a5,0x1
40006c10:	0017f793          	andi	a5,a5,1
40006c14:	02f484b3          	mul	s1,s1,a5
40006c18:	00000793          	li	a5,0
40006c1c:	00050863          	beqz	a0,40006c2c <z_shell_cursor_in_empty_line+0x44>
40006c20:	308020ef          	jal	ra,40008f28 <strlen>
40006c24:	01051793          	slli	a5,a0,0x10
40006c28:	0107d793          	srli	a5,a5,0x10
			sh->ctx->vt100_ctx.cons.terminal_wid ==
40006c2c:	00842703          	lw	a4,8(s0)
	return (((sh->ctx->cmd_buff_pos * sh->ctx->cfg.flags.echo) +
40006c30:	009787b3          	add	a5,a5,s1
		0U);
}
40006c34:	00c12083          	lw	ra,12(sp)
			sh->ctx->vt100_ctx.cons.terminal_wid ==
40006c38:	02e75703          	lhu	a4,46(a4)
}
40006c3c:	00812403          	lw	s0,8(sp)
40006c40:	00412483          	lw	s1,4(sp)
		 z_shell_strlen(sh->ctx->prompt)) %
40006c44:	02e7e533          	rem	a0,a5,a4
}
40006c48:	01010113          	addi	sp,sp,16
40006c4c:	00153513          	seqz	a0,a0
40006c50:	00008067          	ret

40006c54 <z_shell_op_cond_next_line>:

void z_shell_op_cond_next_line(const struct shell *sh)
{
40006c54:	ff010113          	addi	sp,sp,-16
40006c58:	00812423          	sw	s0,8(sp)
40006c5c:	00112623          	sw	ra,12(sp)
40006c60:	00050413          	mv	s0,a0
	if (z_shell_cursor_in_empty_line(sh) || full_line_cmd(sh)) {
40006c64:	f85ff0ef          	jal	ra,40006be8 <z_shell_cursor_in_empty_line>
40006c68:	00050c63          	beqz	a0,40006c80 <z_shell_op_cond_next_line+0x2c>
		z_cursor_next_line_move(sh);
40006c6c:	01442503          	lw	a0,20(s0)
	}
}
40006c70:	00812403          	lw	s0,8(sp)
40006c74:	00c12083          	lw	ra,12(sp)
40006c78:	01010113          	addi	sp,sp,16
		z_cursor_next_line_move(sh);
40006c7c:	e7dff06f          	j	40006af8 <z_cursor_next_line_move.isra.0>
	if (z_shell_cursor_in_empty_line(sh) || full_line_cmd(sh)) {
40006c80:	00040513          	mv	a0,s0
40006c84:	e81ff0ef          	jal	ra,40006b04 <full_line_cmd>
40006c88:	fe0512e3          	bnez	a0,40006c6c <z_shell_op_cond_next_line+0x18>
}
40006c8c:	00c12083          	lw	ra,12(sp)
40006c90:	00812403          	lw	s0,8(sp)
40006c94:	01010113          	addi	sp,sp,16
40006c98:	00008067          	ret

40006c9c <z_shell_op_cursor_position_synchronize>:

void z_shell_op_cursor_position_synchronize(const struct shell *sh)
{
40006c9c:	fe010113          	addi	sp,sp,-32
40006ca0:	00912a23          	sw	s1,20(sp)
40006ca4:	01212823          	sw	s2,16(sp)
40006ca8:	01312623          	sw	s3,12(sp)
40006cac:	00112e23          	sw	ra,28(sp)
40006cb0:	00812c23          	sw	s0,24(sp)
	struct shell_multiline_cons *cons = &sh->ctx->vt100_ctx.cons;
40006cb4:	00852403          	lw	s0,8(a0)
{
40006cb8:	00050493          	mv	s1,a0
	bool last_line;

	z_shell_multiline_data_calc(cons, sh->ctx->cmd_buff_pos,
40006cbc:	04845603          	lhu	a2,72(s0)
40006cc0:	04a45583          	lhu	a1,74(s0)
40006cc4:	02440513          	addi	a0,s0,36
40006cc8:	cf0ff0ef          	jal	ra,400061b8 <z_shell_multiline_data_calc>
	last_line = (cons->cur_y == cons->cur_y_end);

	/* In case cursor reaches the bottom line of a terminal, it will
	 * be moved to the next line.
	 */
	if (full_line_cmd(sh)) {
40006ccc:	00048513          	mv	a0,s1
	last_line = (cons->cur_y == cons->cur_y_end);
40006cd0:	02845983          	lhu	s3,40(s0)
40006cd4:	02a45903          	lhu	s2,42(s0)
	if (full_line_cmd(sh)) {
40006cd8:	e2dff0ef          	jal	ra,40006b04 <full_line_cmd>
40006cdc:	00050663          	beqz	a0,40006ce8 <z_shell_op_cursor_position_synchronize+0x4c>
		z_cursor_next_line_move(sh);
40006ce0:	0144a503          	lw	a0,20(s1)
40006ce4:	e15ff0ef          	jal	ra,40006af8 <z_cursor_next_line_move.isra.0>
	}

	if (last_line) {
40006ce8:	03299863          	bne	s3,s2,40006d18 <z_shell_op_cursor_position_synchronize+0x7c>
		z_shell_op_cursor_horiz_move(sh, cons->cur_x -
							       cons->cur_x_end);
	} else {
		z_shell_op_cursor_vert_move(sh, cons->cur_y_end - cons->cur_y);
		z_shell_op_cursor_horiz_move(sh, cons->cur_x -
40006cec:	02445583          	lhu	a1,36(s0)
							       cons->cur_x_end);
40006cf0:	02645783          	lhu	a5,38(s0)
	}
}
40006cf4:	01812403          	lw	s0,24(sp)
40006cf8:	01c12083          	lw	ra,28(sp)
40006cfc:	01012903          	lw	s2,16(sp)
40006d00:	00c12983          	lw	s3,12(sp)
		z_shell_op_cursor_horiz_move(sh, cons->cur_x -
40006d04:	00048513          	mv	a0,s1
}
40006d08:	01412483          	lw	s1,20(sp)
		z_shell_op_cursor_horiz_move(sh, cons->cur_x -
40006d0c:	40f585b3          	sub	a1,a1,a5
}
40006d10:	02010113          	addi	sp,sp,32
		z_shell_op_cursor_horiz_move(sh, cons->cur_x -
40006d14:	e91ff06f          	j	40006ba4 <z_shell_op_cursor_horiz_move>
		z_shell_op_cursor_vert_move(sh, cons->cur_y_end - cons->cur_y);
40006d18:	02a45583          	lhu	a1,42(s0)
40006d1c:	02845783          	lhu	a5,40(s0)
40006d20:	00048513          	mv	a0,s1
40006d24:	40f585b3          	sub	a1,a1,a5
40006d28:	e39ff0ef          	jal	ra,40006b60 <z_shell_op_cursor_vert_move>
40006d2c:	fc1ff06f          	j	40006cec <z_shell_op_cursor_position_synchronize+0x50>

40006d30 <z_shell_op_cursor_move>:

void z_shell_op_cursor_move(const struct shell *sh, int16_t val)
{
40006d30:	fe010113          	addi	sp,sp,-32
40006d34:	00112e23          	sw	ra,28(sp)
40006d38:	00812c23          	sw	s0,24(sp)
40006d3c:	00912a23          	sw	s1,20(sp)
40006d40:	01212823          	sw	s2,16(sp)
40006d44:	01312623          	sw	s3,12(sp)
40006d48:	00050413          	mv	s0,a0
	struct shell_multiline_cons *cons = &sh->ctx->vt100_ctx.cons;
40006d4c:	00852503          	lw	a0,8(a0)
{
40006d50:	00058493          	mv	s1,a1
	uint16_t new_pos = sh->ctx->cmd_buff_pos + val;
	int32_t row_span;
	int32_t col_span;

	z_shell_multiline_data_calc(cons, sh->ctx->cmd_buff_pos,
40006d54:	04855603          	lhu	a2,72(a0)
	uint16_t new_pos = sh->ctx->cmd_buff_pos + val;
40006d58:	04a55583          	lhu	a1,74(a0)
	z_shell_multiline_data_calc(cons, sh->ctx->cmd_buff_pos,
40006d5c:	02450513          	addi	a0,a0,36
	uint16_t new_pos = sh->ctx->cmd_buff_pos + val;
40006d60:	009584b3          	add	s1,a1,s1
	z_shell_multiline_data_calc(cons, sh->ctx->cmd_buff_pos,
40006d64:	c54ff0ef          	jal	ra,400061b8 <z_shell_multiline_data_calc>
				    sh->ctx->cmd_buff_len);

	/* Calculate the new cursor. */
	row_span = z_row_span_with_buffer_offsets_get(
						&sh->ctx->vt100_ctx.cons,
40006d68:	00842503          	lw	a0,8(s0)
	uint16_t new_pos = sh->ctx->cmd_buff_pos + val;
40006d6c:	01049493          	slli	s1,s1,0x10
40006d70:	0104d493          	srli	s1,s1,0x10
	row_span = z_row_span_with_buffer_offsets_get(
40006d74:	04a55583          	lhu	a1,74(a0)
40006d78:	00048613          	mv	a2,s1
40006d7c:	02450513          	addi	a0,a0,36
40006d80:	c18ff0ef          	jal	ra,40006198 <z_row_span_with_buffer_offsets_get>
40006d84:	00050993          	mv	s3,a0
						sh->ctx->cmd_buff_pos,
						new_pos);
	col_span = z_column_span_with_buffer_offsets_get(
						&sh->ctx->vt100_ctx.cons,
40006d88:	00842503          	lw	a0,8(s0)
	col_span = z_column_span_with_buffer_offsets_get(
40006d8c:	00048613          	mv	a2,s1
40006d90:	04a55583          	lhu	a1,74(a0)
40006d94:	02450513          	addi	a0,a0,36
40006d98:	be0ff0ef          	jal	ra,40006178 <z_column_span_with_buffer_offsets_get>
40006d9c:	00050913          	mv	s2,a0
						sh->ctx->cmd_buff_pos,
						new_pos);

	z_shell_op_cursor_vert_move(sh, -row_span);
40006da0:	413005b3          	neg	a1,s3
40006da4:	00040513          	mv	a0,s0
40006da8:	db9ff0ef          	jal	ra,40006b60 <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(sh, col_span);
40006dac:	00090593          	mv	a1,s2
40006db0:	00040513          	mv	a0,s0
40006db4:	df1ff0ef          	jal	ra,40006ba4 <z_shell_op_cursor_horiz_move>
	sh->ctx->cmd_buff_pos = new_pos;
40006db8:	00842783          	lw	a5,8(s0)
40006dbc:	04979523          	sh	s1,74(a5)
}
40006dc0:	01c12083          	lw	ra,28(sp)
40006dc4:	01812403          	lw	s0,24(sp)
40006dc8:	01412483          	lw	s1,20(sp)
40006dcc:	01012903          	lw	s2,16(sp)
40006dd0:	00c12983          	lw	s3,12(sp)
40006dd4:	02010113          	addi	sp,sp,32
40006dd8:	00008067          	ret

40006ddc <z_shell_op_cursor_word_move>:

	return ret;
}

void z_shell_op_cursor_word_move(const struct shell *sh, int16_t val)
{
40006ddc:	fe010113          	addi	sp,sp,-32
40006de0:	00912a23          	sw	s1,20(sp)
40006de4:	01212823          	sw	s2,16(sp)
40006de8:	00112e23          	sw	ra,28(sp)
40006dec:	00812c23          	sw	s0,24(sp)
40006df0:	01312623          	sw	s3,12(sp)
40006df4:	01412423          	sw	s4,8(sp)
40006df8:	01512223          	sw	s5,4(sp)
40006dfc:	01612023          	sw	s6,0(sp)
40006e00:	00050913          	mv	s2,a0
40006e04:	00100493          	li	s1,1
	int16_t shift;
	int16_t sign;

	if (val < 0) {
40006e08:	0005da63          	bgez	a1,40006e1c <z_shell_op_cursor_word_move+0x40>
		val = -val;
40006e0c:	40b005b3          	neg	a1,a1
40006e10:	01059593          	slli	a1,a1,0x10
40006e14:	4105d593          	srai	a1,a1,0x10
		sign = -1;
40006e18:	fff00493          	li	s1,-1
40006e1c:	01059413          	slli	s0,a1,0x10
40006e20:	01049993          	slli	s3,s1,0x10
40006e24:	01045413          	srli	s0,s0,0x10
40006e28:	0109d993          	srli	s3,s3,0x10
		    ((idx == len) && (sign > 0))) {
40006e2c:	00100a13          	li	s4,1
				(int)'z') ? (chr - 32) : (chr));
}

static inline int isalnum(int chr)
{
	return (int)(isalpha(chr) || isdigit(chr));
40006e30:	01900a93          	li	s5,25
40006e34:	00900b13          	li	s6,9
40006e38:	04c0006f          	j	40006e84 <z_shell_op_cursor_word_move+0xa8>
	} else {
		sign = 1;
	}

	while (val--) {
		shift = shift_calc(sh->ctx->cmd_buff,
40006e3c:	00892783          	lw	a5,8(s2)
	bool found = false;
40006e40:	00000713          	li	a4,0
		if (((idx == 0U) && (sign < 0)) ||
40006e44:	fff00893          	li	a7,-1
		shift = shift_calc(sh->ctx->cmd_buff,
40006e48:	04a7d603          	lhu	a2,74(a5)
40006e4c:	0487d503          	lhu	a0,72(a5)
40006e50:	04e78813          	addi	a6,a5,78
40006e54:	00060593          	mv	a1,a2
		if (((idx == 0U) && (sign < 0)) ||
40006e58:	04059c63          	bnez	a1,40006eb0 <z_shell_op_cursor_word_move+0xd4>
40006e5c:	01148463          	beq	s1,a7,40006e64 <z_shell_op_cursor_word_move+0x88>
40006e60:	04051c63          	bnez	a0,40006eb8 <z_shell_op_cursor_word_move+0xdc>
		idx = pos + ret * sign;
40006e64:	40c585b3          	sub	a1,a1,a2
				   sh->ctx->cmd_buff_pos,
				   sh->ctx->cmd_buff_len, sign);
		z_shell_op_cursor_move(sh, sign * shift);
40006e68:	01059593          	slli	a1,a1,0x10
40006e6c:	4105d593          	srai	a1,a1,0x10
40006e70:	00090513          	mv	a0,s2
40006e74:	ebdff0ef          	jal	ra,40006d30 <z_shell_op_cursor_move>
40006e78:	fff40593          	addi	a1,s0,-1
40006e7c:	01059413          	slli	s0,a1,0x10
40006e80:	01045413          	srli	s0,s0,0x10
	while (val--) {
40006e84:	fa041ce3          	bnez	s0,40006e3c <z_shell_op_cursor_word_move+0x60>
	}
}
40006e88:	01c12083          	lw	ra,28(sp)
40006e8c:	01812403          	lw	s0,24(sp)
40006e90:	01412483          	lw	s1,20(sp)
40006e94:	01012903          	lw	s2,16(sp)
40006e98:	00c12983          	lw	s3,12(sp)
40006e9c:	00812a03          	lw	s4,8(sp)
40006ea0:	00412a83          	lw	s5,4(sp)
40006ea4:	00012b03          	lw	s6,0(sp)
40006ea8:	02010113          	addi	sp,sp,32
40006eac:	00008067          	ret
		if (((idx == 0U) && (sign < 0)) ||
40006eb0:	00b51463          	bne	a0,a1,40006eb8 <z_shell_op_cursor_word_move+0xdc>
		    ((idx == len) && (sign > 0))) {
40006eb4:	fb4488e3          	beq	s1,s4,40006e64 <z_shell_op_cursor_word_move+0x88>
		if (isalnum((int)str[idx]) != 0) {
40006eb8:	00b807b3          	add	a5,a6,a1
40006ebc:	0007c783          	lbu	a5,0(a5)
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
40006ec0:	0207e693          	ori	a3,a5,32
40006ec4:	f9f68693          	addi	a3,a3,-97
	return (int)(isalpha(chr) || isdigit(chr));
40006ec8:	02daf063          	bgeu	s5,a3,40006ee8 <z_shell_op_cursor_word_move+0x10c>
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
40006ecc:	fd078793          	addi	a5,a5,-48
	return (int)(isalpha(chr) || isdigit(chr));
40006ed0:	00fb7c63          	bgeu	s6,a5,40006ee8 <z_shell_op_cursor_word_move+0x10c>
			if (found) {
40006ed4:	f80718e3          	bnez	a4,40006e64 <z_shell_op_cursor_word_move+0x88>
	while (1) {
40006ed8:	00b985b3          	add	a1,s3,a1
40006edc:	01059593          	slli	a1,a1,0x10
40006ee0:	0105d593          	srli	a1,a1,0x10
		idx = pos + ret * sign;
40006ee4:	f75ff06f          	j	40006e58 <z_shell_op_cursor_word_move+0x7c>
			found = true;
40006ee8:	00100713          	li	a4,1
40006eec:	fedff06f          	j	40006ed8 <z_shell_op_cursor_word_move+0xfc>

40006ef0 <z_shell_op_cursor_home_move>:
	z_cursor_restore(sh);
}

void z_shell_op_cursor_home_move(const struct shell *sh)
{
	z_shell_op_cursor_move(sh, -sh->ctx->cmd_buff_pos);
40006ef0:	00852783          	lw	a5,8(a0)
40006ef4:	04a7d583          	lhu	a1,74(a5)
40006ef8:	40b005b3          	neg	a1,a1
40006efc:	01059593          	slli	a1,a1,0x10
40006f00:	4105d593          	srai	a1,a1,0x10
40006f04:	e2dff06f          	j	40006d30 <z_shell_op_cursor_move>

40006f08 <z_shell_op_cursor_end_move>:
}

void z_shell_op_cursor_end_move(const struct shell *sh)
{
	z_shell_op_cursor_move(sh, sh->ctx->cmd_buff_len -
40006f08:	00852783          	lw	a5,8(a0)
40006f0c:	0487d583          	lhu	a1,72(a5)
40006f10:	04a7d783          	lhu	a5,74(a5)
40006f14:	40f585b3          	sub	a1,a1,a5
40006f18:	01059593          	slli	a1,a1,0x10
40006f1c:	4105d593          	srai	a1,a1,0x10
40006f20:	e11ff06f          	j	40006d30 <z_shell_op_cursor_move>

40006f24 <z_shell_op_left_arrow>:
						sh->ctx->cmd_buff_pos);
}

void z_shell_op_left_arrow(const struct shell *sh)
{
	if (sh->ctx->cmd_buff_pos > 0) {
40006f24:	00852783          	lw	a5,8(a0)
40006f28:	04a7d783          	lhu	a5,74(a5)
40006f2c:	00078663          	beqz	a5,40006f38 <z_shell_op_left_arrow+0x14>
		z_shell_op_cursor_move(sh, -1);
40006f30:	fff00593          	li	a1,-1
40006f34:	dfdff06f          	j	40006d30 <z_shell_op_cursor_move>
	}
}
40006f38:	00008067          	ret

40006f3c <z_shell_op_right_arrow>:

void z_shell_op_right_arrow(const struct shell *sh)
{
	if (sh->ctx->cmd_buff_pos < sh->ctx->cmd_buff_len) {
40006f3c:	00852783          	lw	a5,8(a0)
40006f40:	04a7d703          	lhu	a4,74(a5)
40006f44:	0487d783          	lhu	a5,72(a5)
40006f48:	00f77663          	bgeu	a4,a5,40006f54 <z_shell_op_right_arrow+0x18>
		z_shell_op_cursor_move(sh, 1);
40006f4c:	00100593          	li	a1,1
40006f50:	de1ff06f          	j	40006d30 <z_shell_op_cursor_move>
	}
}
40006f54:	00008067          	ret

40006f58 <z_shell_op_delete_from_cursor>:
	reprint_from_cursor(sh, --diff, true);
}

void z_shell_op_delete_from_cursor(const struct shell *sh)
{
	sh->ctx->cmd_buff_len = sh->ctx->cmd_buff_pos;
40006f58:	00852703          	lw	a4,8(a0)
40006f5c:	04a75683          	lhu	a3,74(a4)
40006f60:	04d71423          	sh	a3,72(a4)
	sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos] = '\0';
40006f64:	00852783          	lw	a5,8(a0)
40006f68:	04a7d703          	lhu	a4,74(a5)
40006f6c:	00e787b3          	add	a5,a5,a4
40006f70:	04078723          	sb	zero,78(a5)

	z_clear_eos(sh);
40006f74:	b5dff06f          	j	40006ad0 <z_clear_eos>

40006f78 <z_shell_cmd_line_erase>:
{
	data_insert(sh, compl, compl_len);
}

void z_shell_cmd_line_erase(const struct shell *sh)
{
40006f78:	ff010113          	addi	sp,sp,-16
40006f7c:	00112623          	sw	ra,12(sp)
40006f80:	00812423          	sw	s0,8(sp)
40006f84:	00050413          	mv	s0,a0
	z_shell_multiline_data_calc(&sh->ctx->vt100_ctx.cons,
40006f88:	00852503          	lw	a0,8(a0)
40006f8c:	04855603          	lhu	a2,72(a0)
40006f90:	04a55583          	lhu	a1,74(a0)
40006f94:	02450513          	addi	a0,a0,36
40006f98:	a20ff0ef          	jal	ra,400061b8 <z_shell_multiline_data_calc>
				    sh->ctx->cmd_buff_pos,
				    sh->ctx->cmd_buff_len);
	z_shell_op_cursor_horiz_move(sh,
				   -(sh->ctx->vt100_ctx.cons.cur_x - 1));
40006f9c:	00842783          	lw	a5,8(s0)
	z_shell_op_cursor_horiz_move(sh,
40006fa0:	00100593          	li	a1,1
40006fa4:	00040513          	mv	a0,s0
				   -(sh->ctx->vt100_ctx.cons.cur_x - 1));
40006fa8:	0247d783          	lhu	a5,36(a5)
	z_shell_op_cursor_horiz_move(sh,
40006fac:	40f585b3          	sub	a1,a1,a5
40006fb0:	bf5ff0ef          	jal	ra,40006ba4 <z_shell_op_cursor_horiz_move>
	z_shell_op_cursor_vert_move(sh, sh->ctx->vt100_ctx.cons.cur_y - 1);
40006fb4:	00842783          	lw	a5,8(s0)
40006fb8:	00040513          	mv	a0,s0
40006fbc:	0287d583          	lhu	a1,40(a5)
40006fc0:	fff58593          	addi	a1,a1,-1
40006fc4:	b9dff0ef          	jal	ra,40006b60 <z_shell_op_cursor_vert_move>

	z_clear_eos(sh);
40006fc8:	00040513          	mv	a0,s0
}
40006fcc:	00812403          	lw	s0,8(sp)
40006fd0:	00c12083          	lw	ra,12(sp)
40006fd4:	01010113          	addi	sp,sp,16
	z_clear_eos(sh);
40006fd8:	af9ff06f          	j	40006ad0 <z_clear_eos>

40006fdc <z_shell_print_cmd>:
	z_shell_fprintf(sh, SHELL_INFO, "%s", sh->ctx->prompt);
}

void z_shell_print_cmd(const struct shell *sh)
{
	z_shell_raw_fprintf(sh->fprintf_ctx, "%s", sh->ctx->cmd_buff);
40006fdc:	00852603          	lw	a2,8(a0)
40006fe0:	01452503          	lw	a0,20(a0)
40006fe4:	4002c5b7          	lui	a1,0x4002c
40006fe8:	04e60613          	addi	a2,a2,78
40006fec:	78458593          	addi	a1,a1,1924 # 4002c784 <shell_telnet_fprintf+0x128>
40006ff0:	aa9ff06f          	j	40006a98 <z_shell_raw_fprintf>

40006ff4 <z_shell_write>:
	}
}

void z_shell_write(const struct shell *sh, const void *data,
		 size_t length)
{
40006ff4:	fc010113          	addi	sp,sp,-64
40006ff8:	02812c23          	sw	s0,56(sp)
40006ffc:	02912a23          	sw	s1,52(sp)
40007000:	03212823          	sw	s2,48(sp)
40007004:	03312623          	sw	s3,44(sp)
40007008:	03412423          	sw	s4,40(sp)
4000700c:	03512223          	sw	s5,36(sp)
40007010:	02112e23          	sw	ra,60(sp)
40007014:	00050493          	mv	s1,a0
40007018:	00058993          	mv	s3,a1
4000701c:	00060413          	mv	s0,a2
	__ASSERT_NO_MSG(sh && data);

	size_t offset = 0;
40007020:	00000913          	li	s2,0
		(void)err;
		__ASSERT_NO_MSG(err == 0);
		__ASSERT_NO_MSG(length >= tmp_cnt);
		offset += tmp_cnt;
		length -= tmp_cnt;
		if (tmp_cnt == 0 &&
40007024:	00300a13          	li	s4,3
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
40007028:	00200a93          	li	s5,2
	while (length) {
4000702c:	04041263          	bnez	s0,40007070 <z_shell_write+0x7c>
		    (sh->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
			shell_pend_on_txdone(sh);
		}
	}
}
40007030:	03c12083          	lw	ra,60(sp)
40007034:	03812403          	lw	s0,56(sp)
40007038:	03412483          	lw	s1,52(sp)
4000703c:	03012903          	lw	s2,48(sp)
40007040:	02c12983          	lw	s3,44(sp)
40007044:	02812a03          	lw	s4,40(sp)
40007048:	02412a83          	lw	s5,36(sp)
4000704c:	04010113          	addi	sp,sp,64
40007050:	00008067          	ret
	return sh->ctx->ctx.flags.tx_rdy == 1;
40007054:	2706a783          	lw	a5,624(a3)
40007058:	0017d793          	srli	a5,a5,0x1
4000705c:	0017f793          	andi	a5,a5,1
		while (!z_flag_tx_rdy_get(sh)) {
40007060:	fe078ae3          	beqz	a5,40007054 <z_shell_write+0x60>
40007064:	ffd00593          	li	a1,-3
40007068:	27068513          	addi	a0,a3,624
4000706c:	7c1230ef          	jal	ra,4002b02c <z_impl_atomic_and>
		int err = sh->iface->api->write(sh->iface,
40007070:	0044a503          	lw	a0,4(s1)
40007074:	00040613          	mv	a2,s0
40007078:	012985b3          	add	a1,s3,s2
4000707c:	00052783          	lw	a5,0(a0)
40007080:	00810693          	addi	a3,sp,8
40007084:	00c7a783          	lw	a5,12(a5)
40007088:	000780e7          	jalr	a5
		offset += tmp_cnt;
4000708c:	00812783          	lw	a5,8(sp)
40007090:	00f90933          	add	s2,s2,a5
		length -= tmp_cnt;
40007094:	40f40433          	sub	s0,s0,a5
		if (tmp_cnt == 0 &&
40007098:	f8079ae3          	bnez	a5,4000702c <z_shell_write+0x38>
		    (sh->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
4000709c:	0084a683          	lw	a3,8(s1)
400070a0:	0046a783          	lw	a5,4(a3)
		if (tmp_cnt == 0 &&
400070a4:	fd4786e3          	beq	a5,s4,40007070 <z_shell_write+0x7c>
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
400070a8:	fafae6e3          	bltu	s5,a5,40007054 <z_shell_write+0x60>
		k_poll_event_init(&event,
400070ac:	2a468693          	addi	a3,a3,676
400070b0:	00000613          	li	a2,0
400070b4:	00100593          	li	a1,1
400070b8:	00c10513          	addi	a0,sp,12
400070bc:	3d8240ef          	jal	ra,4002b494 <k_poll_event_init>
400070c0:	fff00613          	li	a2,-1
400070c4:	fff00693          	li	a3,-1
400070c8:	00100593          	li	a1,1
400070cc:	00c10513          	addi	a0,sp,12
400070d0:	3fc240ef          	jal	ra,4002b4cc <z_impl_k_poll>
		k_poll_signal_reset(&sh->ctx->signals[SHELL_SIGNAL_TXDONE]);
400070d4:	0084a503          	lw	a0,8(s1)
400070d8:	2a450513          	addi	a0,a0,676
	z_impl_k_poll_signal_reset(sig);
400070dc:	52c240ef          	jal	ra,4002b608 <z_impl_k_poll_signal_reset>
	while (length) {
400070e0:	f91ff06f          	j	40007070 <z_shell_write+0x7c>

400070e4 <z_shell_print_stream>:

/* Function shall be only used by the fprintf module. */
void z_shell_print_stream(const void *user_ctx, const char *data, size_t len)
{
	z_shell_write((const struct shell *) user_ctx, data, len);
400070e4:	f11ff06f          	j	40006ff4 <z_shell_write>

400070e8 <z_shell_vt100_color_set>:
{
	if (!IS_ENABLED(CONFIG_SHELL_VT100_COLORS)) {
		return;
	}

	if (color >= VT100_COLOR_END) {
400070e8:	00800713          	li	a4,8
{
400070ec:	00058613          	mv	a2,a1
	if (color >= VT100_COLOR_END) {
400070f0:	04b76863          	bltu	a4,a1,40007140 <z_shell_vt100_color_set+0x58>
		return;
	}

	if (sh->ctx->vt100_ctx.col.col == color) {
400070f4:	00852783          	lw	a5,8(a0)
400070f8:	0347a683          	lw	a3,52(a5)
400070fc:	04b68263          	beq	a3,a1,40007140 <z_shell_vt100_color_set+0x58>
		return;
	}

	sh->ctx->vt100_ctx.col.col = color;
40007100:	02b7aa23          	sw	a1,52(a5)

	if (color != SHELL_NORMAL) {
40007104:	00852783          	lw	a5,8(a0)
	return sh->ctx->cfg.flags.use_vt100 == 1;
40007108:	26c7a783          	lw	a5,620(a5)
4000710c:	0057d793          	srli	a5,a5,0x5
40007110:	0017f793          	andi	a5,a5,1
40007114:	00e58c63          	beq	a1,a4,4000712c <z_shell_vt100_color_set+0x44>
		Z_SHELL_VT100_CMD(sh, "\e[1;3%dm", color);
40007118:	02078463          	beqz	a5,40007140 <z_shell_vt100_color_set+0x58>
4000711c:	01452503          	lw	a0,20(a0)
40007120:	4002d5b7          	lui	a1,0x4002d
40007124:	a7c58593          	addi	a1,a1,-1412 # 4002ca7c <_shell_help+0x1c>
40007128:	971ff06f          	j	40006a98 <z_shell_raw_fprintf>
	} else {
		Z_SHELL_VT100_CMD(sh, SHELL_VT100_MODESOFF);
4000712c:	00078a63          	beqz	a5,40007140 <z_shell_vt100_color_set+0x58>
40007130:	01452503          	lw	a0,20(a0)
40007134:	4002c5b7          	lui	a1,0x4002c
40007138:	bfc58593          	addi	a1,a1,-1028 # 4002bbfc <eth_config+0x24>
4000713c:	95dff06f          	j	40006a98 <z_shell_raw_fprintf>
	}
}
40007140:	00008067          	ret

40007144 <z_shell_vt100_colors_restore>:

void z_shell_vt100_colors_restore(const struct shell *sh,
				  const struct shell_vt100_colors *color)
{
40007144:	ff010113          	addi	sp,sp,-16
40007148:	00812423          	sw	s0,8(sp)
4000714c:	00912223          	sw	s1,4(sp)
40007150:	00112623          	sw	ra,12(sp)
40007154:	00058493          	mv	s1,a1
	if (!IS_ENABLED(CONFIG_SHELL_VT100_COLORS)) {
		return;
	}

	z_shell_vt100_color_set(sh, color->col);
40007158:	0005a583          	lw	a1,0(a1)
{
4000715c:	00050413          	mv	s0,a0
	z_shell_vt100_color_set(sh, color->col);
40007160:	f89ff0ef          	jal	ra,400070e8 <z_shell_vt100_color_set>
	vt100_bgcolor_set(sh, color->bgcol);
40007164:	0044a603          	lw	a2,4(s1)
	if ((bgcolor == SHELL_NORMAL) ||
40007168:	00700793          	li	a5,7
4000716c:	04c7e463          	bltu	a5,a2,400071b4 <z_shell_vt100_colors_restore+0x70>
	    (sh->ctx->vt100_ctx.col.bgcol == bgcolor)) {
40007170:	00842783          	lw	a5,8(s0)
	if ((bgcolor == SHELL_NORMAL) ||
40007174:	0387a703          	lw	a4,56(a5)
40007178:	02e60e63          	beq	a2,a4,400071b4 <z_shell_vt100_colors_restore+0x70>
	sh->ctx->vt100_ctx.col.bgcol = bgcolor;
4000717c:	02c7ac23          	sw	a2,56(a5)
40007180:	00842783          	lw	a5,8(s0)
40007184:	26c7a783          	lw	a5,620(a5)
40007188:	0057d793          	srli	a5,a5,0x5
4000718c:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, "\e[403%dm", bgcolor);
40007190:	02078263          	beqz	a5,400071b4 <z_shell_vt100_colors_restore+0x70>
40007194:	01442503          	lw	a0,20(s0)
}
40007198:	00812403          	lw	s0,8(sp)
4000719c:	00c12083          	lw	ra,12(sp)
400071a0:	00412483          	lw	s1,4(sp)
	Z_SHELL_VT100_CMD(sh, "\e[403%dm", bgcolor);
400071a4:	4002d5b7          	lui	a1,0x4002d
400071a8:	a8858593          	addi	a1,a1,-1400 # 4002ca88 <_shell_help+0x28>
}
400071ac:	01010113          	addi	sp,sp,16
	Z_SHELL_VT100_CMD(sh, "\e[403%dm", bgcolor);
400071b0:	8e9ff06f          	j	40006a98 <z_shell_raw_fprintf>
}
400071b4:	00c12083          	lw	ra,12(sp)
400071b8:	00812403          	lw	s0,8(sp)
400071bc:	00412483          	lw	s1,4(sp)
400071c0:	01010113          	addi	sp,sp,16
400071c4:	00008067          	ret

400071c8 <z_shell_vfprintf>:

void z_shell_vfprintf(const struct shell *sh, enum shell_vt100_color color,
		      const char *fmt, va_list args)
{
400071c8:	fd010113          	addi	sp,sp,-48
400071cc:	02812423          	sw	s0,40(sp)
400071d0:	02912223          	sw	s1,36(sp)
400071d4:	03212023          	sw	s2,32(sp)
400071d8:	01312e23          	sw	s3,28(sp)
400071dc:	02112623          	sw	ra,44(sp)
400071e0:	00058993          	mv	s3,a1
	return sh->ctx->cfg.flags.use_colors == 1;
400071e4:	00852583          	lw	a1,8(a0)
400071e8:	00050413          	mv	s0,a0
400071ec:	00060493          	mv	s1,a2
400071f0:	26c5a783          	lw	a5,620(a1)
400071f4:	00068913          	mv	s2,a3
400071f8:	0047d793          	srli	a5,a5,0x4
400071fc:	0017f793          	andi	a5,a5,1
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
40007200:	06078063          	beqz	a5,40007260 <z_shell_vfprintf+0x98>
	    z_flag_use_colors_get(sh)	  &&
40007204:	0345a783          	lw	a5,52(a1)
40007208:	05378c63          	beq	a5,s3,40007260 <z_shell_vfprintf+0x98>
			     enum shell_vt100_color color);

static inline void z_shell_vt100_colors_store(const struct shell *sh,
					      struct shell_vt100_colors *color)
{
	memcpy(color, &sh->ctx->vt100_ctx.col, sizeof(*color));
4000720c:	00800613          	li	a2,8
40007210:	03458593          	addi	a1,a1,52
40007214:	00810513          	addi	a0,sp,8
40007218:	635010ef          	jal	ra,4000904c <memcpy>
	    (color != sh->ctx->vt100_ctx.col.col)) {
		struct shell_vt100_colors col;

		z_shell_vt100_colors_store(sh, &col);
		z_shell_vt100_color_set(sh, color);
4000721c:	00098593          	mv	a1,s3
40007220:	00040513          	mv	a0,s0
40007224:	ec5ff0ef          	jal	ra,400070e8 <z_shell_vt100_color_set>

		z_shell_fprintf_fmt(sh->fprintf_ctx, fmt, args);
40007228:	01442503          	lw	a0,20(s0)
4000722c:	00090613          	mv	a2,s2
40007230:	00048593          	mv	a1,s1
40007234:	e15fe0ef          	jal	ra,40006048 <z_shell_fprintf_fmt>

		z_shell_vt100_colors_restore(sh, &col);
40007238:	00810593          	addi	a1,sp,8
4000723c:	00040513          	mv	a0,s0
40007240:	f05ff0ef          	jal	ra,40007144 <z_shell_vt100_colors_restore>
	} else {
		z_shell_fprintf_fmt(sh->fprintf_ctx, fmt, args);
	}
}
40007244:	02c12083          	lw	ra,44(sp)
40007248:	02812403          	lw	s0,40(sp)
4000724c:	02412483          	lw	s1,36(sp)
40007250:	02012903          	lw	s2,32(sp)
40007254:	01c12983          	lw	s3,28(sp)
40007258:	03010113          	addi	sp,sp,48
4000725c:	00008067          	ret
		z_shell_fprintf_fmt(sh->fprintf_ctx, fmt, args);
40007260:	01442503          	lw	a0,20(s0)
}
40007264:	02812403          	lw	s0,40(sp)
40007268:	02c12083          	lw	ra,44(sp)
4000726c:	01c12983          	lw	s3,28(sp)
		z_shell_fprintf_fmt(sh->fprintf_ctx, fmt, args);
40007270:	00090613          	mv	a2,s2
40007274:	00048593          	mv	a1,s1
}
40007278:	02012903          	lw	s2,32(sp)
4000727c:	02412483          	lw	s1,36(sp)
40007280:	03010113          	addi	sp,sp,48
		z_shell_fprintf_fmt(sh->fprintf_ctx, fmt, args);
40007284:	dc5fe06f          	j	40006048 <z_shell_fprintf_fmt>

40007288 <z_shell_fprintf>:

void z_shell_fprintf(const struct shell *sh,
		     enum shell_vt100_color color,
		     const char *fmt, ...)
{
40007288:	fc010113          	addi	sp,sp,-64
4000728c:	02d12623          	sw	a3,44(sp)
	__ASSERT(z_flag_sync_mode_get(sh) || !k_is_in_isr(),
		 "Thread context required.");

	va_list args;

	va_start(args, fmt);
40007290:	02c10693          	addi	a3,sp,44
{
40007294:	00112e23          	sw	ra,28(sp)
40007298:	02e12823          	sw	a4,48(sp)
4000729c:	02f12a23          	sw	a5,52(sp)
400072a0:	03012c23          	sw	a6,56(sp)
400072a4:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
400072a8:	00d12623          	sw	a3,12(sp)
	z_shell_vfprintf(sh, color, fmt, args);
400072ac:	f1dff0ef          	jal	ra,400071c8 <z_shell_vfprintf>
	va_end(args);
}
400072b0:	01c12083          	lw	ra,28(sp)
400072b4:	04010113          	addi	sp,sp,64
400072b8:	00008067          	ret

400072bc <z_shell_op_word_remove>:
{
400072bc:	fe010113          	addi	sp,sp,-32
400072c0:	00112e23          	sw	ra,28(sp)
400072c4:	00812c23          	sw	s0,24(sp)
400072c8:	00912a23          	sw	s1,20(sp)
400072cc:	01212823          	sw	s2,16(sp)
400072d0:	01312623          	sw	s3,12(sp)
	char *str = &sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos - 1];
400072d4:	00852783          	lw	a5,8(a0)
	if ((sh->ctx->cmd_buff_len == 0) ||
400072d8:	0487d603          	lhu	a2,72(a5)
	char *str = &sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos - 1];
400072dc:	04a7d483          	lhu	s1,74(a5)
	if ((sh->ctx->cmd_buff_len == 0) ||
400072e0:	12060e63          	beqz	a2,4000741c <z_shell_op_word_remove+0x160>
400072e4:	12048c63          	beqz	s1,4000741c <z_shell_op_word_remove+0x160>
	char *str = &sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos - 1];
400072e8:	04d48493          	addi	s1,s1,77
400072ec:	009784b3          	add	s1,a5,s1
	char *str_start = &sh->ctx->cmd_buff[0];
400072f0:	04e78713          	addi	a4,a5,78
400072f4:	00050413          	mv	s0,a0
	char *str = &sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos - 1];
400072f8:	00048793          	mv	a5,s1
	while ((str >= str_start) && (*str == ' ')) {
400072fc:	02000693          	li	a3,32
40007300:	00e7e663          	bltu	a5,a4,4000730c <z_shell_op_word_remove+0x50>
40007304:	0007c583          	lbu	a1,0(a5)
40007308:	00d58663          	beq	a1,a3,40007314 <z_shell_op_word_remove+0x58>
	while ((str >= str_start) && (*str != ' ')) {
4000730c:	02000693          	li	a3,32
40007310:	0180006f          	j	40007328 <z_shell_op_word_remove+0x6c>
		--str;
40007314:	fff78793          	addi	a5,a5,-1
40007318:	fe9ff06f          	j	40007300 <z_shell_op_word_remove+0x44>
	while ((str >= str_start) && (*str != ' ')) {
4000731c:	0007c583          	lbu	a1,0(a5)
40007320:	00d58663          	beq	a1,a3,4000732c <z_shell_op_word_remove+0x70>
		--str;
40007324:	fff78793          	addi	a5,a5,-1
	while ((str >= str_start) && (*str != ' ')) {
40007328:	fee7fae3          	bgeu	a5,a4,4000731c <z_shell_op_word_remove+0x60>
4000732c:	01079913          	slli	s2,a5,0x10
40007330:	01049493          	slli	s1,s1,0x10
40007334:	0104d493          	srli	s1,s1,0x10
40007338:	01095913          	srli	s2,s2,0x10
4000733c:	41248733          	sub	a4,s1,s2
40007340:	01071713          	slli	a4,a4,0x10
40007344:	01075713          	srli	a4,a4,0x10
	memmove(str + 1, str + 1 + chars_to_delete,
40007348:	00178993          	addi	s3,a5,1
4000734c:	00170593          	addi	a1,a4,1
40007350:	40e60633          	sub	a2,a2,a4
40007354:	00b785b3          	add	a1,a5,a1
40007358:	00098513          	mv	a0,s3
4000735c:	4a9010ef          	jal	ra,40009004 <memmove>
	sh->ctx->cmd_buff_len -= chars_to_delete;
40007360:	00842703          	lw	a4,8(s0)
40007364:	409905b3          	sub	a1,s2,s1
40007368:	01059593          	slli	a1,a1,0x10
4000736c:	04875783          	lhu	a5,72(a4)
40007370:	0105d593          	srli	a1,a1,0x10
	z_shell_op_cursor_move(sh, -chars_to_delete);
40007374:	00040513          	mv	a0,s0
	sh->ctx->cmd_buff_len -= chars_to_delete;
40007378:	00f587b3          	add	a5,a1,a5
4000737c:	04f71423          	sh	a5,72(a4)
	sh->ctx->cmd_buff[sh->ctx->cmd_buff_len] = '\0';
40007380:	00842783          	lw	a5,8(s0)
	z_shell_op_cursor_move(sh, -chars_to_delete);
40007384:	01059593          	slli	a1,a1,0x10
40007388:	4105d593          	srai	a1,a1,0x10
	sh->ctx->cmd_buff[sh->ctx->cmd_buff_len] = '\0';
4000738c:	0487d703          	lhu	a4,72(a5)
40007390:	00e787b3          	add	a5,a5,a4
40007394:	04078723          	sb	zero,78(a5)
	z_shell_op_cursor_move(sh, -chars_to_delete);
40007398:	999ff0ef          	jal	ra,40006d30 <z_shell_op_cursor_move>
	return sh->ctx->cfg.flags.use_vt100 == 1;
4000739c:	00842783          	lw	a5,8(s0)
400073a0:	26c7a783          	lw	a5,620(a5)
400073a4:	0057d793          	srli	a5,a5,0x5
400073a8:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SAVECURSOR);
400073ac:	00078a63          	beqz	a5,400073c0 <z_shell_op_word_remove+0x104>
400073b0:	01442503          	lw	a0,20(s0)
400073b4:	4002c5b7          	lui	a1,0x4002c
400073b8:	c0458593          	addi	a1,a1,-1020 # 4002bc04 <eth_config+0x2c>
400073bc:	edcff0ef          	jal	ra,40006a98 <z_shell_raw_fprintf>
	z_shell_fprintf(sh, SHELL_NORMAL, "%s", str + 1);
400073c0:	4002c637          	lui	a2,0x4002c
400073c4:	00098693          	mv	a3,s3
400073c8:	78460613          	addi	a2,a2,1924 # 4002c784 <shell_telnet_fprintf+0x128>
400073cc:	00800593          	li	a1,8
400073d0:	00040513          	mv	a0,s0
400073d4:	eb5ff0ef          	jal	ra,40007288 <z_shell_fprintf>
	z_clear_eos(sh);
400073d8:	00040513          	mv	a0,s0
400073dc:	ef4ff0ef          	jal	ra,40006ad0 <z_clear_eos>
	return sh->ctx->cfg.flags.use_vt100 == 1;
400073e0:	00842783          	lw	a5,8(s0)
400073e4:	26c7a783          	lw	a5,620(a5)
400073e8:	0057d793          	srli	a5,a5,0x5
400073ec:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
400073f0:	02078663          	beqz	a5,4000741c <z_shell_op_word_remove+0x160>
400073f4:	01442503          	lw	a0,20(s0)
}
400073f8:	01812403          	lw	s0,24(sp)
400073fc:	01c12083          	lw	ra,28(sp)
40007400:	01412483          	lw	s1,20(sp)
40007404:	01012903          	lw	s2,16(sp)
40007408:	00c12983          	lw	s3,12(sp)
4000740c:	4002c5b7          	lui	a1,0x4002c
40007410:	c0858593          	addi	a1,a1,-1016 # 4002bc08 <eth_config+0x30>
40007414:	02010113          	addi	sp,sp,32
40007418:	e80ff06f          	j	40006a98 <z_shell_raw_fprintf>
4000741c:	01c12083          	lw	ra,28(sp)
40007420:	01812403          	lw	s0,24(sp)
40007424:	01412483          	lw	s1,20(sp)
40007428:	01012903          	lw	s2,16(sp)
4000742c:	00c12983          	lw	s3,12(sp)
40007430:	02010113          	addi	sp,sp,32
40007434:	00008067          	ret

40007438 <reprint_from_cursor>:
{
40007438:	fe010113          	addi	sp,sp,-32
4000743c:	00812c23          	sw	s0,24(sp)
40007440:	00912a23          	sw	s1,20(sp)
40007444:	01312623          	sw	s3,12(sp)
40007448:	00112e23          	sw	ra,28(sp)
4000744c:	01212823          	sw	s2,16(sp)
40007450:	01412423          	sw	s4,8(sp)
40007454:	00050413          	mv	s0,a0
40007458:	00058493          	mv	s1,a1
4000745c:	00060993          	mv	s3,a2
	if (data_removed) {
40007460:	00060463          	beqz	a2,40007468 <reprint_from_cursor+0x30>
		z_clear_eos(sh);
40007464:	e6cff0ef          	jal	ra,40006ad0 <z_clear_eos>
	return sh->ctx->cfg.flags.obscure == 1;
40007468:	00842683          	lw	a3,8(s0)
4000746c:	26c6a783          	lw	a5,620(a3)
		int len = strlen(&sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos]);
40007470:	04a6d703          	lhu	a4,74(a3)
40007474:	0027d793          	srli	a5,a5,0x2
40007478:	04e70713          	addi	a4,a4,78
4000747c:	0017f793          	andi	a5,a5,1
40007480:	00e686b3          	add	a3,a3,a4
	if (z_flag_obscure_get(sh)) {
40007484:	08078263          	beqz	a5,40007508 <reprint_from_cursor+0xd0>
		int len = strlen(&sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos]);
40007488:	00068513          	mv	a0,a3
4000748c:	29d010ef          	jal	ra,40008f28 <strlen>
40007490:	00050913          	mv	s2,a0
			z_shell_raw_fprintf(sh->fprintf_ctx, "*");
40007494:	4002ca37          	lui	s4,0x4002c
		while (len--) {
40007498:	04091e63          	bnez	s2,400074f4 <reprint_from_cursor+0xbc>
	sh->ctx->cmd_buff_pos = sh->ctx->cmd_buff_len;
4000749c:	00842783          	lw	a5,8(s0)
	if (full_line_cmd(sh)) {
400074a0:	00040513          	mv	a0,s0
	sh->ctx->cmd_buff_pos = sh->ctx->cmd_buff_len;
400074a4:	0487d703          	lhu	a4,72(a5)
400074a8:	04e79523          	sh	a4,74(a5)
	if (full_line_cmd(sh)) {
400074ac:	e58ff0ef          	jal	ra,40006b04 <full_line_cmd>
400074b0:	00050a63          	beqz	a0,400074c4 <reprint_from_cursor+0x8c>
		if (((data_removed) && (diff > 0)) || (!data_removed)) {
400074b4:	00098463          	beqz	s3,400074bc <reprint_from_cursor+0x84>
400074b8:	00048663          	beqz	s1,400074c4 <reprint_from_cursor+0x8c>
			z_cursor_next_line_move(sh);
400074bc:	01442503          	lw	a0,20(s0)
400074c0:	e38ff0ef          	jal	ra,40006af8 <z_cursor_next_line_move.isra.0>
	z_shell_op_cursor_move(sh, -diff);
400074c4:	00040513          	mv	a0,s0
}
400074c8:	01812403          	lw	s0,24(sp)
400074cc:	01c12083          	lw	ra,28(sp)
400074d0:	01012903          	lw	s2,16(sp)
400074d4:	00c12983          	lw	s3,12(sp)
400074d8:	00812a03          	lw	s4,8(sp)
	z_shell_op_cursor_move(sh, -diff);
400074dc:	409005b3          	neg	a1,s1
}
400074e0:	01412483          	lw	s1,20(sp)
	z_shell_op_cursor_move(sh, -diff);
400074e4:	01059593          	slli	a1,a1,0x10
400074e8:	4105d593          	srai	a1,a1,0x10
}
400074ec:	02010113          	addi	sp,sp,32
	z_shell_op_cursor_move(sh, -diff);
400074f0:	841ff06f          	j	40006d30 <z_shell_op_cursor_move>
			z_shell_raw_fprintf(sh->fprintf_ctx, "*");
400074f4:	01442503          	lw	a0,20(s0)
400074f8:	e54a0593          	addi	a1,s4,-428 # 4002be54 <__clz_tab+0x228>
400074fc:	fff90913          	addi	s2,s2,-1
40007500:	d98ff0ef          	jal	ra,40006a98 <z_shell_raw_fprintf>
40007504:	f95ff06f          	j	40007498 <reprint_from_cursor+0x60>
		z_shell_fprintf(sh, SHELL_NORMAL, "%s",
40007508:	4002c637          	lui	a2,0x4002c
4000750c:	78460613          	addi	a2,a2,1924 # 4002c784 <shell_telnet_fprintf+0x128>
40007510:	00800593          	li	a1,8
40007514:	00040513          	mv	a0,s0
40007518:	d71ff0ef          	jal	ra,40007288 <z_shell_fprintf>
4000751c:	f81ff06f          	j	4000749c <reprint_from_cursor+0x64>

40007520 <data_insert>:
{
40007520:	fe010113          	addi	sp,sp,-32
40007524:	00112e23          	sw	ra,28(sp)
40007528:	00812c23          	sw	s0,24(sp)
4000752c:	00912a23          	sw	s1,20(sp)
40007530:	01212823          	sw	s2,16(sp)
40007534:	01312623          	sw	s3,12(sp)
40007538:	01412423          	sw	s4,8(sp)
	uint16_t after = sh->ctx->cmd_buff_len - sh->ctx->cmd_buff_pos;
4000753c:	00852983          	lw	s3,8(a0)
	if ((sh->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
40007540:	0ff00793          	li	a5,255
	uint16_t after = sh->ctx->cmd_buff_len - sh->ctx->cmd_buff_pos;
40007544:	0489d903          	lhu	s2,72(s3)
	if ((sh->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
40007548:	00c90733          	add	a4,s2,a2
4000754c:	08e7c463          	blt	a5,a4,400075d4 <data_insert+0xb4>
	uint16_t after = sh->ctx->cmd_buff_len - sh->ctx->cmd_buff_pos;
40007550:	04a9d783          	lhu	a5,74(s3)
40007554:	00060413          	mv	s0,a2
40007558:	00050493          	mv	s1,a0
4000755c:	40f90933          	sub	s2,s2,a5
40007560:	01091913          	slli	s2,s2,0x10
	char *curr_pos = &sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos];
40007564:	04e78793          	addi	a5,a5,78
40007568:	00f989b3          	add	s3,s3,a5
	uint16_t after = sh->ctx->cmd_buff_len - sh->ctx->cmd_buff_pos;
4000756c:	01095913          	srli	s2,s2,0x10
40007570:	00058a13          	mv	s4,a1
	memmove(curr_pos + len, curr_pos, after);
40007574:	00090613          	mv	a2,s2
40007578:	00098593          	mv	a1,s3
4000757c:	00898533          	add	a0,s3,s0
40007580:	285010ef          	jal	ra,40009004 <memmove>
	memcpy(curr_pos, data, len);
40007584:	00040613          	mv	a2,s0
40007588:	000a0593          	mv	a1,s4
4000758c:	00098513          	mv	a0,s3
40007590:	2bd010ef          	jal	ra,4000904c <memcpy>
	sh->ctx->cmd_buff_len += len;
40007594:	0084a703          	lw	a4,8(s1)
40007598:	04875783          	lhu	a5,72(a4)
4000759c:	00f407b3          	add	a5,s0,a5
400075a0:	04f71423          	sh	a5,72(a4)
	sh->ctx->cmd_buff[sh->ctx->cmd_buff_len] = '\0';
400075a4:	0084a783          	lw	a5,8(s1)
400075a8:	0487d703          	lhu	a4,72(a5)
400075ac:	00e787b3          	add	a5,a5,a4
400075b0:	04078723          	sb	zero,78(a5)
	return sh->ctx->cfg.flags.echo == 1;
400075b4:	0084a703          	lw	a4,8(s1)
400075b8:	26c72783          	lw	a5,620(a4)
400075bc:	0017d793          	srli	a5,a5,0x1
400075c0:	0017f793          	andi	a5,a5,1
	if (!z_flag_echo_get(sh)) {
400075c4:	02079863          	bnez	a5,400075f4 <data_insert+0xd4>
		sh->ctx->cmd_buff_pos += len;
400075c8:	04a75783          	lhu	a5,74(a4)
400075cc:	00f40433          	add	s0,s0,a5
400075d0:	04871523          	sh	s0,74(a4)
}
400075d4:	01c12083          	lw	ra,28(sp)
400075d8:	01812403          	lw	s0,24(sp)
400075dc:	01412483          	lw	s1,20(sp)
400075e0:	01012903          	lw	s2,16(sp)
400075e4:	00c12983          	lw	s3,12(sp)
400075e8:	00812a03          	lw	s4,8(sp)
400075ec:	02010113          	addi	sp,sp,32
400075f0:	00008067          	ret
400075f4:	01812403          	lw	s0,24(sp)
400075f8:	01c12083          	lw	ra,28(sp)
400075fc:	00c12983          	lw	s3,12(sp)
40007600:	00812a03          	lw	s4,8(sp)
	reprint_from_cursor(sh, after, false);
40007604:	00090593          	mv	a1,s2
40007608:	00048513          	mv	a0,s1
}
4000760c:	01012903          	lw	s2,16(sp)
40007610:	01412483          	lw	s1,20(sp)
	reprint_from_cursor(sh, after, false);
40007614:	00000613          	li	a2,0
}
40007618:	02010113          	addi	sp,sp,32
	reprint_from_cursor(sh, after, false);
4000761c:	e1dff06f          	j	40007438 <reprint_from_cursor>

40007620 <z_shell_op_char_insert>:
{
40007620:	fe010113          	addi	sp,sp,-32
40007624:	00812c23          	sw	s0,24(sp)
40007628:	00112e23          	sw	ra,28(sp)
	return sh->ctx->cfg.flags.insert_mode == 1;
4000762c:	00852783          	lw	a5,8(a0)
40007630:	00b107a3          	sb	a1,15(sp)
40007634:	00050413          	mv	s0,a0
40007638:	26c7a703          	lw	a4,620(a5)
4000763c:	00177713          	andi	a4,a4,1
	if (z_flag_insert_mode_get(sh) &&
40007640:	08070063          	beqz	a4,400076c0 <z_shell_op_char_insert+0xa0>
	    (sh->ctx->cmd_buff_len != sh->ctx->cmd_buff_pos)) {
40007644:	04a7d703          	lhu	a4,74(a5)
	if (z_flag_insert_mode_get(sh) &&
40007648:	0487d683          	lhu	a3,72(a5)
4000764c:	06e68a63          	beq	a3,a4,400076c0 <z_shell_op_char_insert+0xa0>
	sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos++] = data;
40007650:	00170693          	addi	a3,a4,1
40007654:	04d79523          	sh	a3,74(a5)
		char_replace(sh, data);
40007658:	0ff5f613          	zext.b	a2,a1
	sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos++] = data;
4000765c:	00e787b3          	add	a5,a5,a4
40007660:	04c78723          	sb	a2,78(a5)
	return sh->ctx->cfg.flags.echo == 1;
40007664:	00852703          	lw	a4,8(a0)
40007668:	26c72783          	lw	a5,620(a4)
4000766c:	0017d793          	srli	a5,a5,0x1
40007670:	0017f793          	andi	a5,a5,1
	if (!z_flag_echo_get(sh)) {
40007674:	02078e63          	beqz	a5,400076b0 <z_shell_op_char_insert+0x90>
	return sh->ctx->cfg.flags.obscure == 1;
40007678:	26c72783          	lw	a5,620(a4)
4000767c:	0027d793          	srli	a5,a5,0x2
40007680:	0017f793          	andi	a5,a5,1
	if (z_flag_obscure_get(sh)) {
40007684:	00078463          	beqz	a5,4000768c <z_shell_op_char_insert+0x6c>
		data = '*';
40007688:	02a00613          	li	a2,42
	z_shell_raw_fprintf(sh->fprintf_ctx, "%c", data);
4000768c:	01442503          	lw	a0,20(s0)
40007690:	4002d5b7          	lui	a1,0x4002d
40007694:	a7858593          	addi	a1,a1,-1416 # 4002ca78 <_shell_help+0x18>
40007698:	c00ff0ef          	jal	ra,40006a98 <z_shell_raw_fprintf>
	if (z_shell_cursor_in_empty_line(sh)) {
4000769c:	00040513          	mv	a0,s0
400076a0:	d48ff0ef          	jal	ra,40006be8 <z_shell_cursor_in_empty_line>
400076a4:	00050663          	beqz	a0,400076b0 <z_shell_op_char_insert+0x90>
		z_cursor_next_line_move(sh);
400076a8:	01442503          	lw	a0,20(s0)
400076ac:	c4cff0ef          	jal	ra,40006af8 <z_cursor_next_line_move.isra.0>
}
400076b0:	01c12083          	lw	ra,28(sp)
400076b4:	01812403          	lw	s0,24(sp)
400076b8:	02010113          	addi	sp,sp,32
400076bc:	00008067          	ret
		data_insert(sh, &data, 1);
400076c0:	00100613          	li	a2,1
400076c4:	00f10593          	addi	a1,sp,15
400076c8:	00040513          	mv	a0,s0
400076cc:	e55ff0ef          	jal	ra,40007520 <data_insert>
}
400076d0:	fe1ff06f          	j	400076b0 <z_shell_op_char_insert+0x90>

400076d4 <z_shell_op_completion_insert>:
	data_insert(sh, compl, compl_len);
400076d4:	e4dff06f          	j	40007520 <data_insert>

400076d8 <z_shell_op_char_delete>:
{
400076d8:	ff010113          	addi	sp,sp,-16
400076dc:	00112623          	sw	ra,12(sp)
400076e0:	00812423          	sw	s0,8(sp)
400076e4:	00912223          	sw	s1,4(sp)
	uint16_t diff = sh->ctx->cmd_buff_len - sh->ctx->cmd_buff_pos;
400076e8:	00852783          	lw	a5,8(a0)
400076ec:	04a7d703          	lhu	a4,74(a5)
400076f0:	0487d403          	lhu	s0,72(a5)
400076f4:	40e40433          	sub	s0,s0,a4
400076f8:	01041413          	slli	s0,s0,0x10
400076fc:	01045413          	srli	s0,s0,0x10
	if (diff == 0U) {
40007700:	04040a63          	beqz	s0,40007754 <z_shell_op_char_delete+0x7c>
	char *str = &sh->ctx->cmd_buff[sh->ctx->cmd_buff_pos];
40007704:	04e70713          	addi	a4,a4,78
40007708:	00050493          	mv	s1,a0
4000770c:	00e78533          	add	a0,a5,a4
	memmove(str, str + 1, diff);
40007710:	00040613          	mv	a2,s0
40007714:	00150593          	addi	a1,a0,1
40007718:	0ed010ef          	jal	ra,40009004 <memmove>
	--sh->ctx->cmd_buff_len;
4000771c:	0084a703          	lw	a4,8(s1)
	reprint_from_cursor(sh, --diff, true);
40007720:	fff40593          	addi	a1,s0,-1
40007724:	00048513          	mv	a0,s1
	--sh->ctx->cmd_buff_len;
40007728:	04875783          	lhu	a5,72(a4)
	reprint_from_cursor(sh, --diff, true);
4000772c:	01059593          	slli	a1,a1,0x10
40007730:	00100613          	li	a2,1
	--sh->ctx->cmd_buff_len;
40007734:	fff78793          	addi	a5,a5,-1
40007738:	04f71423          	sh	a5,72(a4)
}
4000773c:	00812403          	lw	s0,8(sp)
40007740:	00c12083          	lw	ra,12(sp)
40007744:	00412483          	lw	s1,4(sp)
	reprint_from_cursor(sh, --diff, true);
40007748:	0105d593          	srli	a1,a1,0x10
}
4000774c:	01010113          	addi	sp,sp,16
	reprint_from_cursor(sh, --diff, true);
40007750:	ce9ff06f          	j	40007438 <reprint_from_cursor>
}
40007754:	00c12083          	lw	ra,12(sp)
40007758:	00812403          	lw	s0,8(sp)
4000775c:	00412483          	lw	s1,4(sp)
40007760:	01010113          	addi	sp,sp,16
40007764:	00008067          	ret

40007768 <z_shell_op_char_backspace>:
	if ((sh->ctx->cmd_buff_len == 0) ||
40007768:	00852783          	lw	a5,8(a0)
4000776c:	0487d703          	lhu	a4,72(a5)
40007770:	02070c63          	beqz	a4,400077a8 <z_shell_op_char_backspace+0x40>
40007774:	04a7d783          	lhu	a5,74(a5)
40007778:	02078863          	beqz	a5,400077a8 <z_shell_op_char_backspace+0x40>
{
4000777c:	ff010113          	addi	sp,sp,-16
	z_shell_op_cursor_move(sh, -1);
40007780:	fff00593          	li	a1,-1
{
40007784:	00812423          	sw	s0,8(sp)
40007788:	00112623          	sw	ra,12(sp)
4000778c:	00050413          	mv	s0,a0
	z_shell_op_cursor_move(sh, -1);
40007790:	da0ff0ef          	jal	ra,40006d30 <z_shell_op_cursor_move>
	z_shell_op_char_delete(sh);
40007794:	00040513          	mv	a0,s0
}
40007798:	00812403          	lw	s0,8(sp)
4000779c:	00c12083          	lw	ra,12(sp)
400077a0:	01010113          	addi	sp,sp,16
	z_shell_op_char_delete(sh);
400077a4:	f35ff06f          	j	400076d8 <z_shell_op_char_delete>
400077a8:	00008067          	ret

400077ac <z_shell_print_prompt_and_cmd>:
{
400077ac:	ff010113          	addi	sp,sp,-16
400077b0:	00812423          	sw	s0,8(sp)
400077b4:	00112623          	sw	ra,12(sp)
	z_shell_fprintf(sh, SHELL_INFO, "%s", sh->ctx->prompt);
400077b8:	00852783          	lw	a5,8(a0)
400077bc:	4002c637          	lui	a2,0x4002c
400077c0:	78460613          	addi	a2,a2,1924 # 4002c784 <shell_telnet_fprintf+0x128>
400077c4:	0007a683          	lw	a3,0(a5)
400077c8:	00200593          	li	a1,2
{
400077cc:	00050413          	mv	s0,a0
	z_shell_fprintf(sh, SHELL_INFO, "%s", sh->ctx->prompt);
400077d0:	ab9ff0ef          	jal	ra,40007288 <z_shell_fprintf>
	return sh->ctx->cfg.flags.echo == 1;
400077d4:	00842783          	lw	a5,8(s0)
400077d8:	26c7a783          	lw	a5,620(a5)
400077dc:	0017d793          	srli	a5,a5,0x1
400077e0:	0017f793          	andi	a5,a5,1
	if (z_flag_echo_get(sh)) {
400077e4:	02078063          	beqz	a5,40007804 <z_shell_print_prompt_and_cmd+0x58>
		z_shell_print_cmd(sh);
400077e8:	00040513          	mv	a0,s0
400077ec:	ff0ff0ef          	jal	ra,40006fdc <z_shell_print_cmd>
		z_shell_op_cursor_position_synchronize(sh);
400077f0:	00040513          	mv	a0,s0
}
400077f4:	00812403          	lw	s0,8(sp)
400077f8:	00c12083          	lw	ra,12(sp)
400077fc:	01010113          	addi	sp,sp,16
		z_shell_op_cursor_position_synchronize(sh);
40007800:	c9cff06f          	j	40006c9c <z_shell_op_cursor_position_synchronize>
}
40007804:	00c12083          	lw	ra,12(sp)
40007808:	00812403          	lw	s0,8(sp)
4000780c:	01010113          	addi	sp,sp,16
40007810:	00008067          	ret

40007814 <z_shell_raw_fprintf>:
{
40007814:	fc010113          	addi	sp,sp,-64
40007818:	02c12423          	sw	a2,40(sp)
	va_start(args, fmt);
4000781c:	02810613          	addi	a2,sp,40
{
40007820:	00112e23          	sw	ra,28(sp)
40007824:	02d12623          	sw	a3,44(sp)
40007828:	02e12823          	sw	a4,48(sp)
4000782c:	02f12a23          	sw	a5,52(sp)
40007830:	03012c23          	sw	a6,56(sp)
40007834:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
40007838:	00c12623          	sw	a2,12(sp)
	z_shell_fprintf_fmt(ctx, fmt, args);
4000783c:	80dfe0ef          	jal	ra,40006048 <z_shell_fprintf_fmt>
}
40007840:	01c12083          	lw	ra,28(sp)
40007844:	04010113          	addi	sp,sp,64
40007848:	00008067          	ret

4000784c <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
4000784c:	4002e5b7          	lui	a1,0x4002e
40007850:	48c58593          	addi	a1,a1,1164 # 4002e48c <CSWTCH.14405+0xeb0>
40007854:	fc1ff06f          	j	40007814 <z_shell_raw_fprintf>

40007858 <formatted_text_print.constprop.0>:
				 size_t terminal_offset, bool offset_first_line)
{
	size_t offset = 0;
	size_t length;

	if (str == NULL) {
40007858:	1a058c63          	beqz	a1,40007a10 <formatted_text_print.constprop.0+0x1b8>
static void formatted_text_print(const struct shell *sh, const char *str,
4000785c:	fc010113          	addi	sp,sp,-64
40007860:	02812c23          	sw	s0,56(sp)
40007864:	02912a23          	sw	s1,52(sp)
40007868:	03312623          	sw	s3,44(sp)
4000786c:	03412423          	sw	s4,40(sp)
40007870:	02112e23          	sw	ra,60(sp)
40007874:	03212823          	sw	s2,48(sp)
40007878:	03512223          	sw	s5,36(sp)
4000787c:	03612023          	sw	s6,32(sp)
40007880:	01712e23          	sw	s7,28(sp)
40007884:	01812c23          	sw	s8,24(sp)
40007888:	00050493          	mv	s1,a0
4000788c:	00058993          	mv	s3,a1
40007890:	00060a13          	mv	s4,a2
40007894:	00000413          	li	s0,0
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
40007898:	02000713          	li	a4,32
4000789c:	00400693          	li	a3,4
		z_shell_op_cursor_horiz_move(sh, terminal_offset);
	}


	/* Skipping whitespace. */
	while (isspace((int) *(str + offset)) != 0) {
400078a0:	008987b3          	add	a5,s3,s0
400078a4:	0007c783          	lbu	a5,0(a5)
400078a8:	06e78a63          	beq	a5,a4,4000791c <formatted_text_print.constprop.0+0xc4>
400078ac:	ff778793          	addi	a5,a5,-9
400078b0:	06f6f663          	bgeu	a3,a5,4000791c <formatted_text_print.constprop.0+0xc4>
	}

	while (true) {
		size_t idx = 0;

		length = z_shell_strlen(str) - offset;
400078b4:	00010ab7          	lui	s5,0x10
400078b8:	fffa8a93          	addi	s5,s5,-1 # ffff <__kernel_ram_size+0x3d6b>
400078bc:	02000b13          	li	s6,32
400078c0:	00400b93          	li	s7,4

		while (true) {
			/* Determining line break. */
			if (isspace((int) (*(str + offset + idx))) != 0) {
				length = idx;
				if (*(str + offset + idx) == '\n') {
400078c4:	00a00c13          	li	s8,10
400078c8:	00098513          	mv	a0,s3
400078cc:	65c010ef          	jal	ra,40008f28 <strlen>
		    sh->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
400078d0:	0084a783          	lw	a5,8(s1)
		length = z_shell_strlen(str) - offset;
400078d4:	01557533          	and	a0,a0,s5
400078d8:	40850533          	sub	a0,a0,s0
		    sh->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
400078dc:	02e7d683          	lhu	a3,46(a5)
400078e0:	008985b3          	add	a1,s3,s0
			for (idx = 0; idx < length; idx++) {
400078e4:	00000913          	li	s2,0
		    sh->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
400078e8:	414687b3          	sub	a5,a3,s4
		if (length <=
400078ec:	0ca7f263          	bgeu	a5,a0,400079b0 <formatted_text_print.constprop.0+0x158>
			if (isspace((int) (*(str + offset + idx))) != 0) {
400078f0:	01258733          	add	a4,a1,s2
400078f4:	00074703          	lbu	a4,0(a4)
400078f8:	01670863          	beq	a4,s6,40007908 <formatted_text_print.constprop.0+0xb0>
400078fc:	ff770613          	addi	a2,a4,-9
40007900:	00cbe663          	bltu	s7,a2,4000790c <formatted_text_print.constprop.0+0xb4>
				if (*(str + offset + idx) == '\n') {
40007904:	0b870c63          	beq	a4,s8,400079bc <formatted_text_print.constprop.0+0x164>
40007908:	00090793          	mv	a5,s2
					break;
				}
			}

			if ((idx + terminal_offset) >=
4000790c:	012a0733          	add	a4,s4,s2
40007910:	0ad77463          	bgeu	a4,a3,400079b8 <formatted_text_print.constprop.0+0x160>
			    sh->ctx->vt100_ctx.cons.terminal_wid) {
				/* End of line reached. */
				break;
			}

			++idx;
40007914:	00190913          	addi	s2,s2,1
			if (isspace((int) (*(str + offset + idx))) != 0) {
40007918:	fd9ff06f          	j	400078f0 <formatted_text_print.constprop.0+0x98>
		++offset;
4000791c:	00140413          	addi	s0,s0,1
40007920:	f81ff06f          	j	400078a0 <formatted_text_print.constprop.0+0x48>
			for (idx = 0; idx < length; idx++) {
40007924:	00190913          	addi	s2,s2,1
40007928:	05250463          	beq	a0,s2,40007970 <formatted_text_print.constprop.0+0x118>
				if (*(str + offset + idx) == '\n') {
4000792c:	01258733          	add	a4,a1,s2
40007930:	00074703          	lbu	a4,0(a4)
40007934:	fef718e3          	bne	a4,a5,40007924 <formatted_text_print.constprop.0+0xcc>
	z_shell_fprintf_buffer_flush(sh->fprintf_ctx);
40007938:	0144a503          	lw	a0,20(s1)
4000793c:	00b12623          	sw	a1,12(sp)
40007940:	00140413          	addi	s0,s0,1
40007944:	ec4fe0ef          	jal	ra,40006008 <z_shell_fprintf_buffer_flush>
					z_shell_write(sh, str + offset, idx);
40007948:	00c12583          	lw	a1,12(sp)
4000794c:	00090613          	mv	a2,s2
40007950:	00048513          	mv	a0,s1
40007954:	ea0ff0ef          	jal	ra,40006ff4 <z_shell_write>
					z_cursor_next_line_move(sh);
40007958:	0144a503          	lw	a0,20(s1)
					offset += idx + 1;
4000795c:	00890433          	add	s0,s2,s0
					z_cursor_next_line_move(sh);
40007960:	eedff0ef          	jal	ra,4000784c <z_cursor_next_line_move.isra.0>
					z_shell_op_cursor_horiz_move(sh,
40007964:	000a0593          	mv	a1,s4
40007968:	00048513          	mv	a0,s1
4000796c:	a38ff0ef          	jal	ra,40006ba4 <z_shell_op_cursor_horiz_move>
			z_shell_raw_fprintf(sh->fprintf_ctx, str + offset);
40007970:	0144a503          	lw	a0,20(s1)
40007974:	008985b3          	add	a1,s3,s0
40007978:	e9dff0ef          	jal	ra,40007814 <z_shell_raw_fprintf>
		z_cursor_next_line_move(sh);
		z_shell_op_cursor_horiz_move(sh, terminal_offset);

	}
	z_cursor_next_line_move(sh);
}
4000797c:	03812403          	lw	s0,56(sp)
	z_cursor_next_line_move(sh);
40007980:	0144a503          	lw	a0,20(s1)
}
40007984:	03c12083          	lw	ra,60(sp)
40007988:	03412483          	lw	s1,52(sp)
4000798c:	03012903          	lw	s2,48(sp)
40007990:	02c12983          	lw	s3,44(sp)
40007994:	02812a03          	lw	s4,40(sp)
40007998:	02412a83          	lw	s5,36(sp)
4000799c:	02012b03          	lw	s6,32(sp)
400079a0:	01c12b83          	lw	s7,28(sp)
400079a4:	01812c03          	lw	s8,24(sp)
400079a8:	04010113          	addi	sp,sp,64
	z_cursor_next_line_move(sh);
400079ac:	ea1ff06f          	j	4000784c <z_cursor_next_line_move.isra.0>
				if (*(str + offset + idx) == '\n') {
400079b0:	00a00793          	li	a5,10
400079b4:	f75ff06f          	j	40007928 <formatted_text_print.constprop.0+0xd0>
400079b8:	00078913          	mv	s2,a5
400079bc:	0144a503          	lw	a0,20(s1)
400079c0:	00b12623          	sw	a1,12(sp)
		offset += length;
400079c4:	01240433          	add	s0,s0,s2
400079c8:	e40fe0ef          	jal	ra,40006008 <z_shell_fprintf_buffer_flush>
		z_shell_write(sh, str + offset, length);
400079cc:	00c12583          	lw	a1,12(sp)
400079d0:	00090613          	mv	a2,s2
400079d4:	00048513          	mv	a0,s1
400079d8:	e1cff0ef          	jal	ra,40006ff4 <z_shell_write>
		while (isspace((int) (*(str + offset))) != 0) {
400079dc:	008987b3          	add	a5,s3,s0
400079e0:	0007c783          	lbu	a5,0(a5)
400079e4:	01678663          	beq	a5,s6,400079f0 <formatted_text_print.constprop.0+0x198>
400079e8:	ff778793          	addi	a5,a5,-9
400079ec:	00fbe663          	bltu	s7,a5,400079f8 <formatted_text_print.constprop.0+0x1a0>
			++offset;
400079f0:	00140413          	addi	s0,s0,1
400079f4:	fe9ff06f          	j	400079dc <formatted_text_print.constprop.0+0x184>
		z_cursor_next_line_move(sh);
400079f8:	0144a503          	lw	a0,20(s1)
400079fc:	e51ff0ef          	jal	ra,4000784c <z_cursor_next_line_move.isra.0>
		z_shell_op_cursor_horiz_move(sh, terminal_offset);
40007a00:	000a0593          	mv	a1,s4
40007a04:	00048513          	mv	a0,s1
40007a08:	99cff0ef          	jal	ra,40006ba4 <z_shell_op_cursor_horiz_move>
	while (true) {
40007a0c:	ebdff06f          	j	400078c8 <formatted_text_print.constprop.0+0x70>
40007a10:	00008067          	ret

40007a14 <z_shell_help_subcmd_print>:
 * help string
 */
void z_shell_help_subcmd_print(const struct shell *sh,
			       const struct shell_static_entry *parent,
			       const char *description)
{
40007a14:	fa010113          	addi	sp,sp,-96
40007a18:	04812c23          	sw	s0,88(sp)
40007a1c:	04912a23          	sw	s1,84(sp)
40007a20:	05212823          	sw	s2,80(sp)
40007a24:	05312623          	sw	s3,76(sp)
40007a28:	04112e23          	sw	ra,92(sp)
40007a2c:	00058993          	mv	s3,a1
40007a30:	05412423          	sw	s4,72(sp)
40007a34:	05512223          	sw	s5,68(sp)
40007a38:	05612023          	sw	s6,64(sp)
40007a3c:	03712e23          	sw	s7,60(sp)
40007a40:	03812c23          	sw	s8,56(sp)
40007a44:	03912a23          	sw	s9,52(sp)
40007a48:	00050413          	mv	s0,a0
40007a4c:	00060493          	mv	s1,a2
	const struct shell_static_entry *entry = NULL;
	struct shell_static_entry dloc;
	uint16_t longest = 0U;
	size_t idx = 0;
40007a50:	00000593          	li	a1,0
	uint16_t longest = 0U;
40007a54:	00000913          	li	s2,0

	/* Searching for the longest subcommand to print. */
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
40007a58:	01c10613          	addi	a2,sp,28
40007a5c:	00098513          	mv	a0,s3
40007a60:	00158a13          	addi	s4,a1,1
40007a64:	b81fe0ef          	jal	ra,400065e4 <z_shell_cmd_get>
40007a68:	06051c63          	bnez	a0,40007ae0 <z_shell_help_subcmd_print+0xcc>
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
	}

	/* No help to print */
	if (longest == 0) {
40007a6c:	04090063          	beqz	s2,40007aac <z_shell_help_subcmd_print+0x98>
		return;
	}

	if (description != NULL) {
40007a70:	00048a63          	beqz	s1,40007a84 <z_shell_help_subcmd_print+0x70>
		z_shell_fprintf(sh, SHELL_NORMAL, description);
40007a74:	00048613          	mv	a2,s1
40007a78:	00800593          	li	a1,8
40007a7c:	00040513          	mv	a0,s0
40007a80:	809ff0ef          	jal	ra,40007288 <z_shell_fprintf>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
40007a84:	00000593          	li	a1,0
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
40007a88:	4002ca37          	lui	s4,0x4002c
		z_shell_fprintf(sh, SHELL_NORMAL, "%s%-*s", tabulator,
40007a8c:	4002dbb7          	lui	s7,0x4002d
		z_shell_fprintf(sh, SHELL_NORMAL, "%s:", tabulator);
40007a90:	4002dc37          	lui	s8,0x4002d
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
40007a94:	00190c93          	addi	s9,s2,1
	}

	/* Printing subcommands and help string (if exists). */
	idx = 0;

	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
40007a98:	01c10613          	addi	a2,sp,28
40007a9c:	00098513          	mv	a0,s3
40007aa0:	00158b13          	addi	s6,a1,1
40007aa4:	b41fe0ef          	jal	ra,400065e4 <z_shell_cmd_get>
40007aa8:	06051663          	bnez	a0,40007b14 <z_shell_help_subcmd_print+0x100>
		help_item_print(sh, entry->syntax, longest, entry->help);
	}
}
40007aac:	05c12083          	lw	ra,92(sp)
40007ab0:	05812403          	lw	s0,88(sp)
40007ab4:	05412483          	lw	s1,84(sp)
40007ab8:	05012903          	lw	s2,80(sp)
40007abc:	04c12983          	lw	s3,76(sp)
40007ac0:	04812a03          	lw	s4,72(sp)
40007ac4:	04412a83          	lw	s5,68(sp)
40007ac8:	04012b03          	lw	s6,64(sp)
40007acc:	03c12b83          	lw	s7,60(sp)
40007ad0:	03812c03          	lw	s8,56(sp)
40007ad4:	03412c83          	lw	s9,52(sp)
40007ad8:	06010113          	addi	sp,sp,96
40007adc:	00008067          	ret
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
40007ae0:	00052503          	lw	a0,0(a0)
	return str == NULL ? 0U : (uint16_t)strlen(str);
40007ae4:	00000793          	li	a5,0
40007ae8:	00050863          	beqz	a0,40007af8 <z_shell_help_subcmd_print+0xe4>
40007aec:	43c010ef          	jal	ra,40008f28 <strlen>
40007af0:	01051793          	slli	a5,a0,0x10
40007af4:	0107d793          	srli	a5,a5,0x10
40007af8:	00090713          	mv	a4,s2
40007afc:	00f97463          	bgeu	s2,a5,40007b04 <z_shell_help_subcmd_print+0xf0>
40007b00:	00078713          	mv	a4,a5
40007b04:	01071913          	slli	s2,a4,0x10
40007b08:	01095913          	srli	s2,s2,0x10
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
40007b0c:	000a0593          	mv	a1,s4
40007b10:	f49ff06f          	j	40007a58 <z_shell_help_subcmd_print+0x44>
		help_item_print(sh, entry->syntax, longest, entry->help);
40007b14:	00052783          	lw	a5,0(a0)
40007b18:	00452a83          	lw	s5,4(a0)
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
40007b1c:	b00a0513          	addi	a0,s4,-1280 # 4002bb00 <tabulator.1>
		help_item_print(sh, entry->syntax, longest, entry->help);
40007b20:	00f12623          	sw	a5,12(sp)
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
40007b24:	404010ef          	jal	ra,40008f28 <strlen>
	if ((item_name == NULL) || (item_name[0] == '\0')) {
40007b28:	00c12783          	lw	a5,12(sp)
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
40007b2c:	00050493          	mv	s1,a0
	if ((item_name == NULL) || (item_name[0] == '\0')) {
40007b30:	02078863          	beqz	a5,40007b60 <z_shell_help_subcmd_print+0x14c>
40007b34:	0007c703          	lbu	a4,0(a5)
40007b38:	02070463          	beqz	a4,40007b60 <z_shell_help_subcmd_print+0x14c>
		z_shell_fprintf(sh, SHELL_NORMAL, "%s%-*s", tabulator,
40007b3c:	00090713          	mv	a4,s2
40007b40:	b00a0693          	addi	a3,s4,-1280
40007b44:	a94b8613          	addi	a2,s7,-1388 # 4002ca94 <_shell_help+0x34>
40007b48:	00800593          	li	a1,8
40007b4c:	00040513          	mv	a0,s0
40007b50:	f38ff0ef          	jal	ra,40007288 <z_shell_fprintf>
	if (item_help == NULL) {
40007b54:	000a9a63          	bnez	s5,40007b68 <z_shell_help_subcmd_print+0x154>
		z_cursor_next_line_move(sh);
40007b58:	01442503          	lw	a0,20(s0)
40007b5c:	cf1ff0ef          	jal	ra,4000784c <z_cursor_next_line_move.isra.0>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
40007b60:	000b0593          	mv	a1,s6
40007b64:	f35ff06f          	j	40007a98 <z_shell_help_subcmd_print+0x84>
		z_shell_fprintf(sh, SHELL_NORMAL, "%s:", tabulator);
40007b68:	a9cc0613          	addi	a2,s8,-1380 # 4002ca9c <_shell_help+0x3c>
40007b6c:	00040513          	mv	a0,s0
40007b70:	b00a0693          	addi	a3,s4,-1280
40007b74:	00800593          	li	a1,8
40007b78:	f10ff0ef          	jal	ra,40007288 <z_shell_fprintf>
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
40007b7c:	00149613          	slli	a2,s1,0x1
40007b80:	01960633          	add	a2,a2,s9
	formatted_text_print(sh, item_help, offset, false);
40007b84:	01061613          	slli	a2,a2,0x10
40007b88:	01065613          	srli	a2,a2,0x10
40007b8c:	000a8593          	mv	a1,s5
40007b90:	00040513          	mv	a0,s0
40007b94:	cc5ff0ef          	jal	ra,40007858 <formatted_text_print.constprop.0>
40007b98:	fc9ff06f          	j	40007b60 <z_shell_help_subcmd_print+0x14c>

40007b9c <z_shell_help_cmd_print>:

void z_shell_help_cmd_print(const struct shell *sh,
			    const struct shell_static_entry *cmd)
{
40007b9c:	fe010113          	addi	sp,sp,-32
40007ba0:	00812c23          	sw	s0,24(sp)
40007ba4:	00912a23          	sw	s1,20(sp)
40007ba8:	01212823          	sw	s2,16(sp)
40007bac:	00112e23          	sw	ra,28(sp)
40007bb0:	01312623          	sw	s3,12(sp)
40007bb4:	00050913          	mv	s2,a0
	static const char cmd_sep[] = " - "; /* commands separator */
	uint16_t field_width;

	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
40007bb8:	0005a503          	lw	a0,0(a1)
{
40007bbc:	00058493          	mv	s1,a1
40007bc0:	00000413          	li	s0,0
40007bc4:	00050863          	beqz	a0,40007bd4 <z_shell_help_cmd_print+0x38>
40007bc8:	360010ef          	jal	ra,40008f28 <strlen>
40007bcc:	01051413          	slli	s0,a0,0x10
40007bd0:	01045413          	srli	s0,s0,0x10
40007bd4:	4002c9b7          	lui	s3,0x4002c
40007bd8:	afc98513          	addi	a0,s3,-1284 # 4002bafc <cmd_sep.0>
40007bdc:	34c010ef          	jal	ra,40008f28 <strlen>

	z_shell_fprintf(sh, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
40007be0:	0004a683          	lw	a3,0(s1)
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
40007be4:	00a40433          	add	s0,s0,a0
	z_shell_fprintf(sh, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
40007be8:	4002d637          	lui	a2,0x4002d
40007bec:	00090513          	mv	a0,s2
40007bf0:	afc98713          	addi	a4,s3,-1284
40007bf4:	aa060613          	addi	a2,a2,-1376 # 4002caa0 <_shell_help+0x40>
40007bf8:	00800593          	li	a1,8
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
40007bfc:	01041413          	slli	s0,s0,0x10
	z_shell_fprintf(sh, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
40007c00:	e88ff0ef          	jal	ra,40007288 <z_shell_fprintf>
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
40007c04:	01045413          	srli	s0,s0,0x10

	formatted_text_print(sh, cmd->help, field_width, false);
40007c08:	00040613          	mv	a2,s0
}
40007c0c:	01812403          	lw	s0,24(sp)
	formatted_text_print(sh, cmd->help, field_width, false);
40007c10:	0044a583          	lw	a1,4(s1)
}
40007c14:	01c12083          	lw	ra,28(sp)
40007c18:	01412483          	lw	s1,20(sp)
40007c1c:	00c12983          	lw	s3,12(sp)
	formatted_text_print(sh, cmd->help, field_width, false);
40007c20:	00090513          	mv	a0,s2
}
40007c24:	01012903          	lw	s2,16(sp)
40007c28:	02010113          	addi	sp,sp,32
	formatted_text_print(sh, cmd->help, field_width, false);
40007c2c:	c2dff06f          	j	40007858 <formatted_text_print.constprop.0>

40007c30 <z_shell_help_request>:
{
	if (!IS_ENABLED(CONFIG_SHELL_HELP_OPT_PARSE)) {
		return false;
	}

	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
40007c30:	4002d5b7          	lui	a1,0x4002d
{
40007c34:	ff010113          	addi	sp,sp,-16
	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
40007c38:	aa858593          	addi	a1,a1,-1368 # 4002caa8 <_shell_help+0x48>
{
40007c3c:	00812423          	sw	s0,8(sp)
40007c40:	00112623          	sw	ra,12(sp)
40007c44:	00050413          	mv	s0,a0
	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
40007c48:	324010ef          	jal	ra,40008f6c <strcmp>
40007c4c:	02050463          	beqz	a0,40007c74 <z_shell_help_request+0x44>
40007c50:	4002d5b7          	lui	a1,0x4002d
40007c54:	aac58593          	addi	a1,a1,-1364 # 4002caac <_shell_help+0x4c>
40007c58:	00040513          	mv	a0,s0
40007c5c:	310010ef          	jal	ra,40008f6c <strcmp>
40007c60:	00153513          	seqz	a0,a0
		return true;
	}

	return false;
}
40007c64:	00c12083          	lw	ra,12(sp)
40007c68:	00812403          	lw	s0,8(sp)
40007c6c:	01010113          	addi	sp,sp,16
40007c70:	00008067          	ret
		return true;
40007c74:	00100513          	li	a0,1
40007c78:	fedff06f          	j	40007c64 <z_shell_help_request+0x34>

40007c7c <cmd_shell_stats_reset>:
				 size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	sh->stats->log_lost_cnt = 0;
40007c7c:	01852783          	lw	a5,24(a0)

	return 0;
}
40007c80:	00000513          	li	a0,0
	sh->stats->log_lost_cnt = 0;
40007c84:	0007a023          	sw	zero,0(a5)
}
40007c88:	00008067          	ret

40007c8c <z_shell_raw_fprintf>:
{
40007c8c:	fc010113          	addi	sp,sp,-64
40007c90:	02c12423          	sw	a2,40(sp)
	va_start(args, fmt);
40007c94:	02810613          	addi	a2,sp,40
{
40007c98:	00112e23          	sw	ra,28(sp)
40007c9c:	02d12623          	sw	a3,44(sp)
40007ca0:	02e12823          	sw	a4,48(sp)
40007ca4:	02f12a23          	sw	a5,52(sp)
40007ca8:	03012c23          	sw	a6,56(sp)
40007cac:	03112e23          	sw	a7,60(sp)
	va_start(args, fmt);
40007cb0:	00c12623          	sw	a2,12(sp)
	z_shell_fprintf_fmt(ctx, fmt, args);
40007cb4:	b94fe0ef          	jal	ra,40006048 <z_shell_fprintf_fmt>
}
40007cb8:	01c12083          	lw	ra,28(sp)
40007cbc:	04010113          	addi	sp,sp,64
40007cc0:	00008067          	ret

40007cc4 <cmd_resize_default>:

static int cmd_resize_default(const struct shell *sh,
			      size_t argc, char **argv)
{
40007cc4:	ff010113          	addi	sp,sp,-16
40007cc8:	00812423          	sw	s0,8(sp)
40007ccc:	00112623          	sw	ra,12(sp)
	return sh->ctx->cfg.flags.use_vt100 == 1;
40007cd0:	00852783          	lw	a5,8(a0)
40007cd4:	00050413          	mv	s0,a0
40007cd8:	26c7a783          	lw	a5,620(a5)
40007cdc:	0057d793          	srli	a5,a5,0x5
40007ce0:	0017f793          	andi	a5,a5,1
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SETCOL_80);
40007ce4:	00078a63          	beqz	a5,40007cf8 <cmd_resize_default+0x34>
40007ce8:	01452503          	lw	a0,20(a0)
40007cec:	4002c5b7          	lui	a1,0x4002c
40007cf0:	c0c58593          	addi	a1,a1,-1012 # 4002bc0c <eth_config+0x34>
40007cf4:	f99ff0ef          	jal	ra,40007c8c <z_shell_raw_fprintf>
	sh->ctx->vt100_ctx.cons.terminal_wid = SHELL_DEFAULT_TERMINAL_WIDTH;
40007cf8:	00842783          	lw	a5,8(s0)
40007cfc:	05000713          	li	a4,80
	sh->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;

	return 0;
}
40007d00:	00000513          	li	a0,0
	sh->ctx->vt100_ctx.cons.terminal_wid = SHELL_DEFAULT_TERMINAL_WIDTH;
40007d04:	02e79723          	sh	a4,46(a5)
	sh->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
40007d08:	00842783          	lw	a5,8(s0)
40007d0c:	01800713          	li	a4,24
40007d10:	02e79623          	sh	a4,44(a5)
}
40007d14:	00c12083          	lw	ra,12(sp)
40007d18:	00812403          	lw	s0,8(sp)
40007d1c:	01010113          	addi	sp,sp,16
40007d20:	00008067          	ret

40007d24 <cmd_shell_stats_show>:
{
40007d24:	ff010113          	addi	sp,sp,-16
40007d28:	00112623          	sw	ra,12(sp)
	shell_print(sh, "Lost logs: %lu", sh->stats->log_lost_cnt);
40007d2c:	01852783          	lw	a5,24(a0)
40007d30:	4002d637          	lui	a2,0x4002d
40007d34:	ab460613          	addi	a2,a2,-1356 # 4002cab4 <_shell_help+0x54>
40007d38:	0007a683          	lw	a3,0(a5)
40007d3c:	00800593          	li	a1,8
40007d40:	f71fd0ef          	jal	ra,40005cb0 <shell_fprintf>
}
40007d44:	00c12083          	lw	ra,12(sp)
40007d48:	00000513          	li	a0,0
40007d4c:	01010113          	addi	sp,sp,16
40007d50:	00008067          	ret

40007d54 <cmd_backends>:
	shell_print(sh, "Active shell backends:");
40007d54:	4002d637          	lui	a2,0x4002d
{
40007d58:	fe010113          	addi	sp,sp,-32
	shell_print(sh, "Active shell backends:");
40007d5c:	ac460613          	addi	a2,a2,-1340 # 4002cac4 <_shell_help+0x64>
40007d60:	00800593          	li	a1,8
{
40007d64:	00812c23          	sw	s0,24(sp)
40007d68:	00912a23          	sw	s1,20(sp)
40007d6c:	01212823          	sw	s2,16(sp)
40007d70:	01412423          	sw	s4,8(sp)
40007d74:	00112e23          	sw	ra,28(sp)
40007d78:	01312623          	sw	s3,12(sp)
40007d7c:	00050913          	mv	s2,a0
	STRUCT_SECTION_FOREACH(shell, obj) {
40007d80:	4002c437          	lui	s0,0x4002c
	shell_print(sh, "Active shell backends:");
40007d84:	f2dfd0ef          	jal	ra,40005cb0 <shell_fprintf>
	STRUCT_SECTION_FOREACH(shell, obj) {
40007d88:	4002c4b7          	lui	s1,0x4002c
40007d8c:	a4c40413          	addi	s0,s0,-1460 # 4002ba4c <shell_telnet>
	uint16_t cnt = 0;
40007d90:	00000693          	li	a3,0
	STRUCT_SECTION_FOREACH(shell, obj) {
40007d94:	aa448493          	addi	s1,s1,-1372 # 4002baa4 <shell_cmd_clear>
		shell_print(sh, "  %2d. :%s", cnt++, obj->ctx->prompt);
40007d98:	4002da37          	lui	s4,0x4002d
	STRUCT_SECTION_FOREACH(shell, obj) {
40007d9c:	02946463          	bltu	s0,s1,40007dc4 <cmd_backends+0x70>
}
40007da0:	01c12083          	lw	ra,28(sp)
40007da4:	01812403          	lw	s0,24(sp)
40007da8:	01412483          	lw	s1,20(sp)
40007dac:	01012903          	lw	s2,16(sp)
40007db0:	00c12983          	lw	s3,12(sp)
40007db4:	00812a03          	lw	s4,8(sp)
40007db8:	00000513          	li	a0,0
40007dbc:	02010113          	addi	sp,sp,32
40007dc0:	00008067          	ret
		shell_print(sh, "  %2d. :%s", cnt++, obj->ctx->prompt);
40007dc4:	00842783          	lw	a5,8(s0)
40007dc8:	00168993          	addi	s3,a3,1
40007dcc:	01099993          	slli	s3,s3,0x10
40007dd0:	0007a703          	lw	a4,0(a5)
40007dd4:	adca0613          	addi	a2,s4,-1316 # 4002cadc <_shell_help+0x7c>
40007dd8:	00800593          	li	a1,8
40007ddc:	00090513          	mv	a0,s2
40007de0:	0109d993          	srli	s3,s3,0x10
40007de4:	ecdfd0ef          	jal	ra,40005cb0 <shell_fprintf>
	STRUCT_SECTION_FOREACH(shell, obj) {
40007de8:	02c40413          	addi	s0,s0,44
		shell_print(sh, "  %2d. :%s", cnt++, obj->ctx->prompt);
40007dec:	00098693          	mv	a3,s3
40007df0:	fadff06f          	j	40007d9c <cmd_backends+0x48>

40007df4 <cmd_history>:
{
40007df4:	fe010113          	addi	sp,sp,-32
40007df8:	00812c23          	sw	s0,24(sp)
40007dfc:	00912a23          	sw	s1,20(sp)
40007e00:	01212823          	sw	s2,16(sp)
40007e04:	00112e23          	sw	ra,28(sp)
40007e08:	00050413          	mv	s0,a0
40007e0c:	00000493          	li	s1,0
			shell_print(sh, "[%3d] %s",
40007e10:	4002d937          	lui	s2,0x4002d
				    sh->ctx->temp_buff, &len);
40007e14:	00842603          	lw	a2,8(s0)
		z_shell_history_get(sh->history, true,
40007e18:	00c42503          	lw	a0,12(s0)
40007e1c:	00e10693          	addi	a3,sp,14
40007e20:	14e60613          	addi	a2,a2,334
40007e24:	00100593          	li	a1,1
40007e28:	5fc000ef          	jal	ra,40008424 <z_shell_history_get>
		if (len) {
40007e2c:	00e15783          	lhu	a5,14(sp)
40007e30:	00842703          	lw	a4,8(s0)
40007e34:	02078263          	beqz	a5,40007e58 <cmd_history+0x64>
			shell_print(sh, "[%3d] %s",
40007e38:	00048693          	mv	a3,s1
40007e3c:	14e70713          	addi	a4,a4,334
40007e40:	ae890613          	addi	a2,s2,-1304 # 4002cae8 <_shell_help+0x88>
40007e44:	00800593          	li	a1,8
40007e48:	00040513          	mv	a0,s0
40007e4c:	e65fd0ef          	jal	ra,40005cb0 <shell_fprintf>
	while (1) {
40007e50:	00148493          	addi	s1,s1,1
		z_shell_history_get(sh->history, true,
40007e54:	fc1ff06f          	j	40007e14 <cmd_history+0x20>
	sh->ctx->temp_buff[0] = '\0';
40007e58:	14070723          	sb	zero,334(a4)
}
40007e5c:	01c12083          	lw	ra,28(sp)
40007e60:	01812403          	lw	s0,24(sp)
40007e64:	01412483          	lw	s1,20(sp)
40007e68:	01012903          	lw	s2,16(sp)
40007e6c:	00000513          	li	a0,0
40007e70:	02010113          	addi	sp,sp,32
40007e74:	00008067          	ret

40007e78 <cmd_get_retval>:

	return 0;
}

static int cmd_get_retval(const struct shell *sh, size_t argc, char **argv)
{
40007e78:	ff010113          	addi	sp,sp,-16
40007e7c:	00112623          	sw	ra,12(sp)
40007e80:	00812423          	sw	s0,8(sp)
40007e84:	00050413          	mv	s0,a0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(sh, "%d", shell_get_return_value(sh));
40007e88:	90cfe0ef          	jal	ra,40005f94 <shell_get_return_value>
40007e8c:	4002f637          	lui	a2,0x4002f
40007e90:	00050693          	mv	a3,a0
40007e94:	cf460613          	addi	a2,a2,-780 # 4002ecf4 <CSWTCH.14405+0x1718>
40007e98:	00040513          	mv	a0,s0
40007e9c:	00800593          	li	a1,8
40007ea0:	e11fd0ef          	jal	ra,40005cb0 <shell_fprintf>
	return 0;
}
40007ea4:	00c12083          	lw	ra,12(sp)
40007ea8:	00812403          	lw	s0,8(sp)
40007eac:	00000513          	li	a0,0
40007eb0:	01010113          	addi	sp,sp,16
40007eb4:	00008067          	ret

40007eb8 <cmd_echo>:
{
40007eb8:	ff010113          	addi	sp,sp,-16
40007ebc:	00112623          	sw	ra,12(sp)
	if (argc == 2) {
40007ec0:	00200793          	li	a5,2
40007ec4:	02f59a63          	bne	a1,a5,40007ef8 <cmd_echo+0x40>
		shell_error(sh, "%s:%s%s", argv[0],
40007ec8:	00462783          	lw	a5,4(a2)
40007ecc:	00062683          	lw	a3,0(a2)
40007ed0:	4002d737          	lui	a4,0x4002d
40007ed4:	4002d637          	lui	a2,0x4002d
40007ed8:	af870713          	addi	a4,a4,-1288 # 4002caf8 <_shell_help+0x98>
40007edc:	b1060613          	addi	a2,a2,-1264 # 4002cb10 <_shell_help+0xb0>
40007ee0:	00100593          	li	a1,1
40007ee4:	dcdfd0ef          	jal	ra,40005cb0 <shell_fprintf>
40007ee8:	fea00513          	li	a0,-22
}
40007eec:	00c12083          	lw	ra,12(sp)
40007ef0:	01010113          	addi	sp,sp,16
40007ef4:	00008067          	ret
	return sh->ctx->cfg.flags.echo == 1;
40007ef8:	00852783          	lw	a5,8(a0)
40007efc:	00050713          	mv	a4,a0
40007f00:	26c7a783          	lw	a5,620(a5)
40007f04:	0017d793          	srli	a5,a5,0x1
40007f08:	0017f793          	andi	a5,a5,1
	shell_print(sh, "Echo status: %s",
40007f0c:	02078463          	beqz	a5,40007f34 <cmd_echo+0x7c>
40007f10:	4002e6b7          	lui	a3,0x4002e
40007f14:	ec468693          	addi	a3,a3,-316 # 4002dec4 <CSWTCH.14405+0x8e8>
40007f18:	4002d637          	lui	a2,0x4002d
40007f1c:	00070513          	mv	a0,a4
40007f20:	b1c60613          	addi	a2,a2,-1252 # 4002cb1c <_shell_help+0xbc>
40007f24:	00800593          	li	a1,8
40007f28:	d89fd0ef          	jal	ra,40005cb0 <shell_fprintf>
	return 0;
40007f2c:	00000513          	li	a0,0
40007f30:	fbdff06f          	j	40007eec <cmd_echo+0x34>
	shell_print(sh, "Echo status: %s",
40007f34:	4002d6b7          	lui	a3,0x4002d
40007f38:	af468693          	addi	a3,a3,-1292 # 4002caf4 <_shell_help+0x94>
40007f3c:	fddff06f          	j	40007f18 <cmd_echo+0x60>

40007f40 <cmd_clear>:
{
40007f40:	ff010113          	addi	sp,sp,-16
40007f44:	00812423          	sw	s0,8(sp)
40007f48:	00112623          	sw	ra,12(sp)
	return sh->ctx->cfg.flags.use_vt100 == 1;
40007f4c:	00852783          	lw	a5,8(a0)
40007f50:	00050413          	mv	s0,a0
40007f54:	26c7a783          	lw	a5,620(a5)
40007f58:	0057d793          	srli	a5,a5,0x5
40007f5c:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CURSORHOME);
40007f60:	00078a63          	beqz	a5,40007f74 <cmd_clear+0x34>
40007f64:	01452503          	lw	a0,20(a0)
40007f68:	4002c5b7          	lui	a1,0x4002c
40007f6c:	c1458593          	addi	a1,a1,-1004 # 4002bc14 <eth_config+0x3c>
40007f70:	d1dff0ef          	jal	ra,40007c8c <z_shell_raw_fprintf>
40007f74:	00842783          	lw	a5,8(s0)
40007f78:	26c7a783          	lw	a5,620(a5)
40007f7c:	0057d793          	srli	a5,a5,0x5
40007f80:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEARSCREEN);
40007f84:	00078a63          	beqz	a5,40007f98 <cmd_clear+0x58>
40007f88:	01442503          	lw	a0,20(s0)
40007f8c:	4002c5b7          	lui	a1,0x4002c
40007f90:	c1c58593          	addi	a1,a1,-996 # 4002bc1c <eth_config+0x44>
40007f94:	cf9ff0ef          	jal	ra,40007c8c <z_shell_raw_fprintf>
}
40007f98:	00c12083          	lw	ra,12(sp)
40007f9c:	00812403          	lw	s0,8(sp)
40007fa0:	00000513          	li	a0,0
40007fa4:	01010113          	addi	sp,sp,16
40007fa8:	00008067          	ret

40007fac <cmd_resize>:
{
40007fac:	fd010113          	addi	sp,sp,-48
40007fb0:	02112623          	sw	ra,44(sp)
40007fb4:	02812423          	sw	s0,40(sp)
40007fb8:	02912223          	sw	s1,36(sp)
40007fbc:	03212023          	sw	s2,32(sp)
40007fc0:	01312e23          	sw	s3,28(sp)
40007fc4:	01412c23          	sw	s4,24(sp)
40007fc8:	01512a23          	sw	s5,20(sp)
	if (argc != 1) {
40007fcc:	00100793          	li	a5,1
40007fd0:	04f58663          	beq	a1,a5,4000801c <cmd_resize+0x70>
		shell_error(sh, "%s:%s%s", argv[0],
40007fd4:	00462783          	lw	a5,4(a2)
40007fd8:	00062683          	lw	a3,0(a2)
40007fdc:	4002d737          	lui	a4,0x4002d
40007fe0:	4002d637          	lui	a2,0x4002d
40007fe4:	af870713          	addi	a4,a4,-1288 # 4002caf8 <_shell_help+0x98>
40007fe8:	b1060613          	addi	a2,a2,-1264 # 4002cb10 <_shell_help+0xb0>
40007fec:	00100593          	li	a1,1
40007ff0:	cc1fd0ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
40007ff4:	fea00513          	li	a0,-22
}
40007ff8:	02c12083          	lw	ra,44(sp)
40007ffc:	02812403          	lw	s0,40(sp)
40008000:	02412483          	lw	s1,36(sp)
40008004:	02012903          	lw	s2,32(sp)
40008008:	01c12983          	lw	s3,28(sp)
4000800c:	01812a03          	lw	s4,24(sp)
40008010:	01412a83          	lw	s5,20(sp)
40008014:	03010113          	addi	sp,sp,48
40008018:	00008067          	ret
4000801c:	00852783          	lw	a5,8(a0)
40008020:	00050413          	mv	s0,a0
40008024:	26c7a783          	lw	a5,620(a5)
40008028:	0057d793          	srli	a5,a5,0x5
4000802c:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SAVECURSOR);
40008030:	00078a63          	beqz	a5,40008044 <cmd_resize+0x98>
40008034:	01452503          	lw	a0,20(a0)
40008038:	4002c5b7          	lui	a1,0x4002c
4000803c:	c2458593          	addi	a1,a1,-988 # 4002bc24 <eth_config+0x4c>
40008040:	c4dff0ef          	jal	ra,40007c8c <z_shell_raw_fprintf>
	z_shell_op_cursor_vert_move(sh, -SHELL_MAX_TERMINAL_SIZE);
40008044:	f0600593          	li	a1,-250
40008048:	00040513          	mv	a0,s0
4000804c:	b15fe0ef          	jal	ra,40006b60 <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(sh, SHELL_MAX_TERMINAL_SIZE);
40008050:	0fa00593          	li	a1,250
40008054:	00040513          	mv	a0,s0
40008058:	b4dfe0ef          	jal	ra,40006ba4 <z_shell_op_cursor_horiz_move>
	memset(sh->ctx->temp_buff, 0, sizeof(sh->ctx->temp_buff));
4000805c:	00842503          	lw	a0,8(s0)
40008060:	10000613          	li	a2,256
40008064:	00000593          	li	a1,0
40008068:	14e50513          	addi	a0,a0,334
	char c = 0;
4000806c:	000105a3          	sb	zero,11(sp)
	memset(sh->ctx->temp_buff, 0, sizeof(sh->ctx->temp_buff));
40008070:	000010ef          	jal	ra,40009070 <memset>
	z_shell_raw_fprintf(sh->fprintf_ctx, cmd_get_terminal_size);
40008074:	01442503          	lw	a0,20(s0)
40008078:	4002c5b7          	lui	a1,0x4002c
4000807c:	b0458593          	addi	a1,a1,-1276 # 4002bb04 <cmd_get_terminal_size.0>
40008080:	c0dff0ef          	jal	ra,40007c8c <z_shell_raw_fprintf>
	z_shell_fprintf_buffer_flush(sh->fprintf_ctx);
40008084:	01442503          	lw	a0,20(s0)
40008088:	3e800913          	li	s2,1000
	uint16_t buff_idx = 0U;
4000808c:	00000493          	li	s1,0
40008090:	f79fd0ef          	jal	ra,40006008 <z_shell_fprintf_buffer_flush>
			if ((c != SHELL_VT100_ASCII_ESC) &&
40008094:	01b00993          	li	s3,27
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
40008098:	00900a13          	li	s4,9
			if (c == 'R') { /* End of response from the terminal. */
4000809c:	05200a93          	li	s5,82
			(void)sh->iface->api->read(sh->iface, &c,
400080a0:	00442503          	lw	a0,4(s0)
400080a4:	00c10693          	addi	a3,sp,12
400080a8:	00100613          	li	a2,1
400080ac:	00052783          	lw	a5,0(a0)
400080b0:	00b10593          	addi	a1,sp,11
400080b4:	0107a783          	lw	a5,16(a5)
400080b8:	000780e7          	jalr	a5
			if (cnt == 0) {
400080bc:	00c12783          	lw	a5,12(sp)
400080c0:	06079a63          	bnez	a5,40008134 <cmd_resize+0x188>
	for (uint16_t i = 0; i < 1000; i++) {
400080c4:	fff90913          	addi	s2,s2,-1
400080c8:	01091913          	slli	s2,s2,0x10
	z_impl_k_busy_wait(usec_to_wait);
400080cc:	3e800513          	li	a0,1000
400080d0:	01095913          	srli	s2,s2,0x10
400080d4:	2e5220ef          	jal	ra,4002abb8 <z_impl_k_busy_wait>
400080d8:	fc0914e3          	bnez	s2,400080a0 <cmd_resize+0xf4>
	return sh->ctx->cfg.flags.use_vt100 == 1;
400080dc:	00842783          	lw	a5,8(s0)
400080e0:	26c7a783          	lw	a5,620(a5)
400080e4:	0057d793          	srli	a5,a5,0x5
400080e8:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
400080ec:	00078a63          	beqz	a5,40008100 <cmd_resize+0x154>
400080f0:	01442503          	lw	a0,20(s0)
400080f4:	4002c5b7          	lui	a1,0x4002c
400080f8:	c2858593          	addi	a1,a1,-984 # 4002bc28 <eth_config+0x50>
400080fc:	b91ff0ef          	jal	ra,40007c8c <z_shell_raw_fprintf>
		sh->ctx->vt100_ctx.cons.terminal_wid =
40008100:	00842783          	lw	a5,8(s0)
40008104:	05000713          	li	a4,80
		shell_warn(sh, "No response from the terminal, assumed 80x24"
40008108:	4002d637          	lui	a2,0x4002d
		sh->ctx->vt100_ctx.cons.terminal_wid =
4000810c:	02e79723          	sh	a4,46(a5)
		sh->ctx->vt100_ctx.cons.terminal_hei =
40008110:	00842783          	lw	a5,8(s0)
40008114:	01800713          	li	a4,24
		shell_warn(sh, "No response from the terminal, assumed 80x24"
40008118:	00040513          	mv	a0,s0
		sh->ctx->vt100_ctx.cons.terminal_hei =
4000811c:	02e79623          	sh	a4,44(a5)
		shell_warn(sh, "No response from the terminal, assumed 80x24"
40008120:	b3060613          	addi	a2,a2,-1232 # 4002cb30 <_shell_help+0xd0>
40008124:	00300593          	li	a1,3
40008128:	b89fd0ef          	jal	ra,40005cb0 <shell_fprintf>
4000812c:	ff800513          	li	a0,-8
40008130:	ec9ff06f          	j	40007ff8 <cmd_resize+0x4c>
			if ((c != SHELL_VT100_ASCII_ESC) &&
40008134:	00b14703          	lbu	a4,11(sp)
			    (sh->ctx->temp_buff[0] !=
40008138:	00842783          	lw	a5,8(s0)
			if ((c != SHELL_VT100_ASCII_ESC) &&
4000813c:	13370663          	beq	a4,s3,40008268 <cmd_resize+0x2bc>
40008140:	14e7c683          	lbu	a3,334(a5)
40008144:	f5369ee3          	bne	a3,s3,400080a0 <cmd_resize+0xf4>
			if (c == 'R') { /* End of response from the terminal. */
40008148:	13571063          	bne	a4,s5,40008268 <cmd_resize+0x2bc>
				sh->ctx->temp_buff[buff_idx] = '\0';
4000814c:	009787b3          	add	a5,a5,s1
40008150:	14078723          	sb	zero,334(a5)
				if (sh->ctx->temp_buff[1] != '[') {
40008154:	00842603          	lw	a2,8(s0)
40008158:	05b00793          	li	a5,91
4000815c:	14f64703          	lbu	a4,335(a2)
40008160:	0af71a63          	bne	a4,a5,40008214 <cmd_resize+0x268>
40008164:	15060593          	addi	a1,a2,336
	*y = 0U;
40008168:	00000693          	li	a3,0
				buff_idx = 2U;
4000816c:	00200793          	li	a5,2
				while (sh->ctx->temp_buff[buff_idx] != ';') {
40008170:	03b00813          	li	a6,59
					*y = *y * 10U +
40008174:	00a00893          	li	a7,10
					if (buff_idx >=
40008178:	10000313          	li	t1,256
				while (sh->ctx->temp_buff[buff_idx] != ';') {
4000817c:	0005c703          	lbu	a4,0(a1)
40008180:	00078513          	mv	a0,a5
					(sh->ctx->temp_buff[buff_idx++] -
40008184:	00178793          	addi	a5,a5,1
40008188:	01079793          	slli	a5,a5,0x10
4000818c:	0107d793          	srli	a5,a5,0x10
				while (sh->ctx->temp_buff[buff_idx] != ';') {
40008190:	09071663          	bne	a4,a6,4000821c <cmd_resize+0x270>
				if (++buff_idx >= CONFIG_SHELL_CMD_BUFF_SIZE) {
40008194:	0ff00713          	li	a4,255
40008198:	f4e502e3          	beq	a0,a4,400080dc <cmd_resize+0x130>
4000819c:	00f60533          	add	a0,a2,a5
	*x = 0U;
400081a0:	00000713          	li	a4,0
					*x = *x * 10U +
400081a4:	00a00813          	li	a6,10
					if (buff_idx >=
400081a8:	10000893          	li	a7,256
				while (sh->ctx->temp_buff[buff_idx]
400081ac:	14e54583          	lbu	a1,334(a0)
							     != '\0') {
400081b0:	08059663          	bnez	a1,4000823c <cmd_resize+0x290>
				sh->ctx->temp_buff[0] = 0;
400081b4:	14060723          	sb	zero,334(a2)
				if (*x > SHELL_MAX_TERMINAL_SIZE) {
400081b8:	0fa00593          	li	a1,250
		sh->ctx->vt100_ctx.cons.terminal_wid = x;
400081bc:	00842603          	lw	a2,8(s0)
				if (*x > SHELL_MAX_TERMINAL_SIZE) {
400081c0:	00070793          	mv	a5,a4
400081c4:	00e5f463          	bgeu	a1,a4,400081cc <cmd_resize+0x220>
400081c8:	0fa00793          	li	a5,250
		sh->ctx->vt100_ctx.cons.terminal_wid = x;
400081cc:	02f61723          	sh	a5,46(a2)
				if (*y > SHELL_MAX_TERMINAL_SIZE) {
400081d0:	0fa00613          	li	a2,250
		sh->ctx->vt100_ctx.cons.terminal_hei = y;
400081d4:	00842703          	lw	a4,8(s0)
				if (*y > SHELL_MAX_TERMINAL_SIZE) {
400081d8:	00068793          	mv	a5,a3
400081dc:	00d67463          	bgeu	a2,a3,400081e4 <cmd_resize+0x238>
400081e0:	0fa00793          	li	a5,250
		sh->ctx->vt100_ctx.cons.terminal_hei = y;
400081e4:	02f71623          	sh	a5,44(a4)
	return sh->ctx->cfg.flags.use_vt100 == 1;
400081e8:	00842783          	lw	a5,8(s0)
400081ec:	26c7a783          	lw	a5,620(a5)
400081f0:	0057d793          	srli	a5,a5,0x5
400081f4:	0017f793          	andi	a5,a5,1
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
400081f8:	00078a63          	beqz	a5,4000820c <cmd_resize+0x260>
400081fc:	01442503          	lw	a0,20(s0)
40008200:	4002c5b7          	lui	a1,0x4002c
40008204:	c2858593          	addi	a1,a1,-984 # 4002bc28 <eth_config+0x50>
40008208:	a85ff0ef          	jal	ra,40007c8c <z_shell_raw_fprintf>
	return 0;
4000820c:	00000513          	li	a0,0
40008210:	de9ff06f          	j	40007ff8 <cmd_resize+0x4c>
					sh->ctx->temp_buff[0] = 0;
40008214:	14060723          	sb	zero,334(a2)
					return -EIO;
40008218:	ec5ff06f          	j	400080dc <cmd_resize+0x130>
					*y = *y * 10U +
4000821c:	031686b3          	mul	a3,a3,a7
					if (buff_idx >=
40008220:	00158593          	addi	a1,a1,1
					*y = *y * 10U +
40008224:	fd068693          	addi	a3,a3,-48
40008228:	00d70733          	add	a4,a4,a3
4000822c:	01071693          	slli	a3,a4,0x10
40008230:	0106d693          	srli	a3,a3,0x10
					if (buff_idx >=
40008234:	f46794e3          	bne	a5,t1,4000817c <cmd_resize+0x1d0>
40008238:	ea5ff06f          	j	400080dc <cmd_resize+0x130>
					*x = *x * 10U +
4000823c:	03070733          	mul	a4,a4,a6
					(sh->ctx->temp_buff[buff_idx++] -
40008240:	00178793          	addi	a5,a5,1
40008244:	01079793          	slli	a5,a5,0x10
40008248:	0107d793          	srli	a5,a5,0x10
					if (buff_idx >=
4000824c:	00150513          	addi	a0,a0,1
					*x = *x * 10U +
40008250:	fd070713          	addi	a4,a4,-48
40008254:	00e585b3          	add	a1,a1,a4
40008258:	01059713          	slli	a4,a1,0x10
4000825c:	01075713          	srli	a4,a4,0x10
					if (buff_idx >=
40008260:	f51796e3          	bne	a5,a7,400081ac <cmd_resize+0x200>
40008264:	e79ff06f          	j	400080dc <cmd_resize+0x130>
			sh->ctx->temp_buff[buff_idx] = c;
40008268:	009787b3          	add	a5,a5,s1
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
4000826c:	00148493          	addi	s1,s1,1
40008270:	01049493          	slli	s1,s1,0x10
			sh->ctx->temp_buff[buff_idx] = c;
40008274:	14e78723          	sb	a4,334(a5)
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
40008278:	0104d493          	srli	s1,s1,0x10
4000827c:	e29a72e3          	bgeu	s4,s1,400080a0 <cmd_resize+0xf4>
				sh->ctx->temp_buff[0] = 0;
40008280:	00842783          	lw	a5,8(s0)
40008284:	14078723          	sb	zero,334(a5)
				return -ENOMEM;
40008288:	e55ff06f          	j	400080dc <cmd_resize+0x130>

4000828c <cmd_vt100_off>:
{
4000828c:	ff010113          	addi	sp,sp,-16
40008290:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, use_vt100, val, ret);
40008294:	00852503          	lw	a0,8(a0)
40008298:	26c50513          	addi	a0,a0,620
4000829c:	fdf00593          	li	a1,-33
400082a0:	58d220ef          	jal	ra,4002b02c <z_impl_atomic_and>
}
400082a4:	00c12083          	lw	ra,12(sp)
400082a8:	00000513          	li	a0,0
400082ac:	01010113          	addi	sp,sp,16
400082b0:	00008067          	ret

400082b4 <cmd_bacskpace_mode_delete>:
{
400082b4:	ff010113          	addi	sp,sp,-16
400082b8:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, mode_delete, val, ret);
400082bc:	00852503          	lw	a0,8(a0)
400082c0:	26c50513          	addi	a0,a0,620
	return z_impl_atomic_or(target, value);
400082c4:	00800593          	li	a1,8
400082c8:	545220ef          	jal	ra,4002b00c <z_impl_atomic_or>
}
400082cc:	00c12083          	lw	ra,12(sp)
400082d0:	00000513          	li	a0,0
400082d4:	01010113          	addi	sp,sp,16
400082d8:	00008067          	ret

400082dc <cmd_colors_off>:
{
400082dc:	ff010113          	addi	sp,sp,-16
400082e0:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, use_colors, val, ret);
400082e4:	00852503          	lw	a0,8(a0)
400082e8:	26c50513          	addi	a0,a0,620
	return z_impl_atomic_and(target, value);
400082ec:	fef00593          	li	a1,-17
400082f0:	53d220ef          	jal	ra,4002b02c <z_impl_atomic_and>
}
400082f4:	00c12083          	lw	ra,12(sp)
400082f8:	00000513          	li	a0,0
400082fc:	01010113          	addi	sp,sp,16
40008300:	00008067          	ret

40008304 <cmd_bacskpace_mode_backspace>:
{
40008304:	ff010113          	addi	sp,sp,-16
40008308:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, mode_delete, val, ret);
4000830c:	00852503          	lw	a0,8(a0)
40008310:	26c50513          	addi	a0,a0,620
40008314:	ff700593          	li	a1,-9
40008318:	515220ef          	jal	ra,4002b02c <z_impl_atomic_and>
}
4000831c:	00c12083          	lw	ra,12(sp)
40008320:	00000513          	li	a0,0
40008324:	01010113          	addi	sp,sp,16
40008328:	00008067          	ret

4000832c <cmd_echo_off>:
{
4000832c:	ff010113          	addi	sp,sp,-16
40008330:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, echo, val, ret);
40008334:	00852503          	lw	a0,8(a0)
40008338:	26c50513          	addi	a0,a0,620
4000833c:	ffd00593          	li	a1,-3
40008340:	4ed220ef          	jal	ra,4002b02c <z_impl_atomic_and>
}
40008344:	00c12083          	lw	ra,12(sp)
40008348:	00000513          	li	a0,0
4000834c:	01010113          	addi	sp,sp,16
40008350:	00008067          	ret

40008354 <cmd_colors_on>:
{
40008354:	ff010113          	addi	sp,sp,-16
40008358:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, use_colors, val, ret);
4000835c:	00852503          	lw	a0,8(a0)
40008360:	26c50513          	addi	a0,a0,620
	return z_impl_atomic_or(target, value);
40008364:	01000593          	li	a1,16
40008368:	4a5220ef          	jal	ra,4002b00c <z_impl_atomic_or>
}
4000836c:	00c12083          	lw	ra,12(sp)
40008370:	00000513          	li	a0,0
40008374:	01010113          	addi	sp,sp,16
40008378:	00008067          	ret

4000837c <cmd_vt100_on>:
{
4000837c:	ff010113          	addi	sp,sp,-16
40008380:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, use_vt100, val, ret);
40008384:	00852503          	lw	a0,8(a0)
40008388:	26c50513          	addi	a0,a0,620
4000838c:	02000593          	li	a1,32
40008390:	47d220ef          	jal	ra,4002b00c <z_impl_atomic_or>
}
40008394:	00c12083          	lw	ra,12(sp)
40008398:	00000513          	li	a0,0
4000839c:	01010113          	addi	sp,sp,16
400083a0:	00008067          	ret

400083a4 <cmd_echo_on>:
{
400083a4:	ff010113          	addi	sp,sp,-16
400083a8:	00112623          	sw	ra,12(sp)
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, echo, val, ret);
400083ac:	00852503          	lw	a0,8(a0)
400083b0:	26c50513          	addi	a0,a0,620
400083b4:	00200593          	li	a1,2
400083b8:	455220ef          	jal	ra,4002b00c <z_impl_atomic_or>
}
400083bc:	00c12083          	lw	ra,12(sp)
400083c0:	00000513          	li	a0,0
400083c4:	01010113          	addi	sp,sp,16
400083c8:	00008067          	ret

400083cc <remove_from_tail.part.0>:
	memcpy(item->data, src, len);
	sys_dlist_prepend(&history->list, &item->dnode);
}

/* Returns true if element was removed. */
static bool remove_from_tail(struct shell_history *history)
400083cc:	ff010113          	addi	sp,sp,-16
400083d0:	00112623          	sw	ra,12(sp)
 * @return a pointer to the tail element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_tail(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->tail;
400083d4:	00852783          	lw	a5,8(a0)

	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);

	total_len = offsetof(struct shell_history_item, data) +
			h_item->len + h_item->padding;
	ring_buf_get(history->ring_buf, NULL, total_len);
400083d8:	00000593          	li	a1,0
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
400083dc:	0047a683          	lw	a3,4(a5)
	sys_dnode_t *const next = node->next;
400083e0:	0007a703          	lw	a4,0(a5)

	prev->next = next;
400083e4:	00e6a023          	sw	a4,0(a3)
	next->prev = prev;
400083e8:	00d72223          	sw	a3,4(a4)
			h_item->len + h_item->padding;
400083ec:	0087d603          	lhu	a2,8(a5)
	node->next = NULL;
400083f0:	0007a023          	sw	zero,0(a5)
	node->prev = NULL;
400083f4:	0007a223          	sw	zero,4(a5)
400083f8:	00a7d783          	lhu	a5,10(a5)
	ring_buf_get(history->ring_buf, NULL, total_len);
400083fc:	00052503          	lw	a0,0(a0)
			h_item->len + h_item->padding;
40008400:	00f60633          	add	a2,a2,a5
	ring_buf_get(history->ring_buf, NULL, total_len);
40008404:	00c60613          	addi	a2,a2,12
40008408:	eacfa0ef          	jal	ra,40002ab4 <ring_buf_get>

	return true;
}
4000840c:	00c12083          	lw	ra,12(sp)
40008410:	00100513          	li	a0,1
40008414:	01010113          	addi	sp,sp,16
40008418:	00008067          	ret

4000841c <z_shell_history_mode_exit>:
	history->current = NULL;
4000841c:	00052623          	sw	zero,12(a0)
}
40008420:	00008067          	ret

40008424 <z_shell_history_get>:
{
40008424:	ff010113          	addi	sp,sp,-16
40008428:	01212023          	sw	s2,0(sp)
4000842c:	00112623          	sw	ra,12(sp)
40008430:	00812423          	sw	s0,8(sp)
40008434:	00912223          	sw	s1,4(sp)
	return list->head == list;
40008438:	00452403          	lw	s0,4(a0)
	if (sys_dlist_is_empty(&history->list)) {
4000843c:	00450793          	addi	a5,a0,4
{
40008440:	00068913          	mv	s2,a3
	if (sys_dlist_is_empty(&history->list)) {
40008444:	02f41263          	bne	s0,a5,40008468 <z_shell_history_get+0x44>
		*len = 0U;
40008448:	00091023          	sh	zero,0(s2)
		return false;
4000844c:	00000513          	li	a0,0
}
40008450:	00c12083          	lw	ra,12(sp)
40008454:	00812403          	lw	s0,8(sp)
40008458:	00412483          	lw	s1,4(sp)
4000845c:	00012903          	lw	s2,0(sp)
40008460:	01010113          	addi	sp,sp,16
40008464:	00008067          	ret
		if (history->current == NULL) {
40008468:	00c52783          	lw	a5,12(a0)
4000846c:	00060493          	mv	s1,a2
	if (!up) { /* button down */
40008470:	04059463          	bnez	a1,400084b8 <z_shell_history_get+0x94>
		if (history->current == NULL) {
40008474:	fc078ae3          	beqz	a5,40008448 <z_shell_history_get+0x24>
	return (node == list->head) ? NULL : node->prev;
40008478:	00f41663          	bne	s0,a5,40008484 <z_shell_history_get+0x60>
	history->current = l_item;
4000847c:	00052623          	sw	zero,12(a0)
	if (l_item) {
40008480:	fc9ff06f          	j	40008448 <z_shell_history_get+0x24>
40008484:	0047a403          	lw	s0,4(a5)
	history->current = l_item;
40008488:	00852623          	sw	s0,12(a0)
	if (l_item) {
4000848c:	fa040ee3          	beqz	s0,40008448 <z_shell_history_get+0x24>
		memcpy(dst, h_item->data, h_item->len);
40008490:	00845603          	lhu	a2,8(s0)
40008494:	00048513          	mv	a0,s1
40008498:	00c40593          	addi	a1,s0,12
4000849c:	3b1000ef          	jal	ra,4000904c <memcpy>
		*len = h_item->len;
400084a0:	00845783          	lhu	a5,8(s0)
		return true;
400084a4:	00100513          	li	a0,1
		*len = h_item->len;
400084a8:	00f91023          	sh	a5,0(s2)
		dst[*len] = '\0';
400084ac:	00f484b3          	add	s1,s1,a5
400084b0:	00048023          	sb	zero,0(s1)
		return true;
400084b4:	f9dff06f          	j	40008450 <z_shell_history_get+0x2c>
		sys_dlist_peek_head_not_empty(&history->list) :
400084b8:	fc0788e3          	beqz	a5,40008488 <z_shell_history_get+0x64>
	return (node == list->tail) ? NULL : node->next;
400084bc:	00852703          	lw	a4,8(a0)
400084c0:	faf70ee3          	beq	a4,a5,4000847c <z_shell_history_get+0x58>
400084c4:	0007a403          	lw	s0,0(a5)
400084c8:	fc1ff06f          	j	40008488 <z_shell_history_get+0x64>

400084cc <z_shell_history_purge>:

void z_shell_history_purge(struct shell_history *history)
{
400084cc:	ff010113          	addi	sp,sp,-16
400084d0:	00812423          	sw	s0,8(sp)
400084d4:	00912223          	sw	s1,4(sp)
400084d8:	00112623          	sw	ra,12(sp)
400084dc:	00050413          	mv	s0,a0
	if (sys_dlist_is_empty(&history->list)) {
400084e0:	00450493          	addi	s1,a0,4
400084e4:	00442783          	lw	a5,4(s0)
400084e8:	00978863          	beq	a5,s1,400084f8 <z_shell_history_purge+0x2c>
400084ec:	00040513          	mv	a0,s0
400084f0:	eddff0ef          	jal	ra,400083cc <remove_from_tail.part.0>
	while (remove_from_tail(history)) {
400084f4:	fe0518e3          	bnez	a0,400084e4 <z_shell_history_purge+0x18>
	}
}
400084f8:	00c12083          	lw	ra,12(sp)
400084fc:	00812403          	lw	s0,8(sp)
40008500:	00412483          	lw	s1,4(sp)
40008504:	01010113          	addi	sp,sp,16
40008508:	00008067          	ret

4000850c <z_shell_history_put>:

void z_shell_history_put(struct shell_history *history, uint8_t *line,
			 size_t len)
{
4000850c:	fc010113          	addi	sp,sp,-64
40008510:	02912a23          	sw	s1,52(sp)
40008514:	03512223          	sw	s5,36(sp)
40008518:	02112e23          	sw	ra,60(sp)
4000851c:	02812c23          	sw	s0,56(sp)
40008520:	03212823          	sw	s2,48(sp)
40008524:	03312623          	sw	s3,44(sp)
40008528:	03412423          	sw	s4,40(sp)
4000852c:	03612023          	sw	s6,32(sp)
40008530:	01712e23          	sw	s7,28(sp)
	return buf->size;
40008534:	00052783          	lw	a5,0(a0)
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item, *h_prev_item;
	uint32_t total_len = len + offsetof(struct shell_history_item, data);
40008538:	00c60493          	addi	s1,a2,12
	uint32_t claim_len;
	uint32_t claim2_len;
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
4000853c:	40900ab3          	neg	s5,s1

	/* align to word. */
	total_len += padding;

	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
40008540:	01c7a783          	lw	a5,28(a5)
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
40008544:	003afa93          	andi	s5,s5,3
	total_len += padding;
40008548:	009a84b3          	add	s1,s5,s1
	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
4000854c:	0297ee63          	bltu	a5,s1,40008588 <z_shell_history_put+0x7c>
	history->current = NULL;
40008550:	00052623          	sw	zero,12(a0)
40008554:	00050413          	mv	s0,a0
40008558:	00060a13          	mv	s4,a2
		return;
	}

	z_shell_history_mode_exit(history);

	if (len == 0) {
4000855c:	02060663          	beqz	a2,40008588 <z_shell_history_put+0x7c>
	return list->head == list;
40008560:	00452983          	lw	s3,4(a0)
		return;
	}

	l_item = sys_dlist_peek_head(&history->list);
40008564:	00450b13          	addi	s6,a0,4
40008568:	00058b93          	mv	s7,a1
	return sys_dlist_is_empty(list) ? NULL : list->head;
4000856c:	053b0463          	beq	s6,s3,400085b4 <z_shell_history_put+0xa8>
	h_prev_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);

	if (l_item &&
40008570:	04098463          	beqz	s3,400085b8 <z_shell_history_put+0xac>
	   (h_prev_item->len == len) &&
40008574:	0089d783          	lhu	a5,8(s3)
	if (l_item &&
40008578:	04c79063          	bne	a5,a2,400085b8 <z_shell_history_put+0xac>
	   (memcmp(h_prev_item->data, line, len) == 0)) {
4000857c:	00c98513          	addi	a0,s3,12
40008580:	24d000ef          	jal	ra,40008fcc <memcmp>
	   (h_prev_item->len == len) &&
40008584:	02051a63          	bnez	a0,400085b8 <z_shell_history_put+0xac>
		}

		ring_buf_put_finish(history->ring_buf, 0);
		remove_from_tail(history);
	} while (1);
}
40008588:	03c12083          	lw	ra,60(sp)
4000858c:	03812403          	lw	s0,56(sp)
40008590:	03412483          	lw	s1,52(sp)
40008594:	03012903          	lw	s2,48(sp)
40008598:	02c12983          	lw	s3,44(sp)
4000859c:	02812a03          	lw	s4,40(sp)
400085a0:	02412a83          	lw	s5,36(sp)
400085a4:	02012b03          	lw	s6,32(sp)
400085a8:	01c12b83          	lw	s7,28(sp)
400085ac:	04010113          	addi	sp,sp,64
400085b0:	00008067          	ret
400085b4:	00000993          	li	s3,0
		if (ring_buf_is_empty(history->ring_buf)) {
400085b8:	00042783          	lw	a5,0(s0)
400085bc:	0107a683          	lw	a3,16(a5)
400085c0:	0087a703          	lw	a4,8(a5)
400085c4:	00e69e63          	bne	a3,a4,400085e0 <z_shell_history_put+0xd4>
	buf->put_head = buf->put_tail = buf->put_base = value;
400085c8:	0007a623          	sw	zero,12(a5)
400085cc:	0007a423          	sw	zero,8(a5)
400085d0:	0007a223          	sw	zero,4(a5)
	buf->get_head = buf->get_tail = buf->get_base = value;
400085d4:	0007ac23          	sw	zero,24(a5)
400085d8:	0007aa23          	sw	zero,20(a5)
400085dc:	0007a823          	sw	zero,16(a5)
		claim_len = ring_buf_put_claim(history->ring_buf,
400085e0:	00042503          	lw	a0,0(s0)
400085e4:	00048613          	mv	a2,s1
400085e8:	00c10593          	addi	a1,sp,12
400085ec:	ae8fa0ef          	jal	ra,400028d4 <ring_buf_put_claim>
400085f0:	00050913          	mv	s2,a0
		if (claim_len < total_len) {
400085f4:	06957463          	bgeu	a0,s1,4000865c <z_shell_history_put+0x150>
				ring_buf_put_claim(history->ring_buf,
400085f8:	00042503          	lw	a0,0(s0)
400085fc:	00048613          	mv	a2,s1
40008600:	00c10593          	addi	a1,sp,12
40008604:	ad0fa0ef          	jal	ra,400028d4 <ring_buf_put_claim>
			if (claim2_len == total_len) {
40008608:	04a49c63          	bne	s1,a0,40008660 <z_shell_history_put+0x154>
				h_prev_item->padding += claim_len;
4000860c:	00a9d783          	lhu	a5,10(s3)
40008610:	012787b3          	add	a5,a5,s2
40008614:	00f99523          	sh	a5,10(s3)
				total_len += claim_len;
40008618:	00990933          	add	s2,s2,s1
			add_to_head(history, h_item, line, len, padding);
4000861c:	00c12483          	lw	s1,12(sp)
	memcpy(item->data, src, len);
40008620:	000b8593          	mv	a1,s7
40008624:	000a0613          	mv	a2,s4
	item->len = len;
40008628:	01449423          	sh	s4,8(s1)
	item->padding = padding;
4000862c:	01549523          	sh	s5,10(s1)
	memcpy(item->data, src, len);
40008630:	00c48513          	addi	a0,s1,12
40008634:	219000ef          	jal	ra,4000904c <memcpy>
	sys_dnode_t *const head = list->head;
40008638:	00442783          	lw	a5,4(s0)
	node->prev = list;
4000863c:	0164a223          	sw	s6,4(s1)
			ring_buf_put_finish(history->ring_buf, claim_len);
40008640:	00090593          	mv	a1,s2
	node->next = head;
40008644:	00f4a023          	sw	a5,0(s1)
	head->prev = node;
40008648:	0097a223          	sw	s1,4(a5)
4000864c:	00042503          	lw	a0,0(s0)
	list->head = node;
40008650:	00942223          	sw	s1,4(s0)
40008654:	ae0fa0ef          	jal	ra,40002934 <ring_buf_put_finish>
			break;
40008658:	f31ff06f          	j	40008588 <z_shell_history_put+0x7c>
		if (claim_len == total_len) {
4000865c:	fca480e3          	beq	s1,a0,4000861c <z_shell_history_put+0x110>
		ring_buf_put_finish(history->ring_buf, 0);
40008660:	00042503          	lw	a0,0(s0)
40008664:	00000593          	li	a1,0
40008668:	accfa0ef          	jal	ra,40002934 <ring_buf_put_finish>
	if (sys_dlist_is_empty(&history->list)) {
4000866c:	00442783          	lw	a5,4(s0)
40008670:	f4fb04e3          	beq	s6,a5,400085b8 <z_shell_history_put+0xac>
40008674:	00040513          	mv	a0,s0
40008678:	d55ff0ef          	jal	ra,400083cc <remove_from_tail.part.0>
4000867c:	f3dff06f          	j	400085b8 <z_shell_history_put+0xac>

40008680 <z_shell_history_init>:

void z_shell_history_init(struct shell_history *history)
{
	sys_dlist_init(&history->list);
40008680:	00450793          	addi	a5,a0,4
	list->head = (sys_dnode_t *)list;
40008684:	00f52223          	sw	a5,4(a0)
	list->tail = (sys_dnode_t *)list;
40008688:	00f52423          	sw	a5,8(a0)
	history->current = NULL;
4000868c:	00052623          	sw	zero,12(a0)
}
40008690:	00008067          	ret

40008694 <z_shell_has_wildcard>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
40008694:	06050263          	beqz	a0,400086f8 <z_shell_has_wildcard+0x64>

	return ret_val;
}

bool z_shell_has_wildcard(const char *str)
{
40008698:	ff010113          	addi	sp,sp,-16
4000869c:	00812423          	sw	s0,8(sp)
400086a0:	00112623          	sw	ra,12(sp)
400086a4:	00050413          	mv	s0,a0
400086a8:	081000ef          	jal	ra,40008f28 <strlen>
	uint16_t str_len = z_shell_strlen(str);

	for (size_t i = 0; i < str_len; i++) {
400086ac:	01051513          	slli	a0,a0,0x10
400086b0:	00000793          	li	a5,0
400086b4:	01055513          	srli	a0,a0,0x10
		if ((str[i] == '?') || (str[i] == '*')) {
400086b8:	03f00693          	li	a3,63
400086bc:	02a00613          	li	a2,42
	for (size_t i = 0; i < str_len; i++) {
400086c0:	00a7ec63          	bltu	a5,a0,400086d8 <z_shell_has_wildcard+0x44>
			return true;
		}
	}

	return false;
400086c4:	00000513          	li	a0,0
}
400086c8:	00c12083          	lw	ra,12(sp)
400086cc:	00812403          	lw	s0,8(sp)
400086d0:	01010113          	addi	sp,sp,16
400086d4:	00008067          	ret
		if ((str[i] == '?') || (str[i] == '*')) {
400086d8:	00f40733          	add	a4,s0,a5
400086dc:	00074703          	lbu	a4,0(a4)
400086e0:	00d70863          	beq	a4,a3,400086f0 <z_shell_has_wildcard+0x5c>
400086e4:	00c70663          	beq	a4,a2,400086f0 <z_shell_has_wildcard+0x5c>
	for (size_t i = 0; i < str_len; i++) {
400086e8:	00178793          	addi	a5,a5,1
400086ec:	fd5ff06f          	j	400086c0 <z_shell_has_wildcard+0x2c>
			return true;
400086f0:	00100513          	li	a0,1
400086f4:	fd5ff06f          	j	400086c8 <z_shell_has_wildcard+0x34>
	return false;
400086f8:	00000513          	li	a0,0
}
400086fc:	00008067          	ret

40008700 <z_shell_wildcard_prepare>:

void z_shell_wildcard_prepare(const struct shell *sh)
{
40008700:	ff010113          	addi	sp,sp,-16
40008704:	00112623          	sw	ra,12(sp)
40008708:	00812423          	sw	s0,8(sp)
4000870c:	00050413          	mv	s0,a0
	 *    buffer with all expanded commands is copied to Command buffer.
	 * 7. Deepest found handler is executed and all lower level commands,
	 *    including expanded commands, are passed as arguments.
	 */

	memset(sh->ctx->temp_buff, 0, sizeof(sh->ctx->temp_buff));
40008710:	00852503          	lw	a0,8(a0)
40008714:	10000613          	li	a2,256
40008718:	00000593          	li	a1,0
4000871c:	14e50513          	addi	a0,a0,334
40008720:	151000ef          	jal	ra,40009070 <memset>
	memcpy(sh->ctx->temp_buff,
40008724:	00842503          	lw	a0,8(s0)
40008728:	04855603          	lhu	a2,72(a0)
4000872c:	04e50593          	addi	a1,a0,78
40008730:	14e50513          	addi	a0,a0,334
40008734:	119000ef          	jal	ra,4000904c <memcpy>

	/* Function shell_spaces_trim must be used instead of shell_make_argv.
	 * At this point it is important to keep temp_buff as one string.
	 * It will allow to find wildcard commands easily with strstr function.
	 */
	z_shell_spaces_trim(sh->ctx->temp_buff);
40008738:	00842503          	lw	a0,8(s0)
4000873c:	14e50513          	addi	a0,a0,334
40008740:	8d0fe0ef          	jal	ra,40006810 <z_shell_spaces_trim>

	/* +1 for EOS*/
	sh->ctx->cmd_tmp_buff_len = z_shell_strlen(sh->ctx->temp_buff) + 1;
40008744:	00842503          	lw	a0,8(s0)
40008748:	14e50513          	addi	a0,a0,334
4000874c:	7dc000ef          	jal	ra,40008f28 <strlen>
40008750:	00842783          	lw	a5,8(s0)
40008754:	00150513          	addi	a0,a0,1
40008758:	04a79623          	sh	a0,76(a5)
}
4000875c:	00c12083          	lw	ra,12(sp)
40008760:	00812403          	lw	s0,8(sp)
40008764:	01010113          	addi	sp,sp,16
40008768:	00008067          	ret

4000876c <z_shell_wildcard_process>:


enum shell_wildcard_status z_shell_wildcard_process(const struct shell *sh,
					const struct shell_static_entry *cmd,
					const char *pattern)
{
4000876c:	fa010113          	addi	sp,sp,-96
40008770:	04112e23          	sw	ra,92(sp)
40008774:	04812c23          	sw	s0,88(sp)
40008778:	04912a23          	sw	s1,84(sp)
4000877c:	05212823          	sw	s2,80(sp)
40008780:	05312623          	sw	s3,76(sp)
40008784:	05412423          	sw	s4,72(sp)
40008788:	05512223          	sw	s5,68(sp)
4000878c:	05612023          	sw	s6,64(sp)
40008790:	03712e23          	sw	s7,60(sp)
40008794:	03812c23          	sw	s8,56(sp)
40008798:	03912a23          	sw	s9,52(sp)
4000879c:	03a12823          	sw	s10,48(sp)
400087a0:	03b12623          	sw	s11,44(sp)
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_NOT_FOUND;

	if (cmd == NULL) {
400087a4:	04059463          	bnez	a1,400087ec <z_shell_wildcard_process+0x80>
		return ret_val;
400087a8:	00300413          	li	s0,3
	 * and it will try to add matching commands.
	 */
	ret_val = commands_expand(sh, cmd, pattern);

	return ret_val;
}
400087ac:	05c12083          	lw	ra,92(sp)
400087b0:	00040513          	mv	a0,s0
400087b4:	05812403          	lw	s0,88(sp)
400087b8:	05412483          	lw	s1,84(sp)
400087bc:	05012903          	lw	s2,80(sp)
400087c0:	04c12983          	lw	s3,76(sp)
400087c4:	04812a03          	lw	s4,72(sp)
400087c8:	04412a83          	lw	s5,68(sp)
400087cc:	04012b03          	lw	s6,64(sp)
400087d0:	03c12b83          	lw	s7,60(sp)
400087d4:	03812c03          	lw	s8,56(sp)
400087d8:	03412c83          	lw	s9,52(sp)
400087dc:	03012d03          	lw	s10,48(sp)
400087e0:	02c12d83          	lw	s11,44(sp)
400087e4:	06010113          	addi	sp,sp,96
400087e8:	00008067          	ret
400087ec:	00050993          	mv	s3,a0
	if (!z_shell_has_wildcard(pattern)) {
400087f0:	00060513          	mv	a0,a2
400087f4:	00058a13          	mv	s4,a1
400087f8:	00060913          	mv	s2,a2
400087fc:	e99ff0ef          	jal	ra,40008694 <z_shell_has_wildcard>
40008800:	fa0504e3          	beqz	a0,400087a8 <z_shell_wildcard_process+0x3c>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
40008804:	00010bb7          	lui	s7,0x10
	size_t cnt = 0;
40008808:	00000b13          	li	s6,0
	size_t cmd_idx = 0;
4000880c:	00000593          	li	a1,0
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
40008810:	00200413          	li	s0,2
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
40008814:	0ff00c93          	li	s9,255
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
40008818:	fffb8b93          	addi	s7,s7,-1 # ffff <__kernel_ram_size+0x3d6b>
	completion_addr[cmd_len] = ' ';
4000881c:	02000d13          	li	s10,32
40008820:	0680006f          	j	40008888 <z_shell_wildcard_process+0x11c>
	completion_addr = strstr(buff, pattern);
40008824:	00090593          	mv	a1,s2
40008828:	14ea8513          	addi	a0,s5,334
4000882c:	5c4000ef          	jal	ra,40008df0 <strstr>
40008830:	00050493          	mv	s1,a0
	if (!completion_addr) {
40008834:	0e050263          	beqz	a0,40008918 <z_shell_wildcard_process+0x1ac>
40008838:	6f0000ef          	jal	ra,40008f28 <strlen>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
4000883c:	01757633          	and	a2,a0,s7
40008840:	00140513          	addi	a0,s0,1
40008844:	00048593          	mv	a1,s1
40008848:	00160613          	addi	a2,a2,1
4000884c:	00a48533          	add	a0,s1,a0
40008850:	7b4000ef          	jal	ra,40009004 <memmove>
	memcpy(completion_addr, cmd, cmd_len);
40008854:	00040613          	mv	a2,s0
40008858:	00048513          	mv	a0,s1
4000885c:	000d8593          	mv	a1,s11
	completion_addr[cmd_len] = ' ';
40008860:	008484b3          	add	s1,s1,s0
	memcpy(completion_addr, cmd, cmd_len);
40008864:	7e8000ef          	jal	ra,4000904c <memcpy>
	completion_addr[cmd_len] = ' ';
40008868:	01a48023          	sb	s10,0(s1)
	*buff_len += cmd_len + 1; /* + 1 for space */
4000886c:	04cad783          	lhu	a5,76(s5)
			cnt++;
40008870:	001b0b13          	addi	s6,s6,1
	*buff_len += cmd_len + 1; /* + 1 for space */
40008874:	00178793          	addi	a5,a5,1
40008878:	00f40433          	add	s0,s0,a5
4000887c:	048a9623          	sh	s0,76(s5)
			ret_val = command_add(sh->ctx->temp_buff,
40008880:	00000413          	li	s0,0
40008884:	000c0593          	mv	a1,s8
	while ((entry = z_shell_cmd_get(cmd, cmd_idx++, &dloc)) != NULL) {
40008888:	00c10613          	addi	a2,sp,12
4000888c:	000a0513          	mv	a0,s4
40008890:	00158c13          	addi	s8,a1,1
40008894:	d51fd0ef          	jal	ra,400065e4 <z_shell_cmd_get>
40008898:	00050493          	mv	s1,a0
4000889c:	06050063          	beqz	a0,400088fc <z_shell_wildcard_process+0x190>
		if (fnmatch(pattern, entry->syntax, 0) == 0) {
400088a0:	0004a583          	lw	a1,0(s1)
400088a4:	00000613          	li	a2,0
400088a8:	00090513          	mv	a0,s2
400088ac:	4c1000ef          	jal	ra,4000956c <fnmatch>
400088b0:	fc051ae3          	bnez	a0,40008884 <z_shell_wildcard_process+0x118>
					      entry->syntax, pattern);
400088b4:	0004ad83          	lw	s11,0(s1)
			ret_val = command_add(sh->ctx->temp_buff,
400088b8:	0089aa83          	lw	s5,8(s3)
400088bc:	00000413          	li	s0,0
400088c0:	000d8a63          	beqz	s11,400088d4 <z_shell_wildcard_process+0x168>
400088c4:	000d8513          	mv	a0,s11
400088c8:	660000ef          	jal	ra,40008f28 <strlen>
400088cc:	01051413          	slli	s0,a0,0x10
400088d0:	01045413          	srli	s0,s0,0x10
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
400088d4:	04cad783          	lhu	a5,76(s5)
400088d8:	008787b3          	add	a5,a5,s0
400088dc:	f4fcd4e3          	bge	s9,a5,40008824 <z_shell_wildcard_process+0xb8>
				z_shell_fprintf(sh, SHELL_WARNING,
400088e0:	4002d637          	lui	a2,0x4002d
400088e4:	00090693          	mv	a3,s2
400088e8:	24460613          	addi	a2,a2,580 # 4002d244 <shell_m_sub_colors+0x3c>
400088ec:	00300593          	li	a1,3
400088f0:	00098513          	mv	a0,s3
400088f4:	995fe0ef          	jal	ra,40007288 <z_shell_fprintf>
			ret_val = command_add(sh->ctx->temp_buff,
400088f8:	00100413          	li	s0,1
	if (cnt > 0) {
400088fc:	ea0b08e3          	beqz	s6,400087ac <z_shell_wildcard_process+0x40>
		z_shell_pattern_remove(sh->ctx->temp_buff,
40008900:	0089a503          	lw	a0,8(s3)
40008904:	00090613          	mv	a2,s2
40008908:	04c50593          	addi	a1,a0,76
4000890c:	14e50513          	addi	a0,a0,334
40008910:	c11fd0ef          	jal	ra,40006520 <z_shell_pattern_remove>
	return ret_val;
40008914:	e99ff06f          	j	400087ac <z_shell_wildcard_process+0x40>
40008918:	00200413          	li	s0,2
4000891c:	fe1ff06f          	j	400088fc <z_shell_wildcard_process+0x190>

40008920 <z_shell_wildcard_finalize>:

void z_shell_wildcard_finalize(const struct shell *sh)
{
40008920:	ff010113          	addi	sp,sp,-16
40008924:	00812423          	sw	s0,8(sp)
40008928:	00112623          	sw	ra,12(sp)
4000892c:	00050413          	mv	s0,a0
	memcpy(sh->ctx->cmd_buff,
40008930:	00852503          	lw	a0,8(a0)
40008934:	04c55603          	lhu	a2,76(a0)
40008938:	14e50593          	addi	a1,a0,334
4000893c:	04e50513          	addi	a0,a0,78
40008940:	70c000ef          	jal	ra,4000904c <memcpy>
	       sh->ctx->temp_buff,
	       sh->ctx->cmd_tmp_buff_len);
	sh->ctx->cmd_buff_len = sh->ctx->cmd_tmp_buff_len;
40008944:	00842783          	lw	a5,8(s0)
40008948:	04c7d703          	lhu	a4,76(a5)
4000894c:	04e79423          	sh	a4,72(a5)
}
40008950:	00c12083          	lw	ra,12(sp)
40008954:	00812403          	lw	s0,8(sp)
40008958:	01010113          	addi	sp,sp,16
4000895c:	00008067          	ret

40008960 <arch_cpu_idle>:
	__asm__ volatile ("csrs mstatus, %0"
40008960:	00800793          	li	a5,8
40008964:	3007a073          	csrs	mstatus,a5
 */

void __weak arch_cpu_idle(void)
{
	irq_unlock(MSTATUS_IEN);
}
40008968:	00008067          	ret

4000896c <z_riscv_fatal_error>:
 #define NO_REG "                "
#endif

FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf)
{
4000896c:	ff010113          	addi	sp,sp,-16
40008970:	00112623          	sw	ra,12(sp)
		LOG_ERR("   mepc: " PR_REG, esf->mepc);
		LOG_ERR("mstatus: " PR_REG, esf->mstatus);
		LOG_ERR("");
	}

	z_fatal_error(reason, esf);
40008974:	00c1f0ef          	jal	ra,40027980 <z_fatal_error>

40008978 <_Fault>:

	return false;
}

void _Fault(z_arch_esf_t *esf)
{
40008978:	ff010113          	addi	sp,sp,-16
4000897c:	00112623          	sw	ra,12(sp)
40008980:	00050593          	mv	a1,a0
	}
#endif /* CONFIG_USERSPACE */

	unsigned long mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
40008984:	342027f3          	csrr	a5,mcause

#ifndef CONFIG_SOC_OPENISA_RV32M1_RISCV32
	unsigned long mtval;
	__asm__ volatile("csrr %0, mtval" : "=r" (mtval));
40008988:	343027f3          	csrr	a5,mtval
	z_fatal_error(reason, esf);
4000898c:	00000513          	li	a0,0
40008990:	7f11e0ef          	jal	ra,40027980 <z_fatal_error>

40008994 <z_irq_spurious>:
#include <zephyr/arch/riscv/csr.h>

LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_irq_spurious(const void *unused)
{
40008994:	ff010113          	addi	sp,sp,-16
40008998:	00112623          	sw	ra,12(sp)
	unsigned long mcause;

	ARG_UNUSED(unused);

	mcause = csr_read(mcause);
4000899c:	342027f3          	csrr	a5,mcause
	if (mcause == RISCV_MACHINE_EXT_IRQ) {
		LOG_ERR("PLIC interrupt line causing the IRQ: %d",
			riscv_plic_get_irq());
	}
#endif
	z_riscv_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
400089a0:	00000593          	li	a1,0
400089a4:	00100513          	li	a0,1
400089a8:	fc5ff0ef          	jal	ra,4000896c <z_riscv_fatal_error>

400089ac <_PrepC>:
 *
 * This routine prepares for the execution of and runs C code.
 */

void _PrepC(void)
{
400089ac:	ff010113          	addi	sp,sp,-16
400089b0:	00112623          	sw	ra,12(sp)
	z_bss_zero();
400089b4:	1301f0ef          	jal	ra,40027ae4 <z_bss_zero>
	z_data_copy();
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
#endif
	z_cstart();
400089b8:	2181f0ef          	jal	ra,40027bd0 <z_cstart>

400089bc <__initialize>:
/*
 * Remainder of asm-land initialization code before we can jump into
 * the C domain
 */
SECTION_FUNC(TEXT, __initialize)
	csrr a0, mhartid
400089bc:	f1402573          	csrr	a0,mhartid
	li t0, CONFIG_RV_BOOT_HART
400089c0:	00000293          	li	t0,0
	beq a0, t0, boot_first_core
400089c4:	00550463          	beq	a0,t0,400089cc <boot_first_core>
	j boot_secondary_core
400089c8:	0440006f          	j	40008a0c <boot_secondary_core>

400089cc <boot_first_core>:
	fscsr zero
#endif

#ifdef CONFIG_INIT_STACKS
	/* Pre-populate all bytes in z_interrupt_stacks with 0xAA */
	la t0, z_interrupt_stacks
400089cc:	0002c297          	auipc	t0,0x2c
400089d0:	ba428293          	addi	t0,t0,-1116 # 40034570 <z_interrupt_stacks>
	li t1, __z_interrupt_stack_SIZEOF
400089d4:	00001337          	lui	t1,0x1
400089d8:	80030313          	addi	t1,t1,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add t1, t1, t0
400089dc:	00530333          	add	t1,t1,t0

	/* Populate z_interrupt_stacks with 0xaaaaaaaa */
	li t2, 0xaaaaaaaa
400089e0:	aaaab3b7          	lui	t2,0xaaaab
400089e4:	aaa38393          	addi	t2,t2,-1366 # aaaaaaaa <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xaaaaaaab>

400089e8 <aa_loop>:
aa_loop:
	sw t2, 0x00(t0)
400089e8:	0072a023          	sw	t2,0(t0)
	addi t0, t0, 4
400089ec:	00428293          	addi	t0,t0,4
	blt t0, t1, aa_loop
400089f0:	fe62cce3          	blt	t0,t1,400089e8 <aa_loop>

	/*
	 * Initially, setup stack pointer to
	 * z_interrupt_stacks + __z_interrupt_stack_SIZEOF
	 */
	la sp, z_interrupt_stacks
400089f4:	0002c117          	auipc	sp,0x2c
400089f8:	b7c10113          	addi	sp,sp,-1156 # 40034570 <z_interrupt_stacks>
	li t0, __z_interrupt_stack_SIZEOF
400089fc:	000012b7          	lui	t0,0x1
40008a00:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add sp, sp, t0
40008a04:	00510133          	add	sp,sp,t0

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
40008a08:	fa5ff0ef          	jal	ra,400089ac <_PrepC>

40008a0c <boot_secondary_core>:

	la t0, riscv_cpu_wake_flag
	sr zero, 0(t0)
	j z_riscv_secondary_cpu_init
#else
	j loop_unconfigured_cores
40008a0c:	0040006f          	j	40008a10 <loop_unconfigured_cores>

40008a10 <loop_unconfigured_cores>:
#endif

loop_unconfigured_cores:
	wfi
40008a10:	10500073          	wfi
	j loop_unconfigured_cores
40008a14:	ffdff06f          	j	40008a10 <loop_unconfigured_cores>

40008a18 <z_riscv_switch>:

/* void z_riscv_switch(k_thread_t *switch_to, k_thread_t *switch_from) */
SECTION_FUNC(TEXT, z_riscv_switch)

	/* Save the old thread's callee-saved registers */
	DO_CALLEE_SAVED(sr, a1)
40008a18:	0215aa23          	sw	ra,52(a1)
40008a1c:	0285ac23          	sw	s0,56(a1)
40008a20:	0295ae23          	sw	s1,60(a1)
40008a24:	0525a023          	sw	s2,64(a1)
40008a28:	0535a223          	sw	s3,68(a1)
40008a2c:	0545a423          	sw	s4,72(a1)
40008a30:	0555a623          	sw	s5,76(a1)
40008a34:	0565a823          	sw	s6,80(a1)
40008a38:	0575aa23          	sw	s7,84(a1)
40008a3c:	0585ac23          	sw	s8,88(a1)
40008a40:	0595ae23          	sw	s9,92(a1)
40008a44:	07a5a023          	sw	s10,96(a1)
40008a48:	07b5a223          	sw	s11,100(a1)

	/* Save the old thread's stack pointer */
	sr sp, _thread_offset_to_sp(a1)
40008a4c:	0225a823          	sw	sp,48(a1)

	/* Set thread->switch_handle = thread to mark completion */
	sr a1, ___thread_t_switch_handle_OFFSET(a1)
40008a50:	0cb5a023          	sw	a1,192(a1)

	/* Get the new thread's stack pointer */
	lr sp, _thread_offset_to_sp(a0)
40008a54:	03052103          	lw	sp,48(a0)
	call z_thread_mark_switched_in
	mv a0, s0
#endif

	/* Restore the new thread's callee-saved registers */
	DO_CALLEE_SAVED(lr, a0)
40008a58:	03452083          	lw	ra,52(a0)
40008a5c:	03852403          	lw	s0,56(a0)
40008a60:	03c52483          	lw	s1,60(a0)
40008a64:	04052903          	lw	s2,64(a0)
40008a68:	04452983          	lw	s3,68(a0)
40008a6c:	04852a03          	lw	s4,72(a0)
40008a70:	04c52a83          	lw	s5,76(a0)
40008a74:	05052b03          	lw	s6,80(a0)
40008a78:	05452b83          	lw	s7,84(a0)
40008a7c:	05852c03          	lw	s8,88(a0)
40008a80:	05c52c83          	lw	s9,92(a0)
40008a84:	06052d03          	lw	s10,96(a0)
40008a88:	06452d83          	lw	s11,100(a0)

	/* Return to arch_switch() or _irq_wrapper() */
	ret
40008a8c:	00008067          	ret

40008a90 <arch_new_thread>:
#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	const struct soc_esf soc_esf_init = {SOC_ESF_INIT};
#endif

	/* Initial stack frame for thread */
	stack_init = (struct __esf *)Z_STACK_PTR_ALIGN(
40008a90:	fb060613          	addi	a2,a2,-80
 * @param ptr Proposed stack pointer address
 * @return Properly aligned stack pointer address
 */
static inline char *z_stack_ptr_align(char *ptr)
{
	return (char *)ROUND_DOWN(ptr, ARCH_STACK_PTR_ALIGN);
40008a94:	ff067613          	andi	a2,a2,-16
				);

	/* Setup the initial stack frame */
	stack_init->a0 = (unsigned long)entry;
	stack_init->a1 = (unsigned long)p1;
	stack_init->a2 = (unsigned long)p2;
40008a98:	02f62423          	sw	a5,40(a2)
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to z_thread_entry, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = MSTATUS_DEF_RESTORE;
40008a9c:	000027b7          	lui	a5,0x2
40008aa0:	88078793          	addi	a5,a5,-1920 # 1880 <CONFIG_HEAP_MEM_POOL_SIZE+0x880>
40008aa4:	04f62223          	sw	a5,68(a2)
		/* User thread */
		stack_init->mepc = (unsigned long)k_thread_user_mode_enter;

	} else {
		/* Supervisor thread */
		stack_init->mepc = (unsigned long)z_thread_entry;
40008aa8:	400017b7          	lui	a5,0x40001
40008aac:	ffc78793          	addi	a5,a5,-4 # 40000ffc <z_thread_entry>
40008ab0:	04f62023          	sw	a5,64(a2)
#endif

	thread->callee_saved.sp = (unsigned long)stack_init;

	/* where to go when returning from z_riscv_switch() */
	thread->callee_saved.ra = (unsigned long)z_riscv_thread_start;
40008ab4:	400007b7          	lui	a5,0x40000
	stack_init->a0 = (unsigned long)entry;
40008ab8:	02d62023          	sw	a3,32(a2)
	stack_init->a1 = (unsigned long)p1;
40008abc:	02e62223          	sw	a4,36(a2)
	stack_init->a3 = (unsigned long)p3;
40008ac0:	03062623          	sw	a6,44(a2)
	thread->callee_saved.ra = (unsigned long)z_riscv_thread_start;
40008ac4:	15478793          	addi	a5,a5,340 # 40000154 <z_riscv_thread_start>
	thread->callee_saved.sp = (unsigned long)stack_init;
40008ac8:	02c52823          	sw	a2,48(a0)
	thread->callee_saved.ra = (unsigned long)z_riscv_thread_start;
40008acc:	02f52a23          	sw	a5,52(a0)

	/* our switch handle is the thread pointer itself */
	thread->switch_handle = thread;
40008ad0:	0ca52023          	sw	a0,192(a0)
}
40008ad4:	00008067          	ret

40008ad8 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
40008ad8:	ff010113          	addi	sp,sp,-16
40008adc:	00812423          	sw	s0,8(sp)
40008ae0:	01212023          	sw	s2,0(sp)
40008ae4:	00112623          	sw	ra,12(sp)
40008ae8:	00058913          	mv	s2,a1
40008aec:	00912223          	sw	s1,4(sp)
40008af0:	00050693          	mv	a3,a0
	register const char *s = nptr;
40008af4:	00050413          	mv	s0,a0
40008af8:	02000813          	li	a6,32
40008afc:	00400593          	li	a1,4
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
40008b00:	00040713          	mv	a4,s0
40008b04:	00044783          	lbu	a5,0(s0)
40008b08:	00140413          	addi	s0,s0,1
40008b0c:	ff078ae3          	beq	a5,a6,40008b00 <strtol+0x28>
40008b10:	ff778513          	addi	a0,a5,-9
40008b14:	fea5f6e3          	bgeu	a1,a0,40008b00 <strtol+0x28>
	} while (isspace((unsigned char)c) != 0);
	if (c == '-') {
40008b18:	02d00593          	li	a1,45
40008b1c:	02b79a63          	bne	a5,a1,40008b50 <strtol+0x78>
		neg = 1;
		c = *s++;
40008b20:	00174783          	lbu	a5,1(a4)
40008b24:	00270413          	addi	s0,a4,2
		neg = 1;
40008b28:	00100813          	li	a6,1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
40008b2c:	02061e63          	bnez	a2,40008b68 <strtol+0x90>
40008b30:	03000713          	li	a4,48
		s += 2;
		base = 16;
	}

	if (base == 0) {
		base = c == '0' ? 8 : 10;
40008b34:	00a00613          	li	a2,10
	if ((base == 0 || base == 16) &&
40008b38:	04e79e63          	bne	a5,a4,40008b94 <strtol+0xbc>
	    c == '0' && (*s == 'x' || *s == 'X')) {
40008b3c:	00044703          	lbu	a4,0(s0)
40008b40:	05800593          	li	a1,88
		base = c == '0' ? 8 : 10;
40008b44:	00800613          	li	a2,8
	    c == '0' && (*s == 'x' || *s == 'X')) {
40008b48:	0df77713          	andi	a4,a4,223
40008b4c:	0380006f          	j	40008b84 <strtol+0xac>
	} else if (c == '+') {
40008b50:	02b00593          	li	a1,43
	register int neg = 0, any, cutlim;
40008b54:	00000813          	li	a6,0
	} else if (c == '+') {
40008b58:	fcb79ae3          	bne	a5,a1,40008b2c <strtol+0x54>
		c = *s++;
40008b5c:	00174783          	lbu	a5,1(a4)
40008b60:	00270413          	addi	s0,a4,2
40008b64:	fc9ff06f          	j	40008b2c <strtol+0x54>
	if ((base == 0 || base == 16) &&
40008b68:	01000713          	li	a4,16
40008b6c:	02e61463          	bne	a2,a4,40008b94 <strtol+0xbc>
40008b70:	03000713          	li	a4,48
40008b74:	02e79063          	bne	a5,a4,40008b94 <strtol+0xbc>
	    c == '0' && (*s == 'x' || *s == 'X')) {
40008b78:	00044703          	lbu	a4,0(s0)
40008b7c:	05800593          	li	a1,88
40008b80:	0df77713          	andi	a4,a4,223
40008b84:	00b71863          	bne	a4,a1,40008b94 <strtol+0xbc>
		c = s[1];
40008b88:	00144783          	lbu	a5,1(s0)
		base = 16;
40008b8c:	01000613          	li	a2,16
		s += 2;
40008b90:	00240413          	addi	s0,s0,2
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
40008b94:	800004b7          	lui	s1,0x80000
40008b98:	fff48493          	addi	s1,s1,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
40008b9c:	009804b3          	add	s1,a6,s1
	cutlim = cutoff % (unsigned long)base;
40008ba0:	02c4feb3          	remu	t4,s1,a2
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
40008ba4:	00000593          	li	a1,0
40008ba8:	00000513          	li	a0,0
		if (isdigit((unsigned char)c) != 0) {
40008bac:	00900f13          	li	t5,9
			c -= '0';
		} else if (isalpha((unsigned char)c) != 0) {
40008bb0:	01900e13          	li	t3,25
			break;
		}
		if (c >= base) {
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
40008bb4:	fff00f93          	li	t6,-1
	cutoff /= (unsigned long)base;
40008bb8:	02c4d333          	divu	t1,s1,a2
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
40008bbc:	fd078713          	addi	a4,a5,-48
		if (isdigit((unsigned char)c) != 0) {
40008bc0:	02ef6c63          	bltu	t5,a4,40008bf8 <strtol+0x120>
			c -= '0';
40008bc4:	00070793          	mv	a5,a4
		if (c >= base) {
40008bc8:	04c7da63          	bge	a5,a2,40008c1c <strtol+0x144>
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
40008bcc:	03f58063          	beq	a1,t6,40008bec <strtol+0x114>
			any = -1;
40008bd0:	fff00593          	li	a1,-1
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
40008bd4:	00a36c63          	bltu	t1,a0,40008bec <strtol+0x114>
40008bd8:	00651463          	bne	a0,t1,40008be0 <strtol+0x108>
40008bdc:	00fec863          	blt	t4,a5,40008bec <strtol+0x114>
		} else {
			any = 1;
40008be0:	00100593          	li	a1,1
			acc *= base;
40008be4:	02a60533          	mul	a0,a2,a0
			acc += c;
40008be8:	00a78533          	add	a0,a5,a0
	for (acc = 0, any = 0;; c = *s++) {
40008bec:	00140413          	addi	s0,s0,1
40008bf0:	fff44783          	lbu	a5,-1(s0)
		if (isdigit((unsigned char)c) != 0) {
40008bf4:	fc9ff06f          	j	40008bbc <strtol+0xe4>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
40008bf8:	0207e713          	ori	a4,a5,32
40008bfc:	f9f70713          	addi	a4,a4,-97
		} else if (isalpha((unsigned char)c) != 0) {
40008c00:	00ee6e63          	bltu	t3,a4,40008c1c <strtol+0x144>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
40008c04:	fbf78893          	addi	a7,a5,-65
			c -= isupper((unsigned char)c) != 0 ? 'A' - 10 : 'a' - 10;
40008c08:	03700713          	li	a4,55
40008c0c:	011e7463          	bgeu	t3,a7,40008c14 <strtol+0x13c>
40008c10:	05700713          	li	a4,87
40008c14:	40e787b3          	sub	a5,a5,a4
40008c18:	fb1ff06f          	j	40008bc8 <strtol+0xf0>
		}
	}

	if (any < 0) {
40008c1c:	fff00793          	li	a5,-1
40008c20:	02f59863          	bne	a1,a5,40008c50 <strtol+0x178>
40008c24:	5391e0ef          	jal	ra,4002795c <z_impl_z_errno>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
40008c28:	02200793          	li	a5,34
40008c2c:	00f52023          	sw	a5,0(a0)
		acc = neg ? LONG_MIN : LONG_MAX;
40008c30:	00048513          	mv	a0,s1
	} else if (neg) {
		acc = -acc;
	}

	if (endptr != NULL) {
40008c34:	02091663          	bnez	s2,40008c60 <strtol+0x188>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
40008c38:	00c12083          	lw	ra,12(sp)
40008c3c:	00812403          	lw	s0,8(sp)
40008c40:	00412483          	lw	s1,4(sp)
40008c44:	00012903          	lw	s2,0(sp)
40008c48:	01010113          	addi	sp,sp,16
40008c4c:	00008067          	ret
	} else if (neg) {
40008c50:	00080463          	beqz	a6,40008c58 <strtol+0x180>
		acc = -acc;
40008c54:	40a00533          	neg	a0,a0
	if (endptr != NULL) {
40008c58:	fe0900e3          	beqz	s2,40008c38 <strtol+0x160>
		*endptr = (char *)(any ? s - 1 : nptr);
40008c5c:	00058463          	beqz	a1,40008c64 <strtol+0x18c>
40008c60:	fff40693          	addi	a3,s0,-1
40008c64:	00d92023          	sw	a3,0(s2)
40008c68:	fd1ff06f          	j	40008c38 <strtol+0x160>

40008c6c <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
40008c6c:	ff010113          	addi	sp,sp,-16
40008c70:	00812423          	sw	s0,8(sp)
40008c74:	00912223          	sw	s1,4(sp)
40008c78:	00112623          	sw	ra,12(sp)
40008c7c:	00058493          	mv	s1,a1
40008c80:	00050693          	mv	a3,a0
	register const char *s = nptr;
40008c84:	00050413          	mv	s0,a0
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
40008c88:	02000813          	li	a6,32
40008c8c:	00400593          	li	a1,4

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
40008c90:	00040713          	mv	a4,s0
40008c94:	00044783          	lbu	a5,0(s0)
40008c98:	00140413          	addi	s0,s0,1
40008c9c:	ff078ae3          	beq	a5,a6,40008c90 <strtoul+0x24>
40008ca0:	ff778513          	addi	a0,a5,-9
40008ca4:	fea5f6e3          	bgeu	a1,a0,40008c90 <strtoul+0x24>
	} while (isspace((unsigned char)c) != 0);
	if (c == '-') {
40008ca8:	02d00593          	li	a1,45
40008cac:	02b79a63          	bne	a5,a1,40008ce0 <strtoul+0x74>
		neg = 1;
		c = *s++;
40008cb0:	00174783          	lbu	a5,1(a4)
40008cb4:	00270413          	addi	s0,a4,2
		neg = 1;
40008cb8:	00100313          	li	t1,1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
40008cbc:	02061e63          	bnez	a2,40008cf8 <strtoul+0x8c>
40008cc0:	03000713          	li	a4,48
		s += 2;
		base = 16;
	}

	if (base == 0) {
		base = c == '0' ? 8 : 10;
40008cc4:	00a00613          	li	a2,10
	if ((base == 0 || base == 16) &&
40008cc8:	04e79e63          	bne	a5,a4,40008d24 <strtoul+0xb8>
	    c == '0' && (*s == 'x' || *s == 'X')) {
40008ccc:	00044703          	lbu	a4,0(s0)
40008cd0:	05800593          	li	a1,88
		base = c == '0' ? 8 : 10;
40008cd4:	00800613          	li	a2,8
	    c == '0' && (*s == 'x' || *s == 'X')) {
40008cd8:	0df77713          	andi	a4,a4,223
40008cdc:	0380006f          	j	40008d14 <strtoul+0xa8>
	} else if (c == '+') {
40008ce0:	02b00593          	li	a1,43
	register int neg = 0, any, cutlim;
40008ce4:	00000313          	li	t1,0
	} else if (c == '+') {
40008ce8:	fcb79ae3          	bne	a5,a1,40008cbc <strtoul+0x50>
		c = *s++;
40008cec:	00174783          	lbu	a5,1(a4)
40008cf0:	00270413          	addi	s0,a4,2
40008cf4:	fc9ff06f          	j	40008cbc <strtoul+0x50>
	if ((base == 0 || base == 16) &&
40008cf8:	01000713          	li	a4,16
40008cfc:	02e61463          	bne	a2,a4,40008d24 <strtoul+0xb8>
40008d00:	03000713          	li	a4,48
40008d04:	02e79063          	bne	a5,a4,40008d24 <strtoul+0xb8>
	    c == '0' && (*s == 'x' || *s == 'X')) {
40008d08:	00044703          	lbu	a4,0(s0)
40008d0c:	05800593          	li	a1,88
40008d10:	0df77713          	andi	a4,a4,223
40008d14:	00b71863          	bne	a4,a1,40008d24 <strtoul+0xb8>
		c = s[1];
40008d18:	00144783          	lbu	a5,1(s0)
		base = 16;
40008d1c:	01000613          	li	a2,16
		s += 2;
40008d20:	00240413          	addi	s0,s0,2
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
40008d24:	fff00713          	li	a4,-1
40008d28:	02c75e33          	divu	t3,a4,a2
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
40008d2c:	00000593          	li	a1,0
40008d30:	00000513          	li	a0,0
		if (isdigit((unsigned char)c) != 0) {
40008d34:	00900f13          	li	t5,9
			c -= '0';
		} else if (isalpha((unsigned char)c) != 0) {
40008d38:	01900e93          	li	t4,25
			break;
		}
		if (c >= base) {
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
40008d3c:	fff00f93          	li	t6,-1
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
40008d40:	02c77833          	remu	a6,a4,a2
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
40008d44:	fd078713          	addi	a4,a5,-48
		if (isdigit((unsigned char)c) != 0) {
40008d48:	02ef6c63          	bltu	t5,a4,40008d80 <strtoul+0x114>
			c -= '0';
40008d4c:	00070793          	mv	a5,a4
		if (c >= base) {
40008d50:	04c7da63          	bge	a5,a2,40008da4 <strtoul+0x138>
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
40008d54:	03f58063          	beq	a1,t6,40008d74 <strtoul+0x108>
			any = -1;
40008d58:	fff00593          	li	a1,-1
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
40008d5c:	00ae6c63          	bltu	t3,a0,40008d74 <strtoul+0x108>
40008d60:	01c51463          	bne	a0,t3,40008d68 <strtoul+0xfc>
40008d64:	00f84863          	blt	a6,a5,40008d74 <strtoul+0x108>
		} else {
			any = 1;
40008d68:	00100593          	li	a1,1
			acc *= base;
40008d6c:	02a60533          	mul	a0,a2,a0
			acc += c;
40008d70:	00a78533          	add	a0,a5,a0
	for (acc = 0, any = 0;; c = *s++) {
40008d74:	00140413          	addi	s0,s0,1
40008d78:	fff44783          	lbu	a5,-1(s0)
		if (isdigit((unsigned char)c) != 0) {
40008d7c:	fc9ff06f          	j	40008d44 <strtoul+0xd8>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
40008d80:	0207e713          	ori	a4,a5,32
40008d84:	f9f70713          	addi	a4,a4,-97
		} else if (isalpha((unsigned char)c) != 0) {
40008d88:	00eeee63          	bltu	t4,a4,40008da4 <strtoul+0x138>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
40008d8c:	fbf78893          	addi	a7,a5,-65
			c -= isupper((unsigned char)c) != 0 ? 'A' - 10 : 'a' - 10;
40008d90:	03700713          	li	a4,55
40008d94:	011ef463          	bgeu	t4,a7,40008d9c <strtoul+0x130>
40008d98:	05700713          	li	a4,87
40008d9c:	40e787b3          	sub	a5,a5,a4
40008da0:	fb1ff06f          	j	40008d50 <strtoul+0xe4>
		}
	}
	if (any < 0) {
40008da4:	fff00793          	li	a5,-1
40008da8:	02f59663          	bne	a1,a5,40008dd4 <strtoul+0x168>
40008dac:	3b11e0ef          	jal	ra,4002795c <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
40008db0:	02200793          	li	a5,34
40008db4:	00f52023          	sw	a5,0(a0)
		acc = ULONG_MAX;
40008db8:	fff00513          	li	a0,-1
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
40008dbc:	02049463          	bnez	s1,40008de4 <strtoul+0x178>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
40008dc0:	00c12083          	lw	ra,12(sp)
40008dc4:	00812403          	lw	s0,8(sp)
40008dc8:	00412483          	lw	s1,4(sp)
40008dcc:	01010113          	addi	sp,sp,16
40008dd0:	00008067          	ret
	} else if (neg) {
40008dd4:	00030463          	beqz	t1,40008ddc <strtoul+0x170>
		acc = -acc;
40008dd8:	40a00533          	neg	a0,a0
	if (endptr != NULL) {
40008ddc:	fe0482e3          	beqz	s1,40008dc0 <strtoul+0x154>
		*endptr = (char *)(any ? s - 1 : nptr);
40008de0:	00058463          	beqz	a1,40008de8 <strtoul+0x17c>
40008de4:	fff40693          	addi	a3,s0,-1
40008de8:	00d4a023          	sw	a3,0(s1)
	return acc;
40008dec:	fd5ff06f          	j	40008dc0 <strtoul+0x154>

40008df0 <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
40008df0:	fe010113          	addi	sp,sp,-32
40008df4:	00812c23          	sw	s0,24(sp)
40008df8:	00112e23          	sw	ra,28(sp)
40008dfc:	00912a23          	sw	s1,20(sp)
40008e00:	01212823          	sw	s2,16(sp)
40008e04:	01312623          	sw	s3,12(sp)
40008e08:	01412423          	sw	s4,8(sp)
	char c, sc;
	size_t len;

	c = *find++;
40008e0c:	0005ca03          	lbu	s4,0(a1)
{
40008e10:	00050413          	mv	s0,a0
	if (c != 0) {
40008e14:	020a0c63          	beqz	s4,40008e4c <strstr+0x5c>
	c = *find++;
40008e18:	00158493          	addi	s1,a1,1
		len = strlen(find);
40008e1c:	00048513          	mv	a0,s1
40008e20:	108000ef          	jal	ra,40008f28 <strlen>
40008e24:	00050913          	mv	s2,a0
		do {
			do {
				sc = *s++;
40008e28:	00044783          	lbu	a5,0(s0)
40008e2c:	00140993          	addi	s3,s0,1
				if (sc == 0) {
40008e30:	04078463          	beqz	a5,40008e78 <strstr+0x88>
					return NULL;
				}
			} while (sc != c);
40008e34:	02fa1e63          	bne	s4,a5,40008e70 <strstr+0x80>
		} while (strncmp(s, find, len) != 0);
40008e38:	00090613          	mv	a2,s2
40008e3c:	00048593          	mv	a1,s1
40008e40:	00098513          	mv	a0,s3
40008e44:	14c000ef          	jal	ra,40008f90 <strncmp>
40008e48:	02051463          	bnez	a0,40008e70 <strstr+0x80>
		s--;
	}
	return (char *)s;
}
40008e4c:	01c12083          	lw	ra,28(sp)
40008e50:	00040513          	mv	a0,s0
40008e54:	01812403          	lw	s0,24(sp)
40008e58:	01412483          	lw	s1,20(sp)
40008e5c:	01012903          	lw	s2,16(sp)
40008e60:	00c12983          	lw	s3,12(sp)
40008e64:	00812a03          	lw	s4,8(sp)
40008e68:	02010113          	addi	sp,sp,32
40008e6c:	00008067          	ret
{
40008e70:	00098413          	mv	s0,s3
40008e74:	fb5ff06f          	j	40008e28 <strstr+0x38>
					return NULL;
40008e78:	00000413          	li	s0,0
40008e7c:	fd1ff06f          	j	40008e4c <strstr+0x5c>

40008e80 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
40008e80:	00050793          	mv	a5,a0
40008e84:	0005c703          	lbu	a4,0(a1)
40008e88:	00071663          	bnez	a4,40008e94 <strcpy+0x14>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
40008e8c:	00078023          	sb	zero,0(a5)

	return dest;
}
40008e90:	00008067          	ret
		*d = *s;
40008e94:	00e78023          	sb	a4,0(a5)
		s++;
40008e98:	00158593          	addi	a1,a1,1
		d++;
40008e9c:	00178793          	addi	a5,a5,1
		s++;
40008ea0:	fe5ff06f          	j	40008e84 <strcpy+0x4>

40008ea4 <strncpy>:

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
	char *dest = d;

	while ((n > 0) && *s != '\0') {
40008ea4:	00050793          	mv	a5,a0
40008ea8:	00061863          	bnez	a2,40008eb8 <strncpy+0x14>
40008eac:	00c78633          	add	a2,a5,a2
		s++;
		d++;
		n--;
	}

	while (n > 0) {
40008eb0:	02c79263          	bne	a5,a2,40008ed4 <strncpy+0x30>
		d++;
		n--;
	}

	return dest;
}
40008eb4:	00008067          	ret
	while ((n > 0) && *s != '\0') {
40008eb8:	0005c703          	lbu	a4,0(a1)
40008ebc:	fe0708e3          	beqz	a4,40008eac <strncpy+0x8>
		*d = *s;
40008ec0:	00e78023          	sb	a4,0(a5)
		s++;
40008ec4:	00158593          	addi	a1,a1,1
		d++;
40008ec8:	00178793          	addi	a5,a5,1
		n--;
40008ecc:	fff60613          	addi	a2,a2,-1
40008ed0:	fd9ff06f          	j	40008ea8 <strncpy+0x4>
		*d = '\0';
40008ed4:	00078023          	sb	zero,0(a5)
		d++;
40008ed8:	00178793          	addi	a5,a5,1
		n--;
40008edc:	fd5ff06f          	j	40008eb0 <strncpy+0xc>

40008ee0 <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
40008ee0:	0ff5f593          	zext.b	a1,a1

	while ((*s != tmp) && (*s != '\0')) {
40008ee4:	00054783          	lbu	a5,0(a0)
40008ee8:	00b78863          	beq	a5,a1,40008ef8 <strchr+0x18>
40008eec:	00079863          	bnez	a5,40008efc <strchr+0x1c>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
40008ef0:	00058463          	beqz	a1,40008ef8 <strchr+0x18>
40008ef4:	00000513          	li	a0,0
}
40008ef8:	00008067          	ret
		s++;
40008efc:	00150513          	addi	a0,a0,1
40008f00:	fe5ff06f          	j	40008ee4 <strchr+0x4>

40008f04 <strrchr>:
 *
 * @return pointer to last instance of found byte, or NULL if not found
 */

char *strrchr(const char *s, int c)
{
40008f04:	00050793          	mv	a5,a0
	char *match = NULL;

	do {
		if (*s == (char)c) {
40008f08:	0ff5f593          	zext.b	a1,a1
	char *match = NULL;
40008f0c:	00000513          	li	a0,0
		if (*s == (char)c) {
40008f10:	0007c703          	lbu	a4,0(a5)
40008f14:	00b71463          	bne	a4,a1,40008f1c <strrchr+0x18>
40008f18:	00078513          	mv	a0,a5
			match = (char *)s;
		}
	} while (*s++);
40008f1c:	00178793          	addi	a5,a5,1
40008f20:	fe0718e3          	bnez	a4,40008f10 <strrchr+0xc>

	return match;
}
40008f24:	00008067          	ret

40008f28 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
40008f28:	00050793          	mv	a5,a0
	size_t n = 0;
40008f2c:	00000513          	li	a0,0

	while (*s != '\0') {
40008f30:	00a78733          	add	a4,a5,a0
40008f34:	00074703          	lbu	a4,0(a4)
40008f38:	00071463          	bnez	a4,40008f40 <strlen+0x18>
		s++;
		n++;
	}

	return n;
}
40008f3c:	00008067          	ret
		n++;
40008f40:	00150513          	addi	a0,a0,1
40008f44:	fedff06f          	j	40008f30 <strlen+0x8>

40008f48 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
40008f48:	00050793          	mv	a5,a0
	size_t n = 0;
40008f4c:	00000513          	li	a0,0

	while (*s != '\0' && n < maxlen) {
40008f50:	00a78733          	add	a4,a5,a0
40008f54:	00074703          	lbu	a4,0(a4)
40008f58:	00070463          	beqz	a4,40008f60 <strnlen+0x18>
40008f5c:	00b51463          	bne	a0,a1,40008f64 <strnlen+0x1c>
		s++;
		n++;
	}

	return n;
}
40008f60:	00008067          	ret
		n++;
40008f64:	00150513          	addi	a0,a0,1
40008f68:	fe9ff06f          	j	40008f50 <strnlen+0x8>

40008f6c <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
40008f6c:	00054783          	lbu	a5,0(a0)
40008f70:	0005c703          	lbu	a4,0(a1)
40008f74:	00e79463          	bne	a5,a4,40008f7c <strcmp+0x10>
40008f78:	00079663          	bnez	a5,40008f84 <strcmp+0x18>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
40008f7c:	40e78533          	sub	a0,a5,a4
40008f80:	00008067          	ret
		s1++;
40008f84:	00150513          	addi	a0,a0,1
		s2++;
40008f88:	00158593          	addi	a1,a1,1
40008f8c:	fe1ff06f          	j	40008f6c <strcmp>

40008f90 <strncmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
40008f90:	02060a63          	beqz	a2,40008fc4 <strncmp+0x34>
40008f94:	00054703          	lbu	a4,0(a0)
40008f98:	0005c783          	lbu	a5,0(a1)
40008f9c:	00e79463          	bne	a5,a4,40008fa4 <strncmp+0x14>
40008fa0:	00079a63          	bnez	a5,40008fb4 <strncmp+0x24>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
40008fa4:	00054503          	lbu	a0,0(a0)
40008fa8:	0005c783          	lbu	a5,0(a1)
40008fac:	40f50533          	sub	a0,a0,a5
}
40008fb0:	00008067          	ret
		s1++;
40008fb4:	00150513          	addi	a0,a0,1
		s2++;
40008fb8:	00158593          	addi	a1,a1,1
		n--;
40008fbc:	fff60613          	addi	a2,a2,-1
40008fc0:	fd1ff06f          	j	40008f90 <strncmp>
	return (n == 0) ? 0 : (*s1 - *s2);
40008fc4:	00000513          	li	a0,0
40008fc8:	00008067          	ret

40008fcc <memcmp>:
int memcmp(const void *m1, const void *m2, size_t n)
{
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
40008fcc:	02060863          	beqz	a2,40008ffc <memcmp+0x30>
40008fd0:	fff60613          	addi	a2,a2,-1
40008fd4:	00000713          	li	a4,0
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
40008fd8:	00e507b3          	add	a5,a0,a4
40008fdc:	00e586b3          	add	a3,a1,a4
40008fe0:	0007c783          	lbu	a5,0(a5)
40008fe4:	0006c683          	lbu	a3,0(a3)
40008fe8:	00e60663          	beq	a2,a4,40008ff4 <memcmp+0x28>
40008fec:	00170713          	addi	a4,a4,1
40008ff0:	fed784e3          	beq	a5,a3,40008fd8 <memcmp+0xc>
		c1++;
		c2++;
	}

	return *c1 - *c2;
40008ff4:	40d78533          	sub	a0,a5,a3
40008ff8:	00008067          	ret
		return 0;
40008ffc:	00000513          	li	a0,0
}
40009000:	00008067          	ret

40009004 <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
40009004:	40b507b3          	sub	a5,a0,a1
40009008:	02c7fe63          	bgeu	a5,a2,40009044 <memmove+0x40>
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
			n--;
4000900c:	fff60613          	addi	a2,a2,-1
			dest[n] = src[n];
40009010:	00c587b3          	add	a5,a1,a2
40009014:	0007c703          	lbu	a4,0(a5)
40009018:	00c507b3          	add	a5,a0,a2
4000901c:	00e78023          	sb	a4,0(a5)
		while (n > 0) {
40009020:	fe0616e3          	bnez	a2,4000900c <memmove+0x8>
40009024:	00008067          	ret
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
			*dest = *src;
40009028:	00f58733          	add	a4,a1,a5
4000902c:	00074683          	lbu	a3,0(a4)
40009030:	00f50733          	add	a4,a0,a5
40009034:	00178793          	addi	a5,a5,1
40009038:	00d70023          	sb	a3,0(a4)
		while (n > 0) {
4000903c:	fef616e3          	bne	a2,a5,40009028 <memmove+0x24>
			n--;
		}
	}

	return d;
}
40009040:	00008067          	ret
40009044:	00000793          	li	a5,0
40009048:	ff5ff06f          	j	4000903c <memmove+0x38>

4000904c <memcpy>:
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
4000904c:	00000793          	li	a5,0
40009050:	00f61463          	bne	a2,a5,40009058 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
40009054:	00008067          	ret
		*(d_byte++) = *(s_byte++);
40009058:	00f586b3          	add	a3,a1,a5
4000905c:	0006c683          	lbu	a3,0(a3)
40009060:	00f50733          	add	a4,a0,a5
40009064:	00178793          	addi	a5,a5,1
40009068:	00d70023          	sb	a3,0(a4)
		n--;
4000906c:	fe5ff06f          	j	40009050 <memcpy+0x4>

40009070 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
40009070:	0ff5f593          	zext.b	a1,a1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
40009074:	00c50633          	add	a2,a0,a2
	unsigned char *d_byte = (unsigned char *)buf;
40009078:	00050793          	mv	a5,a0
	while (n > 0) {
4000907c:	00c79463          	bne	a5,a2,40009084 <memset+0x14>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
40009080:	00008067          	ret
		*(d_byte++) = c_byte;
40009084:	00178793          	addi	a5,a5,1
40009088:	feb78fa3          	sb	a1,-1(a5)
		n--;
4000908c:	ff1ff06f          	j	4000907c <memset+0xc>

40009090 <memchr>:
 *
 * @return pointer to start of found byte
 */

void *memchr(const void *s, int c, size_t n)
{
40009090:	00050793          	mv	a5,a0
	if (n != 0) {
40009094:	02060063          	beqz	a2,400090b4 <memchr+0x24>
40009098:	00c50633          	add	a2,a0,a2
		const unsigned char *p = s;

		do {
			if (*p++ == (unsigned char)c) {
4000909c:	0ff5f593          	zext.b	a1,a1
400090a0:	00078513          	mv	a0,a5
400090a4:	00054703          	lbu	a4,0(a0)
400090a8:	00178793          	addi	a5,a5,1
400090ac:	00b70663          	beq	a4,a1,400090b8 <memchr+0x28>
				return ((void *)(p - 1));
			}

		} while (--n != 0);
400090b0:	fec798e3          	bne	a5,a2,400090a0 <memchr+0x10>
	}

	return NULL;
400090b4:	00000513          	li	a0,0
}
400090b8:	00008067          	ret

400090bc <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
400090bc:	fff00513          	li	a0,-1
400090c0:	00008067          	ret

400090c4 <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
400090c4:	4003d7b7          	lui	a5,0x4003d
400090c8:	a0a7a823          	sw	a0,-1520(a5) # 4003ca10 <_stdout_hook>
}
400090cc:	00008067          	ret

400090d0 <sprintf_out>:
	int len;
};

static int sprintf_out(int c, struct emitter *p)
{
	if (p->len > 1) { /* need to reserve a byte for EOS */
400090d0:	0045a703          	lw	a4,4(a1)
400090d4:	00100793          	li	a5,1
400090d8:	02e7d263          	bge	a5,a4,400090fc <sprintf_out+0x2c>
		*(p->ptr) = c;
400090dc:	0005a783          	lw	a5,0(a1)
400090e0:	00a78023          	sb	a0,0(a5)
		p->ptr += 1;
400090e4:	0005a783          	lw	a5,0(a1)
400090e8:	00178793          	addi	a5,a5,1
400090ec:	00f5a023          	sw	a5,0(a1)
		p->len -= 1;
400090f0:	0045a783          	lw	a5,4(a1)
400090f4:	fff78793          	addi	a5,a5,-1
400090f8:	00f5a223          	sw	a5,4(a1)
	}
	return 0; /* indicate keep going so we get the total count */
}
400090fc:	00000513          	li	a0,0
40009100:	00008067          	ret

40009104 <snprintf>:

int snprintf(char *ZRESTRICT str, size_t len,
	     const char *ZRESTRICT format, ...)
{
40009104:	fc010113          	addi	sp,sp,-64
40009108:	00112e23          	sw	ra,28(sp)
4000910c:	02d12623          	sw	a3,44(sp)
40009110:	02e12823          	sw	a4,48(sp)
40009114:	02f12a23          	sw	a5,52(sp)
40009118:	03012c23          	sw	a6,56(sp)
4000911c:	03112e23          	sw	a7,60(sp)

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
40009120:	00059463          	bnez	a1,40009128 <snprintf+0x24>
		str = &dummy; /* write final NUL to dummy, can't change *s */
40009124:	00310513          	addi	a0,sp,3
	}

	p.ptr = str;
40009128:	00a12423          	sw	a0,8(sp)
4000912c:	40009537          	lui	a0,0x40009
	p.len = (int) len;
40009130:	00b12623          	sw	a1,12(sp)

	va_start(vargs, format);
40009134:	02c10693          	addi	a3,sp,44
40009138:	00810593          	addi	a1,sp,8
4000913c:	00000713          	li	a4,0
40009140:	0d050513          	addi	a0,a0,208 # 400090d0 <sprintf_out>
40009144:	00d12223          	sw	a3,4(sp)
40009148:	c01f80ef          	jal	ra,40001d48 <z_cbvprintf_impl>
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
	va_end(vargs);

	*(p.ptr) = 0;
4000914c:	00812783          	lw	a5,8(sp)
40009150:	00078023          	sb	zero,0(a5)
	return r;
}
40009154:	01c12083          	lw	ra,28(sp)
40009158:	04010113          	addi	sp,sp,64
4000915c:	00008067          	ret

40009160 <foldcase>:
#define EOS '\0'

static inline int foldcase(int ch, int flags)
{

	if ((flags & FNM_CASEFOLD) != 0 && isupper(ch)) {
40009160:	0085f593          	andi	a1,a1,8
40009164:	00058a63          	beqz	a1,40009178 <foldcase+0x18>
40009168:	fbf50793          	addi	a5,a0,-65
4000916c:	01900713          	li	a4,25
40009170:	00f76463          	bltu	a4,a5,40009178 <foldcase+0x18>
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
40009174:	02050513          	addi	a0,a0,32
		return tolower(ch);
	}

	return ch;
}
40009178:	00008067          	ret

4000917c <fnmatchx>:
static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
{
	const char *stringstart, *r;
	char c, test;

	if (pattern == NULL || string == NULL) {
4000917c:	00051663          	bnez	a0,40009188 <fnmatchx+0xc>
		return FNM_NOMATCH;
40009180:	00100513          	li	a0,1

			break;
		}
	}
	/* NOTREACHED */
}
40009184:	00008067          	ret
{
40009188:	fb010113          	addi	sp,sp,-80
4000918c:	03512a23          	sw	s5,52(sp)
40009190:	04112623          	sw	ra,76(sp)
40009194:	04812423          	sw	s0,72(sp)
40009198:	04912223          	sw	s1,68(sp)
4000919c:	05212023          	sw	s2,64(sp)
400091a0:	03312e23          	sw	s3,60(sp)
400091a4:	03412c23          	sw	s4,56(sp)
400091a8:	03612823          	sw	s6,48(sp)
400091ac:	03712623          	sw	s7,44(sp)
400091b0:	03812423          	sw	s8,40(sp)
400091b4:	03912223          	sw	s9,36(sp)
400091b8:	03a12023          	sw	s10,32(sp)
400091bc:	01b12e23          	sw	s11,28(sp)
400091c0:	00058a93          	mv	s5,a1
	if (pattern == NULL || string == NULL) {
400091c4:	0c058863          	beqz	a1,40009294 <fnmatchx+0x118>
400091c8:	00050b93          	mv	s7,a0
400091cc:	00068b13          	mv	s6,a3
		return FNM_NORES;
400091d0:	00300513          	li	a0,3
	if (recursion-- == 0) {
400091d4:	0c068263          	beqz	a3,40009298 <fnmatchx+0x11c>
400091d8:	00060413          	mv	s0,a2
400091dc:	00058493          	mv	s1,a1
		if (c == '\\' && !(flags & FNM_NOESCAPE)) {
400091e0:	05c00c13          	li	s8,92
		c = FOLDCASE(*pattern++, flags);
400091e4:	000bc503          	lbu	a0,0(s7)
400091e8:	00040593          	mv	a1,s0
400091ec:	001b8993          	addi	s3,s7,1
400091f0:	f71ff0ef          	jal	ra,40009160 <foldcase>
400091f4:	00050793          	mv	a5,a0
400091f8:	0ff57a13          	zext.b	s4,a0
		switch (c) {
400091fc:	03f00713          	li	a4,63
40009200:	0ff57513          	zext.b	a0,a0
			if ((flags & FNM_LEADING_DIR) && *string == '/') {
40009204:	0004c903          	lbu	s2,0(s1)
		switch (c) {
40009208:	06e50c63          	beq	a0,a4,40009280 <fnmatchx+0x104>
4000920c:	0c07f793          	andi	a5,a5,192
40009210:	02079463          	bnez	a5,40009238 <fnmatchx+0xbc>
40009214:	04050a63          	beqz	a0,40009268 <fnmatchx+0xec>
40009218:	02a00793          	li	a5,42
4000921c:	0ef50463          	beq	a0,a5,40009304 <fnmatchx+0x188>
			if (c != FOLDCASE(*string++, flags)) {
40009220:	00040593          	mv	a1,s0
40009224:	00090513          	mv	a0,s2
40009228:	00148493          	addi	s1,s1,1
4000922c:	f35ff0ef          	jal	ra,40009160 <foldcase>
40009230:	0caa0663          	beq	s4,a0,400092fc <fnmatchx+0x180>
40009234:	0600006f          	j	40009294 <fnmatchx+0x118>
		switch (c) {
40009238:	05b00793          	li	a5,91
4000923c:	1cf50263          	beq	a0,a5,40009400 <fnmatchx+0x284>
40009240:	ff8510e3          	bne	a0,s8,40009220 <fnmatchx+0xa4>
			if (!(flags & FNM_NOESCAPE)) {
40009244:	00147793          	andi	a5,s0,1
40009248:	fc079ce3          	bnez	a5,40009220 <fnmatchx+0xa4>
				c = FOLDCASE(*pattern++, flags);
4000924c:	001bc503          	lbu	a0,1(s7)
40009250:	00040593          	mv	a1,s0
40009254:	f0dff0ef          	jal	ra,40009160 <foldcase>
40009258:	0ff57a13          	zext.b	s4,a0
				if (c == EOS) {
4000925c:	fc0a02e3          	beqz	s4,40009220 <fnmatchx+0xa4>
				c = FOLDCASE(*pattern++, flags);
40009260:	002b8993          	addi	s3,s7,2
40009264:	fbdff06f          	j	40009220 <fnmatchx+0xa4>
			if ((flags & FNM_LEADING_DIR) && *string == '/') {
40009268:	01047413          	andi	s0,s0,16
4000926c:	00040663          	beqz	s0,40009278 <fnmatchx+0xfc>
40009270:	02f00793          	li	a5,47
40009274:	02f90263          	beq	s2,a5,40009298 <fnmatchx+0x11c>
			return *string == EOS ? 0 : FNM_NOMATCH;
40009278:	01203533          	snez	a0,s2
4000927c:	01c0006f          	j	40009298 <fnmatchx+0x11c>
			if (*string == EOS) {
40009280:	00090a63          	beqz	s2,40009294 <fnmatchx+0x118>
			if (*string == '/' && (flags & FNM_PATHNAME)) {
40009284:	02f00793          	li	a5,47
40009288:	04f91663          	bne	s2,a5,400092d4 <fnmatchx+0x158>
4000928c:	00247793          	andi	a5,s0,2
40009290:	06078463          	beqz	a5,400092f8 <fnmatchx+0x17c>
		return FNM_NOMATCH;
40009294:	00100513          	li	a0,1
}
40009298:	04c12083          	lw	ra,76(sp)
4000929c:	04812403          	lw	s0,72(sp)
400092a0:	04412483          	lw	s1,68(sp)
400092a4:	04012903          	lw	s2,64(sp)
400092a8:	03c12983          	lw	s3,60(sp)
400092ac:	03812a03          	lw	s4,56(sp)
400092b0:	03412a83          	lw	s5,52(sp)
400092b4:	03012b03          	lw	s6,48(sp)
400092b8:	02c12b83          	lw	s7,44(sp)
400092bc:	02812c03          	lw	s8,40(sp)
400092c0:	02412c83          	lw	s9,36(sp)
400092c4:	02012d03          	lw	s10,32(sp)
400092c8:	01c12d83          	lw	s11,28(sp)
400092cc:	05010113          	addi	sp,sp,80
400092d0:	00008067          	ret
			if (*string == '.' && (flags & FNM_PERIOD) &&
400092d4:	02e00713          	li	a4,46
400092d8:	02e91063          	bne	s2,a4,400092f8 <fnmatchx+0x17c>
400092dc:	00447713          	andi	a4,s0,4
400092e0:	00070c63          	beqz	a4,400092f8 <fnmatchx+0x17c>
400092e4:	fb5488e3          	beq	s1,s5,40009294 <fnmatchx+0x118>
			     ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
400092e8:	00247713          	andi	a4,s0,2
			    (string == stringstart ||
400092ec:	00070663          	beqz	a4,400092f8 <fnmatchx+0x17c>
			     ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
400092f0:	fff4c703          	lbu	a4,-1(s1)
400092f4:	faf700e3          	beq	a4,a5,40009294 <fnmatchx+0x118>
			++string;
400092f8:	00148493          	addi	s1,s1,1
			break;
400092fc:	00098b93          	mv	s7,s3
40009300:	ee5ff06f          	j	400091e4 <fnmatchx+0x68>
			c = FOLDCASE(*pattern, flags);
40009304:	001bc503          	lbu	a0,1(s7)
40009308:	00040593          	mv	a1,s0
			while (c == '*') {
4000930c:	02a00a13          	li	s4,42
			c = FOLDCASE(*pattern, flags);
40009310:	e51ff0ef          	jal	ra,40009160 <foldcase>
40009314:	0ff57513          	zext.b	a0,a0
			while (c == '*') {
40009318:	05450c63          	beq	a0,s4,40009370 <fnmatchx+0x1f4>
			if (*string == '.' && (flags & FNM_PERIOD) &&
4000931c:	02e00793          	li	a5,46
40009320:	02f91263          	bne	s2,a5,40009344 <fnmatchx+0x1c8>
40009324:	00447793          	andi	a5,s0,4
40009328:	00078e63          	beqz	a5,40009344 <fnmatchx+0x1c8>
4000932c:	f75484e3          	beq	s1,s5,40009294 <fnmatchx+0x118>
			     ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
40009330:	00247793          	andi	a5,s0,2
			    (string == stringstart ||
40009334:	00078863          	beqz	a5,40009344 <fnmatchx+0x1c8>
			     ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
40009338:	fff4c703          	lbu	a4,-1(s1)
4000933c:	02f00793          	li	a5,47
40009340:	f4f70ae3          	beq	a4,a5,40009294 <fnmatchx+0x118>
			if (c == EOS) {
40009344:	04051263          	bnez	a0,40009388 <fnmatchx+0x20c>
				if (flags & FNM_PATHNAME) {
40009348:	00247513          	andi	a0,s0,2
4000934c:	f40506e3          	beqz	a0,40009298 <fnmatchx+0x11c>
					return (flags & FNM_LEADING_DIR) ||
40009350:	01047413          	andi	s0,s0,16
				return 0;
40009354:	00000513          	li	a0,0
						       : FNM_NOMATCH;
40009358:	f40410e3          	bnez	s0,40009298 <fnmatchx+0x11c>
							       strchr(string, '/') == NULL
4000935c:	02f00593          	li	a1,47
40009360:	00048513          	mv	a0,s1
40009364:	b7dff0ef          	jal	ra,40008ee0 <strchr>
						       : FNM_NOMATCH;
40009368:	00a03533          	snez	a0,a0
4000936c:	f2dff06f          	j	40009298 <fnmatchx+0x11c>
				c = FOLDCASE(*++pattern, flags);
40009370:	0019c503          	lbu	a0,1(s3)
40009374:	00040593          	mv	a1,s0
40009378:	00198993          	addi	s3,s3,1
4000937c:	de5ff0ef          	jal	ra,40009160 <foldcase>
40009380:	0ff57513          	zext.b	a0,a0
40009384:	f95ff06f          	j	40009318 <fnmatchx+0x19c>
			} else if (c == '/' && flags & FNM_PATHNAME) {
40009388:	02f00793          	li	a5,47
4000938c:	02f51263          	bne	a0,a5,400093b0 <fnmatchx+0x234>
40009390:	00247793          	andi	a5,s0,2
40009394:	00078e63          	beqz	a5,400093b0 <fnmatchx+0x234>
				string = strchr(string, '/');
40009398:	00048513          	mv	a0,s1
4000939c:	02f00593          	li	a1,47
400093a0:	b41ff0ef          	jal	ra,40008ee0 <strchr>
400093a4:	00050493          	mv	s1,a0
				if (string == NULL) {
400093a8:	f4051ae3          	bnez	a0,400092fc <fnmatchx+0x180>
400093ac:	ee9ff06f          	j	40009294 <fnmatchx+0x118>
	if (recursion-- == 0) {
400093b0:	fffb0b13          	addi	s6,s6,-1
				int e = fnmatchx(pattern, string, flags & ~FNM_PERIOD, recursion);
400093b4:	ffb47a13          	andi	s4,s0,-5
				if (e != FNM_NOMATCH) {
400093b8:	00100a93          	li	s5,1
				if (test == '/' && flags & FNM_PATHNAME) {
400093bc:	02f00b93          	li	s7,47
400093c0:	00247c13          	andi	s8,s0,2
				test = FOLDCASE(*string, flags);
400093c4:	0004c503          	lbu	a0,0(s1)
400093c8:	00040593          	mv	a1,s0
400093cc:	d95ff0ef          	jal	ra,40009160 <foldcase>
400093d0:	0ff57913          	zext.b	s2,a0
				if (test == EOS) {
400093d4:	ec0900e3          	beqz	s2,40009294 <fnmatchx+0x118>
				int e = fnmatchx(pattern, string, flags & ~FNM_PERIOD, recursion);
400093d8:	000b0693          	mv	a3,s6
400093dc:	000a0613          	mv	a2,s4
400093e0:	00048593          	mv	a1,s1
400093e4:	00098513          	mv	a0,s3
400093e8:	d95ff0ef          	jal	ra,4000917c <fnmatchx>
				if (e != FNM_NOMATCH) {
400093ec:	eb5516e3          	bne	a0,s5,40009298 <fnmatchx+0x11c>
				if (test == '/' && flags & FNM_PATHNAME) {
400093f0:	01791463          	bne	s2,s7,400093f8 <fnmatchx+0x27c>
400093f4:	ea0c10e3          	bnez	s8,40009294 <fnmatchx+0x118>
				++string;
400093f8:	00148493          	addi	s1,s1,1
			do {
400093fc:	fc9ff06f          	j	400093c4 <fnmatchx+0x248>
			if (*string == EOS) {
40009400:	e8090ae3          	beqz	s2,40009294 <fnmatchx+0x118>
			if (*string == '/' && flags & FNM_PATHNAME) {
40009404:	02f00793          	li	a5,47
40009408:	08f91663          	bne	s2,a5,40009494 <fnmatchx+0x318>
4000940c:	00247793          	andi	a5,s0,2
40009410:	e80792e3          	bnez	a5,40009294 <fnmatchx+0x118>
			r = rangematch(pattern, FOLDCASE(*string, flags), flags);
40009414:	00040593          	mv	a1,s0
40009418:	02f00513          	li	a0,47
4000941c:	d45ff0ef          	jal	ra,40009160 <foldcase>
	negate = *pattern == '!' || *pattern == '^';
40009420:	001bc783          	lbu	a5,1(s7)
40009424:	02100713          	li	a4,33
			r = rangematch(pattern, FOLDCASE(*string, flags), flags);
40009428:	00050a13          	mv	s4,a0
	negate = *pattern == '!' || *pattern == '^';
4000942c:	00e78663          	beq	a5,a4,40009438 <fnmatchx+0x2bc>
40009430:	05e00713          	li	a4,94
40009434:	06e79663          	bne	a5,a4,400094a0 <fnmatchx+0x324>
		++pattern;
40009438:	002b8b93          	addi	s7,s7,2
4000943c:	00100c93          	li	s9,1
	for (need = true, ok = false, c = FOLDCASE(*pattern++, flags); c != ']' || need;
40009440:	000bc503          	lbu	a0,0(s7)
40009444:	00040593          	mv	a1,s0
40009448:	001b8d13          	addi	s10,s7,1
4000944c:	d15ff0ef          	jal	ra,40009160 <foldcase>
40009450:	0ff57d93          	zext.b	s11,a0
40009454:	05d00713          	li	a4,93
40009458:	04ed8a63          	beq	s11,a4,400094ac <fnmatchx+0x330>
4000945c:	00000b93          	li	s7,0
		if (c == '/') {
40009460:	02f00793          	li	a5,47
40009464:	0efd8863          	beq	s11,a5,40009554 <fnmatchx+0x3d8>
		if (c == '\\' && !(flags & FNM_NOESCAPE)) {
40009468:	038d9063          	bne	s11,s8,40009488 <fnmatchx+0x30c>
4000946c:	00147713          	andi	a4,s0,1
40009470:	00071e63          	bnez	a4,4000948c <fnmatchx+0x310>
			c = FOLDCASE(*pattern++, flags);
40009474:	000d4503          	lbu	a0,0(s10)
40009478:	00040593          	mv	a1,s0
4000947c:	001d0d13          	addi	s10,s10,1
40009480:	ce1ff0ef          	jal	ra,40009160 <foldcase>
40009484:	0ff57d93          	zext.b	s11,a0
		if (c == EOS) {
40009488:	e00d86e3          	beqz	s11,40009294 <fnmatchx+0x118>
4000948c:	000d0713          	mv	a4,s10
40009490:	0240006f          	j	400094b4 <fnmatchx+0x338>
			r = rangematch(pattern, FOLDCASE(*string, flags), flags);
40009494:	00040593          	mv	a1,s0
40009498:	00090513          	mv	a0,s2
4000949c:	f81ff06f          	j	4000941c <fnmatchx+0x2a0>
400094a0:	00098b93          	mv	s7,s3
	negate = *pattern == '!' || *pattern == '^';
400094a4:	00000c93          	li	s9,0
400094a8:	f99ff06f          	j	40009440 <fnmatchx+0x2c4>
	for (need = true, ok = false, c = FOLDCASE(*pattern++, flags); c != ']' || need;
400094ac:	000d0713          	mv	a4,s10
400094b0:	00000b93          	li	s7,0
		if (*pattern == '-') {
400094b4:	000d4603          	lbu	a2,0(s10)
400094b8:	02d00793          	li	a5,45
400094bc:	06f61663          	bne	a2,a5,40009528 <fnmatchx+0x3ac>
			c2 = FOLDCASE(*(pattern + 1), flags);
400094c0:	001d4503          	lbu	a0,1(s10)
400094c4:	00040593          	mv	a1,s0
400094c8:	00e12623          	sw	a4,12(sp)
400094cc:	c95ff0ef          	jal	ra,40009160 <foldcase>
400094d0:	0ff57513          	zext.b	a0,a0
			if (c2 != EOS && c2 != ']') {
400094d4:	00c12703          	lw	a4,12(sp)
400094d8:	04050a63          	beqz	a0,4000952c <fnmatchx+0x3b0>
400094dc:	05d00613          	li	a2,93
400094e0:	04c50663          	beq	a0,a2,4000952c <fnmatchx+0x3b0>
				if (c2 == '\\' && !(flags & FNM_NOESCAPE)) {
400094e4:	05c00613          	li	a2,92
				pattern += 2;
400094e8:	002d0713          	addi	a4,s10,2
				if (c2 == '\\' && !(flags & FNM_NOESCAPE)) {
400094ec:	02c51663          	bne	a0,a2,40009518 <fnmatchx+0x39c>
400094f0:	00147613          	andi	a2,s0,1
400094f4:	02061263          	bnez	a2,40009518 <fnmatchx+0x39c>
					c2 = FOLDCASE(*pattern++, flags);
400094f8:	002d4503          	lbu	a0,2(s10)
400094fc:	003d0713          	addi	a4,s10,3
40009500:	00040593          	mv	a1,s0
40009504:	00e12623          	sw	a4,12(sp)
40009508:	c59ff0ef          	jal	ra,40009160 <foldcase>
4000950c:	0ff57513          	zext.b	a0,a0
				if (c2 == EOS) {
40009510:	d80502e3          	beqz	a0,40009294 <fnmatchx+0x118>
					c2 = FOLDCASE(*pattern++, flags);
40009514:	00c12703          	lw	a4,12(sp)
				if (c <= test && test <= c2) {
40009518:	01ba4a63          	blt	s4,s11,4000952c <fnmatchx+0x3b0>
4000951c:	01454863          	blt	a0,s4,4000952c <fnmatchx+0x3b0>
			ok = true;
40009520:	00100b93          	li	s7,1
40009524:	0080006f          	j	4000952c <fnmatchx+0x3b0>
		} else if (c == test) {
40009528:	ff4d8ce3          	beq	s11,s4,40009520 <fnmatchx+0x3a4>
	     c = FOLDCASE(*pattern++, flags)) {
4000952c:	00074503          	lbu	a0,0(a4)
40009530:	00040593          	mv	a1,s0
40009534:	00170d13          	addi	s10,a4,1
40009538:	c29ff0ef          	jal	ra,40009160 <foldcase>
4000953c:	0ff57d93          	zext.b	s11,a0
	for (need = true, ok = false, c = FOLDCASE(*pattern++, flags); c != ']' || need;
40009540:	05d00793          	li	a5,93
40009544:	f0fd9ee3          	bne	s11,a5,40009460 <fnmatchx+0x2e4>
	return ok == negate ? NULL : pattern;
40009548:	d57c86e3          	beq	s9,s7,40009294 <fnmatchx+0x118>
			if (r == (void *)-1) {
4000954c:	fff00793          	li	a5,-1
40009550:	00fd1863          	bne	s10,a5,40009560 <fnmatchx+0x3e4>
				if (*string != '[') {
40009554:	05b00793          	li	a5,91
40009558:	d2f91ee3          	bne	s2,a5,40009294 <fnmatchx+0x118>
		c = FOLDCASE(*pattern++, flags);
4000955c:	00098d13          	mv	s10,s3
			++string;
40009560:	00148493          	addi	s1,s1,1
			break;
40009564:	000d0993          	mv	s3,s10
40009568:	d95ff06f          	j	400092fc <fnmatchx+0x180>

4000956c <fnmatch>:

int fnmatch(const char *pattern, const char *string, int flags)
{
	return fnmatchx(pattern, string, flags, 64);
4000956c:	04000693          	li	a3,64
40009570:	c0dff06f          	j	4000917c <fnmatchx>

40009574 <z_impl_sys_rand32_get>:
static const struct device *const entropy_dev =
	DEVICE_DT_GET(DT_CHOSEN(zephyr_entropy));

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
uint32_t z_impl_sys_rand32_get(void)
{
40009574:	fe010113          	addi	sp,sp,-32
40009578:	00112e23          	sw	ra,28(sp)

static inline int z_impl_entropy_get_entropy(const struct device *dev,
					     uint8_t *buffer,
					     uint16_t length)
{
	const struct entropy_driver_api *api =
4000957c:	4002c537          	lui	a0,0x4002c
40009580:	85c50793          	addi	a5,a0,-1956 # 4002b85c <__device_dts_ord_18>
		(const struct entropy_driver_api *)dev->api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
40009584:	0087a783          	lw	a5,8(a5)
40009588:	00400613          	li	a2,4
4000958c:	00c10593          	addi	a1,sp,12
40009590:	0007a783          	lw	a5,0(a5)
40009594:	85c50513          	addi	a0,a0,-1956
40009598:	000780e7          	jalr	a5
	__ASSERT(device_is_ready(entropy_dev), "Entropy device %s not ready",
		 entropy_dev->name);

	ret = entropy_get_entropy(entropy_dev, (uint8_t *)&random_num,
				  sizeof(random_num));
	if (unlikely(ret < 0)) {
4000959c:	00055663          	bgez	a0,400095a8 <z_impl_sys_rand32_get+0x34>
	return sys_clock_cycle_get_32();
400095a0:	7911c0ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
		 * 32-bit of data.  There's not much that can be done in this
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		random_num = k_cycle_get_32();
400095a4:	00a12623          	sw	a0,12(sp)
	}

	return random_num;
}
400095a8:	01c12083          	lw	ra,28(sp)
400095ac:	00c12503          	lw	a0,12(sp)
400095b0:	02010113          	addi	sp,sp,32
400095b4:	00008067          	ret

400095b8 <z_impl_sys_rand_get>:
	return 0;
}

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
void z_impl_sys_rand_get(void *dst, size_t outlen)
{
400095b8:	fd010113          	addi	sp,sp,-48
400095bc:	02912223          	sw	s1,36(sp)
400095c0:	03212023          	sw	s2,32(sp)
400095c4:	02112623          	sw	ra,44(sp)
400095c8:	02812423          	sw	s0,40(sp)
400095cc:	01312e23          	sw	s3,28(sp)
400095d0:	01412c23          	sw	s4,24(sp)
400095d4:	00050913          	mv	s2,a0
400095d8:	00058493          	mv	s1,a1
	const struct entropy_driver_api *api =
400095dc:	4002c537          	lui	a0,0x4002c
400095e0:	85c50793          	addi	a5,a0,-1956 # 4002b85c <__device_dts_ord_18>
	return api->get_entropy(dev, buffer, length);
400095e4:	0087a783          	lw	a5,8(a5)
400095e8:	01059613          	slli	a2,a1,0x10
400095ec:	01065613          	srli	a2,a2,0x10
400095f0:	0007a783          	lw	a5,0(a5)
400095f4:	00090593          	mv	a1,s2
400095f8:	85c50513          	addi	a0,a0,-1956
400095fc:	000780e7          	jalr	a5
	if (unlikely(ret < 0)) {
40009600:	02055e63          	bgez	a0,4000963c <z_impl_sys_rand_get+0x84>
		uint32_t len = 0;
40009604:	00000413          	li	s0,0
			if (copylen > blocksize) {
40009608:	00400a13          	li	s4,4
4000960c:	02c0006f          	j	40009638 <z_impl_sys_rand_get+0x80>
			size_t copylen = outlen - len;
40009610:	408489b3          	sub	s3,s1,s0
			if (copylen > blocksize) {
40009614:	013a7463          	bgeu	s4,s3,4000961c <z_impl_sys_rand_get+0x64>
40009618:	00400993          	li	s3,4
4000961c:	7151c0ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
			random_num = k_cycle_get_32();
40009620:	00a12623          	sw	a0,12(sp)
			(void)memcpy(&(dst[len]), &random_num, copylen);
40009624:	00098613          	mv	a2,s3
40009628:	00890533          	add	a0,s2,s0
4000962c:	00c10593          	addi	a1,sp,12
40009630:	a1dff0ef          	jal	ra,4000904c <memcpy>
			len += copylen;
40009634:	01340433          	add	s0,s0,s3
		while (len < outlen) {
40009638:	fc946ce3          	bltu	s0,s1,40009610 <z_impl_sys_rand_get+0x58>
	rand_get(dst, outlen, false);
}
4000963c:	02c12083          	lw	ra,44(sp)
40009640:	02812403          	lw	s0,40(sp)
40009644:	02412483          	lw	s1,36(sp)
40009648:	02012903          	lw	s2,32(sp)
4000964c:	01c12983          	lw	s3,28(sp)
40009650:	01812a03          	lw	s4,24(sp)
40009654:	03010113          	addi	sp,sp,48
40009658:	00008067          	ret

4000965c <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, uint8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
4000965c:	00008067          	ret

40009660 <net_buf_id>:
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
40009660:	00a54703          	lbu	a4,10(a0)
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
40009664:	02c00693          	li	a3,44
40009668:	4003d7b7          	lui	a5,0x4003d
4000966c:	02d70733          	mul	a4,a4,a3
40009670:	b8c78793          	addi	a5,a5,-1140 # 4003cb8c <dns_msg_pool>
40009674:	00e787b3          	add	a5,a5,a4
40009678:	0287a703          	lw	a4,40(a5)
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
4000967c:	01c7c783          	lbu	a5,28(a5)
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
40009680:	40e50533          	sub	a0,a0,a4
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
40009684:	01b78793          	addi	a5,a5,27
40009688:	ffc7f793          	andi	a5,a5,-4
}
4000968c:	02f55533          	divu	a0,a0,a5
40009690:	00008067          	ret

40009694 <fixed_data_alloc>:
{
40009694:	ff010113          	addi	sp,sp,-16
40009698:	00112623          	sw	ra,12(sp)
4000969c:	00812423          	sw	s0,8(sp)
400096a0:	00912223          	sw	s1,4(sp)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
400096a4:	00a54703          	lbu	a4,10(a0)
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
400096a8:	02c00693          	li	a3,44
400096ac:	4003d7b7          	lui	a5,0x4003d
400096b0:	02d70733          	mul	a4,a4,a3
400096b4:	b8c78793          	addi	a5,a5,-1140 # 4003cb8c <dns_msg_pool>
400096b8:	00e787b3          	add	a5,a5,a4
400096bc:	0247a783          	lw	a5,36(a5)
	*size = MIN(fixed->data_size, *size);
400096c0:	0005a703          	lw	a4,0(a1)
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
400096c4:	0047a783          	lw	a5,4(a5)
	*size = MIN(fixed->data_size, *size);
400096c8:	0007a683          	lw	a3,0(a5)
400096cc:	00e6f463          	bgeu	a3,a4,400096d4 <fixed_data_alloc+0x40>
400096d0:	00068713          	mv	a4,a3
400096d4:	00e5a023          	sw	a4,0(a1)
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
400096d8:	0007a483          	lw	s1,0(a5)
400096dc:	0047a403          	lw	s0,4(a5)
400096e0:	f81ff0ef          	jal	ra,40009660 <net_buf_id>
400096e4:	02950533          	mul	a0,a0,s1
}
400096e8:	00c12083          	lw	ra,12(sp)
400096ec:	00412483          	lw	s1,4(sp)
400096f0:	00a40533          	add	a0,s0,a0
400096f4:	00812403          	lw	s0,8(sp)
400096f8:	01010113          	addi	sp,sp,16
400096fc:	00008067          	ret

40009700 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
40009700:	fc010113          	addi	sp,sp,-64
40009704:	02912a23          	sw	s1,52(sp)
40009708:	00b12623          	sw	a1,12(sp)
4000970c:	00050493          	mv	s1,a0
	uint64_t end = sys_clock_timeout_end_calc(timeout);
40009710:	00068593          	mv	a1,a3
40009714:	00060513          	mv	a0,a2
{
40009718:	03212823          	sw	s2,48(sp)
4000971c:	03312623          	sw	s3,44(sp)
40009720:	03412423          	sw	s4,40(sp)
40009724:	03512223          	sw	s5,36(sp)
40009728:	03612023          	sw	s6,32(sp)
4000972c:	01712e23          	sw	s7,28(sp)
40009730:	02112e23          	sw	ra,60(sp)
40009734:	02812c23          	sw	s0,56(sp)
40009738:	01812c23          	sw	s8,24(sp)
4000973c:	00060a93          	mv	s5,a2
40009740:	00068993          	mv	s3,a3
40009744:	00060913          	mv	s2,a2
40009748:	00068b93          	mv	s7,a3
	uint64_t end = sys_clock_timeout_end_calc(timeout);
4000974c:	4d4210ef          	jal	ra,4002ac20 <sys_clock_timeout_end_calc>
40009750:	00050a13          	mv	s4,a0
40009754:	00058b13          	mv	s6,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
40009758:	30047c73          	csrrci	s8,mstatus,8
	key = k_spin_lock(&pool->lock);

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
4000975c:	01a4d783          	lhu	a5,26(s1)
40009760:	008c7c13          	andi	s8,s8,8
40009764:	10078c63          	beqz	a5,4000987c <net_buf_alloc_len+0x17c>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
40009768:	0184d703          	lhu	a4,24(s1)
4000976c:	0ae7fa63          	bgeu	a5,a4,40009820 <net_buf_alloc_len+0x120>
	return z_impl_k_queue_get(queue, timeout);
40009770:	00000593          	li	a1,0
40009774:	00000613          	li	a2,0
40009778:	00048513          	mv	a0,s1
4000977c:	4f01f0ef          	jal	ra,40028c6c <z_impl_k_queue_get>
40009780:	00050413          	mv	s0,a0
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
40009784:	08050e63          	beqz	a0,40009820 <net_buf_alloc_len+0x120>
	__asm__ volatile ("csrs mstatus, %0"
40009788:	300c2073          	csrs	mstatus,s8
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
4000978c:	00c12783          	lw	a5,12(sp)
40009790:	14078063          	beqz	a5,400098d0 <net_buf_alloc_len+0x1d0>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
40009794:	0159e9b3          	or	s3,s3,s5
40009798:	02098863          	beqz	s3,400097c8 <net_buf_alloc_len+0xc8>
4000979c:	fff00793          	li	a5,-1
400097a0:	00f91463          	bne	s2,a5,400097a8 <net_buf_alloc_len+0xa8>
400097a4:	032b8263          	beq	s7,s2,400097c8 <net_buf_alloc_len+0xc8>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - sys_clock_tick_get();
400097a8:	3b0210ef          	jal	ra,4002ab58 <sys_clock_tick_get>
400097ac:	40aa0933          	sub	s2,s4,a0
400097b0:	012a3a33          	sltu	s4,s4,s2
400097b4:	40bb0b33          	sub	s6,s6,a1
400097b8:	414b0bb3          	sub	s7,s6,s4

			if (remaining <= 0) {
400097bc:	000bd663          	bgez	s7,400097c8 <net_buf_alloc_len+0xc8>
400097c0:	00000913          	li	s2,0
400097c4:	00000b93          	li	s7,0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
400097c8:	00a44783          	lbu	a5,10(s0)
	return pool->alloc->cb->alloc(buf, size, timeout);
400097cc:	02c00993          	li	s3,44
400097d0:	4003d4b7          	lui	s1,0x4003d
400097d4:	033787b3          	mul	a5,a5,s3
400097d8:	b8c48493          	addi	s1,s1,-1140 # 4003cb8c <dns_msg_pool>
400097dc:	00090613          	mv	a2,s2
400097e0:	000b8693          	mv	a3,s7
400097e4:	00c10593          	addi	a1,sp,12
400097e8:	00040513          	mv	a0,s0
400097ec:	00f487b3          	add	a5,s1,a5
400097f0:	0247a783          	lw	a5,36(a5)
400097f4:	0007a783          	lw	a5,0(a5)
400097f8:	0007a783          	lw	a5,0(a5)
400097fc:	000780e7          	jalr	a5
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
40009800:	00a42a23          	sw	a0,20(s0)
		if (!buf->__buf) {
40009804:	0c051863          	bnez	a0,400098d4 <net_buf_alloc_len+0x1d4>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
40009808:	00a44503          	lbu	a0,10(s0)
4000980c:	00040593          	mv	a1,s0
40009810:	03350533          	mul	a0,a0,s3
40009814:	00a48533          	add	a0,s1,a0
40009818:	4401f0ef          	jal	ra,40028c58 <k_queue_prepend>
}
4000981c:	07c0006f          	j	40009898 <net_buf_alloc_len+0x198>
		uninit_count = pool->uninit_count--;
40009820:	01a4d683          	lhu	a3,26(s1)
40009824:	fff68793          	addi	a5,a3,-1
40009828:	00f49d23          	sh	a5,26(s1)
4000982c:	300c2073          	csrs	mstatus,s8
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
40009830:	01c4c783          	lbu	a5,28(s1)
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
40009834:	0184d703          	lhu	a4,24(s1)
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
40009838:	0284a403          	lw	s0,40(s1)
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
4000983c:	01b78793          	addi	a5,a5,27
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
40009840:	40d70733          	sub	a4,a4,a3
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
40009844:	ffc7f793          	andi	a5,a5,-4
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
40009848:	02e787b3          	mul	a5,a5,a4
	return pool - TYPE_SECTION_START(net_buf_pool);
4000984c:	ba2e9737          	lui	a4,0xba2e9
40009850:	ba370713          	addi	a4,a4,-1117 # ba2e8ba3 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xba2e8ba4>
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
40009854:	00f40433          	add	s0,s0,a5
	return pool - TYPE_SECTION_START(net_buf_pool);
40009858:	4003d7b7          	lui	a5,0x4003d
4000985c:	b8c78793          	addi	a5,a5,-1140 # 4003cb8c <dns_msg_pool>
40009860:	40f487b3          	sub	a5,s1,a5
40009864:	4027d793          	srai	a5,a5,0x2
40009868:	02e787b3          	mul	a5,a5,a4
	buf->pool_id = pool_id(pool);
4000986c:	00f40523          	sb	a5,10(s0)
	buf->user_data_size = pool->user_data_size;
40009870:	01c4c783          	lbu	a5,28(s1)
40009874:	00f405a3          	sb	a5,11(s0)
		goto success;
40009878:	f15ff06f          	j	4000978c <net_buf_alloc_len+0x8c>
4000987c:	300c2073          	csrs	mstatus,s8
40009880:	000a8593          	mv	a1,s5
40009884:	00098613          	mv	a2,s3
40009888:	00048513          	mv	a0,s1
4000988c:	3e01f0ef          	jal	ra,40028c6c <z_impl_k_queue_get>
40009890:	00050413          	mv	s0,a0
	if (!buf) {
40009894:	ee051ce3          	bnez	a0,4000978c <net_buf_alloc_len+0x8c>
		return NULL;
40009898:	00000413          	li	s0,0
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
4000989c:	03c12083          	lw	ra,60(sp)
400098a0:	00040513          	mv	a0,s0
400098a4:	03812403          	lw	s0,56(sp)
400098a8:	03412483          	lw	s1,52(sp)
400098ac:	03012903          	lw	s2,48(sp)
400098b0:	02c12983          	lw	s3,44(sp)
400098b4:	02812a03          	lw	s4,40(sp)
400098b8:	02412a83          	lw	s5,36(sp)
400098bc:	02012b03          	lw	s6,32(sp)
400098c0:	01c12b83          	lw	s7,28(sp)
400098c4:	01812c03          	lw	s8,24(sp)
400098c8:	04010113          	addi	sp,sp,64
400098cc:	00008067          	ret
		buf->__buf = NULL;
400098d0:	00042a23          	sw	zero,20(s0)
	buf->ref   = 1U;
400098d4:	00100793          	li	a5,1
400098d8:	00f41423          	sh	a5,8(s0)
	buf->size  = size;
400098dc:	00c12783          	lw	a5,12(sp)
	buf->frags = NULL;
400098e0:	00042223          	sw	zero,4(s0)
	buf->len  = 0U;
400098e4:	00041823          	sh	zero,16(s0)
	buf->size  = size;
400098e8:	00f41923          	sh	a5,18(s0)
	buf->data = buf->__buf;
400098ec:	01442783          	lw	a5,20(s0)
400098f0:	00f42623          	sw	a5,12(s0)
	return buf;
400098f4:	fa9ff06f          	j	4000989c <net_buf_alloc_len+0x19c>

400098f8 <net_buf_alloc_fixed>:
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool,
				    k_timeout_t timeout)
{
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
400098f8:	02452783          	lw	a5,36(a0)
{
400098fc:	00060693          	mv	a3,a2
40009900:	00058613          	mv	a2,a1

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
40009904:	0047a783          	lw	a5,4(a5)
40009908:	0007a583          	lw	a1,0(a5)
4000990c:	df5ff06f          	j	40009700 <net_buf_alloc_len>

40009910 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
40009910:	fe010113          	addi	sp,sp,-32
40009914:	00912a23          	sw	s1,20(sp)
40009918:	4003d4b7          	lui	s1,0x4003d
4000991c:	00812c23          	sw	s0,24(sp)
40009920:	01212823          	sw	s2,16(sp)
40009924:	00112e23          	sw	ra,28(sp)
40009928:	01312623          	sw	s3,12(sp)
4000992c:	00050413          	mv	s0,a0
40009930:	b8c48493          	addi	s1,s1,-1140 # 4003cb8c <dns_msg_pool>
	pool->alloc->cb->unref(buf, data);
40009934:	02c00913          	li	s2,44
	__ASSERT_NO_MSG(buf);

	while (buf) {
40009938:	02041063          	bnez	s0,40009958 <net_buf_unref+0x48>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
4000993c:	01c12083          	lw	ra,28(sp)
40009940:	01812403          	lw	s0,24(sp)
40009944:	01412483          	lw	s1,20(sp)
40009948:	01012903          	lw	s2,16(sp)
4000994c:	00c12983          	lw	s3,12(sp)
40009950:	02010113          	addi	sp,sp,32
40009954:	00008067          	ret
		if (--buf->ref > 0) {
40009958:	00844783          	lbu	a5,8(s0)
		struct net_buf *frags = buf->frags;
4000995c:	00442983          	lw	s3,4(s0)
		if (--buf->ref > 0) {
40009960:	fff78793          	addi	a5,a5,-1
40009964:	0ff7f793          	zext.b	a5,a5
40009968:	00f40423          	sb	a5,8(s0)
4000996c:	fc0798e3          	bnez	a5,4000993c <net_buf_unref+0x2c>
		if (buf->__buf) {
40009970:	01442583          	lw	a1,20(s0)
40009974:	02058a63          	beqz	a1,400099a8 <net_buf_unref+0x98>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
40009978:	00944783          	lbu	a5,9(s0)
4000997c:	0017f793          	andi	a5,a5,1
40009980:	02079263          	bnez	a5,400099a4 <net_buf_unref+0x94>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
40009984:	00a44783          	lbu	a5,10(s0)
	pool->alloc->cb->unref(buf, data);
40009988:	00040513          	mv	a0,s0
4000998c:	032787b3          	mul	a5,a5,s2
40009990:	00f487b3          	add	a5,s1,a5
40009994:	0247a783          	lw	a5,36(a5)
40009998:	0007a783          	lw	a5,0(a5)
4000999c:	0087a783          	lw	a5,8(a5)
400099a0:	000780e7          	jalr	a5
			buf->__buf = NULL;
400099a4:	00042a23          	sw	zero,20(s0)
		pool = net_buf_pool_get(buf->pool_id);
400099a8:	00a44503          	lbu	a0,10(s0)
		buf->data = NULL;
400099ac:	00042623          	sw	zero,12(s0)
		buf->frags = NULL;
400099b0:	00042223          	sw	zero,4(s0)
		if (pool->destroy) {
400099b4:	03250533          	mul	a0,a0,s2
400099b8:	00a48533          	add	a0,s1,a0
400099bc:	02052783          	lw	a5,32(a0)
400099c0:	00078a63          	beqz	a5,400099d4 <net_buf_unref+0xc4>
			pool->destroy(buf);
400099c4:	00040513          	mv	a0,s0
400099c8:	000780e7          	jalr	a5
{
400099cc:	00098413          	mv	s0,s3
400099d0:	f69ff06f          	j	40009938 <net_buf_unref+0x28>
	k_lifo_put(&pool->free, buf);
400099d4:	00040593          	mv	a1,s0
400099d8:	2801f0ef          	jal	ra,40028c58 <k_queue_prepend>
}
400099dc:	ff1ff06f          	j	400099cc <net_buf_unref+0xbc>

400099e0 <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
400099e0:	00050793          	mv	a5,a0
	__ASSERT_NO_MSG(buf);

	while (buf->frags) {
400099e4:	00078513          	mv	a0,a5
400099e8:	0047a783          	lw	a5,4(a5)
400099ec:	fe079ce3          	bnez	a5,400099e4 <net_buf_frag_last+0x4>
		buf = buf->frags;
	}

	return buf;
}
400099f0:	00008067          	ret

400099f4 <net_buf_frag_insert>:
void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
	__ASSERT_NO_MSG(parent);
	__ASSERT_NO_MSG(frag);

	if (parent->frags) {
400099f4:	00452703          	lw	a4,4(a0)
400099f8:	00070c63          	beqz	a4,40009a10 <net_buf_frag_insert+0x1c>
400099fc:	00058793          	mv	a5,a1
	while (buf->frags) {
40009a00:	00078693          	mv	a3,a5
40009a04:	0047a783          	lw	a5,4(a5)
40009a08:	fe079ce3          	bnez	a5,40009a00 <net_buf_frag_insert+0xc>
		net_buf_frag_last(frag)->frags = parent->frags;
40009a0c:	00e6a223          	sw	a4,4(a3)
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
40009a10:	00b52223          	sw	a1,4(a0)
}
40009a14:	00008067          	ret

40009a18 <net_buf_frag_add>:

struct net_buf *net_buf_frag_add(struct net_buf *head, struct net_buf *frag)
{
	__ASSERT_NO_MSG(frag);

	if (!head) {
40009a18:	00051c63          	bnez	a0,40009a30 <net_buf_frag_add+0x18>
	buf->ref++;
40009a1c:	0085c783          	lbu	a5,8(a1)
		return net_buf_ref(frag);
40009a20:	00058513          	mv	a0,a1
	buf->ref++;
40009a24:	00178793          	addi	a5,a5,1
40009a28:	00f58423          	sb	a5,8(a1)
	}

	net_buf_frag_insert(net_buf_frag_last(head), frag);

	return head;
}
40009a2c:	00008067          	ret
{
40009a30:	ff010113          	addi	sp,sp,-16
40009a34:	00812423          	sw	s0,8(sp)
40009a38:	00112623          	sw	ra,12(sp)
40009a3c:	00050413          	mv	s0,a0
40009a40:	00050793          	mv	a5,a0
	while (buf->frags) {
40009a44:	00078513          	mv	a0,a5
40009a48:	0047a783          	lw	a5,4(a5)
40009a4c:	fe079ce3          	bnez	a5,40009a44 <net_buf_frag_add+0x2c>
	net_buf_frag_insert(net_buf_frag_last(head), frag);
40009a50:	fa5ff0ef          	jal	ra,400099f4 <net_buf_frag_insert>
}
40009a54:	00c12083          	lw	ra,12(sp)
	net_buf_frag_insert(net_buf_frag_last(head), frag);
40009a58:	00040513          	mv	a0,s0
}
40009a5c:	00812403          	lw	s0,8(sp)
40009a60:	01010113          	addi	sp,sp,16
40009a64:	00008067          	ret

40009a68 <net_buf_linearize>:
	return next_frag;
}

size_t net_buf_linearize(void *dst, size_t dst_len, struct net_buf *src,
			 size_t offset, size_t len)
{
40009a68:	fe010113          	addi	sp,sp,-32
40009a6c:	00812c23          	sw	s0,24(sp)
40009a70:	00912a23          	sw	s1,20(sp)
40009a74:	01412423          	sw	s4,8(sp)
40009a78:	00112e23          	sw	ra,28(sp)
40009a7c:	01212823          	sw	s2,16(sp)
40009a80:	01312623          	sw	s3,12(sp)
40009a84:	00050a13          	mv	s4,a0
40009a88:	00058413          	mv	s0,a1
40009a8c:	00060493          	mv	s1,a2
	len = MIN(len, dst_len);

	frag = src;

	/* find the right fragment to start copying from */
	while (frag && offset >= frag->len) {
40009a90:	02049c63          	bnez	s1,40009ac8 <net_buf_linearize+0x60>
40009a94:	00000993          	li	s3,0
		/* after the first iteration, this value will be 0 */
		offset = 0;
	}

	return copied;
}
40009a98:	01c12083          	lw	ra,28(sp)
40009a9c:	01812403          	lw	s0,24(sp)
40009aa0:	01412483          	lw	s1,20(sp)
40009aa4:	01012903          	lw	s2,16(sp)
40009aa8:	00812a03          	lw	s4,8(sp)
40009aac:	00098513          	mv	a0,s3
40009ab0:	00c12983          	lw	s3,12(sp)
40009ab4:	02010113          	addi	sp,sp,32
40009ab8:	00008067          	ret
		frag = frag->frags;
40009abc:	0044a483          	lw	s1,4(s1)
		offset -= frag->len;
40009ac0:	40f686b3          	sub	a3,a3,a5
		frag = frag->frags;
40009ac4:	fcdff06f          	j	40009a90 <net_buf_linearize+0x28>
	while (frag && offset >= frag->len) {
40009ac8:	0104d783          	lhu	a5,16(s1)
40009acc:	fef6f8e3          	bgeu	a3,a5,40009abc <net_buf_linearize+0x54>
	len = MIN(len, dst_len);
40009ad0:	00877463          	bgeu	a4,s0,40009ad8 <net_buf_linearize+0x70>
40009ad4:	00070413          	mv	s0,a4
40009ad8:	00000993          	li	s3,0
	while (frag && len > 0) {
40009adc:	fa048ee3          	beqz	s1,40009a98 <net_buf_linearize+0x30>
40009ae0:	fa040ce3          	beqz	s0,40009a98 <net_buf_linearize+0x30>
		to_copy = MIN(len, frag->len - offset);
40009ae4:	0104d903          	lhu	s2,16(s1)
40009ae8:	40d90933          	sub	s2,s2,a3
40009aec:	01247463          	bgeu	s0,s2,40009af4 <net_buf_linearize+0x8c>
40009af0:	00040913          	mv	s2,s0
		memcpy((uint8_t *)dst + copied, frag->data + offset, to_copy);
40009af4:	00c4a583          	lw	a1,12(s1)
40009af8:	013a0533          	add	a0,s4,s3
40009afc:	00090613          	mv	a2,s2
40009b00:	00d585b3          	add	a1,a1,a3
40009b04:	d48ff0ef          	jal	ra,4000904c <memcpy>
		copied += to_copy;
40009b08:	012989b3          	add	s3,s3,s2
		frag = frag->frags;
40009b0c:	0044a483          	lw	s1,4(s1)
		len -= to_copy;
40009b10:	41240433          	sub	s0,s0,s2
		offset = 0;
40009b14:	00000693          	li	a3,0
40009b18:	fc5ff06f          	j	40009adc <net_buf_linearize+0x74>

40009b1c <net_buf_simple_add>:
	return buf->data + buf->len;
40009b1c:	00455783          	lhu	a5,4(a0)
40009b20:	00052703          	lw	a4,0(a0)

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
40009b24:	00b785b3          	add	a1,a5,a1
40009b28:	00b51223          	sh	a1,4(a0)
	return tail;
}
40009b2c:	00f70533          	add	a0,a4,a5
40009b30:	00008067          	ret

40009b34 <net_buf_simple_add_be16>:
40009b34:	00455703          	lhu	a4,4(a0)
40009b38:	00052783          	lw	a5,0(a0)
40009b3c:	00e787b3          	add	a5,a5,a4
	buf->len += len;
40009b40:	00270713          	addi	a4,a4,2
40009b44:	00e51223          	sh	a4,4(a0)
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
40009b48:	0085d713          	srli	a4,a1,0x8
40009b4c:	00e78023          	sb	a4,0(a5)
	dst[1] = val;
40009b50:	00b780a3          	sb	a1,1(a5)
void net_buf_simple_add_be16(struct net_buf_simple *buf, uint16_t val)
{
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_be16(val, net_buf_simple_add(buf, sizeof(val)));
}
40009b54:	00008067          	ret

40009b58 <net_buf_simple_pull>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
40009b58:	00455703          	lhu	a4,4(a0)
{
40009b5c:	00050793          	mv	a5,a0
	buf->len -= len;
40009b60:	40b70733          	sub	a4,a4,a1
40009b64:	00e51223          	sh	a4,4(a0)
	return buf->data += len;
40009b68:	00052503          	lw	a0,0(a0)
40009b6c:	00b50533          	add	a0,a0,a1
40009b70:	00a7a023          	sw	a0,0(a5)
}
40009b74:	00008067          	ret

40009b78 <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
40009b78:	00050793          	mv	a5,a0

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
40009b7c:	0047d703          	lhu	a4,4(a5)
	void *data = buf->data;
40009b80:	00052503          	lw	a0,0(a0)
	buf->len -= len;
40009b84:	40b70733          	sub	a4,a4,a1
	buf->data += len;
40009b88:	00b505b3          	add	a1,a0,a1
	buf->len -= len;
40009b8c:	00e79223          	sh	a4,4(a5)
	buf->data += len;
40009b90:	00b7a023          	sw	a1,0(a5)

	return data;
}
40009b94:	00008067          	ret

40009b98 <net_buf_simple_max_len>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
40009b98:	00052783          	lw	a5,0(a0)
40009b9c:	00852703          	lw	a4,8(a0)
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
}

uint16_t net_buf_simple_max_len(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf);
40009ba0:	00655503          	lhu	a0,6(a0)
	return buf->data - buf->__buf;
40009ba4:	40e787b3          	sub	a5,a5,a4
	return buf->size - net_buf_simple_headroom(buf);
40009ba8:	40f50533          	sub	a0,a0,a5
}
40009bac:	01051513          	slli	a0,a0,0x10
40009bb0:	01055513          	srli	a0,a0,0x10
40009bb4:	00008067          	ret

40009bb8 <net_ipv4_is_addr_mcast>:
 *
 * @return True if address is multicast address, False otherwise.
 */
static inline bool net_ipv4_is_addr_mcast(const struct in_addr *addr)
{
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
40009bb8:	00054503          	lbu	a0,0(a0)
40009bbc:	f00007b7          	lui	a5,0xf0000
40009bc0:	01851513          	slli	a0,a0,0x18
40009bc4:	00f57533          	and	a0,a0,a5
40009bc8:	200007b7          	lui	a5,0x20000
40009bcc:	00f50533          	add	a0,a0,a5
}
40009bd0:	00153513          	seqz	a0,a0
40009bd4:	00008067          	ret

40009bd8 <ethernet_flags>:
 *
 * @return a pointer to the iface L2 data
 */
static inline void *net_if_l2_data(struct net_if *iface)
{
	return iface->if_dev->l2_data;
40009bd8:	00052783          	lw	a5,0(a0)

enum net_l2_flags ethernet_flags(struct net_if *iface)
{
	struct ethernet_context *ctx = net_if_l2_data(iface);

	return ctx->ethernet_l2_flags;
40009bdc:	0087a783          	lw	a5,8(a5) # 20000008 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1a0a1f08>
}
40009be0:	0187c503          	lbu	a0,24(a5)
40009be4:	00008067          	ret

40009be8 <ethernet_enable>:
{
40009be8:	ff010113          	addi	sp,sp,-16
40009bec:	00112623          	sw	ra,12(sp)
40009bf0:	00812423          	sw	s0,8(sp)
40009bf4:	00912223          	sw	s1,4(sp)
 *
 * @return a pointer to the device driver instance
 */
static inline const struct device *net_if_get_device(struct net_if *iface)
{
	return iface->if_dev->dev;
40009bf8:	00052783          	lw	a5,0(a0)
40009bfc:	0007a703          	lw	a4,0(a5)
	const struct ethernet_api *eth =
40009c00:	00872483          	lw	s1,8(a4)
	if (!eth) {
40009c04:	04048e63          	beqz	s1,40009c60 <ethernet_enable+0x78>
	if (!state) {
40009c08:	04059463          	bnez	a1,40009c50 <ethernet_enable+0x68>
40009c0c:	00050413          	mv	s0,a0
		net_arp_clear_cache(iface);
40009c10:	5c8010ef          	jal	ra,4000b1d8 <net_arp_clear_cache>
		if (eth->stop) {
40009c14:	0084a783          	lw	a5,8(s1)
40009c18:	00079e63          	bnez	a5,40009c34 <ethernet_enable+0x4c>
	int ret = 0;
40009c1c:	00000513          	li	a0,0
}
40009c20:	00c12083          	lw	ra,12(sp)
40009c24:	00812403          	lw	s0,8(sp)
40009c28:	00412483          	lw	s1,4(sp)
40009c2c:	01010113          	addi	sp,sp,16
40009c30:	00008067          	ret
40009c34:	00042703          	lw	a4,0(s0)
			ret = eth->stop(net_if_get_device(iface));
40009c38:	00072503          	lw	a0,0(a4)
}
40009c3c:	00812403          	lw	s0,8(sp)
40009c40:	00c12083          	lw	ra,12(sp)
40009c44:	00412483          	lw	s1,4(sp)
40009c48:	01010113          	addi	sp,sp,16
			ret = eth->start(net_if_get_device(iface));
40009c4c:	00078067          	jr	a5
		if (eth->start) {
40009c50:	0044a783          	lw	a5,4(s1)
40009c54:	fc0784e3          	beqz	a5,40009c1c <ethernet_enable+0x34>
			ret = eth->start(net_if_get_device(iface));
40009c58:	00070513          	mv	a0,a4
40009c5c:	fe1ff06f          	j	40009c3c <ethernet_enable+0x54>
		return -ENOENT;
40009c60:	ffe00513          	li	a0,-2
40009c64:	fbdff06f          	j	40009c20 <ethernet_enable+0x38>

40009c68 <net_eth_is_addr_broadcast>:
} __packed;


static inline bool net_eth_is_addr_broadcast(struct net_eth_addr *addr)
{
	if (addr->addr[0] == 0xff &&
40009c68:	00054683          	lbu	a3,0(a0)
40009c6c:	0ff00713          	li	a4,255
{
40009c70:	00050793          	mv	a5,a0
	    addr->addr[4] == 0xff &&
	    addr->addr[5] == 0xff) {
		return true;
	}

	return false;
40009c74:	00000513          	li	a0,0
	if (addr->addr[0] == 0xff &&
40009c78:	02e69c63          	bne	a3,a4,40009cb0 <net_eth_is_addr_broadcast+0x48>
40009c7c:	0017c703          	lbu	a4,1(a5)
	return false;
40009c80:	00000513          	li	a0,0
	if (addr->addr[0] == 0xff &&
40009c84:	02d71663          	bne	a4,a3,40009cb0 <net_eth_is_addr_broadcast+0x48>
	    addr->addr[1] == 0xff &&
40009c88:	0027c683          	lbu	a3,2(a5)
40009c8c:	02e69263          	bne	a3,a4,40009cb0 <net_eth_is_addr_broadcast+0x48>
	    addr->addr[2] == 0xff &&
40009c90:	0037c703          	lbu	a4,3(a5)
40009c94:	00d71e63          	bne	a4,a3,40009cb0 <net_eth_is_addr_broadcast+0x48>
	    addr->addr[3] == 0xff &&
40009c98:	0047c683          	lbu	a3,4(a5)
40009c9c:	00e69a63          	bne	a3,a4,40009cb0 <net_eth_is_addr_broadcast+0x48>
	    addr->addr[4] == 0xff &&
40009ca0:	0057c503          	lbu	a0,5(a5)
40009ca4:	f0150513          	addi	a0,a0,-255
40009ca8:	00153513          	seqz	a0,a0
40009cac:	00008067          	ret
}
40009cb0:	00008067          	ret

40009cb4 <carrier_on_off>:
{
	struct ethernet_context *ctx = CONTAINER_OF(work, struct ethernet_context,
						    carrier_work);
	bool eth_carrier_up;

	if (ctx->iface == NULL) {
40009cb4:	01052783          	lw	a5,16(a0)
40009cb8:	06078c63          	beqz	a5,40009d30 <carrier_on_off+0x7c>
{
40009cbc:	ff010113          	addi	sp,sp,-16
40009cc0:	00812423          	sw	s0,8(sp)
40009cc4:	00050413          	mv	s0,a0
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_bit(const atomic_t *target, int bit)
{
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
40009cc8:	ffc50513          	addi	a0,a0,-4
40009ccc:	00112623          	sw	ra,12(sp)
40009cd0:	318210ef          	jal	ra,4002afe8 <atomic_get>
		return;
	}

	eth_carrier_up = atomic_test_bit(&ctx->flags, ETH_CARRIER_UP);

	if (eth_carrier_up == ctx->is_net_carrier_up) {
40009cd4:	01442703          	lw	a4,20(s0)

	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
40009cd8:	00157793          	andi	a5,a0,1
40009cdc:	00875713          	srli	a4,a4,0x8
40009ce0:	00177713          	andi	a4,a4,1
40009ce4:	02f70e63          	beq	a4,a5,40009d20 <carrier_on_off+0x6c>
		return;
	}

	ctx->is_net_carrier_up = eth_carrier_up;
40009ce8:	01544703          	lbu	a4,21(s0)

	NET_DBG("Carrier %s for interface %p", eth_carrier_up ? "ON" : "OFF",
		ctx->iface);

	if (eth_carrier_up) {
		ethernet_mgmt_raise_carrier_on_event(ctx->iface);
40009cec:	01042503          	lw	a0,16(s0)
	ctx->is_net_carrier_up = eth_carrier_up;
40009cf0:	ffe77713          	andi	a4,a4,-2
40009cf4:	00f76733          	or	a4,a4,a5
40009cf8:	00e40aa3          	sb	a4,21(s0)
	if (eth_carrier_up) {
40009cfc:	00078a63          	beqz	a5,40009d10 <carrier_on_off+0x5c>
		net_if_carrier_on(ctx->iface);
	} else {
		ethernet_mgmt_raise_carrier_off_event(ctx->iface);
		net_if_carrier_off(ctx->iface);
	}
}
40009d00:	00812403          	lw	s0,8(sp)
40009d04:	00c12083          	lw	ra,12(sp)
40009d08:	01010113          	addi	sp,sp,16
		net_if_carrier_on(ctx->iface);
40009d0c:	3290506f          	j	4000f834 <net_if_carrier_on>
}
40009d10:	00812403          	lw	s0,8(sp)
40009d14:	00c12083          	lw	ra,12(sp)
40009d18:	01010113          	addi	sp,sp,16
		net_if_carrier_off(ctx->iface);
40009d1c:	35d0506f          	j	4000f878 <net_if_carrier_off>
}
40009d20:	00c12083          	lw	ra,12(sp)
40009d24:	00812403          	lw	s0,8(sp)
40009d28:	01010113          	addi	sp,sp,16
40009d2c:	00008067          	ret
40009d30:	00008067          	ret

40009d34 <ethernet_recv>:
{
40009d34:	fe010113          	addi	sp,sp,-32
40009d38:	00112e23          	sw	ra,28(sp)
40009d3c:	00812c23          	sw	s0,24(sp)
40009d40:	00912a23          	sw	s1,20(sp)
40009d44:	01212823          	sw	s2,16(sp)
40009d48:	01312623          	sw	s3,12(sp)
40009d4c:	01412423          	sw	s4,8(sp)
40009d50:	01512223          	sw	s5,4(sp)
40009d54:	01612023          	sw	s6,0(sp)
	return net_buf_frags_len(pkt->frags);
}

static inline uint8_t *net_pkt_data(struct net_pkt *pkt)
{
	return pkt->frags->data;
40009d58:	0085a783          	lw	a5,8(a1)
40009d5c:	00c7a483          	lw	s1,12(a5)
	if (hdr == NULL || pkt->buffer->len < hdr_len) {
40009d60:	06048263          	beqz	s1,40009dc4 <ethernet_recv+0x90>
40009d64:	0107d703          	lhu	a4,16(a5)
40009d68:	00d00793          	li	a5,13
40009d6c:	04e7fc63          	bgeu	a5,a4,40009dc4 <ethernet_recv+0x90>
40009d70:	00d4c903          	lbu	s2,13(s1)
40009d74:	00c4c783          	lbu	a5,12(s1)
40009d78:	00050a13          	mv	s4,a0
40009d7c:	00891913          	slli	s2,s2,0x8
40009d80:	00f96933          	or	s2,s2,a5
40009d84:	00895713          	srli	a4,s2,0x8
40009d88:	00891793          	slli	a5,s2,0x8
40009d8c:	00e7e7b3          	or	a5,a5,a4
	switch (type) {
40009d90:	0000e737          	lui	a4,0xe
40009d94:	01079793          	slli	a5,a5,0x10
40009d98:	d8670713          	addi	a4,a4,-634 # dd86 <__kernel_ram_size+0x1af2>
40009d9c:	00058413          	mv	s0,a1
	type = ntohs(hdr->type);
40009da0:	0107d793          	srli	a5,a5,0x10
	switch (type) {
40009da4:	16e90663          	beq	s2,a4,40009f10 <ethernet_recv+0x1dc>
40009da8:	00008737          	lui	a4,0x8
40009dac:	6dd70713          	addi	a4,a4,1757 # 86dd <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x46dd>
40009db0:	00f76e63          	bltu	a4,a5,40009dcc <ethernet_recv+0x98>
40009db4:	00800713          	li	a4,8
40009db8:	02e90463          	beq	s2,a4,40009de0 <ethernet_recv+0xac>
40009dbc:	60800713          	li	a4,1544
40009dc0:	02e90063          	beq	s2,a4,40009de0 <ethernet_recv+0xac>
	return NET_DROP;
40009dc4:	00200513          	li	a0,2
40009dc8:	2040006f          	j	40009fcc <ethernet_recv+0x298>
	switch (type) {
40009dcc:	00009737          	lui	a4,0x9
40009dd0:	e8870713          	addi	a4,a4,-376 # 8e88 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x4e88>
40009dd4:	fee918e3          	bne	s2,a4,40009dc4 <ethernet_recv+0x90>
40009dd8:	00000993          	li	s3,0
40009ddc:	0180006f          	j	40009df4 <ethernet_recv+0xc0>
	pkt->family = family;
40009de0:	03744703          	lbu	a4,55(s0)
		family = AF_INET;
40009de4:	00100993          	li	s3,1
40009de8:	01f77713          	andi	a4,a4,31
40009dec:	02076713          	ori	a4,a4,32
40009df0:	02e40ba3          	sb	a4,55(s0)
	lladdr->addr = hdr->src.addr;
40009df4:	00648713          	addi	a4,s1,6
40009df8:	02e42223          	sw	a4,36(s0)
	lladdr->len = sizeof(struct net_eth_addr);
40009dfc:	30600713          	li	a4,774
40009e00:	02e41423          	sh	a4,40(s0)
	lladdr->addr = hdr->dst.addr;
40009e04:	02942623          	sw	s1,44(s0)
	lladdr->len = sizeof(struct net_eth_addr);
40009e08:	02e41823          	sh	a4,48(s0)
	return pkt->ll_proto_type;
}

static inline void net_pkt_set_ll_proto_type(struct net_pkt *pkt, uint16_t type)
{
	pkt->ll_proto_type = type;
40009e0c:	02f41a23          	sh	a5,52(s0)
	if (!net_eth_is_addr_broadcast((struct net_eth_addr *)lladdr->addr) &&
40009e10:	00048513          	mv	a0,s1
40009e14:	e55ff0ef          	jal	ra,40009c68 <net_eth_is_addr_broadcast>
40009e18:	10050863          	beqz	a0,40009f28 <ethernet_recv+0x1f4>
 *
 * @return New beginning of the buffer data.
 */
static inline void *net_buf_pull(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull(&buf->b, len);
40009e1c:	00842503          	lw	a0,8(s0)
40009e20:	00e00593          	li	a1,14
40009e24:	00c50513          	addi	a0,a0,12
40009e28:	d31ff0ef          	jal	ra,40009b58 <net_buf_simple_pull>
	if (IS_ENABLED(CONFIG_NET_IPV4) && type == NET_ETH_PTYPE_IP &&
40009e2c:	00800793          	li	a5,8
40009e30:	08f91a63          	bne	s2,a5,40009ec4 <ethernet_recv+0x190>
	if (net_eth_is_addr_broadcast(&hdr->dst) &&
40009e34:	00048513          	mv	a0,s1
40009e38:	e31ff0ef          	jal	ra,40009c68 <net_eth_is_addr_broadcast>
	return pkt->frags->data;
40009e3c:	00842783          	lw	a5,8(s0)
40009e40:	08050263          	beqz	a0,40009ec4 <ethernet_recv+0x190>
40009e44:	00c7ab03          	lw	s6,12(a5)
	    !(net_ipv4_is_addr_mcast((struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
40009e48:	010b0a13          	addi	s4,s6,16
40009e4c:	000a0513          	mv	a0,s4
40009e50:	d69ff0ef          	jal	ra,40009bb8 <net_ipv4_is_addr_mcast>
	if (net_eth_is_addr_broadcast(&hdr->dst) &&
40009e54:	06051863          	bnez	a0,40009ec4 <ethernet_recv+0x190>
	return pkt->iface;
40009e58:	01842a83          	lw	s5,24(s0)
 */
#if defined(CONFIG_NET_NATIVE_IPV4)
static inline bool net_ipv4_is_addr_bcast(struct net_if *iface,
					  const struct in_addr *addr)
{
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
40009e5c:	605060ef          	jal	ra,40010c60 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40009e60:	011b4703          	lbu	a4,17(s6)
40009e64:	010b4783          	lbu	a5,16(s6)
40009e68:	00054683          	lbu	a3,0(a0)
40009e6c:	00871713          	slli	a4,a4,0x8
40009e70:	00f76733          	or	a4,a4,a5
40009e74:	012b4783          	lbu	a5,18(s6)
40009e78:	01079793          	slli	a5,a5,0x10
40009e7c:	00e7e7b3          	or	a5,a5,a4
40009e80:	013b4703          	lbu	a4,19(s6)
40009e84:	01871713          	slli	a4,a4,0x18
40009e88:	00f76733          	or	a4,a4,a5
40009e8c:	00154783          	lbu	a5,1(a0)
40009e90:	00879793          	slli	a5,a5,0x8
40009e94:	00d7e7b3          	or	a5,a5,a3
40009e98:	00254683          	lbu	a3,2(a0)
40009e9c:	01069693          	slli	a3,a3,0x10
40009ea0:	00f6e6b3          	or	a3,a3,a5
40009ea4:	00354783          	lbu	a5,3(a0)
40009ea8:	01879793          	slli	a5,a5,0x18
40009eac:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
40009eb0:	00f70a63          	beq	a4,a5,40009ec4 <ethernet_recv+0x190>
		return true;
	}

	return net_if_ipv4_is_addr_bcast(iface, addr);
40009eb4:	000a0593          	mv	a1,s4
40009eb8:	000a8513          	mv	a0,s5
40009ebc:	515040ef          	jal	ra,4000ebd0 <net_if_ipv4_is_addr_bcast>
	    !(net_ipv4_is_addr_mcast((struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
40009ec0:	f00502e3          	beqz	a0,40009dc4 <ethernet_recv+0x90>
	ethernet_update_rx_stats(iface, hdr, net_pkt_get_len(pkt) + hdr_len);
40009ec4:	00842683          	lw	a3,8(s0)
	switch (type) {
40009ec8:	00068793          	mv	a5,a3
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;

	while (buf) {
40009ecc:	0a079a63          	bnez	a5,40009f80 <ethernet_recv+0x24c>
	if (IS_ENABLED(CONFIG_NET_ARP) &&
40009ed0:	00100793          	li	a5,1
40009ed4:	0af99a63          	bne	s3,a5,40009f88 <ethernet_recv+0x254>
	    family == AF_INET && type == NET_ETH_PTYPE_ARP) {
40009ed8:	60800793          	li	a5,1544
40009edc:	0af91663          	bne	s2,a5,40009f88 <ethernet_recv+0x254>
		return net_arp_input(pkt, hdr);
40009ee0:	00040513          	mv	a0,s0
}
40009ee4:	01812403          	lw	s0,24(sp)
40009ee8:	01c12083          	lw	ra,28(sp)
40009eec:	01012903          	lw	s2,16(sp)
40009ef0:	00c12983          	lw	s3,12(sp)
40009ef4:	00812a03          	lw	s4,8(sp)
40009ef8:	00412a83          	lw	s5,4(sp)
40009efc:	00012b03          	lw	s6,0(sp)
		return net_arp_input(pkt, hdr);
40009f00:	00048593          	mv	a1,s1
}
40009f04:	01412483          	lw	s1,20(sp)
40009f08:	02010113          	addi	sp,sp,32
		return net_arp_input(pkt, hdr);
40009f0c:	6bd0006f          	j	4000adc8 <net_arp_input>
	pkt->family = family;
40009f10:	0375c703          	lbu	a4,55(a1)
		family = AF_INET6;
40009f14:	00200993          	li	s3,2
40009f18:	01f77713          	andi	a4,a4,31
40009f1c:	04076713          	ori	a4,a4,64
40009f20:	02e58ba3          	sb	a4,55(a1)
		break;
40009f24:	ed1ff06f          	j	40009df4 <ethernet_recv+0xc0>
}

static inline bool net_eth_is_addr_multicast(struct net_eth_addr *addr)
{
#if defined(CONFIG_NET_IPV6)
	if (addr->addr[0] == 0x33 &&
40009f28:	0004c783          	lbu	a5,0(s1)
40009f2c:	03300713          	li	a4,51
40009f30:	02e79a63          	bne	a5,a4,40009f64 <ethernet_recv+0x230>
40009f34:	0014c703          	lbu	a4,1(s1)
	}
#endif

#if defined(CONFIG_NET_IPV4)
	if (addr->addr[0] == 0x01 &&
	    addr->addr[1] == 0x00 &&
40009f38:	eef702e3          	beq	a4,a5,40009e1c <ethernet_recv+0xe8>
 *
 * @return a pointer to the network link address
 */
static inline struct net_linkaddr *net_if_get_link_addr(struct net_if *iface)
{
	return &iface->if_dev->link_addr;
40009f3c:	000a2783          	lw	a5,0(s4)
{
	if (!lladdr1 || !lladdr2) {
		return false;
	}

	if (lladdr1->len != lladdr2->len) {
40009f40:	00600713          	li	a4,6
40009f44:	0147c683          	lbu	a3,20(a5)
40009f48:	e6e69ee3          	bne	a3,a4,40009dc4 <ethernet_recv+0x90>
		return false;
	}

	return !memcmp(lladdr1->addr, lladdr2->addr, lladdr1->len);
40009f4c:	0107a503          	lw	a0,16(a5)
40009f50:	00600613          	li	a2,6
40009f54:	00048593          	mv	a1,s1
40009f58:	874ff0ef          	jal	ra,40008fcc <memcmp>
		    (struct net_eth_addr *)lladdr->addr) &&
40009f5c:	ec0500e3          	beqz	a0,40009e1c <ethernet_recv+0xe8>
40009f60:	e65ff06f          	j	40009dc4 <ethernet_recv+0x90>
	if (addr->addr[0] == 0x01 &&
40009f64:	00100713          	li	a4,1
40009f68:	fce79ae3          	bne	a5,a4,40009f3c <ethernet_recv+0x208>
40009f6c:	0014c783          	lbu	a5,1(s1)
40009f70:	fc0796e3          	bnez	a5,40009f3c <ethernet_recv+0x208>
	    addr->addr[1] == 0x00 &&
40009f74:	0024c703          	lbu	a4,2(s1)
40009f78:	05e00793          	li	a5,94
40009f7c:	fbdff06f          	j	40009f38 <ethernet_recv+0x204>
		bytes += buf->len;
		buf = buf->frags;
40009f80:	0047a783          	lw	a5,4(a5)
40009f84:	f49ff06f          	j	40009ecc <ethernet_recv+0x198>
	return pkt->family;
40009f88:	03442703          	lw	a4,52(s0)
	if (net_pkt_family(pkt) == AF_INET) {
40009f8c:	00100613          	li	a2,1
	return pkt->frags->data;
40009f90:	00c6a783          	lw	a5,12(a3)
40009f94:	01d75713          	srli	a4,a4,0x1d
40009f98:	04c71e63          	bne	a4,a2,40009ff4 <ethernet_recv+0x2c0>
40009f9c:	0037c703          	lbu	a4,3(a5)
40009fa0:	0027c603          	lbu	a2,2(a5)
40009fa4:	00871713          	slli	a4,a4,0x8
40009fa8:	00c76733          	or	a4,a4,a2
40009fac:	00871793          	slli	a5,a4,0x8
40009fb0:	00875713          	srli	a4,a4,0x8
40009fb4:	00e7e7b3          	or	a5,a5,a4
		len = ntohs(NET_IPV6_HDR(pkt)->len) + NET_IPV6H_LEN;
40009fb8:	01079793          	slli	a5,a5,0x10
40009fbc:	0107d793          	srli	a5,a5,0x10
	if (len < NET_ETH_MINIMAL_FRAME_SIZE - sizeof(struct net_eth_hdr)) {
40009fc0:	02d00713          	li	a4,45
40009fc4:	04f77a63          	bgeu	a4,a5,4000a018 <ethernet_recv+0x2e4>
	return NET_CONTINUE;
40009fc8:	00100513          	li	a0,1
}
40009fcc:	01c12083          	lw	ra,28(sp)
40009fd0:	01812403          	lw	s0,24(sp)
40009fd4:	01412483          	lw	s1,20(sp)
40009fd8:	01012903          	lw	s2,16(sp)
40009fdc:	00c12983          	lw	s3,12(sp)
40009fe0:	00812a03          	lw	s4,8(sp)
40009fe4:	00412a83          	lw	s5,4(sp)
40009fe8:	00012b03          	lw	s6,0(sp)
40009fec:	02010113          	addi	sp,sp,32
40009ff0:	00008067          	ret
		len = ntohs(NET_IPV6_HDR(pkt)->len) + NET_IPV6H_LEN;
40009ff4:	0057c703          	lbu	a4,5(a5)
40009ff8:	0047c603          	lbu	a2,4(a5)
40009ffc:	00871713          	slli	a4,a4,0x8
4000a000:	00c76733          	or	a4,a4,a2
4000a004:	00871793          	slli	a5,a4,0x8
4000a008:	00875713          	srli	a4,a4,0x8
4000a00c:	00e7e7b3          	or	a5,a5,a4
4000a010:	02878793          	addi	a5,a5,40
4000a014:	fa5ff06f          	j	40009fb8 <ethernet_recv+0x284>
			if (frag->len < len) {
4000a018:	0106d703          	lhu	a4,16(a3)
4000a01c:	00f77e63          	bgeu	a4,a5,4000a038 <ethernet_recv+0x304>
				len -= frag->len;
4000a020:	40e787b3          	sub	a5,a5,a4
4000a024:	01079793          	slli	a5,a5,0x10
4000a028:	0107d793          	srli	a5,a5,0x10
		for (frag = pkt->frags; frag; frag = frag->frags) {
4000a02c:	0046a683          	lw	a3,4(a3)
4000a030:	fe0694e3          	bnez	a3,4000a018 <ethernet_recv+0x2e4>
4000a034:	f95ff06f          	j	40009fc8 <ethernet_recv+0x294>
				frag->len = len;
4000a038:	00f69823          	sh	a5,16(a3)
				len = 0U;
4000a03c:	00000793          	li	a5,0
4000a040:	fedff06f          	j	4000a02c <ethernet_recv+0x2f8>

4000a044 <net_eth_broadcast_addr>:
	return &broadcast_eth_addr;
4000a044:	4002c537          	lui	a0,0x4002c
}
4000a048:	b2850513          	addi	a0,a0,-1240 # 4002bb28 <broadcast_eth_addr>
4000a04c:	00008067          	ret

4000a050 <net_eth_ipv4_mcast_to_mac_addr>:
	mac_addr->addr[0] = 0x01;
4000a050:	00100793          	li	a5,1
4000a054:	00f58023          	sb	a5,0(a1)
	mac_addr->addr[2] = 0x5e;
4000a058:	05e00793          	li	a5,94
	mac_addr->addr[1] = 0x00;
4000a05c:	000580a3          	sb	zero,1(a1)
	mac_addr->addr[2] = 0x5e;
4000a060:	00f58123          	sb	a5,2(a1)
	mac_addr->addr[3] = ipv4_addr->s4_addr[1];
4000a064:	00154783          	lbu	a5,1(a0)
4000a068:	00f581a3          	sb	a5,3(a1)
	mac_addr->addr[4] = ipv4_addr->s4_addr[2];
4000a06c:	00254703          	lbu	a4,2(a0)
	mac_addr->addr[3] &= 0x7f;
4000a070:	07f7f793          	andi	a5,a5,127
	mac_addr->addr[4] = ipv4_addr->s4_addr[2];
4000a074:	00e58223          	sb	a4,4(a1)
	mac_addr->addr[5] = ipv4_addr->s4_addr[3];
4000a078:	00354703          	lbu	a4,3(a0)
	mac_addr->addr[3] &= 0x7f;
4000a07c:	00f581a3          	sb	a5,3(a1)
	mac_addr->addr[5] = ipv4_addr->s4_addr[3];
4000a080:	00e582a3          	sb	a4,5(a1)
}
4000a084:	00008067          	ret

4000a088 <ethernet_send>:
{
4000a088:	fc010113          	addi	sp,sp,-64
4000a08c:	03212823          	sw	s2,48(sp)
4000a090:	02112e23          	sw	ra,60(sp)
4000a094:	02812c23          	sw	s0,56(sp)
4000a098:	02912a23          	sw	s1,52(sp)
4000a09c:	03312623          	sw	s3,44(sp)
4000a0a0:	03412423          	sw	s4,40(sp)
4000a0a4:	03512223          	sw	s5,36(sp)
4000a0a8:	03612023          	sw	s6,32(sp)
4000a0ac:	01712e23          	sw	s7,28(sp)
	return iface->if_dev->dev;
4000a0b0:	00052783          	lw	a5,0(a0)
		ret = -ENOENT;
4000a0b4:	ffe00913          	li	s2,-2
	const struct ethernet_api *api = net_if_get_device(iface)->api;
4000a0b8:	0007a783          	lw	a5,0(a5)
4000a0bc:	0087ab03          	lw	s6,8(a5)
	if (!api) {
4000a0c0:	280b0c63          	beqz	s6,4000a358 <ethernet_send+0x2d0>
	return pkt->family;
4000a0c4:	0345a783          	lw	a5,52(a1)
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
4000a0c8:	00100713          	li	a4,1
4000a0cc:	00050a93          	mv	s5,a0
4000a0d0:	01d7d793          	srli	a5,a5,0x1d
4000a0d4:	00058493          	mv	s1,a1
4000a0d8:	1ee79863          	bne	a5,a4,4000a2c8 <ethernet_send+0x240>
	return pkt->frags->data;
4000a0dc:	0085a783          	lw	a5,8(a1)
	return pkt->iface;
4000a0e0:	0185a903          	lw	s2,24(a1)
	return pkt->frags->data;
4000a0e4:	00c7a403          	lw	s0,12(a5)
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000a0e8:	379060ef          	jal	ra,40010c60 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000a0ec:	00054683          	lbu	a3,0(a0)
4000a0f0:	01144703          	lbu	a4,17(s0)
4000a0f4:	01044783          	lbu	a5,16(s0)
4000a0f8:	00871713          	slli	a4,a4,0x8
4000a0fc:	00f76733          	or	a4,a4,a5
4000a100:	01244783          	lbu	a5,18(s0)
4000a104:	01079793          	slli	a5,a5,0x10
4000a108:	00e7e7b3          	or	a5,a5,a4
4000a10c:	01344703          	lbu	a4,19(s0)
4000a110:	01871713          	slli	a4,a4,0x18
4000a114:	00f76733          	or	a4,a4,a5
4000a118:	00154783          	lbu	a5,1(a0)
4000a11c:	00879793          	slli	a5,a5,0x8
4000a120:	00d7e7b3          	or	a5,a5,a3
4000a124:	00254683          	lbu	a3,2(a0)
4000a128:	01069693          	slli	a3,a3,0x10
4000a12c:	00f6e6b3          	or	a3,a3,a5
4000a130:	00354783          	lbu	a5,3(a0)
4000a134:	01879793          	slli	a5,a5,0x18
4000a138:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000a13c:	12f71063          	bne	a4,a5,4000a25c <ethernet_send+0x1d4>
				ptype = htons(NET_ETH_PTYPE_IP);
4000a140:	00048413          	mv	s0,s1
4000a144:	00800993          	li	s3,8
	if (!net_pkt_lladdr_dst(pkt)->addr) {
4000a148:	02c42783          	lw	a5,44(s0)
4000a14c:	00079c63          	bnez	a5,4000a164 <ethernet_send+0xdc>
		net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)broadcast_eth_addr.addr;
4000a150:	4002c7b7          	lui	a5,0x4002c
4000a154:	b2878793          	addi	a5,a5,-1240 # 4002bb28 <broadcast_eth_addr>
4000a158:	02f42623          	sw	a5,44(s0)
		net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
4000a15c:	00600793          	li	a5,6
4000a160:	02f40823          	sb	a5,48(s0)
	hdr_frag = net_pkt_get_frag(pkt, hdr_len, NET_BUF_TIMEOUT);
4000a164:	00a00613          	li	a2,10
4000a168:	00000693          	li	a3,0
4000a16c:	00e00593          	li	a1,14
4000a170:	00040513          	mv	a0,s0
4000a174:	519080ef          	jal	ra,40012e8c <net_pkt_get_frag>
4000a178:	00050a13          	mv	s4,a0
	if (!hdr_frag) {
4000a17c:	1c050c63          	beqz	a0,4000a354 <ethernet_send+0x2cc>
		if (ptype == htons(NET_ETH_PTYPE_ARP) ||
4000a180:	60800793          	li	a5,1544
		hdr = (struct net_eth_hdr *)(hdr_frag->data);
4000a184:	00c52903          	lw	s2,12(a0)
		if (ptype == htons(NET_ETH_PTYPE_ARP) ||
4000a188:	1af98e63          	beq	s3,a5,4000a344 <ethernet_send+0x2bc>
	return pkt->family;
4000a18c:	03442783          	lw	a5,52(s0)
	if (net_pkt_family(pkt) == AF_INET &&
4000a190:	00100713          	li	a4,1
4000a194:	01d7d793          	srli	a5,a5,0x1d
4000a198:	16e79063          	bne	a5,a4,4000a2f8 <ethernet_send+0x270>
	return pkt->frags->data;
4000a19c:	00842783          	lw	a5,8(s0)
	    net_ipv4_is_addr_mcast((struct in_addr *)NET_IPV4_HDR(pkt)->dst)) {
4000a1a0:	00c7ab83          	lw	s7,12(a5)
4000a1a4:	010b8b93          	addi	s7,s7,16
4000a1a8:	000b8513          	mv	a0,s7
4000a1ac:	a0dff0ef          	jal	ra,40009bb8 <net_ipv4_is_addr_mcast>
	if (net_pkt_family(pkt) == AF_INET &&
4000a1b0:	18050a63          	beqz	a0,4000a344 <ethernet_send+0x2bc>
		net_eth_ipv4_mcast_to_mac_addr(
4000a1b4:	00090593          	mv	a1,s2
4000a1b8:	000b8513          	mv	a0,s7
4000a1bc:	e95ff0ef          	jal	ra,4000a050 <net_eth_ipv4_mcast_to_mac_addr>
		memcpy(&hdr->src, net_pkt_lladdr_src(pkt)->addr,
4000a1c0:	02442583          	lw	a1,36(s0)
4000a1c4:	00600613          	li	a2,6
4000a1c8:	00690513          	addi	a0,s2,6
4000a1cc:	e81fe0ef          	jal	ra,4000904c <memcpy>
		hdr->type = ptype;
4000a1d0:	0089d793          	srli	a5,s3,0x8
4000a1d4:	00f906a3          	sb	a5,13(s2)
4000a1d8:	01390623          	sb	s3,12(s2)
	return net_buf_simple_add(&buf->b, len);
4000a1dc:	00e00593          	li	a1,14
4000a1e0:	00ca0513          	addi	a0,s4,12
4000a1e4:	939ff0ef          	jal	ra,40009b1c <net_buf_simple_add>
	net_pkt_frag_insert(pkt, hdr_frag);
4000a1e8:	000a0593          	mv	a1,s4
4000a1ec:	00040513          	mv	a0,s0
4000a1f0:	5a5080ef          	jal	ra,40012f94 <net_pkt_frag_insert>
	net_pkt_cursor_init(pkt);
4000a1f4:	00040513          	mv	a0,s0
4000a1f8:	7f9080ef          	jal	ra,400131f0 <net_pkt_cursor_init>
4000a1fc:	000aa703          	lw	a4,0(s5)
			      struct net_if *iface,
			      struct net_pkt *pkt)
{
	net_capture_pkt(iface, pkt);

	return send_fn(dev, pkt);
4000a200:	018b2783          	lw	a5,24(s6)
4000a204:	00040593          	mv	a1,s0
4000a208:	00072503          	lw	a0,0(a4)
4000a20c:	000780e7          	jalr	a5
4000a210:	00050913          	mv	s2,a0
	if (ret != 0) {
4000a214:	16050a63          	beqz	a0,4000a388 <ethernet_send+0x300>
	buf = pkt->buffer;
4000a218:	00842503          	lw	a0,8(s0)
	pkt->buffer = buf->frags;
4000a21c:	00452783          	lw	a5,4(a0)
4000a220:	00f42423          	sw	a5,8(s0)
	buf->frags = NULL;
4000a224:	00052223          	sw	zero,4(a0)
	net_pkt_frag_unref(buf);
4000a228:	4e9080ef          	jal	ra,40012f10 <net_pkt_frag_unref>
		if (IS_ENABLED(CONFIG_NET_ARP) && ptype == htons(NET_ETH_PTYPE_ARP)) {
4000a22c:	60800793          	li	a5,1544
4000a230:	12f99463          	bne	s3,a5,4000a358 <ethernet_send+0x2d0>
			net_pkt_ref(orig_pkt);
4000a234:	00048513          	mv	a0,s1
4000a238:	47d080ef          	jal	ra,40012eb4 <net_pkt_ref>
4000a23c:	00842783          	lw	a5,8(s0)
			if (net_arp_clear_pending(iface,
4000a240:	000a8513          	mv	a0,s5
				(struct in_addr *)NET_IPV4_HDR(pkt)->dst)) {
4000a244:	00c7a583          	lw	a1,12(a5)
			if (net_arp_clear_pending(iface,
4000a248:	01058593          	addi	a1,a1,16
4000a24c:	0e8010ef          	jal	ra,4000b334 <net_arp_clear_pending>
	net_pkt_unref(pkt);
4000a250:	00040513          	mv	a0,s0
4000a254:	4c9080ef          	jal	ra,40012f1c <net_pkt_unref>
4000a258:	1000006f          	j	4000a358 <ethernet_send+0x2d0>
	return net_if_ipv4_is_addr_bcast(iface, addr);
4000a25c:	01040593          	addi	a1,s0,16
4000a260:	00090513          	mv	a0,s2
4000a264:	16d040ef          	jal	ra,4000ebd0 <net_if_ipv4_is_addr_bcast>
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
4000a268:	ec051ce3          	bnez	a0,4000a140 <ethernet_send+0xb8>
4000a26c:	0084a783          	lw	a5,8(s1)
	    net_ipv4_is_addr_mcast((struct in_addr *)NET_IPV4_HDR(pkt)->dst)) {
4000a270:	00c7a583          	lw	a1,12(a5)
4000a274:	01058593          	addi	a1,a1,16
4000a278:	00058513          	mv	a0,a1
4000a27c:	00b12623          	sw	a1,12(sp)
4000a280:	939ff0ef          	jal	ra,40009bb8 <net_ipv4_is_addr_mcast>
	if (ethernet_ipv4_dst_is_broadcast_or_mcast(pkt)) {
4000a284:	ea051ee3          	bnez	a0,4000a140 <ethernet_send+0xb8>
		arp_pkt = net_arp_prepare(pkt, (struct in_addr *)NET_IPV4_HDR(pkt)->dst, NULL);
4000a288:	00c12583          	lw	a1,12(sp)
4000a28c:	00000613          	li	a2,0
4000a290:	00048513          	mv	a0,s1
4000a294:	740000ef          	jal	ra,4000a9d4 <net_arp_prepare>
4000a298:	00050413          	mv	s0,a0
		if (!arp_pkt) {
4000a29c:	0a050c63          	beqz	a0,4000a354 <ethernet_send+0x2cc>
				ptype = htons(NET_ETH_PTYPE_IP);
4000a2a0:	00800993          	li	s3,8
		if (pkt != arp_pkt) {
4000a2a4:	eaa482e3          	beq	s1,a0,4000a148 <ethernet_send+0xc0>
			net_pkt_unref(pkt);
4000a2a8:	00048513          	mv	a0,s1
4000a2ac:	471080ef          	jal	ra,40012f1c <net_pkt_unref>
	pkt->family = family;
4000a2b0:	03744783          	lbu	a5,55(s0)
4000a2b4:	01f7f793          	andi	a5,a5,31
4000a2b8:	0207e793          	ori	a5,a5,32
4000a2bc:	02f40ba3          	sb	a5,55(s0)
		ptype = htons(NET_ETH_PTYPE_ARP);
4000a2c0:	60800993          	li	s3,1544
}
4000a2c4:	e85ff06f          	j	4000a148 <ethernet_send+0xc0>
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
4000a2c8:	00200713          	li	a4,2
4000a2cc:	00e78e63          	beq	a5,a4,4000a2e8 <ethernet_send+0x260>
	pkt->family = family;
4000a2d0:	0375c783          	lbu	a5,55(a1)
}
4000a2d4:	00058413          	mv	s0,a1
	pkt->family = family;
4000a2d8:	01f7f793          	andi	a5,a5,31
4000a2dc:	0207e793          	ori	a5,a5,32
4000a2e0:	02f58ba3          	sb	a5,55(a1)
4000a2e4:	fddff06f          	j	4000a2c0 <ethernet_send+0x238>
		ptype = htons(NET_ETH_PTYPE_IPV6);
4000a2e8:	0000e9b7          	lui	s3,0xe
4000a2ec:	00058413          	mv	s0,a1
4000a2f0:	d8698993          	addi	s3,s3,-634 # dd86 <__kernel_ram_size+0x1af2>
4000a2f4:	e55ff06f          	j	4000a148 <ethernet_send+0xc0>
	if (net_pkt_family(pkt) == AF_INET6 &&
4000a2f8:	00200713          	li	a4,2
4000a2fc:	04e79463          	bne	a5,a4,4000a344 <ethernet_send+0x2bc>
	return pkt->frags->data;
4000a300:	00842783          	lw	a5,8(s0)
	return addr->s6_addr[0] == 0xFF;
4000a304:	00c7a783          	lw	a5,12(a5)
4000a308:	0187c703          	lbu	a4,24(a5)
4000a30c:	0ff00793          	li	a5,255
4000a310:	02f71a63          	bne	a4,a5,4000a344 <ethernet_send+0x2bc>
		memcpy(dst, (uint8_t *)multicast_eth_addr.addr,
4000a314:	4002c5b7          	lui	a1,0x4002c
4000a318:	00200613          	li	a2,2
4000a31c:	b3058593          	addi	a1,a1,-1232 # 4002bb30 <multicast_eth_addr>
4000a320:	00090513          	mv	a0,s2
4000a324:	d29fe0ef          	jal	ra,4000904c <memcpy>
4000a328:	00842783          	lw	a5,8(s0)
		memcpy((uint8_t *)dst + 2,
4000a32c:	00400613          	li	a2,4
4000a330:	00290513          	addi	a0,s2,2
4000a334:	00c7a583          	lw	a1,12(a5)
4000a338:	02458593          	addi	a1,a1,36
			memcpy(&hdr->dst, net_pkt_lladdr_dst(pkt)->addr,
4000a33c:	d11fe0ef          	jal	ra,4000904c <memcpy>
4000a340:	e81ff06f          	j	4000a1c0 <ethernet_send+0x138>
4000a344:	02c42583          	lw	a1,44(s0)
4000a348:	00600613          	li	a2,6
4000a34c:	00090513          	mv	a0,s2
4000a350:	fedff06f          	j	4000a33c <ethernet_send+0x2b4>
				ret = -ENOMEM;
4000a354:	ff400913          	li	s2,-12
}
4000a358:	03c12083          	lw	ra,60(sp)
4000a35c:	03812403          	lw	s0,56(sp)
4000a360:	03412483          	lw	s1,52(sp)
4000a364:	02c12983          	lw	s3,44(sp)
4000a368:	02812a03          	lw	s4,40(sp)
4000a36c:	02412a83          	lw	s5,36(sp)
4000a370:	02012b03          	lw	s6,32(sp)
4000a374:	01c12b83          	lw	s7,28(sp)
4000a378:	00090513          	mv	a0,s2
4000a37c:	03012903          	lw	s2,48(sp)
4000a380:	04010113          	addi	sp,sp,64
4000a384:	00008067          	ret
	ret = net_pkt_get_len(pkt);
4000a388:	00842503          	lw	a0,8(s0)
	size_t bytes = 0;
4000a38c:	00000913          	li	s2,0
	if (ret != 0) {
4000a390:	00050793          	mv	a5,a0
	while (buf) {
4000a394:	00079c63          	bnez	a5,4000a3ac <ethernet_send+0x324>
	pkt->buffer = buf->frags;
4000a398:	00452783          	lw	a5,4(a0)
4000a39c:	00f42423          	sw	a5,8(s0)
	buf->frags = NULL;
4000a3a0:	00052223          	sw	zero,4(a0)
	net_pkt_frag_unref(buf);
4000a3a4:	36d080ef          	jal	ra,40012f10 <net_pkt_frag_unref>
4000a3a8:	ea9ff06f          	j	4000a250 <ethernet_send+0x1c8>
		bytes += buf->len;
4000a3ac:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
4000a3b0:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4000a3b4:	00e90933          	add	s2,s2,a4
		buf = buf->frags;
4000a3b8:	fddff06f          	j	4000a394 <ethernet_send+0x30c>

4000a3bc <ethernet_init>:
			&params, sizeof(struct ethernet_req_params));
}
#endif/* CONFIG_NET_PROMISCUOUS_MODE */

void ethernet_init(struct net_if *iface)
{
4000a3bc:	ff010113          	addi	sp,sp,-16
4000a3c0:	00912223          	sw	s1,4(sp)
4000a3c4:	00112623          	sw	ra,12(sp)
4000a3c8:	00812423          	sw	s0,8(sp)
	return iface->if_dev->l2_data;
4000a3cc:	00052783          	lw	a5,0(a0)

	NET_DBG("Initializing Ethernet L2 %p for iface %p", ctx, iface);

	ctx->ethernet_l2_flags = NET_L2_MULTICAST;
	ctx->iface = iface;
	k_work_init(&ctx->carrier_work, carrier_on_off);
4000a3d0:	4000a5b7          	lui	a1,0x4000a
{
4000a3d4:	00050493          	mv	s1,a0
4000a3d8:	0087a403          	lw	s0,8(a5)
	ctx->ethernet_l2_flags = NET_L2_MULTICAST;
4000a3dc:	00100793          	li	a5,1
	k_work_init(&ctx->carrier_work, carrier_on_off);
4000a3e0:	cb458593          	addi	a1,a1,-844 # 40009cb4 <carrier_on_off>
	ctx->ethernet_l2_flags = NET_L2_MULTICAST;
4000a3e4:	00f40c23          	sb	a5,24(s0)
	ctx->iface = iface;
4000a3e8:	00a42a23          	sw	a0,20(s0)
	k_work_init(&ctx->carrier_work, carrier_on_off);
4000a3ec:	00440513          	addi	a0,s0,4
4000a3f0:	7d11e0ef          	jal	ra,400293c0 <k_work_init>
	return iface->if_dev->dev;
4000a3f4:	0004a783          	lw	a5,0(s1)
4000a3f8:	0007a503          	lw	a0,0(a5)
enum ethernet_hw_caps net_eth_get_hw_capabilities(struct net_if *iface)
{
	const struct ethernet_api *eth =
		(struct ethernet_api *)net_if_get_device(iface)->api;

	if (!eth->get_capabilities) {
4000a3fc:	00852783          	lw	a5,8(a0)
4000a400:	00c7a783          	lw	a5,12(a5)
4000a404:	00078e63          	beqz	a5,4000a420 <ethernet_init+0x64>
		return (enum ethernet_hw_caps)0;
	}

	return eth->get_capabilities(net_if_get_device(iface));
4000a408:	000780e7          	jalr	a5

	if (net_eth_get_hw_capabilities(iface) & ETHERNET_PROMISC_MODE) {
4000a40c:	40057513          	andi	a0,a0,1024
4000a410:	00050863          	beqz	a0,4000a420 <ethernet_init+0x64>
		ctx->ethernet_l2_flags |= NET_L2_PROMISC_MODE;
4000a414:	01844783          	lbu	a5,24(s0)
4000a418:	0047e793          	ori	a5,a5,4
4000a41c:	00f40c23          	sb	a5,24(s0)
			break;
		}
	}
#endif

	net_arp_init();
4000a420:	7d1000ef          	jal	ra,4000b3f0 <net_arp_init>

	ctx->is_init = true;
4000a424:	01944783          	lbu	a5,25(s0)
4000a428:	0027e793          	ori	a5,a5,2
4000a42c:	00f40ca3          	sb	a5,25(s0)
}
4000a430:	00c12083          	lw	ra,12(sp)
4000a434:	00812403          	lw	s0,8(sp)
4000a438:	00412483          	lw	s1,4(sp)
4000a43c:	01010113          	addi	sp,sp,16
4000a440:	00008067          	ret

4000a444 <sys_slist_prepend>:
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
4000a444:	00052783          	lw	a5,0(a0)
	parent->next = child;
4000a448:	00f5a023          	sw	a5,0(a1)
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node);

Z_GENLIST_PREPEND(slist, snode)
4000a44c:	00452783          	lw	a5,4(a0)
	list->head = node;
4000a450:	00b52023          	sw	a1,0(a0)
Z_GENLIST_PREPEND(slist, snode)
4000a454:	00079463          	bnez	a5,4000a45c <sys_slist_prepend+0x18>
	list->tail = node;
4000a458:	00b52223          	sw	a1,4(a0)
Z_GENLIST_PREPEND(slist, snode)
4000a45c:	00008067          	ret

4000a460 <sys_slist_remove>:
	return node->next;
4000a460:	00062783          	lw	a5,0(a2)
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
4000a464:	00059e63          	bnez	a1,4000a480 <sys_slist_remove+0x20>
4000a468:	00452703          	lw	a4,4(a0)
	list->head = node;
4000a46c:	00f52023          	sw	a5,0(a0)
Z_GENLIST_REMOVE(slist, snode)
4000a470:	00e61463          	bne	a2,a4,4000a478 <sys_slist_remove+0x18>
	list->tail = node;
4000a474:	00f52223          	sw	a5,4(a0)
	parent->next = child;
4000a478:	00062023          	sw	zero,0(a2)
Z_GENLIST_REMOVE(slist, snode)
4000a47c:	00008067          	ret
	parent->next = child;
4000a480:	00f5a023          	sw	a5,0(a1)
Z_GENLIST_REMOVE(slist, snode)
4000a484:	00452783          	lw	a5,4(a0)
4000a488:	fef618e3          	bne	a2,a5,4000a478 <sys_slist_remove+0x18>
	list->tail = node;
4000a48c:	00b52223          	sw	a1,4(a0)
}
4000a490:	fe9ff06f          	j	4000a478 <sys_slist_remove+0x18>

4000a494 <k_uptime_get_32>:
{
4000a494:	ff010113          	addi	sp,sp,-16
4000a498:	00112623          	sw	ra,12(sp)
	return z_impl_k_uptime_ticks();
4000a49c:	718200ef          	jal	ra,4002abb4 <z_impl_k_uptime_ticks>
}
4000a4a0:	00c12083          	lw	ra,12(sp)
4000a4a4:	00a00793          	li	a5,10
4000a4a8:	02a78533          	mul	a0,a5,a0
4000a4ac:	01010113          	addi	sp,sp,16
4000a4b0:	00008067          	ret

4000a4b4 <arp_entry_get_last_from_table>:

	return CONTAINER_OF(node, struct arp_entry, node);
}

static struct arp_entry *arp_entry_get_last_from_table(void)
{
4000a4b4:	ff010113          	addi	sp,sp,-16
	return list->tail;
4000a4b8:	40031537          	lui	a0,0x40031
4000a4bc:	00112623          	sw	ra,12(sp)
4000a4c0:	00812423          	sw	s0,8(sp)
4000a4c4:	a1c50793          	addi	a5,a0,-1508 # 40030a1c <arp_table>
4000a4c8:	0047a403          	lw	s0,4(a5)
	/* We assume last entry is the oldest one,
	 * so is the preferred one to be taken out.
	 */

	node = sys_slist_peek_tail(&arp_table);
	if (!node) {
4000a4cc:	02040063          	beqz	s0,4000a4ec <arp_entry_get_last_from_table+0x38>
	return list->head;
4000a4d0:	0007a783          	lw	a5,0(a5)
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4000a4d4:	00000593          	li	a1,0
4000a4d8:	00078a63          	beqz	a5,4000a4ec <arp_entry_get_last_from_table+0x38>
4000a4dc:	02f41263          	bne	s0,a5,4000a500 <arp_entry_get_last_from_table+0x4c>
4000a4e0:	00040613          	mv	a2,s0
4000a4e4:	a1c50513          	addi	a0,a0,-1508
4000a4e8:	f79ff0ef          	jal	ra,4000a460 <sys_slist_remove>
	}

	sys_slist_find_and_remove(&arp_table, node);

	return CONTAINER_OF(node, struct arp_entry, node);
}
4000a4ec:	00c12083          	lw	ra,12(sp)
4000a4f0:	00040513          	mv	a0,s0
4000a4f4:	00812403          	lw	s0,8(sp)
4000a4f8:	01010113          	addi	sp,sp,16
4000a4fc:	00008067          	ret
	return node->next;
4000a500:	00078593          	mv	a1,a5
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4000a504:	0007a783          	lw	a5,0(a5)
4000a508:	fd1ff06f          	j	4000a4d8 <arp_entry_get_last_from_table+0x24>

4000a50c <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
4000a50c:	00058613          	mv	a2,a1
4000a510:	00050593          	mv	a1,a0
	return z_impl_k_mutex_lock(mutex, timeout);
4000a514:	40032537          	lui	a0,0x40032
4000a518:	c1450513          	addi	a0,a0,-1004 # 40031c14 <arp_mutex>
4000a51c:	3601e06f          	j	4002887c <z_impl_k_mutex_lock>

4000a520 <k_mutex_unlock.constprop.0.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
4000a520:	40032537          	lui	a0,0x40032
4000a524:	c1450513          	addi	a0,a0,-1004 # 40031c14 <arp_mutex>
4000a528:	4b01e06f          	j	400289d8 <z_impl_k_mutex_unlock>

4000a52c <if_get_addr.isra.0>:
					  struct in_addr *addr)
{
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
	int i;

	if (!ipv4) {
4000a52c:	08050663          	beqz	a0,4000a5b8 <if_get_addr.isra.0+0x8c>
		return NULL;
	}

	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
		if (ipv4->unicast[i].is_used &&
4000a530:	02c52783          	lw	a5,44(a0)
4000a534:	00100713          	li	a4,1
4000a538:	0197d793          	srli	a5,a5,0x19
4000a53c:	0017f793          	andi	a5,a5,1
4000a540:	06078a63          	beqz	a5,4000a5b4 <if_get_addr.isra.0+0x88>
4000a544:	00055783          	lhu	a5,0(a0)
4000a548:	06e79663          	bne	a5,a4,4000a5b4 <if_get_addr.isra.0+0x88>
		    ipv4->unicast[i].address.family == AF_INET &&
4000a54c:	02d50703          	lb	a4,45(a0)
4000a550:	06f71263          	bne	a4,a5,4000a5b4 <if_get_addr.isra.0+0x88>
		    ipv4->unicast[i].addr_state == NET_ADDR_PREFERRED &&
4000a554:	04058c63          	beqz	a1,4000a5ac <if_get_addr.isra.0+0x80>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000a558:	0015c703          	lbu	a4,1(a1)
4000a55c:	0005c783          	lbu	a5,0(a1)
4000a560:	00454683          	lbu	a3,4(a0)
4000a564:	00871713          	slli	a4,a4,0x8
4000a568:	00f76733          	or	a4,a4,a5
4000a56c:	0025c783          	lbu	a5,2(a1)
4000a570:	01079793          	slli	a5,a5,0x10
4000a574:	00e7e7b3          	or	a5,a5,a4
4000a578:	0035c703          	lbu	a4,3(a1)
4000a57c:	01871713          	slli	a4,a4,0x18
4000a580:	00f76733          	or	a4,a4,a5
4000a584:	00554783          	lbu	a5,5(a0)
4000a588:	00879793          	slli	a5,a5,0x8
4000a58c:	00d7e7b3          	or	a5,a5,a3
4000a590:	00654683          	lbu	a3,6(a0)
4000a594:	01069693          	slli	a3,a3,0x10
4000a598:	00f6e6b3          	or	a3,a3,a5
4000a59c:	00754783          	lbu	a5,7(a0)
4000a5a0:	01879793          	slli	a5,a5,0x18
4000a5a4:	00d7e7b3          	or	a5,a5,a3
		    (!addr ||
4000a5a8:	00f71663          	bne	a4,a5,4000a5b4 <if_get_addr.isra.0+0x88>
		     net_ipv4_addr_cmp(addr,
				       &ipv4->unicast[i].address.in_addr))) {
			return &ipv4->unicast[i].address.in_addr;
4000a5ac:	00450513          	addi	a0,a0,4
4000a5b0:	00008067          	ret
		return NULL;
4000a5b4:	00000513          	li	a0,0
		}
	}

	return NULL;
}
4000a5b8:	00008067          	ret

4000a5bc <arp_entry_find.isra.0>:
	SYS_SLIST_FOR_EACH_CONTAINER(list, entry, node) {
4000a5bc:	00051463          	bnez	a0,4000a5c4 <arp_entry_find.isra.0+0x8>
}
4000a5c0:	00008067          	ret
		if (entry->iface == iface &&
4000a5c4:	00852783          	lw	a5,8(a0)
4000a5c8:	04b79c63          	bne	a5,a1,4000a620 <arp_entry_find.isra.0+0x64>
4000a5cc:	00d54703          	lbu	a4,13(a0)
4000a5d0:	00c54783          	lbu	a5,12(a0)
4000a5d4:	00064803          	lbu	a6,0(a2)
4000a5d8:	00871713          	slli	a4,a4,0x8
4000a5dc:	00f76733          	or	a4,a4,a5
4000a5e0:	00e54783          	lbu	a5,14(a0)
4000a5e4:	01079793          	slli	a5,a5,0x10
4000a5e8:	00e7e7b3          	or	a5,a5,a4
4000a5ec:	00f54703          	lbu	a4,15(a0)
4000a5f0:	01871713          	slli	a4,a4,0x18
4000a5f4:	00f76733          	or	a4,a4,a5
4000a5f8:	00164783          	lbu	a5,1(a2)
4000a5fc:	00879793          	slli	a5,a5,0x8
4000a600:	0107e7b3          	or	a5,a5,a6
4000a604:	00264803          	lbu	a6,2(a2)
4000a608:	01081813          	slli	a6,a6,0x10
4000a60c:	00f86833          	or	a6,a6,a5
4000a610:	00364783          	lbu	a5,3(a2)
4000a614:	01879793          	slli	a5,a5,0x18
4000a618:	0107e7b3          	or	a5,a5,a6
4000a61c:	faf702e3          	beq	a4,a5,4000a5c0 <arp_entry_find.isra.0+0x4>
		if (previous) {
4000a620:	00068463          	beqz	a3,4000a628 <arp_entry_find.isra.0+0x6c>
			*previous = &entry->node;
4000a624:	00a6a023          	sw	a0,0(a3)
	return node->next;
4000a628:	00052503          	lw	a0,0(a0)
4000a62c:	f91ff06f          	j	4000a5bc <arp_entry_find.isra.0>

4000a630 <arp_update>:
static void arp_update(struct net_if *iface,
		       struct in_addr *src,
		       struct net_eth_addr *hwaddr,
		       bool gratuitous,
		       bool force)
{
4000a630:	fc010113          	addi	sp,sp,-64
4000a634:	02912a23          	sw	s1,52(sp)
4000a638:	03212823          	sw	s2,48(sp)
4000a63c:	03612023          	sw	s6,32(sp)
4000a640:	00050913          	mv	s2,a0
4000a644:	00058493          	mv	s1,a1
	struct arp_entry *entry;
	struct net_pkt *pkt;

	NET_DBG("src %s", net_sprint_ipv4_addr(src));

	k_mutex_lock(&arp_mutex, K_FOREVER);
4000a648:	fff00513          	li	a0,-1
4000a64c:	fff00593          	li	a1,-1
4000a650:	40031b37          	lui	s6,0x40031
{
4000a654:	03312623          	sw	s3,44(sp)
4000a658:	03412423          	sw	s4,40(sp)
4000a65c:	03512223          	sw	s5,36(sp)
4000a660:	01712e23          	sw	s7,28(sp)
4000a664:	02112e23          	sw	ra,60(sp)
4000a668:	02812c23          	sw	s0,56(sp)
4000a66c:	00060993          	mv	s3,a2
4000a670:	00068a93          	mv	s5,a3
4000a674:	00070a13          	mv	s4,a4
	k_mutex_lock(&arp_mutex, K_FOREVER);
4000a678:	e95ff0ef          	jal	ra,4000a50c <k_mutex_lock.constprop.0.isra.0>
	sys_snode_t *prev = NULL;
4000a67c:	a24b2b83          	lw	s7,-1500(s6) # 40030a24 <arp_pending_entries>
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
4000a680:	00c10693          	addi	a3,sp,12
4000a684:	00048613          	mv	a2,s1
4000a688:	00090593          	mv	a1,s2
4000a68c:	000b8513          	mv	a0,s7
	sys_snode_t *prev = NULL;
4000a690:	00012623          	sw	zero,12(sp)
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
4000a694:	f29ff0ef          	jal	ra,4000a5bc <arp_entry_find.isra.0>
	if (entry) {
4000a698:	0a051263          	bnez	a0,4000a73c <arp_update+0x10c>
	if (sys_slist_is_empty(&arp_pending_entries)) {
4000a69c:	000b9863          	bnez	s7,4000a6ac <arp_update+0x7c>
		k_work_cancel_delayable(&arp_request_timer);
4000a6a0:	40031537          	lui	a0,0x40031
4000a6a4:	da850513          	addi	a0,a0,-600 # 40030da8 <arp_request_timer>
4000a6a8:	7951e0ef          	jal	ra,4002963c <k_work_cancel_delayable>

	entry = arp_entry_get_pending(iface, src);
	if (!entry) {
		if (IS_ENABLED(CONFIG_NET_ARP_GRATUITOUS) && gratuitous) {
4000a6ac:	020a8863          	beqz	s5,4000a6dc <arp_update+0xac>
	entry = arp_entry_find(&arp_table, iface, src, &prev);
4000a6b0:	400317b7          	lui	a5,0x40031
4000a6b4:	a1c7a503          	lw	a0,-1508(a5) # 40030a1c <arp_table>
4000a6b8:	00c10693          	addi	a3,sp,12
4000a6bc:	00048613          	mv	a2,s1
4000a6c0:	00090593          	mv	a1,s2
4000a6c4:	ef9ff0ef          	jal	ra,4000a5bc <arp_entry_find.isra.0>
	if (entry) {
4000a6c8:	00050a63          	beqz	a0,4000a6dc <arp_update+0xac>
		memcpy(&entry->eth, hwaddr, sizeof(struct net_eth_addr));
4000a6cc:	00600613          	li	a2,6
4000a6d0:	00098593          	mv	a1,s3
4000a6d4:	01050513          	addi	a0,a0,16
4000a6d8:	975fe0ef          	jal	ra,4000904c <memcpy>
			arp_gratuitous(iface, src, hwaddr);
		}

		if (force) {
4000a6dc:	020a0a63          	beqz	s4,4000a710 <arp_update+0xe0>
			sys_snode_t *prev = NULL;
			struct arp_entry *entry;

			entry = arp_entry_find(&arp_table, iface, src, &prev);
4000a6e0:	40031a37          	lui	s4,0x40031
4000a6e4:	a1ca2503          	lw	a0,-1508(s4) # 40030a1c <arp_table>
4000a6e8:	00c10693          	addi	a3,sp,12
4000a6ec:	00048613          	mv	a2,s1
4000a6f0:	00090593          	mv	a1,s2
			sys_snode_t *prev = NULL;
4000a6f4:	00012623          	sw	zero,12(sp)
			entry = arp_entry_find(&arp_table, iface, src, &prev);
4000a6f8:	ec5ff0ef          	jal	ra,4000a5bc <arp_entry_find.isra.0>
			if (entry) {
4000a6fc:	0c050463          	beqz	a0,4000a7c4 <arp_update+0x194>
				memcpy(&entry->eth, hwaddr,
4000a700:	00600613          	li	a2,6
4000a704:	00098593          	mv	a1,s3
4000a708:	01050513          	addi	a0,a0,16
4000a70c:	941fe0ef          	jal	ra,4000904c <memcpy>

		net_if_queue_tx(iface, pkt);
	}

	k_mutex_unlock(&arp_mutex);
}
4000a710:	03812403          	lw	s0,56(sp)
4000a714:	03c12083          	lw	ra,60(sp)
4000a718:	03412483          	lw	s1,52(sp)
4000a71c:	03012903          	lw	s2,48(sp)
4000a720:	02c12983          	lw	s3,44(sp)
4000a724:	02812a03          	lw	s4,40(sp)
4000a728:	02412a83          	lw	s5,36(sp)
4000a72c:	02012b03          	lw	s6,32(sp)
4000a730:	01c12b83          	lw	s7,28(sp)
4000a734:	04010113          	addi	sp,sp,64
		k_mutex_unlock(&arp_mutex);
4000a738:	de9ff06f          	j	4000a520 <k_mutex_unlock.constprop.0.isra.0>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
4000a73c:	00c12583          	lw	a1,12(sp)
4000a740:	00050613          	mv	a2,a0
4000a744:	00050413          	mv	s0,a0
4000a748:	a24b0513          	addi	a0,s6,-1500
4000a74c:	d15ff0ef          	jal	ra,4000a460 <sys_slist_remove>
	if (sys_slist_is_empty(&arp_pending_entries)) {
4000a750:	a24b2783          	lw	a5,-1500(s6)
4000a754:	00079863          	bnez	a5,4000a764 <arp_update+0x134>
		k_work_cancel_delayable(&arp_request_timer);
4000a758:	40031537          	lui	a0,0x40031
4000a75c:	da850513          	addi	a0,a0,-600 # 40030da8 <arp_request_timer>
4000a760:	6dd1e0ef          	jal	ra,4002963c <k_work_cancel_delayable>
	memcpy(&entry->eth, hwaddr, sizeof(struct net_eth_addr));
4000a764:	00098593          	mv	a1,s3
4000a768:	00600613          	li	a2,6
4000a76c:	01040513          	addi	a0,s0,16
4000a770:	8ddfe0ef          	jal	ra,4000904c <memcpy>
	sys_slist_prepend(&arp_table, &entry->node);
4000a774:	40031537          	lui	a0,0x40031
4000a778:	00040593          	mv	a1,s0
4000a77c:	a1c50513          	addi	a0,a0,-1508 # 40030a1c <arp_table>
4000a780:	cc5ff0ef          	jal	ra,4000a444 <sys_slist_prepend>
		pkt = k_fifo_get(&entry->pending_queue, K_FOREVER);
4000a784:	01840493          	addi	s1,s0,24
		net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
4000a788:	00600993          	li	s3,6
	while (!k_fifo_is_empty(&entry->pending_queue)) {
4000a78c:	01842783          	lw	a5,24(s0)
4000a790:	f80780e3          	beqz	a5,4000a710 <arp_update+0xe0>
	return z_impl_k_queue_get(queue, timeout);
4000a794:	fff00593          	li	a1,-1
4000a798:	fff00613          	li	a2,-1
4000a79c:	00048513          	mv	a0,s1
4000a7a0:	4cc1e0ef          	jal	ra,40028c6c <z_impl_k_queue_get>
	return pkt->frags->data;
4000a7a4:	00852783          	lw	a5,8(a0)
		net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
4000a7a8:	03350823          	sb	s3,48(a0)
4000a7ac:	00050593          	mv	a1,a0
		net_pkt_lladdr_dst(pkt)->addr =
4000a7b0:	00c7a783          	lw	a5,12(a5)
4000a7b4:	02f52623          	sw	a5,44(a0)
		net_if_queue_tx(iface, pkt);
4000a7b8:	00090513          	mv	a0,s2
4000a7bc:	4c9040ef          	jal	ra,4000f484 <net_if_queue_tx>
4000a7c0:	fcdff06f          	j	4000a78c <arp_update+0x15c>
	return list->head;
4000a7c4:	40031537          	lui	a0,0x40031
4000a7c8:	a2c52403          	lw	s0,-1492(a0) # 40030a2c <arp_free_entries>
	if (!node) {
4000a7cc:	08040263          	beqz	s0,4000a850 <arp_update+0x220>
	sys_slist_remove(&arp_free_entries, NULL, node);
4000a7d0:	00040613          	mv	a2,s0
4000a7d4:	00000593          	li	a1,0
4000a7d8:	a2c50513          	addi	a0,a0,-1492
4000a7dc:	c85ff0ef          	jal	ra,4000a460 <sys_slist_remove>
					entry->req_start = k_uptime_get_32();
4000a7e0:	cb5ff0ef          	jal	ra,4000a494 <k_uptime_get_32>
4000a7e4:	00a42223          	sw	a0,4(s0)
					entry->iface = iface;
4000a7e8:	01242423          	sw	s2,8(s0)
					net_ipaddr_copy(&entry->ip, src);
4000a7ec:	0014c783          	lbu	a5,1(s1)
4000a7f0:	0004c703          	lbu	a4,0(s1)
					memcpy(&entry->eth, hwaddr, sizeof(entry->eth));
4000a7f4:	00098593          	mv	a1,s3
					net_ipaddr_copy(&entry->ip, src);
4000a7f8:	00879793          	slli	a5,a5,0x8
4000a7fc:	00e7e7b3          	or	a5,a5,a4
4000a800:	0024c703          	lbu	a4,2(s1)
					memcpy(&entry->eth, hwaddr, sizeof(entry->eth));
4000a804:	00600613          	li	a2,6
4000a808:	01040513          	addi	a0,s0,16
					net_ipaddr_copy(&entry->ip, src);
4000a80c:	01071713          	slli	a4,a4,0x10
4000a810:	00f76733          	or	a4,a4,a5
4000a814:	0034c783          	lbu	a5,3(s1)
4000a818:	00e40623          	sb	a4,12(s0)
4000a81c:	01879793          	slli	a5,a5,0x18
4000a820:	00e7e7b3          	or	a5,a5,a4
4000a824:	0087d713          	srli	a4,a5,0x8
4000a828:	00e406a3          	sb	a4,13(s0)
4000a82c:	0107d713          	srli	a4,a5,0x10
4000a830:	0187d793          	srli	a5,a5,0x18
4000a834:	00e40723          	sb	a4,14(s0)
4000a838:	00f407a3          	sb	a5,15(s0)
					memcpy(&entry->eth, hwaddr, sizeof(entry->eth));
4000a83c:	811fe0ef          	jal	ra,4000904c <memcpy>
					sys_slist_prepend(&arp_table, &entry->node);
4000a840:	00040593          	mv	a1,s0
4000a844:	a1ca0513          	addi	a0,s4,-1508
4000a848:	bfdff0ef          	jal	ra,4000a444 <sys_slist_prepend>
4000a84c:	ec5ff06f          	j	4000a710 <arp_update+0xe0>
					entry = arp_entry_get_last_from_table();
4000a850:	c65ff0ef          	jal	ra,4000a4b4 <arp_entry_get_last_from_table>
4000a854:	00050413          	mv	s0,a0
				if (entry) {
4000a858:	f80514e3          	bnez	a0,4000a7e0 <arp_update+0x1b0>
4000a85c:	eb5ff06f          	j	4000a710 <arp_update+0xe0>

4000a860 <arp_entry_cleanup>:
{
4000a860:	ff010113          	addi	sp,sp,-16
4000a864:	00812423          	sw	s0,8(sp)
4000a868:	00912223          	sw	s1,4(sp)
4000a86c:	00112623          	sw	ra,12(sp)
4000a870:	00050413          	mv	s0,a0
			pkt = k_fifo_get(&entry->pending_queue, K_FOREVER);
4000a874:	01850493          	addi	s1,a0,24
	if (pending) {
4000a878:	04059663          	bnez	a1,4000a8c4 <arp_entry_cleanup+0x64>
	entry->iface = NULL;
4000a87c:	00042423          	sw	zero,8(s0)
	(void)memset(&entry->ip, 0, sizeof(struct in_addr));
4000a880:	00400613          	li	a2,4
4000a884:	00000593          	li	a1,0
4000a888:	00c40513          	addi	a0,s0,12
4000a88c:	fe4fe0ef          	jal	ra,40009070 <memset>
	(void)memset(&entry->eth, 0, sizeof(struct net_eth_addr));
4000a890:	01040513          	addi	a0,s0,16
}
4000a894:	00812403          	lw	s0,8(sp)
4000a898:	00c12083          	lw	ra,12(sp)
4000a89c:	00412483          	lw	s1,4(sp)
	(void)memset(&entry->eth, 0, sizeof(struct net_eth_addr));
4000a8a0:	00600613          	li	a2,6
4000a8a4:	00000593          	li	a1,0
}
4000a8a8:	01010113          	addi	sp,sp,16
	(void)memset(&entry->eth, 0, sizeof(struct net_eth_addr));
4000a8ac:	fc4fe06f          	j	40009070 <memset>
4000a8b0:	fff00593          	li	a1,-1
4000a8b4:	fff00613          	li	a2,-1
4000a8b8:	00048513          	mv	a0,s1
4000a8bc:	3b01e0ef          	jal	ra,40028c6c <z_impl_k_queue_get>
			net_pkt_unref(pkt);
4000a8c0:	65c080ef          	jal	ra,40012f1c <net_pkt_unref>
		while (!k_fifo_is_empty(&entry->pending_queue)) {
4000a8c4:	01842783          	lw	a5,24(s0)
4000a8c8:	fe0794e3          	bnez	a5,4000a8b0 <arp_entry_cleanup+0x50>
4000a8cc:	fb1ff06f          	j	4000a87c <arp_entry_cleanup+0x1c>

4000a8d0 <arp_request_timeout>:
{
4000a8d0:	fe010113          	addi	sp,sp,-32
4000a8d4:	00112e23          	sw	ra,28(sp)
4000a8d8:	00812c23          	sw	s0,24(sp)
4000a8dc:	00912a23          	sw	s1,20(sp)
4000a8e0:	01212823          	sw	s2,16(sp)
4000a8e4:	01412423          	sw	s4,8(sp)
4000a8e8:	01312623          	sw	s3,12(sp)
	uint32_t current = k_uptime_get_32();
4000a8ec:	ba9ff0ef          	jal	ra,4000a494 <k_uptime_get_32>
4000a8f0:	00050493          	mv	s1,a0
	k_mutex_lock(&arp_mutex, K_FOREVER);
4000a8f4:	fff00593          	li	a1,-1
4000a8f8:	fff00513          	li	a0,-1
4000a8fc:	40031a37          	lui	s4,0x40031
4000a900:	c0dff0ef          	jal	ra,4000a50c <k_mutex_lock.constprop.0.isra.0>
4000a904:	a24a2403          	lw	s0,-1500(s4) # 40030a24 <arp_pending_entries>
4000a908:	00000913          	li	s2,0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
4000a90c:	00040463          	beqz	s0,4000a914 <arp_request_timeout+0x44>
	return node->next;
4000a910:	00042903          	lw	s2,0(s0)
			    ARP_REQUEST_TIMEOUT - current) > 0) {
4000a914:	7d000993          	li	s3,2000
4000a918:	409989b3          	sub	s3,s3,s1
	return list->tail;
4000a91c:	400314b7          	lui	s1,0x40031
4000a920:	a2c48493          	addi	s1,s1,-1492 # 40030a2c <arp_free_entries>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
4000a924:	02041263          	bnez	s0,4000a948 <arp_request_timeout+0x78>
}
4000a928:	01812403          	lw	s0,24(sp)
4000a92c:	01c12083          	lw	ra,28(sp)
4000a930:	01412483          	lw	s1,20(sp)
4000a934:	01012903          	lw	s2,16(sp)
4000a938:	00c12983          	lw	s3,12(sp)
4000a93c:	00812a03          	lw	s4,8(sp)
4000a940:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&arp_mutex);
4000a944:	bddff06f          	j	4000a520 <k_mutex_unlock.constprop.0.isra.0>
			    ARP_REQUEST_TIMEOUT - current) > 0) {
4000a948:	00442583          	lw	a1,4(s0)
4000a94c:	00b985b3          	add	a1,s3,a1
		if ((int32_t)(entry->req_start +
4000a950:	04b04c63          	bgtz	a1,4000a9a8 <arp_request_timeout+0xd8>
		arp_entry_cleanup(entry, true);
4000a954:	00100593          	li	a1,1
4000a958:	00040513          	mv	a0,s0
4000a95c:	f05ff0ef          	jal	ra,4000a860 <arp_entry_cleanup>
		sys_slist_remove(&arp_pending_entries, NULL, &entry->node);
4000a960:	00040613          	mv	a2,s0
4000a964:	00000593          	li	a1,0
4000a968:	a24a0513          	addi	a0,s4,-1500
4000a96c:	af5ff0ef          	jal	ra,4000a460 <sys_slist_remove>
	parent->next = child;
4000a970:	00042023          	sw	zero,0(s0)
	return list->tail;
4000a974:	0044a783          	lw	a5,4(s1)
Z_GENLIST_APPEND(slist, snode)
4000a978:	02079263          	bnez	a5,4000a99c <arp_request_timeout+0xcc>
	list->tail = node;
4000a97c:	0084a223          	sw	s0,4(s1)
	list->head = node;
4000a980:	0084a023          	sw	s0,0(s1)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
4000a984:	00000793          	li	a5,0
4000a988:	00090463          	beqz	s2,4000a990 <arp_request_timeout+0xc0>
	return node->next;
4000a98c:	00092783          	lw	a5,0(s2)
4000a990:	00090413          	mv	s0,s2
4000a994:	00078913          	mv	s2,a5
4000a998:	f8dff06f          	j	4000a924 <arp_request_timeout+0x54>
	parent->next = child;
4000a99c:	0087a023          	sw	s0,0(a5)
	list->tail = node;
4000a9a0:	0084a223          	sw	s0,4(s1)
}
4000a9a4:	fe1ff06f          	j	4000a984 <arp_request_timeout+0xb4>
		t += off;
4000a9a8:	00958513          	addi	a0,a1,9
			return t / ((uint64_t)from_hz / to_hz);
4000a9ac:	00a00613          	li	a2,10
4000a9b0:	00000693          	li	a3,0
4000a9b4:	00b535b3          	sltu	a1,a0,a1
4000a9b8:	901f50ef          	jal	ra,400002b8 <__udivdi3>
		k_work_reschedule(&arp_request_timer,
4000a9bc:	00058613          	mv	a2,a1
4000a9c0:	00050593          	mv	a1,a0
4000a9c4:	40031537          	lui	a0,0x40031
4000a9c8:	da850513          	addi	a0,a0,-600 # 40030da8 <arp_request_timer>
4000a9cc:	4591e0ef          	jal	ra,40029624 <k_work_reschedule>
4000a9d0:	f59ff06f          	j	4000a928 <arp_request_timeout+0x58>

4000a9d4 <net_arp_prepare>:
{
4000a9d4:	fb010113          	addi	sp,sp,-80
4000a9d8:	04112623          	sw	ra,76(sp)
4000a9dc:	04812423          	sw	s0,72(sp)
4000a9e0:	04912223          	sw	s1,68(sp)
4000a9e4:	05212023          	sw	s2,64(sp)
4000a9e8:	03312e23          	sw	s3,60(sp)
4000a9ec:	03412c23          	sw	s4,56(sp)
4000a9f0:	03512a23          	sw	s5,52(sp)
4000a9f4:	03612823          	sw	s6,48(sp)
4000a9f8:	03712623          	sw	s7,44(sp)
	if (!pkt || !pkt->buffer) {
4000a9fc:	02051c63          	bnez	a0,4000aa34 <net_arp_prepare+0x60>
		return NULL;
4000aa00:	00000993          	li	s3,0
}
4000aa04:	04c12083          	lw	ra,76(sp)
4000aa08:	04812403          	lw	s0,72(sp)
4000aa0c:	04412483          	lw	s1,68(sp)
4000aa10:	04012903          	lw	s2,64(sp)
4000aa14:	03812a03          	lw	s4,56(sp)
4000aa18:	03412a83          	lw	s5,52(sp)
4000aa1c:	03012b03          	lw	s6,48(sp)
4000aa20:	02c12b83          	lw	s7,44(sp)
4000aa24:	00098513          	mv	a0,s3
4000aa28:	03c12983          	lw	s3,60(sp)
4000aa2c:	05010113          	addi	sp,sp,80
4000aa30:	00008067          	ret
	if (!pkt || !pkt->buffer) {
4000aa34:	00852783          	lw	a5,8(a0)
4000aa38:	00050913          	mv	s2,a0
4000aa3c:	fc0782e3          	beqz	a5,4000aa00 <net_arp_prepare+0x2c>
4000aa40:	00058a13          	mv	s4,a1
4000aa44:	00060a93          	mv	s5,a2
	if (!current_ip && !is_ipv4_ll_used &&
4000aa48:	04061663          	bnez	a2,4000aa94 <net_arp_prepare+0xc0>
	    !net_if_ipv4_addr_mask_cmp(net_pkt_iface(pkt), request_ip)) {
4000aa4c:	01852503          	lw	a0,24(a0)
4000aa50:	05c040ef          	jal	ra,4000eaac <net_if_ipv4_addr_mask_cmp>
	if (!current_ip && !is_ipv4_ll_used &&
4000aa54:	04051063          	bnez	a0,4000aa94 <net_arp_prepare+0xc0>
		struct net_if_ipv4 *ipv4 = net_pkt_iface(pkt)->config.ip.ipv4;
4000aa58:	01892783          	lw	a5,24(s2)
4000aa5c:	0087a783          	lw	a5,8(a5)
		if (ipv4) {
4000aa60:	02078a63          	beqz	a5,4000aa94 <net_arp_prepare+0xc0>
	return UNALIGNED_GET(&addr->s_addr) == 0;
4000aa64:	0497c683          	lbu	a3,73(a5)
4000aa68:	0487c703          	lbu	a4,72(a5)
			addr = &ipv4->gw;
4000aa6c:	04878a13          	addi	s4,a5,72
4000aa70:	00869693          	slli	a3,a3,0x8
4000aa74:	00e6e6b3          	or	a3,a3,a4
4000aa78:	04a7c703          	lbu	a4,74(a5)
4000aa7c:	04b7c783          	lbu	a5,75(a5)
4000aa80:	01071713          	slli	a4,a4,0x10
4000aa84:	00d76733          	or	a4,a4,a3
4000aa88:	01879793          	slli	a5,a5,0x18
4000aa8c:	00e7e7b3          	or	a5,a5,a4
			if (net_ipv4_is_addr_unspecified(addr)) {
4000aa90:	f60788e3          	beqz	a5,4000aa00 <net_arp_prepare+0x2c>
	k_mutex_lock(&arp_mutex, K_FOREVER);
4000aa94:	fff00513          	li	a0,-1
4000aa98:	fff00593          	li	a1,-1
4000aa9c:	400314b7          	lui	s1,0x40031
4000aaa0:	a6dff0ef          	jal	ra,4000a50c <k_mutex_lock.constprop.0.isra.0>
	return pkt->iface;
4000aaa4:	a1c4a983          	lw	s3,-1508(s1) # 40030a1c <arp_table>
4000aaa8:	01892583          	lw	a1,24(s2)
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
4000aaac:	01c10693          	addi	a3,sp,28
4000aab0:	000a0613          	mv	a2,s4
4000aab4:	00098513          	mv	a0,s3
4000aab8:	00b12623          	sw	a1,12(sp)
	sys_snode_t *prev = NULL;
4000aabc:	00012e23          	sw	zero,28(sp)
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
4000aac0:	afdff0ef          	jal	ra,4000a5bc <arp_entry_find.isra.0>
	if (entry) {
4000aac4:	00c12583          	lw	a1,12(sp)
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
4000aac8:	00050413          	mv	s0,a0
	if (entry) {
4000aacc:	22051e63          	bnez	a0,4000ad08 <net_arp_prepare+0x334>
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
4000aad0:	40031b37          	lui	s6,0x40031
4000aad4:	a24b2503          	lw	a0,-1500(s6) # 40030a24 <arp_pending_entries>
4000aad8:	00000693          	li	a3,0
4000aadc:	000a0613          	mv	a2,s4
4000aae0:	addff0ef          	jal	ra,4000a5bc <arp_entry_find.isra.0>
4000aae4:	00050493          	mv	s1,a0
		if (!entry) {
4000aae8:	26051e63          	bnez	a0,4000ad64 <net_arp_prepare+0x390>
	return list->head;
4000aaec:	40031537          	lui	a0,0x40031
4000aaf0:	a2c52403          	lw	s0,-1492(a0) # 40030a2c <arp_free_entries>
	if (!node) {
4000aaf4:	26040263          	beqz	s0,4000ad58 <net_arp_prepare+0x384>
	sys_slist_remove(&arp_free_entries, NULL, node);
4000aaf8:	00040613          	mv	a2,s0
4000aafc:	00000593          	li	a1,0
4000ab00:	a2c50513          	addi	a0,a0,-1492
4000ab04:	95dff0ef          	jal	ra,4000a460 <sys_slist_remove>
4000ab08:	01892b83          	lw	s7,24(s2)
	if (current_ip) {
4000ab0c:	00090993          	mv	s3,s2
4000ab10:	020a9463          	bnez	s5,4000ab38 <net_arp_prepare+0x164>
		pkt = net_pkt_alloc_with_buffer(iface,
4000ab14:	00a00713          	li	a4,10
4000ab18:	00000793          	li	a5,0
4000ab1c:	00000693          	li	a3,0
4000ab20:	00000613          	li	a2,0
4000ab24:	01c00593          	li	a1,28
4000ab28:	000b8513          	mv	a0,s7
4000ab2c:	3f1080ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
4000ab30:	00050993          	mv	s3,a0
		if (!pkt) {
4000ab34:	1c050663          	beqz	a0,4000ad00 <net_arp_prepare+0x32c>
	return net_buf_simple_add(&buf->b, len);
4000ab38:	0089a503          	lw	a0,8(s3)
4000ab3c:	01c00593          	li	a1,28
4000ab40:	00c50513          	addi	a0,a0,12
4000ab44:	fd9fe0ef          	jal	ra,40009b1c <net_buf_simple_add>
	return pkt->frags->data;
4000ab48:	0089a783          	lw	a5,8(s3)
4000ab4c:	00c7a483          	lw	s1,12(a5)
	if (entry) {
4000ab50:	24040063          	beqz	s0,4000ad90 <net_arp_prepare+0x3bc>
			k_fifo_put(&entry->pending_queue, net_pkt_ref(pending));
4000ab54:	00090513          	mv	a0,s2
4000ab58:	35c080ef          	jal	ra,40012eb4 <net_pkt_ref>
4000ab5c:	00050593          	mv	a1,a0
4000ab60:	01840513          	addi	a0,s0,24
4000ab64:	0e01e0ef          	jal	ra,40028c44 <k_queue_append>
	return pkt->iface;
4000ab68:	0189a683          	lw	a3,24(s3)
		entry->iface = net_pkt_iface(pkt);
4000ab6c:	00d42423          	sw	a3,8(s0)
		net_ipaddr_copy(&entry->ip, next_addr);
4000ab70:	001a4783          	lbu	a5,1(s4)
4000ab74:	000a4703          	lbu	a4,0(s4)
4000ab78:	00879793          	slli	a5,a5,0x8
4000ab7c:	00e7e7b3          	or	a5,a5,a4
4000ab80:	002a4703          	lbu	a4,2(s4)
4000ab84:	01071713          	slli	a4,a4,0x10
4000ab88:	00f76733          	or	a4,a4,a5
4000ab8c:	003a4783          	lbu	a5,3(s4)
4000ab90:	00e40623          	sb	a4,12(s0)
4000ab94:	01879793          	slli	a5,a5,0x18
4000ab98:	00e7e7b3          	or	a5,a5,a4
4000ab9c:	0087d713          	srli	a4,a5,0x8
4000aba0:	00e406a3          	sb	a4,13(s0)
4000aba4:	0107d713          	srli	a4,a5,0x10
4000aba8:	0187d793          	srli	a5,a5,0x18
4000abac:	00e40723          	sb	a4,14(s0)
4000abb0:	00f407a3          	sb	a5,15(s0)
			(uint8_t *)net_if_get_link_addr(entry->iface)->addr;
4000abb4:	0006a783          	lw	a5,0(a3)
4000abb8:	0107a783          	lw	a5,16(a5)
		net_pkt_lladdr_src(pkt)->addr =
4000abbc:	02f9a223          	sw	a5,36(s3)
	parent->next = child;
4000abc0:	00042023          	sw	zero,0(s0)
	return list->tail;
4000abc4:	a24b0793          	addi	a5,s6,-1500
4000abc8:	0047a703          	lw	a4,4(a5)
Z_GENLIST_APPEND(slist, snode)
4000abcc:	1a071c63          	bnez	a4,4000ad84 <net_arp_prepare+0x3b0>
	list->tail = node;
4000abd0:	0087a223          	sw	s0,4(a5)
	list->head = node;
4000abd4:	0087a023          	sw	s0,0(a5)
	entry->req_start = k_uptime_get_32();
4000abd8:	8bdff0ef          	jal	ra,4000a494 <k_uptime_get_32>
4000abdc:	00a42223          	sw	a0,4(s0)
	return z_timeout_remaining(&dwork->timeout);
4000abe0:	40031537          	lui	a0,0x40031
4000abe4:	db850513          	addi	a0,a0,-584 # 40030db8 <arp_request_timer+0x10>
4000abe8:	6011f0ef          	jal	ra,4002a9e8 <z_timeout_remaining>
	if (!k_work_delayable_remaining_get(&arp_request_timer)) {
4000abec:	00b56533          	or	a0,a0,a1
4000abf0:	00051c63          	bnez	a0,4000ac08 <net_arp_prepare+0x234>
		k_work_reschedule(&arp_request_timer,
4000abf4:	40031537          	lui	a0,0x40031
4000abf8:	0c800593          	li	a1,200
4000abfc:	00000613          	li	a2,0
4000ac00:	da850513          	addi	a0,a0,-600 # 40030da8 <arp_request_timer>
4000ac04:	2211e0ef          	jal	ra,40029624 <k_work_reschedule>
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
4000ac08:	00600b13          	li	s6,6
4000ac0c:	03698423          	sb	s6,40(s3)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)net_eth_broadcast_addr();
4000ac10:	c34ff0ef          	jal	ra,4000a044 <net_eth_broadcast_addr>
4000ac14:	02a9a623          	sw	a0,44(s3)
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
4000ac18:	03698823          	sb	s6,48(s3)
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
4000ac1c:	00800713          	li	a4,8
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
4000ac20:	00100793          	li	a5,1
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
4000ac24:	00e48123          	sb	a4,2(s1)
	hdr->protolen = sizeof(struct in_addr);
4000ac28:	00400713          	li	a4,4
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
4000ac2c:	00f480a3          	sb	a5,1(s1)
	hdr->protolen = sizeof(struct in_addr);
4000ac30:	00e482a3          	sb	a4,5(s1)
	hdr->opcode = htons(NET_ARP_REQUEST);
4000ac34:	00f483a3          	sb	a5,7(s1)
	(void)memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
4000ac38:	00600613          	li	a2,6
4000ac3c:	00000593          	li	a1,0
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
4000ac40:	00048023          	sb	zero,0(s1)
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
4000ac44:	000481a3          	sb	zero,3(s1)
	hdr->hwlen = sizeof(struct net_eth_addr);
4000ac48:	01648223          	sb	s6,4(s1)
	hdr->opcode = htons(NET_ARP_REQUEST);
4000ac4c:	00048323          	sb	zero,6(s1)
	(void)memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
4000ac50:	01248513          	addi	a0,s1,18
4000ac54:	c1cfe0ef          	jal	ra,40009070 <memset>
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
4000ac58:	001a4783          	lbu	a5,1(s4)
4000ac5c:	000a4703          	lbu	a4,0(s4)
	memcpy(hdr->src_hwaddr.addr, net_pkt_lladdr_src(pkt)->addr,
4000ac60:	00600613          	li	a2,6
4000ac64:	00879793          	slli	a5,a5,0x8
4000ac68:	00e7e7b3          	or	a5,a5,a4
4000ac6c:	002a4703          	lbu	a4,2(s4)
4000ac70:	00848513          	addi	a0,s1,8
4000ac74:	01071713          	slli	a4,a4,0x10
4000ac78:	00f76733          	or	a4,a4,a5
4000ac7c:	003a4783          	lbu	a5,3(s4)
4000ac80:	00e48c23          	sb	a4,24(s1)
4000ac84:	01879793          	slli	a5,a5,0x18
4000ac88:	00e7e7b3          	or	a5,a5,a4
4000ac8c:	0087d713          	srli	a4,a5,0x8
4000ac90:	00e48ca3          	sb	a4,25(s1)
4000ac94:	0107d713          	srli	a4,a5,0x10
4000ac98:	0187d793          	srli	a5,a5,0x18
4000ac9c:	00e48d23          	sb	a4,26(s1)
4000aca0:	00f48da3          	sb	a5,27(s1)
4000aca4:	0249a583          	lw	a1,36(s3)
4000aca8:	ba4fe0ef          	jal	ra,4000904c <memcpy>
	} else if (!entry) {
4000acac:	0e041a63          	bnez	s0,4000ada0 <net_arp_prepare+0x3cc>
	return pkt->frags->data;
4000acb0:	00892783          	lw	a5,8(s2)
		my_addr = (struct in_addr *)NET_IPV4_HDR(pending)->src;
4000acb4:	00c7a503          	lw	a0,12(a5)
4000acb8:	00c50513          	addi	a0,a0,12
4000acbc:	00154783          	lbu	a5,1(a0)
4000acc0:	00054703          	lbu	a4,0(a0)
4000acc4:	00879793          	slli	a5,a5,0x8
4000acc8:	00e7e7b3          	or	a5,a5,a4
4000accc:	00254703          	lbu	a4,2(a0)
4000acd0:	01071713          	slli	a4,a4,0x10
4000acd4:	00f76733          	or	a4,a4,a5
4000acd8:	00354783          	lbu	a5,3(a0)
4000acdc:	00e48723          	sb	a4,14(s1)
4000ace0:	01879793          	slli	a5,a5,0x18
4000ace4:	00e7e7b3          	or	a5,a5,a4
4000ace8:	0087d713          	srli	a4,a5,0x8
4000acec:	00e487a3          	sb	a4,15(s1)
4000acf0:	0107d713          	srli	a4,a5,0x10
4000acf4:	0187d793          	srli	a5,a5,0x18
4000acf8:	00e48823          	sb	a4,16(s1)
4000acfc:	00f488a3          	sb	a5,17(s1)
		k_mutex_unlock(&arp_mutex);
4000ad00:	821ff0ef          	jal	ra,4000a520 <k_mutex_unlock.constprop.0.isra.0>
		return req;
4000ad04:	d01ff06f          	j	4000aa04 <net_arp_prepare+0x30>
		if (&entry->node != sys_slist_peek_head(&arp_table)) {
4000ad08:	03350063          	beq	a0,s3,4000ad28 <net_arp_prepare+0x354>
			sys_slist_remove(&arp_table, prev, &entry->node);
4000ad0c:	01c12583          	lw	a1,28(sp)
4000ad10:	00050613          	mv	a2,a0
4000ad14:	a1c48513          	addi	a0,s1,-1508
4000ad18:	f48ff0ef          	jal	ra,4000a460 <sys_slist_remove>
			sys_slist_prepend(&arp_table, &entry->node);
4000ad1c:	00040593          	mv	a1,s0
4000ad20:	a1c48513          	addi	a0,s1,-1508
4000ad24:	f20ff0ef          	jal	ra,4000a444 <sys_slist_prepend>
	k_mutex_unlock(&arp_mutex);
4000ad28:	ff8ff0ef          	jal	ra,4000a520 <k_mutex_unlock.constprop.0.isra.0>
	return &iface->if_dev->link_addr;
4000ad2c:	00842783          	lw	a5,8(s0)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)&entry->eth;
4000ad30:	01040413          	addi	s0,s0,16
	return pkt;
4000ad34:	00090993          	mv	s3,s2
		(uint8_t *)net_if_get_link_addr(entry->iface)->addr;
4000ad38:	0007a783          	lw	a5,0(a5)
4000ad3c:	0107a783          	lw	a5,16(a5)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)&entry->eth;
4000ad40:	02892623          	sw	s0,44(s2)
	net_pkt_lladdr_src(pkt)->addr =
4000ad44:	02f92223          	sw	a5,36(s2)
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
4000ad48:	00600793          	li	a5,6
4000ad4c:	02f90423          	sb	a5,40(s2)
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
4000ad50:	02f90823          	sb	a5,48(s2)
	return pkt;
4000ad54:	cb1ff06f          	j	4000aa04 <net_arp_prepare+0x30>
				entry = arp_entry_get_last_from_table();
4000ad58:	f5cff0ef          	jal	ra,4000a4b4 <arp_entry_get_last_from_table>
4000ad5c:	00050413          	mv	s0,a0
4000ad60:	da9ff06f          	j	4000ab08 <net_arp_prepare+0x134>
						  net_pkt_ref(pkt))) {
4000ad64:	00090513          	mv	a0,s2
4000ad68:	14c080ef          	jal	ra,40012eb4 <net_pkt_ref>
4000ad6c:	00050593          	mv	a1,a0
			    k_queue_unique_append(&entry->pending_queue._queue,
4000ad70:	01848513          	addi	a0,s1,24
4000ad74:	7911d0ef          	jal	ra,40028d04 <k_queue_unique_append>
			if (!net_pkt_ipv4_auto(pkt) &&
4000ad78:	d80508e3          	beqz	a0,4000ab08 <net_arp_prepare+0x134>
				k_mutex_unlock(&arp_mutex);
4000ad7c:	fa4ff0ef          	jal	ra,4000a520 <k_mutex_unlock.constprop.0.isra.0>
				return NULL;
4000ad80:	c81ff06f          	j	4000aa00 <net_arp_prepare+0x2c>
	parent->next = child;
4000ad84:	00872023          	sw	s0,0(a4)
	list->tail = node;
4000ad88:	0087a223          	sw	s0,4(a5)
}
4000ad8c:	e4dff06f          	j	4000abd8 <net_arp_prepare+0x204>
			(uint8_t *)net_if_get_link_addr(iface)->addr;
4000ad90:	000ba783          	lw	a5,0(s7)
4000ad94:	0107a783          	lw	a5,16(a5)
		net_pkt_lladdr_src(pkt)->addr =
4000ad98:	02f9a223          	sw	a5,36(s3)
4000ad9c:	e6dff06f          	j	4000ac08 <net_arp_prepare+0x234>
		my_addr = if_get_addr(entry->iface, current_ip);
4000ada0:	00842783          	lw	a5,8(s0)
4000ada4:	000a8593          	mv	a1,s5
4000ada8:	0087a503          	lw	a0,8(a5)
4000adac:	f80ff0ef          	jal	ra,4000a52c <if_get_addr.isra.0>
	if (my_addr) {
4000adb0:	f00516e3          	bnez	a0,4000acbc <net_arp_prepare+0x2e8>
		(void)memset(&hdr->src_ipaddr, 0, sizeof(struct in_addr));
4000adb4:	00400613          	li	a2,4
4000adb8:	00000593          	li	a1,0
4000adbc:	00e48513          	addi	a0,s1,14
4000adc0:	ab0fe0ef          	jal	ra,40009070 <memset>
4000adc4:	f3dff06f          	j	4000ad00 <net_arp_prepare+0x32c>

4000adc8 <net_arp_input>:
	return true;
}

enum net_verdict net_arp_input(struct net_pkt *pkt,
			       struct net_eth_hdr *eth_hdr)
{
4000adc8:	fc010113          	addi	sp,sp,-64
4000adcc:	02912a23          	sw	s1,52(sp)
4000add0:	03212823          	sw	s2,48(sp)
4000add4:	02112e23          	sw	ra,60(sp)
4000add8:	02812c23          	sw	s0,56(sp)
4000addc:	03312623          	sw	s3,44(sp)
4000ade0:	03412423          	sw	s4,40(sp)
4000ade4:	03512223          	sw	s5,36(sp)
4000ade8:	03612023          	sw	s6,32(sp)
4000adec:	01712e23          	sw	s7,28(sp)
4000adf0:	00852683          	lw	a3,8(a0)
4000adf4:	00050493          	mv	s1,a0
4000adf8:	00058913          	mv	s2,a1
4000adfc:	00068793          	mv	a5,a3
	size_t bytes = 0;
4000ae00:	00000713          	li	a4,0
	while (buf) {
4000ae04:	04079263          	bnez	a5,4000ae48 <net_arp_input+0x80>
4000ae08:	00c6a403          	lw	s0,12(a3)
	struct net_eth_addr *dst_hw_addr;
	struct net_arp_hdr *arp_hdr;
	struct net_pkt *reply;
	struct in_addr *addr;

	if (net_pkt_get_len(pkt) < (sizeof(struct net_arp_hdr) -
4000ae0c:	408907b3          	sub	a5,s2,s0
4000ae10:	01c78793          	addi	a5,a5,28
4000ae14:	04f77263          	bgeu	a4,a5,4000ae58 <net_arp_input+0x90>
				    (net_pkt_ip_data(pkt) - (uint8_t *)eth_hdr))) {
		NET_DBG("Invalid ARP header (len %zu, min %zu bytes) %p",
			net_pkt_get_len(pkt), sizeof(struct net_arp_hdr) -
			(net_pkt_ip_data(pkt) - (uint8_t *)eth_hdr), pkt);
		return NET_DROP;
4000ae18:	00200513          	li	a0,2
	}

	net_pkt_unref(pkt);

	return NET_OK;
}
4000ae1c:	03c12083          	lw	ra,60(sp)
4000ae20:	03812403          	lw	s0,56(sp)
4000ae24:	03412483          	lw	s1,52(sp)
4000ae28:	03012903          	lw	s2,48(sp)
4000ae2c:	02c12983          	lw	s3,44(sp)
4000ae30:	02812a03          	lw	s4,40(sp)
4000ae34:	02412a83          	lw	s5,36(sp)
4000ae38:	02012b03          	lw	s6,32(sp)
4000ae3c:	01c12b83          	lw	s7,28(sp)
4000ae40:	04010113          	addi	sp,sp,64
4000ae44:	00008067          	ret
		bytes += buf->len;
4000ae48:	0107d603          	lhu	a2,16(a5)
		buf = buf->frags;
4000ae4c:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4000ae50:	00c70733          	add	a4,a4,a2
		buf = buf->frags;
4000ae54:	fb1ff06f          	j	4000ae04 <net_arp_input+0x3c>
	if (ntohs(arp_hdr->hwtype) != NET_ARP_HTYPE_ETH ||
4000ae58:	00144703          	lbu	a4,1(s0)
4000ae5c:	00044783          	lbu	a5,0(s0)
4000ae60:	00871713          	slli	a4,a4,0x8
4000ae64:	00f76733          	or	a4,a4,a5
4000ae68:	10000793          	li	a5,256
4000ae6c:	faf716e3          	bne	a4,a5,4000ae18 <net_arp_input+0x50>
4000ae70:	00344783          	lbu	a5,3(s0)
4000ae74:	00244683          	lbu	a3,2(s0)
4000ae78:	00879793          	slli	a5,a5,0x8
4000ae7c:	00d7e7b3          	or	a5,a5,a3
4000ae80:	00800693          	li	a3,8
4000ae84:	f8d79ae3          	bne	a5,a3,4000ae18 <net_arp_input+0x50>
	    ntohs(arp_hdr->protocol) != NET_ETH_PTYPE_IP ||
4000ae88:	00444683          	lbu	a3,4(s0)
4000ae8c:	00600793          	li	a5,6
4000ae90:	f8f694e3          	bne	a3,a5,4000ae18 <net_arp_input+0x50>
	    arp_hdr->hwlen != sizeof(struct net_eth_addr) ||
4000ae94:	00544683          	lbu	a3,5(s0)
4000ae98:	00400793          	li	a5,4
4000ae9c:	f6f69ee3          	bne	a3,a5,4000ae18 <net_arp_input+0x50>
	    arp_hdr->protolen != NET_ARP_IPV4_PTYPE_SIZE ||
4000aea0:	00e44683          	lbu	a3,14(s0)
4000aea4:	07f00793          	li	a5,127
4000aea8:	f6f688e3          	beq	a3,a5,4000ae18 <net_arp_input+0x50>
	switch (ntohs(arp_hdr->opcode)) {
4000aeac:	00744783          	lbu	a5,7(s0)
4000aeb0:	00644683          	lbu	a3,6(s0)
4000aeb4:	00879793          	slli	a5,a5,0x8
4000aeb8:	00d7e7b3          	or	a5,a5,a3
4000aebc:	00e78e63          	beq	a5,a4,4000aed8 <net_arp_input+0x110>
4000aec0:	20000713          	li	a4,512
4000aec4:	28e78063          	beq	a5,a4,4000b144 <net_arp_input+0x37c>
	net_pkt_unref(pkt);
4000aec8:	00048513          	mv	a0,s1
4000aecc:	050080ef          	jal	ra,40012f1c <net_pkt_unref>
	return NET_OK;
4000aed0:	00000513          	li	a0,0
4000aed4:	f49ff06f          	j	4000ae1c <net_arp_input+0x54>
4000aed8:	0184a783          	lw	a5,24(s1)
		if (memcmp(&arp_hdr->src_hwaddr,
4000aedc:	00840b93          	addi	s7,s0,8
4000aee0:	00600613          	li	a2,6
			   net_if_get_link_addr(net_pkt_iface(pkt))->addr,
4000aee4:	0007a783          	lw	a5,0(a5)
		if (memcmp(&arp_hdr->src_hwaddr,
4000aee8:	000b8513          	mv	a0,s7
4000aeec:	0107a583          	lw	a1,16(a5)
4000aef0:	8dcfe0ef          	jal	ra,40008fcc <memcmp>
4000aef4:	f20502e3          	beqz	a0,4000ae18 <net_arp_input+0x50>
				   net_eth_broadcast_addr(),
4000aef8:	94cff0ef          	jal	ra,4000a044 <net_eth_broadcast_addr>
4000aefc:	00050593          	mv	a1,a0
			if (memcmp(&eth_hdr->dst,
4000af00:	00600613          	li	a2,6
4000af04:	00090513          	mv	a0,s2
4000af08:	8c4fe0ef          	jal	ra,40008fcc <memcmp>
4000af0c:	04051863          	bnez	a0,4000af5c <net_arp_input+0x194>
				   net_eth_broadcast_addr(),
4000af10:	934ff0ef          	jal	ra,4000a044 <net_eth_broadcast_addr>
4000af14:	00050593          	mv	a1,a0
			    memcmp(&arp_hdr->dst_hwaddr,
4000af18:	00600613          	li	a2,6
4000af1c:	01240513          	addi	a0,s0,18
4000af20:	8acfe0ef          	jal	ra,40008fcc <memcmp>
				   sizeof(struct net_eth_addr)) == 0 &&
4000af24:	02051c63          	bnez	a0,4000af5c <net_arp_input+0x194>
			    memcmp(&arp_hdr->dst_ipaddr, &arp_hdr->src_ipaddr,
4000af28:	00e40593          	addi	a1,s0,14
4000af2c:	00400613          	li	a2,4
4000af30:	01840513          	addi	a0,s0,24
4000af34:	00b12623          	sw	a1,12(sp)
4000af38:	894fe0ef          	jal	ra,40008fcc <memcmp>
				   sizeof(struct net_eth_addr)) == 0 &&
4000af3c:	00c12583          	lw	a1,12(sp)
4000af40:	00051e63          	bnez	a0,4000af5c <net_arp_input+0x194>
				arp_update(net_pkt_iface(pkt),
4000af44:	00000713          	li	a4,0
4000af48:	00100693          	li	a3,1
4000af4c:	000b8613          	mv	a2,s7
			arp_update(net_pkt_iface(pkt),
4000af50:	0184a503          	lw	a0,24(s1)
4000af54:	edcff0ef          	jal	ra,4000a630 <arp_update>
4000af58:	f71ff06f          	j	4000aec8 <net_arp_input+0x100>
		if (memcmp(&eth_hdr->dst, net_eth_broadcast_addr(),
4000af5c:	8e8ff0ef          	jal	ra,4000a044 <net_eth_broadcast_addr>
4000af60:	00050593          	mv	a1,a0
4000af64:	00600613          	li	a2,6
4000af68:	00090513          	mv	a0,s2
4000af6c:	860fe0ef          	jal	ra,40008fcc <memcmp>
4000af70:	00051e63          	bnez	a0,4000af8c <net_arp_input+0x1c4>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
4000af74:	00e44783          	lbu	a5,14(s0)
4000af78:	f0000737          	lui	a4,0xf0000
4000af7c:	01879793          	slli	a5,a5,0x18
4000af80:	00e7f7b3          	and	a5,a5,a4
			   sizeof(struct net_eth_addr)) == 0 &&
4000af84:	e0000737          	lui	a4,0xe0000
4000af88:	e8e788e3          	beq	a5,a4,4000ae18 <net_arp_input+0x50>
	return pkt->iface;
4000af8c:	0184a983          	lw	s3,24(s1)
		addr = if_get_addr(net_pkt_iface(pkt),
4000af90:	01840593          	addi	a1,s0,24
4000af94:	0089a503          	lw	a0,8(s3)
4000af98:	d94ff0ef          	jal	ra,4000a52c <if_get_addr.isra.0>
		if (!addr) {
4000af9c:	e6050ee3          	beqz	a0,4000ae18 <net_arp_input+0x50>
	if (addr->addr[0] == 0x00 &&
4000afa0:	01244783          	lbu	a5,18(s0)
4000afa4:	18079c63          	bnez	a5,4000b13c <net_arp_input+0x374>
4000afa8:	01344783          	lbu	a5,19(s0)
4000afac:	18079863          	bnez	a5,4000b13c <net_arp_input+0x374>
	    addr->addr[1] == 0x00 &&
4000afb0:	01444783          	lbu	a5,20(s0)
4000afb4:	18079463          	bnez	a5,4000b13c <net_arp_input+0x374>
	    addr->addr[2] == 0x00 &&
4000afb8:	01544783          	lbu	a5,21(s0)
4000afbc:	18079063          	bnez	a5,4000b13c <net_arp_input+0x374>
	    addr->addr[3] == 0x00 &&
4000afc0:	01644783          	lbu	a5,22(s0)
4000afc4:	16079c63          	bnez	a5,4000b13c <net_arp_input+0x374>
	    addr->addr[4] == 0x00 &&
4000afc8:	01744783          	lbu	a5,23(s0)
4000afcc:	16079863          	bnez	a5,4000b13c <net_arp_input+0x374>
			arp_update(net_pkt_iface(pkt),
4000afd0:	00100713          	li	a4,1
4000afd4:	00000693          	li	a3,0
4000afd8:	000b8613          	mv	a2,s7
4000afdc:	00e40593          	addi	a1,s0,14
4000afe0:	00098513          	mv	a0,s3
4000afe4:	e4cff0ef          	jal	ra,4000a630 <arp_update>
4000afe8:	0184a983          	lw	s3,24(s1)
	pkt = net_pkt_alloc_with_buffer(iface, sizeof(struct net_arp_hdr),
4000afec:	00a00713          	li	a4,10
4000aff0:	00000793          	li	a5,0
4000aff4:	00000693          	li	a3,0
4000aff8:	00000613          	li	a2,0
4000affc:	01c00593          	li	a1,28
4000b000:	00098513          	mv	a0,s3
4000b004:	718080ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
4000b008:	00050913          	mv	s2,a0
	if (!pkt) {
4000b00c:	ea050ee3          	beqz	a0,4000aec8 <net_arp_input+0x100>
	return net_buf_simple_add(&buf->b, len);
4000b010:	00852503          	lw	a0,8(a0)
4000b014:	01c00593          	li	a1,28
	hdr->hwlen = sizeof(struct net_eth_addr);
4000b018:	00600a93          	li	s5,6
4000b01c:	00c50513          	addi	a0,a0,12
4000b020:	afdfe0ef          	jal	ra,40009b1c <net_buf_simple_add>
	return pkt->frags->data;
4000b024:	00892783          	lw	a5,8(s2)
	memcpy(&hdr->dst_hwaddr.addr, &dst_addr->addr,
4000b028:	000b8593          	mv	a1,s7
4000b02c:	00600613          	li	a2,6
4000b030:	00c7a403          	lw	s0,12(a5)
4000b034:	0084a783          	lw	a5,8(s1)
4000b038:	01240b13          	addi	s6,s0,18
4000b03c:	00c7aa03          	lw	s4,12(a5)
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
4000b040:	00100793          	li	a5,1
4000b044:	00f400a3          	sb	a5,1(s0)
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
4000b048:	00800793          	li	a5,8
4000b04c:	00f40123          	sb	a5,2(s0)
	hdr->protolen = sizeof(struct in_addr);
4000b050:	00400793          	li	a5,4
4000b054:	00f402a3          	sb	a5,5(s0)
	hdr->opcode = htons(NET_ARP_REPLY);
4000b058:	00200793          	li	a5,2
4000b05c:	00f403a3          	sb	a5,7(s0)
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
4000b060:	00040023          	sb	zero,0(s0)
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
4000b064:	000401a3          	sb	zero,3(s0)
	hdr->hwlen = sizeof(struct net_eth_addr);
4000b068:	01540223          	sb	s5,4(s0)
	hdr->opcode = htons(NET_ARP_REPLY);
4000b06c:	00040323          	sb	zero,6(s0)
	memcpy(&hdr->dst_hwaddr.addr, &dst_addr->addr,
4000b070:	000b0513          	mv	a0,s6
4000b074:	fd9fd0ef          	jal	ra,4000904c <memcpy>
	memcpy(&hdr->src_hwaddr.addr, net_if_get_link_addr(iface)->addr,
4000b078:	0009a783          	lw	a5,0(s3)
4000b07c:	00600613          	li	a2,6
4000b080:	00840513          	addi	a0,s0,8
4000b084:	0107a583          	lw	a1,16(a5)
4000b088:	fc5fd0ef          	jal	ra,4000904c <memcpy>
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
4000b08c:	00fa4783          	lbu	a5,15(s4)
4000b090:	00ea4703          	lbu	a4,14(s4)
			net_if_queue_tx(net_pkt_iface(reply), reply);
4000b094:	00090593          	mv	a1,s2
4000b098:	00879793          	slli	a5,a5,0x8
4000b09c:	00e7e7b3          	or	a5,a5,a4
4000b0a0:	010a4703          	lbu	a4,16(s4)
4000b0a4:	01071713          	slli	a4,a4,0x10
4000b0a8:	00f76733          	or	a4,a4,a5
4000b0ac:	011a4783          	lbu	a5,17(s4)
4000b0b0:	00e40c23          	sb	a4,24(s0)
4000b0b4:	01879793          	slli	a5,a5,0x18
4000b0b8:	00e7e7b3          	or	a5,a5,a4
4000b0bc:	0087d713          	srli	a4,a5,0x8
4000b0c0:	00e40ca3          	sb	a4,25(s0)
4000b0c4:	0107d713          	srli	a4,a5,0x10
4000b0c8:	0187d793          	srli	a5,a5,0x18
4000b0cc:	00e40d23          	sb	a4,26(s0)
4000b0d0:	00f40da3          	sb	a5,27(s0)
4000b0d4:	019a4783          	lbu	a5,25(s4)
4000b0d8:	018a4703          	lbu	a4,24(s4)
4000b0dc:	00879793          	slli	a5,a5,0x8
4000b0e0:	00e7e7b3          	or	a5,a5,a4
4000b0e4:	01aa4703          	lbu	a4,26(s4)
4000b0e8:	01071713          	slli	a4,a4,0x10
4000b0ec:	00f76733          	or	a4,a4,a5
4000b0f0:	01ba4783          	lbu	a5,27(s4)
4000b0f4:	00e40723          	sb	a4,14(s0)
4000b0f8:	01879793          	slli	a5,a5,0x18
4000b0fc:	00e7e7b3          	or	a5,a5,a4
4000b100:	0087d713          	srli	a4,a5,0x8
4000b104:	00e407a3          	sb	a4,15(s0)
4000b108:	0107d713          	srli	a4,a5,0x10
4000b10c:	0187d793          	srli	a5,a5,0x18
4000b110:	00e40823          	sb	a4,16(s0)
4000b114:	00f408a3          	sb	a5,17(s0)
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
4000b118:	0009a783          	lw	a5,0(s3)
			net_if_queue_tx(net_pkt_iface(reply), reply);
4000b11c:	01892503          	lw	a0,24(s2)
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
4000b120:	0107a783          	lw	a5,16(a5)
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
4000b124:	03590423          	sb	s5,40(s2)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)&hdr->dst_hwaddr.addr;
4000b128:	03692623          	sw	s6,44(s2)
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
4000b12c:	02f92223          	sw	a5,36(s2)
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
4000b130:	03590823          	sb	s5,48(s2)
			net_if_queue_tx(net_pkt_iface(reply), reply);
4000b134:	350040ef          	jal	ra,4000f484 <net_if_queue_tx>
4000b138:	d91ff06f          	j	4000aec8 <net_arp_input+0x100>
			dst_hw_addr = &eth_hdr->src;
4000b13c:	00690b93          	addi	s7,s2,6
4000b140:	ea9ff06f          	j	4000afe8 <net_arp_input+0x220>
		if (net_ipv4_is_my_addr((struct in_addr *)arp_hdr->dst_ipaddr)) {
4000b144:	01840913          	addi	s2,s0,24
 */
static inline bool net_ipv4_is_my_addr(const struct in_addr *addr)
{
	bool ret;

	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
4000b148:	00000593          	li	a1,0
4000b14c:	00090513          	mv	a0,s2
4000b150:	4bd030ef          	jal	ra,4000ee0c <net_if_ipv4_addr_lookup>
	if (!ret) {
4000b154:	00050c63          	beqz	a0,4000b16c <net_arp_input+0x3a4>
			arp_update(net_pkt_iface(pkt),
4000b158:	00000713          	li	a4,0
4000b15c:	00000693          	li	a3,0
4000b160:	00840613          	addi	a2,s0,8
4000b164:	00e40593          	addi	a1,s0,14
4000b168:	de9ff06f          	j	4000af50 <net_arp_input+0x188>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000b16c:	2f5050ef          	jal	ra,40010c60 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000b170:	01944703          	lbu	a4,25(s0)
4000b174:	01844783          	lbu	a5,24(s0)
4000b178:	00054683          	lbu	a3,0(a0)
4000b17c:	00871713          	slli	a4,a4,0x8
4000b180:	00f76733          	or	a4,a4,a5
4000b184:	01a44783          	lbu	a5,26(s0)
4000b188:	01079793          	slli	a5,a5,0x10
4000b18c:	00e7e7b3          	or	a5,a5,a4
4000b190:	01b44703          	lbu	a4,27(s0)
4000b194:	01871713          	slli	a4,a4,0x18
4000b198:	00f76733          	or	a4,a4,a5
4000b19c:	00154783          	lbu	a5,1(a0)
4000b1a0:	00879793          	slli	a5,a5,0x8
4000b1a4:	00d7e7b3          	or	a5,a5,a3
4000b1a8:	00254683          	lbu	a3,2(a0)
4000b1ac:	01069693          	slli	a3,a3,0x10
4000b1b0:	00f6e6b3          	or	a3,a3,a5
4000b1b4:	00354783          	lbu	a5,3(a0)
4000b1b8:	01879793          	slli	a5,a5,0x18
4000b1bc:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000b1c0:	f8f70ce3          	beq	a4,a5,4000b158 <net_arp_input+0x390>
	return net_if_ipv4_is_addr_bcast(iface, addr);
4000b1c4:	00090593          	mv	a1,s2
4000b1c8:	00000513          	li	a0,0
4000b1cc:	205030ef          	jal	ra,4000ebd0 <net_if_ipv4_is_addr_bcast>
		if (net_ipv4_is_my_addr((struct in_addr *)arp_hdr->dst_ipaddr)) {
4000b1d0:	ce050ce3          	beqz	a0,4000aec8 <net_arp_input+0x100>
4000b1d4:	f85ff06f          	j	4000b158 <net_arp_input+0x390>

4000b1d8 <net_arp_clear_cache>:

void net_arp_clear_cache(struct net_if *iface)
{
4000b1d8:	fe010113          	addi	sp,sp,-32
4000b1dc:	00912a23          	sw	s1,20(sp)
4000b1e0:	01412423          	sw	s4,8(sp)
4000b1e4:	00050493          	mv	s1,a0
	sys_snode_t *prev = NULL;
	struct arp_entry *entry, *next;

	NET_DBG("Flushing ARP table");

	k_mutex_lock(&arp_mutex, K_FOREVER);
4000b1e8:	fff00593          	li	a1,-1
4000b1ec:	fff00513          	li	a0,-1
	return list->head;
4000b1f0:	40031a37          	lui	s4,0x40031
{
4000b1f4:	00812c23          	sw	s0,24(sp)
4000b1f8:	00112e23          	sw	ra,28(sp)
4000b1fc:	01212823          	sw	s2,16(sp)
4000b200:	01312623          	sw	s3,12(sp)
4000b204:	01512223          	sw	s5,4(sp)
4000b208:	01612023          	sw	s6,0(sp)
	k_mutex_lock(&arp_mutex, K_FOREVER);
4000b20c:	b00ff0ef          	jal	ra,4000a50c <k_mutex_lock.constprop.0.isra.0>
4000b210:	a1ca2403          	lw	s0,-1508(s4) # 40030a1c <arp_table>

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
4000b214:	00040a63          	beqz	s0,4000b228 <net_arp_clear_cache+0x50>
	return node->next;
4000b218:	00042903          	lw	s2,0(s0)
4000b21c:	00000993          	li	s3,0
		}

		arp_entry_cleanup(entry, false);

		sys_slist_remove(&arp_table, prev, &entry->node);
		sys_slist_prepend(&arp_free_entries, &entry->node);
4000b220:	40031ab7          	lui	s5,0x40031
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
4000b224:	06041063          	bnez	s0,4000b284 <net_arp_clear_cache+0xac>
	return list->head;
4000b228:	40031a37          	lui	s4,0x40031
4000b22c:	a24a2403          	lw	s0,-1500(s4) # 40030a24 <arp_pending_entries>
4000b230:	a24a0a93          	addi	s5,s4,-1500

	prev = NULL;

	NET_DBG("Flushing ARP pending requests");

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
4000b234:	00040a63          	beqz	s0,4000b248 <net_arp_clear_cache+0x70>
	return node->next;
4000b238:	00042903          	lw	s2,0(s0)
4000b23c:	00000993          	li	s3,0
		}

		arp_entry_cleanup(entry, true);

		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
		sys_slist_prepend(&arp_free_entries, &entry->node);
4000b240:	40031b37          	lui	s6,0x40031
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
4000b244:	08041c63          	bnez	s0,4000b2dc <net_arp_clear_cache+0x104>
	}

	if (sys_slist_is_empty(&arp_pending_entries)) {
4000b248:	000aa783          	lw	a5,0(s5) # 40031000 <rx_classes+0x70>
4000b24c:	00079863          	bnez	a5,4000b25c <net_arp_clear_cache+0x84>
		k_work_cancel_delayable(&arp_request_timer);
4000b250:	40031537          	lui	a0,0x40031
4000b254:	da850513          	addi	a0,a0,-600 # 40030da8 <arp_request_timer>
4000b258:	3e41e0ef          	jal	ra,4002963c <k_work_cancel_delayable>
	}

	k_mutex_unlock(&arp_mutex);
}
4000b25c:	01812403          	lw	s0,24(sp)
4000b260:	01c12083          	lw	ra,28(sp)
4000b264:	01412483          	lw	s1,20(sp)
4000b268:	01012903          	lw	s2,16(sp)
4000b26c:	00c12983          	lw	s3,12(sp)
4000b270:	00812a03          	lw	s4,8(sp)
4000b274:	00412a83          	lw	s5,4(sp)
4000b278:	00012b03          	lw	s6,0(sp)
4000b27c:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&arp_mutex);
4000b280:	aa0ff06f          	j	4000a520 <k_mutex_unlock.constprop.0.isra.0>
			prev = &entry->node;
4000b284:	00040793          	mv	a5,s0
		if (iface && iface != entry->iface) {
4000b288:	00048663          	beqz	s1,4000b294 <net_arp_clear_cache+0xbc>
4000b28c:	00842703          	lw	a4,8(s0)
4000b290:	02971863          	bne	a4,s1,4000b2c0 <net_arp_clear_cache+0xe8>
		arp_entry_cleanup(entry, false);
4000b294:	00000593          	li	a1,0
4000b298:	00040513          	mv	a0,s0
4000b29c:	dc4ff0ef          	jal	ra,4000a860 <arp_entry_cleanup>
		sys_slist_remove(&arp_table, prev, &entry->node);
4000b2a0:	00040613          	mv	a2,s0
4000b2a4:	00098593          	mv	a1,s3
4000b2a8:	a1ca0513          	addi	a0,s4,-1508
4000b2ac:	9b4ff0ef          	jal	ra,4000a460 <sys_slist_remove>
		sys_slist_prepend(&arp_free_entries, &entry->node);
4000b2b0:	00040593          	mv	a1,s0
4000b2b4:	a2ca8513          	addi	a0,s5,-1492
4000b2b8:	98cff0ef          	jal	ra,4000a444 <sys_slist_prepend>
4000b2bc:	00098793          	mv	a5,s3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
4000b2c0:	00000713          	li	a4,0
4000b2c4:	00090463          	beqz	s2,4000b2cc <net_arp_clear_cache+0xf4>
4000b2c8:	00092703          	lw	a4,0(s2)
4000b2cc:	00090413          	mv	s0,s2
4000b2d0:	00078993          	mv	s3,a5
4000b2d4:	00070913          	mv	s2,a4
4000b2d8:	f4dff06f          	j	4000b224 <net_arp_clear_cache+0x4c>
			prev = &entry->node;
4000b2dc:	00040793          	mv	a5,s0
		if (iface && iface != entry->iface) {
4000b2e0:	00048663          	beqz	s1,4000b2ec <net_arp_clear_cache+0x114>
4000b2e4:	00842703          	lw	a4,8(s0)
4000b2e8:	02e49863          	bne	s1,a4,4000b318 <net_arp_clear_cache+0x140>
		arp_entry_cleanup(entry, true);
4000b2ec:	00100593          	li	a1,1
4000b2f0:	00040513          	mv	a0,s0
4000b2f4:	d6cff0ef          	jal	ra,4000a860 <arp_entry_cleanup>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
4000b2f8:	00040613          	mv	a2,s0
4000b2fc:	00098593          	mv	a1,s3
4000b300:	a24a0513          	addi	a0,s4,-1500
4000b304:	95cff0ef          	jal	ra,4000a460 <sys_slist_remove>
		sys_slist_prepend(&arp_free_entries, &entry->node);
4000b308:	00040593          	mv	a1,s0
4000b30c:	a2cb0513          	addi	a0,s6,-1492 # 40030a2c <arp_free_entries>
4000b310:	934ff0ef          	jal	ra,4000a444 <sys_slist_prepend>
4000b314:	00098793          	mv	a5,s3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
4000b318:	00000713          	li	a4,0
4000b31c:	00090463          	beqz	s2,4000b324 <net_arp_clear_cache+0x14c>
4000b320:	00092703          	lw	a4,0(s2)
4000b324:	00090413          	mv	s0,s2
4000b328:	00078993          	mv	s3,a5
4000b32c:	00070913          	mv	s2,a4
4000b330:	f15ff06f          	j	4000b244 <net_arp_clear_cache+0x6c>

4000b334 <net_arp_clear_pending>:
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
4000b334:	400317b7          	lui	a5,0x40031

int net_arp_clear_pending(struct net_if *iface, struct in_addr *dst)
{
4000b338:	00058613          	mv	a2,a1
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
4000b33c:	00050593          	mv	a1,a0
4000b340:	a247a503          	lw	a0,-1500(a5) # 40030a24 <arp_pending_entries>
{
4000b344:	ff010113          	addi	sp,sp,-16
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
4000b348:	00000693          	li	a3,0
{
4000b34c:	00112623          	sw	ra,12(sp)
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
4000b350:	a6cff0ef          	jal	ra,4000a5bc <arp_entry_find.isra.0>
	struct arp_entry *entry = arp_entry_find_pending(iface, dst);

	if (!entry) {
4000b354:	00050e63          	beqz	a0,4000b370 <net_arp_clear_pending+0x3c>
		return -ENOENT;
	}

	arp_entry_cleanup(entry, true);
4000b358:	00100593          	li	a1,1
4000b35c:	d04ff0ef          	jal	ra,4000a860 <arp_entry_cleanup>

	return 0;
4000b360:	00000513          	li	a0,0
}
4000b364:	00c12083          	lw	ra,12(sp)
4000b368:	01010113          	addi	sp,sp,16
4000b36c:	00008067          	ret
		return -ENOENT;
4000b370:	ffe00513          	li	a0,-2
4000b374:	ff1ff06f          	j	4000b364 <net_arp_clear_pending+0x30>

4000b378 <net_arp_foreach>:

int net_arp_foreach(net_arp_cb_t cb, void *user_data)
{
4000b378:	fe010113          	addi	sp,sp,-32
4000b37c:	01212823          	sw	s2,16(sp)
4000b380:	01312623          	sw	s3,12(sp)
4000b384:	00050913          	mv	s2,a0
4000b388:	00058993          	mv	s3,a1
	int ret = 0;
	struct arp_entry *entry;

	k_mutex_lock(&arp_mutex, K_FOREVER);
4000b38c:	fff00513          	li	a0,-1
4000b390:	fff00593          	li	a1,-1
{
4000b394:	00812c23          	sw	s0,24(sp)
4000b398:	00912a23          	sw	s1,20(sp)
4000b39c:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&arp_mutex, K_FOREVER);
4000b3a0:	96cff0ef          	jal	ra,4000a50c <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4000b3a4:	400317b7          	lui	a5,0x40031
4000b3a8:	a1c7a403          	lw	s0,-1508(a5) # 40030a1c <arp_table>
4000b3ac:	00000493          	li	s1,0

	SYS_SLIST_FOR_EACH_CONTAINER(&arp_table, entry, node) {
4000b3b0:	02041463          	bnez	s0,4000b3d8 <net_arp_foreach+0x60>
		ret++;
		cb(entry, user_data);
	}

	k_mutex_unlock(&arp_mutex);
4000b3b4:	96cff0ef          	jal	ra,4000a520 <k_mutex_unlock.constprop.0.isra.0>

	return ret;
}
4000b3b8:	01c12083          	lw	ra,28(sp)
4000b3bc:	01812403          	lw	s0,24(sp)
4000b3c0:	01012903          	lw	s2,16(sp)
4000b3c4:	00c12983          	lw	s3,12(sp)
4000b3c8:	00048513          	mv	a0,s1
4000b3cc:	01412483          	lw	s1,20(sp)
4000b3d0:	02010113          	addi	sp,sp,32
4000b3d4:	00008067          	ret
		cb(entry, user_data);
4000b3d8:	00040513          	mv	a0,s0
4000b3dc:	00098593          	mv	a1,s3
4000b3e0:	000900e7          	jalr	s2
		ret++;
4000b3e4:	00148493          	addi	s1,s1,1
	return node->next;
4000b3e8:	00042403          	lw	s0,0(s0)
4000b3ec:	fc5ff06f          	j	4000b3b0 <net_arp_foreach+0x38>

4000b3f0 <net_arp_init>:

void net_arp_init(void)
{
4000b3f0:	ff010113          	addi	sp,sp,-16
4000b3f4:	00912223          	sw	s1,4(sp)
	int i;

	if (arp_cache_initialized) {
4000b3f8:	400314b7          	lui	s1,0x40031
4000b3fc:	b034c783          	lbu	a5,-1277(s1) # 40030b03 <arp_cache_initialized>
{
4000b400:	00112623          	sw	ra,12(sp)
4000b404:	00812423          	sw	s0,8(sp)
	if (arp_cache_initialized) {
4000b408:	08079a63          	bnez	a5,4000b49c <net_arp_init+0xac>
	list->head = NULL;
4000b40c:	40031437          	lui	s0,0x40031
4000b410:	a2c40793          	addi	a5,s0,-1492 # 40030a2c <arp_free_entries>
4000b414:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
4000b418:	0007a223          	sw	zero,4(a5)
	list->head = NULL;
4000b41c:	400317b7          	lui	a5,0x40031
4000b420:	a2478793          	addi	a5,a5,-1500 # 40030a24 <arp_pending_entries>
4000b424:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
4000b428:	0007a223          	sw	zero,4(a5)
	list->head = NULL;
4000b42c:	400317b7          	lui	a5,0x40031
4000b430:	a1c78793          	addi	a5,a5,-1508 # 40030a1c <arp_table>
4000b434:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
4000b438:	0007a223          	sw	zero,4(a5)
	z_impl_k_queue_init(queue);
4000b43c:	40032537          	lui	a0,0x40032
4000b440:	c4050513          	addi	a0,a0,-960 # 40031c40 <arp_entries+0x18>
4000b444:	7dc1d0ef          	jal	ra,40028c20 <z_impl_k_queue_init>
	sys_slist_init(&arp_table);

	for (i = 0; i < CONFIG_NET_ARP_TABLE_SIZE; i++) {
		/* Inserting entry as free with initialised packet queue */
		k_fifo_init(&arp_entries[i].pending_queue);
		sys_slist_prepend(&arp_free_entries, &arp_entries[i].node);
4000b448:	400325b7          	lui	a1,0x40032
4000b44c:	c2858593          	addi	a1,a1,-984 # 40031c28 <arp_entries>
4000b450:	a2c40513          	addi	a0,s0,-1492
4000b454:	ff1fe0ef          	jal	ra,4000a444 <sys_slist_prepend>
4000b458:	40032537          	lui	a0,0x40032
4000b45c:	c7050513          	addi	a0,a0,-912 # 40031c70 <arp_entries+0x48>
4000b460:	7c01d0ef          	jal	ra,40028c20 <z_impl_k_queue_init>
4000b464:	400325b7          	lui	a1,0x40032
4000b468:	a2c40513          	addi	a0,s0,-1492
4000b46c:	c5858593          	addi	a1,a1,-936 # 40031c58 <arp_entries+0x30>
4000b470:	fd5fe0ef          	jal	ra,4000a444 <sys_slist_prepend>
	}

	k_work_init_delayable(&arp_request_timer, arp_request_timeout);
4000b474:	4000b5b7          	lui	a1,0x4000b
4000b478:	40031537          	lui	a0,0x40031
4000b47c:	8d058593          	addi	a1,a1,-1840 # 4000a8d0 <arp_request_timeout>
4000b480:	da850513          	addi	a0,a0,-600 # 40030da8 <arp_request_timer>
4000b484:	0501e0ef          	jal	ra,400294d4 <k_work_init_delayable>
	return z_impl_k_mutex_init(mutex);
4000b488:	40032537          	lui	a0,0x40032
4000b48c:	c1450513          	addi	a0,a0,-1004 # 40031c14 <arp_mutex>
4000b490:	3d41d0ef          	jal	ra,40028864 <z_impl_k_mutex_init>

	k_mutex_init(&arp_mutex);

	arp_cache_initialized = true;
4000b494:	00100793          	li	a5,1
4000b498:	b0f481a3          	sb	a5,-1277(s1)
}
4000b49c:	00c12083          	lw	ra,12(sp)
4000b4a0:	00812403          	lw	s0,8(sp)
4000b4a4:	00412483          	lw	s1,4(sp)
4000b4a8:	01010113          	addi	sp,sp,16
4000b4ac:	00008067          	ret

4000b4b0 <net_ipv6_is_addr_loopback>:
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4000b4b0:	00154703          	lbu	a4,1(a0)
4000b4b4:	00054683          	lbu	a3,0(a0)
{
4000b4b8:	00050793          	mv	a5,a0
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4000b4bc:	00871713          	slli	a4,a4,0x8
4000b4c0:	00d76733          	or	a4,a4,a3
4000b4c4:	00254683          	lbu	a3,2(a0)
4000b4c8:	01069693          	slli	a3,a3,0x10
4000b4cc:	00e6e6b3          	or	a3,a3,a4
4000b4d0:	00354703          	lbu	a4,3(a0)
4000b4d4:	01871713          	slli	a4,a4,0x18
4000b4d8:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000b4dc:	0c071263          	bnez	a4,4000b5a0 <net_ipv6_is_addr_loopback+0xf0>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4000b4e0:	00554703          	lbu	a4,5(a0)
4000b4e4:	00454683          	lbu	a3,4(a0)
4000b4e8:	00871713          	slli	a4,a4,0x8
4000b4ec:	00d76733          	or	a4,a4,a3
4000b4f0:	00654683          	lbu	a3,6(a0)
4000b4f4:	01069693          	slli	a3,a3,0x10
4000b4f8:	00e6e6b3          	or	a3,a3,a4
4000b4fc:	00754703          	lbu	a4,7(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000b500:	00000513          	li	a0,0
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4000b504:	01871713          	slli	a4,a4,0x18
4000b508:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4000b50c:	08071c63          	bnez	a4,4000b5a4 <net_ipv6_is_addr_loopback+0xf4>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000b510:	0097c703          	lbu	a4,9(a5)
4000b514:	0087c683          	lbu	a3,8(a5)
4000b518:	00871713          	slli	a4,a4,0x8
4000b51c:	00d76733          	or	a4,a4,a3
4000b520:	00a7c683          	lbu	a3,10(a5)
4000b524:	01069693          	slli	a3,a3,0x10
4000b528:	00e6e6b3          	or	a3,a3,a4
4000b52c:	00b7c703          	lbu	a4,11(a5)
4000b530:	01871713          	slli	a4,a4,0x18
4000b534:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4000b538:	06071663          	bnez	a4,4000b5a4 <net_ipv6_is_addr_loopback+0xf4>
		ntohl(UNALIGNED_GET(&addr->s6_addr32[3])) == 1;
4000b53c:	00d7c683          	lbu	a3,13(a5)
4000b540:	00c7c703          	lbu	a4,12(a5)
4000b544:	00869693          	slli	a3,a3,0x8
4000b548:	00e6e6b3          	or	a3,a3,a4
4000b54c:	00e7c703          	lbu	a4,14(a5)
4000b550:	00f7c783          	lbu	a5,15(a5)
4000b554:	01071713          	slli	a4,a4,0x10
4000b558:	01879793          	slli	a5,a5,0x18
4000b55c:	00d76733          	or	a4,a4,a3
4000b560:	00e7e6b3          	or	a3,a5,a4
4000b564:	0187d513          	srli	a0,a5,0x18
4000b568:	01871713          	slli	a4,a4,0x18
4000b56c:	00e56533          	or	a0,a0,a4
4000b570:	00010737          	lui	a4,0x10
4000b574:	0086d793          	srli	a5,a3,0x8
4000b578:	f0070713          	addi	a4,a4,-256 # ff00 <__kernel_ram_size+0x3c6c>
4000b57c:	00e7f7b3          	and	a5,a5,a4
4000b580:	00f56533          	or	a0,a0,a5
4000b584:	00869693          	slli	a3,a3,0x8
4000b588:	00ff07b7          	lui	a5,0xff0
4000b58c:	00f6f6b3          	and	a3,a3,a5
4000b590:	00d56533          	or	a0,a0,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000b594:	fff50513          	addi	a0,a0,-1
4000b598:	00153513          	seqz	a0,a0
4000b59c:	00008067          	ret
4000b5a0:	00000513          	li	a0,0
}
4000b5a4:	00008067          	ret

4000b5a8 <processing_data>:
	NET_DBG("Unknown protocol family packet (0x%x)", family);
	return NET_DROP;
}

static void processing_data(struct net_pkt *pkt, bool is_loopback)
{
4000b5a8:	ff010113          	addi	sp,sp,-16
4000b5ac:	00812423          	sw	s0,8(sp)
4000b5b0:	00112623          	sw	ra,12(sp)
4000b5b4:	00912223          	sw	s1,4(sp)
	pkt->l2_processed = is_l2_processed;
4000b5b8:	03854783          	lbu	a5,56(a0)
4000b5bc:	00050413          	mv	s0,a0
4000b5c0:	fef7f793          	andi	a5,a5,-17
4000b5c4:	02f50c23          	sb	a5,56(a0)
	if (!pkt->frags) {
4000b5c8:	00852783          	lw	a5,8(a0)
4000b5cc:	02078463          	beqz	a5,4000b5f4 <processing_data+0x4c>
4000b5d0:	00058493          	mv	s1,a1
	if (!is_loopback && !locally_routed) {
4000b5d4:	02058c63          	beqz	a1,4000b60c <processing_data+0x64>
4000b5d8:	03844783          	lbu	a5,56(s0)
	net_pkt_cursor_init(pkt);
4000b5dc:	00040513          	mv	a0,s0
4000b5e0:	0107e793          	ori	a5,a5,16
4000b5e4:	02f40c23          	sb	a5,56(s0)
4000b5e8:	409070ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	return pkt->family;
4000b5ec:	03442783          	lw	a5,52(s0)
	if (IS_ENABLED(CONFIG_NET_IP) && (family == AF_INET || family == AF_INET6 ||
4000b5f0:	0407d463          	bgez	a5,4000b638 <processing_data+0x90>
			 * to the stack in this case.
			 */
			goto again;
		} else {
			NET_DBG("Dropping pkt %p", pkt);
			net_pkt_unref(pkt);
4000b5f4:	00040513          	mv	a0,s0
	default:
		NET_DBG("Dropping pkt %p", pkt);
		net_pkt_unref(pkt);
		break;
	}
}
4000b5f8:	00812403          	lw	s0,8(sp)
4000b5fc:	00c12083          	lw	ra,12(sp)
4000b600:	00412483          	lw	s1,4(sp)
4000b604:	01010113          	addi	sp,sp,16
			net_pkt_unref(pkt);
4000b608:	1150706f          	j	40012f1c <net_pkt_unref>
		ret = net_if_recv_data(net_pkt_iface(pkt), pkt);
4000b60c:	00050593          	mv	a1,a0
4000b610:	01852503          	lw	a0,24(a0)
4000b614:	4a1030ef          	jal	ra,4000f2b4 <net_if_recv_data>
		if (ret != NET_CONTINUE) {
4000b618:	00100793          	li	a5,1
4000b61c:	faf50ee3          	beq	a0,a5,4000b5d8 <processing_data+0x30>
	switch (process_data(pkt, is_loopback)) {
4000b620:	fc051ae3          	bnez	a0,4000b5f4 <processing_data+0x4c>
}
4000b624:	00c12083          	lw	ra,12(sp)
4000b628:	00812403          	lw	s0,8(sp)
4000b62c:	00412483          	lw	s1,4(sp)
4000b630:	01010113          	addi	sp,sp,16
4000b634:	00008067          	ret
	return pkt->frags->data;
4000b638:	00842783          	lw	a5,8(s0)
		if (IS_ENABLED(CONFIG_NET_IPV6) && vtc_vhl == 0x60) {
4000b63c:	06000713          	li	a4,96
		uint8_t vtc_vhl = NET_IPV6_HDR(pkt)->vtc & 0xf0;
4000b640:	00c7a783          	lw	a5,12(a5) # ff000c <__rom_region_size+0xfbf630>
4000b644:	0007c783          	lbu	a5,0(a5)
4000b648:	0f07f793          	andi	a5,a5,240
		if (IS_ENABLED(CONFIG_NET_IPV6) && vtc_vhl == 0x60) {
4000b64c:	00e79a63          	bne	a5,a4,4000b660 <processing_data+0xb8>
			return net_ipv6_input(pkt, is_loopback);
4000b650:	00048593          	mv	a1,s1
4000b654:	00040513          	mv	a0,s0
4000b658:	4a00b0ef          	jal	ra,40016af8 <net_ipv6_input>
4000b65c:	fc5ff06f          	j	4000b620 <processing_data+0x78>
		} else if (IS_ENABLED(CONFIG_NET_IPV4) && vtc_vhl == 0x40) {
4000b660:	04000713          	li	a4,64
4000b664:	f8e798e3          	bne	a5,a4,4000b5f4 <processing_data+0x4c>
			return net_ipv4_input(pkt);
4000b668:	00040513          	mv	a0,s0
4000b66c:	2900a0ef          	jal	ra,400158fc <net_ipv4_input>
4000b670:	fb1ff06f          	j	4000b620 <processing_data+0x78>

4000b674 <net_init>:

	return status;
}

static int net_init(void)
{
4000b674:	ff010113          	addi	sp,sp,-16
4000b678:	00112623          	sw	ra,12(sp)
	net_hostname_init();

	NET_DBG("Priority %d", CONFIG_NET_INIT_PRIO);

	net_pkt_init();
4000b67c:	19d080ef          	jal	ra,40014018 <net_pkt_init>

	net_context_init();
4000b680:	374070ef          	jal	ra,400129f4 <net_context_init>
	net_icmpv4_init();
4000b684:	6e5090ef          	jal	ra,40015568 <net_icmpv4_init>
	net_icmpv6_init();
4000b688:	5fd0a0ef          	jal	ra,40016484 <net_icmpv6_init>
	net_ipv4_init();
4000b68c:	5680a0ef          	jal	ra,40015bf4 <net_ipv4_init>
	net_ipv6_init();
4000b690:	2c50b0ef          	jal	ra,40017154 <net_ipv6_init>
		net_conn_init();
4000b694:	5f4090ef          	jal	ra,40014c88 <net_conn_init>
	net_tcp_init();
4000b698:	0a5130ef          	jal	ra,4001ef3c <net_tcp_init>
	net_route_init();
4000b69c:	5440f0ef          	jal	ra,4001abe0 <net_route_init>

	l3_init();

	net_mgmt_event_init();
4000b6a0:	16d050ef          	jal	ra,4001100c <net_mgmt_event_init>
	net_if_init();
4000b6a4:	21c040ef          	jal	ra,4000f8c0 <net_if_init>
	net_tc_rx_init();
4000b6a8:	1e5080ef          	jal	ra,4001408c <net_tc_rx_init>
	net_if_post_init();
4000b6ac:	388040ef          	jal	ra,4000fa34 <net_if_post_init>
	dns_init_resolver();
4000b6b0:	24c1a0ef          	jal	ra,400258fc <dns_init_resolver>
	net_shell_init();
4000b6b4:	47c180ef          	jal	ra,40023b30 <net_shell_init>

	init_rx_queues();

	return services_init();
}
4000b6b8:	00c12083          	lw	ra,12(sp)
4000b6bc:	00000513          	li	a0,0
4000b6c0:	01010113          	addi	sp,sp,16
4000b6c4:	00008067          	ret

4000b6c8 <net_send_data>:
	if (!pkt || !pkt->frags) {
4000b6c8:	38050063          	beqz	a0,4000ba48 <net_send_data+0x380>
{
4000b6cc:	fe010113          	addi	sp,sp,-32
4000b6d0:	00812c23          	sw	s0,24(sp)
4000b6d4:	00112e23          	sw	ra,28(sp)
4000b6d8:	00912a23          	sw	s1,20(sp)
4000b6dc:	01212823          	sw	s2,16(sp)
	if (!pkt || !pkt->frags) {
4000b6e0:	00852703          	lw	a4,8(a0)
4000b6e4:	00050413          	mv	s0,a0
		return -ENODATA;
4000b6e8:	fc300793          	li	a5,-61
	if (!pkt || !pkt->frags) {
4000b6ec:	04070a63          	beqz	a4,4000b740 <net_send_data+0x78>
	if (!net_pkt_iface(pkt)) {
4000b6f0:	01852703          	lw	a4,24(a0)
		return -EINVAL;
4000b6f4:	fea00793          	li	a5,-22
	if (!net_pkt_iface(pkt)) {
4000b6f8:	04070463          	beqz	a4,4000b740 <net_send_data+0x78>
	net_pkt_trim_buffer(pkt);
4000b6fc:	209070ef          	jal	ra,40013104 <net_pkt_trim_buffer>
	net_pkt_cursor_init(pkt);
4000b700:	00040513          	mv	a0,s0
4000b704:	2ed070ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	return pkt->family;
4000b708:	03442783          	lw	a5,52(s0)
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
4000b70c:	00200713          	li	a4,2
4000b710:	01d7d793          	srli	a5,a5,0x1d
4000b714:	10e79a63          	bne	a5,a4,4000b828 <net_send_data+0x160>
	return pkt->frags->data;
4000b718:	00842783          	lw	a5,8(s0)
		if (net_ipv6_addr_cmp((struct in6_addr *)NET_IPV6_HDR(pkt)->dst,
4000b71c:	00c7a483          	lw	s1,12(a5)
4000b720:	54c050ef          	jal	ra,40010c6c <net_ipv6_unspecified_address>
4000b724:	00050593          	mv	a1,a0
4000b728:	01848493          	addi	s1,s1,24
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4000b72c:	01000613          	li	a2,16
4000b730:	00048513          	mv	a0,s1
4000b734:	899fd0ef          	jal	ra,40008fcc <memcmp>
4000b738:	02051263          	bnez	a0,4000b75c <net_send_data+0x94>
			return -EADDRNOTAVAIL;
4000b73c:	f8300793          	li	a5,-125
}
4000b740:	01c12083          	lw	ra,28(sp)
4000b744:	01812403          	lw	s0,24(sp)
4000b748:	01412483          	lw	s1,20(sp)
4000b74c:	01012903          	lw	s2,16(sp)
4000b750:	00078513          	mv	a0,a5
4000b754:	02010113          	addi	sp,sp,32
4000b758:	00008067          	ret
4000b75c:	00842783          	lw	a5,8(s0)
				(struct in6_addr *)NET_IPV6_HDR(pkt)->dst) ||
4000b760:	00c7a483          	lw	s1,12(a5)
4000b764:	01848493          	addi	s1,s1,24
		if (net_ipv6_is_addr_loopback(
4000b768:	00048513          	mv	a0,s1
4000b76c:	d45ff0ef          	jal	ra,4000b4b0 <net_ipv6_is_addr_loopback>
4000b770:	06050063          	beqz	a0,4000b7d0 <net_send_data+0x108>
4000b774:	00842783          	lw	a5,8(s0)
	memcpy(dest, src, sizeof(struct in6_addr));
4000b778:	01000613          	li	a2,16
4000b77c:	00010513          	mv	a0,sp
			net_ipv6_addr_copy_raw((uint8_t *)&addr, NET_IPV6_HDR(pkt)->src);
4000b780:	00c7a583          	lw	a1,12(a5)
4000b784:	00858593          	addi	a1,a1,8
4000b788:	8c5fd0ef          	jal	ra,4000904c <memcpy>
4000b78c:	00842783          	lw	a5,8(s0)
4000b790:	01000613          	li	a2,16
4000b794:	00c7a503          	lw	a0,12(a5)
4000b798:	01850593          	addi	a1,a0,24
4000b79c:	00850513          	addi	a0,a0,8
4000b7a0:	8adfd0ef          	jal	ra,4000904c <memcpy>
4000b7a4:	00842783          	lw	a5,8(s0)
4000b7a8:	01000613          	li	a2,16
4000b7ac:	00010593          	mv	a1,sp
			net_ipv6_addr_copy_raw(NET_IPV6_HDR(pkt)->dst, (uint8_t *)&addr);
4000b7b0:	00c7a503          	lw	a0,12(a5)
4000b7b4:	01850513          	addi	a0,a0,24
4000b7b8:	895fd0ef          	jal	ra,4000904c <memcpy>
		processing_data(pkt, true);
4000b7bc:	00100593          	li	a1,1
4000b7c0:	00040513          	mv	a0,s0
4000b7c4:	de5ff0ef          	jal	ra,4000b5a8 <processing_data>
		return 0;
4000b7c8:	00000793          	li	a5,0
4000b7cc:	f75ff06f          	j	4000b740 <net_send_data+0x78>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
4000b7d0:	00000593          	li	a1,0
4000b7d4:	00048513          	mv	a0,s1
4000b7d8:	744010ef          	jal	ra,4000cf1c <net_if_ipv6_addr_lookup>
				(struct in6_addr *)NET_IPV6_HDR(pkt)->dst) ||
4000b7dc:	f8051ce3          	bnez	a0,4000b774 <net_send_data+0xac>
4000b7e0:	00842783          	lw	a5,8(s0)
4000b7e4:	00c7a503          	lw	a0,12(a5)
 * false otherwise.
 */
static inline bool net_ipv6_is_addr_mcast_scope(const struct in6_addr *addr,
						int scope)
{
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
4000b7e8:	0ff00793          	li	a5,255
4000b7ec:	01854703          	lbu	a4,24(a0)
4000b7f0:	00f71863          	bne	a4,a5,4000b800 <net_send_data+0x138>
4000b7f4:	01954703          	lbu	a4,25(a0)
4000b7f8:	00100793          	li	a5,1
4000b7fc:	fcf700e3          	beq	a4,a5,4000b7bc <net_send_data+0xf4>
		if (net_ipv6_is_addr_loopback(
4000b800:	00850513          	addi	a0,a0,8
4000b804:	cadff0ef          	jal	ra,4000b4b0 <net_ipv6_is_addr_loopback>
4000b808:	f2051ae3          	bnez	a0,4000b73c <net_send_data+0x74>
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
4000b80c:	01842503          	lw	a0,24(s0)
4000b810:	00040593          	mv	a1,s0
4000b814:	499030ef          	jal	ra,4000f4ac <net_if_send_data>
4000b818:	00200793          	li	a5,2
4000b81c:	faf516e3          	bne	a0,a5,4000b7c8 <net_send_data+0x100>
		return -EIO;
4000b820:	ffb00793          	li	a5,-5
4000b824:	f1dff06f          	j	4000b740 <net_send_data+0x78>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
4000b828:	00100713          	li	a4,1
4000b82c:	fee790e3          	bne	a5,a4,4000b80c <net_send_data+0x144>
4000b830:	00842783          	lw	a5,8(s0)
4000b834:	00c7a483          	lw	s1,12(a5)
		if (net_ipv4_addr_cmp((struct in_addr *)NET_IPV4_HDR(pkt)->dst,
4000b838:	41c050ef          	jal	ra,40010c54 <net_ipv4_unspecified_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000b83c:	00054683          	lbu	a3,0(a0)
4000b840:	0114c703          	lbu	a4,17(s1)
4000b844:	0104c783          	lbu	a5,16(s1)
4000b848:	00871713          	slli	a4,a4,0x8
4000b84c:	00f76733          	or	a4,a4,a5
4000b850:	0124c783          	lbu	a5,18(s1)
4000b854:	01079793          	slli	a5,a5,0x10
4000b858:	00e7e7b3          	or	a5,a5,a4
4000b85c:	0134c703          	lbu	a4,19(s1)
4000b860:	01871713          	slli	a4,a4,0x18
4000b864:	00f76733          	or	a4,a4,a5
4000b868:	00154783          	lbu	a5,1(a0)
4000b86c:	00879793          	slli	a5,a5,0x8
4000b870:	00d7e7b3          	or	a5,a5,a3
4000b874:	00254683          	lbu	a3,2(a0)
4000b878:	01069693          	slli	a3,a3,0x10
4000b87c:	00f6e6b3          	or	a3,a3,a5
4000b880:	00354783          	lbu	a5,3(a0)
4000b884:	01879793          	slli	a5,a5,0x18
4000b888:	00d7e7b3          	or	a5,a5,a3
4000b88c:	eaf708e3          	beq	a4,a5,4000b73c <net_send_data+0x74>
4000b890:	00842783          	lw	a5,8(s0)
4000b894:	00c7a483          	lw	s1,12(a5)
		if (net_ipv4_is_addr_loopback((struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
4000b898:	07f00793          	li	a5,127
4000b89c:	0104c703          	lbu	a4,16(s1)
4000b8a0:	0af71063          	bne	a4,a5,4000b940 <net_send_data+0x278>
4000b8a4:	00842783          	lw	a5,8(s0)
4000b8a8:	00c7a783          	lw	a5,12(a5)
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
4000b8ac:	00d7c703          	lbu	a4,13(a5)
4000b8b0:	00c7c683          	lbu	a3,12(a5)
4000b8b4:	0107c583          	lbu	a1,16(a5)
4000b8b8:	00871713          	slli	a4,a4,0x8
4000b8bc:	00d76733          	or	a4,a4,a3
4000b8c0:	0117c683          	lbu	a3,17(a5)
4000b8c4:	00e7c603          	lbu	a2,14(a5)
4000b8c8:	00869693          	slli	a3,a3,0x8
4000b8cc:	00b6e6b3          	or	a3,a3,a1
4000b8d0:	0127c583          	lbu	a1,18(a5)
4000b8d4:	01061613          	slli	a2,a2,0x10
4000b8d8:	00e66633          	or	a2,a2,a4
4000b8dc:	01059593          	slli	a1,a1,0x10
4000b8e0:	00d5e5b3          	or	a1,a1,a3
4000b8e4:	0137c683          	lbu	a3,19(a5)
4000b8e8:	00b78623          	sb	a1,12(a5)
4000b8ec:	00f7c703          	lbu	a4,15(a5)
4000b8f0:	01869693          	slli	a3,a3,0x18
4000b8f4:	00b6e6b3          	or	a3,a3,a1
4000b8f8:	0086d593          	srli	a1,a3,0x8
4000b8fc:	00b786a3          	sb	a1,13(a5)
4000b900:	0106d593          	srli	a1,a3,0x10
4000b904:	0186d693          	srli	a3,a3,0x18
4000b908:	00d787a3          	sb	a3,15(a5)
4000b90c:	00b78723          	sb	a1,14(a5)
4000b910:	00842783          	lw	a5,8(s0)
4000b914:	01871713          	slli	a4,a4,0x18
4000b918:	00c76733          	or	a4,a4,a2
4000b91c:	00c7a783          	lw	a5,12(a5)
4000b920:	00875693          	srli	a3,a4,0x8
4000b924:	00d788a3          	sb	a3,17(a5)
4000b928:	01075693          	srli	a3,a4,0x10
4000b92c:	01875713          	srli	a4,a4,0x18
4000b930:	00c78823          	sb	a2,16(a5)
4000b934:	00d78923          	sb	a3,18(a5)
4000b938:	00e789a3          	sb	a4,19(a5)
	if (status < 0) {
4000b93c:	e81ff06f          	j	4000b7bc <net_send_data+0xf4>
	return pkt->iface;
4000b940:	01842903          	lw	s2,24(s0)
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000b944:	31c050ef          	jal	ra,40010c60 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000b948:	0114c703          	lbu	a4,17(s1)
4000b94c:	0104c783          	lbu	a5,16(s1)
4000b950:	00054683          	lbu	a3,0(a0)
4000b954:	00871713          	slli	a4,a4,0x8
4000b958:	00f76733          	or	a4,a4,a5
4000b95c:	0124c783          	lbu	a5,18(s1)
4000b960:	01079793          	slli	a5,a5,0x10
4000b964:	00e7e7b3          	or	a5,a5,a4
4000b968:	0134c703          	lbu	a4,19(s1)
4000b96c:	01871713          	slli	a4,a4,0x18
4000b970:	00f76733          	or	a4,a4,a5
4000b974:	00154783          	lbu	a5,1(a0)
4000b978:	00879793          	slli	a5,a5,0x8
4000b97c:	00d7e7b3          	or	a5,a5,a3
4000b980:	00254683          	lbu	a3,2(a0)
4000b984:	01069693          	slli	a3,a3,0x10
4000b988:	00f6e6b3          	or	a3,a3,a5
4000b98c:	00354783          	lbu	a5,3(a0)
4000b990:	01879793          	slli	a5,a5,0x18
4000b994:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000b998:	08f70c63          	beq	a4,a5,4000ba30 <net_send_data+0x368>
	return net_if_ipv4_is_addr_bcast(iface, addr);
4000b99c:	01048593          	addi	a1,s1,16
4000b9a0:	00090513          	mv	a0,s2
4000b9a4:	22c030ef          	jal	ra,4000ebd0 <net_if_ipv4_is_addr_bcast>
		if (net_ipv4_is_addr_loopback((struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
4000b9a8:	08051463          	bnez	a0,4000ba30 <net_send_data+0x368>
	return pkt->frags->data;
4000b9ac:	00842783          	lw	a5,8(s0)
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
4000b9b0:	00000593          	li	a1,0
4000b9b4:	00c7a903          	lw	s2,12(a5)
		     net_ipv4_is_my_addr((struct in_addr *)NET_IPV4_HDR(pkt)->dst))) {
4000b9b8:	01090493          	addi	s1,s2,16
4000b9bc:	00048513          	mv	a0,s1
4000b9c0:	44c030ef          	jal	ra,4000ee0c <net_if_ipv4_addr_lookup>
	if (!ret) {
4000b9c4:	ee0510e3          	bnez	a0,4000b8a4 <net_send_data+0x1dc>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000b9c8:	298050ef          	jal	ra,40010c60 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000b9cc:	01194703          	lbu	a4,17(s2)
4000b9d0:	01094783          	lbu	a5,16(s2)
4000b9d4:	00054683          	lbu	a3,0(a0)
4000b9d8:	00871713          	slli	a4,a4,0x8
4000b9dc:	00f76733          	or	a4,a4,a5
4000b9e0:	01294783          	lbu	a5,18(s2)
4000b9e4:	01079793          	slli	a5,a5,0x10
4000b9e8:	00e7e7b3          	or	a5,a5,a4
4000b9ec:	01394703          	lbu	a4,19(s2)
4000b9f0:	01871713          	slli	a4,a4,0x18
4000b9f4:	00f76733          	or	a4,a4,a5
4000b9f8:	00154783          	lbu	a5,1(a0)
4000b9fc:	00879793          	slli	a5,a5,0x8
4000ba00:	00d7e7b3          	or	a5,a5,a3
4000ba04:	00254683          	lbu	a3,2(a0)
4000ba08:	01069693          	slli	a3,a3,0x10
4000ba0c:	00f6e6b3          	or	a3,a3,a5
4000ba10:	00354783          	lbu	a5,3(a0)
4000ba14:	01879793          	slli	a5,a5,0x18
4000ba18:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4000ba1c:	e8f704e3          	beq	a4,a5,4000b8a4 <net_send_data+0x1dc>
	return net_if_ipv4_is_addr_bcast(iface, addr);
4000ba20:	00048593          	mv	a1,s1
4000ba24:	00000513          	li	a0,0
4000ba28:	1a8030ef          	jal	ra,4000ebd0 <net_if_ipv4_is_addr_bcast>
				     (struct in_addr *)NET_IPV4_HDR(pkt)->dst) == false &&
4000ba2c:	e6051ce3          	bnez	a0,4000b8a4 <net_send_data+0x1dc>
4000ba30:	00842783          	lw	a5,8(s0)
	return addr->s4_addr[0] == 127U;
4000ba34:	00c7a783          	lw	a5,12(a5)
		if (net_ipv4_is_addr_loopback((struct in_addr *)NET_IPV4_HDR(pkt)->src)) {
4000ba38:	00c7c703          	lbu	a4,12(a5)
4000ba3c:	07f00793          	li	a5,127
4000ba40:	dcf716e3          	bne	a4,a5,4000b80c <net_send_data+0x144>
4000ba44:	cf9ff06f          	j	4000b73c <net_send_data+0x74>
		return -ENODATA;
4000ba48:	fc300793          	li	a5,-61
}
4000ba4c:	00078513          	mv	a0,a5
4000ba50:	00008067          	ret

4000ba54 <net_process_rx_packet>:
	pkt_len = net_pkt_get_len(pkt);
4000ba54:	00852783          	lw	a5,8(a0)
	while (buf) {
4000ba58:	00079663          	bnez	a5,4000ba64 <net_process_rx_packet+0x10>
	processing_data(pkt, is_loopback);
4000ba5c:	00000593          	li	a1,0
4000ba60:	b49ff06f          	j	4000b5a8 <processing_data>
		buf = buf->frags;
4000ba64:	0047a783          	lw	a5,4(a5)
4000ba68:	ff1ff06f          	j	4000ba58 <net_process_rx_packet+0x4>

4000ba6c <net_recv_data>:
	if (!pkt || !iface) {
4000ba6c:	0a058a63          	beqz	a1,4000bb20 <net_recv_data+0xb4>
{
4000ba70:	ff010113          	addi	sp,sp,-16
4000ba74:	00912223          	sw	s1,4(sp)
4000ba78:	00112623          	sw	ra,12(sp)
4000ba7c:	00050493          	mv	s1,a0
4000ba80:	00812423          	sw	s0,8(sp)
		return -EINVAL;
4000ba84:	fea00513          	li	a0,-22
	if (!pkt || !iface) {
4000ba88:	08048263          	beqz	s1,4000bb0c <net_recv_data+0xa0>
4000ba8c:	0085a783          	lw	a5,8(a1)
4000ba90:	00058413          	mv	s0,a1
		return -ENODATA;
4000ba94:	fc300513          	li	a0,-61
	return !pkt->buffer || !net_pkt_data(pkt) || pkt->buffer->len == 0;
4000ba98:	06078a63          	beqz	a5,4000bb0c <net_recv_data+0xa0>
4000ba9c:	00c7a703          	lw	a4,12(a5)
4000baa0:	06070663          	beqz	a4,4000bb0c <net_recv_data+0xa0>
4000baa4:	0107d783          	lhu	a5,16(a5)
4000baa8:	06078263          	beqz	a5,4000bb0c <net_recv_data+0xa0>
	return atomic_test_bit(iface->if_dev->flags, value);
4000baac:	0004a503          	lw	a0,0(s1)
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
4000bab0:	00c50513          	addi	a0,a0,12
4000bab4:	5341f0ef          	jal	ra,4002afe8 <atomic_get>
	if (!net_if_flag_is_set(iface, NET_IF_UP)) {
4000bab8:	00157793          	andi	a5,a0,1
		return -ENETDOWN;
4000babc:	f8d00513          	li	a0,-115
	if (!net_if_flag_is_set(iface, NET_IF_UP)) {
4000bac0:	04078663          	beqz	a5,4000bb0c <net_recv_data+0xa0>
				    (struct in6_addr *)NET_IPV6_HDR(pkt)->src);
}

static inline void net_pkt_set_overwrite(struct net_pkt *pkt, bool overwrite)
{
	pkt->overwrite = overwrite;
4000bac4:	03744783          	lbu	a5,55(s0)
	net_pkt_cursor_init(pkt);
4000bac8:	00040513          	mv	a0,s0
4000bacc:	0017e793          	ori	a5,a5,1
4000bad0:	02f40ba3          	sb	a5,55(s0)
4000bad4:	71c070ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	pkt->iface = iface;
4000bad8:	00942c23          	sw	s1,24(s0)
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
4000badc:	0004a783          	lw	a5,0(s1)
	uint8_t tc = net_rx_priority2tc(prio);
4000bae0:	04144503          	lbu	a0,65(s0)
4000bae4:	0157c783          	lbu	a5,21(a5)
4000bae8:	02f404a3          	sb	a5,41(s0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
4000baec:	0004a783          	lw	a5,0(s1)
4000baf0:	0157c783          	lbu	a5,21(a5)
4000baf4:	02f408a3          	sb	a5,49(s0)
4000baf8:	570080ef          	jal	ra,40014068 <net_rx_priority2tc>
		net_tc_submit_to_rx_queue(tc, pkt);
4000bafc:	0ff57513          	zext.b	a0,a0
4000bb00:	00040593          	mv	a1,s0
4000bb04:	544080ef          	jal	ra,40014048 <net_tc_submit_to_rx_queue>
	return 0;
4000bb08:	00000513          	li	a0,0
}
4000bb0c:	00c12083          	lw	ra,12(sp)
4000bb10:	00812403          	lw	s0,8(sp)
4000bb14:	00412483          	lw	s1,4(sp)
4000bb18:	01010113          	addi	sp,sp,16
4000bb1c:	00008067          	ret
		return -EINVAL;
4000bb20:	fea00513          	li	a0,-22
}
4000bb24:	00008067          	ret

4000bb28 <sys_slist_append>:
	parent->next = child;
4000bb28:	0005a023          	sw	zero,0(a1)
	return list->tail;
4000bb2c:	00452783          	lw	a5,4(a0)
Z_GENLIST_APPEND(slist, snode)
4000bb30:	00079863          	bnez	a5,4000bb40 <sys_slist_append+0x18>
	list->tail = node;
4000bb34:	00b52223          	sw	a1,4(a0)
	list->head = node;
4000bb38:	00b52023          	sw	a1,0(a0)
}
4000bb3c:	00008067          	ret
	parent->next = child;
4000bb40:	00b7a023          	sw	a1,0(a5)
	list->tail = node;
4000bb44:	00b52223          	sw	a1,4(a0)
Z_GENLIST_APPEND(slist, snode)
4000bb48:	00008067          	ret

4000bb4c <sys_slist_find_and_remove>:
	return list->head;
4000bb4c:	00052783          	lw	a5,0(a0)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4000bb50:	00000713          	li	a4,0
4000bb54:	00079663          	bnez	a5,4000bb60 <sys_slist_find_and_remove+0x14>
4000bb58:	00000513          	li	a0,0
4000bb5c:	00008067          	ret
4000bb60:	02b79e63          	bne	a5,a1,4000bb9c <sys_slist_find_and_remove+0x50>
	return node->next;
4000bb64:	0005a783          	lw	a5,0(a1)
Z_GENLIST_REMOVE(slist, snode)
4000bb68:	02071063          	bnez	a4,4000bb88 <sys_slist_find_and_remove+0x3c>
4000bb6c:	00452703          	lw	a4,4(a0)
	list->head = node;
4000bb70:	00f52023          	sw	a5,0(a0)
Z_GENLIST_REMOVE(slist, snode)
4000bb74:	00e59463          	bne	a1,a4,4000bb7c <sys_slist_find_and_remove+0x30>
	list->tail = node;
4000bb78:	00f52223          	sw	a5,4(a0)
	parent->next = child;
4000bb7c:	0005a023          	sw	zero,0(a1)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4000bb80:	00100513          	li	a0,1
Z_GENLIST_REMOVE(slist, snode)
4000bb84:	00008067          	ret
	parent->next = child;
4000bb88:	00f72023          	sw	a5,0(a4)
Z_GENLIST_REMOVE(slist, snode)
4000bb8c:	00452783          	lw	a5,4(a0)
4000bb90:	fef596e3          	bne	a1,a5,4000bb7c <sys_slist_find_and_remove+0x30>
	list->tail = node;
4000bb94:	00e52223          	sw	a4,4(a0)
}
4000bb98:	fe5ff06f          	j	4000bb7c <sys_slist_find_and_remove+0x30>
	return node->next;
4000bb9c:	00078713          	mv	a4,a5
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4000bba0:	0007a783          	lw	a5,0(a5)
4000bba4:	fb1ff06f          	j	4000bb54 <sys_slist_find_and_remove+0x8>

4000bba8 <net_ipv6_is_addr_loopback>:
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4000bba8:	00154703          	lbu	a4,1(a0)
4000bbac:	00054683          	lbu	a3,0(a0)
{
4000bbb0:	00050793          	mv	a5,a0
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4000bbb4:	00871713          	slli	a4,a4,0x8
4000bbb8:	00d76733          	or	a4,a4,a3
4000bbbc:	00254683          	lbu	a3,2(a0)
4000bbc0:	01069693          	slli	a3,a3,0x10
4000bbc4:	00e6e6b3          	or	a3,a3,a4
4000bbc8:	00354703          	lbu	a4,3(a0)
4000bbcc:	01871713          	slli	a4,a4,0x18
4000bbd0:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000bbd4:	0c071263          	bnez	a4,4000bc98 <net_ipv6_is_addr_loopback+0xf0>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4000bbd8:	00554703          	lbu	a4,5(a0)
4000bbdc:	00454683          	lbu	a3,4(a0)
4000bbe0:	00871713          	slli	a4,a4,0x8
4000bbe4:	00d76733          	or	a4,a4,a3
4000bbe8:	00654683          	lbu	a3,6(a0)
4000bbec:	01069693          	slli	a3,a3,0x10
4000bbf0:	00e6e6b3          	or	a3,a3,a4
4000bbf4:	00754703          	lbu	a4,7(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000bbf8:	00000513          	li	a0,0
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4000bbfc:	01871713          	slli	a4,a4,0x18
4000bc00:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4000bc04:	08071c63          	bnez	a4,4000bc9c <net_ipv6_is_addr_loopback+0xf4>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000bc08:	0097c703          	lbu	a4,9(a5)
4000bc0c:	0087c683          	lbu	a3,8(a5)
4000bc10:	00871713          	slli	a4,a4,0x8
4000bc14:	00d76733          	or	a4,a4,a3
4000bc18:	00a7c683          	lbu	a3,10(a5)
4000bc1c:	01069693          	slli	a3,a3,0x10
4000bc20:	00e6e6b3          	or	a3,a3,a4
4000bc24:	00b7c703          	lbu	a4,11(a5)
4000bc28:	01871713          	slli	a4,a4,0x18
4000bc2c:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4000bc30:	06071663          	bnez	a4,4000bc9c <net_ipv6_is_addr_loopback+0xf4>
		ntohl(UNALIGNED_GET(&addr->s6_addr32[3])) == 1;
4000bc34:	00d7c683          	lbu	a3,13(a5)
4000bc38:	00c7c703          	lbu	a4,12(a5)
4000bc3c:	00869693          	slli	a3,a3,0x8
4000bc40:	00e6e6b3          	or	a3,a3,a4
4000bc44:	00e7c703          	lbu	a4,14(a5)
4000bc48:	00f7c783          	lbu	a5,15(a5)
4000bc4c:	01071713          	slli	a4,a4,0x10
4000bc50:	01879793          	slli	a5,a5,0x18
4000bc54:	00d76733          	or	a4,a4,a3
4000bc58:	00e7e6b3          	or	a3,a5,a4
4000bc5c:	0187d513          	srli	a0,a5,0x18
4000bc60:	01871713          	slli	a4,a4,0x18
4000bc64:	00e56533          	or	a0,a0,a4
4000bc68:	00010737          	lui	a4,0x10
4000bc6c:	0086d793          	srli	a5,a3,0x8
4000bc70:	f0070713          	addi	a4,a4,-256 # ff00 <__kernel_ram_size+0x3c6c>
4000bc74:	00e7f7b3          	and	a5,a5,a4
4000bc78:	00f56533          	or	a0,a0,a5
4000bc7c:	00869693          	slli	a3,a3,0x8
4000bc80:	00ff07b7          	lui	a5,0xff0
4000bc84:	00f6f6b3          	and	a3,a3,a5
4000bc88:	00d56533          	or	a0,a0,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4000bc8c:	fff50513          	addi	a0,a0,-1
4000bc90:	00153513          	seqz	a0,a0
4000bc94:	00008067          	ret
4000bc98:	00000513          	li	a0,0
}
4000bc9c:	00008067          	ret

4000bca0 <net_ipv4_is_ll_addr>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xFFFF0000) == 0xA9FE0000;
4000bca0:	00154783          	lbu	a5,1(a0)
4000bca4:	00054703          	lbu	a4,0(a0)
4000bca8:	00879793          	slli	a5,a5,0x8
4000bcac:	00e7e7b3          	or	a5,a5,a4
4000bcb0:	00254703          	lbu	a4,2(a0)
4000bcb4:	01071713          	slli	a4,a4,0x10
4000bcb8:	00f76733          	or	a4,a4,a5
4000bcbc:	00354783          	lbu	a5,3(a0)
4000bcc0:	01879793          	slli	a5,a5,0x18
4000bcc4:	00e7e6b3          	or	a3,a5,a4
4000bcc8:	0187d513          	srli	a0,a5,0x18
4000bccc:	01871713          	slli	a4,a4,0x18
4000bcd0:	00e56533          	or	a0,a0,a4
4000bcd4:	00010737          	lui	a4,0x10
4000bcd8:	0086d793          	srli	a5,a3,0x8
4000bcdc:	f0070713          	addi	a4,a4,-256 # ff00 <__kernel_ram_size+0x3c6c>
4000bce0:	00e7f7b3          	and	a5,a5,a4
4000bce4:	00f56533          	or	a0,a0,a5
4000bce8:	00869693          	slli	a3,a3,0x8
4000bcec:	00ff07b7          	lui	a5,0xff0
4000bcf0:	00f6f6b3          	and	a3,a3,a5
4000bcf4:	00d56533          	or	a0,a0,a3
4000bcf8:	ffff07b7          	lui	a5,0xffff0
4000bcfc:	00f57533          	and	a0,a0,a5
4000bd00:	560207b7          	lui	a5,0x56020
4000bd04:	00f50533          	add	a0,a0,a5
}
4000bd08:	00153513          	seqz	a0,a0
4000bd0c:	00008067          	ret

4000bd10 <net_if_l2>:
	if (!iface || !iface->if_dev) {
4000bd10:	00050863          	beqz	a0,4000bd20 <net_if_l2+0x10>
4000bd14:	00052503          	lw	a0,0(a0)
4000bd18:	00050463          	beqz	a0,4000bd20 <net_if_l2+0x10>
	return iface->if_dev->l2;
4000bd1c:	00452503          	lw	a0,4(a0)
}
4000bd20:	00008067          	ret

4000bd24 <net_context_send_cb>:
#endif

static inline void net_context_send_cb(struct net_context *context,
				       int status)
{
	if (!context) {
4000bd24:	00050a63          	beqz	a0,4000bd38 <net_context_send_cb+0x14>
		return;
	}

	if (context->send_cb) {
4000bd28:	04c52703          	lw	a4,76(a0)
4000bd2c:	00070663          	beqz	a4,4000bd38 <net_context_send_cb+0x14>
		context->send_cb(context, status, context->user_data);
4000bd30:	00452603          	lw	a2,4(a0)
4000bd34:	00070067          	jr	a4
		net_stats_update_udp_sent(net_context_get_iface(context));
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
		   net_context_get_proto(context) == IPPROTO_TCP) {
		net_stats_update_tcp_seg_sent(net_context_get_iface(context));
	}
}
4000bd38:	00008067          	ret

4000bd3c <l2_flags_get>:

	return NULL;
}

static enum net_l2_flags l2_flags_get(struct net_if *iface)
{
4000bd3c:	ff010113          	addi	sp,sp,-16
4000bd40:	00812423          	sw	s0,8(sp)
4000bd44:	00112623          	sw	ra,12(sp)
4000bd48:	00050413          	mv	s0,a0
	enum net_l2_flags flags = 0;

	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
4000bd4c:	fc5ff0ef          	jal	ra,4000bd10 <net_if_l2>
4000bd50:	02050063          	beqz	a0,4000bd70 <l2_flags_get+0x34>
4000bd54:	00c52783          	lw	a5,12(a0)
4000bd58:	00078c63          	beqz	a5,4000bd70 <l2_flags_get+0x34>
		flags = net_if_l2(iface)->get_flags(iface);
4000bd5c:	00040513          	mv	a0,s0
	}

	return flags;
}
4000bd60:	00812403          	lw	s0,8(sp)
4000bd64:	00c12083          	lw	ra,12(sp)
4000bd68:	01010113          	addi	sp,sp,16
		flags = net_if_l2(iface)->get_flags(iface);
4000bd6c:	00078067          	jr	a5 # 56020000 <__data_region_end+0x15fe338c>
}
4000bd70:	00c12083          	lw	ra,12(sp)
4000bd74:	00812403          	lw	s0,8(sp)
4000bd78:	00000513          	li	a0,0
4000bd7c:	01010113          	addi	sp,sp,16
4000bd80:	00008067          	ret

4000bd84 <get_ipaddr_diff>:

#if defined(CONFIG_NET_NATIVE_IPV4) || defined(CONFIG_NET_NATIVE_IPV6)
/* Return how many bits are shared between two IP addresses */
static uint8_t get_ipaddr_diff(const uint8_t *src, const uint8_t *dst, int addr_len)
{
4000bd84:	00050693          	mv	a3,a0
	uint8_t j, k, xor;
	uint8_t len = 0U;

	for (j = 0U; j < addr_len; j++) {
4000bd88:	00000713          	li	a4,0
4000bd8c:	00371793          	slli	a5,a4,0x3
4000bd90:	0ff7f513          	zext.b	a0,a5
4000bd94:	06c75063          	bge	a4,a2,4000bdf4 <get_ipaddr_diff+0x70>
		if (src[j] == dst[j]) {
4000bd98:	00e687b3          	add	a5,a3,a4
4000bd9c:	00e58833          	add	a6,a1,a4
4000bda0:	0007c783          	lbu	a5,0(a5)
4000bda4:	00084803          	lbu	a6,0(a6)
4000bda8:	01079863          	bne	a5,a6,4000bdb8 <get_ipaddr_diff+0x34>
	for (j = 0U; j < addr_len; j++) {
4000bdac:	00170713          	addi	a4,a4,1
4000bdb0:	0ff77713          	zext.b	a4,a4
4000bdb4:	fd9ff06f          	j	4000bd8c <get_ipaddr_diff+0x8>
			len += 8U;
		} else {
			xor = src[j] ^ dst[j];
4000bdb8:	0107c7b3          	xor	a5,a5,a6
			for (k = 0U; k < 8; k++) {
				if (!(xor & 0x80)) {
4000bdbc:	01879713          	slli	a4,a5,0x18
4000bdc0:	41875713          	srai	a4,a4,0x18
4000bdc4:	02074863          	bltz	a4,4000bdf4 <get_ipaddr_diff+0x70>
4000bdc8:	00850713          	addi	a4,a0,8
4000bdcc:	0ff77713          	zext.b	a4,a4
					len++;
4000bdd0:	00150513          	addi	a0,a0,1
					xor <<= 1;
4000bdd4:	00179793          	slli	a5,a5,0x1
					len++;
4000bdd8:	0ff57513          	zext.b	a0,a0
					xor <<= 1;
4000bddc:	0ff7f793          	zext.b	a5,a5
			for (k = 0U; k < 8; k++) {
4000bde0:	00e51463          	bne	a0,a4,4000bde8 <get_ipaddr_diff+0x64>
4000bde4:	00008067          	ret
				if (!(xor & 0x80)) {
4000bde8:	01879693          	slli	a3,a5,0x18
4000bdec:	4186d693          	srai	a3,a3,0x18
4000bdf0:	fe06d0e3          	bgez	a3,4000bdd0 <get_ipaddr_diff+0x4c>
			break;
		}
	}

	return len;
}
4000bdf4:	00008067          	ret

4000bdf8 <net_ipv6_is_prefix>:
	if (length > 128) {
4000bdf8:	08000793          	li	a5,128
4000bdfc:	02c7f663          	bgeu	a5,a2,4000be28 <net_ipv6_is_prefix+0x30>
		return false;
4000be00:	00000513          	li	a0,0
}
4000be04:	00008067          	ret
		return false;
4000be08:	00000513          	li	a0,0
}
4000be0c:	01c12083          	lw	ra,28(sp)
4000be10:	01812403          	lw	s0,24(sp)
4000be14:	01412483          	lw	s1,20(sp)
4000be18:	01012903          	lw	s2,16(sp)
4000be1c:	00c12983          	lw	s3,12(sp)
4000be20:	02010113          	addi	sp,sp,32
4000be24:	00008067          	ret
{
4000be28:	fe010113          	addi	sp,sp,-32
4000be2c:	01312623          	sw	s3,12(sp)
	if (memcmp(addr1, addr2, bytes)) {
4000be30:	00365993          	srli	s3,a2,0x3
{
4000be34:	00812c23          	sw	s0,24(sp)
4000be38:	00060413          	mv	s0,a2
	if (memcmp(addr1, addr2, bytes)) {
4000be3c:	00098613          	mv	a2,s3
{
4000be40:	00912a23          	sw	s1,20(sp)
4000be44:	01212823          	sw	s2,16(sp)
4000be48:	00112e23          	sw	ra,28(sp)
4000be4c:	00050913          	mv	s2,a0
4000be50:	00058493          	mv	s1,a1
	if (memcmp(addr1, addr2, bytes)) {
4000be54:	978fd0ef          	jal	ra,40008fcc <memcmp>
4000be58:	fa0518e3          	bnez	a0,4000be08 <net_ipv6_is_prefix+0x10>
4000be5c:	40800433          	neg	s0,s0
4000be60:	00747413          	andi	s0,s0,7
		return true;
4000be64:	00100513          	li	a0,1
	if (!remain) {
4000be68:	fa0402e3          	beqz	s0,4000be0c <net_ipv6_is_prefix+0x14>
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
4000be6c:	01390933          	add	s2,s2,s3
4000be70:	013484b3          	add	s1,s1,s3
4000be74:	0004c783          	lbu	a5,0(s1)
4000be78:	00094503          	lbu	a0,0(s2)
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
4000be7c:	00800713          	li	a4,8
4000be80:	40870733          	sub	a4,a4,s0
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
4000be84:	00f54533          	xor	a0,a0,a5
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
4000be88:	0ff00793          	li	a5,255
4000be8c:	00e797b3          	sll	a5,a5,a4
4000be90:	0ff7c793          	xori	a5,a5,255
4000be94:	008797b3          	sll	a5,a5,s0
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
4000be98:	00f57533          	and	a0,a0,a5
4000be9c:	00153513          	seqz	a0,a0
4000bea0:	f6dff06f          	j	4000be0c <net_ipv6_is_prefix+0x14>

4000bea4 <net_ipv6_addr_cmp>:
{
4000bea4:	ff010113          	addi	sp,sp,-16
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4000bea8:	01000613          	li	a2,16
{
4000beac:	00112623          	sw	ra,12(sp)
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4000beb0:	91cfd0ef          	jal	ra,40008fcc <memcmp>
}
4000beb4:	00c12083          	lw	ra,12(sp)
4000beb8:	00153513          	seqz	a0,a0
4000bebc:	01010113          	addi	sp,sp,16
4000bec0:	00008067          	ret

4000bec4 <k_uptime_get_32>:
{
4000bec4:	ff010113          	addi	sp,sp,-16
4000bec8:	00112623          	sw	ra,12(sp)
	return z_impl_k_uptime_ticks();
4000becc:	4e91e0ef          	jal	ra,4002abb4 <z_impl_k_uptime_ticks>
}
4000bed0:	00c12083          	lw	ra,12(sp)
4000bed4:	00a00793          	li	a5,10
4000bed8:	02a78533          	mul	a0,a5,a0
4000bedc:	01010113          	addi	sp,sp,16
4000bee0:	00008067          	ret

4000bee4 <atomic_clear_bit>:
 * @param target Address of atomic variable or array.
 * @param bit Bit number (starting from 0).
 */
static inline void atomic_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
4000bee4:	00100713          	li	a4,1

	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
4000bee8:	0055d793          	srli	a5,a1,0x5
	atomic_val_t mask = ATOMIC_MASK(bit);
4000beec:	00b71733          	sll	a4,a4,a1
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
4000bef0:	00279793          	slli	a5,a5,0x2
	return z_impl_atomic_and(target, value);
4000bef4:	fff74593          	not	a1,a4
4000bef8:	00f50533          	add	a0,a0,a5
4000befc:	1301f06f          	j	4002b02c <z_impl_atomic_and>

4000bf00 <iface_router_notify_deletion.constprop.0>:

static void iface_router_notify_deletion(struct net_if_router *router,
					 const char *delete_reason)
{
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
	    router->address.family == AF_INET6) {
4000bf00:	00455783          	lhu	a5,4(a0)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
4000bf04:	00200713          	li	a4,2
4000bf08:	00e79e63          	bne	a5,a4,4000bf24 <iface_router_notify_deletion.constprop.0+0x24>
		NET_DBG("IPv6 router %s %s",
			net_sprint_ipv6_addr(net_if_router_ipv6(router)),
			delete_reason);

		net_mgmt_event_notify_with_info(NET_EVENT_IPV6_ROUTER_DEL,
4000bf0c:	01852583          	lw	a1,24(a0)
4000bf10:	00850613          	addi	a2,a0,8
4000bf14:	e0600537          	lui	a0,0xe0600
4000bf18:	01000693          	li	a3,16
4000bf1c:	00a50513          	addi	a0,a0,10 # e060000a <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000b>
		   router->address.family == AF_INET) {
		NET_DBG("IPv4 router %s %s",
			net_sprint_ipv4_addr(net_if_router_ipv4(router)),
			delete_reason);

		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ROUTER_DEL,
4000bf20:	0100506f          	j	40010f30 <net_mgmt_event_notify_with_info>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
4000bf24:	00100713          	li	a4,1
4000bf28:	00e79e63          	bne	a5,a4,4000bf44 <iface_router_notify_deletion.constprop.0+0x44>
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ROUTER_DEL,
4000bf2c:	01852583          	lw	a1,24(a0)
4000bf30:	00850613          	addi	a2,a0,8
4000bf34:	e0040537          	lui	a0,0xe0040
4000bf38:	01000693          	li	a3,16
4000bf3c:	00650513          	addi	a0,a0,6 # e0040006 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0040007>
4000bf40:	fe1ff06f          	j	4000bf20 <iface_router_notify_deletion.constprop.0+0x20>
						router->iface,
						&router->address.in_addr,
						sizeof(struct in6_addr));
	}
}
4000bf44:	00008067          	ret

4000bf48 <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
4000bf48:	00058613          	mv	a2,a1
4000bf4c:	00050593          	mv	a1,a0
	return z_impl_k_mutex_lock(mutex, timeout);
4000bf50:	4003d537          	lui	a0,0x4003d
4000bf54:	ab050513          	addi	a0,a0,-1360 # 4003cab0 <lock>
4000bf58:	1251c06f          	j	4002887c <z_impl_k_mutex_lock>

4000bf5c <k_mutex_unlock.constprop.0.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
4000bf5c:	4003d537          	lui	a0,0x4003d
4000bf60:	ab050513          	addi	a0,a0,-1360 # 4003cab0 <lock>
4000bf64:	2751c06f          	j	400289d8 <z_impl_k_mutex_unlock>

4000bf68 <if_ipv4_get_addr>:
	return src;
}

static struct in_addr *if_ipv4_get_addr(struct net_if *iface,
					enum net_addr_state addr_state, bool ll)
{
4000bf68:	ff010113          	addi	sp,sp,-16
4000bf6c:	00812423          	sw	s0,8(sp)
4000bf70:	00912223          	sw	s1,4(sp)
4000bf74:	00050413          	mv	s0,a0
4000bf78:	00058493          	mv	s1,a1
	struct in_addr *addr = NULL;
	struct net_if_ipv4 *ipv4;
	int i;

	k_mutex_lock(&lock, K_FOREVER);
4000bf7c:	fff00513          	li	a0,-1
4000bf80:	fff00593          	li	a1,-1
{
4000bf84:	01212023          	sw	s2,0(sp)
4000bf88:	00112623          	sw	ra,12(sp)
4000bf8c:	00060913          	mv	s2,a2
	k_mutex_lock(&lock, K_FOREVER);
4000bf90:	fb9ff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>

	if (!iface) {
4000bf94:	00040663          	beqz	s0,4000bfa0 <if_ipv4_get_addr+0x38>
		goto out;
	}

	ipv4 = iface->config.ip.ipv4;
4000bf98:	00842403          	lw	s0,8(s0)
	if (!ipv4) {
4000bf9c:	02041663          	bnez	s0,4000bfc8 <if_ipv4_get_addr+0x60>
		addr = &ipv4->unicast[i].address.in_addr;
		goto out;
	}

out:
	k_mutex_unlock(&lock);
4000bfa0:	fbdff0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>

	return addr;
}
4000bfa4:	00c12083          	lw	ra,12(sp)
4000bfa8:	00040513          	mv	a0,s0
4000bfac:	00812403          	lw	s0,8(sp)
4000bfb0:	00412483          	lw	s1,4(sp)
4000bfb4:	00012903          	lw	s2,0(sp)
4000bfb8:	01010113          	addi	sp,sp,16
4000bfbc:	00008067          	ret
			if (ll) {
4000bfc0:	fe0900e3          	beqz	s2,4000bfa0 <if_ipv4_get_addr+0x38>
4000bfc4:	0440006f          	j	4000c008 <if_ipv4_get_addr+0xa0>
		if (!ipv4->unicast[i].is_used ||
4000bfc8:	02c42783          	lw	a5,44(s0)
4000bfcc:	0197d793          	srli	a5,a5,0x19
4000bfd0:	0017f793          	andi	a5,a5,1
4000bfd4:	02078a63          	beqz	a5,4000c008 <if_ipv4_get_addr+0xa0>
4000bfd8:	fff00793          	li	a5,-1
4000bfdc:	00f48663          	beq	s1,a5,4000bfe8 <if_ipv4_get_addr+0x80>
		    (addr_state != NET_ADDR_ANY_STATE &&
4000bfe0:	02d40783          	lb	a5,45(s0)
4000bfe4:	02979263          	bne	a5,s1,4000c008 <if_ipv4_get_addr+0xa0>
		     ipv4->unicast[i].addr_state != addr_state) ||
4000bfe8:	00045703          	lhu	a4,0(s0)
4000bfec:	00100793          	li	a5,1
4000bff0:	00f71c63          	bne	a4,a5,4000c008 <if_ipv4_get_addr+0xa0>
		if (net_ipv4_is_ll_addr(&ipv4->unicast[i].address.in_addr)) {
4000bff4:	00440413          	addi	s0,s0,4
4000bff8:	00040513          	mv	a0,s0
4000bffc:	ca5ff0ef          	jal	ra,4000bca0 <net_ipv4_is_ll_addr>
4000c000:	fc0500e3          	beqz	a0,4000bfc0 <if_ipv4_get_addr+0x58>
			if (!ll) {
4000c004:	f8091ee3          	bnez	s2,4000bfa0 <if_ipv4_get_addr+0x38>
	struct in_addr *addr = NULL;
4000c008:	00000413          	li	s0,0
4000c00c:	f95ff06f          	j	4000bfa0 <if_ipv4_get_addr+0x38>

4000c010 <iface_router_lookup>:
{
4000c010:	fd010113          	addi	sp,sp,-48
4000c014:	01412c23          	sw	s4,24(sp)
4000c018:	01512a23          	sw	s5,20(sp)
4000c01c:	00058a13          	mv	s4,a1
4000c020:	00050a93          	mv	s5,a0
	k_mutex_lock(&lock, K_FOREVER);
4000c024:	fff00593          	li	a1,-1
4000c028:	fff00513          	li	a0,-1
{
4000c02c:	02812423          	sw	s0,40(sp)
4000c030:	02912223          	sw	s1,36(sp)
4000c034:	03212023          	sw	s2,32(sp)
4000c038:	01312e23          	sw	s3,28(sp)
4000c03c:	02112623          	sw	ra,44(sp)
		if (!routers[i].is_used ||
4000c040:	400329b7          	lui	s3,0x40032
{
4000c044:	00060493          	mv	s1,a2
	k_mutex_lock(&lock, K_FOREVER);
4000c048:	f01ff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
		if (!routers[i].is_used ||
4000c04c:	e0c98793          	addi	a5,s3,-500 # 40031e0c <routers>
4000c050:	0227d783          	lhu	a5,34(a5)
4000c054:	40032437          	lui	s0,0x40032
4000c058:	e1440413          	addi	s0,s0,-492 # 40031e14 <routers+0x8>
4000c05c:	0017f793          	andi	a5,a5,1
4000c060:	e0c98993          	addi	s3,s3,-500
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
4000c064:	00000913          	li	s2,0
		if (!routers[i].is_used ||
4000c068:	08078c63          	beqz	a5,4000c100 <iface_router_lookup+0xf0>
4000c06c:	ffc45783          	lhu	a5,-4(s0)
4000c070:	09479863          	bne	a5,s4,4000c100 <iface_router_lookup+0xf0>
		    routers[i].address.family != family ||
4000c074:	01042783          	lw	a5,16(s0)
4000c078:	09579463          	bne	a5,s5,4000c100 <iface_router_lookup+0xf0>
		if ((IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6 &&
4000c07c:	00200793          	li	a5,2
4000c080:	06fa0863          	beq	s4,a5,4000c0f0 <iface_router_lookup+0xe0>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000c084:	0014c783          	lbu	a5,1(s1)
4000c088:	0004c703          	lbu	a4,0(s1)
4000c08c:	00879793          	slli	a5,a5,0x8
4000c090:	00e7e7b3          	or	a5,a5,a4
4000c094:	0024c703          	lbu	a4,2(s1)
4000c098:	01071713          	slli	a4,a4,0x10
4000c09c:	00f76733          	or	a4,a4,a5
4000c0a0:	0034c783          	lbu	a5,3(s1)
4000c0a4:	01879793          	slli	a5,a5,0x18
4000c0a8:	00e7e7b3          	or	a5,a5,a4
		    (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET &&
4000c0ac:	00042703          	lw	a4,0(s0)
4000c0b0:	04e79863          	bne	a5,a4,4000c100 <iface_router_lookup+0xf0>
			router = &routers[i];
4000c0b4:	02400793          	li	a5,36
4000c0b8:	02f90933          	mul	s2,s2,a5
4000c0bc:	01298533          	add	a0,s3,s2
			goto out;
4000c0c0:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000c0c4:	e99ff0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000c0c8:	02c12083          	lw	ra,44(sp)
4000c0cc:	02812403          	lw	s0,40(sp)
4000c0d0:	00c12503          	lw	a0,12(sp)
4000c0d4:	02412483          	lw	s1,36(sp)
4000c0d8:	02012903          	lw	s2,32(sp)
4000c0dc:	01c12983          	lw	s3,28(sp)
4000c0e0:	01812a03          	lw	s4,24(sp)
4000c0e4:	01412a83          	lw	s5,20(sp)
4000c0e8:	03010113          	addi	sp,sp,48
4000c0ec:	00008067          	ret
		     net_ipv6_addr_cmp(net_if_router_ipv6(&routers[i]),
4000c0f0:	00048593          	mv	a1,s1
4000c0f4:	00040513          	mv	a0,s0
4000c0f8:	dadff0ef          	jal	ra,4000bea4 <net_ipv6_addr_cmp>
		if ((IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6 &&
4000c0fc:	fa051ce3          	bnez	a0,4000c0b4 <iface_router_lookup+0xa4>
	struct net_if_router *router = NULL;
4000c100:	00000513          	li	a0,0
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
4000c104:	fa091ee3          	bnez	s2,4000c0c0 <iface_router_lookup+0xb0>
		if (!routers[i].is_used ||
4000c108:	0469d783          	lhu	a5,70(s3)
4000c10c:	0017f793          	andi	a5,a5,1
4000c110:	fa0788e3          	beqz	a5,4000c0c0 <iface_router_lookup+0xb0>
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
4000c114:	02440413          	addi	s0,s0,36
4000c118:	00100913          	li	s2,1
4000c11c:	f51ff06f          	j	4000c06c <iface_router_lookup+0x5c>

4000c120 <iface_router_update_timer>:
{
4000c120:	ff010113          	addi	sp,sp,-16
4000c124:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000c128:	fff00593          	li	a1,-1
{
4000c12c:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000c130:	fff00513          	li	a0,-1
{
4000c134:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000c138:	e11ff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4000c13c:	400317b7          	lui	a5,0x40031
4000c140:	a647a703          	lw	a4,-1436(a5) # 40030a64 <active_router_timers>
4000c144:	00000693          	li	a3,0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
4000c148:	00070463          	beqz	a4,4000c150 <iface_router_update_timer+0x30>
	return node->next;
4000c14c:	00072683          	lw	a3,0(a4)
4000c150:	fff00513          	li	a0,-1
	ends += MSEC_PER_SEC * router->lifetime;
4000c154:	3e800613          	li	a2,1000
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
4000c158:	02071463          	bnez	a4,4000c180 <iface_router_update_timer+0x60>
	if (new_delay == UINT32_MAX) {
4000c15c:	fff00793          	li	a5,-1
4000c160:	04f51e63          	bne	a0,a5,4000c1bc <iface_router_update_timer+0x9c>
		k_work_cancel_delayable(&router_timer);
4000c164:	40031537          	lui	a0,0x40031
4000c168:	e9850513          	addi	a0,a0,-360 # 40030e98 <router_timer>
4000c16c:	4d01d0ef          	jal	ra,4002963c <k_work_cancel_delayable>
}
4000c170:	00812403          	lw	s0,8(sp)
4000c174:	00c12083          	lw	ra,12(sp)
4000c178:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
4000c17c:	de1ff06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>
	return (int32_t)(ends - now);
4000c180:	01c72783          	lw	a5,28(a4)
	ends += MSEC_PER_SEC * router->lifetime;
4000c184:	02075703          	lhu	a4,32(a4)
	return (int32_t)(ends - now);
4000c188:	408787b3          	sub	a5,a5,s0
	ends += MSEC_PER_SEC * router->lifetime;
4000c18c:	02c70733          	mul	a4,a4,a2
	return (int32_t)(ends - now);
4000c190:	00e787b3          	add	a5,a5,a4
		if (ends <= 0) {
4000c194:	02f05263          	blez	a5,4000c1b8 <iface_router_update_timer+0x98>
		new_delay = MIN((uint32_t)ends, new_delay);
4000c198:	00a7f463          	bgeu	a5,a0,4000c1a0 <iface_router_update_timer+0x80>
4000c19c:	00078513          	mv	a0,a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
4000c1a0:	00000793          	li	a5,0
4000c1a4:	00068463          	beqz	a3,4000c1ac <iface_router_update_timer+0x8c>
4000c1a8:	0006a783          	lw	a5,0(a3)
4000c1ac:	00068713          	mv	a4,a3
4000c1b0:	00078693          	mv	a3,a5
4000c1b4:	fa5ff06f          	j	4000c158 <iface_router_update_timer+0x38>
			new_delay = 0;
4000c1b8:	00000513          	li	a0,0
4000c1bc:	00a00613          	li	a2,10
4000c1c0:	00000693          	li	a3,0
4000c1c4:	00950513          	addi	a0,a0,9
4000c1c8:	00000593          	li	a1,0
4000c1cc:	8ecf40ef          	jal	ra,400002b8 <__udivdi3>
		k_work_reschedule(&router_timer, K_MSEC(new_delay));
4000c1d0:	00058613          	mv	a2,a1
4000c1d4:	00050593          	mv	a1,a0
4000c1d8:	40031537          	lui	a0,0x40031
4000c1dc:	e9850513          	addi	a0,a0,-360 # 40030e98 <router_timer>
4000c1e0:	4441d0ef          	jal	ra,40029624 <k_work_reschedule>
4000c1e4:	f8dff06f          	j	4000c170 <iface_router_update_timer+0x50>

4000c1e8 <iface_router_add>:
{
4000c1e8:	fd010113          	addi	sp,sp,-48
4000c1ec:	01412c23          	sw	s4,24(sp)
4000c1f0:	01712623          	sw	s7,12(sp)
4000c1f4:	00050a13          	mv	s4,a0
4000c1f8:	00058b93          	mv	s7,a1
	k_mutex_lock(&lock, K_FOREVER);
4000c1fc:	fff00513          	li	a0,-1
4000c200:	fff00593          	li	a1,-1
{
4000c204:	03212023          	sw	s2,32(sp)
4000c208:	01312e23          	sw	s3,28(sp)
4000c20c:	01512a23          	sw	s5,20(sp)
4000c210:	01612823          	sw	s6,16(sp)
4000c214:	01812423          	sw	s8,8(sp)
		if (routers[i].is_used) {
4000c218:	40032937          	lui	s2,0x40032
{
4000c21c:	02112623          	sw	ra,44(sp)
4000c220:	02812423          	sw	s0,40(sp)
4000c224:	02912223          	sw	s1,36(sp)
4000c228:	00060b13          	mv	s6,a2
4000c22c:	00068993          	mv	s3,a3
4000c230:	00070c13          	mv	s8,a4
	k_mutex_lock(&lock, K_FOREVER);
4000c234:	d15ff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
		if (routers[i].is_used) {
4000c238:	e0c90793          	addi	a5,s2,-500 # 40031e0c <routers>
4000c23c:	0227d783          	lhu	a5,34(a5)
4000c240:	e0c90913          	addi	s2,s2,-500
4000c244:	00000a93          	li	s5,0
4000c248:	0017f793          	andi	a5,a5,1
4000c24c:	04078863          	beqz	a5,4000c29c <iface_router_add+0xb4>
4000c250:	04695783          	lhu	a5,70(s2)
	struct net_if_router *router = NULL;
4000c254:	00000413          	li	s0,0
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
4000c258:	00100a93          	li	s5,1
		if (routers[i].is_used) {
4000c25c:	0017f793          	andi	a5,a5,1
4000c260:	02078e63          	beqz	a5,4000c29c <iface_router_add+0xb4>
	k_mutex_unlock(&lock);
4000c264:	cf9ff0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000c268:	02c12083          	lw	ra,44(sp)
4000c26c:	00040513          	mv	a0,s0
4000c270:	02812403          	lw	s0,40(sp)
4000c274:	02412483          	lw	s1,36(sp)
4000c278:	02012903          	lw	s2,32(sp)
4000c27c:	01c12983          	lw	s3,28(sp)
4000c280:	01812a03          	lw	s4,24(sp)
4000c284:	01412a83          	lw	s5,20(sp)
4000c288:	01012b03          	lw	s6,16(sp)
4000c28c:	00c12b83          	lw	s7,12(sp)
4000c290:	00812c03          	lw	s8,8(sp)
4000c294:	03010113          	addi	sp,sp,48
4000c298:	00008067          	ret
		routers[i].is_used = true;
4000c29c:	02400493          	li	s1,36
4000c2a0:	029a84b3          	mul	s1,s5,s1
4000c2a4:	00990433          	add	s0,s2,s1
4000c2a8:	02244783          	lbu	a5,34(s0)
		routers[i].iface = iface;
4000c2ac:	01442c23          	sw	s4,24(s0)
		routers[i].address.family = family;
4000c2b0:	01741223          	sh	s7,4(s0)
		routers[i].is_used = true;
4000c2b4:	0017e793          	ori	a5,a5,1
4000c2b8:	02f40123          	sb	a5,34(s0)
		if (lifetime) {
4000c2bc:	060c0a63          	beqz	s8,4000c330 <iface_router_add+0x148>
			routers[i].is_default = true;
4000c2c0:	0ff7f793          	zext.b	a5,a5
4000c2c4:	ff97f793          	andi	a5,a5,-7
4000c2c8:	0027e793          	ori	a5,a5,2
4000c2cc:	02f40123          	sb	a5,34(s0)
			routers[i].lifetime = lifetime;
4000c2d0:	03841023          	sh	s8,32(s0)
			routers[i].life_start = k_uptime_get_32();
4000c2d4:	bf1ff0ef          	jal	ra,4000bec4 <k_uptime_get_32>
4000c2d8:	00a42e23          	sw	a0,28(s0)
			sys_slist_append(&active_router_timers,
4000c2dc:	40031537          	lui	a0,0x40031
4000c2e0:	a6450513          	addi	a0,a0,-1436 # 40030a64 <active_router_timers>
4000c2e4:	00040593          	mv	a1,s0
4000c2e8:	841ff0ef          	jal	ra,4000bb28 <sys_slist_append>
			iface_router_update_timer(routers[i].life_start);
4000c2ec:	01c42503          	lw	a0,28(s0)
4000c2f0:	e31ff0ef          	jal	ra,4000c120 <iface_router_update_timer>
 * @return pointer to the IPv6 address, or NULL if none
 */
#if defined(CONFIG_NET_NATIVE_IPV6)
static inline struct in6_addr *net_if_router_ipv6(struct net_if_router *router)
{
	return &router->address.in6_addr;
4000c2f4:	00848493          	addi	s1,s1,8
		if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
4000c2f8:	00200793          	li	a5,2
4000c2fc:	009904b3          	add	s1,s2,s1
4000c300:	04fb9463          	bne	s7,a5,4000c348 <iface_router_add+0x160>
			memcpy(net_if_router_ipv6(&routers[i]), addr,
4000c304:	01000613          	li	a2,16
4000c308:	000b0593          	mv	a1,s6
4000c30c:	00048513          	mv	a0,s1
4000c310:	d3dfc0ef          	jal	ra,4000904c <memcpy>
			net_mgmt_event_notify_with_info(
4000c314:	e0600537          	lui	a0,0xe0600
4000c318:	01000693          	li	a3,16
4000c31c:	00048613          	mv	a2,s1
4000c320:	000a0593          	mv	a1,s4
4000c324:	00950513          	addi	a0,a0,9 # e0600009 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000a>
			net_mgmt_event_notify_with_info(
4000c328:	409040ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
		goto out;
4000c32c:	f39ff06f          	j	4000c264 <iface_router_add+0x7c>
			routers[i].is_default = false;
4000c330:	02244783          	lbu	a5,34(s0)
			routers[i].lifetime = 0;
4000c334:	02041023          	sh	zero,32(s0)
			routers[i].is_default = false;
4000c338:	ff97f793          	andi	a5,a5,-7
4000c33c:	0047e793          	ori	a5,a5,4
4000c340:	02f40123          	sb	a5,34(s0)
4000c344:	fb1ff06f          	j	4000c2f4 <iface_router_add+0x10c>
			memcpy(net_if_router_ipv4(&routers[i]), addr,
4000c348:	00400613          	li	a2,4
4000c34c:	000b0593          	mv	a1,s6
4000c350:	00048513          	mv	a0,s1
4000c354:	cf9fc0ef          	jal	ra,4000904c <memcpy>
			routers[i].is_default = is_default;
4000c358:	02400793          	li	a5,36
4000c35c:	02fa8ab3          	mul	s5,s5,a5
4000c360:	0019f993          	andi	s3,s3,1
4000c364:	00199993          	slli	s3,s3,0x1
			net_mgmt_event_notify_with_info(
4000c368:	e0040537          	lui	a0,0xe0040
4000c36c:	00400693          	li	a3,4
4000c370:	00048613          	mv	a2,s1
4000c374:	000a0593          	mv	a1,s4
4000c378:	00550513          	addi	a0,a0,5 # e0040005 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0040006>
			routers[i].is_default = is_default;
4000c37c:	01590933          	add	s2,s2,s5
4000c380:	02294783          	lbu	a5,34(s2)
4000c384:	ffd7f793          	andi	a5,a5,-3
4000c388:	0137e7b3          	or	a5,a5,s3
4000c38c:	02f90123          	sb	a5,34(s2)
			net_mgmt_event_notify_with_info(
4000c390:	f99ff06f          	j	4000c328 <iface_router_add+0x140>

4000c394 <iface_router_rm>:
{
4000c394:	fe010113          	addi	sp,sp,-32
4000c398:	00812c23          	sw	s0,24(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000c39c:	fff00593          	li	a1,-1
{
4000c3a0:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000c3a4:	fff00513          	li	a0,-1
{
4000c3a8:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000c3ac:	b9dff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (!router->is_used) {
4000c3b0:	02244783          	lbu	a5,34(s0)
	bool ret = false;
4000c3b4:	00000513          	li	a0,0
	if (!router->is_used) {
4000c3b8:	0017f793          	andi	a5,a5,1
4000c3bc:	02078c63          	beqz	a5,4000c3f4 <iface_router_rm+0x60>
	iface_router_notify_deletion(router, "has been removed");
4000c3c0:	00040513          	mv	a0,s0
4000c3c4:	b3dff0ef          	jal	ra,4000bf00 <iface_router_notify_deletion.constprop.0>
	if (sys_slist_find_and_remove(&active_router_timers, &router->node)) {
4000c3c8:	40031537          	lui	a0,0x40031
4000c3cc:	00040593          	mv	a1,s0
4000c3d0:	a6450513          	addi	a0,a0,-1436 # 40030a64 <active_router_timers>
4000c3d4:	f78ff0ef          	jal	ra,4000bb4c <sys_slist_find_and_remove>
4000c3d8:	00050663          	beqz	a0,4000c3e4 <iface_router_rm+0x50>
		iface_router_update_timer(k_uptime_get_32());
4000c3dc:	ae9ff0ef          	jal	ra,4000bec4 <k_uptime_get_32>
4000c3e0:	d41ff0ef          	jal	ra,4000c120 <iface_router_update_timer>
	router->is_used = false;
4000c3e4:	02244783          	lbu	a5,34(s0)
	ret = true;
4000c3e8:	00100513          	li	a0,1
	router->is_used = false;
4000c3ec:	ffe7f793          	andi	a5,a5,-2
4000c3f0:	02f40123          	sb	a5,34(s0)
	ret = true;
4000c3f4:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000c3f8:	b65ff0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000c3fc:	01c12083          	lw	ra,28(sp)
4000c400:	01812403          	lw	s0,24(sp)
4000c404:	00c12503          	lw	a0,12(sp)
4000c408:	02010113          	addi	sp,sp,32
4000c40c:	00008067          	ret

4000c410 <address_lifetime_timeout>:
{
4000c410:	fe010113          	addi	sp,sp,-32
4000c414:	00112e23          	sw	ra,28(sp)
4000c418:	01312623          	sw	s3,12(sp)
4000c41c:	01512223          	sw	s5,4(sp)
4000c420:	00812c23          	sw	s0,24(sp)
4000c424:	00912a23          	sw	s1,20(sp)
4000c428:	01212823          	sw	s2,16(sp)
4000c42c:	01412423          	sw	s4,8(sp)
4000c430:	01612023          	sw	s6,0(sp)
	uint32_t current_time = k_uptime_get_32();
4000c434:	a91ff0ef          	jal	ra,4000bec4 <k_uptime_get_32>
4000c438:	00050993          	mv	s3,a0
	k_mutex_lock(&lock, K_FOREVER);
4000c43c:	fff00593          	li	a1,-1
4000c440:	fff00513          	li	a0,-1
4000c444:	b05ff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4000c448:	40031ab7          	lui	s5,0x40031
4000c44c:	a5caa783          	lw	a5,-1444(s5) # 40030a5c <active_address_lifetime_timers>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_address_lifetime_timers,
4000c450:	0a078663          	beqz	a5,4000c4fc <address_lifetime_timeout+0xec>
	return node->next;
4000c454:	0007a403          	lw	s0,0(a5)
4000c458:	fec78913          	addi	s2,a5,-20
4000c45c:	00040463          	beqz	s0,4000c464 <address_lifetime_timeout+0x54>
4000c460:	fec40413          	addi	s0,s0,-20
{
4000c464:	fff00493          	li	s1,-1
	ifaddr->addr_state = NET_ADDR_DEPRECATED;
4000c468:	00200b13          	li	s6,2
4000c46c:	00c0006f          	j	4000c478 <address_lifetime_timeout+0x68>
{
4000c470:	00040913          	mv	s2,s0
4000c474:	00078413          	mv	s0,a5
		struct net_timeout *timeout = &current->lifetime;
4000c478:	01490a13          	addi	s4,s2,20
		uint32_t this_update = net_timeout_evaluate(timeout,
4000c47c:	00098593          	mv	a1,s3
4000c480:	000a0513          	mv	a0,s4
4000c484:	708030ef          	jal	ra,4000fb8c <net_timeout_evaluate>
		if (this_update == 0U) {
4000c488:	02051c63          	bnez	a0,4000c4c0 <address_lifetime_timeout+0xb0>
	sys_slist_find_and_remove(&active_address_lifetime_timers,
4000c48c:	000a0593          	mv	a1,s4
	ifaddr->addr_state = NET_ADDR_DEPRECATED;
4000c490:	036906a3          	sb	s6,45(s2)
	sys_slist_find_and_remove(&active_address_lifetime_timers,
4000c494:	a5ca8513          	addi	a0,s5,-1444
4000c498:	eb4ff0ef          	jal	ra,4000bb4c <sys_slist_find_and_remove>
	net_timeout_set(&ifaddr->lifetime, 0, 0);
4000c49c:	00000613          	li	a2,0
4000c4a0:	00000593          	li	a1,0
4000c4a4:	000a0513          	mv	a0,s4
4000c4a8:	5e4030ef          	jal	ra,4000fa8c <net_timeout_set>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_address_lifetime_timers,
4000c4ac:	02040063          	beqz	s0,4000c4cc <address_lifetime_timeout+0xbc>
4000c4b0:	01442783          	lw	a5,20(s0)
4000c4b4:	fa078ee3          	beqz	a5,4000c470 <address_lifetime_timeout+0x60>
4000c4b8:	fec78793          	addi	a5,a5,-20
4000c4bc:	fb5ff06f          	j	4000c470 <address_lifetime_timeout+0x60>
		if (this_update < next_update) {
4000c4c0:	00957463          	bgeu	a0,s1,4000c4c8 <address_lifetime_timeout+0xb8>
4000c4c4:	00050493          	mv	s1,a0
		if (current == next) {
4000c4c8:	ff2412e3          	bne	s0,s2,4000c4ac <address_lifetime_timeout+0x9c>
	if (next_update != UINT32_MAX) {
4000c4cc:	fff00793          	li	a5,-1
4000c4d0:	02f48663          	beq	s1,a5,4000c4fc <address_lifetime_timeout+0xec>
		t += off;
4000c4d4:	00948513          	addi	a0,s1,9
			return t / ((uint64_t)from_hz / to_hz);
4000c4d8:	00a00613          	li	a2,10
4000c4dc:	00000693          	li	a3,0
4000c4e0:	009535b3          	sltu	a1,a0,s1
4000c4e4:	dd5f30ef          	jal	ra,400002b8 <__udivdi3>
		k_work_reschedule(&address_lifetime_timer, K_MSEC(next_update));
4000c4e8:	00058613          	mv	a2,a1
4000c4ec:	00050593          	mv	a1,a0
4000c4f0:	40031537          	lui	a0,0x40031
4000c4f4:	e6850513          	addi	a0,a0,-408 # 40030e68 <address_lifetime_timer>
4000c4f8:	12c1d0ef          	jal	ra,40029624 <k_work_reschedule>
}
4000c4fc:	01812403          	lw	s0,24(sp)
4000c500:	01c12083          	lw	ra,28(sp)
4000c504:	01412483          	lw	s1,20(sp)
4000c508:	01012903          	lw	s2,16(sp)
4000c50c:	00c12983          	lw	s3,12(sp)
4000c510:	00812a03          	lw	s4,8(sp)
4000c514:	00412a83          	lw	s5,4(sp)
4000c518:	00012b03          	lw	s6,0(sp)
4000c51c:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
4000c520:	a3dff06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>

4000c524 <iface_router_find_default.constprop.0>:
static struct net_if_router *iface_router_find_default(struct net_if *iface,
4000c524:	ff010113          	addi	sp,sp,-16
4000c528:	00912223          	sw	s1,4(sp)
4000c52c:	01212023          	sw	s2,0(sp)
4000c530:	00050493          	mv	s1,a0
4000c534:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
4000c538:	fff00513          	li	a0,-1
4000c53c:	fff00593          	li	a1,-1
static struct net_if_router *iface_router_find_default(struct net_if *iface,
4000c540:	00112623          	sw	ra,12(sp)
4000c544:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000c548:	a01ff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
		if (!routers[i].is_used ||
4000c54c:	400327b7          	lui	a5,0x40032
4000c550:	e0c78713          	addi	a4,a5,-500 # 40031e0c <routers>
4000c554:	02072703          	lw	a4,32(a4)
4000c558:	e0c78793          	addi	a5,a5,-500
4000c55c:	01075693          	srli	a3,a4,0x10
4000c560:	0016f693          	andi	a3,a3,1
4000c564:	02068263          	beqz	a3,4000c588 <iface_router_find_default.constprop.0+0x64>
		    !routers[i].is_default ||
4000c568:	01175713          	srli	a4,a4,0x11
		if (!routers[i].is_used ||
4000c56c:	00177713          	andi	a4,a4,1
4000c570:	00070c63          	beqz	a4,4000c588 <iface_router_find_default.constprop.0+0x64>
		    !routers[i].is_default ||
4000c574:	0047d703          	lhu	a4,4(a5)
4000c578:	01271863          	bne	a4,s2,4000c588 <iface_router_find_default.constprop.0+0x64>
		if (iface && iface != routers[i].iface) {
4000c57c:	04048063          	beqz	s1,4000c5bc <iface_router_find_default.constprop.0+0x98>
4000c580:	0187a703          	lw	a4,24(a5)
4000c584:	02e48c63          	beq	s1,a4,4000c5bc <iface_router_find_default.constprop.0+0x98>
		if (!routers[i].is_used ||
4000c588:	0447a703          	lw	a4,68(a5)
	struct net_if_router *router = NULL;
4000c58c:	00000413          	li	s0,0
		if (!routers[i].is_used ||
4000c590:	01075693          	srli	a3,a4,0x10
4000c594:	0016f693          	andi	a3,a3,1
4000c598:	02068a63          	beqz	a3,4000c5cc <iface_router_find_default.constprop.0+0xa8>
		    !routers[i].is_default ||
4000c59c:	01175713          	srli	a4,a4,0x11
		if (!routers[i].is_used ||
4000c5a0:	00177713          	andi	a4,a4,1
4000c5a4:	02070463          	beqz	a4,4000c5cc <iface_router_find_default.constprop.0+0xa8>
		    !routers[i].is_default ||
4000c5a8:	0287d703          	lhu	a4,40(a5)
4000c5ac:	03271063          	bne	a4,s2,4000c5cc <iface_router_find_default.constprop.0+0xa8>
		if (iface && iface != routers[i].iface) {
4000c5b0:	02049e63          	bnez	s1,4000c5ec <iface_router_find_default.constprop.0+0xc8>
	for (i = 0; i < CONFIG_NET_MAX_ROUTERS; i++) {
4000c5b4:	00100413          	li	s0,1
4000c5b8:	0080006f          	j	4000c5c0 <iface_router_find_default.constprop.0+0x9c>
4000c5bc:	00000413          	li	s0,0
		router = &routers[i];
4000c5c0:	02400713          	li	a4,36
4000c5c4:	02e40433          	mul	s0,s0,a4
4000c5c8:	00878433          	add	s0,a5,s0
	k_mutex_unlock(&lock);
4000c5cc:	991ff0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000c5d0:	00c12083          	lw	ra,12(sp)
4000c5d4:	00040513          	mv	a0,s0
4000c5d8:	00812403          	lw	s0,8(sp)
4000c5dc:	00412483          	lw	s1,4(sp)
4000c5e0:	00012903          	lw	s2,0(sp)
4000c5e4:	01010113          	addi	sp,sp,16
4000c5e8:	00008067          	ret
		if (iface && iface != routers[i].iface) {
4000c5ec:	03c7a703          	lw	a4,60(a5)
4000c5f0:	fce49ee3          	bne	s1,a4,4000c5cc <iface_router_find_default.constprop.0+0xa8>
4000c5f4:	fc1ff06f          	j	4000c5b4 <iface_router_find_default.constprop.0+0x90>

4000c5f8 <net_if_flag_is_set>:
	if (iface == NULL) {
4000c5f8:	02050c63          	beqz	a0,4000c630 <net_if_flag_is_set+0x38>
{
4000c5fc:	ff010113          	addi	sp,sp,-16
4000c600:	00812423          	sw	s0,8(sp)
4000c604:	00112623          	sw	ra,12(sp)
	return atomic_test_bit(iface->if_dev->flags, value);
4000c608:	00052503          	lw	a0,0(a0)
4000c60c:	00058413          	mv	s0,a1
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
4000c610:	00c50513          	addi	a0,a0,12
4000c614:	1d51e0ef          	jal	ra,4002afe8 <atomic_get>
}
4000c618:	00c12083          	lw	ra,12(sp)
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
4000c61c:	40855533          	sra	a0,a0,s0
4000c620:	00812403          	lw	s0,8(sp)
4000c624:	00157513          	andi	a0,a0,1
4000c628:	01010113          	addi	sp,sp,16
4000c62c:	00008067          	ret
		return false;
4000c630:	00000513          	li	a0,0
}
4000c634:	00008067          	ret

4000c638 <net_if_ipv6_start_dad>:
{
4000c638:	ff010113          	addi	sp,sp,-16
4000c63c:	00812423          	sw	s0,8(sp)
4000c640:	00912223          	sw	s1,4(sp)
4000c644:	00112623          	sw	ra,12(sp)
4000c648:	00058413          	mv	s0,a1
	ifaddr->addr_state = NET_ADDR_TENTATIVE;
4000c64c:	020586a3          	sb	zero,45(a1)
 */
static inline bool net_if_is_up(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_UP) &&
4000c650:	00000593          	li	a1,0
{
4000c654:	00050493          	mv	s1,a0
4000c658:	fa1ff0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
4000c65c:	06050e63          	beqz	a0,4000c6d8 <net_if_ipv6_start_dad+0xa0>
	       net_if_flag_is_set(iface, NET_IF_RUNNING);
4000c660:	00800593          	li	a1,8
4000c664:	00048513          	mv	a0,s1
4000c668:	f91ff0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
	return net_if_flag_is_set(iface, NET_IF_UP) &&
4000c66c:	06050663          	beqz	a0,4000c6d8 <net_if_ipv6_start_dad+0xa0>
		ifaddr->dad_count = 1U;
4000c670:	00100793          	li	a5,1
4000c674:	02f40723          	sb	a5,46(s0)
		if (!net_ipv6_start_dad(iface, ifaddr)) {
4000c678:	00040593          	mv	a1,s0
4000c67c:	00048513          	mv	a0,s1
4000c680:	4a90c0ef          	jal	ra,40019328 <net_ipv6_start_dad>
4000c684:	04051a63          	bnez	a0,4000c6d8 <net_if_ipv6_start_dad+0xa0>
			ifaddr->dad_start = k_uptime_get_32();
4000c688:	83dff0ef          	jal	ra,4000bec4 <k_uptime_get_32>
4000c68c:	02a42423          	sw	a0,40(s0)
			sys_slist_append(&active_dad_timers, &ifaddr->dad_node);
4000c690:	40031537          	lui	a0,0x40031
4000c694:	02440593          	addi	a1,s0,36
4000c698:	a4c50513          	addi	a0,a0,-1460 # 40030a4c <active_dad_timers>
4000c69c:	c8cff0ef          	jal	ra,4000bb28 <sys_slist_append>
	return z_timeout_remaining(&dwork->timeout);
4000c6a0:	40031537          	lui	a0,0x40031
4000c6a4:	e1850513          	addi	a0,a0,-488 # 40030e18 <dad_timer+0x10>
4000c6a8:	3401e0ef          	jal	ra,4002a9e8 <z_timeout_remaining>
			if (!k_work_delayable_remaining_get(&dad_timer)) {
4000c6ac:	00b56533          	or	a0,a0,a1
4000c6b0:	02051463          	bnez	a0,4000c6d8 <net_if_ipv6_start_dad+0xa0>
}
4000c6b4:	00812403          	lw	s0,8(sp)
4000c6b8:	00c12083          	lw	ra,12(sp)
4000c6bc:	00412483          	lw	s1,4(sp)
				k_work_reschedule(&dad_timer,
4000c6c0:	40031537          	lui	a0,0x40031
4000c6c4:	00a00593          	li	a1,10
4000c6c8:	00000613          	li	a2,0
4000c6cc:	e0850513          	addi	a0,a0,-504 # 40030e08 <dad_timer>
}
4000c6d0:	01010113          	addi	sp,sp,16
				k_work_reschedule(&dad_timer,
4000c6d4:	7511c06f          	j	40029624 <k_work_reschedule>
}
4000c6d8:	00c12083          	lw	ra,12(sp)
4000c6dc:	00812403          	lw	s0,8(sp)
4000c6e0:	00412483          	lw	s1,4(sp)
4000c6e4:	01010113          	addi	sp,sp,16
4000c6e8:	00008067          	ret

4000c6ec <net_if_ipv4_get_best_match.isra.0>:
static struct in_addr *net_if_ipv4_get_best_match(struct net_if *iface,
4000c6ec:	fe010113          	addi	sp,sp,-32
4000c6f0:	01212823          	sw	s2,16(sp)
4000c6f4:	00112e23          	sw	ra,28(sp)
4000c6f8:	00812c23          	sw	s0,24(sp)
4000c6fc:	00912a23          	sw	s1,20(sp)
4000c700:	01312623          	sw	s3,12(sp)
		return NULL;
4000c704:	00000913          	li	s2,0
	if (!ipv4) {
4000c708:	06050263          	beqz	a0,4000c76c <net_if_ipv4_get_best_match.isra.0+0x80>
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
4000c70c:	02c52703          	lw	a4,44(a0)
4000c710:	020106b7          	lui	a3,0x2010
4000c714:	020007b7          	lui	a5,0x2000
4000c718:	f0068693          	addi	a3,a3,-256 # 200ff00 <__rom_region_size+0x1fdf524>
4000c71c:	10078793          	addi	a5,a5,256 # 2000100 <__rom_region_size+0x1fcf724>
4000c720:	00d77733          	and	a4,a4,a3
4000c724:	04f71463          	bne	a4,a5,4000c76c <net_if_ipv4_get_best_match.isra.0+0x80>
4000c728:	00055703          	lhu	a4,0(a0)
4000c72c:	00100793          	li	a5,1
4000c730:	02f71e63          	bne	a4,a5,4000c76c <net_if_ipv4_get_best_match.isra.0+0x80>
	    !net_ipv4_is_ll_addr(&addr->address.in_addr)) {
4000c734:	00450413          	addi	s0,a0,4
4000c738:	00040513          	mv	a0,s0
4000c73c:	00058993          	mv	s3,a1
4000c740:	00060493          	mv	s1,a2
4000c744:	d5cff0ef          	jal	ra,4000bca0 <net_ipv4_is_ll_addr>
	    addr->address.family == AF_INET &&
4000c748:	02051263          	bnez	a0,4000c76c <net_if_ipv4_get_best_match.isra.0+0x80>
	return get_ipaddr_diff((const uint8_t *)src, (const uint8_t *)dst, 4);
4000c74c:	00400613          	li	a2,4
4000c750:	00040593          	mv	a1,s0
4000c754:	00098513          	mv	a0,s3
4000c758:	e2cff0ef          	jal	ra,4000bd84 <get_ipaddr_diff>
		if (len >= *best_so_far) {
4000c75c:	0004c783          	lbu	a5,0(s1)
4000c760:	00f56663          	bltu	a0,a5,4000c76c <net_if_ipv4_get_best_match.isra.0+0x80>
			*best_so_far = len;
4000c764:	00a48023          	sb	a0,0(s1)
	    !net_ipv4_is_ll_addr(&addr->address.in_addr)) {
4000c768:	00040913          	mv	s2,s0
}
4000c76c:	01c12083          	lw	ra,28(sp)
4000c770:	01812403          	lw	s0,24(sp)
4000c774:	01412483          	lw	s1,20(sp)
4000c778:	00c12983          	lw	s3,12(sp)
4000c77c:	00090513          	mv	a0,s2
4000c780:	01012903          	lw	s2,16(sp)
4000c784:	02010113          	addi	sp,sp,32
4000c788:	00008067          	ret

4000c78c <net_if_ipv6_get_best_match.isra.0>:
static struct in6_addr *net_if_ipv6_get_best_match(struct net_if *iface,
4000c78c:	fc010113          	addi	sp,sp,-64
4000c790:	03612023          	sw	s6,32(sp)
4000c794:	02112e23          	sw	ra,60(sp)
4000c798:	02812c23          	sw	s0,56(sp)
4000c79c:	02912a23          	sw	s1,52(sp)
4000c7a0:	03212823          	sw	s2,48(sp)
4000c7a4:	03312623          	sw	s3,44(sp)
4000c7a8:	03412423          	sw	s4,40(sp)
4000c7ac:	03512223          	sw	s5,36(sp)
4000c7b0:	01712e23          	sw	s7,28(sp)
4000c7b4:	01812c23          	sw	s8,24(sp)
4000c7b8:	01912a23          	sw	s9,20(sp)
4000c7bc:	01a12823          	sw	s10,16(sp)
4000c7c0:	01b12623          	sw	s11,12(sp)
		return NULL;
4000c7c4:	00000b13          	li	s6,0
	if (!ipv6) {
4000c7c8:	0c050863          	beqz	a0,4000c898 <net_if_ipv6_get_best_match.isra.0+0x10c>
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
4000c7cc:	02010bb7          	lui	s7,0x2010
4000c7d0:	02000c37          	lui	s8,0x2000
4000c7d4:	00050913          	mv	s2,a0
4000c7d8:	00058993          	mv	s3,a1
4000c7dc:	00060a93          	mv	s5,a2
4000c7e0:	00050413          	mv	s0,a0
	struct in6_addr *src = NULL;
4000c7e4:	00000b13          	li	s6,0
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000c7e8:	00000a13          	li	s4,0
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
4000c7ec:	03000d93          	li	s11,48
4000c7f0:	f00b8b93          	addi	s7,s7,-256 # 200ff00 <__rom_region_size+0x1fdf524>
4000c7f4:	100c0c13          	addi	s8,s8,256 # 2000100 <__rom_region_size+0x1fcf724>
4000c7f8:	00200693          	li	a3,2
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000c7fc:	00300d13          	li	s10,3
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
4000c800:	03ba07b3          	mul	a5,s4,s11
4000c804:	00f907b3          	add	a5,s2,a5
4000c808:	02c7a483          	lw	s1,44(a5)
4000c80c:	0174f7b3          	and	a5,s1,s7
4000c810:	07879e63          	bne	a5,s8,4000c88c <net_if_ipv6_get_best_match.isra.0+0x100>
4000c814:	00045783          	lhu	a5,0(s0)
4000c818:	06d79a63          	bne	a5,a3,4000c88c <net_if_ipv6_get_best_match.isra.0+0x100>
	return UNALIGNED_GET(&addr->s6_addr16[0]) == htons(0xFE80);
4000c81c:	00544783          	lbu	a5,5(s0)
4000c820:	00444703          	lbu	a4,4(s0)
4000c824:	00879793          	slli	a5,a5,0x8
	    addr->address.family == AF_INET6 &&
4000c828:	00e7e7b3          	or	a5,a5,a4
4000c82c:	00008737          	lui	a4,0x8
4000c830:	0fe70713          	addi	a4,a4,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
4000c834:	04e78c63          	beq	a5,a4,4000c88c <net_if_ipv6_get_best_match.isra.0+0x100>
		len = get_diff_ipv6(dst, &ipv6->unicast[i].address.in6_addr);
4000c838:	00440c93          	addi	s9,s0,4
	return get_ipaddr_diff((const uint8_t *)src, (const uint8_t *)dst, 16);
4000c83c:	01000613          	li	a2,16
4000c840:	000c8593          	mv	a1,s9
4000c844:	00098513          	mv	a0,s3
4000c848:	d3cff0ef          	jal	ra,4000bd84 <get_ipaddr_diff>
		if (len >= *best_so_far) {
4000c84c:	000ac783          	lbu	a5,0(s5)
4000c850:	00200693          	li	a3,2
4000c854:	02f56c63          	bltu	a0,a5,4000c88c <net_if_ipv6_get_best_match.isra.0+0x100>
			if (ipv6->unicast[i].is_mesh_local && len < 64 &&
4000c858:	01a4d493          	srli	s1,s1,0x1a
4000c85c:	0014f493          	andi	s1,s1,1
4000c860:	02048263          	beqz	s1,4000c884 <net_if_ipv6_get_best_match.isra.0+0xf8>
4000c864:	03f00793          	li	a5,63
4000c868:	00a7ee63          	bltu	a5,a0,4000c884 <net_if_ipv6_get_best_match.isra.0+0xf8>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
4000c86c:	0009c703          	lbu	a4,0(s3)
4000c870:	0ff00793          	li	a5,255
4000c874:	00f71c63          	bne	a4,a5,4000c88c <net_if_ipv6_get_best_match.isra.0+0x100>
4000c878:	0019c703          	lbu	a4,1(s3)
4000c87c:	00300793          	li	a5,3
4000c880:	00f71663          	bne	a4,a5,4000c88c <net_if_ipv6_get_best_match.isra.0+0x100>
			*best_so_far = len;
4000c884:	00aa8023          	sb	a0,0(s5)
			src = &ipv6->unicast[i].address.in6_addr;
4000c888:	000c8b13          	mv	s6,s9
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000c88c:	001a0a13          	addi	s4,s4,1
4000c890:	03040413          	addi	s0,s0,48
4000c894:	f7aa16e3          	bne	s4,s10,4000c800 <net_if_ipv6_get_best_match.isra.0+0x74>
}
4000c898:	03c12083          	lw	ra,60(sp)
4000c89c:	03812403          	lw	s0,56(sp)
4000c8a0:	03412483          	lw	s1,52(sp)
4000c8a4:	03012903          	lw	s2,48(sp)
4000c8a8:	02c12983          	lw	s3,44(sp)
4000c8ac:	02812a03          	lw	s4,40(sp)
4000c8b0:	02412a83          	lw	s5,36(sp)
4000c8b4:	01c12b83          	lw	s7,28(sp)
4000c8b8:	01812c03          	lw	s8,24(sp)
4000c8bc:	01412c83          	lw	s9,20(sp)
4000c8c0:	01012d03          	lw	s10,16(sp)
4000c8c4:	00c12d83          	lw	s11,12(sp)
4000c8c8:	000b0513          	mv	a0,s6
4000c8cc:	02012b03          	lw	s6,32(sp)
4000c8d0:	04010113          	addi	sp,sp,64
4000c8d4:	00008067          	ret

4000c8d8 <need_calc_checksum>:

	k_mutex_unlock(&lock);
}

static bool need_calc_checksum(struct net_if *iface, enum ethernet_hw_caps caps)
{
4000c8d8:	ff010113          	addi	sp,sp,-16
4000c8dc:	00812423          	sw	s0,8(sp)
4000c8e0:	00912223          	sw	s1,4(sp)
4000c8e4:	00112623          	sw	ra,12(sp)
4000c8e8:	00050493          	mv	s1,a0
4000c8ec:	00058413          	mv	s0,a1
#if defined(CONFIG_NET_L2_ETHERNET)
	if (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {
4000c8f0:	c20ff0ef          	jal	ra,4000bd10 <net_if_l2>
4000c8f4:	4003d7b7          	lui	a5,0x4003d
4000c8f8:	c6478793          	addi	a5,a5,-924 # 4003cc64 <_net_l2_ETHERNET>
4000c8fc:	04a79063          	bne	a5,a0,4000c93c <need_calc_checksum+0x64>
	return iface->if_dev->dev;
4000c900:	0004a783          	lw	a5,0(s1)
4000c904:	0007a503          	lw	a0,0(a5)
	if (!eth->get_capabilities) {
4000c908:	00852783          	lw	a5,8(a0)
4000c90c:	00c7a703          	lw	a4,12(a5)
		return (enum ethernet_hw_caps)0;
4000c910:	00000793          	li	a5,0
	if (!eth->get_capabilities) {
4000c914:	00070663          	beqz	a4,4000c920 <need_calc_checksum+0x48>
	return eth->get_capabilities(net_if_get_device(iface));
4000c918:	000700e7          	jalr	a4
4000c91c:	00050793          	mv	a5,a0
		return true;
	}

	return !(net_eth_get_hw_capabilities(iface) & caps);
4000c920:	00f47533          	and	a0,s0,a5
4000c924:	00153513          	seqz	a0,a0
	ARG_UNUSED(iface);
	ARG_UNUSED(caps);

	return true;
#endif
}
4000c928:	00c12083          	lw	ra,12(sp)
4000c92c:	00812403          	lw	s0,8(sp)
4000c930:	00412483          	lw	s1,4(sp)
4000c934:	01010113          	addi	sp,sp,16
4000c938:	00008067          	ret
		return true;
4000c93c:	00100513          	li	a0,1
4000c940:	fe9ff06f          	j	4000c928 <need_calc_checksum+0x50>

4000c944 <net_if_flag_set.isra.0>:
	return z_impl_atomic_or(target, value);
4000c944:	00100793          	li	a5,1
4000c948:	00b795b3          	sll	a1,a5,a1
4000c94c:	00c50513          	addi	a0,a0,12
4000c950:	6bc1e06f          	j	4002b00c <z_impl_atomic_or>

4000c954 <net_if_flag_test_and_set.isra.0>:
static inline bool net_if_flag_test_and_set(struct net_if *iface,
4000c954:	ff010113          	addi	sp,sp,-16
4000c958:	00812423          	sw	s0,8(sp)
	atomic_val_t mask = ATOMIC_MASK(bit);
4000c95c:	00100413          	li	s0,1
4000c960:	00112623          	sw	ra,12(sp)
4000c964:	00b41433          	sll	s0,s0,a1
4000c968:	00040593          	mv	a1,s0
4000c96c:	00c50513          	addi	a0,a0,12
4000c970:	69c1e0ef          	jal	ra,4002b00c <z_impl_atomic_or>
}
4000c974:	00c12083          	lw	ra,12(sp)
	return (old & mask) != 0;
4000c978:	00a47533          	and	a0,s0,a0
4000c97c:	00812403          	lw	s0,8(sp)
4000c980:	00a03533          	snez	a0,a0
4000c984:	01010113          	addi	sp,sp,16
4000c988:	00008067          	ret

4000c98c <atomic_test_and_clear_bit>:
{
4000c98c:	ff010113          	addi	sp,sp,-16
4000c990:	00812423          	sw	s0,8(sp)
	atomic_val_t mask = ATOMIC_MASK(bit);
4000c994:	00100413          	li	s0,1
{
4000c998:	00112623          	sw	ra,12(sp)
	atomic_val_t mask = ATOMIC_MASK(bit);
4000c99c:	00b41433          	sll	s0,s0,a1
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
4000c9a0:	0055d593          	srli	a1,a1,0x5
4000c9a4:	00259793          	slli	a5,a1,0x2
	return z_impl_atomic_and(target, value);
4000c9a8:	00f50533          	add	a0,a0,a5
4000c9ac:	fff44593          	not	a1,s0
4000c9b0:	67c1e0ef          	jal	ra,4002b02c <z_impl_atomic_and>
}
4000c9b4:	00c12083          	lw	ra,12(sp)
	return (old & mask) != 0;
4000c9b8:	00a47533          	and	a0,s0,a0
}
4000c9bc:	00812403          	lw	s0,8(sp)
4000c9c0:	00a03533          	snez	a0,a0
4000c9c4:	01010113          	addi	sp,sp,16
4000c9c8:	00008067          	ret

4000c9cc <iface_router_expired>:
{
4000c9cc:	fe010113          	addi	sp,sp,-32
4000c9d0:	00112e23          	sw	ra,28(sp)
4000c9d4:	00812c23          	sw	s0,24(sp)
4000c9d8:	00912a23          	sw	s1,20(sp)
4000c9dc:	01312623          	sw	s3,12(sp)
4000c9e0:	01212823          	sw	s2,16(sp)
4000c9e4:	01412423          	sw	s4,8(sp)
4000c9e8:	01512223          	sw	s5,4(sp)
	uint32_t current_time = k_uptime_get_32();
4000c9ec:	cd8ff0ef          	jal	ra,4000bec4 <k_uptime_get_32>
4000c9f0:	00050993          	mv	s3,a0
	k_mutex_lock(&lock, K_FOREVER);
4000c9f4:	fff00593          	li	a1,-1
4000c9f8:	fff00513          	li	a0,-1
	return list->head;
4000c9fc:	400314b7          	lui	s1,0x40031
4000ca00:	d48ff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
4000ca04:	a644a403          	lw	s0,-1436(s1) # 40030a64 <active_router_timers>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
4000ca08:	00040c63          	beqz	s0,4000ca20 <iface_router_expired+0x54>
	return node->next;
4000ca0c:	00042a03          	lw	s4,0(s0)
4000ca10:	a6448493          	addi	s1,s1,-1436
4000ca14:	00000913          	li	s2,0
	ends += MSEC_PER_SEC * router->lifetime;
4000ca18:	3e800a93          	li	s5,1000
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
4000ca1c:	02041863          	bnez	s0,4000ca4c <iface_router_expired+0x80>
	iface_router_update_timer(current_time);
4000ca20:	00098513          	mv	a0,s3
4000ca24:	efcff0ef          	jal	ra,4000c120 <iface_router_update_timer>
}
4000ca28:	01812403          	lw	s0,24(sp)
4000ca2c:	01c12083          	lw	ra,28(sp)
4000ca30:	01412483          	lw	s1,20(sp)
4000ca34:	01012903          	lw	s2,16(sp)
4000ca38:	00c12983          	lw	s3,12(sp)
4000ca3c:	00812a03          	lw	s4,8(sp)
4000ca40:	00412a83          	lw	s5,4(sp)
4000ca44:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
4000ca48:	d14ff06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>
	ends += MSEC_PER_SEC * router->lifetime;
4000ca4c:	02045703          	lhu	a4,32(s0)
	return (int32_t)(ends - now);
4000ca50:	01c42783          	lw	a5,28(s0)
			prev_node = &router->node;
4000ca54:	00040693          	mv	a3,s0
	ends += MSEC_PER_SEC * router->lifetime;
4000ca58:	03570733          	mul	a4,a4,s5
	return (int32_t)(ends - now);
4000ca5c:	413787b3          	sub	a5,a5,s3
4000ca60:	00e787b3          	add	a5,a5,a4
		if (ends > 0) {
4000ca64:	02f04c63          	bgtz	a5,4000ca9c <iface_router_expired+0xd0>
		iface_router_notify_deletion(router, "has expired");
4000ca68:	00040513          	mv	a0,s0
4000ca6c:	c94ff0ef          	jal	ra,4000bf00 <iface_router_notify_deletion.constprop.0>
Z_GENLIST_REMOVE(slist, snode)
4000ca70:	00042783          	lw	a5,0(s0)
4000ca74:	04091263          	bnez	s2,4000cab8 <iface_router_expired+0xec>
4000ca78:	0044a703          	lw	a4,4(s1)
	list->head = node;
4000ca7c:	00f4a023          	sw	a5,0(s1)
Z_GENLIST_REMOVE(slist, snode)
4000ca80:	00e41463          	bne	s0,a4,4000ca88 <iface_router_expired+0xbc>
	list->tail = node;
4000ca84:	00f4a223          	sw	a5,4(s1)
		router->is_used = false;
4000ca88:	02244783          	lbu	a5,34(s0)
	parent->next = child;
4000ca8c:	00042023          	sw	zero,0(s0)
4000ca90:	00090693          	mv	a3,s2
4000ca94:	ffe7f793          	andi	a5,a5,-2
4000ca98:	02f40123          	sb	a5,34(s0)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
4000ca9c:	00000793          	li	a5,0
4000caa0:	000a0463          	beqz	s4,4000caa8 <iface_router_expired+0xdc>
	return node->next;
4000caa4:	000a2783          	lw	a5,0(s4)
4000caa8:	000a0413          	mv	s0,s4
4000caac:	00068913          	mv	s2,a3
4000cab0:	00078a13          	mv	s4,a5
4000cab4:	f69ff06f          	j	4000ca1c <iface_router_expired+0x50>
	parent->next = child;
4000cab8:	00f92023          	sw	a5,0(s2)
Z_GENLIST_REMOVE(slist, snode)
4000cabc:	0044a783          	lw	a5,4(s1)
4000cac0:	fcf414e3          	bne	s0,a5,4000ca88 <iface_router_expired+0xbc>
	list->tail = node;
4000cac4:	0124a223          	sw	s2,4(s1)
}
4000cac8:	fc1ff06f          	j	4000ca88 <iface_router_expired+0xbc>

4000cacc <z_impl_net_if_get_by_index>:
	if (index <= 0) {
4000cacc:	02a05463          	blez	a0,4000caf4 <z_impl_net_if_get_by_index+0x28>
	if (&_net_if_list_start[index - 1] >= _net_if_list_end) {
4000cad0:	00c00793          	li	a5,12
4000cad4:	fff50513          	addi	a0,a0,-1
4000cad8:	02f50533          	mul	a0,a0,a5
4000cadc:	4003d7b7          	lui	a5,0x4003d
4000cae0:	c3c78793          	addi	a5,a5,-964 # 4003cc3c <__net_if_dts_ord_12_0>
4000cae4:	00f50533          	add	a0,a0,a5
4000cae8:	4003d7b7          	lui	a5,0x4003d
4000caec:	c4878793          	addi	a5,a5,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000caf0:	00f56463          	bltu	a0,a5,4000caf8 <z_impl_net_if_get_by_index+0x2c>
		return NULL;
4000caf4:	00000513          	li	a0,0
}
4000caf8:	00008067          	ret

4000cafc <net_if_set_link_addr_locked>:
{
4000cafc:	fd010113          	addi	sp,sp,-48
4000cb00:	02812423          	sw	s0,40(sp)
4000cb04:	01312e23          	sw	s3,28(sp)
4000cb08:	00050413          	mv	s0,a0
4000cb0c:	00058993          	mv	s3,a1
	k_mutex_lock(&lock, K_FOREVER);
4000cb10:	fff00513          	li	a0,-1
4000cb14:	fff00593          	li	a1,-1
{
4000cb18:	02912223          	sw	s1,36(sp)
4000cb1c:	03212023          	sw	s2,32(sp)
4000cb20:	02112623          	sw	ra,44(sp)
4000cb24:	00060913          	mv	s2,a2
4000cb28:	00068493          	mv	s1,a3
	k_mutex_lock(&lock, K_FOREVER);
4000cb2c:	c1cff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_flag_is_set(iface, NET_IF_RUNNING)) {
4000cb30:	00800593          	li	a1,8
4000cb34:	00040513          	mv	a0,s0
4000cb38:	ac1ff0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
4000cb3c:	04051263          	bnez	a0,4000cb80 <net_if_set_link_addr_locked+0x84>
	return &iface->if_dev->link_addr;
4000cb40:	00042783          	lw	a5,0(s0)
	net_if_get_link_addr(iface)->addr = addr;
4000cb44:	0137a823          	sw	s3,16(a5)
	return &iface->if_dev->link_addr;
4000cb48:	00042783          	lw	a5,0(s0)
	net_if_get_link_addr(iface)->len = len;
4000cb4c:	01278a23          	sb	s2,20(a5)
	return &iface->if_dev->link_addr;
4000cb50:	00042783          	lw	a5,0(s0)
	net_if_get_link_addr(iface)->type = type;
4000cb54:	00978aa3          	sb	s1,21(a5)
	return 0;
4000cb58:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000cb5c:	c00ff0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000cb60:	02c12083          	lw	ra,44(sp)
4000cb64:	02812403          	lw	s0,40(sp)
4000cb68:	00c12503          	lw	a0,12(sp)
4000cb6c:	02412483          	lw	s1,36(sp)
4000cb70:	02012903          	lw	s2,32(sp)
4000cb74:	01c12983          	lw	s3,28(sp)
4000cb78:	03010113          	addi	sp,sp,48
4000cb7c:	00008067          	ret
		return -EPERM;
4000cb80:	fff00513          	li	a0,-1
4000cb84:	fd5ff06f          	j	4000cb58 <net_if_set_link_addr_locked+0x5c>

4000cb88 <net_if_lookup_by_dev>:
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000cb88:	4003d7b7          	lui	a5,0x4003d
{
4000cb8c:	00050713          	mv	a4,a0
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000cb90:	c3c78513          	addi	a0,a5,-964 # 4003cc3c <__net_if_dts_ord_12_0>
4000cb94:	4003d7b7          	lui	a5,0x4003d
4000cb98:	c4878793          	addi	a5,a5,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000cb9c:	00f56663          	bltu	a0,a5,4000cba8 <net_if_lookup_by_dev+0x20>
	return NULL;
4000cba0:	00000513          	li	a0,0
}
4000cba4:	00008067          	ret
	return iface->if_dev->dev;
4000cba8:	00052683          	lw	a3,0(a0)
		if (net_if_get_device(iface) == dev) {
4000cbac:	0006a683          	lw	a3,0(a3)
4000cbb0:	fed70ae3          	beq	a4,a3,4000cba4 <net_if_lookup_by_dev+0x1c>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000cbb4:	00c50513          	addi	a0,a0,12
4000cbb8:	fe5ff06f          	j	4000cb9c <net_if_lookup_by_dev+0x14>

4000cbbc <net_if_get_default>:
	if (&_net_if_list_start[0] == &_net_if_list_end[0]) {
4000cbbc:	4003d737          	lui	a4,0x4003d
4000cbc0:	4003d7b7          	lui	a5,0x4003d
4000cbc4:	c4878793          	addi	a5,a5,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000cbc8:	c3c70693          	addi	a3,a4,-964 # 4003cc3c <__net_if_dts_ord_12_0>
		return NULL;
4000cbcc:	00000513          	li	a0,0
	if (&_net_if_list_start[0] == &_net_if_list_end[0]) {
4000cbd0:	00f68a63          	beq	a3,a5,4000cbe4 <net_if_get_default+0x28>
	if (default_iface != NULL) {
4000cbd4:	400317b7          	lui	a5,0x40031
4000cbd8:	a6c7a503          	lw	a0,-1428(a5) # 40030a6c <default_iface>
4000cbdc:	00051463          	bnez	a0,4000cbe4 <net_if_get_default+0x28>
	return iface ? iface : _net_if_list_start;
4000cbe0:	c3c70513          	addi	a0,a4,-964
}
4000cbe4:	00008067          	ret

4000cbe8 <net_if_mcast_monitor>:
{
4000cbe8:	fe010113          	addi	sp,sp,-32
4000cbec:	00912a23          	sw	s1,20(sp)
4000cbf0:	01212823          	sw	s2,16(sp)
4000cbf4:	00050493          	mv	s1,a0
4000cbf8:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
4000cbfc:	fff00513          	li	a0,-1
4000cc00:	fff00593          	li	a1,-1
{
4000cc04:	01312623          	sw	s3,12(sp)
4000cc08:	00112e23          	sw	ra,28(sp)
4000cc0c:	00812c23          	sw	s0,24(sp)
4000cc10:	00060993          	mv	s3,a2
	k_mutex_lock(&lock, K_FOREVER);
4000cc14:	b34ff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4000cc18:	400317b7          	lui	a5,0x40031
4000cc1c:	a347a783          	lw	a5,-1484(a5) # 40030a34 <mcast_monitor_callbacks>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&mcast_monitor_callbacks,
4000cc20:	00078663          	beqz	a5,4000cc2c <net_if_mcast_monitor+0x44>
	return node->next;
4000cc24:	0007a403          	lw	s0,0(a5)
4000cc28:	02079063          	bnez	a5,4000cc48 <net_if_mcast_monitor+0x60>
}
4000cc2c:	01812403          	lw	s0,24(sp)
4000cc30:	01c12083          	lw	ra,28(sp)
4000cc34:	01412483          	lw	s1,20(sp)
4000cc38:	01012903          	lw	s2,16(sp)
4000cc3c:	00c12983          	lw	s3,12(sp)
4000cc40:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
4000cc44:	b18ff06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>
		if (iface == mon->iface) {
4000cc48:	0047a703          	lw	a4,4(a5)
4000cc4c:	00971c63          	bne	a4,s1,4000cc64 <net_if_mcast_monitor+0x7c>
			mon->cb(iface, addr, is_joined);
4000cc50:	0087a783          	lw	a5,8(a5)
4000cc54:	00098613          	mv	a2,s3
4000cc58:	00090593          	mv	a1,s2
4000cc5c:	00048513          	mv	a0,s1
4000cc60:	000780e7          	jalr	a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&mcast_monitor_callbacks,
4000cc64:	00000713          	li	a4,0
4000cc68:	00040463          	beqz	s0,4000cc70 <net_if_mcast_monitor+0x88>
4000cc6c:	00042703          	lw	a4,0(s0)
4000cc70:	00040793          	mv	a5,s0
4000cc74:	00070413          	mv	s0,a4
4000cc78:	fb1ff06f          	j	4000cc28 <net_if_mcast_monitor+0x40>

4000cc7c <net_if_config_ipv6_get>:
{
4000cc7c:	fe010113          	addi	sp,sp,-32
4000cc80:	00812c23          	sw	s0,24(sp)
4000cc84:	00912a23          	sw	s1,20(sp)
4000cc88:	00050413          	mv	s0,a0
4000cc8c:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
4000cc90:	fff00513          	li	a0,-1
4000cc94:	fff00593          	li	a1,-1
{
4000cc98:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000cc9c:	aacff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (!net_if_flag_is_set(iface, NET_IF_IPV6)) {
4000cca0:	00700593          	li	a1,7
4000cca4:	00040513          	mv	a0,s0
4000cca8:	951ff0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
4000ccac:	04050c63          	beqz	a0,4000cd04 <net_if_config_ipv6_get+0x88>
	if (iface->config.ip.ipv6) {
4000ccb0:	00442783          	lw	a5,4(s0)
4000ccb4:	02078863          	beqz	a5,4000cce4 <net_if_config_ipv6_get+0x68>
		if (ipv6) {
4000ccb8:	00048463          	beqz	s1,4000ccc0 <net_if_config_ipv6_get+0x44>
			*ipv6 = &ipv6_addresses[i].ipv6;
4000ccbc:	00f4a023          	sw	a5,0(s1)
	int ret = 0;
4000ccc0:	00000513          	li	a0,0
4000ccc4:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000ccc8:	a94ff0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000cccc:	01c12083          	lw	ra,28(sp)
4000ccd0:	01812403          	lw	s0,24(sp)
4000ccd4:	00c12503          	lw	a0,12(sp)
4000ccd8:	01412483          	lw	s1,20(sp)
4000ccdc:	02010113          	addi	sp,sp,32
4000cce0:	00008067          	ret
		if (ipv6_addresses[i].iface) {
4000cce4:	400327b7          	lui	a5,0x40032
4000cce8:	ce078793          	addi	a5,a5,-800 # 40031ce0 <ipv6_addresses>
4000ccec:	1287a703          	lw	a4,296(a5)
	ret = -ESRCH;
4000ccf0:	ffd00513          	li	a0,-3
		if (ipv6_addresses[i].iface) {
4000ccf4:	fc0718e3          	bnez	a4,4000ccc4 <net_if_config_ipv6_get+0x48>
		iface->config.ip.ipv6 = &ipv6_addresses[i].ipv6;
4000ccf8:	00f42223          	sw	a5,4(s0)
		ipv6_addresses[i].iface = iface;
4000ccfc:	1287a423          	sw	s0,296(a5)
4000cd00:	fb9ff06f          	j	4000ccb8 <net_if_config_ipv6_get+0x3c>
		ret = -ENOTSUP;
4000cd04:	f7a00513          	li	a0,-134
4000cd08:	fbdff06f          	j	4000ccc4 <net_if_config_ipv6_get+0x48>

4000cd0c <net_if_start_rs>:
{
4000cd0c:	ff010113          	addi	sp,sp,-16
4000cd10:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000cd14:	fff00593          	li	a1,-1
{
4000cd18:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000cd1c:	fff00513          	li	a0,-1
{
4000cd20:	00112623          	sw	ra,12(sp)
4000cd24:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000cd28:	a20ff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {
4000cd2c:	00b00593          	li	a1,11
4000cd30:	00040513          	mv	a0,s0
4000cd34:	8c5ff0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
4000cd38:	04051c63          	bnez	a0,4000cd90 <net_if_start_rs+0x84>
	ipv6 = iface->config.ip.ipv6;
4000cd3c:	00442483          	lw	s1,4(s0)
	if (!ipv6) {
4000cd40:	04048863          	beqz	s1,4000cd90 <net_if_start_rs+0x84>
	if (!net_ipv6_start_rs(iface)) {
4000cd44:	00040513          	mv	a0,s0
4000cd48:	2cd0c0ef          	jal	ra,40019814 <net_ipv6_start_rs>
4000cd4c:	04051263          	bnez	a0,4000cd90 <net_if_start_rs+0x84>
		ipv6->rs_start = k_uptime_get_32();
4000cd50:	974ff0ef          	jal	ra,4000bec4 <k_uptime_get_32>
4000cd54:	12a4a023          	sw	a0,288(s1)
		sys_slist_append(&active_rs_timers, &ipv6->rs_node);
4000cd58:	40031537          	lui	a0,0x40031
4000cd5c:	11c48593          	addi	a1,s1,284
4000cd60:	a4450513          	addi	a0,a0,-1468 # 40030a44 <active_rs_timers>
4000cd64:	dc5fe0ef          	jal	ra,4000bb28 <sys_slist_append>
4000cd68:	40031537          	lui	a0,0x40031
4000cd6c:	de850513          	addi	a0,a0,-536 # 40030de8 <rs_timer+0x10>
4000cd70:	4791d0ef          	jal	ra,4002a9e8 <z_timeout_remaining>
		if (!k_work_delayable_remaining_get(&rs_timer)) {
4000cd74:	00b56533          	or	a0,a0,a1
4000cd78:	00051c63          	bnez	a0,4000cd90 <net_if_start_rs+0x84>
			k_work_reschedule(&rs_timer, K_MSEC(RS_TIMEOUT));
4000cd7c:	40031537          	lui	a0,0x40031
4000cd80:	06400593          	li	a1,100
4000cd84:	00000613          	li	a2,0
4000cd88:	dd850513          	addi	a0,a0,-552 # 40030dd8 <rs_timer>
4000cd8c:	0991c0ef          	jal	ra,40029624 <k_work_reschedule>
}
4000cd90:	00812403          	lw	s0,8(sp)
4000cd94:	00c12083          	lw	ra,12(sp)
4000cd98:	00412483          	lw	s1,4(sp)
4000cd9c:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
4000cda0:	9bcff06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>

4000cda4 <rs_timeout>:
{
4000cda4:	fe010113          	addi	sp,sp,-32
4000cda8:	00112e23          	sw	ra,28(sp)
4000cdac:	00912a23          	sw	s1,20(sp)
4000cdb0:	01212823          	sw	s2,16(sp)
4000cdb4:	00812c23          	sw	s0,24(sp)
4000cdb8:	01312623          	sw	s3,12(sp)
4000cdbc:	01412423          	sw	s4,8(sp)
4000cdc0:	01512223          	sw	s5,4(sp)
	uint32_t current_time = k_uptime_get_32();
4000cdc4:	900ff0ef          	jal	ra,4000bec4 <k_uptime_get_32>
4000cdc8:	00050913          	mv	s2,a0
	k_mutex_lock(&lock, K_FOREVER);
4000cdcc:	fff00593          	li	a1,-1
4000cdd0:	fff00513          	li	a0,-1
4000cdd4:	974ff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4000cdd8:	400314b7          	lui	s1,0x40031
4000cddc:	a444a703          	lw	a4,-1468(s1) # 40030a44 <active_rs_timers>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_rs_timers,
4000cde0:	0c070463          	beqz	a4,4000cea8 <rs_timeout+0x104>
	return node->next;
4000cde4:	00072403          	lw	s0,0(a4)
4000cde8:	a4448493          	addi	s1,s1,-1468
4000cdec:	ee470793          	addi	a5,a4,-284
4000cdf0:	00040463          	beqz	s0,4000cdf8 <rs_timeout+0x54>
4000cdf4:	ee440413          	addi	s0,s0,-284
		delay = (int32_t)(ipv6->rs_start + RS_TIMEOUT - current_time);
4000cdf8:	3e800993          	li	s3,1000
4000cdfc:	412989b3          	sub	s3,s3,s2
		STRUCT_SECTION_FOREACH(net_if, tmp) {
4000ce00:	4003d937          	lui	s2,0x4003d
4000ce04:	4003dab7          	lui	s5,0x4003d
4000ce08:	c4890913          	addi	s2,s2,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
			if (ipv6->rs_count < RS_COUNT) {
4000ce0c:	00200a13          	li	s4,2
4000ce10:	00c0006f          	j	4000ce1c <rs_timeout+0x78>
{
4000ce14:	00040793          	mv	a5,s0
4000ce18:	00070413          	mv	s0,a4
		delay = (int32_t)(ipv6->rs_start + RS_TIMEOUT - current_time);
4000ce1c:	1207a583          	lw	a1,288(a5)
4000ce20:	00b985b3          	add	a1,s3,a1
		if (delay > 0) {
4000ce24:	04b04e63          	bgtz	a1,4000ce80 <rs_timeout+0xdc>
4000ce28:	11c7a683          	lw	a3,284(a5)
Z_GENLIST_REMOVE(slist, snode)
4000ce2c:	0044a603          	lw	a2,4(s1)
		sys_slist_remove(&active_rs_timers, NULL, &ipv6->rs_node);
4000ce30:	11c78713          	addi	a4,a5,284
	list->head = node;
4000ce34:	00d4a023          	sw	a3,0(s1)
Z_GENLIST_REMOVE(slist, snode)
4000ce38:	00e61463          	bne	a2,a4,4000ce40 <rs_timeout+0x9c>
	list->tail = node;
4000ce3c:	00d4a223          	sw	a3,4(s1)
		ipv6->rs_count++;
4000ce40:	1247c703          	lbu	a4,292(a5)
	parent->next = child;
4000ce44:	1007ae23          	sw	zero,284(a5)
		STRUCT_SECTION_FOREACH(net_if, tmp) {
4000ce48:	c3ca8513          	addi	a0,s5,-964 # 4003cc3c <__net_if_dts_ord_12_0>
		ipv6->rs_count++;
4000ce4c:	00170713          	addi	a4,a4,1
4000ce50:	0ff77713          	zext.b	a4,a4
4000ce54:	12e78223          	sb	a4,292(a5)
		STRUCT_SECTION_FOREACH(net_if, tmp) {
4000ce58:	01256c63          	bltu	a0,s2,4000ce70 <rs_timeout+0xcc>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_rs_timers,
4000ce5c:	04040663          	beqz	s0,4000cea8 <rs_timeout+0x104>
	return node->next;
4000ce60:	11c42703          	lw	a4,284(s0)
4000ce64:	fa0708e3          	beqz	a4,4000ce14 <rs_timeout+0x70>
4000ce68:	ee470713          	addi	a4,a4,-284
4000ce6c:	fa9ff06f          	j	4000ce14 <rs_timeout+0x70>
			if (tmp->config.ip.ipv6 == ipv6) {
4000ce70:	00452683          	lw	a3,4(a0)
4000ce74:	04f68c63          	beq	a3,a5,4000cecc <rs_timeout+0x128>
		STRUCT_SECTION_FOREACH(net_if, tmp) {
4000ce78:	00c50513          	addi	a0,a0,12
4000ce7c:	fddff06f          	j	4000ce58 <rs_timeout+0xb4>
		t += off;
4000ce80:	00958513          	addi	a0,a1,9
			return t / ((uint64_t)from_hz / to_hz);
4000ce84:	00a00613          	li	a2,10
4000ce88:	00000693          	li	a3,0
4000ce8c:	00b535b3          	sltu	a1,a0,a1
4000ce90:	c28f30ef          	jal	ra,400002b8 <__udivdi3>
		k_work_reschedule(&rs_timer, K_MSEC(ipv6->rs_start +
4000ce94:	00058613          	mv	a2,a1
4000ce98:	00050593          	mv	a1,a0
4000ce9c:	40031537          	lui	a0,0x40031
4000cea0:	dd850513          	addi	a0,a0,-552 # 40030dd8 <rs_timer>
4000cea4:	7801c0ef          	jal	ra,40029624 <k_work_reschedule>
}
4000cea8:	01812403          	lw	s0,24(sp)
4000ceac:	01c12083          	lw	ra,28(sp)
4000ceb0:	01412483          	lw	s1,20(sp)
4000ceb4:	01012903          	lw	s2,16(sp)
4000ceb8:	00c12983          	lw	s3,12(sp)
4000cebc:	00812a03          	lw	s4,8(sp)
4000cec0:	00412a83          	lw	s5,4(sp)
4000cec4:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
4000cec8:	894ff06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>
			if (ipv6->rs_count < RS_COUNT) {
4000cecc:	f8ea68e3          	bltu	s4,a4,4000ce5c <rs_timeout+0xb8>
				net_if_start_rs(iface);
4000ced0:	e3dff0ef          	jal	ra,4000cd0c <net_if_start_rs>
4000ced4:	f89ff06f          	j	4000ce5c <rs_timeout+0xb8>

4000ced8 <net_if_stop_rs>:
{
4000ced8:	ff010113          	addi	sp,sp,-16
4000cedc:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000cee0:	fff00593          	li	a1,-1
{
4000cee4:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000cee8:	fff00513          	li	a0,-1
{
4000ceec:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000cef0:	858ff0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
4000cef4:	00442583          	lw	a1,4(s0)
	if (!ipv6) {
4000cef8:	00058a63          	beqz	a1,4000cf0c <net_if_stop_rs+0x34>
	sys_slist_find_and_remove(&active_rs_timers, &ipv6->rs_node);
4000cefc:	40031537          	lui	a0,0x40031
4000cf00:	11c58593          	addi	a1,a1,284
4000cf04:	a4450513          	addi	a0,a0,-1468 # 40030a44 <active_rs_timers>
4000cf08:	c45fe0ef          	jal	ra,4000bb4c <sys_slist_find_and_remove>
}
4000cf0c:	00812403          	lw	s0,8(sp)
4000cf10:	00c12083          	lw	ra,12(sp)
4000cf14:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
4000cf18:	844ff06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>

4000cf1c <net_if_ipv6_addr_lookup>:
{
4000cf1c:	fd010113          	addi	sp,sp,-48
4000cf20:	02912223          	sw	s1,36(sp)
4000cf24:	01312e23          	sw	s3,28(sp)
4000cf28:	01512a23          	sw	s5,20(sp)
4000cf2c:	01612823          	sw	s6,16(sp)
4000cf30:	00058993          	mv	s3,a1
4000cf34:	00050b13          	mv	s6,a0
	k_mutex_lock(&lock, K_FOREVER);
4000cf38:	fff00593          	li	a1,-1
4000cf3c:	fff00513          	li	a0,-1
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000cf40:	4003d4b7          	lui	s1,0x4003d
4000cf44:	4003dab7          	lui	s5,0x4003d
{
4000cf48:	01712623          	sw	s7,12(sp)
4000cf4c:	01812423          	sw	s8,8(sp)
4000cf50:	01912223          	sw	s9,4(sp)
4000cf54:	02112623          	sw	ra,44(sp)
4000cf58:	02812423          	sw	s0,40(sp)
4000cf5c:	03212023          	sw	s2,32(sp)
4000cf60:	01412c23          	sw	s4,24(sp)
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000cf64:	c3c48493          	addi	s1,s1,-964 # 4003cc3c <__net_if_dts_ord_12_0>
	k_mutex_lock(&lock, K_FOREVER);
4000cf68:	fe1fe0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000cf6c:	c48a8a93          	addi	s5,s5,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
			if (!ipv6->unicast[i].is_used ||
4000cf70:	03000b93          	li	s7,48
4000cf74:	00200c13          	li	s8,2
		for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000cf78:	00300c93          	li	s9,3
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000cf7c:	0154e663          	bltu	s1,s5,4000cf88 <net_if_ipv6_addr_lookup+0x6c>
	struct net_if_addr *ifaddr = NULL;
4000cf80:	00000413          	li	s0,0
4000cf84:	0640006f          	j	4000cfe8 <net_if_ipv6_addr_lookup+0xcc>
		struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
4000cf88:	0044a403          	lw	s0,4(s1)
		if (!ipv6) {
4000cf8c:	00041663          	bnez	s0,4000cf98 <net_if_ipv6_addr_lookup+0x7c>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000cf90:	00c48493          	addi	s1,s1,12
4000cf94:	fe9ff06f          	j	4000cf7c <net_if_ipv6_addr_lookup+0x60>
4000cf98:	00440a13          	addi	s4,s0,4
		for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000cf9c:	00000913          	li	s2,0
			if (!ipv6->unicast[i].is_used ||
4000cfa0:	037907b3          	mul	a5,s2,s7
4000cfa4:	00f407b3          	add	a5,s0,a5
4000cfa8:	02c7a783          	lw	a5,44(a5)
4000cfac:	0197d793          	srli	a5,a5,0x19
4000cfb0:	0017f793          	andi	a5,a5,1
4000cfb4:	06078863          	beqz	a5,4000d024 <net_if_ipv6_addr_lookup+0x108>
4000cfb8:	ffca5783          	lhu	a5,-4(s4)
4000cfbc:	07879463          	bne	a5,s8,4000d024 <net_if_ipv6_addr_lookup+0x108>
			if (net_ipv6_is_prefix(
4000cfc0:	08000613          	li	a2,128
4000cfc4:	000a0593          	mv	a1,s4
4000cfc8:	000b0513          	mv	a0,s6
4000cfcc:	e2dfe0ef          	jal	ra,4000bdf8 <net_ipv6_is_prefix>
4000cfd0:	04050a63          	beqz	a0,4000d024 <net_if_ipv6_addr_lookup+0x108>
				if (ret) {
4000cfd4:	00098463          	beqz	s3,4000cfdc <net_if_ipv6_addr_lookup+0xc0>
					*ret = iface;
4000cfd8:	0099a023          	sw	s1,0(s3)
				ifaddr = &ipv6->unicast[i];
4000cfdc:	03000793          	li	a5,48
4000cfe0:	02f90933          	mul	s2,s2,a5
4000cfe4:	01240433          	add	s0,s0,s2
	k_mutex_unlock(&lock);
4000cfe8:	f75fe0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000cfec:	02c12083          	lw	ra,44(sp)
4000cff0:	00040513          	mv	a0,s0
4000cff4:	02812403          	lw	s0,40(sp)
4000cff8:	02412483          	lw	s1,36(sp)
4000cffc:	02012903          	lw	s2,32(sp)
4000d000:	01c12983          	lw	s3,28(sp)
4000d004:	01812a03          	lw	s4,24(sp)
4000d008:	01412a83          	lw	s5,20(sp)
4000d00c:	01012b03          	lw	s6,16(sp)
4000d010:	00c12b83          	lw	s7,12(sp)
4000d014:	00812c03          	lw	s8,8(sp)
4000d018:	00412c83          	lw	s9,4(sp)
4000d01c:	03010113          	addi	sp,sp,48
4000d020:	00008067          	ret
		for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d024:	00190913          	addi	s2,s2,1
4000d028:	030a0a13          	addi	s4,s4,48
4000d02c:	f7991ae3          	bne	s2,s9,4000cfa0 <net_if_ipv6_addr_lookup+0x84>
4000d030:	f61ff06f          	j	4000cf90 <net_if_ipv6_addr_lookup+0x74>

4000d034 <dad_timeout>:
{
4000d034:	fd010113          	addi	sp,sp,-48
4000d038:	02112623          	sw	ra,44(sp)
4000d03c:	03212023          	sw	s2,32(sp)
4000d040:	01312e23          	sw	s3,28(sp)
4000d044:	02812423          	sw	s0,40(sp)
4000d048:	02912223          	sw	s1,36(sp)
4000d04c:	01412c23          	sw	s4,24(sp)
4000d050:	01512a23          	sw	s5,20(sp)
4000d054:	01612823          	sw	s6,16(sp)
	uint32_t current_time = k_uptime_get_32();
4000d058:	e6dfe0ef          	jal	ra,4000bec4 <k_uptime_get_32>
4000d05c:	00050993          	mv	s3,a0
	k_mutex_lock(&lock, K_FOREVER);
4000d060:	fff00593          	li	a1,-1
4000d064:	fff00513          	li	a0,-1
4000d068:	ee1fe0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4000d06c:	40031937          	lui	s2,0x40031
4000d070:	a4c92783          	lw	a5,-1460(s2) # 40030a4c <active_dad_timers>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,
4000d074:	0e078263          	beqz	a5,4000d158 <dad_timeout+0x124>
	return node->next;
4000d078:	0007a483          	lw	s1,0(a5)
4000d07c:	a4c90913          	addi	s2,s2,-1460
4000d080:	fdc78413          	addi	s0,a5,-36
4000d084:	00048463          	beqz	s1,4000d08c <dad_timeout+0x58>
4000d088:	fdc48493          	addi	s1,s1,-36
				  DAD_TIMEOUT - current_time);
4000d08c:	06400a13          	li	s4,100
4000d090:	413a0a33          	sub	s4,s4,s3
			net_mgmt_event_notify_with_info(
4000d094:	e06009b7          	lui	s3,0xe0600
		ifaddr->addr_state = NET_ADDR_PREFERRED;
4000d098:	00100b13          	li	s6,1
			net_mgmt_event_notify_with_info(
4000d09c:	00d98993          	addi	s3,s3,13 # e060000d <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000e>
4000d0a0:	04c0006f          	j	4000d0ec <dad_timeout+0xb8>
		t += off;
4000d0a4:	00978513          	addi	a0,a5,9
		k_work_reschedule(&dad_timer, K_MSEC((uint32_t)delay));
4000d0a8:	41f7d593          	srai	a1,a5,0x1f
4000d0ac:	00f537b3          	sltu	a5,a0,a5
			return t / ((uint64_t)from_hz / to_hz);
4000d0b0:	00a00613          	li	a2,10
4000d0b4:	00000693          	li	a3,0
4000d0b8:	00b785b3          	add	a1,a5,a1
4000d0bc:	9fcf30ef          	jal	ra,400002b8 <__udivdi3>
4000d0c0:	00058613          	mv	a2,a1
4000d0c4:	00050593          	mv	a1,a0
4000d0c8:	40031537          	lui	a0,0x40031
4000d0cc:	e0850513          	addi	a0,a0,-504 # 40030e08 <dad_timer>
4000d0d0:	5541c0ef          	jal	ra,40029624 <k_work_reschedule>
4000d0d4:	0840006f          	j	4000d158 <dad_timeout+0x124>
4000d0d8:	0244a783          	lw	a5,36(s1)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,
4000d0dc:	00078463          	beqz	a5,4000d0e4 <dad_timeout+0xb0>
4000d0e0:	fdc78793          	addi	a5,a5,-36
{
4000d0e4:	00048413          	mv	s0,s1
4000d0e8:	00078493          	mv	s1,a5
				  DAD_TIMEOUT - current_time);
4000d0ec:	02842783          	lw	a5,40(s0)
4000d0f0:	00fa07b3          	add	a5,s4,a5
		if (delay > 0) {
4000d0f4:	faf048e3          	bgtz	a5,4000d0a4 <dad_timeout+0x70>
4000d0f8:	02442703          	lw	a4,36(s0)
Z_GENLIST_REMOVE(slist, snode)
4000d0fc:	00492683          	lw	a3,4(s2)
		sys_slist_remove(&active_dad_timers, NULL, &ifaddr->dad_node);
4000d100:	02440793          	addi	a5,s0,36
	list->head = node;
4000d104:	00e92023          	sw	a4,0(s2)
Z_GENLIST_REMOVE(slist, snode)
4000d108:	00f69463          	bne	a3,a5,4000d110 <dad_timeout+0xdc>
	list->tail = node;
4000d10c:	00e92223          	sw	a4,4(s2)
		tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr,
4000d110:	00440a93          	addi	s5,s0,4
	parent->next = child;
4000d114:	02042223          	sw	zero,36(s0)
		ifaddr->addr_state = NET_ADDR_PREFERRED;
4000d118:	036406a3          	sb	s6,45(s0)
		tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr,
4000d11c:	00c10593          	addi	a1,sp,12
4000d120:	000a8513          	mv	a0,s5
		iface = NULL;
4000d124:	00012623          	sw	zero,12(sp)
		tmp = net_if_ipv6_addr_lookup(&ifaddr->address.in6_addr,
4000d128:	df5ff0ef          	jal	ra,4000cf1c <net_if_ipv6_addr_lookup>
		if (tmp == ifaddr) {
4000d12c:	02a41463          	bne	s0,a0,4000d154 <dad_timeout+0x120>
			net_mgmt_event_notify_with_info(
4000d130:	00c12403          	lw	s0,12(sp)
4000d134:	00098513          	mv	a0,s3
4000d138:	01000693          	li	a3,16
4000d13c:	00040593          	mv	a1,s0
4000d140:	000a8613          	mv	a2,s5
4000d144:	5ed030ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
			net_ipv6_nbr_rm(iface, &ifaddr->address.in6_addr);
4000d148:	000a8593          	mv	a1,s5
4000d14c:	00040513          	mv	a0,s0
4000d150:	0a90a0ef          	jal	ra,400179f8 <net_ipv6_nbr_rm>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_dad_timers,
4000d154:	f80492e3          	bnez	s1,4000d0d8 <dad_timeout+0xa4>
}
4000d158:	02812403          	lw	s0,40(sp)
4000d15c:	02c12083          	lw	ra,44(sp)
4000d160:	02412483          	lw	s1,36(sp)
4000d164:	02012903          	lw	s2,32(sp)
4000d168:	01c12983          	lw	s3,28(sp)
4000d16c:	01812a03          	lw	s4,24(sp)
4000d170:	01412a83          	lw	s5,20(sp)
4000d174:	01012b03          	lw	s6,16(sp)
4000d178:	03010113          	addi	sp,sp,48
	k_mutex_unlock(&lock);
4000d17c:	de1fe06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>

4000d180 <net_if_ipv6_addr_lookup_by_iface>:
{
4000d180:	fd010113          	addi	sp,sp,-48
4000d184:	02812423          	sw	s0,40(sp)
4000d188:	01412c23          	sw	s4,24(sp)
4000d18c:	00050413          	mv	s0,a0
4000d190:	00058a13          	mv	s4,a1
	k_mutex_lock(&lock, K_FOREVER);
4000d194:	fff00513          	li	a0,-1
4000d198:	fff00593          	li	a1,-1
{
4000d19c:	01312e23          	sw	s3,28(sp)
4000d1a0:	02112623          	sw	ra,44(sp)
4000d1a4:	02912223          	sw	s1,36(sp)
4000d1a8:	03212023          	sw	s2,32(sp)
4000d1ac:	01512a23          	sw	s5,20(sp)
4000d1b0:	01612823          	sw	s6,16(sp)
4000d1b4:	01712623          	sw	s7,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000d1b8:	d91fe0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
4000d1bc:	00442983          	lw	s3,4(s0)
	if (!ipv6) {
4000d1c0:	04098c63          	beqz	s3,4000d218 <net_if_ipv6_addr_lookup_by_iface+0x98>
4000d1c4:	00498913          	addi	s2,s3,4
4000d1c8:	00000493          	li	s1,0
		if (!ipv6->unicast[i].is_used ||
4000d1cc:	03000b13          	li	s6,48
4000d1d0:	00200b93          	li	s7,2
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d1d4:	00300a93          	li	s5,3
		if (!ipv6->unicast[i].is_used ||
4000d1d8:	03648433          	mul	s0,s1,s6
4000d1dc:	00898433          	add	s0,s3,s0
4000d1e0:	02c42783          	lw	a5,44(s0)
4000d1e4:	0197d793          	srli	a5,a5,0x19
4000d1e8:	0017f793          	andi	a5,a5,1
4000d1ec:	02078063          	beqz	a5,4000d20c <net_if_ipv6_addr_lookup_by_iface+0x8c>
4000d1f0:	ffc95783          	lhu	a5,-4(s2)
4000d1f4:	01779c63          	bne	a5,s7,4000d20c <net_if_ipv6_addr_lookup_by_iface+0x8c>
		if (net_ipv6_is_prefix(
4000d1f8:	08000613          	li	a2,128
4000d1fc:	00090593          	mv	a1,s2
4000d200:	000a0513          	mv	a0,s4
4000d204:	bf5fe0ef          	jal	ra,4000bdf8 <net_ipv6_is_prefix>
4000d208:	00051a63          	bnez	a0,4000d21c <net_if_ipv6_addr_lookup_by_iface+0x9c>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d20c:	00148493          	addi	s1,s1,1
4000d210:	03090913          	addi	s2,s2,48
4000d214:	fd5492e3          	bne	s1,s5,4000d1d8 <net_if_ipv6_addr_lookup_by_iface+0x58>
	struct net_if_addr *ifaddr = NULL;
4000d218:	00000413          	li	s0,0
	k_mutex_unlock(&lock);
4000d21c:	d41fe0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000d220:	02c12083          	lw	ra,44(sp)
4000d224:	00040513          	mv	a0,s0
4000d228:	02812403          	lw	s0,40(sp)
4000d22c:	02412483          	lw	s1,36(sp)
4000d230:	02012903          	lw	s2,32(sp)
4000d234:	01c12983          	lw	s3,28(sp)
4000d238:	01812a03          	lw	s4,24(sp)
4000d23c:	01412a83          	lw	s5,20(sp)
4000d240:	01012b03          	lw	s6,16(sp)
4000d244:	00c12b83          	lw	s7,12(sp)
4000d248:	03010113          	addi	sp,sp,48
4000d24c:	00008067          	ret

4000d250 <net_if_ipv6_addr_update_lifetime>:
{
4000d250:	ff010113          	addi	sp,sp,-16
4000d254:	00812423          	sw	s0,8(sp)
4000d258:	00912223          	sw	s1,4(sp)
4000d25c:	00050413          	mv	s0,a0
4000d260:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
4000d264:	fff00513          	li	a0,-1
4000d268:	fff00593          	li	a1,-1
{
4000d26c:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000d270:	cd9fe0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	ifaddr->addr_state = NET_ADDR_PREFERRED;
4000d274:	00100793          	li	a5,1
4000d278:	02f406a3          	sb	a5,45(s0)
	sys_slist_append(&active_address_lifetime_timers,
4000d27c:	40031537          	lui	a0,0x40031
4000d280:	01440413          	addi	s0,s0,20
4000d284:	00040593          	mv	a1,s0
4000d288:	a5c50513          	addi	a0,a0,-1444 # 40030a5c <active_address_lifetime_timers>
4000d28c:	89dfe0ef          	jal	ra,4000bb28 <sys_slist_append>
	net_timeout_set(&ifaddr->lifetime, vlifetime, k_uptime_get_32());
4000d290:	c35fe0ef          	jal	ra,4000bec4 <k_uptime_get_32>
4000d294:	00050613          	mv	a2,a0
4000d298:	00048593          	mv	a1,s1
4000d29c:	00040513          	mv	a0,s0
4000d2a0:	7ec020ef          	jal	ra,4000fa8c <net_timeout_set>
	k_work_reschedule(&address_lifetime_timer, K_NO_WAIT);
4000d2a4:	40031537          	lui	a0,0x40031
4000d2a8:	00000593          	li	a1,0
4000d2ac:	00000613          	li	a2,0
4000d2b0:	e6850513          	addi	a0,a0,-408 # 40030e68 <address_lifetime_timer>
4000d2b4:	3701c0ef          	jal	ra,40029624 <k_work_reschedule>
}
4000d2b8:	00812403          	lw	s0,8(sp)
4000d2bc:	00c12083          	lw	ra,12(sp)
4000d2c0:	00412483          	lw	s1,4(sp)
4000d2c4:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
4000d2c8:	c95fe06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>

4000d2cc <net_if_ipv6_addr_add>:
{
4000d2cc:	fa010113          	addi	sp,sp,-96
4000d2d0:	04912a23          	sw	s1,84(sp)
4000d2d4:	05412423          	sw	s4,72(sp)
4000d2d8:	00050493          	mv	s1,a0
4000d2dc:	00058a13          	mv	s4,a1
	k_mutex_lock(&lock, K_FOREVER);
4000d2e0:	fff00513          	li	a0,-1
4000d2e4:	fff00593          	li	a1,-1
{
4000d2e8:	05612023          	sw	s6,64(sp)
4000d2ec:	03712e23          	sw	s7,60(sp)
4000d2f0:	04112e23          	sw	ra,92(sp)
4000d2f4:	04812c23          	sw	s0,88(sp)
4000d2f8:	05212823          	sw	s2,80(sp)
4000d2fc:	05312623          	sw	s3,76(sp)
4000d300:	05512223          	sw	s5,68(sp)
4000d304:	03812c23          	sw	s8,56(sp)
4000d308:	03912a23          	sw	s9,52(sp)
4000d30c:	00060b93          	mv	s7,a2
4000d310:	00068b13          	mv	s6,a3
	k_mutex_lock(&lock, K_FOREVER);
4000d314:	c35fe0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
4000d318:	00c10593          	addi	a1,sp,12
4000d31c:	00048513          	mv	a0,s1
4000d320:	95dff0ef          	jal	ra,4000cc7c <net_if_config_ipv6_get>
4000d324:	04055263          	bgez	a0,4000d368 <net_if_ipv6_addr_add+0x9c>
	struct net_if_addr *ifaddr = NULL;
4000d328:	00000413          	li	s0,0
	k_mutex_unlock(&lock);
4000d32c:	c31fe0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000d330:	05c12083          	lw	ra,92(sp)
4000d334:	00040513          	mv	a0,s0
4000d338:	05812403          	lw	s0,88(sp)
4000d33c:	05412483          	lw	s1,84(sp)
4000d340:	05012903          	lw	s2,80(sp)
4000d344:	04c12983          	lw	s3,76(sp)
4000d348:	04812a03          	lw	s4,72(sp)
4000d34c:	04412a83          	lw	s5,68(sp)
4000d350:	04012b03          	lw	s6,64(sp)
4000d354:	03c12b83          	lw	s7,60(sp)
4000d358:	03812c03          	lw	s8,56(sp)
4000d35c:	03412c83          	lw	s9,52(sp)
4000d360:	06010113          	addi	sp,sp,96
4000d364:	00008067          	ret
	ifaddr = ipv6_addr_find(iface, addr);
4000d368:	0044aa83          	lw	s5,4(s1)
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d36c:	00000913          	li	s2,0
		if (!ipv6->unicast[i].is_used) {
4000d370:	03000c93          	li	s9,48
4000d374:	004a8993          	addi	s3,s5,4
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d378:	00300c13          	li	s8,3
		if (!ipv6->unicast[i].is_used) {
4000d37c:	03990433          	mul	s0,s2,s9
4000d380:	008a8433          	add	s0,s5,s0
4000d384:	02c42783          	lw	a5,44(s0)
4000d388:	0197d793          	srli	a5,a5,0x19
4000d38c:	0017f793          	andi	a5,a5,1
4000d390:	00078a63          	beqz	a5,4000d3a4 <net_if_ipv6_addr_add+0xd8>
		if (net_ipv6_addr_cmp(
4000d394:	00098593          	mv	a1,s3
4000d398:	000a0513          	mv	a0,s4
4000d39c:	b09fe0ef          	jal	ra,4000bea4 <net_ipv6_addr_cmp>
4000d3a0:	f80516e3          	bnez	a0,4000d32c <net_if_ipv6_addr_add+0x60>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d3a4:	00190913          	addi	s2,s2,1
4000d3a8:	03098993          	addi	s3,s3,48
4000d3ac:	fd8918e3          	bne	s2,s8,4000d37c <net_if_ipv6_addr_add+0xb0>
		if (ipv6->unicast[i].is_used) {
4000d3b0:	00c12a83          	lw	s5,12(sp)
4000d3b4:	02caa783          	lw	a5,44(s5)
4000d3b8:	0197d793          	srli	a5,a5,0x19
4000d3bc:	0017f793          	andi	a5,a5,1
4000d3c0:	16078663          	beqz	a5,4000d52c <net_if_ipv6_addr_add+0x260>
4000d3c4:	05caa783          	lw	a5,92(s5)
4000d3c8:	0197d793          	srli	a5,a5,0x19
4000d3cc:	0017f793          	andi	a5,a5,1
4000d3d0:	16078263          	beqz	a5,4000d534 <net_if_ipv6_addr_add+0x268>
4000d3d4:	08caa783          	lw	a5,140(s5)
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d3d8:	00200993          	li	s3,2
		if (ipv6->unicast[i].is_used) {
4000d3dc:	0197d793          	srli	a5,a5,0x19
4000d3e0:	0017f793          	andi	a5,a5,1
4000d3e4:	f40792e3          	bnez	a5,4000d328 <net_if_ipv6_addr_add+0x5c>
		net_if_addr_init(&ipv6->unicast[i], addr, addr_type,
4000d3e8:	03000913          	li	s2,48
4000d3ec:	03298933          	mul	s2,s3,s2
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
4000d3f0:	01000613          	li	a2,16
4000d3f4:	000a0593          	mv	a1,s4
4000d3f8:	01010513          	addi	a0,sp,16
		net_if_addr_init(&ipv6->unicast[i], addr, addr_type,
4000d3fc:	012a8433          	add	s0,s5,s2
	ifaddr->is_used = true;
4000d400:	02f44783          	lbu	a5,47(s0)
	ifaddr->addr_type = addr_type;
4000d404:	03740623          	sb	s7,44(s0)
	ifaddr->is_used = true;
4000d408:	0027e793          	ori	a5,a5,2
4000d40c:	02f407a3          	sb	a5,47(s0)
	ifaddr->address.family = AF_INET6;
4000d410:	00200793          	li	a5,2
4000d414:	00f41023          	sh	a5,0(s0)
	net_ipaddr_copy(&ifaddr->address.in6_addr, addr);
4000d418:	c35fb0ef          	jal	ra,4000904c <memcpy>
4000d41c:	01000613          	li	a2,16
4000d420:	01010593          	addi	a1,sp,16
4000d424:	00440513          	addi	a0,s0,4
4000d428:	c25fb0ef          	jal	ra,4000904c <memcpy>
	if (vlifetime) {
4000d42c:	02f44783          	lbu	a5,47(s0)
4000d430:	100b0663          	beqz	s6,4000d53c <net_if_ipv6_addr_add+0x270>
		ifaddr->is_infinite = false;
4000d434:	ffe7f793          	andi	a5,a5,-2
4000d438:	02f407a3          	sb	a5,47(s0)
		net_if_ipv6_addr_update_lifetime(ifaddr, vlifetime);
4000d43c:	000b0593          	mv	a1,s6
4000d440:	00040513          	mv	a0,s0
4000d444:	e0dff0ef          	jal	ra,4000d250 <net_if_ipv6_addr_update_lifetime>
		if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT) &&
4000d448:	00048513          	mv	a0,s1
4000d44c:	8f1fe0ef          	jal	ra,4000bd3c <l2_flags_get>
			join_mcast_nodes(iface,
4000d450:	00490913          	addi	s2,s2,4
		if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT) &&
4000d454:	00857513          	andi	a0,a0,8
			join_mcast_nodes(iface,
4000d458:	012a8933          	add	s2,s5,s2
		if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT) &&
4000d45c:	0e051663          	bnez	a0,4000d548 <net_if_ipv6_addr_add+0x27c>
		    !net_ipv6_is_addr_loopback(addr) &&
4000d460:	000a0513          	mv	a0,s4
4000d464:	f44fe0ef          	jal	ra,4000bba8 <net_ipv6_is_addr_loopback>
		if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT) &&
4000d468:	0e051063          	bnez	a0,4000d548 <net_if_ipv6_addr_add+0x27c>
		    !net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {
4000d46c:	00b00593          	li	a1,11
4000d470:	00048513          	mv	a0,s1
4000d474:	984ff0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
		    !net_ipv6_is_addr_loopback(addr) &&
4000d478:	0c051863          	bnez	a0,4000d548 <net_if_ipv6_addr_add+0x27c>
	flags = l2_flags_get(iface);
4000d47c:	00048513          	mv	a0,s1
4000d480:	8bdfe0ef          	jal	ra,4000bd3c <l2_flags_get>
	if (flags & NET_L2_MULTICAST) {
4000d484:	00157793          	andi	a5,a0,1
	flags = l2_flags_get(iface);
4000d488:	00050a13          	mv	s4,a0
	if (flags & NET_L2_MULTICAST) {
4000d48c:	06078c63          	beqz	a5,4000d504 <net_if_ipv6_addr_add+0x238>
					uint16_t addr0, uint16_t addr1,
					uint16_t addr2, uint16_t addr3,
					uint16_t addr4, uint16_t addr5,
					uint16_t addr6, uint16_t addr7)
{
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
4000d490:	2ff00b93          	li	s7,767
	UNALIGNED_PUT(htons(addr1), &addr->s6_addr16[1]);
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
	UNALIGNED_PUT(htons(addr3), &addr->s6_addr16[3]);
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
	UNALIGNED_PUT(htons(addr5), &addr->s6_addr16[5]);
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
4000d494:	01000b37          	lui	s6,0x1000
	ret = net_ipv6_mld_join(iface, &addr);
4000d498:	02010593          	addi	a1,sp,32
4000d49c:	00048513          	mv	a0,s1
		if (!(flags & NET_L2_MULTICAST_SKIP_JOIN_SOLICIT_NODE)) {
4000d4a0:	002a7a13          	andi	s4,s4,2
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
4000d4a4:	03712023          	sw	s7,32(sp)
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
4000d4a8:	02012223          	sw	zero,36(sp)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
4000d4ac:	02012423          	sw	zero,40(sp)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
4000d4b0:	03612623          	sw	s6,44(sp)
	ret = net_ipv6_mld_join(iface, &addr);
4000d4b4:	1290c0ef          	jal	ra,40019ddc <net_ipv6_mld_join>
		if (!(flags & NET_L2_MULTICAST_SKIP_JOIN_SOLICIT_NODE)) {
4000d4b8:	040a1663          	bnez	s4,4000d504 <net_if_ipv6_addr_add+0x238>
	dst->s6_addr[12]  = 0xFF;
4000d4bc:	fff00793          	li	a5,-1
4000d4c0:	02f10623          	sb	a5,44(sp)
	dst->s6_addr[13]  = src->s6_addr[13];
4000d4c4:	03000793          	li	a5,48
4000d4c8:	02f987b3          	mul	a5,s3,a5
	dst->s6_addr[0]   = 0xFF;
4000d4cc:	03712023          	sw	s7,32(sp)
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
4000d4d0:	02012223          	sw	zero,36(sp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
4000d4d4:	03612423          	sw	s6,40(sp)
	ret = net_ipv6_mld_join(iface, &addr);
4000d4d8:	02010593          	addi	a1,sp,32
4000d4dc:	00048513          	mv	a0,s1
	dst->s6_addr[13]  = src->s6_addr[13];
4000d4e0:	00fa87b3          	add	a5,s5,a5
4000d4e4:	0117c783          	lbu	a5,17(a5)
4000d4e8:	02f106a3          	sb	a5,45(sp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
4000d4ec:	00f94783          	lbu	a5,15(s2)
4000d4f0:	00e94703          	lbu	a4,14(s2)
4000d4f4:	00879793          	slli	a5,a5,0x8
4000d4f8:	00e7e7b3          	or	a5,a5,a4
4000d4fc:	02f11723          	sh	a5,46(sp)
4000d500:	0dd0c0ef          	jal	ra,40019ddc <net_ipv6_mld_join>
			net_if_ipv6_start_dad(iface, &ipv6->unicast[i]);
4000d504:	00040593          	mv	a1,s0
4000d508:	00048513          	mv	a0,s1
4000d50c:	92cff0ef          	jal	ra,4000c638 <net_if_ipv6_start_dad>
		net_mgmt_event_notify_with_info(
4000d510:	e0600537          	lui	a0,0xe0600
4000d514:	01000693          	li	a3,16
4000d518:	00090613          	mv	a2,s2
4000d51c:	00048593          	mv	a1,s1
4000d520:	00150513          	addi	a0,a0,1 # e0600001 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600002>
4000d524:	20d030ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
		goto out;
4000d528:	e05ff06f          	j	4000d32c <net_if_ipv6_addr_add+0x60>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d52c:	00000993          	li	s3,0
4000d530:	eb9ff06f          	j	4000d3e8 <net_if_ipv6_addr_add+0x11c>
4000d534:	00100993          	li	s3,1
4000d538:	eb1ff06f          	j	4000d3e8 <net_if_ipv6_addr_add+0x11c>
		ifaddr->is_infinite = true;
4000d53c:	0017e793          	ori	a5,a5,1
4000d540:	02f407a3          	sb	a5,47(s0)
4000d544:	f05ff06f          	j	4000d448 <net_if_ipv6_addr_add+0x17c>
			ipv6->unicast[i].addr_state = NET_ADDR_PREFERRED;
4000d548:	03000793          	li	a5,48
4000d54c:	02f989b3          	mul	s3,s3,a5
4000d550:	00100713          	li	a4,1
4000d554:	013a87b3          	add	a5,s5,s3
4000d558:	02e786a3          	sb	a4,45(a5)
4000d55c:	fb5ff06f          	j	4000d510 <net_if_ipv6_addr_add+0x244>

4000d560 <net_if_start_dad>:
{
4000d560:	fb010113          	addi	sp,sp,-80
4000d564:	04912223          	sw	s1,68(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000d568:	fff00593          	li	a1,-1
{
4000d56c:	00050493          	mv	s1,a0
	k_mutex_lock(&lock, K_FOREVER);
4000d570:	fff00513          	li	a0,-1
{
4000d574:	04112623          	sw	ra,76(sp)
4000d578:	04812423          	sw	s0,72(sp)
4000d57c:	05212023          	sw	s2,64(sp)
4000d580:	03312e23          	sw	s3,60(sp)
4000d584:	03412c23          	sw	s4,56(sp)
4000d588:	03512a23          	sw	s5,52(sp)
4000d58c:	03612823          	sw	s6,48(sp)
4000d590:	03712623          	sw	s7,44(sp)
	struct in6_addr addr = { };
4000d594:	00012823          	sw	zero,16(sp)
4000d598:	00012a23          	sw	zero,20(sp)
4000d59c:	00012c23          	sw	zero,24(sp)
4000d5a0:	00012e23          	sw	zero,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000d5a4:	9a5fe0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	ret = net_if_config_ipv6_get(iface, &ipv6);
4000d5a8:	00c10593          	addi	a1,sp,12
4000d5ac:	00048513          	mv	a0,s1
4000d5b0:	eccff0ef          	jal	ra,4000cc7c <net_if_config_ipv6_get>
	if (ret < 0) {
4000d5b4:	02055a63          	bgez	a0,4000d5e8 <net_if_start_dad+0x88>
	k_mutex_unlock(&lock);
4000d5b8:	9a5fe0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000d5bc:	04c12083          	lw	ra,76(sp)
4000d5c0:	04812403          	lw	s0,72(sp)
4000d5c4:	04412483          	lw	s1,68(sp)
4000d5c8:	04012903          	lw	s2,64(sp)
4000d5cc:	03c12983          	lw	s3,60(sp)
4000d5d0:	03812a03          	lw	s4,56(sp)
4000d5d4:	03412a83          	lw	s5,52(sp)
4000d5d8:	03012b03          	lw	s6,48(sp)
4000d5dc:	02c12b83          	lw	s7,44(sp)
4000d5e0:	05010113          	addi	sp,sp,80
4000d5e4:	00008067          	ret
	if (!ipv6) {
4000d5e8:	00c12983          	lw	s3,12(sp)
4000d5ec:	fc0986e3          	beqz	s3,4000d5b8 <net_if_start_dad+0x58>
	return &iface->if_dev->link_addr;
4000d5f0:	0004a403          	lw	s0,0(s1)
 *  @param lladdr Link local address
 */
static inline void net_ipv6_addr_create_iid(struct in6_addr *addr,
					    struct net_linkaddr *lladdr)
{
	UNALIGNED_PUT(htonl(0xfe800000), &addr->s6_addr32[0]);
4000d5f4:	000087b7          	lui	a5,0x8
4000d5f8:	0fe78793          	addi	a5,a5,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
4000d5fc:	00f12823          	sw	a5,16(sp)
	UNALIGNED_PUT(0, &addr->s6_addr32[1]);

	switch (lladdr->len) {
4000d600:	01444783          	lbu	a5,20(s0)
	UNALIGNED_PUT(0, &addr->s6_addr32[1]);
4000d604:	00012a23          	sw	zero,20(sp)
	switch (lladdr->len) {
4000d608:	00600713          	li	a4,6
4000d60c:	0ae78e63          	beq	a5,a4,4000d6c8 <net_if_start_dad+0x168>
4000d610:	00800713          	li	a4,8
4000d614:	10e78263          	beq	a5,a4,4000d718 <net_if_start_dad+0x1b8>
4000d618:	00200713          	li	a4,2
4000d61c:	02e79a63          	bne	a5,a4,4000d650 <net_if_start_dad+0xf0>
	case 2:
		/* The generated IPv6 shall not toggle the
		 * Universal/Local bit. RFC 6282 ch 3.2.2
		 */
		if (lladdr->type == NET_LINK_IEEE802154) {
4000d620:	01544703          	lbu	a4,21(s0)
4000d624:	00100793          	li	a5,1
4000d628:	02f71463          	bne	a4,a5,4000d650 <net_if_start_dad+0xf0>
			UNALIGNED_PUT(0, &addr->s6_addr32[2]);
4000d62c:	ff0007b7          	lui	a5,0xff000
4000d630:	00f12c23          	sw	a5,24(sp)
			addr->s6_addr[11] = 0xff;
			addr->s6_addr[12] = 0xfe;
4000d634:	0fe00793          	li	a5,254
4000d638:	00f11e23          	sh	a5,28(sp)
			addr->s6_addr[13] = 0U;
			addr->s6_addr[14] = lladdr->addr[0];
4000d63c:	01042783          	lw	a5,16(s0)
4000d640:	0007c703          	lbu	a4,0(a5) # ff000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xff000001>
4000d644:	00e10f23          	sb	a4,30(sp)
			addr->s6_addr[15] = lladdr->addr[1];
4000d648:	0017c783          	lbu	a5,1(a5)
4000d64c:	00f10fa3          	sb	a5,31(sp)
	ifaddr = net_if_ipv6_addr_add(iface, &addr, NET_ADDR_AUTOCONF, 0);
4000d650:	00000693          	li	a3,0
4000d654:	00100613          	li	a2,1
4000d658:	01010593          	addi	a1,sp,16
4000d65c:	00048513          	mv	a0,s1
4000d660:	c6dff0ef          	jal	ra,4000d2cc <net_if_ipv6_addr_add>
4000d664:	00050a13          	mv	s4,a0
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d668:	00098413          	mv	s0,s3
	ifaddr = net_if_ipv6_addr_add(iface, &addr, NET_ADDR_AUTOCONF, 0);
4000d66c:	00000913          	li	s2,0
		if (!ipv6->unicast[i].is_used ||
4000d670:	03000b13          	li	s6,48
4000d674:	00200b93          	li	s7,2
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d678:	00300a93          	li	s5,3
		if (!ipv6->unicast[i].is_used ||
4000d67c:	036907b3          	mul	a5,s2,s6
4000d680:	00f987b3          	add	a5,s3,a5
4000d684:	02c7a783          	lw	a5,44(a5)
4000d688:	0197d793          	srli	a5,a5,0x19
4000d68c:	0017f793          	andi	a5,a5,1
4000d690:	02078463          	beqz	a5,4000d6b8 <net_if_start_dad+0x158>
4000d694:	00045783          	lhu	a5,0(s0)
4000d698:	03779063          	bne	a5,s7,4000d6b8 <net_if_start_dad+0x158>
		    ipv6->unicast[i].address.family != AF_INET6 ||
4000d69c:	008a0e63          	beq	s4,s0,4000d6b8 <net_if_start_dad+0x158>
		    net_ipv6_is_addr_loopback(
4000d6a0:	00440513          	addi	a0,s0,4
4000d6a4:	d04fe0ef          	jal	ra,4000bba8 <net_ipv6_is_addr_loopback>
		    &ipv6->unicast[i] == ifaddr ||
4000d6a8:	00051863          	bnez	a0,4000d6b8 <net_if_start_dad+0x158>
		net_if_ipv6_start_dad(iface, &ipv6->unicast[i]);
4000d6ac:	00040593          	mv	a1,s0
4000d6b0:	00048513          	mv	a0,s1
4000d6b4:	f85fe0ef          	jal	ra,4000c638 <net_if_ipv6_start_dad>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d6b8:	00190913          	addi	s2,s2,1
4000d6bc:	03040413          	addi	s0,s0,48
4000d6c0:	fb591ee3          	bne	s2,s5,4000d67c <net_if_start_dad+0x11c>
4000d6c4:	ef5ff06f          	j	4000d5b8 <net_if_start_dad+0x58>
		break;
	case 6:
		/* We do not toggle the Universal/Local bit
		 * in Bluetooth. See RFC 7668 ch 3.2.2
		 */
		memcpy(&addr->s6_addr[8], lladdr->addr, 3);
4000d6c8:	01042583          	lw	a1,16(s0)
4000d6cc:	00300613          	li	a2,3
4000d6d0:	01810513          	addi	a0,sp,24
4000d6d4:	979fb0ef          	jal	ra,4000904c <memcpy>
		addr->s6_addr[11] = 0xff;
		addr->s6_addr[12] = 0xfe;
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
4000d6d8:	01042583          	lw	a1,16(s0)
		addr->s6_addr[11] = 0xff;
4000d6dc:	fff00793          	li	a5,-1
4000d6e0:	00f10da3          	sb	a5,27(sp)
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
4000d6e4:	00300613          	li	a2,3
		addr->s6_addr[12] = 0xfe;
4000d6e8:	ffe00793          	li	a5,-2
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
4000d6ec:	00358593          	addi	a1,a1,3
4000d6f0:	01d10513          	addi	a0,sp,29
		addr->s6_addr[12] = 0xfe;
4000d6f4:	00f10e23          	sb	a5,28(sp)
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
4000d6f8:	955fb0ef          	jal	ra,4000904c <memcpy>
		if (lladdr->type == NET_LINK_BLUETOOTH) {
			addr->s6_addr[8] ^= 0x02;
		}
#endif

		if (lladdr->type == NET_LINK_ETHERNET) {
4000d6fc:	01544703          	lbu	a4,21(s0)
4000d700:	00300793          	li	a5,3
4000d704:	f4f716e3          	bne	a4,a5,4000d650 <net_if_start_dad+0xf0>
		}

		break;
	case 8:
		memcpy(&addr->s6_addr[8], lladdr->addr, lladdr->len);
		addr->s6_addr[8] ^= 0x02;
4000d708:	01814783          	lbu	a5,24(sp)
4000d70c:	0027c793          	xori	a5,a5,2
4000d710:	00f10c23          	sb	a5,24(sp)
		break;
4000d714:	f3dff06f          	j	4000d650 <net_if_start_dad+0xf0>
		memcpy(&addr->s6_addr[8], lladdr->addr, lladdr->len);
4000d718:	01042583          	lw	a1,16(s0)
4000d71c:	00800613          	li	a2,8
4000d720:	01810513          	addi	a0,sp,24
4000d724:	929fb0ef          	jal	ra,4000904c <memcpy>
4000d728:	fe1ff06f          	j	4000d708 <net_if_start_dad+0x1a8>

4000d72c <update_operational_state>:
	return "";
#endif /* CONFIG_NET_IF_LOG_LEVEL >= LOG_LEVEL_DBG */
}

static void update_operational_state(struct net_if *iface)
{
4000d72c:	ff010113          	addi	sp,sp,-16
4000d730:	00812423          	sw	s0,8(sp)
4000d734:	00112623          	sw	ra,12(sp)
4000d738:	00912223          	sw	s1,4(sp)
	enum net_if_oper_state prev_state = iface->if_dev->oper_state;
4000d73c:	00052783          	lw	a5,0(a0)
 */
static inline bool net_if_is_admin_up(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_UP);
4000d740:	00000593          	li	a1,0
{
4000d744:	00050413          	mv	s0,a0
	enum net_if_oper_state prev_state = iface->if_dev->oper_state;
4000d748:	01a7c483          	lbu	s1,26(a5)
4000d74c:	eadfe0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
	enum net_if_oper_state new_state = NET_IF_OPER_UNKNOWN;

	if (!net_if_is_admin_up(iface)) {
4000d750:	06051063          	bnez	a0,4000d7b0 <update_operational_state+0x84>
		iface->if_dev->oper_state = oper_state;
4000d754:	00042703          	lw	a4,0(s0)
4000d758:	00200793          	li	a5,2
4000d75c:	00f70d23          	sb	a5,26(a4)
	return iface->if_dev->oper_state;
4000d760:	00042503          	lw	a0,0(s0)
	}

	new_state = NET_IF_OPER_UP;

exit:
	if (net_if_oper_state_set(iface, new_state) != new_state) {
4000d764:	01a54703          	lbu	a4,26(a0)
4000d768:	10f71063          	bne	a4,a5,4000d868 <update_operational_state+0x13c>
	if (net_if_oper_state(iface) == NET_IF_OPER_UP) {
		if (prev_state != NET_IF_OPER_UP) {
			notify_iface_up(iface);
		}
	} else {
		if (prev_state == NET_IF_OPER_UP) {
4000d76c:	00600793          	li	a5,6
4000d770:	0ef49c63          	bne	s1,a5,4000d868 <update_operational_state+0x13c>
	atomic_clear_bit(iface->if_dev->flags, value);
4000d774:	00800593          	li	a1,8
4000d778:	00c50513          	addi	a0,a0,12
4000d77c:	f68fe0ef          	jal	ra,4000bee4 <atomic_clear_bit>
				     const void *info, size_t length);

static inline void net_mgmt_event_notify(uint32_t mgmt_event,
					 struct net_if *iface)
{
	net_mgmt_event_notify_with_info(mgmt_event, iface, NULL, 0);
4000d780:	d0010537          	lui	a0,0xd0010
4000d784:	00040593          	mv	a1,s0
4000d788:	00150513          	addi	a0,a0,1 # d0010001 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd0010002>
4000d78c:	00000693          	li	a3,0
4000d790:	00000613          	li	a2,0
4000d794:	79c030ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
	    !(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
4000d798:	00040513          	mv	a0,s0
			notify_iface_down(iface);
		}
	}
}
4000d79c:	00812403          	lw	s0,8(sp)
4000d7a0:	00c12083          	lw	ra,12(sp)
4000d7a4:	00412483          	lw	s1,4(sp)
4000d7a8:	01010113          	addi	sp,sp,16
	    !(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
4000d7ac:	d90fe06f          	j	4000bd3c <l2_flags_get>
 */
static inline bool net_if_is_carrier_ok(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_LOWER_UP);
4000d7b0:	00900593          	li	a1,9
4000d7b4:	00040513          	mv	a0,s0
4000d7b8:	e41fe0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
	if (!net_if_is_carrier_ok(iface)) {
4000d7bc:	f8050ce3          	beqz	a0,4000d754 <update_operational_state+0x28>
 */
static inline bool net_if_is_dormant(struct net_if *iface)
{
	NET_ASSERT(iface);

	return net_if_flag_is_set(iface, NET_IF_DORMANT);
4000d7c0:	00a00593          	li	a1,10
4000d7c4:	00040513          	mv	a0,s0
4000d7c8:	e31fe0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
		iface->if_dev->oper_state = oper_state;
4000d7cc:	00042703          	lw	a4,0(s0)
4000d7d0:	00600793          	li	a5,6
4000d7d4:	40a787b3          	sub	a5,a5,a0
4000d7d8:	0ff7f793          	zext.b	a5,a5
4000d7dc:	00f70d23          	sb	a5,26(a4)
	return iface->if_dev->oper_state;
4000d7e0:	00042503          	lw	a0,0(s0)
4000d7e4:	01a54703          	lbu	a4,26(a0)
	if (net_if_oper_state_set(iface, new_state) != new_state) {
4000d7e8:	08f71063          	bne	a4,a5,4000d868 <update_operational_state+0x13c>
	if (net_if_oper_state(iface) == NET_IF_OPER_UP) {
4000d7ec:	00600793          	li	a5,6
4000d7f0:	f6f71ee3          	bne	a4,a5,4000d76c <update_operational_state+0x40>
		if (prev_state != NET_IF_OPER_UP) {
4000d7f4:	06e48a63          	beq	s1,a4,4000d868 <update_operational_state+0x13c>
	net_if_flag_set(iface, NET_IF_RUNNING);
4000d7f8:	00800593          	li	a1,8
4000d7fc:	948ff0ef          	jal	ra,4000c944 <net_if_flag_set.isra.0>
4000d800:	d0010537          	lui	a0,0xd0010
4000d804:	00000693          	li	a3,0
4000d808:	00000613          	li	a2,0
4000d80c:	00040593          	mv	a1,s0
4000d810:	00250513          	addi	a0,a0,2 # d0010002 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd0010003>
4000d814:	71c030ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
	    !(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
4000d818:	00040513          	mv	a0,s0
4000d81c:	d20fe0ef          	jal	ra,4000bd3c <l2_flags_get>
	if (!is_iface_offloaded(iface) &&
4000d820:	00857513          	andi	a0,a0,8
4000d824:	04051263          	bnez	a0,4000d868 <update_operational_state+0x13c>
	if (!net_if_flag_is_set(iface, NET_IF_IPV6) ||
4000d828:	00700593          	li	a1,7
4000d82c:	00040513          	mv	a0,s0
4000d830:	dc9fe0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
4000d834:	02050a63          	beqz	a0,4000d868 <update_operational_state+0x13c>
	    net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {
4000d838:	00b00593          	li	a1,11
4000d83c:	00040513          	mv	a0,s0
4000d840:	db9fe0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
	if (!net_if_flag_is_set(iface, NET_IF_IPV6) ||
4000d844:	02051263          	bnez	a0,4000d868 <update_operational_state+0x13c>
		net_if_start_dad(iface);
4000d848:	00040513          	mv	a0,s0
4000d84c:	d15ff0ef          	jal	ra,4000d560 <net_if_start_dad>
	net_if_start_rs(iface);
4000d850:	00040513          	mv	a0,s0
}
4000d854:	00812403          	lw	s0,8(sp)
4000d858:	00c12083          	lw	ra,12(sp)
4000d85c:	00412483          	lw	s1,4(sp)
4000d860:	01010113          	addi	sp,sp,16
	net_if_start_rs(iface);
4000d864:	ca8ff06f          	j	4000cd0c <net_if_start_rs>
}
4000d868:	00c12083          	lw	ra,12(sp)
4000d86c:	00812403          	lw	s0,8(sp)
4000d870:	00412483          	lw	s1,4(sp)
4000d874:	01010113          	addi	sp,sp,16
4000d878:	00008067          	ret

4000d87c <net_if_ipv6_maddr_rm>:
{
4000d87c:	fd010113          	addi	sp,sp,-48
4000d880:	02912223          	sw	s1,36(sp)
4000d884:	01312e23          	sw	s3,28(sp)
4000d888:	00050493          	mv	s1,a0
4000d88c:	00058993          	mv	s3,a1
	k_mutex_lock(&lock, K_FOREVER);
4000d890:	fff00513          	li	a0,-1
4000d894:	fff00593          	li	a1,-1
{
4000d898:	02812423          	sw	s0,40(sp)
4000d89c:	02112623          	sw	ra,44(sp)
4000d8a0:	03212023          	sw	s2,32(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000d8a4:	ea4fe0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
4000d8a8:	0044a403          	lw	s0,4(s1)
	if (!ipv6) {
4000d8ac:	02041863          	bnez	s0,4000d8dc <net_if_ipv6_maddr_rm+0x60>
	bool ret = false;
4000d8b0:	00000513          	li	a0,0
4000d8b4:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000d8b8:	ea4fe0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000d8bc:	02c12083          	lw	ra,44(sp)
4000d8c0:	02812403          	lw	s0,40(sp)
4000d8c4:	00c12503          	lw	a0,12(sp)
4000d8c8:	02412483          	lw	s1,36(sp)
4000d8cc:	02012903          	lw	s2,32(sp)
4000d8d0:	01c12983          	lw	s3,28(sp)
4000d8d4:	03010113          	addi	sp,sp,48
4000d8d8:	00008067          	ret
		if (!ipv6->mcast[i].is_used) {
4000d8dc:	0a442783          	lw	a5,164(s0)
4000d8e0:	0017f793          	andi	a5,a5,1
4000d8e4:	06079063          	bnez	a5,4000d944 <net_if_ipv6_maddr_rm+0xc8>
4000d8e8:	0bc42783          	lw	a5,188(s0)
4000d8ec:	0017f793          	andi	a5,a5,1
4000d8f0:	fc0780e3          	beqz	a5,4000d8b0 <net_if_ipv6_maddr_rm+0x34>
		if (!net_ipv6_addr_cmp(&ipv6->mcast[i].address.in6_addr,
4000d8f4:	0ac40913          	addi	s2,s0,172
4000d8f8:	00098593          	mv	a1,s3
4000d8fc:	00090513          	mv	a0,s2
4000d900:	da4fe0ef          	jal	ra,4000bea4 <net_ipv6_addr_cmp>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
4000d904:	00100793          	li	a5,1
		if (!net_ipv6_addr_cmp(&ipv6->mcast[i].address.in6_addr,
4000d908:	fa0504e3          	beqz	a0,4000d8b0 <net_if_ipv6_maddr_rm+0x34>
		ipv6->mcast[i].is_used = false;
4000d90c:	01800713          	li	a4,24
4000d910:	02e787b3          	mul	a5,a5,a4
		net_mgmt_event_notify_with_info(
4000d914:	e0600537          	lui	a0,0xe0600
4000d918:	00450513          	addi	a0,a0,4 # e0600004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600005>
4000d91c:	01000693          	li	a3,16
4000d920:	00090613          	mv	a2,s2
4000d924:	00048593          	mv	a1,s1
		ipv6->mcast[i].is_used = false;
4000d928:	00f40433          	add	s0,s0,a5
4000d92c:	0a444783          	lbu	a5,164(s0)
4000d930:	ffe7f793          	andi	a5,a5,-2
4000d934:	0af40223          	sb	a5,164(s0)
		net_mgmt_event_notify_with_info(
4000d938:	5f8030ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
		ret = true;
4000d93c:	00100513          	li	a0,1
		goto out;
4000d940:	f75ff06f          	j	4000d8b4 <net_if_ipv6_maddr_rm+0x38>
		if (!net_ipv6_addr_cmp(&ipv6->mcast[i].address.in6_addr,
4000d944:	09440913          	addi	s2,s0,148
4000d948:	00098593          	mv	a1,s3
4000d94c:	00090513          	mv	a0,s2
4000d950:	d54fe0ef          	jal	ra,4000bea4 <net_ipv6_addr_cmp>
4000d954:	f8050ae3          	beqz	a0,4000d8e8 <net_if_ipv6_maddr_rm+0x6c>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
4000d958:	00000793          	li	a5,0
4000d95c:	fb1ff06f          	j	4000d90c <net_if_ipv6_maddr_rm+0x90>

4000d960 <net_if_ipv6_addr_rm>:
{
4000d960:	fc010113          	addi	sp,sp,-64
4000d964:	03212823          	sw	s2,48(sp)
4000d968:	03412423          	sw	s4,40(sp)
4000d96c:	00058913          	mv	s2,a1
4000d970:	00050a13          	mv	s4,a0
	k_mutex_lock(&lock, K_FOREVER);
4000d974:	fff00593          	li	a1,-1
4000d978:	fff00513          	li	a0,-1
{
4000d97c:	02812c23          	sw	s0,56(sp)
4000d980:	02112e23          	sw	ra,60(sp)
4000d984:	02912a23          	sw	s1,52(sp)
4000d988:	03312623          	sw	s3,44(sp)
4000d98c:	03512223          	sw	s5,36(sp)
4000d990:	03612023          	sw	s6,32(sp)
4000d994:	01712e23          	sw	s7,28(sp)
4000d998:	01812c23          	sw	s8,24(sp)
4000d99c:	01912a23          	sw	s9,20(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000d9a0:	da8fe0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
4000d9a4:	004a2403          	lw	s0,4(s4)
	if (!ipv6) {
4000d9a8:	04041263          	bnez	s0,4000d9ec <net_if_ipv6_addr_rm+0x8c>
	bool ret = false;
4000d9ac:	00000993          	li	s3,0
	k_mutex_unlock(&lock);
4000d9b0:	dacfe0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000d9b4:	03c12083          	lw	ra,60(sp)
4000d9b8:	03812403          	lw	s0,56(sp)
4000d9bc:	03412483          	lw	s1,52(sp)
4000d9c0:	03012903          	lw	s2,48(sp)
4000d9c4:	02812a03          	lw	s4,40(sp)
4000d9c8:	02412a83          	lw	s5,36(sp)
4000d9cc:	02012b03          	lw	s6,32(sp)
4000d9d0:	01c12b83          	lw	s7,28(sp)
4000d9d4:	01812c03          	lw	s8,24(sp)
4000d9d8:	01412c83          	lw	s9,20(sp)
4000d9dc:	00098513          	mv	a0,s3
4000d9e0:	02c12983          	lw	s3,44(sp)
4000d9e4:	04010113          	addi	sp,sp,64
4000d9e8:	00008067          	ret
4000d9ec:	00440a93          	addi	s5,s0,4
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d9f0:	00000493          	li	s1,0
		if (!ipv6->unicast[i].is_used) {
4000d9f4:	03000c93          	li	s9,48
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000d9f8:	00300c13          	li	s8,3
		if (!ipv6->unicast[i].is_used) {
4000d9fc:	03948b33          	mul	s6,s1,s9
4000da00:	01640bb3          	add	s7,s0,s6
4000da04:	02cba783          	lw	a5,44(s7)
4000da08:	0197d793          	srli	a5,a5,0x19
4000da0c:	0017f793          	andi	a5,a5,1
4000da10:	0c078263          	beqz	a5,4000dad4 <net_if_ipv6_addr_rm+0x174>
		if (!net_ipv6_addr_cmp(&ipv6->unicast[i].address.in6_addr,
4000da14:	00090593          	mv	a1,s2
4000da18:	000a8513          	mv	a0,s5
4000da1c:	c88fe0ef          	jal	ra,4000bea4 <net_ipv6_addr_cmp>
4000da20:	00050993          	mv	s3,a0
4000da24:	0a050863          	beqz	a0,4000dad4 <net_if_ipv6_addr_rm+0x174>
		if (!ipv6->unicast[i].is_infinite) {
4000da28:	02fbc783          	lbu	a5,47(s7)
4000da2c:	0017f793          	andi	a5,a5,1
4000da30:	02079663          	bnez	a5,4000da5c <net_if_ipv6_addr_rm+0xfc>
			sys_slist_find_and_remove(
4000da34:	014b0593          	addi	a1,s6,20 # 1000014 <__rom_region_size+0xfcf638>
4000da38:	40031b37          	lui	s6,0x40031
4000da3c:	00b405b3          	add	a1,s0,a1
4000da40:	a5cb0513          	addi	a0,s6,-1444 # 40030a5c <active_address_lifetime_timers>
4000da44:	908fe0ef          	jal	ra,4000bb4c <sys_slist_find_and_remove>
			if (sys_slist_is_empty(
4000da48:	a5cb2783          	lw	a5,-1444(s6)
4000da4c:	00079863          	bnez	a5,4000da5c <net_if_ipv6_addr_rm+0xfc>
				k_work_cancel_delayable(
4000da50:	40031537          	lui	a0,0x40031
4000da54:	e6850513          	addi	a0,a0,-408 # 40030e68 <address_lifetime_timer>
4000da58:	3e51b0ef          	jal	ra,4002963c <k_work_cancel_delayable>
		ipv6->unicast[i].is_used = false;
4000da5c:	03000793          	li	a5,48
4000da60:	02f484b3          	mul	s1,s1,a5
		net_if_ipv6_maddr_rm(iface, &maddr);
4000da64:	00010593          	mv	a1,sp
4000da68:	000a0513          	mv	a0,s4
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
4000da6c:	00012223          	sw	zero,4(sp)
		ipv6->unicast[i].is_used = false;
4000da70:	00940433          	add	s0,s0,s1
4000da74:	02f44783          	lbu	a5,47(s0)
4000da78:	ffd7f793          	andi	a5,a5,-3
4000da7c:	02f407a3          	sb	a5,47(s0)
	dst->s6_addr[0]   = 0xFF;
4000da80:	2ff00793          	li	a5,767
4000da84:	00f12023          	sw	a5,0(sp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
4000da88:	010007b7          	lui	a5,0x1000
4000da8c:	00f12423          	sw	a5,8(sp)
	dst->s6_addr[12]  = 0xFF;
4000da90:	fff00793          	li	a5,-1
4000da94:	00f10623          	sb	a5,12(sp)
	dst->s6_addr[13]  = src->s6_addr[13];
4000da98:	00d94783          	lbu	a5,13(s2)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
4000da9c:	00e94703          	lbu	a4,14(s2)
	dst->s6_addr[13]  = src->s6_addr[13];
4000daa0:	00f106a3          	sb	a5,13(sp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
4000daa4:	00f94783          	lbu	a5,15(s2)
4000daa8:	00879793          	slli	a5,a5,0x8
4000daac:	00e7e7b3          	or	a5,a5,a4
4000dab0:	00f11723          	sh	a5,14(sp)
		net_if_ipv6_maddr_rm(iface, &maddr);
4000dab4:	dc9ff0ef          	jal	ra,4000d87c <net_if_ipv6_maddr_rm>
		net_mgmt_event_notify_with_info(
4000dab8:	e0600537          	lui	a0,0xe0600
4000dabc:	01000693          	li	a3,16
4000dac0:	000a8613          	mv	a2,s5
4000dac4:	000a0593          	mv	a1,s4
4000dac8:	00250513          	addi	a0,a0,2 # e0600002 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600003>
4000dacc:	464030ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
		goto out;
4000dad0:	ee1ff06f          	j	4000d9b0 <net_if_ipv6_addr_rm+0x50>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000dad4:	00148493          	addi	s1,s1,1
4000dad8:	030a8a93          	addi	s5,s5,48
4000dadc:	f38490e3          	bne	s1,s8,4000d9fc <net_if_ipv6_addr_rm+0x9c>
4000dae0:	ecdff06f          	j	4000d9ac <net_if_ipv6_addr_rm+0x4c>

4000dae4 <net_if_ipv6_dad_failed>:
{
4000dae4:	fe010113          	addi	sp,sp,-32
4000dae8:	00912a23          	sw	s1,20(sp)
4000daec:	00a12623          	sw	a0,12(sp)
4000daf0:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
4000daf4:	fff00513          	li	a0,-1
4000daf8:	fff00593          	li	a1,-1
{
4000dafc:	00112e23          	sw	ra,28(sp)
4000db00:	00812c23          	sw	s0,24(sp)
4000db04:	01212823          	sw	s2,16(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000db08:	c40fe0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	ifaddr = net_if_ipv6_addr_lookup(addr, &iface);
4000db0c:	00c10593          	addi	a1,sp,12
4000db10:	00048513          	mv	a0,s1
4000db14:	c08ff0ef          	jal	ra,4000cf1c <net_if_ipv6_addr_lookup>
	if (!ifaddr) {
4000db18:	04050063          	beqz	a0,4000db58 <net_if_ipv6_dad_failed+0x74>
	sys_slist_find_and_remove(&active_dad_timers, &ifaddr->dad_node);
4000db1c:	02450593          	addi	a1,a0,36
4000db20:	00050413          	mv	s0,a0
4000db24:	40031537          	lui	a0,0x40031
4000db28:	a4c50513          	addi	a0,a0,-1460 # 40030a4c <active_dad_timers>
4000db2c:	820fe0ef          	jal	ra,4000bb4c <sys_slist_find_and_remove>
	net_mgmt_event_notify_with_info(NET_EVENT_IPV6_DAD_FAILED, iface,
4000db30:	00c12903          	lw	s2,12(sp)
4000db34:	e0600537          	lui	a0,0xe0600
4000db38:	00e50513          	addi	a0,a0,14 # e060000e <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000f>
4000db3c:	00090593          	mv	a1,s2
4000db40:	01000693          	li	a3,16
4000db44:	00440613          	addi	a2,s0,4
4000db48:	3e8030ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
	net_if_ipv6_addr_rm(iface, addr);
4000db4c:	00048593          	mv	a1,s1
4000db50:	00090513          	mv	a0,s2
4000db54:	e0dff0ef          	jal	ra,4000d960 <net_if_ipv6_addr_rm>
	k_mutex_unlock(&lock);
4000db58:	c04fe0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000db5c:	01c12083          	lw	ra,28(sp)
4000db60:	01812403          	lw	s0,24(sp)
4000db64:	01412483          	lw	s1,20(sp)
4000db68:	01012903          	lw	s2,16(sp)
4000db6c:	02010113          	addi	sp,sp,32
4000db70:	00008067          	ret

4000db74 <remove_prefix_addresses>:
{
4000db74:	fd010113          	addi	sp,sp,-48
4000db78:	02812423          	sw	s0,40(sp)
4000db7c:	02912223          	sw	s1,36(sp)
4000db80:	03212023          	sw	s2,32(sp)
4000db84:	01312e23          	sw	s3,28(sp)
4000db88:	01412c23          	sw	s4,24(sp)
4000db8c:	01512a23          	sw	s5,20(sp)
4000db90:	01612823          	sw	s6,16(sp)
4000db94:	01712623          	sw	s7,12(sp)
4000db98:	01812423          	sw	s8,8(sp)
4000db9c:	01912223          	sw	s9,4(sp)
4000dba0:	02112623          	sw	ra,44(sp)
4000dba4:	00050913          	mv	s2,a0
4000dba8:	00058493          	mv	s1,a1
4000dbac:	00060993          	mv	s3,a2
4000dbb0:	00068a13          	mv	s4,a3
4000dbb4:	00458413          	addi	s0,a1,4
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000dbb8:	00000c93          	li	s9,0
		if (!ipv6->unicast[i].is_used ||
4000dbbc:	03000b13          	li	s6,48
4000dbc0:	00200b93          	li	s7,2
		    ipv6->unicast[i].address.family != AF_INET6 ||
4000dbc4:	00100c13          	li	s8,1
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000dbc8:	00300a93          	li	s5,3
		if (!ipv6->unicast[i].is_used ||
4000dbcc:	036c87b3          	mul	a5,s9,s6
4000dbd0:	00f487b3          	add	a5,s1,a5
4000dbd4:	02c7a783          	lw	a5,44(a5) # 100002c <__rom_region_size+0xfcf650>
4000dbd8:	0197d793          	srli	a5,a5,0x19
4000dbdc:	0017f793          	andi	a5,a5,1
4000dbe0:	02078a63          	beqz	a5,4000dc14 <remove_prefix_addresses+0xa0>
4000dbe4:	ffc45783          	lhu	a5,-4(s0)
4000dbe8:	03779663          	bne	a5,s7,4000dc14 <remove_prefix_addresses+0xa0>
		    ipv6->unicast[i].address.family != AF_INET6 ||
4000dbec:	02844783          	lbu	a5,40(s0)
4000dbf0:	03879263          	bne	a5,s8,4000dc14 <remove_prefix_addresses+0xa0>
		if (net_ipv6_is_prefix(
4000dbf4:	000a0613          	mv	a2,s4
4000dbf8:	00040593          	mv	a1,s0
4000dbfc:	00098513          	mv	a0,s3
4000dc00:	9f8fe0ef          	jal	ra,4000bdf8 <net_ipv6_is_prefix>
4000dc04:	00050863          	beqz	a0,4000dc14 <remove_prefix_addresses+0xa0>
			net_if_ipv6_addr_rm(iface,
4000dc08:	00040593          	mv	a1,s0
4000dc0c:	00090513          	mv	a0,s2
4000dc10:	d51ff0ef          	jal	ra,4000d960 <net_if_ipv6_addr_rm>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000dc14:	001c8c93          	addi	s9,s9,1
4000dc18:	03040413          	addi	s0,s0,48
4000dc1c:	fb5c98e3          	bne	s9,s5,4000dbcc <remove_prefix_addresses+0x58>
}
4000dc20:	02c12083          	lw	ra,44(sp)
4000dc24:	02812403          	lw	s0,40(sp)
4000dc28:	02412483          	lw	s1,36(sp)
4000dc2c:	02012903          	lw	s2,32(sp)
4000dc30:	01c12983          	lw	s3,28(sp)
4000dc34:	01812a03          	lw	s4,24(sp)
4000dc38:	01412a83          	lw	s5,20(sp)
4000dc3c:	01012b03          	lw	s6,16(sp)
4000dc40:	00c12b83          	lw	s7,12(sp)
4000dc44:	00812c03          	lw	s8,8(sp)
4000dc48:	00412c83          	lw	s9,4(sp)
4000dc4c:	03010113          	addi	sp,sp,48
4000dc50:	00008067          	ret

4000dc54 <prefix_lifetime_timeout>:
{
4000dc54:	fc010113          	addi	sp,sp,-64
4000dc58:	02112e23          	sw	ra,60(sp)
4000dc5c:	02812c23          	sw	s0,56(sp)
4000dc60:	02912a23          	sw	s1,52(sp)
4000dc64:	03312623          	sw	s3,44(sp)
4000dc68:	03212823          	sw	s2,48(sp)
4000dc6c:	03412423          	sw	s4,40(sp)
	uint32_t current_time = k_uptime_get_32();
4000dc70:	a54fe0ef          	jal	ra,4000bec4 <k_uptime_get_32>
4000dc74:	00050993          	mv	s3,a0
	k_mutex_lock(&lock, K_FOREVER);
4000dc78:	fff00593          	li	a1,-1
4000dc7c:	fff00513          	li	a0,-1
4000dc80:	ac8fe0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4000dc84:	400317b7          	lui	a5,0x40031
4000dc88:	a547a403          	lw	s0,-1452(a5) # 40030a54 <active_prefix_lifetime_timers>
4000dc8c:	00000493          	li	s1,0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
4000dc90:	00040463          	beqz	s0,4000dc98 <prefix_lifetime_timeout+0x44>
	return node->next;
4000dc94:	00042483          	lw	s1,0(s0)
	net_mgmt_event_notify_with_info(
4000dc98:	e0600a37          	lui	s4,0xe0600
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
4000dc9c:	fff00913          	li	s2,-1
	net_mgmt_event_notify_with_info(
4000dca0:	006a0a13          	addi	s4,s4,6 # e0600006 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600007>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
4000dca4:	08040063          	beqz	s0,4000dd24 <prefix_lifetime_timeout+0xd0>
		uint32_t this_update = net_timeout_evaluate(timeout,
4000dca8:	00098593          	mv	a1,s3
4000dcac:	00040513          	mv	a0,s0
4000dcb0:	6dd010ef          	jal	ra,4000fb8c <net_timeout_evaluate>
		if (this_update == 0U) {
4000dcb4:	06051263          	bnez	a0,4000dd18 <prefix_lifetime_timeout+0xc4>
	ifprefix->is_used = false;
4000dcb8:	02544783          	lbu	a5,37(s0)
	if (net_if_config_ipv6_get(ifprefix->iface, &ipv6) < 0) {
4000dcbc:	02042503          	lw	a0,32(s0)
4000dcc0:	01c10593          	addi	a1,sp,28
	ifprefix->is_used = false;
4000dcc4:	ffd7f793          	andi	a5,a5,-3
4000dcc8:	02f402a3          	sb	a5,37(s0)
	if (net_if_config_ipv6_get(ifprefix->iface, &ipv6) < 0) {
4000dccc:	fb1fe0ef          	jal	ra,4000cc7c <net_if_config_ipv6_get>
4000dcd0:	02054863          	bltz	a0,4000dd00 <prefix_lifetime_timeout+0xac>
	remove_prefix_addresses(ifprefix->iface, ipv6, &ifprefix->prefix,
4000dcd4:	02444683          	lbu	a3,36(s0)
4000dcd8:	01c12583          	lw	a1,28(sp)
4000dcdc:	02042503          	lw	a0,32(s0)
4000dce0:	01040613          	addi	a2,s0,16
4000dce4:	00c12623          	sw	a2,12(sp)
4000dce8:	e8dff0ef          	jal	ra,4000db74 <remove_prefix_addresses>
	net_mgmt_event_notify_with_info(
4000dcec:	00c12603          	lw	a2,12(sp)
4000dcf0:	02042583          	lw	a1,32(s0)
4000dcf4:	01000693          	li	a3,16
4000dcf8:	000a0513          	mv	a0,s4
4000dcfc:	234030ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_prefix_lifetime_timers,
4000dd00:	00000793          	li	a5,0
4000dd04:	00048463          	beqz	s1,4000dd0c <prefix_lifetime_timeout+0xb8>
4000dd08:	0004a783          	lw	a5,0(s1)
4000dd0c:	00048413          	mv	s0,s1
4000dd10:	00078493          	mv	s1,a5
4000dd14:	f91ff06f          	j	4000dca4 <prefix_lifetime_timeout+0x50>
		if (this_update < next_update) {
4000dd18:	01257463          	bgeu	a0,s2,4000dd20 <prefix_lifetime_timeout+0xcc>
4000dd1c:	00050913          	mv	s2,a0
		if (current == next) {
4000dd20:	fe9410e3          	bne	s0,s1,4000dd00 <prefix_lifetime_timeout+0xac>
	if (next_update != UINT32_MAX) {
4000dd24:	fff00793          	li	a5,-1
4000dd28:	02f90663          	beq	s2,a5,4000dd54 <prefix_lifetime_timeout+0x100>
		t += off;
4000dd2c:	00990513          	addi	a0,s2,9
			return t / ((uint64_t)from_hz / to_hz);
4000dd30:	00a00613          	li	a2,10
4000dd34:	00000693          	li	a3,0
4000dd38:	012535b3          	sltu	a1,a0,s2
4000dd3c:	d7cf20ef          	jal	ra,400002b8 <__udivdi3>
		k_work_reschedule(&prefix_lifetime_timer, K_MSEC(next_update));
4000dd40:	00058613          	mv	a2,a1
4000dd44:	00050593          	mv	a1,a0
4000dd48:	40031537          	lui	a0,0x40031
4000dd4c:	e3850513          	addi	a0,a0,-456 # 40030e38 <prefix_lifetime_timer>
4000dd50:	0d51b0ef          	jal	ra,40029624 <k_work_reschedule>
}
4000dd54:	03812403          	lw	s0,56(sp)
4000dd58:	03c12083          	lw	ra,60(sp)
4000dd5c:	03412483          	lw	s1,52(sp)
4000dd60:	03012903          	lw	s2,48(sp)
4000dd64:	02c12983          	lw	s3,44(sp)
4000dd68:	02812a03          	lw	s4,40(sp)
4000dd6c:	04010113          	addi	sp,sp,64
	k_mutex_unlock(&lock);
4000dd70:	9ecfe06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>

4000dd74 <net_if_ipv6_maddr_lookup>:
{
4000dd74:	fe010113          	addi	sp,sp,-32
4000dd78:	00812c23          	sw	s0,24(sp)
4000dd7c:	01212823          	sw	s2,16(sp)
4000dd80:	01312623          	sw	s3,12(sp)
4000dd84:	01412423          	sw	s4,8(sp)
4000dd88:	00058913          	mv	s2,a1
4000dd8c:	00050a13          	mv	s4,a0
	k_mutex_lock(&lock, K_FOREVER);
4000dd90:	fff00593          	li	a1,-1
4000dd94:	fff00513          	li	a0,-1
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000dd98:	4003d437          	lui	s0,0x4003d
4000dd9c:	4003d9b7          	lui	s3,0x4003d
{
4000dda0:	01512223          	sw	s5,4(sp)
4000dda4:	00112e23          	sw	ra,28(sp)
4000dda8:	00912a23          	sw	s1,20(sp)
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000ddac:	c3c40413          	addi	s0,s0,-964 # 4003cc3c <__net_if_dts_ord_12_0>
	k_mutex_lock(&lock, K_FOREVER);
4000ddb0:	998fe0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000ddb4:	c4898993          	addi	s3,s3,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
			if (!ipv6->mcast[i].is_used ||
4000ddb8:	00200a93          	li	s5,2
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000ddbc:	01346663          	bltu	s0,s3,4000ddc8 <net_if_ipv6_maddr_lookup+0x54>
	struct net_if_mcast_addr *ifmaddr = NULL;
4000ddc0:	00000493          	li	s1,0
4000ddc4:	0900006f          	j	4000de54 <net_if_ipv6_maddr_lookup+0xe0>
		struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
4000ddc8:	00442483          	lw	s1,4(s0)
		if (ret && *ret && iface != *ret) {
4000ddcc:	0a090a63          	beqz	s2,4000de80 <net_if_ipv6_maddr_lookup+0x10c>
4000ddd0:	00092783          	lw	a5,0(s2)
4000ddd4:	0a078663          	beqz	a5,4000de80 <net_if_ipv6_maddr_lookup+0x10c>
4000ddd8:	00878a63          	beq	a5,s0,4000ddec <net_if_ipv6_maddr_lookup+0x78>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000dddc:	00c40413          	addi	s0,s0,12
4000dde0:	ff3470e3          	bgeu	s0,s3,4000ddc0 <net_if_ipv6_maddr_lookup+0x4c>
		struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
4000dde4:	00442483          	lw	s1,4(s0)
		if (ret && *ret && iface != *ret) {
4000dde8:	fe9ff06f          	j	4000ddd0 <net_if_ipv6_maddr_lookup+0x5c>
		if (!ipv6) {
4000ddec:	fe0488e3          	beqz	s1,4000dddc <net_if_ipv6_maddr_lookup+0x68>
			if (!ipv6->mcast[i].is_used ||
4000ddf0:	0a44a783          	lw	a5,164(s1)
4000ddf4:	0017f793          	andi	a5,a5,1
4000ddf8:	02078063          	beqz	a5,4000de18 <net_if_ipv6_maddr_lookup+0xa4>
4000ddfc:	0904d783          	lhu	a5,144(s1)
4000de00:	01579c63          	bne	a5,s5,4000de18 <net_if_ipv6_maddr_lookup+0xa4>
			if (net_ipv6_is_prefix(
4000de04:	08000613          	li	a2,128
4000de08:	09448593          	addi	a1,s1,148
4000de0c:	000a0513          	mv	a0,s4
4000de10:	fe9fd0ef          	jal	ra,4000bdf8 <net_ipv6_is_prefix>
4000de14:	06051c63          	bnez	a0,4000de8c <net_if_ipv6_maddr_lookup+0x118>
			if (!ipv6->mcast[i].is_used ||
4000de18:	0bc4a783          	lw	a5,188(s1)
4000de1c:	0017f793          	andi	a5,a5,1
4000de20:	06078263          	beqz	a5,4000de84 <net_if_ipv6_maddr_lookup+0x110>
4000de24:	0a84d783          	lhu	a5,168(s1)
4000de28:	05579e63          	bne	a5,s5,4000de84 <net_if_ipv6_maddr_lookup+0x110>
			if (net_ipv6_is_prefix(
4000de2c:	08000613          	li	a2,128
4000de30:	0ac48593          	addi	a1,s1,172
4000de34:	000a0513          	mv	a0,s4
4000de38:	fc1fd0ef          	jal	ra,4000bdf8 <net_ipv6_is_prefix>
4000de3c:	04050463          	beqz	a0,4000de84 <net_if_ipv6_maddr_lookup+0x110>
4000de40:	01800793          	li	a5,24
				if (ret) {
4000de44:	00090463          	beqz	s2,4000de4c <net_if_ipv6_maddr_lookup+0xd8>
					*ret = iface;
4000de48:	00892023          	sw	s0,0(s2)
				ifmaddr = &ipv6->mcast[i];
4000de4c:	09078793          	addi	a5,a5,144
4000de50:	00f484b3          	add	s1,s1,a5
	k_mutex_unlock(&lock);
4000de54:	908fe0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000de58:	01c12083          	lw	ra,28(sp)
4000de5c:	01812403          	lw	s0,24(sp)
4000de60:	01012903          	lw	s2,16(sp)
4000de64:	00c12983          	lw	s3,12(sp)
4000de68:	00812a03          	lw	s4,8(sp)
4000de6c:	00412a83          	lw	s5,4(sp)
4000de70:	00048513          	mv	a0,s1
4000de74:	01412483          	lw	s1,20(sp)
4000de78:	02010113          	addi	sp,sp,32
4000de7c:	00008067          	ret
		if (!ipv6) {
4000de80:	f60498e3          	bnez	s1,4000ddf0 <net_if_ipv6_maddr_lookup+0x7c>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000de84:	00c40413          	addi	s0,s0,12
4000de88:	f35ff06f          	j	4000ddbc <net_if_ipv6_maddr_lookup+0x48>
			if (net_ipv6_is_prefix(
4000de8c:	00000793          	li	a5,0
4000de90:	fb5ff06f          	j	4000de44 <net_if_ipv6_maddr_lookup+0xd0>

4000de94 <net_if_ipv6_maddr_add>:
{
4000de94:	fc010113          	addi	sp,sp,-64
4000de98:	03212823          	sw	s2,48(sp)
4000de9c:	00a12623          	sw	a0,12(sp)
4000dea0:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
4000dea4:	fff00513          	li	a0,-1
4000dea8:	fff00593          	li	a1,-1
{
4000deac:	02112e23          	sw	ra,60(sp)
4000deb0:	02812c23          	sw	s0,56(sp)
4000deb4:	02912a23          	sw	s1,52(sp)
4000deb8:	03312623          	sw	s3,44(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000debc:	88cfe0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
4000dec0:	00c12503          	lw	a0,12(sp)
4000dec4:	01c10593          	addi	a1,sp,28
4000dec8:	db5fe0ef          	jal	ra,4000cc7c <net_if_config_ipv6_get>
4000decc:	02055663          	bgez	a0,4000def8 <net_if_ipv6_maddr_add+0x64>
	struct net_if_mcast_addr *ifmaddr = NULL;
4000ded0:	00000413          	li	s0,0
	k_mutex_unlock(&lock);
4000ded4:	888fe0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000ded8:	03c12083          	lw	ra,60(sp)
4000dedc:	00040513          	mv	a0,s0
4000dee0:	03812403          	lw	s0,56(sp)
4000dee4:	03412483          	lw	s1,52(sp)
4000dee8:	03012903          	lw	s2,48(sp)
4000deec:	02c12983          	lw	s3,44(sp)
4000def0:	04010113          	addi	sp,sp,64
4000def4:	00008067          	ret
	if (!net_ipv6_is_addr_mcast(addr)) {
4000def8:	00094703          	lbu	a4,0(s2)
4000defc:	0ff00793          	li	a5,255
4000df00:	fcf718e3          	bne	a4,a5,4000ded0 <net_if_ipv6_maddr_add+0x3c>
	if (net_if_ipv6_maddr_lookup(addr, &iface)) {
4000df04:	00c10593          	addi	a1,sp,12
4000df08:	00090513          	mv	a0,s2
4000df0c:	e69ff0ef          	jal	ra,4000dd74 <net_if_ipv6_maddr_lookup>
4000df10:	fc0510e3          	bnez	a0,4000ded0 <net_if_ipv6_maddr_add+0x3c>
		if (ipv6->mcast[i].is_used) {
4000df14:	01c12403          	lw	s0,28(sp)
4000df18:	0a442783          	lw	a5,164(s0)
4000df1c:	0017f793          	andi	a5,a5,1
4000df20:	06078863          	beqz	a5,4000df90 <net_if_ipv6_maddr_add+0xfc>
4000df24:	0bc42783          	lw	a5,188(s0)
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
4000df28:	00100493          	li	s1,1
		if (ipv6->mcast[i].is_used) {
4000df2c:	0017f793          	andi	a5,a5,1
4000df30:	fa0790e3          	bnez	a5,4000ded0 <net_if_ipv6_maddr_add+0x3c>
		ipv6->mcast[i].is_used = true;
4000df34:	01800793          	li	a5,24
4000df38:	02f484b3          	mul	s1,s1,a5
		memcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);
4000df3c:	01000613          	li	a2,16
4000df40:	00090593          	mv	a1,s2
		ipv6->mcast[i].is_used = true;
4000df44:	009407b3          	add	a5,s0,s1
4000df48:	0a47c703          	lbu	a4,164(a5)
		memcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);
4000df4c:	09448993          	addi	s3,s1,148
4000df50:	013409b3          	add	s3,s0,s3
		ipv6->mcast[i].is_used = true;
4000df54:	00176713          	ori	a4,a4,1
4000df58:	0ae78223          	sb	a4,164(a5)
		ipv6->mcast[i].address.family = AF_INET6;
4000df5c:	00200713          	li	a4,2
4000df60:	08e79823          	sh	a4,144(a5)
		memcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);
4000df64:	00098513          	mv	a0,s3
4000df68:	8e4fb0ef          	jal	ra,4000904c <memcpy>
		net_mgmt_event_notify_with_info(
4000df6c:	00c12583          	lw	a1,12(sp)
4000df70:	e0600537          	lui	a0,0xe0600
4000df74:	01000693          	li	a3,16
4000df78:	00098613          	mv	a2,s3
4000df7c:	00350513          	addi	a0,a0,3 # e0600003 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600004>
		ifmaddr = &ipv6->mcast[i];
4000df80:	09048493          	addi	s1,s1,144
		net_mgmt_event_notify_with_info(
4000df84:	7ad020ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
		ifmaddr = &ipv6->mcast[i];
4000df88:	00940433          	add	s0,s0,s1
		goto out;
4000df8c:	f49ff06f          	j	4000ded4 <net_if_ipv6_maddr_add+0x40>
	for (i = 0; i < NET_IF_MAX_IPV6_MADDR; i++) {
4000df90:	00000493          	li	s1,0
4000df94:	fa1ff06f          	j	4000df34 <net_if_ipv6_maddr_add+0xa0>

4000df98 <net_if_ipv6_maddr_join>:
{
4000df98:	ff010113          	addi	sp,sp,-16
4000df9c:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000dfa0:	fff00593          	li	a1,-1
{
4000dfa4:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000dfa8:	fff00513          	li	a0,-1
{
4000dfac:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000dfb0:	f99fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	addr->is_joined = true;
4000dfb4:	01444783          	lbu	a5,20(s0)
4000dfb8:	0027e793          	ori	a5,a5,2
4000dfbc:	00f40a23          	sb	a5,20(s0)
}
4000dfc0:	00812403          	lw	s0,8(sp)
4000dfc4:	00c12083          	lw	ra,12(sp)
4000dfc8:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
4000dfcc:	f91fd06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>

4000dfd0 <net_if_ipv6_prefix_add>:
{
4000dfd0:	fb010113          	addi	sp,sp,-80
4000dfd4:	03312e23          	sw	s3,60(sp)
4000dfd8:	03612823          	sw	s6,48(sp)
4000dfdc:	00050993          	mv	s3,a0
4000dfe0:	00058b13          	mv	s6,a1
	k_mutex_lock(&lock, K_FOREVER);
4000dfe4:	fff00513          	li	a0,-1
4000dfe8:	fff00593          	li	a1,-1
{
4000dfec:	05212023          	sw	s2,64(sp)
4000dff0:	03712623          	sw	s7,44(sp)
4000dff4:	04112623          	sw	ra,76(sp)
4000dff8:	04812423          	sw	s0,72(sp)
4000dffc:	04912223          	sw	s1,68(sp)
4000e000:	03412c23          	sw	s4,56(sp)
4000e004:	03512a23          	sw	s5,52(sp)
4000e008:	00060b93          	mv	s7,a2
4000e00c:	00068913          	mv	s2,a3
	k_mutex_lock(&lock, K_FOREVER);
4000e010:	f39fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv6_get(iface, &ipv6) < 0) {
4000e014:	00c10593          	addi	a1,sp,12
4000e018:	00098513          	mv	a0,s3
4000e01c:	c61fe0ef          	jal	ra,4000cc7c <net_if_config_ipv6_get>
4000e020:	02055e63          	bgez	a0,4000e05c <net_if_ipv6_prefix_add+0x8c>
	struct net_if_ipv6_prefix *ifprefix = NULL;
4000e024:	00000493          	li	s1,0
	k_mutex_unlock(&lock);
4000e028:	f35fd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000e02c:	04c12083          	lw	ra,76(sp)
4000e030:	04812403          	lw	s0,72(sp)
4000e034:	04012903          	lw	s2,64(sp)
4000e038:	03c12983          	lw	s3,60(sp)
4000e03c:	03812a03          	lw	s4,56(sp)
4000e040:	03412a83          	lw	s5,52(sp)
4000e044:	03012b03          	lw	s6,48(sp)
4000e048:	02c12b83          	lw	s7,44(sp)
4000e04c:	00048513          	mv	a0,s1
4000e050:	04412483          	lw	s1,68(sp)
4000e054:	05010113          	addi	sp,sp,80
4000e058:	00008067          	ret
	ifprefix = ipv6_prefix_find(iface, prefix, len);
4000e05c:	0049a483          	lw	s1,4(s3)
	if (!ipv6) {
4000e060:	0a049863          	bnez	s1,4000e110 <net_if_ipv6_prefix_add+0x140>
	if (!ipv6) {
4000e064:	00c12a03          	lw	s4,12(sp)
4000e068:	fa0a0ee3          	beqz	s4,4000e024 <net_if_ipv6_prefix_add+0x54>
		if (ipv6->prefix[i].is_used) {
4000e06c:	0e4a2783          	lw	a5,228(s4)
4000e070:	0097d793          	srli	a5,a5,0x9
4000e074:	0017f793          	andi	a5,a5,1
4000e078:	10078063          	beqz	a5,4000e178 <net_if_ipv6_prefix_add+0x1a8>
4000e07c:	10ca2783          	lw	a5,268(s4)
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
4000e080:	00100413          	li	s0,1
		if (ipv6->prefix[i].is_used) {
4000e084:	0097d793          	srli	a5,a5,0x9
4000e088:	0017f793          	andi	a5,a5,1
4000e08c:	f8079ce3          	bnez	a5,4000e024 <net_if_ipv6_prefix_add+0x54>
		net_if_ipv6_prefix_init(iface, &ipv6->prefix[i], prefix,
4000e090:	02800793          	li	a5,40
4000e094:	02f40433          	mul	s0,s0,a5
	net_ipaddr_copy(&ifprefix->prefix, addr);
4000e098:	000b0593          	mv	a1,s6
4000e09c:	01000613          	li	a2,16
4000e0a0:	01010513          	addi	a0,sp,16
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
4000e0a4:	00190913          	addi	s2,s2,1
4000e0a8:	00193913          	seqz	s2,s2
	ifprefix->is_used = true;
4000e0ac:	008a0ab3          	add	s5,s4,s0
4000e0b0:	0e5ac783          	lbu	a5,229(s5)
		net_if_ipv6_prefix_init(iface, &ipv6->prefix[i], prefix,
4000e0b4:	0c040493          	addi	s1,s0,192
	ifprefix->len = len;
4000e0b8:	0f7a8223          	sb	s7,228(s5)
	ifprefix->is_used = true;
4000e0bc:	0027e793          	ori	a5,a5,2
4000e0c0:	0efa82a3          	sb	a5,229(s5)
	ifprefix->iface = iface;
4000e0c4:	0f3aa023          	sw	s3,224(s5)
	net_ipaddr_copy(&ifprefix->prefix, addr);
4000e0c8:	f85fa0ef          	jal	ra,4000904c <memcpy>
		net_if_ipv6_prefix_init(iface, &ipv6->prefix[i], prefix,
4000e0cc:	009a04b3          	add	s1,s4,s1
	net_ipaddr_copy(&ifprefix->prefix, addr);
4000e0d0:	01010593          	addi	a1,sp,16
4000e0d4:	01000613          	li	a2,16
4000e0d8:	01048513          	addi	a0,s1,16
4000e0dc:	f71fa0ef          	jal	ra,4000904c <memcpy>
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
4000e0e0:	0e5ac783          	lbu	a5,229(s5)
			&ipv6->prefix[i].prefix, sizeof(struct in6_addr));
4000e0e4:	0d040613          	addi	a2,s0,208
		net_mgmt_event_notify_with_info(
4000e0e8:	e0600537          	lui	a0,0xe0600
4000e0ec:	ffe7f793          	andi	a5,a5,-2
4000e0f0:	0127e7b3          	or	a5,a5,s2
4000e0f4:	0efa82a3          	sb	a5,229(s5)
4000e0f8:	01000693          	li	a3,16
4000e0fc:	00ca0633          	add	a2,s4,a2
4000e100:	00098593          	mv	a1,s3
4000e104:	00550513          	addi	a0,a0,5 # e0600005 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600006>
4000e108:	629020ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
		goto out;
4000e10c:	f1dff06f          	j	4000e028 <net_if_ipv6_prefix_add+0x58>
		if (!ipv6->prefix[i].is_used) {
4000e110:	0e44a783          	lw	a5,228(s1)
4000e114:	0097d793          	srli	a5,a5,0x9
4000e118:	0017f793          	andi	a5,a5,1
4000e11c:	00078e63          	beqz	a5,4000e138 <net_if_ipv6_prefix_add+0x168>
		if (net_ipv6_addr_cmp(prefix, &ipv6->prefix[i].prefix) &&
4000e120:	0d048593          	addi	a1,s1,208
4000e124:	000b0513          	mv	a0,s6
4000e128:	d7dfd0ef          	jal	ra,4000bea4 <net_ipv6_addr_cmp>
4000e12c:	00050663          	beqz	a0,4000e138 <net_if_ipv6_prefix_add+0x168>
4000e130:	0e44c783          	lbu	a5,228(s1)
4000e134:	03778e63          	beq	a5,s7,4000e170 <net_if_ipv6_prefix_add+0x1a0>
		if (!ipv6->prefix[i].is_used) {
4000e138:	10c4a783          	lw	a5,268(s1)
4000e13c:	0097d793          	srli	a5,a5,0x9
4000e140:	0017f793          	andi	a5,a5,1
4000e144:	f20780e3          	beqz	a5,4000e064 <net_if_ipv6_prefix_add+0x94>
		if (net_ipv6_addr_cmp(prefix, &ipv6->prefix[i].prefix) &&
4000e148:	0f848593          	addi	a1,s1,248
4000e14c:	000b0513          	mv	a0,s6
4000e150:	d55fd0ef          	jal	ra,4000bea4 <net_ipv6_addr_cmp>
4000e154:	f00508e3          	beqz	a0,4000e064 <net_if_ipv6_prefix_add+0x94>
4000e158:	10c4c783          	lbu	a5,268(s1)
4000e15c:	f17794e3          	bne	a5,s7,4000e064 <net_if_ipv6_prefix_add+0x94>
4000e160:	02800793          	li	a5,40
			return &ipv6->prefix[i];
4000e164:	0c078793          	addi	a5,a5,192
4000e168:	00f484b3          	add	s1,s1,a5
	if (ifprefix) {
4000e16c:	ebdff06f          	j	4000e028 <net_if_ipv6_prefix_add+0x58>
		if (net_ipv6_addr_cmp(prefix, &ipv6->prefix[i].prefix) &&
4000e170:	00000793          	li	a5,0
4000e174:	ff1ff06f          	j	4000e164 <net_if_ipv6_prefix_add+0x194>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
4000e178:	00000413          	li	s0,0
4000e17c:	f15ff06f          	j	4000e090 <net_if_ipv6_prefix_add+0xc0>

4000e180 <net_if_ipv6_prefix_get>:
{
4000e180:	ff010113          	addi	sp,sp,-16
4000e184:	00812423          	sw	s0,8(sp)
4000e188:	01212023          	sw	s2,0(sp)
4000e18c:	00050413          	mv	s0,a0
4000e190:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
4000e194:	fff00513          	li	a0,-1
4000e198:	fff00593          	li	a1,-1
{
4000e19c:	00112623          	sw	ra,12(sp)
4000e1a0:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e1a4:	da5fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (!iface) {
4000e1a8:	00041663          	bnez	s0,4000e1b4 <net_if_ipv6_prefix_get+0x34>
		iface = net_if_get_default();
4000e1ac:	a11fe0ef          	jal	ra,4000cbbc <net_if_get_default>
4000e1b0:	00050413          	mv	s0,a0
	ipv6 = iface->config.ip.ipv6;
4000e1b4:	00442403          	lw	s0,4(s0)
	if (!ipv6) {
4000e1b8:	04040a63          	beqz	s0,4000e20c <net_if_ipv6_prefix_get+0x8c>
		if (!ipv6->prefix[i].is_used) {
4000e1bc:	0e442783          	lw	a5,228(s0)
4000e1c0:	0097d793          	srli	a5,a5,0x9
4000e1c4:	0017f793          	andi	a5,a5,1
4000e1c8:	06079263          	bnez	a5,4000e22c <net_if_ipv6_prefix_get+0xac>
	struct net_if_ipv6_prefix *prefix = NULL;
4000e1cc:	00000493          	li	s1,0
		if (!ipv6->prefix[i].is_used) {
4000e1d0:	10c42783          	lw	a5,268(s0)
4000e1d4:	0097d793          	srli	a5,a5,0x9
4000e1d8:	0017f793          	andi	a5,a5,1
4000e1dc:	02078663          	beqz	a5,4000e208 <net_if_ipv6_prefix_get+0x88>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
4000e1e0:	10c44603          	lbu	a2,268(s0)
4000e1e4:	00090593          	mv	a1,s2
4000e1e8:	0f840513          	addi	a0,s0,248
4000e1ec:	c0dfd0ef          	jal	ra,4000bdf8 <net_ipv6_is_prefix>
4000e1f0:	00050c63          	beqz	a0,4000e208 <net_if_ipv6_prefix_get+0x88>
			if (!prefix || prefix->len > ipv6->prefix[i].len) {
4000e1f4:	00048863          	beqz	s1,4000e204 <net_if_ipv6_prefix_get+0x84>
4000e1f8:	0244c703          	lbu	a4,36(s1)
4000e1fc:	10c44783          	lbu	a5,268(s0)
4000e200:	00e7f463          	bgeu	a5,a4,4000e208 <net_if_ipv6_prefix_get+0x88>
				prefix = &ipv6->prefix[i];
4000e204:	0e840493          	addi	s1,s0,232
	struct net_if_ipv6_prefix *prefix = NULL;
4000e208:	00048413          	mv	s0,s1
	k_mutex_unlock(&lock);
4000e20c:	d51fd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000e210:	00c12083          	lw	ra,12(sp)
4000e214:	00040513          	mv	a0,s0
4000e218:	00812403          	lw	s0,8(sp)
4000e21c:	00412483          	lw	s1,4(sp)
4000e220:	00012903          	lw	s2,0(sp)
4000e224:	01010113          	addi	sp,sp,16
4000e228:	00008067          	ret
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
4000e22c:	0e444603          	lbu	a2,228(s0)
4000e230:	00090593          	mv	a1,s2
4000e234:	0d040513          	addi	a0,s0,208
4000e238:	bc1fd0ef          	jal	ra,4000bdf8 <net_ipv6_is_prefix>
4000e23c:	f80508e3          	beqz	a0,4000e1cc <net_if_ipv6_prefix_get+0x4c>
				prefix = &ipv6->prefix[i];
4000e240:	0c040493          	addi	s1,s0,192
4000e244:	f8dff06f          	j	4000e1d0 <net_if_ipv6_prefix_get+0x50>

4000e248 <net_if_ipv6_prefix_lookup>:
{
4000e248:	ff010113          	addi	sp,sp,-16
4000e24c:	00812423          	sw	s0,8(sp)
4000e250:	00912223          	sw	s1,4(sp)
4000e254:	00050413          	mv	s0,a0
4000e258:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
4000e25c:	fff00513          	li	a0,-1
4000e260:	fff00593          	li	a1,-1
{
4000e264:	01212023          	sw	s2,0(sp)
4000e268:	00112623          	sw	ra,12(sp)
4000e26c:	00060913          	mv	s2,a2
	k_mutex_lock(&lock, K_FOREVER);
4000e270:	cd9fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
4000e274:	00442403          	lw	s0,4(s0)
	if (!ipv6) {
4000e278:	02041463          	bnez	s0,4000e2a0 <net_if_ipv6_prefix_lookup+0x58>
	struct net_if_ipv6_prefix *prefix = NULL;
4000e27c:	00000413          	li	s0,0
	k_mutex_unlock(&lock);
4000e280:	cddfd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000e284:	00c12083          	lw	ra,12(sp)
4000e288:	00040513          	mv	a0,s0
4000e28c:	00812403          	lw	s0,8(sp)
4000e290:	00412483          	lw	s1,4(sp)
4000e294:	00012903          	lw	s2,0(sp)
4000e298:	01010113          	addi	sp,sp,16
4000e29c:	00008067          	ret
		if (!ipv6->prefix[i].is_used) {
4000e2a0:	0e442783          	lw	a5,228(s0)
4000e2a4:	0097d793          	srli	a5,a5,0x9
4000e2a8:	0017f793          	andi	a5,a5,1
4000e2ac:	04079063          	bnez	a5,4000e2ec <net_if_ipv6_prefix_lookup+0xa4>
4000e2b0:	10c42783          	lw	a5,268(s0)
4000e2b4:	0097d793          	srli	a5,a5,0x9
4000e2b8:	0017f793          	andi	a5,a5,1
4000e2bc:	fc0780e3          	beqz	a5,4000e27c <net_if_ipv6_prefix_lookup+0x34>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
4000e2c0:	00090613          	mv	a2,s2
4000e2c4:	00048593          	mv	a1,s1
4000e2c8:	0f840513          	addi	a0,s0,248
4000e2cc:	b2dfd0ef          	jal	ra,4000bdf8 <net_ipv6_is_prefix>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
4000e2d0:	00100793          	li	a5,1
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
4000e2d4:	fa0504e3          	beqz	a0,4000e27c <net_if_ipv6_prefix_lookup+0x34>
			prefix = &ipv6->prefix[i];
4000e2d8:	02800713          	li	a4,40
4000e2dc:	02e787b3          	mul	a5,a5,a4
4000e2e0:	0c078793          	addi	a5,a5,192
4000e2e4:	00f40433          	add	s0,s0,a5
			goto out;
4000e2e8:	f99ff06f          	j	4000e280 <net_if_ipv6_prefix_lookup+0x38>
		if (net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
4000e2ec:	00090613          	mv	a2,s2
4000e2f0:	00048593          	mv	a1,s1
4000e2f4:	0d040513          	addi	a0,s0,208
4000e2f8:	b01fd0ef          	jal	ra,4000bdf8 <net_ipv6_is_prefix>
4000e2fc:	fa050ae3          	beqz	a0,4000e2b0 <net_if_ipv6_prefix_lookup+0x68>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
4000e300:	00000793          	li	a5,0
4000e304:	fd5ff06f          	j	4000e2d8 <net_if_ipv6_prefix_lookup+0x90>

4000e308 <net_if_ipv6_addr_onlink>:
{
4000e308:	fd010113          	addi	sp,sp,-48
4000e30c:	02812423          	sw	s0,40(sp)
4000e310:	03212023          	sw	s2,32(sp)
4000e314:	01312e23          	sw	s3,28(sp)
4000e318:	01412c23          	sw	s4,24(sp)
4000e31c:	00050913          	mv	s2,a0
4000e320:	00058a13          	mv	s4,a1
	k_mutex_lock(&lock, K_FOREVER);
4000e324:	fff00513          	li	a0,-1
4000e328:	fff00593          	li	a1,-1
	STRUCT_SECTION_FOREACH(net_if, tmp) {
4000e32c:	4003d437          	lui	s0,0x4003d
4000e330:	4003d9b7          	lui	s3,0x4003d
{
4000e334:	02112623          	sw	ra,44(sp)
4000e338:	02912223          	sw	s1,36(sp)
	STRUCT_SECTION_FOREACH(net_if, tmp) {
4000e33c:	c3c40413          	addi	s0,s0,-964 # 4003cc3c <__net_if_dts_ord_12_0>
	k_mutex_lock(&lock, K_FOREVER);
4000e340:	c09fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, tmp) {
4000e344:	c4898993          	addi	s3,s3,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000e348:	01346663          	bltu	s0,s3,4000e354 <net_if_ipv6_addr_onlink+0x4c>
	bool ret = false;
4000e34c:	00000513          	li	a0,0
4000e350:	0880006f          	j	4000e3d8 <net_if_ipv6_addr_onlink+0xd0>
		struct net_if_ipv6 *ipv6 = tmp->config.ip.ipv6;
4000e354:	00442483          	lw	s1,4(s0)
		if (iface && *iface && *iface != tmp) {
4000e358:	02090263          	beqz	s2,4000e37c <net_if_ipv6_addr_onlink+0x74>
4000e35c:	00092783          	lw	a5,0(s2)
4000e360:	00078e63          	beqz	a5,4000e37c <net_if_ipv6_addr_onlink+0x74>
4000e364:	00879463          	bne	a5,s0,4000e36c <net_if_ipv6_addr_onlink+0x64>
		if (!ipv6) {
4000e368:	00049c63          	bnez	s1,4000e380 <net_if_ipv6_addr_onlink+0x78>
	STRUCT_SECTION_FOREACH(net_if, tmp) {
4000e36c:	00c40413          	addi	s0,s0,12
4000e370:	fd347ee3          	bgeu	s0,s3,4000e34c <net_if_ipv6_addr_onlink+0x44>
		struct net_if_ipv6 *ipv6 = tmp->config.ip.ipv6;
4000e374:	00442483          	lw	s1,4(s0)
		if (iface && *iface && *iface != tmp) {
4000e378:	fe5ff06f          	j	4000e35c <net_if_ipv6_addr_onlink+0x54>
		if (!ipv6) {
4000e37c:	02048c63          	beqz	s1,4000e3b4 <net_if_ipv6_addr_onlink+0xac>
			if (ipv6->prefix[i].is_used &&
4000e380:	0e44a783          	lw	a5,228(s1)
4000e384:	0097d793          	srli	a5,a5,0x9
4000e388:	0017f793          	andi	a5,a5,1
4000e38c:	02079863          	bnez	a5,4000e3bc <net_if_ipv6_addr_onlink+0xb4>
4000e390:	10c4a783          	lw	a5,268(s1)
4000e394:	0097d793          	srli	a5,a5,0x9
4000e398:	0017f793          	andi	a5,a5,1
4000e39c:	00078c63          	beqz	a5,4000e3b4 <net_if_ipv6_addr_onlink+0xac>
			    net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
4000e3a0:	10c4c603          	lbu	a2,268(s1)
4000e3a4:	000a0593          	mv	a1,s4
4000e3a8:	0f848513          	addi	a0,s1,248
4000e3ac:	a4dfd0ef          	jal	ra,4000bdf8 <net_ipv6_is_prefix>
			if (ipv6->prefix[i].is_used &&
4000e3b0:	02051063          	bnez	a0,4000e3d0 <net_if_ipv6_addr_onlink+0xc8>
	STRUCT_SECTION_FOREACH(net_if, tmp) {
4000e3b4:	00c40413          	addi	s0,s0,12
4000e3b8:	f91ff06f          	j	4000e348 <net_if_ipv6_addr_onlink+0x40>
			    net_ipv6_is_prefix(ipv6->prefix[i].prefix.s6_addr,
4000e3bc:	0e44c603          	lbu	a2,228(s1)
4000e3c0:	000a0593          	mv	a1,s4
4000e3c4:	0d048513          	addi	a0,s1,208
4000e3c8:	a31fd0ef          	jal	ra,4000bdf8 <net_ipv6_is_prefix>
			if (ipv6->prefix[i].is_used &&
4000e3cc:	fc0502e3          	beqz	a0,4000e390 <net_if_ipv6_addr_onlink+0x88>
				if (iface) {
4000e3d0:	02091a63          	bnez	s2,4000e404 <net_if_ipv6_addr_onlink+0xfc>
				ret = true;
4000e3d4:	00100513          	li	a0,1
4000e3d8:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000e3dc:	b81fd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000e3e0:	02c12083          	lw	ra,44(sp)
4000e3e4:	02812403          	lw	s0,40(sp)
4000e3e8:	00c12503          	lw	a0,12(sp)
4000e3ec:	02412483          	lw	s1,36(sp)
4000e3f0:	02012903          	lw	s2,32(sp)
4000e3f4:	01c12983          	lw	s3,28(sp)
4000e3f8:	01812a03          	lw	s4,24(sp)
4000e3fc:	03010113          	addi	sp,sp,48
4000e400:	00008067          	ret
					*iface = tmp;
4000e404:	00892023          	sw	s0,0(s2)
4000e408:	fcdff06f          	j	4000e3d4 <net_if_ipv6_addr_onlink+0xcc>

4000e40c <net_if_ipv6_prefix_set_timer>:
	if (lifetime == 0xffffffff) {
4000e40c:	fff00793          	li	a5,-1
4000e410:	08f58463          	beq	a1,a5,4000e498 <net_if_ipv6_prefix_set_timer+0x8c>
{
4000e414:	ff010113          	addi	sp,sp,-16
4000e418:	00812423          	sw	s0,8(sp)
4000e41c:	00912223          	sw	s1,4(sp)
4000e420:	00050413          	mv	s0,a0
4000e424:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
4000e428:	fff00513          	li	a0,-1
4000e42c:	fff00593          	li	a1,-1
{
4000e430:	00112623          	sw	ra,12(sp)
4000e434:	01212023          	sw	s2,0(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e438:	b11fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	(void)sys_slist_find_and_remove(&active_prefix_lifetime_timers,
4000e43c:	40031937          	lui	s2,0x40031
4000e440:	00040593          	mv	a1,s0
4000e444:	a5490513          	addi	a0,s2,-1452 # 40030a54 <active_prefix_lifetime_timers>
4000e448:	f04fd0ef          	jal	ra,4000bb4c <sys_slist_find_and_remove>
	sys_slist_append(&active_prefix_lifetime_timers,
4000e44c:	00040593          	mv	a1,s0
4000e450:	a5490513          	addi	a0,s2,-1452
4000e454:	ed4fd0ef          	jal	ra,4000bb28 <sys_slist_append>
	net_timeout_set(&ifprefix->lifetime, lifetime, k_uptime_get_32());
4000e458:	a6dfd0ef          	jal	ra,4000bec4 <k_uptime_get_32>
4000e45c:	00050613          	mv	a2,a0
4000e460:	00048593          	mv	a1,s1
4000e464:	00040513          	mv	a0,s0
4000e468:	624010ef          	jal	ra,4000fa8c <net_timeout_set>
	k_work_reschedule(&prefix_lifetime_timer, K_NO_WAIT);
4000e46c:	40031537          	lui	a0,0x40031
4000e470:	00000593          	li	a1,0
4000e474:	00000613          	li	a2,0
4000e478:	e3850513          	addi	a0,a0,-456 # 40030e38 <prefix_lifetime_timer>
4000e47c:	1a81b0ef          	jal	ra,40029624 <k_work_reschedule>
}
4000e480:	00812403          	lw	s0,8(sp)
4000e484:	00c12083          	lw	ra,12(sp)
4000e488:	00412483          	lw	s1,4(sp)
4000e48c:	00012903          	lw	s2,0(sp)
4000e490:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
4000e494:	ac9fd06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>
4000e498:	00008067          	ret

4000e49c <net_if_ipv6_prefix_unset_timer>:
	if (!prefix->is_used) {
4000e49c:	02554783          	lbu	a5,37(a0)
4000e4a0:	0027f793          	andi	a5,a5,2
4000e4a4:	04078863          	beqz	a5,4000e4f4 <net_if_ipv6_prefix_unset_timer+0x58>
{
4000e4a8:	ff010113          	addi	sp,sp,-16
4000e4ac:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e4b0:	fff00593          	li	a1,-1
4000e4b4:	00050413          	mv	s0,a0
4000e4b8:	fff00513          	li	a0,-1
{
4000e4bc:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e4c0:	a89fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	sys_slist_find_and_remove(&active_prefix_lifetime_timers,
4000e4c4:	40031537          	lui	a0,0x40031
4000e4c8:	00040593          	mv	a1,s0
4000e4cc:	a5450513          	addi	a0,a0,-1452 # 40030a54 <active_prefix_lifetime_timers>
4000e4d0:	e7cfd0ef          	jal	ra,4000bb4c <sys_slist_find_and_remove>
	net_timeout_set(&ifprefix->lifetime, 0, 0);
4000e4d4:	00040513          	mv	a0,s0
4000e4d8:	00000613          	li	a2,0
4000e4dc:	00000593          	li	a1,0
4000e4e0:	5ac010ef          	jal	ra,4000fa8c <net_timeout_set>
}
4000e4e4:	00812403          	lw	s0,8(sp)
4000e4e8:	00c12083          	lw	ra,12(sp)
4000e4ec:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
4000e4f0:	a6dfd06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>
4000e4f4:	00008067          	ret

4000e4f8 <net_if_ipv6_prefix_rm>:
{
4000e4f8:	fd010113          	addi	sp,sp,-48
4000e4fc:	03212023          	sw	s2,32(sp)
4000e500:	01312e23          	sw	s3,28(sp)
4000e504:	00050913          	mv	s2,a0
4000e508:	00058993          	mv	s3,a1
	k_mutex_lock(&lock, K_FOREVER);
4000e50c:	fff00513          	li	a0,-1
4000e510:	fff00593          	li	a1,-1
{
4000e514:	02812423          	sw	s0,40(sp)
4000e518:	01412c23          	sw	s4,24(sp)
4000e51c:	02112623          	sw	ra,44(sp)
4000e520:	02912223          	sw	s1,36(sp)
4000e524:	01512a23          	sw	s5,20(sp)
4000e528:	00060a13          	mv	s4,a2
	k_mutex_lock(&lock, K_FOREVER);
4000e52c:	a1dfd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
4000e530:	00492403          	lw	s0,4(s2)
	if (!ipv6) {
4000e534:	02041c63          	bnez	s0,4000e56c <net_if_ipv6_prefix_rm+0x74>
	bool ret = false;
4000e538:	00000513          	li	a0,0
4000e53c:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000e540:	a1dfd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000e544:	02c12083          	lw	ra,44(sp)
4000e548:	02812403          	lw	s0,40(sp)
4000e54c:	00c12503          	lw	a0,12(sp)
4000e550:	02412483          	lw	s1,36(sp)
4000e554:	02012903          	lw	s2,32(sp)
4000e558:	01c12983          	lw	s3,28(sp)
4000e55c:	01812a03          	lw	s4,24(sp)
4000e560:	01412a83          	lw	s5,20(sp)
4000e564:	03010113          	addi	sp,sp,48
4000e568:	00008067          	ret
		if (!ipv6->prefix[i].is_used) {
4000e56c:	0e442783          	lw	a5,228(s0)
4000e570:	0097d793          	srli	a5,a5,0x9
4000e574:	0017f793          	andi	a5,a5,1
4000e578:	02078063          	beqz	a5,4000e598 <net_if_ipv6_prefix_rm+0xa0>
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
4000e57c:	0d040a93          	addi	s5,s0,208
4000e580:	00098593          	mv	a1,s3
4000e584:	000a8513          	mv	a0,s5
4000e588:	91dfd0ef          	jal	ra,4000bea4 <net_ipv6_addr_cmp>
4000e58c:	00050663          	beqz	a0,4000e598 <net_if_ipv6_prefix_rm+0xa0>
4000e590:	0e444783          	lbu	a5,228(s0)
4000e594:	09478863          	beq	a5,s4,4000e624 <net_if_ipv6_prefix_rm+0x12c>
		if (!ipv6->prefix[i].is_used) {
4000e598:	10c42783          	lw	a5,268(s0)
4000e59c:	0097d793          	srli	a5,a5,0x9
4000e5a0:	0017f793          	andi	a5,a5,1
4000e5a4:	f8078ae3          	beqz	a5,4000e538 <net_if_ipv6_prefix_rm+0x40>
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
4000e5a8:	0f840a93          	addi	s5,s0,248
4000e5ac:	00098593          	mv	a1,s3
4000e5b0:	000a8513          	mv	a0,s5
4000e5b4:	8f1fd0ef          	jal	ra,4000bea4 <net_ipv6_addr_cmp>
4000e5b8:	f80500e3          	beqz	a0,4000e538 <net_if_ipv6_prefix_rm+0x40>
4000e5bc:	10c44783          	lbu	a5,268(s0)
4000e5c0:	f7479ce3          	bne	a5,s4,4000e538 <net_if_ipv6_prefix_rm+0x40>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
4000e5c4:	00100493          	li	s1,1
4000e5c8:	02800513          	li	a0,40
		net_if_ipv6_prefix_unset_timer(&ipv6->prefix[i]);
4000e5cc:	0c050513          	addi	a0,a0,192
4000e5d0:	00a40533          	add	a0,s0,a0
4000e5d4:	ec9ff0ef          	jal	ra,4000e49c <net_if_ipv6_prefix_unset_timer>
		ipv6->prefix[i].is_used = false;
4000e5d8:	02800793          	li	a5,40
4000e5dc:	02f484b3          	mul	s1,s1,a5
		remove_prefix_addresses(iface, ipv6, addr, len);
4000e5e0:	000a0693          	mv	a3,s4
4000e5e4:	00098613          	mv	a2,s3
4000e5e8:	00040593          	mv	a1,s0
4000e5ec:	00090513          	mv	a0,s2
		ipv6->prefix[i].is_used = false;
4000e5f0:	009404b3          	add	s1,s0,s1
4000e5f4:	0e54c783          	lbu	a5,229(s1)
4000e5f8:	ffd7f793          	andi	a5,a5,-3
4000e5fc:	0ef482a3          	sb	a5,229(s1)
		remove_prefix_addresses(iface, ipv6, addr, len);
4000e600:	d74ff0ef          	jal	ra,4000db74 <remove_prefix_addresses>
		net_mgmt_event_notify_with_info(
4000e604:	e0600537          	lui	a0,0xe0600
4000e608:	00650513          	addi	a0,a0,6 # e0600006 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600007>
4000e60c:	01000693          	li	a3,16
4000e610:	000a8613          	mv	a2,s5
4000e614:	00090593          	mv	a1,s2
4000e618:	119020ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
		ret = true;
4000e61c:	00100513          	li	a0,1
		goto out;
4000e620:	f1dff06f          	j	4000e53c <net_if_ipv6_prefix_rm+0x44>
	for (i = 0; i < NET_IF_MAX_IPV6_PREFIX; i++) {
4000e624:	00000493          	li	s1,0
		if (!net_ipv6_addr_cmp(&ipv6->prefix[i].prefix, addr) ||
4000e628:	00000513          	li	a0,0
4000e62c:	fa1ff06f          	j	4000e5cc <net_if_ipv6_prefix_rm+0xd4>

4000e630 <net_if_ipv6_router_lookup>:
{
4000e630:	00058613          	mv	a2,a1
	return iface_router_lookup(iface, AF_INET6, addr);
4000e634:	00200593          	li	a1,2
4000e638:	9d9fd06f          	j	4000c010 <iface_router_lookup>

4000e63c <net_if_ipv6_router_find_default>:
	return iface_router_find_default(iface, AF_INET6, addr);
4000e63c:	00200593          	li	a1,2
4000e640:	ee5fd06f          	j	4000c524 <iface_router_find_default.constprop.0>

4000e644 <net_if_ipv6_router_update_lifetime>:
{
4000e644:	ff010113          	addi	sp,sp,-16
4000e648:	00812423          	sw	s0,8(sp)
4000e64c:	00912223          	sw	s1,4(sp)
4000e650:	00112623          	sw	ra,12(sp)
4000e654:	00050413          	mv	s0,a0
4000e658:	00058493          	mv	s1,a1
	router->life_start = k_uptime_get_32();
4000e65c:	869fd0ef          	jal	ra,4000bec4 <k_uptime_get_32>
4000e660:	00a42e23          	sw	a0,28(s0)
	router->lifetime = lifetime;
4000e664:	02941023          	sh	s1,32(s0)
}
4000e668:	00812403          	lw	s0,8(sp)
4000e66c:	00c12083          	lw	ra,12(sp)
4000e670:	00412483          	lw	s1,4(sp)
4000e674:	01010113          	addi	sp,sp,16
	iface_router_update_timer(router->life_start);
4000e678:	aa9fd06f          	j	4000c120 <iface_router_update_timer>

4000e67c <net_if_ipv6_router_add>:
{
4000e67c:	00060713          	mv	a4,a2
	return iface_router_add(iface, AF_INET6, addr, false, lifetime);
4000e680:	00000693          	li	a3,0
4000e684:	00058613          	mv	a2,a1
4000e688:	00200593          	li	a1,2
4000e68c:	b5dfd06f          	j	4000c1e8 <iface_router_add>

4000e690 <net_if_ipv6_router_rm>:
	return iface_router_rm(router);
4000e690:	d05fd06f          	j	4000c394 <iface_router_rm>

4000e694 <net_if_ipv6_get_hop_limit>:
{
4000e694:	fe010113          	addi	sp,sp,-32
4000e698:	00812c23          	sw	s0,24(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e69c:	fff00593          	li	a1,-1
{
4000e6a0:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000e6a4:	fff00513          	li	a0,-1
{
4000e6a8:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e6ac:	89dfd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (!iface->config.ip.ipv6) {
4000e6b0:	00442783          	lw	a5,4(s0)
	int ret = 0;
4000e6b4:	00000513          	li	a0,0
	if (!iface->config.ip.ipv6) {
4000e6b8:	00078463          	beqz	a5,4000e6c0 <net_if_ipv6_get_hop_limit+0x2c>
	ret = iface->config.ip.ipv6->hop_limit;
4000e6bc:	1257c503          	lbu	a0,293(a5)
4000e6c0:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000e6c4:	899fd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000e6c8:	01c12083          	lw	ra,28(sp)
4000e6cc:	01812403          	lw	s0,24(sp)
4000e6d0:	00c12503          	lw	a0,12(sp)
4000e6d4:	02010113          	addi	sp,sp,32
4000e6d8:	00008067          	ret

4000e6dc <net_ipv6_set_hop_limit>:
{
4000e6dc:	ff010113          	addi	sp,sp,-16
4000e6e0:	00812423          	sw	s0,8(sp)
4000e6e4:	00912223          	sw	s1,4(sp)
4000e6e8:	00058413          	mv	s0,a1
4000e6ec:	00050493          	mv	s1,a0
	k_mutex_lock(&lock, K_FOREVER);
4000e6f0:	fff00593          	li	a1,-1
4000e6f4:	fff00513          	li	a0,-1
{
4000e6f8:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e6fc:	84dfd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (!iface->config.ip.ipv6) {
4000e700:	0044a783          	lw	a5,4(s1)
4000e704:	00078463          	beqz	a5,4000e70c <net_ipv6_set_hop_limit+0x30>
	iface->config.ip.ipv6->hop_limit = hop_limit;
4000e708:	128782a3          	sb	s0,293(a5)
}
4000e70c:	00812403          	lw	s0,8(sp)
4000e710:	00c12083          	lw	ra,12(sp)
4000e714:	00412483          	lw	s1,4(sp)
4000e718:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
4000e71c:	841fd06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>

4000e720 <net_if_ipv6_get_ll>:
{
4000e720:	fe010113          	addi	sp,sp,-32
4000e724:	00812c23          	sw	s0,24(sp)
4000e728:	00912a23          	sw	s1,20(sp)
4000e72c:	00058413          	mv	s0,a1
4000e730:	00050493          	mv	s1,a0
	k_mutex_lock(&lock, K_FOREVER);
4000e734:	fff00593          	li	a1,-1
4000e738:	fff00513          	li	a0,-1
{
4000e73c:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e740:	809fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	ipv6 = iface->config.ip.ipv6;
4000e744:	0044a503          	lw	a0,4(s1)
	if (!ipv6) {
4000e748:	06050a63          	beqz	a0,4000e7bc <net_if_ipv6_get_ll+0x9c>
4000e74c:	00450793          	addi	a5,a0,4
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000e750:	00000693          	li	a3,0
		if (!ipv6->unicast[i].is_used ||
4000e754:	03000813          	li	a6,48
4000e758:	fff00893          	li	a7,-1
		     ipv6->unicast[i].addr_state != addr_state) ||
4000e75c:	00200313          	li	t1,2
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000e760:	00300593          	li	a1,3
		if (!ipv6->unicast[i].is_used ||
4000e764:	03068733          	mul	a4,a3,a6
4000e768:	00e50733          	add	a4,a0,a4
4000e76c:	02c72703          	lw	a4,44(a4)
4000e770:	01975713          	srli	a4,a4,0x19
4000e774:	00177713          	andi	a4,a4,1
4000e778:	02070a63          	beqz	a4,4000e7ac <net_if_ipv6_get_ll+0x8c>
4000e77c:	01140663          	beq	s0,a7,4000e788 <net_if_ipv6_get_ll+0x68>
		    (addr_state != NET_ADDR_ANY_STATE &&
4000e780:	02978703          	lb	a4,41(a5)
4000e784:	02871463          	bne	a4,s0,4000e7ac <net_if_ipv6_get_ll+0x8c>
		     ipv6->unicast[i].addr_state != addr_state) ||
4000e788:	ffc7d703          	lhu	a4,-4(a5)
4000e78c:	02671063          	bne	a4,t1,4000e7ac <net_if_ipv6_get_ll+0x8c>
	return UNALIGNED_GET(&addr->s6_addr16[0]) == htons(0xFE80);
4000e790:	0017c703          	lbu	a4,1(a5)
4000e794:	0007c603          	lbu	a2,0(a5)
4000e798:	00871713          	slli	a4,a4,0x8
		if (net_ipv6_is_ll_addr(&ipv6->unicast[i].address.in6_addr)) {
4000e79c:	00c76733          	or	a4,a4,a2
4000e7a0:	00008637          	lui	a2,0x8
4000e7a4:	0fe60613          	addi	a2,a2,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
4000e7a8:	02c70a63          	beq	a4,a2,4000e7dc <net_if_ipv6_get_ll+0xbc>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
4000e7ac:	00168693          	addi	a3,a3,1
4000e7b0:	03078793          	addi	a5,a5,48
4000e7b4:	fab698e3          	bne	a3,a1,4000e764 <net_if_ipv6_get_ll+0x44>
	struct in6_addr *addr = NULL;
4000e7b8:	00000513          	li	a0,0
4000e7bc:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000e7c0:	f9cfd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000e7c4:	01c12083          	lw	ra,28(sp)
4000e7c8:	01812403          	lw	s0,24(sp)
4000e7cc:	00c12503          	lw	a0,12(sp)
4000e7d0:	01412483          	lw	s1,20(sp)
4000e7d4:	02010113          	addi	sp,sp,32
4000e7d8:	00008067          	ret
		if (net_ipv6_is_ll_addr(&ipv6->unicast[i].address.in6_addr)) {
4000e7dc:	00078513          	mv	a0,a5
4000e7e0:	fddff06f          	j	4000e7bc <net_if_ipv6_get_ll+0x9c>

4000e7e4 <net_if_ipv6_select_src_addr>:
{
4000e7e4:	fd010113          	addi	sp,sp,-48
4000e7e8:	02812423          	sw	s0,40(sp)
4000e7ec:	03212023          	sw	s2,32(sp)
4000e7f0:	00050413          	mv	s0,a0
4000e7f4:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
4000e7f8:	fff00513          	li	a0,-1
4000e7fc:	fff00593          	li	a1,-1
{
4000e800:	02112623          	sw	ra,44(sp)
4000e804:	02912223          	sw	s1,36(sp)
4000e808:	01312e23          	sw	s3,28(sp)
	uint8_t best_match = 0U;
4000e80c:	000107a3          	sb	zero,15(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e810:	f38fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
4000e814:	00194683          	lbu	a3,1(s2)
4000e818:	00094603          	lbu	a2,0(s2)
	if (!net_ipv6_is_ll_addr(dst) && !net_ipv6_is_addr_mcast_link(dst)) {
4000e81c:	000087b7          	lui	a5,0x8
4000e820:	00869713          	slli	a4,a3,0x8
4000e824:	00c76733          	or	a4,a4,a2
4000e828:	0fe78793          	addi	a5,a5,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
4000e82c:	08f70663          	beq	a4,a5,4000e8b8 <net_if_ipv6_select_src_addr+0xd4>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
4000e830:	0ff00793          	li	a5,255
4000e834:	00f61663          	bne	a2,a5,4000e840 <net_if_ipv6_select_src_addr+0x5c>
4000e838:	00200793          	li	a5,2
4000e83c:	06f68e63          	beq	a3,a5,4000e8b8 <net_if_ipv6_select_src_addr+0xd4>
		if (dst_iface) {
4000e840:	06040263          	beqz	s0,4000e8a4 <net_if_ipv6_select_src_addr+0xc0>
			src = net_if_ipv6_get_best_match(dst_iface, dst,
4000e844:	00442503          	lw	a0,4(s0)
4000e848:	00f10613          	addi	a2,sp,15
4000e84c:	00090593          	mv	a1,s2
4000e850:	f3dfd0ef          	jal	ra,4000c78c <net_if_ipv6_get_best_match.isra.0>
			src = net_if_ipv6_get_ll(dst_iface, NET_ADDR_PREFERRED);
4000e854:	00050413          	mv	s0,a0
4000e858:	0240006f          	j	4000e87c <net_if_ipv6_select_src_addr+0x98>
				addr = net_if_ipv6_get_best_match(iface, dst,
4000e85c:	0044a503          	lw	a0,4(s1)
4000e860:	00f10613          	addi	a2,sp,15
4000e864:	00090593          	mv	a1,s2
4000e868:	f25fd0ef          	jal	ra,4000c78c <net_if_ipv6_get_best_match.isra.0>
				if (addr) {
4000e86c:	00050463          	beqz	a0,4000e874 <net_if_ipv6_select_src_addr+0x90>
4000e870:	00050413          	mv	s0,a0
			STRUCT_SECTION_FOREACH(net_if, iface) {
4000e874:	00c48493          	addi	s1,s1,12
4000e878:	ff34e2e3          	bltu	s1,s3,4000e85c <net_if_ipv6_select_src_addr+0x78>
	if (!src) {
4000e87c:	06040663          	beqz	s0,4000e8e8 <net_if_ipv6_select_src_addr+0x104>
	k_mutex_unlock(&lock);
4000e880:	edcfd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000e884:	02c12083          	lw	ra,44(sp)
4000e888:	00040513          	mv	a0,s0
4000e88c:	02812403          	lw	s0,40(sp)
4000e890:	02412483          	lw	s1,36(sp)
4000e894:	02012903          	lw	s2,32(sp)
4000e898:	01c12983          	lw	s3,28(sp)
4000e89c:	03010113          	addi	sp,sp,48
4000e8a0:	00008067          	ret
			STRUCT_SECTION_FOREACH(net_if, iface) {
4000e8a4:	4003d4b7          	lui	s1,0x4003d
4000e8a8:	4003d9b7          	lui	s3,0x4003d
4000e8ac:	c3c48493          	addi	s1,s1,-964 # 4003cc3c <__net_if_dts_ord_12_0>
4000e8b0:	c4898993          	addi	s3,s3,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000e8b4:	fc5ff06f          	j	4000e878 <net_if_ipv6_select_src_addr+0x94>
		if (dst_iface) {
4000e8b8:	02040e63          	beqz	s0,4000e8f4 <net_if_ipv6_select_src_addr+0x110>
			src = net_if_ipv6_get_ll(dst_iface, NET_ADDR_PREFERRED);
4000e8bc:	00100593          	li	a1,1
4000e8c0:	00040513          	mv	a0,s0
4000e8c4:	e5dff0ef          	jal	ra,4000e720 <net_if_ipv6_get_ll>
4000e8c8:	f8dff06f          	j	4000e854 <net_if_ipv6_select_src_addr+0x70>
				addr = net_if_ipv6_get_ll(iface,
4000e8cc:	00100593          	li	a1,1
4000e8d0:	00048513          	mv	a0,s1
4000e8d4:	e4dff0ef          	jal	ra,4000e720 <net_if_ipv6_get_ll>
4000e8d8:	00050413          	mv	s0,a0
				if (addr) {
4000e8dc:	fa0512e3          	bnez	a0,4000e880 <net_if_ipv6_select_src_addr+0x9c>
			STRUCT_SECTION_FOREACH(net_if, iface) {
4000e8e0:	00c48493          	addi	s1,s1,12
4000e8e4:	ff24e4e3          	bltu	s1,s2,4000e8cc <net_if_ipv6_select_src_addr+0xe8>
		src = net_ipv6_unspecified_address();
4000e8e8:	384020ef          	jal	ra,40010c6c <net_ipv6_unspecified_address>
4000e8ec:	00050413          	mv	s0,a0
		goto out;
4000e8f0:	f91ff06f          	j	4000e880 <net_if_ipv6_select_src_addr+0x9c>
			STRUCT_SECTION_FOREACH(net_if, iface) {
4000e8f4:	4003d4b7          	lui	s1,0x4003d
4000e8f8:	4003d937          	lui	s2,0x4003d
4000e8fc:	c3c48493          	addi	s1,s1,-964 # 4003cc3c <__net_if_dts_ord_12_0>
4000e900:	c4890913          	addi	s2,s2,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000e904:	fe1ff06f          	j	4000e8e4 <net_if_ipv6_select_src_addr+0x100>

4000e908 <net_if_ipv6_select_src_iface>:
{
4000e908:	fe010113          	addi	sp,sp,-32
4000e90c:	00812c23          	sw	s0,24(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e910:	fff00593          	li	a1,-1
{
4000e914:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000e918:	fff00513          	li	a0,-1
{
4000e91c:	00112e23          	sw	ra,28(sp)
	struct net_if *iface = NULL;
4000e920:	00012623          	sw	zero,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e924:	e24fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	src = net_if_ipv6_select_src_addr(NULL, dst);
4000e928:	00040593          	mv	a1,s0
4000e92c:	00000513          	li	a0,0
4000e930:	eb5ff0ef          	jal	ra,4000e7e4 <net_if_ipv6_select_src_addr>
4000e934:	00050413          	mv	s0,a0
	if (src != net_ipv6_unspecified_address()) {
4000e938:	334020ef          	jal	ra,40010c6c <net_ipv6_unspecified_address>
4000e93c:	02a41263          	bne	s0,a0,4000e960 <net_if_ipv6_select_src_iface+0x58>
		iface = net_if_get_default();
4000e940:	a7cfe0ef          	jal	ra,4000cbbc <net_if_get_default>
4000e944:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000e948:	e14fd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000e94c:	01c12083          	lw	ra,28(sp)
4000e950:	01812403          	lw	s0,24(sp)
4000e954:	00c12503          	lw	a0,12(sp)
4000e958:	02010113          	addi	sp,sp,32
4000e95c:	00008067          	ret
		net_if_ipv6_addr_lookup(src, &iface);
4000e960:	00c10593          	addi	a1,sp,12
4000e964:	00040513          	mv	a0,s0
4000e968:	db4fe0ef          	jal	ra,4000cf1c <net_if_ipv6_addr_lookup>
	if (iface == NULL) {
4000e96c:	00c12783          	lw	a5,12(sp)
4000e970:	fc079ce3          	bnez	a5,4000e948 <net_if_ipv6_select_src_iface+0x40>
4000e974:	fcdff06f          	j	4000e940 <net_if_ipv6_select_src_iface+0x38>

4000e978 <net_if_ipv6_calc_reachable_time>:
{
4000e978:	ff010113          	addi	sp,sp,-16
4000e97c:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e980:	fff00593          	li	a1,-1
{
4000e984:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000e988:	fff00513          	li	a0,-1
{
4000e98c:	00112623          	sw	ra,12(sp)
4000e990:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e994:	db4fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	min_reachable = (MIN_RANDOM_NUMER * ipv6->base_reachable_time)
4000e998:	11042403          	lw	s0,272(s0)
	k_mutex_unlock(&lock);
4000e99c:	dc0fd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
	min_reachable = (MIN_RANDOM_NUMER * ipv6->base_reachable_time)
4000e9a0:	00145493          	srli	s1,s0,0x1
	if (z_syscall_trap()) {
		return (uint32_t) arch_syscall_invoke0(K_SYSCALL_SYS_RAND32_GET);
	}
#endif
	compiler_barrier();
	return z_impl_sys_rand32_get();
4000e9a4:	bd1fa0ef          	jal	ra,40009574 <z_impl_sys_rand32_get>
	max_reachable = (MAX_RANDOM_NUMER * ipv6->base_reachable_time)
4000e9a8:	00300793          	li	a5,3
4000e9ac:	02f40433          	mul	s0,s0,a5
}
4000e9b0:	00c12083          	lw	ra,12(sp)
	max_reachable = (MAX_RANDOM_NUMER * ipv6->base_reachable_time)
4000e9b4:	00145413          	srli	s0,s0,0x1
	       sys_rand32_get() % (max_reachable - min_reachable);
4000e9b8:	40940433          	sub	s0,s0,s1
4000e9bc:	02857533          	remu	a0,a0,s0
}
4000e9c0:	00812403          	lw	s0,8(sp)
4000e9c4:	00950533          	add	a0,a0,s1
4000e9c8:	00412483          	lw	s1,4(sp)
4000e9cc:	01010113          	addi	sp,sp,16
4000e9d0:	00008067          	ret

4000e9d4 <net_if_config_ipv4_get>:
{
4000e9d4:	fe010113          	addi	sp,sp,-32
4000e9d8:	00812c23          	sw	s0,24(sp)
4000e9dc:	00912a23          	sw	s1,20(sp)
4000e9e0:	00050413          	mv	s0,a0
4000e9e4:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
4000e9e8:	fff00513          	li	a0,-1
4000e9ec:	fff00593          	li	a1,-1
{
4000e9f0:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000e9f4:	d54fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (!net_if_flag_is_set(iface, NET_IF_IPV4)) {
4000e9f8:	00600593          	li	a1,6
4000e9fc:	00040513          	mv	a0,s0
4000ea00:	bf9fd0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
4000ea04:	04050c63          	beqz	a0,4000ea5c <net_if_config_ipv4_get+0x88>
	if (iface->config.ip.ipv4) {
4000ea08:	00842783          	lw	a5,8(s0)
4000ea0c:	02078863          	beqz	a5,4000ea3c <net_if_config_ipv4_get+0x68>
		if (ipv4) {
4000ea10:	00048463          	beqz	s1,4000ea18 <net_if_config_ipv4_get+0x44>
			*ipv4 = &ipv4_addresses[i].ipv4;
4000ea14:	00f4a023          	sw	a5,0(s1)
	int ret = 0;
4000ea18:	00000513          	li	a0,0
4000ea1c:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000ea20:	d3cfd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000ea24:	01c12083          	lw	ra,28(sp)
4000ea28:	01812403          	lw	s0,24(sp)
4000ea2c:	00c12503          	lw	a0,12(sp)
4000ea30:	01412483          	lw	s1,20(sp)
4000ea34:	02010113          	addi	sp,sp,32
4000ea38:	00008067          	ret
		if (ipv4_addresses[i].iface) {
4000ea3c:	400327b7          	lui	a5,0x40032
4000ea40:	c8878793          	addi	a5,a5,-888 # 40031c88 <ipv4_addresses>
4000ea44:	0547a703          	lw	a4,84(a5)
	ret = -ESRCH;
4000ea48:	ffd00513          	li	a0,-3
		if (ipv4_addresses[i].iface) {
4000ea4c:	fc0718e3          	bnez	a4,4000ea1c <net_if_config_ipv4_get+0x48>
		iface->config.ip.ipv4 = &ipv4_addresses[i].ipv4;
4000ea50:	00f42423          	sw	a5,8(s0)
		ipv4_addresses[i].iface = iface;
4000ea54:	0487aa23          	sw	s0,84(a5)
4000ea58:	fb9ff06f          	j	4000ea10 <net_if_config_ipv4_get+0x3c>
		ret = -ENOTSUP;
4000ea5c:	f7a00513          	li	a0,-134
4000ea60:	fbdff06f          	j	4000ea1c <net_if_config_ipv4_get+0x48>

4000ea64 <net_if_ipv4_get_ttl>:
{
4000ea64:	fe010113          	addi	sp,sp,-32
4000ea68:	00812c23          	sw	s0,24(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000ea6c:	fff00593          	li	a1,-1
{
4000ea70:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000ea74:	fff00513          	li	a0,-1
{
4000ea78:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000ea7c:	cccfd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (!iface->config.ip.ipv4) {
4000ea80:	00842783          	lw	a5,8(s0)
	int ret = 0;
4000ea84:	00000513          	li	a0,0
	if (!iface->config.ip.ipv4) {
4000ea88:	00078463          	beqz	a5,4000ea90 <net_if_ipv4_get_ttl+0x2c>
	ret = iface->config.ip.ipv4->ttl;
4000ea8c:	0507c503          	lbu	a0,80(a5)
4000ea90:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000ea94:	cc8fd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000ea98:	01c12083          	lw	ra,28(sp)
4000ea9c:	01812403          	lw	s0,24(sp)
4000eaa0:	00c12503          	lw	a0,12(sp)
4000eaa4:	02010113          	addi	sp,sp,32
4000eaa8:	00008067          	ret

4000eaac <net_if_ipv4_addr_mask_cmp>:
{
4000eaac:	fe010113          	addi	sp,sp,-32
4000eab0:	00812c23          	sw	s0,24(sp)
4000eab4:	00912a23          	sw	s1,20(sp)
4000eab8:	00058413          	mv	s0,a1
4000eabc:	00050493          	mv	s1,a0
	k_mutex_lock(&lock, K_FOREVER);
4000eac0:	fff00593          	li	a1,-1
4000eac4:	fff00513          	li	a0,-1
{
4000eac8:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000eacc:	c7cfd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	ipv4 = iface->config.ip.ipv4;
4000ead0:	0084a703          	lw	a4,8(s1)
	if (!ipv4) {
4000ead4:	04070e63          	beqz	a4,4000eb30 <net_if_ipv4_addr_mask_cmp+0x84>
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
4000ead8:	00144783          	lbu	a5,1(s0)
4000eadc:	00044683          	lbu	a3,0(s0)
		if (!ipv4->unicast[i].is_used ||
4000eae0:	02c72503          	lw	a0,44(a4)
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
4000eae4:	00879793          	slli	a5,a5,0x8
4000eae8:	00d7e7b3          	or	a5,a5,a3
4000eaec:	00244683          	lbu	a3,2(s0)
		if (!ipv4->unicast[i].is_used ||
4000eaf0:	01955513          	srli	a0,a0,0x19
4000eaf4:	00157513          	andi	a0,a0,1
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
4000eaf8:	01069693          	slli	a3,a3,0x10
4000eafc:	00f6e6b3          	or	a3,a3,a5
4000eb00:	00344783          	lbu	a5,3(s0)
		if (!ipv4->unicast[i].is_used ||
4000eb04:	00100613          	li	a2,1
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
4000eb08:	01879793          	slli	a5,a5,0x18
4000eb0c:	00d7e7b3          	or	a5,a5,a3
4000eb10:	04c72683          	lw	a3,76(a4)
		if (!ipv4->unicast[i].is_used ||
4000eb14:	02050063          	beqz	a0,4000eb34 <net_if_ipv4_addr_mask_cmp+0x88>
4000eb18:	00075583          	lhu	a1,0(a4)
4000eb1c:	00c59a63          	bne	a1,a2,4000eb30 <net_if_ipv4_addr_mask_cmp+0x84>
		if ((ipv4->unicast[i].address.in_addr.s_addr &
4000eb20:	00472703          	lw	a4,4(a4)
4000eb24:	00e7c7b3          	xor	a5,a5,a4
4000eb28:	00d7f7b3          	and	a5,a5,a3
4000eb2c:	00078463          	beqz	a5,4000eb34 <net_if_ipv4_addr_mask_cmp+0x88>
	bool ret = false;
4000eb30:	00000513          	li	a0,0
4000eb34:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000eb38:	c24fd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000eb3c:	01c12083          	lw	ra,28(sp)
4000eb40:	01812403          	lw	s0,24(sp)
4000eb44:	00c12503          	lw	a0,12(sp)
4000eb48:	01412483          	lw	s1,20(sp)
4000eb4c:	02010113          	addi	sp,sp,32
4000eb50:	00008067          	ret

4000eb54 <ipv4_is_broadcast_address>:
{
4000eb54:	ff010113          	addi	sp,sp,-16
4000eb58:	00112623          	sw	ra,12(sp)
4000eb5c:	00812423          	sw	s0,8(sp)
4000eb60:	00912223          	sw	s1,4(sp)
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
4000eb64:	00852483          	lw	s1,8(a0)
	if (!ipv4) {
4000eb68:	00049e63          	bnez	s1,4000eb84 <ipv4_is_broadcast_address+0x30>
		return false;
4000eb6c:	00000513          	li	a0,0
}
4000eb70:	00c12083          	lw	ra,12(sp)
4000eb74:	00812403          	lw	s0,8(sp)
4000eb78:	00412483          	lw	s1,4(sp)
4000eb7c:	01010113          	addi	sp,sp,16
4000eb80:	00008067          	ret
4000eb84:	00058413          	mv	s0,a1
	if (!net_if_ipv4_addr_mask_cmp(iface, addr)) {
4000eb88:	f25ff0ef          	jal	ra,4000eaac <net_if_ipv4_addr_mask_cmp>
4000eb8c:	fe0500e3          	beqz	a0,4000eb6c <ipv4_is_broadcast_address+0x18>
	if ((UNALIGNED_GET(&addr->s_addr) & ~ipv4->netmask.s_addr) ==
4000eb90:	00144703          	lbu	a4,1(s0)
4000eb94:	00044783          	lbu	a5,0(s0)
4000eb98:	00344503          	lbu	a0,3(s0)
4000eb9c:	00871713          	slli	a4,a4,0x8
4000eba0:	00f76733          	or	a4,a4,a5
4000eba4:	00244783          	lbu	a5,2(s0)
4000eba8:	04c4a683          	lw	a3,76(s1)
4000ebac:	01851513          	slli	a0,a0,0x18
4000ebb0:	01079793          	slli	a5,a5,0x10
4000ebb4:	00e7e7b3          	or	a5,a5,a4
4000ebb8:	fff6c693          	not	a3,a3
4000ebbc:	00f56533          	or	a0,a0,a5
4000ebc0:	00d57533          	and	a0,a0,a3
4000ebc4:	40d50533          	sub	a0,a0,a3
4000ebc8:	00153513          	seqz	a0,a0
4000ebcc:	fa5ff06f          	j	4000eb70 <ipv4_is_broadcast_address+0x1c>

4000ebd0 <net_if_ipv4_is_addr_bcast>:
{
4000ebd0:	fe010113          	addi	sp,sp,-32
4000ebd4:	00812c23          	sw	s0,24(sp)
4000ebd8:	00912a23          	sw	s1,20(sp)
4000ebdc:	00050413          	mv	s0,a0
4000ebe0:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
4000ebe4:	fff00513          	li	a0,-1
4000ebe8:	fff00593          	li	a1,-1
{
4000ebec:	00112e23          	sw	ra,28(sp)
4000ebf0:	01212823          	sw	s2,16(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000ebf4:	b54fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (iface) {
4000ebf8:	04040a63          	beqz	s0,4000ec4c <net_if_ipv4_is_addr_bcast+0x7c>
		ret = ipv4_is_broadcast_address(iface, addr);
4000ebfc:	00048593          	mv	a1,s1
4000ec00:	00040513          	mv	a0,s0
4000ec04:	f51ff0ef          	jal	ra,4000eb54 <ipv4_is_broadcast_address>
		goto out;
4000ec08:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000ec0c:	b50fd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000ec10:	01c12083          	lw	ra,28(sp)
4000ec14:	01812403          	lw	s0,24(sp)
4000ec18:	00c12503          	lw	a0,12(sp)
4000ec1c:	01412483          	lw	s1,20(sp)
4000ec20:	01012903          	lw	s2,16(sp)
4000ec24:	02010113          	addi	sp,sp,32
4000ec28:	00008067          	ret
		ret = ipv4_is_broadcast_address(iface, addr);
4000ec2c:	00048593          	mv	a1,s1
4000ec30:	00040513          	mv	a0,s0
4000ec34:	f21ff0ef          	jal	ra,4000eb54 <ipv4_is_broadcast_address>
		if (ret) {
4000ec38:	fc0518e3          	bnez	a0,4000ec08 <net_if_ipv4_is_addr_bcast+0x38>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000ec3c:	00c40413          	addi	s0,s0,12
4000ec40:	ff2466e3          	bltu	s0,s2,4000ec2c <net_if_ipv4_is_addr_bcast+0x5c>
out:
4000ec44:	00000513          	li	a0,0
4000ec48:	fc1ff06f          	j	4000ec08 <net_if_ipv4_is_addr_bcast+0x38>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000ec4c:	4003d437          	lui	s0,0x4003d
4000ec50:	4003d937          	lui	s2,0x4003d
4000ec54:	c3c40413          	addi	s0,s0,-964 # 4003cc3c <__net_if_dts_ord_12_0>
4000ec58:	c4890913          	addi	s2,s2,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000ec5c:	fe5ff06f          	j	4000ec40 <net_if_ipv4_is_addr_bcast+0x70>

4000ec60 <net_if_ipv4_select_src_iface>:
{
4000ec60:	ff010113          	addi	sp,sp,-16
4000ec64:	00812423          	sw	s0,8(sp)
4000ec68:	00912223          	sw	s1,4(sp)
4000ec6c:	01212023          	sw	s2,0(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000ec70:	fff00593          	li	a1,-1
{
4000ec74:	00050913          	mv	s2,a0
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000ec78:	4003d437          	lui	s0,0x4003d
	k_mutex_lock(&lock, K_FOREVER);
4000ec7c:	fff00513          	li	a0,-1
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000ec80:	4003d4b7          	lui	s1,0x4003d
{
4000ec84:	00112623          	sw	ra,12(sp)
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000ec88:	c3c40413          	addi	s0,s0,-964 # 4003cc3c <__net_if_dts_ord_12_0>
	k_mutex_lock(&lock, K_FOREVER);
4000ec8c:	abcfd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000ec90:	c4848493          	addi	s1,s1,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000ec94:	02946663          	bltu	s0,s1,4000ecc0 <net_if_ipv4_select_src_iface+0x60>
		selected = net_if_get_default();
4000ec98:	f25fd0ef          	jal	ra,4000cbbc <net_if_get_default>
4000ec9c:	00050413          	mv	s0,a0
	k_mutex_unlock(&lock);
4000eca0:	abcfd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000eca4:	00c12083          	lw	ra,12(sp)
4000eca8:	00040513          	mv	a0,s0
4000ecac:	00812403          	lw	s0,8(sp)
4000ecb0:	00412483          	lw	s1,4(sp)
4000ecb4:	00012903          	lw	s2,0(sp)
4000ecb8:	01010113          	addi	sp,sp,16
4000ecbc:	00008067          	ret
		ret = net_if_ipv4_addr_mask_cmp(iface, dst);
4000ecc0:	00090593          	mv	a1,s2
4000ecc4:	00040513          	mv	a0,s0
4000ecc8:	de5ff0ef          	jal	ra,4000eaac <net_if_ipv4_addr_mask_cmp>
		if (ret) {
4000eccc:	fc051ae3          	bnez	a0,4000eca0 <net_if_ipv4_select_src_iface+0x40>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000ecd0:	00c40413          	addi	s0,s0,12
4000ecd4:	fc1ff06f          	j	4000ec94 <net_if_ipv4_select_src_iface+0x34>

4000ecd8 <net_if_ipv4_get_ll>:
	return if_ipv4_get_addr(iface, addr_state, true);
4000ecd8:	00100613          	li	a2,1
4000ecdc:	a8cfd06f          	j	4000bf68 <if_ipv4_get_addr>

4000ece0 <net_if_ipv4_get_global_addr>:
	return if_ipv4_get_addr(iface, addr_state, false);
4000ece0:	00000613          	li	a2,0
4000ece4:	a84fd06f          	j	4000bf68 <if_ipv4_get_addr>

4000ece8 <net_if_ipv4_select_src_addr>:
{
4000ece8:	fd010113          	addi	sp,sp,-48
4000ecec:	02912223          	sw	s1,36(sp)
4000ecf0:	01312e23          	sw	s3,28(sp)
4000ecf4:	00050493          	mv	s1,a0
4000ecf8:	00058993          	mv	s3,a1
	k_mutex_lock(&lock, K_FOREVER);
4000ecfc:	fff00513          	li	a0,-1
4000ed00:	fff00593          	li	a1,-1
{
4000ed04:	02112623          	sw	ra,44(sp)
4000ed08:	02812423          	sw	s0,40(sp)
4000ed0c:	03212023          	sw	s2,32(sp)
4000ed10:	01412c23          	sw	s4,24(sp)
	uint8_t best_match = 0U;
4000ed14:	000107a3          	sb	zero,15(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000ed18:	a30fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (!net_ipv4_is_ll_addr(dst)) {
4000ed1c:	00098513          	mv	a0,s3
4000ed20:	f81fc0ef          	jal	ra,4000bca0 <net_ipv4_is_ll_addr>
4000ed24:	08051263          	bnez	a0,4000eda8 <net_if_ipv4_select_src_addr+0xc0>
		if (dst_iface) {
4000ed28:	06048463          	beqz	s1,4000ed90 <net_if_ipv4_select_src_addr+0xa8>
			src = net_if_ipv4_get_best_match(dst_iface, dst,
4000ed2c:	0084a503          	lw	a0,8(s1)
4000ed30:	00f10613          	addi	a2,sp,15
4000ed34:	00098593          	mv	a1,s3
4000ed38:	9b5fd0ef          	jal	ra,4000c6ec <net_if_ipv4_get_best_match.isra.0>
			src = net_if_ipv4_get_ll(dst_iface, NET_ADDR_PREFERRED);
4000ed3c:	00050413          	mv	s0,a0
4000ed40:	0240006f          	j	4000ed64 <net_if_ipv4_select_src_addr+0x7c>
				addr = net_if_ipv4_get_best_match(iface, dst,
4000ed44:	00892503          	lw	a0,8(s2)
4000ed48:	00f10613          	addi	a2,sp,15
4000ed4c:	00098593          	mv	a1,s3
4000ed50:	99dfd0ef          	jal	ra,4000c6ec <net_if_ipv4_get_best_match.isra.0>
				if (addr) {
4000ed54:	00050463          	beqz	a0,4000ed5c <net_if_ipv4_select_src_addr+0x74>
4000ed58:	00050413          	mv	s0,a0
			STRUCT_SECTION_FOREACH(net_if, iface) {
4000ed5c:	00c90913          	addi	s2,s2,12
4000ed60:	ff4962e3          	bltu	s2,s4,4000ed44 <net_if_ipv4_select_src_addr+0x5c>
	if (!src) {
4000ed64:	06040a63          	beqz	s0,4000edd8 <net_if_ipv4_select_src_addr+0xf0>
	k_mutex_unlock(&lock);
4000ed68:	9f4fd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000ed6c:	02c12083          	lw	ra,44(sp)
4000ed70:	00040513          	mv	a0,s0
4000ed74:	02812403          	lw	s0,40(sp)
4000ed78:	02412483          	lw	s1,36(sp)
4000ed7c:	02012903          	lw	s2,32(sp)
4000ed80:	01c12983          	lw	s3,28(sp)
4000ed84:	01812a03          	lw	s4,24(sp)
4000ed88:	03010113          	addi	sp,sp,48
4000ed8c:	00008067          	ret
			STRUCT_SECTION_FOREACH(net_if, iface) {
4000ed90:	4003d937          	lui	s2,0x4003d
4000ed94:	4003da37          	lui	s4,0x4003d
	const struct in_addr *src = NULL;
4000ed98:	00000413          	li	s0,0
			STRUCT_SECTION_FOREACH(net_if, iface) {
4000ed9c:	c3c90913          	addi	s2,s2,-964 # 4003cc3c <__net_if_dts_ord_12_0>
4000eda0:	c48a0a13          	addi	s4,s4,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000eda4:	fbdff06f          	j	4000ed60 <net_if_ipv4_select_src_addr+0x78>
		if (dst_iface) {
4000eda8:	04048863          	beqz	s1,4000edf8 <net_if_ipv4_select_src_addr+0x110>
			src = net_if_ipv4_get_ll(dst_iface, NET_ADDR_PREFERRED);
4000edac:	00100593          	li	a1,1
4000edb0:	00048513          	mv	a0,s1
4000edb4:	f25ff0ef          	jal	ra,4000ecd8 <net_if_ipv4_get_ll>
4000edb8:	f85ff06f          	j	4000ed3c <net_if_ipv4_select_src_addr+0x54>
				addr = net_if_ipv4_get_ll(iface,
4000edbc:	00100593          	li	a1,1
4000edc0:	00090513          	mv	a0,s2
4000edc4:	f15ff0ef          	jal	ra,4000ecd8 <net_if_ipv4_get_ll>
4000edc8:	00050413          	mv	s0,a0
				if (addr) {
4000edcc:	f8051ee3          	bnez	a0,4000ed68 <net_if_ipv4_select_src_addr+0x80>
			STRUCT_SECTION_FOREACH(net_if, iface) {
4000edd0:	00c90913          	addi	s2,s2,12
4000edd4:	ff3964e3          	bltu	s2,s3,4000edbc <net_if_ipv4_select_src_addr+0xd4>
		src = net_if_ipv4_get_global_addr(dst_iface,
4000edd8:	00100593          	li	a1,1
4000eddc:	00048513          	mv	a0,s1
4000ede0:	f01ff0ef          	jal	ra,4000ece0 <net_if_ipv4_get_global_addr>
4000ede4:	00050413          	mv	s0,a0
		if (!src) {
4000ede8:	f80510e3          	bnez	a0,4000ed68 <net_if_ipv4_select_src_addr+0x80>
			src = net_ipv4_unspecified_address();
4000edec:	669010ef          	jal	ra,40010c54 <net_ipv4_unspecified_address>
4000edf0:	00050413          	mv	s0,a0
4000edf4:	f75ff06f          	j	4000ed68 <net_if_ipv4_select_src_addr+0x80>
			STRUCT_SECTION_FOREACH(net_if, iface) {
4000edf8:	4003d937          	lui	s2,0x4003d
4000edfc:	4003d9b7          	lui	s3,0x4003d
4000ee00:	c3c90913          	addi	s2,s2,-964 # 4003cc3c <__net_if_dts_ord_12_0>
4000ee04:	c4898993          	addi	s3,s3,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000ee08:	fcdff06f          	j	4000edd4 <net_if_ipv4_select_src_addr+0xec>

4000ee0c <net_if_ipv4_addr_lookup>:
{
4000ee0c:	fe010113          	addi	sp,sp,-32
4000ee10:	00812c23          	sw	s0,24(sp)
4000ee14:	00912a23          	sw	s1,20(sp)
4000ee18:	00050413          	mv	s0,a0
4000ee1c:	00058493          	mv	s1,a1
	k_mutex_lock(&lock, K_FOREVER);
4000ee20:	fff00513          	li	a0,-1
4000ee24:	fff00593          	li	a1,-1
{
4000ee28:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000ee2c:	91cfd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000ee30:	4003d7b7          	lui	a5,0x4003d
4000ee34:	4003d637          	lui	a2,0x4003d
4000ee38:	c3c78793          	addi	a5,a5,-964 # 4003cc3c <__net_if_dts_ord_12_0>
4000ee3c:	c4860613          	addi	a2,a2,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
			if (!ipv4->unicast[i].is_used ||
4000ee40:	00100593          	li	a1,1
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000ee44:	00c7e663          	bltu	a5,a2,4000ee50 <net_if_ipv4_addr_lookup+0x44>
	struct net_if_addr *ifaddr = NULL;
4000ee48:	00000513          	li	a0,0
4000ee4c:	05c0006f          	j	4000eea8 <net_if_ipv4_addr_lookup+0x9c>
		struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
4000ee50:	0087a503          	lw	a0,8(a5)
		if (!ipv4) {
4000ee54:	06050a63          	beqz	a0,4000eec8 <net_if_ipv4_addr_lookup+0xbc>
			if (!ipv4->unicast[i].is_used ||
4000ee58:	02c52703          	lw	a4,44(a0)
4000ee5c:	01975713          	srli	a4,a4,0x19
4000ee60:	00177713          	andi	a4,a4,1
4000ee64:	06070263          	beqz	a4,4000eec8 <net_if_ipv4_addr_lookup+0xbc>
4000ee68:	00055703          	lhu	a4,0(a0)
4000ee6c:	04b71e63          	bne	a4,a1,4000eec8 <net_if_ipv4_addr_lookup+0xbc>
			if (UNALIGNED_GET(&addr->s4_addr32[0]) ==
4000ee70:	00144703          	lbu	a4,1(s0)
4000ee74:	00044683          	lbu	a3,0(s0)
4000ee78:	00871713          	slli	a4,a4,0x8
4000ee7c:	00d76733          	or	a4,a4,a3
4000ee80:	00244683          	lbu	a3,2(s0)
4000ee84:	01069693          	slli	a3,a3,0x10
4000ee88:	00e6e6b3          	or	a3,a3,a4
4000ee8c:	00344703          	lbu	a4,3(s0)
4000ee90:	01871713          	slli	a4,a4,0x18
4000ee94:	00d76733          	or	a4,a4,a3
4000ee98:	00452683          	lw	a3,4(a0)
4000ee9c:	02e69663          	bne	a3,a4,4000eec8 <net_if_ipv4_addr_lookup+0xbc>
				if (ret) {
4000eea0:	00048463          	beqz	s1,4000eea8 <net_if_ipv4_addr_lookup+0x9c>
					*ret = iface;
4000eea4:	00f4a023          	sw	a5,0(s1)
				goto out;
4000eea8:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000eeac:	8b0fd0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000eeb0:	01c12083          	lw	ra,28(sp)
4000eeb4:	01812403          	lw	s0,24(sp)
4000eeb8:	00c12503          	lw	a0,12(sp)
4000eebc:	01412483          	lw	s1,20(sp)
4000eec0:	02010113          	addi	sp,sp,32
4000eec4:	00008067          	ret
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000eec8:	00c78793          	addi	a5,a5,12
4000eecc:	f79ff06f          	j	4000ee44 <net_if_ipv4_addr_lookup+0x38>

4000eed0 <net_if_ipv4_set_netmask>:
{
4000eed0:	ff010113          	addi	sp,sp,-16
4000eed4:	00812423          	sw	s0,8(sp)
4000eed8:	00912223          	sw	s1,4(sp)
4000eedc:	00058413          	mv	s0,a1
4000eee0:	00050493          	mv	s1,a0
	k_mutex_lock(&lock, K_FOREVER);
4000eee4:	fff00593          	li	a1,-1
4000eee8:	fff00513          	li	a0,-1
{
4000eeec:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000eef0:	858fd0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv4_get(iface, NULL) < 0) {
4000eef4:	00000593          	li	a1,0
4000eef8:	00048513          	mv	a0,s1
4000eefc:	ad9ff0ef          	jal	ra,4000e9d4 <net_if_config_ipv4_get>
4000ef00:	04054863          	bltz	a0,4000ef50 <net_if_ipv4_set_netmask+0x80>
	if (!iface->config.ip.ipv4) {
4000ef04:	0084a683          	lw	a3,8(s1)
4000ef08:	04068463          	beqz	a3,4000ef50 <net_if_ipv4_set_netmask+0x80>
	net_ipaddr_copy(&iface->config.ip.ipv4->netmask, netmask);
4000ef0c:	00144783          	lbu	a5,1(s0)
4000ef10:	00044703          	lbu	a4,0(s0)
4000ef14:	00879793          	slli	a5,a5,0x8
4000ef18:	00e7e7b3          	or	a5,a5,a4
4000ef1c:	00244703          	lbu	a4,2(s0)
4000ef20:	01071713          	slli	a4,a4,0x10
4000ef24:	00f76733          	or	a4,a4,a5
4000ef28:	00344783          	lbu	a5,3(s0)
4000ef2c:	04e68623          	sb	a4,76(a3)
4000ef30:	01879793          	slli	a5,a5,0x18
4000ef34:	00e7e7b3          	or	a5,a5,a4
4000ef38:	0087d713          	srli	a4,a5,0x8
4000ef3c:	04e686a3          	sb	a4,77(a3)
4000ef40:	0107d713          	srli	a4,a5,0x10
4000ef44:	0187d793          	srli	a5,a5,0x18
4000ef48:	04e68723          	sb	a4,78(a3)
4000ef4c:	04f687a3          	sb	a5,79(a3)
}
4000ef50:	00812403          	lw	s0,8(sp)
4000ef54:	00c12083          	lw	ra,12(sp)
4000ef58:	00412483          	lw	s1,4(sp)
4000ef5c:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
4000ef60:	ffdfc06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>

4000ef64 <net_if_ipv4_addr_add>:
{
4000ef64:	fd010113          	addi	sp,sp,-48
4000ef68:	02912223          	sw	s1,36(sp)
4000ef6c:	03212023          	sw	s2,32(sp)
4000ef70:	00058493          	mv	s1,a1
4000ef74:	00050913          	mv	s2,a0
	k_mutex_lock(&lock, K_FOREVER);
4000ef78:	fff00593          	li	a1,-1
4000ef7c:	fff00513          	li	a0,-1
{
4000ef80:	02112623          	sw	ra,44(sp)
4000ef84:	02812423          	sw	s0,40(sp)
4000ef88:	01312e23          	sw	s3,28(sp)
4000ef8c:	01412c23          	sw	s4,24(sp)
4000ef90:	00068993          	mv	s3,a3
4000ef94:	00060a13          	mv	s4,a2
	k_mutex_lock(&lock, K_FOREVER);
4000ef98:	fb1fc0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
4000ef9c:	00c10593          	addi	a1,sp,12
4000efa0:	00090513          	mv	a0,s2
4000efa4:	a31ff0ef          	jal	ra,4000e9d4 <net_if_config_ipv4_get>
	struct net_if_addr *ifaddr = NULL;
4000efa8:	00000413          	li	s0,0
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
4000efac:	0e054863          	bltz	a0,4000f09c <net_if_ipv4_addr_add+0x138>
	ifaddr = ipv4_addr_find(iface, addr);
4000efb0:	00892403          	lw	s0,8(s2)
		if (!ipv4->unicast[i].is_used) {
4000efb4:	02c42783          	lw	a5,44(s0)
4000efb8:	0197d793          	srli	a5,a5,0x19
4000efbc:	0017f793          	andi	a5,a5,1
4000efc0:	04078c63          	beqz	a5,4000f018 <net_if_ipv4_addr_add+0xb4>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4000efc4:	0014c703          	lbu	a4,1(s1)
4000efc8:	0004c783          	lbu	a5,0(s1)
4000efcc:	00444683          	lbu	a3,4(s0)
4000efd0:	00871713          	slli	a4,a4,0x8
4000efd4:	00f76733          	or	a4,a4,a5
4000efd8:	0024c783          	lbu	a5,2(s1)
4000efdc:	01079793          	slli	a5,a5,0x10
4000efe0:	00e7e7b3          	or	a5,a5,a4
4000efe4:	0034c703          	lbu	a4,3(s1)
4000efe8:	01871713          	slli	a4,a4,0x18
4000efec:	00f76733          	or	a4,a4,a5
4000eff0:	00544783          	lbu	a5,5(s0)
4000eff4:	00879793          	slli	a5,a5,0x8
4000eff8:	00d7e7b3          	or	a5,a5,a3
4000effc:	00644683          	lbu	a3,6(s0)
4000f000:	01069693          	slli	a3,a3,0x10
4000f004:	00f6e6b3          	or	a3,a3,a5
4000f008:	00744783          	lbu	a5,7(s0)
4000f00c:	01879793          	slli	a5,a5,0x18
4000f010:	00d7e7b3          	or	a5,a5,a3
		if (net_ipv4_addr_cmp(addr,
4000f014:	08f70463          	beq	a4,a5,4000f09c <net_if_ipv4_addr_add+0x138>
		if (addr_type == NET_ADDR_DHCP
4000f018:	00200793          	li	a5,2
		struct net_if_addr *cur = &ipv4->unicast[i];
4000f01c:	00c12703          	lw	a4,12(sp)
		if (addr_type == NET_ADDR_DHCP
4000f020:	00fa1863          	bne	s4,a5,4000f030 <net_if_ipv4_addr_add+0xcc>
		    && cur->addr_type == NET_ADDR_OVERRIDABLE) {
4000f024:	02c74683          	lbu	a3,44(a4)
4000f028:	00400793          	li	a5,4
4000f02c:	00f68c63          	beq	a3,a5,4000f044 <net_if_ipv4_addr_add+0xe0>
		if (!ipv4->unicast[i].is_used) {
4000f030:	02c72783          	lw	a5,44(a4)
4000f034:	00000413          	li	s0,0
4000f038:	0197d793          	srli	a5,a5,0x19
4000f03c:	0017f793          	andi	a5,a5,1
4000f040:	04079e63          	bnez	a5,4000f09c <net_if_ipv4_addr_add+0x138>
		struct net_if_addr *cur = &ipv4->unicast[i];
4000f044:	00070413          	mv	s0,a4
	if (ifaddr) {
4000f048:	04070a63          	beqz	a4,4000f09c <net_if_ipv4_addr_add+0x138>
		ifaddr->is_used = true;
4000f04c:	02f74783          	lbu	a5,47(a4)
4000f050:	0019b993          	seqz	s3,s3
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ADDR_ADD, iface,
4000f054:	e0040537          	lui	a0,0xe0040
		ifaddr->is_used = true;
4000f058:	0027e793          	ori	a5,a5,2
4000f05c:	02f707a3          	sb	a5,47(a4)
		ifaddr->address.family = AF_INET;
4000f060:	00100793          	li	a5,1
4000f064:	00f71023          	sh	a5,0(a4)
		ifaddr->address.in_addr.s4_addr32[0] =
4000f068:	02f44683          	lbu	a3,47(s0)
						addr->s4_addr32[0];
4000f06c:	0004a703          	lw	a4,0(s1)
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ADDR_ADD, iface,
4000f070:	00440613          	addi	a2,s0,4
4000f074:	ffe6f693          	andi	a3,a3,-2
4000f078:	0136e6b3          	or	a3,a3,s3
4000f07c:	02d407a3          	sb	a3,47(s0)
		ifaddr->address.in_addr.s4_addr32[0] =
4000f080:	00e42223          	sw	a4,4(s0)
		ifaddr->addr_type = addr_type;
4000f084:	03440623          	sb	s4,44(s0)
		ifaddr->addr_state = NET_ADDR_PREFERRED;
4000f088:	02f406a3          	sb	a5,45(s0)
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ADDR_ADD, iface,
4000f08c:	00400693          	li	a3,4
4000f090:	00090593          	mv	a1,s2
4000f094:	00150513          	addi	a0,a0,1 # e0040001 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0040002>
4000f098:	699010ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
	k_mutex_unlock(&lock);
4000f09c:	ec1fc0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000f0a0:	02c12083          	lw	ra,44(sp)
4000f0a4:	00040513          	mv	a0,s0
4000f0a8:	02812403          	lw	s0,40(sp)
4000f0ac:	02412483          	lw	s1,36(sp)
4000f0b0:	02012903          	lw	s2,32(sp)
4000f0b4:	01c12983          	lw	s3,28(sp)
4000f0b8:	01812a03          	lw	s4,24(sp)
4000f0bc:	03010113          	addi	sp,sp,48
4000f0c0:	00008067          	ret

4000f0c4 <net_if_ipv4_addr_rm>:
{
4000f0c4:	ff010113          	addi	sp,sp,-16
4000f0c8:	00912223          	sw	s1,4(sp)
4000f0cc:	01212023          	sw	s2,0(sp)
4000f0d0:	00058493          	mv	s1,a1
4000f0d4:	00050913          	mv	s2,a0
	k_mutex_lock(&lock, K_FOREVER);
4000f0d8:	fff00593          	li	a1,-1
4000f0dc:	fff00513          	li	a0,-1
{
4000f0e0:	00112623          	sw	ra,12(sp)
4000f0e4:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000f0e8:	e61fc0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	ipv4 = iface->config.ip.ipv4;
4000f0ec:	00892603          	lw	a2,8(s2)
	if (!ipv4) {
4000f0f0:	00061663          	bnez	a2,4000f0fc <net_if_ipv4_addr_rm+0x38>
	bool ret = false;
4000f0f4:	00000413          	li	s0,0
4000f0f8:	08c0006f          	j	4000f184 <net_if_ipv4_addr_rm+0xc0>
		if (!ipv4->unicast[i].is_used) {
4000f0fc:	02c62403          	lw	s0,44(a2)
4000f100:	01945413          	srli	s0,s0,0x19
4000f104:	00147413          	andi	s0,s0,1
4000f108:	06040e63          	beqz	s0,4000f184 <net_if_ipv4_addr_rm+0xc0>
4000f10c:	0014c703          	lbu	a4,1(s1)
4000f110:	0004c783          	lbu	a5,0(s1)
4000f114:	00464683          	lbu	a3,4(a2)
4000f118:	00871713          	slli	a4,a4,0x8
4000f11c:	00f76733          	or	a4,a4,a5
4000f120:	0024c783          	lbu	a5,2(s1)
4000f124:	01079793          	slli	a5,a5,0x10
4000f128:	00e7e7b3          	or	a5,a5,a4
4000f12c:	0034c703          	lbu	a4,3(s1)
4000f130:	01871713          	slli	a4,a4,0x18
4000f134:	00f76733          	or	a4,a4,a5
4000f138:	00564783          	lbu	a5,5(a2)
4000f13c:	00879793          	slli	a5,a5,0x8
4000f140:	00d7e7b3          	or	a5,a5,a3
4000f144:	00664683          	lbu	a3,6(a2)
4000f148:	01069693          	slli	a3,a3,0x10
4000f14c:	00f6e6b3          	or	a3,a3,a5
4000f150:	00764783          	lbu	a5,7(a2)
4000f154:	01879793          	slli	a5,a5,0x18
4000f158:	00d7e7b3          	or	a5,a5,a3
		if (!net_ipv4_addr_cmp(&ipv4->unicast[i].address.in_addr,
4000f15c:	f8f71ce3          	bne	a4,a5,4000f0f4 <net_if_ipv4_addr_rm+0x30>
		ipv4->unicast[i].is_used = false;
4000f160:	02f64783          	lbu	a5,47(a2)
		net_mgmt_event_notify_with_info(
4000f164:	e0040537          	lui	a0,0xe0040
4000f168:	00400693          	li	a3,4
		ipv4->unicast[i].is_used = false;
4000f16c:	ffd7f793          	andi	a5,a5,-3
4000f170:	02f607a3          	sb	a5,47(a2)
		net_mgmt_event_notify_with_info(
4000f174:	00090593          	mv	a1,s2
4000f178:	00460613          	addi	a2,a2,4
4000f17c:	00250513          	addi	a0,a0,2 # e0040002 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0040003>
4000f180:	5b1010ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
	k_mutex_unlock(&lock);
4000f184:	dd9fc0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000f188:	00c12083          	lw	ra,12(sp)
4000f18c:	00040513          	mv	a0,s0
4000f190:	00812403          	lw	s0,8(sp)
4000f194:	00412483          	lw	s1,4(sp)
4000f198:	00012903          	lw	s2,0(sp)
4000f19c:	01010113          	addi	sp,sp,16
4000f1a0:	00008067          	ret

4000f1a4 <net_if_ipv4_maddr_lookup>:
{
4000f1a4:	ff010113          	addi	sp,sp,-16
4000f1a8:	00912223          	sw	s1,4(sp)
4000f1ac:	01212023          	sw	s2,0(sp)
4000f1b0:	00050493          	mv	s1,a0
4000f1b4:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
4000f1b8:	fff00513          	li	a0,-1
4000f1bc:	fff00593          	li	a1,-1
{
4000f1c0:	00112623          	sw	ra,12(sp)
4000f1c4:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000f1c8:	d81fc0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000f1cc:	4003d7b7          	lui	a5,0x4003d
4000f1d0:	4003d737          	lui	a4,0x4003d
4000f1d4:	c3c78793          	addi	a5,a5,-964 # 4003cc3c <__net_if_dts_ord_12_0>
4000f1d8:	c4870713          	addi	a4,a4,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000f1dc:	04e7fe63          	bgeu	a5,a4,4000f238 <net_if_ipv4_maddr_lookup+0x94>
		if (ret && *ret && iface != *ret) {
4000f1e0:	04090063          	beqz	s2,4000f220 <net_if_ipv4_maddr_lookup+0x7c>
4000f1e4:	00092683          	lw	a3,0(s2)
4000f1e8:	02068c63          	beqz	a3,4000f220 <net_if_ipv4_maddr_lookup+0x7c>
4000f1ec:	04f69263          	bne	a3,a5,4000f230 <net_if_ipv4_maddr_lookup+0x8c>
		addr = ipv4_maddr_find(iface, true, maddr);
4000f1f0:	0087a403          	lw	s0,8(a5)
	if (!ipv4) {
4000f1f4:	04041663          	bnez	s0,4000f240 <net_if_ipv4_maddr_lookup+0x9c>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000f1f8:	00c78793          	addi	a5,a5,12
4000f1fc:	fee7e4e3          	bltu	a5,a4,4000f1e4 <net_if_ipv4_maddr_lookup+0x40>
	k_mutex_unlock(&lock);
4000f200:	d5dfc0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000f204:	00c12083          	lw	ra,12(sp)
4000f208:	00040513          	mv	a0,s0
4000f20c:	00812403          	lw	s0,8(sp)
4000f210:	00412483          	lw	s1,4(sp)
4000f214:	00012903          	lw	s2,0(sp)
4000f218:	01010113          	addi	sp,sp,16
4000f21c:	00008067          	ret
		addr = ipv4_maddr_find(iface, true, maddr);
4000f220:	0087a403          	lw	s0,8(a5)
	if (!ipv4) {
4000f224:	00041e63          	bnez	s0,4000f240 <net_if_ipv4_maddr_lookup+0x9c>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000f228:	00c78793          	addi	a5,a5,12
4000f22c:	fb1ff06f          	j	4000f1dc <net_if_ipv4_maddr_lookup+0x38>
4000f230:	00c78793          	addi	a5,a5,12
4000f234:	fae7e8e3          	bltu	a5,a4,4000f1e4 <net_if_ipv4_maddr_lookup+0x40>
out:
4000f238:	00000413          	li	s0,0
4000f23c:	fc5ff06f          	j	4000f200 <net_if_ipv4_maddr_lookup+0x5c>
		if ((is_used && !ipv4->mcast[i].is_used) ||
4000f240:	04442683          	lw	a3,68(s0)
4000f244:	0016f693          	andi	a3,a3,1
4000f248:	fe0680e3          	beqz	a3,4000f228 <net_if_ipv4_maddr_lookup+0x84>
		if (addr) {
4000f24c:	04048c63          	beqz	s1,4000f2a4 <net_if_ipv4_maddr_lookup+0x100>
4000f250:	03544603          	lbu	a2,53(s0)
4000f254:	03444683          	lbu	a3,52(s0)
4000f258:	0004c583          	lbu	a1,0(s1)
4000f25c:	00861613          	slli	a2,a2,0x8
4000f260:	00d66633          	or	a2,a2,a3
4000f264:	03644683          	lbu	a3,54(s0)
4000f268:	01069693          	slli	a3,a3,0x10
4000f26c:	00c6e6b3          	or	a3,a3,a2
4000f270:	03744603          	lbu	a2,55(s0)
4000f274:	01861613          	slli	a2,a2,0x18
4000f278:	00d66633          	or	a2,a2,a3
4000f27c:	0014c683          	lbu	a3,1(s1)
4000f280:	00869693          	slli	a3,a3,0x8
4000f284:	00b6e6b3          	or	a3,a3,a1
4000f288:	0024c583          	lbu	a1,2(s1)
4000f28c:	01059593          	slli	a1,a1,0x10
4000f290:	00d5e5b3          	or	a1,a1,a3
4000f294:	0034c683          	lbu	a3,3(s1)
4000f298:	01869693          	slli	a3,a3,0x18
4000f29c:	00b6e6b3          	or	a3,a3,a1
			if (!net_ipv4_addr_cmp(&ipv4->mcast[i].address.in_addr,
4000f2a0:	f8d614e3          	bne	a2,a3,4000f228 <net_if_ipv4_maddr_lookup+0x84>
			if (ret) {
4000f2a4:	00090463          	beqz	s2,4000f2ac <net_if_ipv4_maddr_lookup+0x108>
				*ret = iface;
4000f2a8:	00f92023          	sw	a5,0(s2)
		return &ipv4->mcast[i];
4000f2ac:	03040413          	addi	s0,s0,48
4000f2b0:	f51ff06f          	j	4000f200 <net_if_ipv4_maddr_lookup+0x5c>

4000f2b4 <net_if_recv_data>:
{
4000f2b4:	fe010113          	addi	sp,sp,-32
4000f2b8:	00812c23          	sw	s0,24(sp)
4000f2bc:	00112e23          	sw	ra,28(sp)
4000f2c0:	00050413          	mv	s0,a0
4000f2c4:	00b12623          	sw	a1,12(sp)
	return net_if_l2(iface)->recv(iface, pkt);
4000f2c8:	a49fc0ef          	jal	ra,4000bd10 <net_if_l2>
4000f2cc:	00052783          	lw	a5,0(a0)
4000f2d0:	00040513          	mv	a0,s0
}
4000f2d4:	01812403          	lw	s0,24(sp)
	return net_if_l2(iface)->recv(iface, pkt);
4000f2d8:	00c12583          	lw	a1,12(sp)
}
4000f2dc:	01c12083          	lw	ra,28(sp)
4000f2e0:	02010113          	addi	sp,sp,32
	return net_if_l2(iface)->recv(iface, pkt);
4000f2e4:	00078067          	jr	a5

4000f2e8 <net_if_call_link_cb>:
{
4000f2e8:	fe010113          	addi	sp,sp,-32
4000f2ec:	00912a23          	sw	s1,20(sp)
4000f2f0:	01212823          	sw	s2,16(sp)
4000f2f4:	00050493          	mv	s1,a0
4000f2f8:	00058913          	mv	s2,a1
	k_mutex_lock(&lock, K_FOREVER);
4000f2fc:	fff00513          	li	a0,-1
4000f300:	fff00593          	li	a1,-1
{
4000f304:	01312623          	sw	s3,12(sp)
4000f308:	00112e23          	sw	ra,28(sp)
4000f30c:	00812c23          	sw	s0,24(sp)
4000f310:	00060993          	mv	s3,a2
	k_mutex_lock(&lock, K_FOREVER);
4000f314:	c35fc0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4000f318:	400317b7          	lui	a5,0x40031
4000f31c:	a3c7a783          	lw	a5,-1476(a5) # 40030a3c <link_callbacks>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
4000f320:	00078663          	beqz	a5,4000f32c <net_if_call_link_cb+0x44>
	return node->next;
4000f324:	0007a403          	lw	s0,0(a5)
4000f328:	02079063          	bnez	a5,4000f348 <net_if_call_link_cb+0x60>
}
4000f32c:	01812403          	lw	s0,24(sp)
4000f330:	01c12083          	lw	ra,28(sp)
4000f334:	01412483          	lw	s1,20(sp)
4000f338:	01012903          	lw	s2,16(sp)
4000f33c:	00c12983          	lw	s3,12(sp)
4000f340:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
4000f344:	c19fc06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>
		link->cb(iface, lladdr, status);
4000f348:	0047a783          	lw	a5,4(a5)
4000f34c:	00098613          	mv	a2,s3
4000f350:	00090593          	mv	a1,s2
4000f354:	00048513          	mv	a0,s1
4000f358:	000780e7          	jalr	a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
4000f35c:	00000713          	li	a4,0
4000f360:	00040463          	beqz	s0,4000f368 <net_if_call_link_cb+0x80>
4000f364:	00042703          	lw	a4,0(s0)
4000f368:	00040793          	mv	a5,s0
4000f36c:	00070413          	mv	s0,a4
4000f370:	fb9ff06f          	j	4000f328 <net_if_call_link_cb+0x40>

4000f374 <net_if_tx.isra.0>:
static bool net_if_tx(struct net_if *iface, struct net_pkt *pkt)
4000f374:	fd010113          	addi	sp,sp,-48
4000f378:	02112623          	sw	ra,44(sp)
4000f37c:	02812423          	sw	s0,40(sp)
4000f380:	02912223          	sw	s1,36(sp)
4000f384:	03212023          	sw	s2,32(sp)
4000f388:	01312e23          	sw	s3,28(sp)
	struct net_linkaddr ll_dst = {
4000f38c:	00012023          	sw	zero,0(sp)
4000f390:	00012223          	sw	zero,4(sp)
	if (!pkt) {
4000f394:	0c058663          	beqz	a1,4000f460 <net_if_tx.isra.0+0xec>
	if (!sys_slist_is_empty(&link_callbacks)) {
4000f398:	400317b7          	lui	a5,0x40031
4000f39c:	a3c7a783          	lw	a5,-1476(a5) # 40030a3c <link_callbacks>
4000f3a0:	00050493          	mv	s1,a0
4000f3a4:	00058413          	mv	s0,a1
4000f3a8:	02078e63          	beqz	a5,4000f3e4 <net_if_tx.isra.0+0x70>
		if (net_linkaddr_set(&ll_dst_storage,
4000f3ac:	02c5a583          	lw	a1,44(a1)
4000f3b0:	03044603          	lbu	a2,48(s0)
 * This value should always be <= NET_LINK_ADDR_MAX_LENGTH.
 */
static inline int net_linkaddr_set(struct net_linkaddr_storage *lladdr_store,
				   uint8_t *new_addr, uint8_t new_len)
{
	if (!lladdr_store || !new_addr) {
4000f3b4:	02058863          	beqz	a1,4000f3e4 <net_if_tx.isra.0+0x70>
		return -EINVAL;
	}

	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
4000f3b8:	00600793          	li	a5,6
4000f3bc:	02c7e463          	bltu	a5,a2,4000f3e4 <net_if_tx.isra.0+0x70>
		return -EMSGSIZE;
	}

	lladdr_store->len = new_len;
	memcpy(lladdr_store->addr, new_addr, new_len);
4000f3c0:	00a10913          	addi	s2,sp,10
4000f3c4:	00090513          	mv	a0,s2
	lladdr_store->len = new_len;
4000f3c8:	00c104a3          	sb	a2,9(sp)
	memcpy(lladdr_store->addr, new_addr, new_len);
4000f3cc:	c81f90ef          	jal	ra,4000904c <memcpy>
			ll_dst.len = ll_dst_storage.len;
4000f3d0:	00914783          	lbu	a5,9(sp)
			ll_dst.addr = ll_dst_storage.addr;
4000f3d4:	01212023          	sw	s2,0(sp)
			ll_dst.len = ll_dst_storage.len;
4000f3d8:	00f10223          	sb	a5,4(sp)
			ll_dst.type = net_pkt_lladdr_dst(pkt)->type;
4000f3dc:	03144783          	lbu	a5,49(s0)
4000f3e0:	00f102a3          	sb	a5,5(sp)
	if (net_if_flag_is_set(iface, NET_IF_LOWER_UP)) {
4000f3e4:	00900593          	li	a1,9
4000f3e8:	00048513          	mv	a0,s1
	return pkt->context;
4000f3ec:	01442983          	lw	s3,20(s0)
4000f3f0:	a08fd0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
4000f3f4:	08050463          	beqz	a0,4000f47c <net_if_tx.isra.0+0x108>
	return pkt->family;
4000f3f8:	03442783          	lw	a5,52(s0)
		if (IS_ENABLED(CONFIG_NET_TCP) &&
4000f3fc:	01d7d793          	srli	a5,a5,0x1d
4000f400:	00078863          	beqz	a5,4000f410 <net_if_tx.isra.0+0x9c>
	pkt->pkt_queued = send;
4000f404:	03744783          	lbu	a5,55(s0)
4000f408:	ffb7f793          	andi	a5,a5,-5
4000f40c:	02f40ba3          	sb	a5,55(s0)
		status = net_if_l2(iface)->send(iface, pkt);
4000f410:	00048513          	mv	a0,s1
4000f414:	8fdfc0ef          	jal	ra,4000bd10 <net_if_l2>
4000f418:	00452783          	lw	a5,4(a0)
4000f41c:	00040593          	mv	a1,s0
4000f420:	00048513          	mv	a0,s1
4000f424:	000780e7          	jalr	a5
4000f428:	00050913          	mv	s2,a0
	if (status < 0) {
4000f42c:	00055663          	bgez	a0,4000f438 <net_if_tx.isra.0+0xc4>
		net_pkt_unref(pkt);
4000f430:	00040513          	mv	a0,s0
4000f434:	2e9030ef          	jal	ra,40012f1c <net_pkt_unref>
	if (context) {
4000f438:	00098863          	beqz	s3,4000f448 <net_if_tx.isra.0+0xd4>
		net_context_send_cb(context, status);
4000f43c:	00090593          	mv	a1,s2
4000f440:	00098513          	mv	a0,s3
4000f444:	8e1fc0ef          	jal	ra,4000bd24 <net_context_send_cb>
	if (ll_dst.addr) {
4000f448:	00012783          	lw	a5,0(sp)
4000f44c:	00078a63          	beqz	a5,4000f460 <net_if_tx.isra.0+0xec>
		net_if_call_link_cb(iface, &ll_dst, status);
4000f450:	00090613          	mv	a2,s2
4000f454:	00010593          	mv	a1,sp
4000f458:	00048513          	mv	a0,s1
4000f45c:	e8dff0ef          	jal	ra,4000f2e8 <net_if_call_link_cb>
}
4000f460:	02c12083          	lw	ra,44(sp)
4000f464:	02812403          	lw	s0,40(sp)
4000f468:	02412483          	lw	s1,36(sp)
4000f46c:	02012903          	lw	s2,32(sp)
4000f470:	01c12983          	lw	s3,28(sp)
4000f474:	03010113          	addi	sp,sp,48
4000f478:	00008067          	ret
		status = -ENETDOWN;
4000f47c:	f8d00913          	li	s2,-115
4000f480:	fb1ff06f          	j	4000f430 <net_if_tx.isra.0+0xbc>

4000f484 <net_if_queue_tx>:
{
4000f484:	fe010113          	addi	sp,sp,-32
4000f488:	00112e23          	sw	ra,28(sp)
	uint8_t tc = net_tx_priority2tc(prio);
4000f48c:	0415c503          	lbu	a0,65(a1)
4000f490:	00b12623          	sw	a1,12(sp)
4000f494:	3cd040ef          	jal	ra,40014060 <net_tx_priority2tc>
		net_if_tx(net_pkt_iface(pkt), pkt);
4000f498:	00c12583          	lw	a1,12(sp)
}
4000f49c:	01c12083          	lw	ra,28(sp)
		net_if_tx(net_pkt_iface(pkt), pkt);
4000f4a0:	0185a503          	lw	a0,24(a1)
}
4000f4a4:	02010113          	addi	sp,sp,32
		net_if_tx(net_pkt_iface(pkt), pkt);
4000f4a8:	ecdff06f          	j	4000f374 <net_if_tx.isra.0>

4000f4ac <net_if_send_data>:
{
4000f4ac:	fd010113          	addi	sp,sp,-48
4000f4b0:	02812423          	sw	s0,40(sp)
4000f4b4:	02912223          	sw	s1,36(sp)
4000f4b8:	02112623          	sw	ra,44(sp)
4000f4bc:	03212023          	sw	s2,32(sp)
4000f4c0:	01312e23          	sw	s3,28(sp)
	return pkt->context;
4000f4c4:	0145a983          	lw	s3,20(a1)
4000f4c8:	00050493          	mv	s1,a0
4000f4cc:	00058413          	mv	s0,a1
	k_mutex_lock(&lock, K_FOREVER);
4000f4d0:	fff00513          	li	a0,-1
4000f4d4:	fff00593          	li	a1,-1
4000f4d8:	a71fc0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	if (!net_if_flag_is_set(iface, NET_IF_LOWER_UP) ||
4000f4dc:	00900593          	li	a1,9
4000f4e0:	00048513          	mv	a0,s1
4000f4e4:	914fd0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
4000f4e8:	02051863          	bnez	a0,4000f518 <net_if_send_data+0x6c>
		status = -ENETDOWN;
4000f4ec:	f8d00613          	li	a2,-115
		if (context) {
4000f4f0:	00098c63          	beqz	s3,4000f508 <net_if_send_data+0x5c>
			net_context_send_cb(context, status);
4000f4f4:	00060593          	mv	a1,a2
4000f4f8:	00098513          	mv	a0,s3
4000f4fc:	00c12623          	sw	a2,12(sp)
4000f500:	825fc0ef          	jal	ra,4000bd24 <net_context_send_cb>
4000f504:	00c12603          	lw	a2,12(sp)
		if (dst->addr) {
4000f508:	02c42783          	lw	a5,44(s0)
4000f50c:	0a079663          	bnez	a5,4000f5b8 <net_if_send_data+0x10c>
		status = -ENETDOWN;
4000f510:	00200513          	li	a0,2
4000f514:	0680006f          	j	4000f57c <net_if_send_data+0xd0>
	    net_if_flag_is_set(iface, NET_IF_SUSPENDED)) {
4000f518:	00400593          	li	a1,4
4000f51c:	00048513          	mv	a0,s1
4000f520:	8d8fd0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
	if (!net_if_flag_is_set(iface, NET_IF_LOWER_UP) ||
4000f524:	fc0514e3          	bnez	a0,4000f4ec <net_if_send_data+0x40>
	if (!net_if_flag_is_set(iface, NET_IF_POINTOPOINT) &&
4000f528:	00100593          	li	a1,1
4000f52c:	00048513          	mv	a0,s1
4000f530:	8c8fd0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
4000f534:	02051463          	bnez	a0,4000f55c <net_if_send_data+0xb0>
4000f538:	02442783          	lw	a5,36(s0)
4000f53c:	02079063          	bnez	a5,4000f55c <net_if_send_data+0xb0>
	return net_if_get_link_addr(pkt->iface);
4000f540:	01842783          	lw	a5,24(s0)
		net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
4000f544:	0007a703          	lw	a4,0(a5)
4000f548:	01072703          	lw	a4,16(a4)
4000f54c:	02e42223          	sw	a4,36(s0)
		net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
4000f550:	0007a783          	lw	a5,0(a5)
4000f554:	0147c783          	lbu	a5,20(a5)
4000f558:	02f40423          	sb	a5,40(s0)
	return pkt->family;
4000f55c:	03442903          	lw	s2,52(s0)
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
4000f560:	00200793          	li	a5,2
4000f564:	01d95913          	srli	s2,s2,0x1d
4000f568:	02f90e63          	beq	s2,a5,4000f5a4 <net_if_send_data+0xf8>
		net_if_queue_tx(iface, pkt);
4000f56c:	00048513          	mv	a0,s1
4000f570:	00040593          	mv	a1,s0
4000f574:	f11ff0ef          	jal	ra,4000f484 <net_if_queue_tx>
4000f578:	00000513          	li	a0,0
4000f57c:	00a12623          	sw	a0,12(sp)
	k_mutex_unlock(&lock);
4000f580:	9ddfc0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>
}
4000f584:	02c12083          	lw	ra,44(sp)
4000f588:	02812403          	lw	s0,40(sp)
4000f58c:	00c12503          	lw	a0,12(sp)
4000f590:	02412483          	lw	s1,36(sp)
4000f594:	02012903          	lw	s2,32(sp)
4000f598:	01c12983          	lw	s3,28(sp)
4000f59c:	03010113          	addi	sp,sp,48
4000f5a0:	00008067          	ret
		verdict = net_ipv6_prepare_for_send(pkt);
4000f5a4:	00040513          	mv	a0,s0
4000f5a8:	599090ef          	jal	ra,40019340 <net_ipv6_prepare_for_send>
	if (verdict == NET_DROP) {
4000f5ac:	01251e63          	bne	a0,s2,4000f5c8 <net_if_send_data+0x11c>
	int status = -EIO;
4000f5b0:	ffb00613          	li	a2,-5
4000f5b4:	f3dff06f          	j	4000f4f0 <net_if_send_data+0x44>
			net_if_call_link_cb(iface, dst, status);
4000f5b8:	02c40593          	addi	a1,s0,44
4000f5bc:	00048513          	mv	a0,s1
4000f5c0:	d29ff0ef          	jal	ra,4000f2e8 <net_if_call_link_cb>
4000f5c4:	f4dff06f          	j	4000f510 <net_if_send_data+0x64>
	} else if (verdict == NET_OK) {
4000f5c8:	fa051ae3          	bnez	a0,4000f57c <net_if_send_data+0xd0>
4000f5cc:	fa1ff06f          	j	4000f56c <net_if_send_data+0xc0>

4000f5d0 <net_if_need_calc_tx_checksum>:
	return need_calc_checksum(iface, ETHERNET_HW_TX_CHKSUM_OFFLOAD);
4000f5d0:	00100593          	li	a1,1
4000f5d4:	b04fd06f          	j	4000c8d8 <need_calc_checksum>

4000f5d8 <net_if_need_calc_rx_checksum>:
	return need_calc_checksum(iface, ETHERNET_HW_RX_CHKSUM_OFFLOAD);
4000f5d8:	00200593          	li	a1,2
4000f5dc:	afcfd06f          	j	4000c8d8 <need_calc_checksum>

4000f5e0 <net_if_get_by_iface>:
	if (!(iface >= _net_if_list_start && iface < _net_if_list_end)) {
4000f5e0:	4003d737          	lui	a4,0x4003d
4000f5e4:	c3c70713          	addi	a4,a4,-964 # 4003cc3c <__net_if_dts_ord_12_0>
{
4000f5e8:	00050793          	mv	a5,a0
	if (!(iface >= _net_if_list_start && iface < _net_if_list_end)) {
4000f5ec:	02e56863          	bltu	a0,a4,4000f61c <net_if_get_by_iface+0x3c>
4000f5f0:	4003d6b7          	lui	a3,0x4003d
4000f5f4:	c4868693          	addi	a3,a3,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
		return -1;
4000f5f8:	fff00513          	li	a0,-1
	if (!(iface >= _net_if_list_start && iface < _net_if_list_end)) {
4000f5fc:	02d7f263          	bgeu	a5,a3,4000f620 <net_if_get_by_iface+0x40>
	return (iface - _net_if_list_start) + 1;
4000f600:	40e78533          	sub	a0,a5,a4
4000f604:	aaaab7b7          	lui	a5,0xaaaab
4000f608:	aab78793          	addi	a5,a5,-1365 # aaaaaaab <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xaaaaaaac>
4000f60c:	40255513          	srai	a0,a0,0x2
4000f610:	02f50533          	mul	a0,a0,a5
4000f614:	00150513          	addi	a0,a0,1
4000f618:	00008067          	ret
		return -1;
4000f61c:	fff00513          	li	a0,-1
}
4000f620:	00008067          	ret

4000f624 <net_if_foreach>:
{
4000f624:	fe010113          	addi	sp,sp,-32
4000f628:	00812c23          	sw	s0,24(sp)
4000f62c:	00912a23          	sw	s1,20(sp)
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000f630:	4003d437          	lui	s0,0x4003d
4000f634:	4003d4b7          	lui	s1,0x4003d
{
4000f638:	01212823          	sw	s2,16(sp)
4000f63c:	01312623          	sw	s3,12(sp)
4000f640:	00112e23          	sw	ra,28(sp)
4000f644:	00050913          	mv	s2,a0
4000f648:	00058993          	mv	s3,a1
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000f64c:	c3c40413          	addi	s0,s0,-964 # 4003cc3c <__net_if_dts_ord_12_0>
4000f650:	c4848493          	addi	s1,s1,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000f654:	02946063          	bltu	s0,s1,4000f674 <net_if_foreach+0x50>
}
4000f658:	01c12083          	lw	ra,28(sp)
4000f65c:	01812403          	lw	s0,24(sp)
4000f660:	01412483          	lw	s1,20(sp)
4000f664:	01012903          	lw	s2,16(sp)
4000f668:	00c12983          	lw	s3,12(sp)
4000f66c:	02010113          	addi	sp,sp,32
4000f670:	00008067          	ret
		cb(iface, user_data);
4000f674:	00040513          	mv	a0,s0
4000f678:	00098593          	mv	a1,s3
4000f67c:	000900e7          	jalr	s2
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000f680:	00c40413          	addi	s0,s0,12
4000f684:	fd1ff06f          	j	4000f654 <net_if_foreach+0x30>

4000f688 <net_if_up>:
	return;
#endif
}

int net_if_up(struct net_if *iface)
{
4000f688:	ff010113          	addi	sp,sp,-16
4000f68c:	00812423          	sw	s0,8(sp)
	int status = 0;

	NET_DBG("iface %p", iface);

	k_mutex_lock(&lock, K_FOREVER);
4000f690:	fff00593          	li	a1,-1
{
4000f694:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000f698:	fff00513          	li	a0,-1
{
4000f69c:	00112623          	sw	ra,12(sp)
4000f6a0:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000f6a4:	8a5fc0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>

	if (net_if_flag_is_set(iface, NET_IF_UP)) {
4000f6a8:	00000593          	li	a1,0
4000f6ac:	00040513          	mv	a0,s0
4000f6b0:	f49fc0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
		status = -EALREADY;
4000f6b4:	f8800493          	li	s1,-120
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
4000f6b8:	02051663          	bnez	a0,4000f6e4 <net_if_up+0x5c>
		goto out;
	}

	/* If the L2 does not support enable just set the flag */
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
4000f6bc:	00040513          	mv	a0,s0
4000f6c0:	e50fc0ef          	jal	ra,4000bd10 <net_if_l2>
4000f6c4:	02050e63          	beqz	a0,4000f700 <net_if_up+0x78>
4000f6c8:	00852783          	lw	a5,8(a0)
4000f6cc:	02078a63          	beqz	a5,4000f700 <net_if_up+0x78>
		goto done;
	}

	/* Notify L2 to enable the interface */
	status = net_if_l2(iface)->enable(iface, true);
4000f6d0:	00100593          	li	a1,1
4000f6d4:	00040513          	mv	a0,s0
4000f6d8:	000780e7          	jalr	a5
4000f6dc:	00050493          	mv	s1,a0
	if (status < 0) {
4000f6e0:	02055263          	bgez	a0,4000f704 <net_if_up+0x7c>
	net_if_flag_set(iface, NET_IF_UP);
	net_mgmt_event_notify(NET_EVENT_IF_ADMIN_UP, iface);
	update_operational_state(iface);

out:
	k_mutex_unlock(&lock);
4000f6e4:	879fc0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>

	return status;
}
4000f6e8:	00c12083          	lw	ra,12(sp)
4000f6ec:	00812403          	lw	s0,8(sp)
4000f6f0:	00048513          	mv	a0,s1
4000f6f4:	00412483          	lw	s1,4(sp)
4000f6f8:	01010113          	addi	sp,sp,16
4000f6fc:	00008067          	ret
	int status = 0;
4000f700:	00000493          	li	s1,0
	net_if_flag_set(iface, NET_IF_UP);
4000f704:	00042503          	lw	a0,0(s0)
4000f708:	00000593          	li	a1,0
4000f70c:	a38fd0ef          	jal	ra,4000c944 <net_if_flag_set.isra.0>
4000f710:	d0010537          	lui	a0,0xd0010
4000f714:	00000693          	li	a3,0
4000f718:	00000613          	li	a2,0
4000f71c:	00040593          	mv	a1,s0
4000f720:	00450513          	addi	a0,a0,4 # d0010004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd0010005>
4000f724:	00d010ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
	update_operational_state(iface);
4000f728:	00040513          	mv	a0,s0
4000f72c:	800fe0ef          	jal	ra,4000d72c <update_operational_state>
4000f730:	fb5ff06f          	j	4000f6e4 <net_if_up+0x5c>

4000f734 <net_if_down>:

int net_if_down(struct net_if *iface)
{
4000f734:	ff010113          	addi	sp,sp,-16
4000f738:	00812423          	sw	s0,8(sp)
	int status = 0;

	NET_DBG("iface %p", iface);

	k_mutex_lock(&lock, K_FOREVER);
4000f73c:	fff00593          	li	a1,-1
{
4000f740:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000f744:	fff00513          	li	a0,-1
{
4000f748:	00112623          	sw	ra,12(sp)
4000f74c:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000f750:	ff8fc0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>

	if (!net_if_flag_is_set(iface, NET_IF_UP)) {
4000f754:	00000593          	li	a1,0
4000f758:	00040513          	mv	a0,s0
4000f75c:	e9dfc0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
		status = -EALREADY;
4000f760:	f8800493          	li	s1,-120
	if (!net_if_flag_is_set(iface, NET_IF_UP)) {
4000f764:	06050e63          	beqz	a0,4000f7e0 <net_if_down+0xac>
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
4000f768:	00442483          	lw	s1,4(s0)
	if (!ipv6) {
4000f76c:	04048663          	beqz	s1,4000f7b8 <net_if_down+0x84>
		if (!ipv6->mcast[i].is_used ||
4000f770:	0a44a783          	lw	a5,164(s1)
4000f774:	0017f713          	andi	a4,a5,1
4000f778:	00070e63          	beqz	a4,4000f794 <net_if_down+0x60>
		    !ipv6->mcast[i].is_joined) {
4000f77c:	0017d793          	srli	a5,a5,0x1
		if (!ipv6->mcast[i].is_used ||
4000f780:	0017f793          	andi	a5,a5,1
4000f784:	00078863          	beqz	a5,4000f794 <net_if_down+0x60>
		net_ipv6_mld_leave(iface, &ipv6->mcast[i].address.in6_addr);
4000f788:	09448593          	addi	a1,s1,148
4000f78c:	00040513          	mv	a0,s0
4000f790:	7500a0ef          	jal	ra,40019ee0 <net_ipv6_mld_leave>
		if (!ipv6->mcast[i].is_used ||
4000f794:	0bc4a783          	lw	a5,188(s1)
4000f798:	0017f713          	andi	a4,a5,1
4000f79c:	00070e63          	beqz	a4,4000f7b8 <net_if_down+0x84>
		    !ipv6->mcast[i].is_joined) {
4000f7a0:	0017d793          	srli	a5,a5,0x1
		if (!ipv6->mcast[i].is_used ||
4000f7a4:	0017f793          	andi	a5,a5,1
4000f7a8:	00078863          	beqz	a5,4000f7b8 <net_if_down+0x84>
		net_ipv6_mld_leave(iface, &ipv6->mcast[i].address.in6_addr);
4000f7ac:	0ac48593          	addi	a1,s1,172
4000f7b0:	00040513          	mv	a0,s0
4000f7b4:	72c0a0ef          	jal	ra,40019ee0 <net_ipv6_mld_leave>

	leave_mcast_all(iface);
	leave_ipv4_mcast_all(iface);

	/* If the L2 does not support enable just clear the flag */
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
4000f7b8:	00040513          	mv	a0,s0
4000f7bc:	d54fc0ef          	jal	ra,4000bd10 <net_if_l2>
4000f7c0:	02050e63          	beqz	a0,4000f7fc <net_if_down+0xc8>
4000f7c4:	00852783          	lw	a5,8(a0)
4000f7c8:	02078a63          	beqz	a5,4000f7fc <net_if_down+0xc8>
		goto done;
	}

	/* Notify L2 to disable the interface */
	status = net_if_l2(iface)->enable(iface, false);
4000f7cc:	00000593          	li	a1,0
4000f7d0:	00040513          	mv	a0,s0
4000f7d4:	000780e7          	jalr	a5
4000f7d8:	00050493          	mv	s1,a0
	if (status < 0) {
4000f7dc:	02055263          	bgez	a0,4000f800 <net_if_down+0xcc>
	net_if_flag_clear(iface, NET_IF_UP);
	net_mgmt_event_notify(NET_EVENT_IF_ADMIN_DOWN, iface);
	update_operational_state(iface);

out:
	k_mutex_unlock(&lock);
4000f7e0:	f7cfc0ef          	jal	ra,4000bf5c <k_mutex_unlock.constprop.0.isra.0>

	return status;
}
4000f7e4:	00c12083          	lw	ra,12(sp)
4000f7e8:	00812403          	lw	s0,8(sp)
4000f7ec:	00048513          	mv	a0,s1
4000f7f0:	00412483          	lw	s1,4(sp)
4000f7f4:	01010113          	addi	sp,sp,16
4000f7f8:	00008067          	ret
	int status = 0;
4000f7fc:	00000493          	li	s1,0
	atomic_clear_bit(iface->if_dev->flags, value);
4000f800:	00042503          	lw	a0,0(s0)
4000f804:	00000593          	li	a1,0
4000f808:	00c50513          	addi	a0,a0,12
4000f80c:	ed8fc0ef          	jal	ra,4000bee4 <atomic_clear_bit>
4000f810:	d0010537          	lui	a0,0xd0010
4000f814:	00000693          	li	a3,0
4000f818:	00000613          	li	a2,0
4000f81c:	00040593          	mv	a1,s0
4000f820:	00350513          	addi	a0,a0,3 # d0010003 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd0010004>
4000f824:	70c010ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
	update_operational_state(iface);
4000f828:	00040513          	mv	a0,s0
4000f82c:	f01fd0ef          	jal	ra,4000d72c <update_operational_state>
4000f830:	fb1ff06f          	j	4000f7e0 <net_if_down+0xac>

4000f834 <net_if_carrier_on>:

void net_if_carrier_on(struct net_if *iface)
{
4000f834:	ff010113          	addi	sp,sp,-16
4000f838:	00812423          	sw	s0,8(sp)
	NET_ASSERT(iface);

	k_mutex_lock(&lock, K_FOREVER);
4000f83c:	fff00593          	li	a1,-1
{
4000f840:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000f844:	fff00513          	li	a0,-1
{
4000f848:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000f84c:	efcfc0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>

	if (!net_if_flag_test_and_set(iface, NET_IF_LOWER_UP)) {
4000f850:	00042503          	lw	a0,0(s0)
4000f854:	00900593          	li	a1,9
4000f858:	8fcfd0ef          	jal	ra,4000c954 <net_if_flag_test_and_set.isra.0>
4000f85c:	00051663          	bnez	a0,4000f868 <net_if_carrier_on+0x34>
		update_operational_state(iface);
4000f860:	00040513          	mv	a0,s0
4000f864:	ec9fd0ef          	jal	ra,4000d72c <update_operational_state>
	}

	k_mutex_unlock(&lock);
}
4000f868:	00812403          	lw	s0,8(sp)
4000f86c:	00c12083          	lw	ra,12(sp)
4000f870:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
4000f874:	ee8fc06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>

4000f878 <net_if_carrier_off>:

void net_if_carrier_off(struct net_if *iface)
{
4000f878:	ff010113          	addi	sp,sp,-16
4000f87c:	00812423          	sw	s0,8(sp)
	NET_ASSERT(iface);

	k_mutex_lock(&lock, K_FOREVER);
4000f880:	fff00593          	li	a1,-1
{
4000f884:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4000f888:	fff00513          	li	a0,-1
{
4000f88c:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&lock, K_FOREVER);
4000f890:	eb8fc0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	return atomic_test_and_clear_bit(iface->if_dev->flags, value);
4000f894:	00042503          	lw	a0,0(s0)
4000f898:	00900593          	li	a1,9
4000f89c:	00c50513          	addi	a0,a0,12
4000f8a0:	8ecfd0ef          	jal	ra,4000c98c <atomic_test_and_clear_bit>

	if (net_if_flag_test_and_clear(iface, NET_IF_LOWER_UP)) {
4000f8a4:	00050663          	beqz	a0,4000f8b0 <net_if_carrier_off+0x38>
		update_operational_state(iface);
4000f8a8:	00040513          	mv	a0,s0
4000f8ac:	e81fd0ef          	jal	ra,4000d72c <update_operational_state>
	}

	k_mutex_unlock(&lock);
}
4000f8b0:	00812403          	lw	s0,8(sp)
4000f8b4:	00c12083          	lw	ra,12(sp)
4000f8b8:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&lock);
4000f8bc:	ea0fc06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>

4000f8c0 <net_if_init>:
	k_fifo_put(&tx_ts_queue, pkt);
}
#endif /* CONFIG_NET_PKT_TIMESTAMP_THREAD */

void net_if_init(void)
{
4000f8c0:	fe010113          	addi	sp,sp,-32
4000f8c4:	00812c23          	sw	s0,24(sp)
4000f8c8:	01212823          	sw	s2,16(sp)
	int if_count = 0;

	NET_DBG("");

	k_mutex_lock(&lock, K_FOREVER);
4000f8cc:	fff00513          	li	a0,-1
4000f8d0:	fff00593          	li	a1,-1

	net_tc_tx_init();

	STRUCT_SECTION_FOREACH(net_if, iface) {
4000f8d4:	4003d437          	lui	s0,0x4003d
4000f8d8:	4003d937          	lui	s2,0x4003d
{
4000f8dc:	00112e23          	sw	ra,28(sp)
4000f8e0:	00912a23          	sw	s1,20(sp)
4000f8e4:	01312623          	sw	s3,12(sp)
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000f8e8:	c3c40413          	addi	s0,s0,-964 # 4003cc3c <__net_if_dts_ord_12_0>
	k_mutex_lock(&lock, K_FOREVER);
4000f8ec:	e5cfc0ef          	jal	ra,4000bf48 <k_mutex_lock.constprop.0.isra.0>
	int if_count = 0;
4000f8f0:	00000493          	li	s1,0
	net_tc_tx_init();
4000f8f4:	794040ef          	jal	ra,40014088 <net_tc_tx_init>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000f8f8:	c4890913          	addi	s2,s2,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000f8fc:	0f246463          	bltu	s0,s2,4000f9e4 <net_if_init+0x124>
		init_iface(iface);
		if_count++;
	}

	if (if_count == 0) {
4000f900:	0c048463          	beqz	s1,4000f9c8 <net_if_init+0x108>
	k_work_init_delayable(&dad_timer, dad_timeout);
4000f904:	4000d5b7          	lui	a1,0x4000d
4000f908:	40031537          	lui	a0,0x40031
4000f90c:	03458593          	addi	a1,a1,52 # 4000d034 <dad_timeout>
4000f910:	e0850513          	addi	a0,a0,-504 # 40030e08 <dad_timer>
4000f914:	3c1190ef          	jal	ra,400294d4 <k_work_init_delayable>
	list->head = NULL;
4000f918:	400317b7          	lui	a5,0x40031
	k_work_init_delayable(&rs_timer, rs_timeout);
4000f91c:	4000d5b7          	lui	a1,0x4000d
4000f920:	40031537          	lui	a0,0x40031
4000f924:	a4c78793          	addi	a5,a5,-1460 # 40030a4c <active_dad_timers>
4000f928:	da458593          	addi	a1,a1,-604 # 4000cda4 <rs_timeout>
4000f92c:	dd850513          	addi	a0,a0,-552 # 40030dd8 <rs_timer>
4000f930:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
4000f934:	0007a223          	sw	zero,4(a5)
4000f938:	39d190ef          	jal	ra,400294d4 <k_work_init_delayable>
	list->head = NULL;
4000f93c:	400317b7          	lui	a5,0x40031
	k_work_init_delayable(&address_lifetime_timer,
4000f940:	4000c5b7          	lui	a1,0x4000c
4000f944:	40031537          	lui	a0,0x40031
4000f948:	a4478793          	addi	a5,a5,-1468 # 40030a44 <active_rs_timers>
4000f94c:	41058593          	addi	a1,a1,1040 # 4000c410 <address_lifetime_timeout>
4000f950:	e6850513          	addi	a0,a0,-408 # 40030e68 <address_lifetime_timer>
4000f954:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
4000f958:	0007a223          	sw	zero,4(a5)
4000f95c:	379190ef          	jal	ra,400294d4 <k_work_init_delayable>
	k_work_init_delayable(&prefix_lifetime_timer, prefix_lifetime_timeout);
4000f960:	4000e5b7          	lui	a1,0x4000e
4000f964:	40031537          	lui	a0,0x40031
4000f968:	c5458593          	addi	a1,a1,-940 # 4000dc54 <prefix_lifetime_timeout>
4000f96c:	e3850513          	addi	a0,a0,-456 # 40030e38 <prefix_lifetime_timer>
4000f970:	365190ef          	jal	ra,400294d4 <k_work_init_delayable>
		ipv6_addresses[i].ipv6.hop_limit = CONFIG_NET_INITIAL_HOP_LIMIT;
4000f974:	40032537          	lui	a0,0x40032
		ipv6_addresses[i].ipv6.base_reachable_time = REACHABLE_TIME;
4000f978:	000077b7          	lui	a5,0x7
		ipv6_addresses[i].ipv6.hop_limit = CONFIG_NET_INITIAL_HOP_LIMIT;
4000f97c:	ce050413          	addi	s0,a0,-800 # 40031ce0 <ipv6_addresses>
		ipv6_addresses[i].ipv6.base_reachable_time = REACHABLE_TIME;
4000f980:	53078793          	addi	a5,a5,1328 # 7530 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3530>
		ipv6_addresses[i].ipv6.hop_limit = CONFIG_NET_INITIAL_HOP_LIMIT;
4000f984:	04000493          	li	s1,64
	ipv6->reachable_time = net_if_ipv6_calc_reachable_time(ipv6);
4000f988:	ce050513          	addi	a0,a0,-800
		ipv6_addresses[i].ipv6.base_reachable_time = REACHABLE_TIME;
4000f98c:	10f42823          	sw	a5,272(s0)
		ipv6_addresses[i].ipv6.hop_limit = CONFIG_NET_INITIAL_HOP_LIMIT;
4000f990:	129402a3          	sb	s1,293(s0)
4000f994:	fe5fe0ef          	jal	ra,4000e978 <net_if_ipv6_calc_reachable_time>
4000f998:	10a42a23          	sw	a0,276(s0)
	k_work_init_delayable(&router_timer, iface_router_expired);
4000f99c:	4000d5b7          	lui	a1,0x4000d
4000f9a0:	40031537          	lui	a0,0x40031
		ipv4_addresses[i].ipv4.ttl = CONFIG_NET_INITIAL_TTL;
4000f9a4:	400327b7          	lui	a5,0x40032
	k_work_init_delayable(&router_timer, iface_router_expired);
4000f9a8:	9cc58593          	addi	a1,a1,-1588 # 4000c9cc <iface_router_expired>
4000f9ac:	e9850513          	addi	a0,a0,-360 # 40030e98 <router_timer>
		ipv4_addresses[i].ipv4.ttl = CONFIG_NET_INITIAL_TTL;
4000f9b0:	cc978c23          	sb	s1,-808(a5) # 40031cd8 <ipv4_addresses+0x50>
	k_work_init_delayable(&router_timer, iface_router_expired);
4000f9b4:	321190ef          	jal	ra,400294d4 <k_work_init_delayable>
	list->head = NULL;
4000f9b8:	400317b7          	lui	a5,0x40031
4000f9bc:	a6478793          	addi	a5,a5,-1436 # 40030a64 <active_router_timers>
4000f9c0:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
4000f9c4:	0007a223          	sw	zero,4(a5)
	}
#endif

out:
	k_mutex_unlock(&lock);
}
4000f9c8:	01812403          	lw	s0,24(sp)
4000f9cc:	01c12083          	lw	ra,28(sp)
4000f9d0:	01412483          	lw	s1,20(sp)
4000f9d4:	01012903          	lw	s2,16(sp)
4000f9d8:	00c12983          	lw	s3,12(sp)
4000f9dc:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
4000f9e0:	d7cfc06f          	j	4000bf5c <k_mutex_unlock.constprop.0.isra.0>
	return iface->if_dev->dev;
4000f9e4:	00042503          	lw	a0,0(s0)
	const struct net_if_api *api = net_if_get_device(iface)->api;
4000f9e8:	00052783          	lw	a5,0(a0)
4000f9ec:	0087a983          	lw	s3,8(a5)
	if (!api || !api->init) {
4000f9f0:	02098c63          	beqz	s3,4000fa28 <net_if_init+0x168>
4000f9f4:	0009a783          	lw	a5,0(s3)
4000f9f8:	02078863          	beqz	a5,4000fa28 <net_if_init+0x168>
	net_if_flag_set(iface, NET_IF_IPV4);
4000f9fc:	00600593          	li	a1,6
4000fa00:	f45fc0ef          	jal	ra,4000c944 <net_if_flag_set.isra.0>
	net_if_flag_set(iface, NET_IF_IPV6);
4000fa04:	00042503          	lw	a0,0(s0)
4000fa08:	00700593          	li	a1,7
4000fa0c:	f39fc0ef          	jal	ra,4000c944 <net_if_flag_set.isra.0>
	net_if_flag_test_and_set(iface, NET_IF_LOWER_UP);
4000fa10:	00042503          	lw	a0,0(s0)
4000fa14:	00900593          	li	a1,9
4000fa18:	f3dfc0ef          	jal	ra,4000c954 <net_if_flag_test_and_set.isra.0>
	api->init(iface);
4000fa1c:	0009a783          	lw	a5,0(s3)
4000fa20:	00040513          	mv	a0,s0
4000fa24:	000780e7          	jalr	a5
		if_count++;
4000fa28:	00148493          	addi	s1,s1,1
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000fa2c:	00c40413          	addi	s0,s0,12
4000fa30:	ecdff06f          	j	4000f8fc <net_if_init+0x3c>

4000fa34 <net_if_post_init>:

void net_if_post_init(void)
{
4000fa34:	ff010113          	addi	sp,sp,-16
4000fa38:	00812423          	sw	s0,8(sp)
4000fa3c:	00912223          	sw	s1,4(sp)
	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000fa40:	4003d437          	lui	s0,0x4003d
4000fa44:	4003d4b7          	lui	s1,0x4003d
{
4000fa48:	00112623          	sw	ra,12(sp)
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000fa4c:	c3c40413          	addi	s0,s0,-964 # 4003cc3c <__net_if_dts_ord_12_0>
4000fa50:	c4848493          	addi	s1,s1,-952 # 4003cc48 <__net_if_dev_dts_ord_12_0>
4000fa54:	00946c63          	bltu	s0,s1,4000fa6c <net_if_post_init+0x38>
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
			net_if_up(iface);
		}
	}
}
4000fa58:	00c12083          	lw	ra,12(sp)
4000fa5c:	00812403          	lw	s0,8(sp)
4000fa60:	00412483          	lw	s1,4(sp)
4000fa64:	01010113          	addi	sp,sp,16
4000fa68:	00008067          	ret
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
4000fa6c:	00300593          	li	a1,3
4000fa70:	00040513          	mv	a0,s0
4000fa74:	b85fc0ef          	jal	ra,4000c5f8 <net_if_flag_is_set>
4000fa78:	00051663          	bnez	a0,4000fa84 <net_if_post_init+0x50>
			net_if_up(iface);
4000fa7c:	00040513          	mv	a0,s0
4000fa80:	c09ff0ef          	jal	ra,4000f688 <net_if_up>
	STRUCT_SECTION_FOREACH(net_if, iface) {
4000fa84:	00c40413          	addi	s0,s0,12
4000fa88:	fcdff06f          	j	4000fa54 <net_if_post_init+0x20>

4000fa8c <net_timeout_set>:
#include <zephyr/sys_clock.h>

void net_timeout_set(struct net_timeout *timeout,
		     uint32_t lifetime,
		     uint32_t now)
{
4000fa8c:	ff010113          	addi	sp,sp,-16
4000fa90:	00812423          	sw	s0,8(sp)
4000fa94:	00112623          	sw	ra,12(sp)
4000fa98:	00912223          	sw	s1,4(sp)
	uint64_t expire_timeout;

	timeout->timer_start = now;
4000fa9c:	00c52223          	sw	a2,4(a0)
{
4000faa0:	00050413          	mv	s0,a0

	/* Highly unlikely, but a zero timeout isn't correctly handled by the
	 * standard calculation.
	 */
	if (lifetime == 0U) {
4000faa4:	02059063          	bnez	a1,4000fac4 <net_timeout_set+0x38>
		timeout->wrap_counter = 0;
4000faa8:	00052623          	sw	zero,12(a0)
		timeout->timer_timeout = 0;
4000faac:	00052423          	sw	zero,8(a0)
	 */
	if (timeout->timer_timeout == 0U) {
		timeout->timer_timeout = NET_TIMEOUT_MAX_VALUE;
		timeout->wrap_counter -= 1;
	}
}
4000fab0:	00c12083          	lw	ra,12(sp)
4000fab4:	00812403          	lw	s0,8(sp)
4000fab8:	00412483          	lw	s1,4(sp)
4000fabc:	01010113          	addi	sp,sp,16
4000fac0:	00008067          	ret
	expire_timeout = (uint64_t)MSEC_PER_SEC * (uint64_t)lifetime;
4000fac4:	3e800793          	li	a5,1000
4000fac8:	02f584b3          	mul	s1,a1,a5
	timeout->wrap_counter = expire_timeout /
4000facc:	80000637          	lui	a2,0x80000
4000fad0:	00000693          	li	a3,0
4000fad4:	fff60613          	addi	a2,a2,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	expire_timeout = (uint64_t)MSEC_PER_SEC * (uint64_t)lifetime;
4000fad8:	02f5b5b3          	mulhu	a1,a1,a5
	timeout->wrap_counter = expire_timeout /
4000fadc:	00048513          	mv	a0,s1
4000fae0:	fd8f00ef          	jal	ra,400002b8 <__udivdi3>
		(uint64_t)NET_TIMEOUT_MAX_VALUE *
4000fae4:	800007b7          	lui	a5,0x80000
4000fae8:	fff78793          	addi	a5,a5,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
4000faec:	02f50733          	mul	a4,a0,a5
	timeout->wrap_counter = expire_timeout /
4000faf0:	00a42623          	sw	a0,12(s0)
	timeout->timer_timeout = expire_timeout -
4000faf4:	40e486b3          	sub	a3,s1,a4
	if (timeout->timer_timeout == 0U) {
4000faf8:	00e48663          	beq	s1,a4,4000fb04 <net_timeout_set+0x78>
	timeout->timer_timeout = expire_timeout -
4000fafc:	00d42423          	sw	a3,8(s0)
4000fb00:	fb1ff06f          	j	4000fab0 <net_timeout_set+0x24>
		timeout->wrap_counter -= 1;
4000fb04:	fff50513          	addi	a0,a0,-1
		timeout->timer_timeout = NET_TIMEOUT_MAX_VALUE;
4000fb08:	00f42423          	sw	a5,8(s0)
		timeout->wrap_counter -= 1;
4000fb0c:	00a42623          	sw	a0,12(s0)
4000fb10:	fa1ff06f          	j	4000fab0 <net_timeout_set+0x24>

4000fb14 <net_timeout_remaining>:
uint32_t net_timeout_remaining(const struct net_timeout *timeout,
			       uint32_t now)
{
	int64_t ret = timeout->timer_timeout;

	ret += timeout->wrap_counter * (uint64_t)NET_TIMEOUT_MAX_VALUE;
4000fb14:	00c52783          	lw	a5,12(a0)
4000fb18:	01f79713          	slli	a4,a5,0x1f
4000fb1c:	0017d693          	srli	a3,a5,0x1
4000fb20:	40f707b3          	sub	a5,a4,a5
4000fb24:	00f73733          	sltu	a4,a4,a5
4000fb28:	40e686b3          	sub	a3,a3,a4
4000fb2c:	00852703          	lw	a4,8(a0)
4000fb30:	00e78733          	add	a4,a5,a4
4000fb34:	00f737b3          	sltu	a5,a4,a5
4000fb38:	00d787b3          	add	a5,a5,a3
	ret -= (int64_t)(int32_t)(now - timeout->timer_start);
4000fb3c:	00452683          	lw	a3,4(a0)
4000fb40:	40d58533          	sub	a0,a1,a3
4000fb44:	41f55693          	srai	a3,a0,0x1f
4000fb48:	40a70533          	sub	a0,a4,a0
4000fb4c:	00a73733          	sltu	a4,a4,a0
4000fb50:	40d785b3          	sub	a1,a5,a3
4000fb54:	40e585b3          	sub	a1,a1,a4
	if (ret <= 0) {
4000fb58:	00b04663          	bgtz	a1,4000fb64 <net_timeout_remaining+0x50>
4000fb5c:	02059463          	bnez	a1,4000fb84 <net_timeout_remaining+0x70>
4000fb60:	02050263          	beqz	a0,4000fb84 <net_timeout_remaining+0x70>
{
4000fb64:	ff010113          	addi	sp,sp,-16
		return 0;
	}

	return (uint32_t)((uint64_t)ret / MSEC_PER_SEC);
4000fb68:	3e800613          	li	a2,1000
4000fb6c:	00000693          	li	a3,0
{
4000fb70:	00112623          	sw	ra,12(sp)
	return (uint32_t)((uint64_t)ret / MSEC_PER_SEC);
4000fb74:	f44f00ef          	jal	ra,400002b8 <__udivdi3>
}
4000fb78:	00c12083          	lw	ra,12(sp)
4000fb7c:	01010113          	addi	sp,sp,16
4000fb80:	00008067          	ret
		return 0;
4000fb84:	00000513          	li	a0,0
}
4000fb88:	00008067          	ret

4000fb8c <net_timeout_evaluate>:

	/* Time since last evaluation or set. */
	elapsed = now - timeout->timer_start;

	/* The delay used the last time this was evaluated. */
	wraps = (timeout->wrap_counter > 0U);
4000fb8c:	00c52603          	lw	a2,12(a0)
	elapsed = now - timeout->timer_start;
4000fb90:	00452683          	lw	a3,4(a0)
{
4000fb94:	00050793          	mv	a5,a0
	last_delay = wraps
		? NET_TIMEOUT_MAX_VALUE
		: timeout->timer_timeout;
4000fb98:	00060e63          	beqz	a2,4000fbb4 <net_timeout_evaluate+0x28>

	/* Time remaining until completion of the last delay. */
	remains = (int32_t)(last_delay - elapsed);
4000fb9c:	80000837          	lui	a6,0x80000
4000fba0:	fff80813          	addi	a6,a6,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
4000fba4:	40b80533          	sub	a0,a6,a1
4000fba8:	00d50533          	add	a0,a0,a3

	/* If the deadline for the next event hasn't been reached yet just
	 * return the remaining time.
	 */
	if (remains > 0) {
4000fbac:	02a05063          	blez	a0,4000fbcc <net_timeout_evaluate+0x40>
4000fbb0:	00008067          	ret
	remains = (int32_t)(last_delay - elapsed);
4000fbb4:	00852783          	lw	a5,8(a0)
4000fbb8:	00f686b3          	add	a3,a3,a5
4000fbbc:	40b68533          	sub	a0,a3,a1
	if (remains > 0) {
4000fbc0:	06a04263          	bgtz	a0,4000fc24 <net_timeout_evaluate+0x98>
	/* Deadline has been reached.  If we're not wrapping we've completed
	 * the last portion of the full timeout, so return zero to indicate
	 * the timeout has completed.
	 */
	if (!wraps) {
		return 0U;
4000fbc4:	00000513          	li	a0,0
4000fbc8:	00008067          	ret
	 * that's at least NET_TIMEOUT_MAX_VALUE, and can apply the
	 * reduction by decrementing the wrap count.
	 */
	timeout->timer_start = now;
	elapsed -= NET_TIMEOUT_MAX_VALUE;
	timeout->wrap_counter -= 1;
4000fbcc:	fff60713          	addi	a4,a2,-1
4000fbd0:	00e7a623          	sw	a4,12(a5)
	 * NET_TIMEOUT_MAX_VALUE.  But if subtracting would reduce the
	 * counter to zero or go negative we need to reduce the the wrap
	 * counter once more and add the residual to the counter, so the
	 * counter remains positive.
	 */
	if (timeout->timer_timeout > elapsed) {
4000fbd4:	0087a703          	lw	a4,8(a5)
4000fbd8:	41058533          	sub	a0,a1,a6
	timeout->timer_start = now;
4000fbdc:	00b7a223          	sw	a1,4(a5)
	if (timeout->timer_timeout > elapsed) {
4000fbe0:	40a685b3          	sub	a1,a3,a0
	elapsed -= NET_TIMEOUT_MAX_VALUE;
4000fbe4:	40d50533          	sub	a0,a0,a3
	if (timeout->timer_timeout > elapsed) {
4000fbe8:	00e57e63          	bgeu	a0,a4,4000fc04 <net_timeout_evaluate+0x78>
		timeout->timer_timeout -= elapsed;
4000fbec:	00e585b3          	add	a1,a1,a4
4000fbf0:	00b7a423          	sw	a1,8(a5)
		timeout->wrap_counter -= 1U;
	}

	return (timeout->wrap_counter == 0U)
		? timeout->timer_timeout
		: NET_TIMEOUT_MAX_VALUE;
4000fbf4:	00c7a703          	lw	a4,12(a5)
4000fbf8:	02071263          	bnez	a4,4000fc1c <net_timeout_evaluate+0x90>
4000fbfc:	0087a503          	lw	a0,8(a5)
4000fc00:	00008067          	ret
		timeout->timer_timeout += NET_TIMEOUT_MAX_VALUE - elapsed;
4000fc04:	01070733          	add	a4,a4,a6
4000fc08:	00b70733          	add	a4,a4,a1
		timeout->wrap_counter -= 1U;
4000fc0c:	ffe60613          	addi	a2,a2,-2
		timeout->timer_timeout += NET_TIMEOUT_MAX_VALUE - elapsed;
4000fc10:	00e7a423          	sw	a4,8(a5)
		timeout->wrap_counter -= 1U;
4000fc14:	00c7a623          	sw	a2,12(a5)
4000fc18:	fddff06f          	j	4000fbf4 <net_timeout_evaluate+0x68>
		: NET_TIMEOUT_MAX_VALUE;
4000fc1c:	80000537          	lui	a0,0x80000
4000fc20:	fff50513          	addi	a0,a0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
}
4000fc24:	00008067          	ret

4000fc28 <convert_port>:
}
#endif /* CONFIG_NET_IPV4_IGMP */

#if defined(CONFIG_NET_IP)
static bool convert_port(const char *buf, uint16_t *port)
{
4000fc28:	fe010113          	addi	sp,sp,-32
4000fc2c:	00912a23          	sw	s1,20(sp)
	unsigned long tmp;
	char *endptr;

	tmp = strtoul(buf, &endptr, 10);
4000fc30:	00a00613          	li	a2,10
{
4000fc34:	00058493          	mv	s1,a1
	tmp = strtoul(buf, &endptr, 10);
4000fc38:	00c10593          	addi	a1,sp,12
{
4000fc3c:	00812c23          	sw	s0,24(sp)
4000fc40:	00112e23          	sw	ra,28(sp)
4000fc44:	00050413          	mv	s0,a0
	tmp = strtoul(buf, &endptr, 10);
4000fc48:	824f90ef          	jal	ra,40008c6c <strtoul>
	if ((endptr == buf && tmp == 0) ||
4000fc4c:	00c12703          	lw	a4,12(sp)
	tmp = strtoul(buf, &endptr, 10);
4000fc50:	00050793          	mv	a5,a0
	if ((endptr == buf && tmp == 0) ||
4000fc54:	00871663          	bne	a4,s0,4000fc60 <convert_port+0x38>
	    !(*buf != '\0' && *endptr == '\0') ||
	    ((unsigned long)(unsigned short)tmp != tmp)) {
		return false;
4000fc58:	00000513          	li	a0,0
	if ((endptr == buf && tmp == 0) ||
4000fc5c:	02078463          	beqz	a5,4000fc84 <convert_port+0x5c>
4000fc60:	00044683          	lbu	a3,0(s0)
		return false;
4000fc64:	00000513          	li	a0,0
	if ((endptr == buf && tmp == 0) ||
4000fc68:	00068e63          	beqz	a3,4000fc84 <convert_port+0x5c>
	    !(*buf != '\0' && *endptr == '\0') ||
4000fc6c:	00074703          	lbu	a4,0(a4)
4000fc70:	00071a63          	bnez	a4,4000fc84 <convert_port+0x5c>
4000fc74:	00010737          	lui	a4,0x10
4000fc78:	00e7f663          	bgeu	a5,a4,4000fc84 <convert_port+0x5c>
	    ((unsigned long)(unsigned short)tmp != tmp)) {
4000fc7c:	00f49023          	sh	a5,0(s1)
	}

	*port = tmp;

	return true;
4000fc80:	00100513          	li	a0,1
}
4000fc84:	01c12083          	lw	ra,28(sp)
4000fc88:	01812403          	lw	s0,24(sp)
4000fc8c:	01412483          	lw	s1,20(sp)
4000fc90:	02010113          	addi	sp,sp,32
4000fc94:	00008067          	ret

4000fc98 <net_byte_to_hex>:
{
4000fc98:	00050793          	mv	a5,a0
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
4000fc9c:	0045d713          	srli	a4,a1,0x4
		if (i == 0 && !pad && !val) {
4000fca0:	04068863          	beqz	a3,4000fcf0 <net_byte_to_hex+0x58>
		if (val < 10) {
4000fca4:	00900513          	li	a0,9
			*ptr++ = (char) (val + '0');
4000fca8:	03070693          	addi	a3,a4,48 # 10030 <__kernel_ram_size+0x3d9c>
		if (val < 10) {
4000fcac:	00e57863          	bgeu	a0,a4,4000fcbc <net_byte_to_hex+0x24>
			*ptr++ = (char) (val - 10 + base);
4000fcb0:	ff660693          	addi	a3,a2,-10
4000fcb4:	00d70733          	add	a4,a4,a3
4000fcb8:	0ff77693          	zext.b	a3,a4
4000fcbc:	00d78023          	sb	a3,0(a5)
4000fcc0:	00178793          	addi	a5,a5,1
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
4000fcc4:	00f5f593          	andi	a1,a1,15
		if (val < 10) {
4000fcc8:	00900693          	li	a3,9
			*ptr++ = (char) (val - 10 + base);
4000fccc:	00178513          	addi	a0,a5,1
			*ptr++ = (char) (val + '0');
4000fcd0:	03058713          	addi	a4,a1,48
		if (val < 10) {
4000fcd4:	00b6f863          	bgeu	a3,a1,4000fce4 <net_byte_to_hex+0x4c>
			*ptr++ = (char) (val - 10 + base);
4000fcd8:	ff660613          	addi	a2,a2,-10
4000fcdc:	00c585b3          	add	a1,a1,a2
4000fce0:	0ff5f713          	zext.b	a4,a1
4000fce4:	00e78023          	sb	a4,0(a5)
	*ptr = '\0';
4000fce8:	000780a3          	sb	zero,1(a5)
}
4000fcec:	00008067          	ret
		if (i == 0 && !pad && !val) {
4000fcf0:	fa071ae3          	bnez	a4,4000fca4 <net_byte_to_hex+0xc>
4000fcf4:	fd1ff06f          	j	4000fcc4 <net_byte_to_hex+0x2c>

4000fcf8 <net_sprint_ll_addr_buf>:
	if (ll == NULL) {
4000fcf8:	0c050a63          	beqz	a0,4000fdcc <net_sprint_ll_addr_buf+0xd4>
{
4000fcfc:	fe010113          	addi	sp,sp,-32
4000fd00:	00812c23          	sw	s0,24(sp)
4000fd04:	01212823          	sw	s2,16(sp)
4000fd08:	01312623          	sw	s3,12(sp)
4000fd0c:	01412423          	sw	s4,8(sp)
4000fd10:	00112e23          	sw	ra,28(sp)
4000fd14:	00912a23          	sw	s1,20(sp)
4000fd18:	01512223          	sw	s5,4(sp)
4000fd1c:	01612023          	sw	s6,0(sp)
	switch (ll_len) {
4000fd20:	00200793          	li	a5,2
4000fd24:	00050a13          	mv	s4,a0
4000fd28:	00058993          	mv	s3,a1
4000fd2c:	00060413          	mv	s0,a2
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
4000fd30:	0ff6f913          	zext.b	s2,a3
	switch (ll_len) {
4000fd34:	00f58863          	beq	a1,a5,4000fd44 <net_sprint_ll_addr_buf+0x4c>
4000fd38:	00800793          	li	a5,8
4000fd3c:	00f58463          	beq	a1,a5,4000fd44 <net_sprint_ll_addr_buf+0x4c>
		len = 6U;
4000fd40:	00600993          	li	s3,6
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
4000fd44:	00040513          	mv	a0,s0
4000fd48:	00000493          	li	s1,0
4000fd4c:	04090a63          	beqz	s2,4000fda0 <net_sprint_ll_addr_buf+0xa8>
		*ptr++ = ':';
4000fd50:	03a00b13          	li	s6,58
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
4000fd54:	00300a93          	li	s5,3
		ptr = net_byte_to_hex(ptr, (char)ll[i], 'A', true);
4000fd58:	009a07b3          	add	a5,s4,s1
4000fd5c:	0007c583          	lbu	a1,0(a5)
4000fd60:	00100693          	li	a3,1
4000fd64:	04100613          	li	a2,65
4000fd68:	f31ff0ef          	jal	ra,4000fc98 <net_byte_to_hex>
4000fd6c:	00050793          	mv	a5,a0
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
4000fd70:	00148493          	addi	s1,s1,1
		*ptr++ = ':';
4000fd74:	01678023          	sb	s6,0(a5)
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
4000fd78:	0ff4f713          	zext.b	a4,s1
		*ptr++ = ':';
4000fd7c:	00150513          	addi	a0,a0,1
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
4000fd80:	01377863          	bgeu	a4,s3,4000fd90 <net_sprint_ll_addr_buf+0x98>
4000fd84:	03548733          	mul	a4,s1,s5
4000fd88:	0ff77713          	zext.b	a4,a4
4000fd8c:	fce916e3          	bne	s2,a4,4000fd58 <net_sprint_ll_addr_buf+0x60>
	if (!(ptr - buf)) {
4000fd90:	00a40863          	beq	s0,a0,4000fda0 <net_sprint_ll_addr_buf+0xa8>
	*(ptr - 1) = '\0';
4000fd94:	00078023          	sb	zero,0(a5)
	return buf;
4000fd98:	00040513          	mv	a0,s0
4000fd9c:	0080006f          	j	4000fda4 <net_sprint_ll_addr_buf+0xac>
		return NULL;
4000fda0:	00000513          	li	a0,0
}
4000fda4:	01c12083          	lw	ra,28(sp)
4000fda8:	01812403          	lw	s0,24(sp)
4000fdac:	01412483          	lw	s1,20(sp)
4000fdb0:	01012903          	lw	s2,16(sp)
4000fdb4:	00c12983          	lw	s3,12(sp)
4000fdb8:	00812a03          	lw	s4,8(sp)
4000fdbc:	00412a83          	lw	s5,4(sp)
4000fdc0:	00012b03          	lw	s6,0(sp)
4000fdc4:	02010113          	addi	sp,sp,32
4000fdc8:	00008067          	ret
		return "<unknown>";
4000fdcc:	4002d537          	lui	a0,0x4002d
4000fdd0:	2e850513          	addi	a0,a0,744 # 4002d2e8 <net_buf_fixed_cb+0x50>
}
4000fdd4:	00008067          	ret

4000fdd8 <z_impl_net_addr_ntop>:
{
4000fdd8:	fa010113          	addi	sp,sp,-96
4000fddc:	04812c23          	sw	s0,88(sp)
4000fde0:	05212823          	sw	s2,80(sp)
4000fde4:	05312623          	sw	s3,76(sp)
4000fde8:	04112e23          	sw	ra,92(sp)
4000fdec:	04912a23          	sw	s1,84(sp)
4000fdf0:	05412423          	sw	s4,72(sp)
4000fdf4:	05512223          	sw	s5,68(sp)
4000fdf8:	05612023          	sw	s6,64(sp)
4000fdfc:	03712e23          	sw	s7,60(sp)
4000fe00:	03812c23          	sw	s8,56(sp)
4000fe04:	03912a23          	sw	s9,52(sp)
4000fe08:	03a12823          	sw	s10,48(sp)
4000fe0c:	03b12623          	sw	s11,44(sp)
	unsigned char zeros[8] = { 0 };
4000fe10:	00012c23          	sw	zero,24(sp)
4000fe14:	00012e23          	sw	zero,28(sp)
	if (family == AF_INET6) {
4000fe18:	00200793          	li	a5,2
{
4000fe1c:	00050913          	mv	s2,a0
4000fe20:	00058993          	mv	s3,a1
4000fe24:	00060413          	mv	s0,a2
	if (family == AF_INET6) {
4000fe28:	0af51463          	bne	a0,a5,4000fed0 <z_impl_net_addr_ntop+0xf8>
		w = (uint16_t *)addr6->s6_addr16;
4000fe2c:	01810793          	addi	a5,sp,24
4000fe30:	00b12423          	sw	a1,8(sp)
4000fe34:	00000613          	li	a2,0
4000fe38:	00078513          	mv	a0,a5
			for (j = i; j < 8; j++) {
4000fe3c:	00800593          	li	a1,8
{
4000fe40:	00060693          	mv	a3,a2
4000fe44:	01c0006f          	j	4000fe60 <z_impl_net_addr_ntop+0x88>
				zeros[i]++;
4000fe48:	0007c703          	lbu	a4,0(a5)
			for (j = i; j < 8; j++) {
4000fe4c:	00168693          	addi	a3,a3,1
				zeros[i]++;
4000fe50:	00170713          	addi	a4,a4,1
4000fe54:	00e78023          	sb	a4,0(a5)
			for (j = i; j < 8; j++) {
4000fe58:	0ff6f713          	zext.b	a4,a3
4000fe5c:	02b70063          	beq	a4,a1,4000fe7c <z_impl_net_addr_ntop+0xa4>
				if (UNALIGNED_GET(&w[j]) != 0) {
4000fe60:	00169713          	slli	a4,a3,0x1
4000fe64:	00e98733          	add	a4,s3,a4
4000fe68:	00074803          	lbu	a6,0(a4)
4000fe6c:	00174703          	lbu	a4,1(a4)
4000fe70:	00871713          	slli	a4,a4,0x8
4000fe74:	01076733          	or	a4,a4,a6
4000fe78:	fc0708e3          	beqz	a4,4000fe48 <z_impl_net_addr_ntop+0x70>
		for (i = 0U; i < 8; i++) {
4000fe7c:	00160613          	addi	a2,a2,1
4000fe80:	00178793          	addi	a5,a5,1
4000fe84:	fab61ee3          	bne	a2,a1,4000fe40 <z_impl_net_addr_ntop+0x68>
4000fe88:	00000793          	li	a5,0
	int8_t pos = -1;
4000fe8c:	fff00a93          	li	s5,-1
	uint8_t i, bl, bh, longest = 1U;
4000fe90:	00100493          	li	s1,1
		for (i = 0U; i < 8; i++) {
4000fe94:	00800693          	li	a3,8
			if (zeros[i] > longest) {
4000fe98:	00f50733          	add	a4,a0,a5
4000fe9c:	00074703          	lbu	a4,0(a4)
4000fea0:	00e4f863          	bgeu	s1,a4,4000feb0 <z_impl_net_addr_ntop+0xd8>
				pos = i;
4000fea4:	01879a93          	slli	s5,a5,0x18
4000fea8:	418ada93          	srai	s5,s5,0x18
4000feac:	00070493          	mv	s1,a4
		for (i = 0U; i < 8; i++) {
4000feb0:	00178793          	addi	a5,a5,1
4000feb4:	fed792e3          	bne	a5,a3,4000fe98 <z_impl_net_addr_ntop+0xc0>
		if (longest == 1U) {
4000feb8:	00100793          	li	a5,1
4000febc:	04f49e63          	bne	s1,a5,4000ff18 <z_impl_net_addr_ntop+0x140>
		len = 8;
4000fec0:	00800a13          	li	s4,8
	char delim = ':';
4000fec4:	03a00b13          	li	s6,58
			pos = -1;
4000fec8:	fff00a93          	li	s5,-1
4000fecc:	0540006f          	j	4000ff20 <z_impl_net_addr_ntop+0x148>
	} else if (family == AF_INET) {
4000fed0:	00100793          	li	a5,1
4000fed4:	0af50e63          	beq	a0,a5,4000ff90 <z_impl_net_addr_ntop+0x1b8>
		return NULL;
4000fed8:	00000513          	li	a0,0
}
4000fedc:	05c12083          	lw	ra,92(sp)
4000fee0:	05812403          	lw	s0,88(sp)
4000fee4:	05412483          	lw	s1,84(sp)
4000fee8:	05012903          	lw	s2,80(sp)
4000feec:	04c12983          	lw	s3,76(sp)
4000fef0:	04812a03          	lw	s4,72(sp)
4000fef4:	04412a83          	lw	s5,68(sp)
4000fef8:	04012b03          	lw	s6,64(sp)
4000fefc:	03c12b83          	lw	s7,60(sp)
4000ff00:	03812c03          	lw	s8,56(sp)
4000ff04:	03412c83          	lw	s9,52(sp)
4000ff08:	03012d03          	lw	s10,48(sp)
4000ff0c:	02c12d83          	lw	s11,44(sp)
4000ff10:	06010113          	addi	sp,sp,96
4000ff14:	00008067          	ret
		len = 8;
4000ff18:	00800a13          	li	s4,8
	char delim = ':';
4000ff1c:	03a00b13          	li	s6,58
4000ff20:	00040513          	mv	a0,s0
	bool needcolon = false;
4000ff24:	00000613          	li	a2,0
	for (i = 0U; i < len; i++) {
4000ff28:	00000d13          	li	s10,0
4000ff2c:	00000793          	li	a5,0
		} else if (bl > 0x0f) {
4000ff30:	00f00b93          	li	s7,15
			if (bl < 10) {
4000ff34:	00900c13          	li	s8,9
			*ptr++ = ':';
4000ff38:	03a00c93          	li	s9,58
			i += longest - 1U;
4000ff3c:	fff48493          	addi	s1,s1,-1
	for (i = 9; i >= 0; i--, divisor /= 10U) {
4000ff40:	00a00d93          	li	s11,10
		if (len == 4) {
4000ff44:	00400713          	li	a4,4
4000ff48:	0cea1063          	bne	s4,a4,40010008 <z_impl_net_addr_ntop+0x230>
			value = (uint32_t)addr->s4_addr[i];
4000ff4c:	00f987b3          	add	a5,s3,a5
4000ff50:	0007c683          	lbu	a3,0(a5)
			if (value == 0U) {
4000ff54:	04069863          	bnez	a3,4000ffa4 <z_impl_net_addr_ntop+0x1cc>
				*ptr++ = '0';
4000ff58:	03000793          	li	a5,48
4000ff5c:	00f50023          	sb	a5,0(a0)
				*ptr++ = delim;
4000ff60:	016500a3          	sb	s6,1(a0)
4000ff64:	00250513          	addi	a0,a0,2
	for (i = 0U; i < len; i++) {
4000ff68:	001d0713          	addi	a4,s10,1
4000ff6c:	0ff77d13          	zext.b	s10,a4
4000ff70:	000d0793          	mv	a5,s10
4000ff74:	fd4d48e3          	blt	s10,s4,4000ff44 <z_impl_net_addr_ntop+0x16c>
	if (!(ptr - dst)) {
4000ff78:	f68500e3          	beq	a0,s0,4000fed8 <z_impl_net_addr_ntop+0x100>
	if (family == AF_INET) {
4000ff7c:	00100793          	li	a5,1
4000ff80:	18f91863          	bne	s2,a5,40010110 <z_impl_net_addr_ntop+0x338>
		*(ptr - 1) = '\0';
4000ff84:	fe050fa3          	sb	zero,-1(a0)
		return NULL;
4000ff88:	00040513          	mv	a0,s0
4000ff8c:	f51ff06f          	j	4000fedc <z_impl_net_addr_ntop+0x104>
		len = 4;
4000ff90:	00400a13          	li	s4,4
		delim = '.';
4000ff94:	02e00b13          	li	s6,46
	int8_t pos = -1;
4000ff98:	fff00a93          	li	s5,-1
	uint8_t i, bl, bh, longest = 1U;
4000ff9c:	00100493          	li	s1,1
4000ffa0:	f81ff06f          	j	4000ff20 <z_impl_net_addr_ntop+0x148>
			l = net_value_to_udec(ptr, value, 0);
4000ffa4:	3b9ad737          	lui	a4,0x3b9ad
4000ffa8:	00050793          	mv	a5,a0
4000ffac:	00900593          	li	a1,9
4000ffb0:	00000313          	li	t1,0
4000ffb4:	a0070813          	addi	a6,a4,-1536 # 3b9aca00 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x35a4e900>
	for (i = 9; i >= 0; i--, divisor /= 10U) {
4000ffb8:	fff00e13          	li	t3,-1
		temp = value / divisor;
4000ffbc:	0306d8b3          	divu	a7,a3,a6
		value = value % divisor;
4000ffc0:	00068e93          	mv	t4,a3
4000ffc4:	0306f6b3          	remu	a3,a3,a6
		if ((precision > i) || (temp != 0)) {
4000ffc8:	0065c463          	blt	a1,t1,4000ffd0 <z_impl_net_addr_ntop+0x1f8>
4000ffcc:	010eea63          	bltu	t4,a6,4000ffe0 <z_impl_net_addr_ntop+0x208>
			*buf++ = (char) (temp + '0');
4000ffd0:	03088893          	addi	a7,a7,48 # 1000030 <__rom_region_size+0xfcf654>
4000ffd4:	01178023          	sb	a7,0(a5)
4000ffd8:	00058313          	mv	t1,a1
4000ffdc:	00178793          	addi	a5,a5,1
	for (i = 9; i >= 0; i--, divisor /= 10U) {
4000ffe0:	fff58593          	addi	a1,a1,-1
4000ffe4:	03b85833          	divu	a6,a6,s11
4000ffe8:	fdc59ae3          	bne	a1,t3,4000ffbc <z_impl_net_addr_ntop+0x1e4>
	*buf = 0;
4000ffec:	00078023          	sb	zero,0(a5)
	return buf - start;
4000fff0:	40a787b3          	sub	a5,a5,a0
			ptr += l;
4000fff4:	0ff7f793          	zext.b	a5,a5
4000fff8:	00f507b3          	add	a5,a0,a5
			*ptr++ = delim;
4000fffc:	00178513          	addi	a0,a5,1
40010000:	01678023          	sb	s6,0(a5)
			continue;
40010004:	f65ff06f          	j	4000ff68 <z_impl_net_addr_ntop+0x190>
		if (i == pos) {
40010008:	02fa9863          	bne	s5,a5,40010038 <z_impl_net_addr_ntop+0x260>
			if (needcolon || i == 0U) {
4001000c:	00061463          	bnez	a2,40010014 <z_impl_net_addr_ntop+0x23c>
40010010:	000d1863          	bnez	s10,40010020 <z_impl_net_addr_ntop+0x248>
				*ptr++ = ':';
40010014:	03a00793          	li	a5,58
40010018:	00f50023          	sb	a5,0(a0)
4001001c:	00150513          	addi	a0,a0,1
			i += longest - 1U;
40010020:	009d0733          	add	a4,s10,s1
			*ptr++ = ':';
40010024:	01950023          	sb	s9,0(a0)
			i += longest - 1U;
40010028:	0ff77d13          	zext.b	s10,a4
			*ptr++ = ':';
4001002c:	00150513          	addi	a0,a0,1
			needcolon = false;
40010030:	00000613          	li	a2,0
			continue;
40010034:	f35ff06f          	j	4000ff68 <z_impl_net_addr_ntop+0x190>
		if (needcolon) {
40010038:	00060663          	beqz	a2,40010044 <z_impl_net_addr_ntop+0x26c>
			*ptr++ = ':';
4001003c:	01950023          	sb	s9,0(a0)
40010040:	00150513          	addi	a0,a0,1
		value = (uint32_t)sys_be16_to_cpu(UNALIGNED_GET(&w[i]));
40010044:	00812703          	lw	a4,8(sp)
40010048:	001d1793          	slli	a5,s10,0x1
4001004c:	00f707b3          	add	a5,a4,a5
40010050:	0017c683          	lbu	a3,1(a5)
40010054:	0007c603          	lbu	a2,0(a5)
40010058:	00869693          	slli	a3,a3,0x8
4001005c:	00c6e6b3          	or	a3,a3,a2
40010060:	00869793          	slli	a5,a3,0x8
40010064:	0086d693          	srli	a3,a3,0x8
40010068:	00d7e7b3          	or	a5,a5,a3
4001006c:	01079793          	slli	a5,a5,0x10
40010070:	0107d793          	srli	a5,a5,0x10
		bh = value >> 8;
40010074:	0087d693          	srli	a3,a5,0x8
		bl = value & 0xff;
40010078:	0ff7f793          	zext.b	a5,a5
		if (bh) {
4001007c:	06068063          	beqz	a3,400100dc <z_impl_net_addr_ntop+0x304>
		bh = value >> 8;
40010080:	0ff6f593          	zext.b	a1,a3
			if (bh > 0x0f) {
40010084:	02dbfc63          	bgeu	s7,a3,400100bc <z_impl_net_addr_ntop+0x2e4>
				ptr = net_byte_to_hex(ptr, bh, 'a', false);
40010088:	00000693          	li	a3,0
4001008c:	06100613          	li	a2,97
40010090:	00f12623          	sw	a5,12(sp)
40010094:	c05ff0ef          	jal	ra,4000fc98 <net_byte_to_hex>
40010098:	00c12783          	lw	a5,12(sp)
4001009c:	00050813          	mv	a6,a0
			ptr = net_byte_to_hex(ptr, bl, 'a', true);
400100a0:	00100693          	li	a3,1
400100a4:	06100613          	li	a2,97
400100a8:	00078593          	mv	a1,a5
400100ac:	00080513          	mv	a0,a6
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
400100b0:	be9ff0ef          	jal	ra,4000fc98 <net_byte_to_hex>
		needcolon = true;
400100b4:	00100613          	li	a2,1
400100b8:	eb1ff06f          	j	4000ff68 <z_impl_net_addr_ntop+0x190>
				if (bh < 10) {
400100bc:	00dc6c63          	bltu	s8,a3,400100d4 <z_impl_net_addr_ntop+0x2fc>
					*ptr++ = (char)(bh + '0');
400100c0:	03058593          	addi	a1,a1,48
400100c4:	0ff5f593          	zext.b	a1,a1
400100c8:	00150813          	addi	a6,a0,1
400100cc:	00b50023          	sb	a1,0(a0)
400100d0:	fd1ff06f          	j	400100a0 <z_impl_net_addr_ntop+0x2c8>
					*ptr++ = (char) (bh - 10 + 'a');
400100d4:	05758593          	addi	a1,a1,87
400100d8:	fedff06f          	j	400100c4 <z_impl_net_addr_ntop+0x2ec>
		} else if (bl > 0x0f) {
400100dc:	00fbfa63          	bgeu	s7,a5,400100f0 <z_impl_net_addr_ntop+0x318>
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
400100e0:	00000693          	li	a3,0
400100e4:	06100613          	li	a2,97
400100e8:	00078593          	mv	a1,a5
400100ec:	fc5ff06f          	j	400100b0 <z_impl_net_addr_ntop+0x2d8>
			if (bl < 10) {
400100f0:	00fc6c63          	bltu	s8,a5,40010108 <z_impl_net_addr_ntop+0x330>
				*ptr++ = (char)(bl + '0');
400100f4:	03078793          	addi	a5,a5,48
				*ptr++ = (char) (bl - 10 + 'a');
400100f8:	0ff7f793          	zext.b	a5,a5
400100fc:	00f50023          	sb	a5,0(a0)
40010100:	00150513          	addi	a0,a0,1
40010104:	fb1ff06f          	j	400100b4 <z_impl_net_addr_ntop+0x2dc>
40010108:	05778793          	addi	a5,a5,87
4001010c:	fedff06f          	j	400100f8 <z_impl_net_addr_ntop+0x320>
		*ptr = '\0';
40010110:	00050023          	sb	zero,0(a0)
40010114:	e75ff06f          	j	4000ff88 <z_impl_net_addr_ntop+0x1b0>

40010118 <net_sprint_addr>:
	char *s = buf[++i % NBUFS];
40010118:	400317b7          	lui	a5,0x40031
4001011c:	a707a603          	lw	a2,-1424(a5) # 40030a70 <i.3>
40010120:	00160613          	addi	a2,a2,1
40010124:	a6c7a823          	sw	a2,-1424(a5)
40010128:	00300793          	li	a5,3
4001012c:	02f66633          	rem	a2,a2,a5
40010130:	02800793          	li	a5,40
		union { uintptr_t x; size_t val; } parm3 = { .val = size };
		return (char *) arch_syscall_invoke4(parm0.x, parm1.x, parm2.x, parm3.x, K_SYSCALL_NET_ADDR_NTOP);
	}
#endif
	compiler_barrier();
	return z_impl_net_addr_ntop(family, src, dst, size);
40010134:	02800693          	li	a3,40
40010138:	02f60633          	mul	a2,a2,a5
4001013c:	400327b7          	lui	a5,0x40032
40010140:	e5478793          	addi	a5,a5,-428 # 40031e54 <buf.2>
40010144:	00c78633          	add	a2,a5,a2
40010148:	c91ff06f          	j	4000fdd8 <z_impl_net_addr_ntop>

4001014c <z_impl_net_addr_pton>:
{
4001014c:	fc010113          	addi	sp,sp,-64
40010150:	02812c23          	sw	s0,56(sp)
40010154:	03212823          	sw	s2,48(sp)
40010158:	02112e23          	sw	ra,60(sp)
4001015c:	02912a23          	sw	s1,52(sp)
40010160:	03312623          	sw	s3,44(sp)
40010164:	03412423          	sw	s4,40(sp)
40010168:	03512223          	sw	s5,36(sp)
4001016c:	03612023          	sw	s6,32(sp)
40010170:	01712e23          	sw	s7,28(sp)
	if (family == AF_INET) {
40010174:	00100793          	li	a5,1
{
40010178:	00058413          	mv	s0,a1
4001017c:	00060913          	mv	s2,a2
	if (family == AF_INET) {
40010180:	08f51263          	bne	a0,a5,40010204 <z_impl_net_addr_pton+0xb8>
		len = strlen(src);
40010184:	00058513          	mv	a0,a1
40010188:	da1f80ef          	jal	ra,40008f28 <strlen>
		for (i = 0; i < len; i++) {
4001018c:	00000793          	li	a5,0
			if (!(src[i] >= '0' && src[i] <= '9') &&
40010190:	00900613          	li	a2,9
40010194:	02e00593          	li	a1,46
		for (i = 0; i < len; i++) {
40010198:	04a79663          	bne	a5,a0,400101e4 <z_impl_net_addr_pton+0x98>
		(void)memset(addr, 0, sizeof(struct in_addr));
4001019c:	00400613          	li	a2,4
400101a0:	00000593          	li	a1,0
400101a4:	00090513          	mv	a0,s2
400101a8:	ec9f80ef          	jal	ra,40009070 <memset>
		for (i = 0; i < sizeof(struct in_addr); i++) {
400101ac:	00000493          	li	s1,0
400101b0:	00400993          	li	s3,4
			addr->s4_addr[i] = strtol(src, &endptr, 10);
400101b4:	00040513          	mv	a0,s0
400101b8:	00a00613          	li	a2,10
400101bc:	00c10593          	addi	a1,sp,12
400101c0:	919f80ef          	jal	ra,40008ad8 <strtol>
			src = ++endptr;
400101c4:	00c12403          	lw	s0,12(sp)
			addr->s4_addr[i] = strtol(src, &endptr, 10);
400101c8:	009907b3          	add	a5,s2,s1
400101cc:	00a78023          	sb	a0,0(a5)
		for (i = 0; i < sizeof(struct in_addr); i++) {
400101d0:	00148493          	addi	s1,s1,1
			src = ++endptr;
400101d4:	00140413          	addi	s0,s0,1
		for (i = 0; i < sizeof(struct in_addr); i++) {
400101d8:	fd349ee3          	bne	s1,s3,400101b4 <z_impl_net_addr_pton+0x68>
	return 0;
400101dc:	00000513          	li	a0,0
400101e0:	1500006f          	j	40010330 <z_impl_net_addr_pton+0x1e4>
			if (!(src[i] >= '0' && src[i] <= '9') &&
400101e4:	00f40733          	add	a4,s0,a5
400101e8:	00074683          	lbu	a3,0(a4)
400101ec:	fd068713          	addi	a4,a3,-48
400101f0:	0ff77713          	zext.b	a4,a4
400101f4:	00e67463          	bgeu	a2,a4,400101fc <z_impl_net_addr_pton+0xb0>
400101f8:	12b69a63          	bne	a3,a1,4001032c <z_impl_net_addr_pton+0x1e0>
		for (i = 0; i < len; i++) {
400101fc:	00178793          	addi	a5,a5,1
40010200:	f99ff06f          	j	40010198 <z_impl_net_addr_pton+0x4c>
	} else if (family == AF_INET6) {
40010204:	00200793          	li	a5,2
40010208:	12f51263          	bne	a0,a5,4001032c <z_impl_net_addr_pton+0x1e0>
		int expected_groups = strchr(src, '.') ? 6 : 8;
4001020c:	02e00593          	li	a1,46
40010210:	00040513          	mv	a0,s0
40010214:	ccdf80ef          	jal	ra,40008ee0 <strchr>
40010218:	00800b13          	li	s6,8
4001021c:	00050463          	beqz	a0,40010224 <z_impl_net_addr_pton+0xd8>
40010220:	00600b13          	li	s6,6
		if (*src == ':') {
40010224:	00044703          	lbu	a4,0(s0)
40010228:	03a00793          	li	a5,58
4001022c:	00f71463          	bne	a4,a5,40010234 <z_impl_net_addr_pton+0xe8>
			src++;
40010230:	00140413          	addi	s0,s0,1
		len = strlen(src);
40010234:	00040513          	mv	a0,s0
40010238:	cf1f80ef          	jal	ra,40008f28 <strlen>
		for (i = 0; i < len; i++) {
4001023c:	01f816b7          	lui	a3,0x1f81
40010240:	00000713          	li	a4,0
			if (!(src[i] >= '0' && src[i] <= '9') &&
40010244:	00900593          	li	a1,9
40010248:	04600813          	li	a6,70
4001024c:	00500893          	li	a7,5
40010250:	02d00313          	li	t1,45
40010254:	00168693          	addi	a3,a3,1 # 1f81001 <__rom_region_size+0x1f50625>
		for (i = 0; i < len; i++) {
40010258:	08a74a63          	blt	a4,a0,400102ec <z_impl_net_addr_pton+0x1a0>
		for (i = 0; i < expected_groups; i++) {
4001025c:	00000493          	li	s1,0
			if (*src != ':') {
40010260:	03a00a13          	li	s4,58
				if (i < 0) {
40010264:	fff00a93          	li	s5,-1
			if (!src || *src == '\0') {
40010268:	00044783          	lbu	a5,0(s0)
4001026c:	0c078063          	beqz	a5,4001032c <z_impl_net_addr_pton+0x1e0>
			if (*src != ':') {
40010270:	11478e63          	beq	a5,s4,4001038c <z_impl_net_addr_pton+0x240>
				UNALIGNED_PUT(htons(strtol(src, NULL, 16)),
40010274:	01000613          	li	a2,16
40010278:	00000593          	li	a1,0
4001027c:	00040513          	mv	a0,s0
40010280:	859f80ef          	jal	ra,40008ad8 <strtol>
40010284:	00050993          	mv	s3,a0
40010288:	00000593          	li	a1,0
4001028c:	01000613          	li	a2,16
40010290:	00040513          	mv	a0,s0
40010294:	845f80ef          	jal	ra,40008ad8 <strtol>
40010298:	4089d793          	srai	a5,s3,0x8
4001029c:	00851513          	slli	a0,a0,0x8
400102a0:	0ff7f793          	zext.b	a5,a5
400102a4:	00a7e7b3          	or	a5,a5,a0
400102a8:	01079713          	slli	a4,a5,0x10
400102ac:	00149b93          	slli	s7,s1,0x1
400102b0:	01790bb3          	add	s7,s2,s7
400102b4:	01075713          	srli	a4,a4,0x10
400102b8:	00fb8023          	sb	a5,0(s7)
400102bc:	00875793          	srli	a5,a4,0x8
400102c0:	00fb80a3          	sb	a5,1(s7)
				src = strchr(src, ':');
400102c4:	03a00593          	li	a1,58
400102c8:	00040513          	mv	a0,s0
400102cc:	c15f80ef          	jal	ra,40008ee0 <strchr>
				if (src) {
400102d0:	08050663          	beqz	a0,4001035c <z_impl_net_addr_pton+0x210>
					src++;
400102d4:	00150413          	addi	s0,a0,1
		for (i = 0; i < expected_groups; i++) {
400102d8:	00148493          	addi	s1,s1,1
400102dc:	f964c6e3          	blt	s1,s6,40010268 <z_impl_net_addr_pton+0x11c>
		if (expected_groups == 6) {
400102e0:	00600793          	li	a5,6
400102e4:	eefb1ce3          	bne	s6,a5,400101dc <z_impl_net_addr_pton+0x90>
400102e8:	0f40006f          	j	400103dc <z_impl_net_addr_pton+0x290>
			if (!(src[i] >= '0' && src[i] <= '9') &&
400102ec:	00e407b3          	add	a5,s0,a4
400102f0:	0007c783          	lbu	a5,0(a5)
400102f4:	fd078613          	addi	a2,a5,-48
400102f8:	0ff67613          	zext.b	a2,a2
400102fc:	00c5fe63          	bgeu	a1,a2,40010318 <z_impl_net_addr_pton+0x1cc>
40010300:	02f86063          	bltu	a6,a5,40010320 <z_impl_net_addr_pton+0x1d4>
40010304:	02f37463          	bgeu	t1,a5,4001032c <z_impl_net_addr_pton+0x1e0>
40010308:	fd278793          	addi	a5,a5,-46
4001030c:	00f6d7b3          	srl	a5,a3,a5
40010310:	0017f793          	andi	a5,a5,1
40010314:	00078c63          	beqz	a5,4001032c <z_impl_net_addr_pton+0x1e0>
		for (i = 0; i < len; i++) {
40010318:	00170713          	addi	a4,a4,1
4001031c:	f3dff06f          	j	40010258 <z_impl_net_addr_pton+0x10c>
40010320:	f9f78793          	addi	a5,a5,-97
40010324:	0ff7f793          	zext.b	a5,a5
40010328:	fef8f8e3          	bgeu	a7,a5,40010318 <z_impl_net_addr_pton+0x1cc>
				return -EINVAL;
4001032c:	fea00513          	li	a0,-22
}
40010330:	03c12083          	lw	ra,60(sp)
40010334:	03812403          	lw	s0,56(sp)
40010338:	03412483          	lw	s1,52(sp)
4001033c:	03012903          	lw	s2,48(sp)
40010340:	02c12983          	lw	s3,44(sp)
40010344:	02812a03          	lw	s4,40(sp)
40010348:	02412a83          	lw	s5,36(sp)
4001034c:	02012b03          	lw	s6,32(sp)
40010350:	01c12b83          	lw	s7,28(sp)
40010354:	04010113          	addi	sp,sp,64
40010358:	00008067          	ret
					if (i < expected_groups - 1) {
4001035c:	fffb0793          	addi	a5,s6,-1
40010360:	fcf4c6e3          	blt	s1,a5,4001032c <z_impl_net_addr_pton+0x1e0>
		for (i = 0; i < expected_groups; i++) {
40010364:	00148493          	addi	s1,s1,1
40010368:	fd64c2e3          	blt	s1,s6,4001032c <z_impl_net_addr_pton+0x1e0>
		if (expected_groups == 6) {
4001036c:	00600793          	li	a5,6
40010370:	e6fb16e3          	bne	s6,a5,400101dc <z_impl_net_addr_pton+0x90>
40010374:	fb9ff06f          	j	4001032c <z_impl_net_addr_pton+0x1e0>
				UNALIGNED_PUT(0, &addr->s6_addr16[i]);
40010378:	00149793          	slli	a5,s1,0x1
4001037c:	00f907b3          	add	a5,s2,a5
40010380:	00078023          	sb	zero,0(a5)
40010384:	000780a3          	sb	zero,1(a5)
			for (; i < expected_groups; i++) {
40010388:	00148493          	addi	s1,s1,1
4001038c:	ff64c6e3          	blt	s1,s6,40010378 <z_impl_net_addr_pton+0x22c>
			tmp = strrchr(src, ':');
40010390:	03a00593          	li	a1,58
40010394:	00040513          	mv	a0,s0
40010398:	b6df80ef          	jal	ra,40008f04 <strrchr>
			if (src == tmp && (expected_groups == 6 || !src[1])) {
4001039c:	00600793          	li	a5,6
400103a0:	08851263          	bne	a0,s0,40010424 <z_impl_net_addr_pton+0x2d8>
400103a4:	02fb0a63          	beq	s6,a5,400103d8 <z_impl_net_addr_pton+0x28c>
400103a8:	00144783          	lbu	a5,1(s0)
400103ac:	e20788e3          	beqz	a5,400101dc <z_impl_net_addr_pton+0x90>
			i = expected_groups - 1;
400103b0:	fffb0493          	addi	s1,s6,-1
				if (*tmp == ':') {
400103b4:	00054783          	lbu	a5,0(a0)
400103b8:	01479663          	bne	a5,s4,400103c4 <z_impl_net_addr_pton+0x278>
					i--;
400103bc:	fff48493          	addi	s1,s1,-1
				if (i < 0) {
400103c0:	f75486e3          	beq	s1,s5,4001032c <z_impl_net_addr_pton+0x1e0>
			} while (tmp-- != src);
400103c4:	fff50513          	addi	a0,a0,-1
400103c8:	00150793          	addi	a5,a0,1
400103cc:	fef414e3          	bne	s0,a5,400103b4 <z_impl_net_addr_pton+0x268>
			src++;
400103d0:	00250413          	addi	s0,a0,2
400103d4:	f05ff06f          	j	400102d8 <z_impl_net_addr_pton+0x18c>
				src++;
400103d8:	00140413          	addi	s0,s0,1
			for (i = 0; i < 4; i++) {
400103dc:	00000493          	li	s1,0
400103e0:	00400993          	li	s3,4
				if (!src || !*src) {
400103e4:	00044783          	lbu	a5,0(s0)
400103e8:	f40782e3          	beqz	a5,4001032c <z_impl_net_addr_pton+0x1e0>
				addr->s6_addr[12 + i] = strtol(src, NULL, 10);
400103ec:	00000593          	li	a1,0
400103f0:	00a00613          	li	a2,10
400103f4:	00040513          	mv	a0,s0
400103f8:	ee0f80ef          	jal	ra,40008ad8 <strtol>
400103fc:	009907b3          	add	a5,s2,s1
40010400:	00a78623          	sb	a0,12(a5)
				src = strchr(src, '.');
40010404:	02e00593          	li	a1,46
40010408:	00040513          	mv	a0,s0
4001040c:	ad5f80ef          	jal	ra,40008ee0 <strchr>
				if (src) {
40010410:	02050063          	beqz	a0,40010430 <z_impl_net_addr_pton+0x2e4>
			for (i = 0; i < 4; i++) {
40010414:	00148493          	addi	s1,s1,1
					src++;
40010418:	00150413          	addi	s0,a0,1
			for (i = 0; i < 4; i++) {
4001041c:	fd3494e3          	bne	s1,s3,400103e4 <z_impl_net_addr_pton+0x298>
40010420:	dbdff06f          	j	400101dc <z_impl_net_addr_pton+0x90>
			if (expected_groups == 6) {
40010424:	f8fb16e3          	bne	s6,a5,400103b0 <z_impl_net_addr_pton+0x264>
				tmp--;
40010428:	fff50513          	addi	a0,a0,-1
4001042c:	f85ff06f          	j	400103b0 <z_impl_net_addr_pton+0x264>
					if (i < 3) {
40010430:	00300793          	li	a5,3
40010434:	eef49ce3          	bne	s1,a5,4001032c <z_impl_net_addr_pton+0x1e0>
40010438:	da5ff06f          	j	400101dc <z_impl_net_addr_pton+0x90>

4001043c <parse_ipv4>:
#endif /* CONFIG_NET_IPV6 */

#if defined(CONFIG_NET_IPV4)
static bool parse_ipv4(const char *str, size_t str_len,
		       struct sockaddr *addr, bool has_port)
{
4001043c:	fc010113          	addi	sp,sp,-64
40010440:	02912a23          	sw	s1,52(sp)
40010444:	03312623          	sw	s3,44(sp)
40010448:	03412423          	sw	s4,40(sp)
4001044c:	03512223          	sw	s5,36(sp)
40010450:	02112e23          	sw	ra,60(sp)
40010454:	02812c23          	sw	s0,56(sp)
40010458:	03212823          	sw	s2,48(sp)
	char ipaddr[NET_IPV4_ADDR_LEN + 1];
	struct in_addr *addr4;
	int end, len, ret, i;
	uint16_t port;

	len = MIN(NET_IPV4_ADDR_LEN, str_len);
4001045c:	01000713          	li	a4,16
{
40010460:	00050993          	mv	s3,a0
40010464:	00058493          	mv	s1,a1
40010468:	00060a13          	mv	s4,a2
4001046c:	00068a93          	mv	s5,a3
	len = MIN(NET_IPV4_ADDR_LEN, str_len);
40010470:	01000793          	li	a5,16
40010474:	00b76463          	bltu	a4,a1,4001047c <parse_ipv4+0x40>
40010478:	00058793          	mv	a5,a1

	for (i = 0; i < len; i++) {
4001047c:	00000413          	li	s0,0
40010480:	04f44663          	blt	s0,a5,400104cc <parse_ipv4+0x90>
40010484:	00078413          	mv	s0,a5
			len = i;
			break;
		}
	}

	if (has_port) {
40010488:	0e0a8663          	beqz	s5,40010574 <parse_ipv4+0x138>
		/* IPv4 address with port number */
		ptr = memchr(str, ':', len);
4001048c:	00040613          	mv	a2,s0
40010490:	03a00593          	li	a1,58
40010494:	00098513          	mv	a0,s3
40010498:	bf9f80ef          	jal	ra,40009090 <memchr>
4001049c:	00050913          	mv	s2,a0
		if (!ptr) {
400104a0:	04051063          	bnez	a0,400104e0 <parse_ipv4+0xa4>
			return false;
400104a4:	00000513          	li	a0,0

	NET_DBG("IPv4 host %s port %d",
		net_addr_ntop(AF_INET, addr4, ipaddr, sizeof(ipaddr) - 1),
		port);
	return true;
}
400104a8:	03c12083          	lw	ra,60(sp)
400104ac:	03812403          	lw	s0,56(sp)
400104b0:	03412483          	lw	s1,52(sp)
400104b4:	03012903          	lw	s2,48(sp)
400104b8:	02c12983          	lw	s3,44(sp)
400104bc:	02812a03          	lw	s4,40(sp)
400104c0:	02412a83          	lw	s5,36(sp)
400104c4:	04010113          	addi	sp,sp,64
400104c8:	00008067          	ret
		if (!str[i]) {
400104cc:	00898733          	add	a4,s3,s0
400104d0:	00074703          	lbu	a4,0(a4)
400104d4:	fa070ae3          	beqz	a4,40010488 <parse_ipv4+0x4c>
	for (i = 0; i < len; i++) {
400104d8:	00140413          	addi	s0,s0,1
400104dc:	fa5ff06f          	j	40010480 <parse_ipv4+0x44>
		end = MIN(len, ptr - str);
400104e0:	413507b3          	sub	a5,a0,s3
400104e4:	0087d463          	bge	a5,s0,400104ec <parse_ipv4+0xb0>
400104e8:	00078413          	mv	s0,a5
	memcpy(ipaddr, str, end);
400104ec:	00040613          	mv	a2,s0
400104f0:	00098593          	mv	a1,s3
400104f4:	00c10513          	addi	a0,sp,12
400104f8:	b55f80ef          	jal	ra,4000904c <memcpy>
	ipaddr[end] = '\0';
400104fc:	02040793          	addi	a5,s0,32
40010500:	002787b3          	add	a5,a5,sp
40010504:	fe078623          	sb	zero,-20(a5)
	return z_impl_net_addr_pton(family, src, dst);
40010508:	00100513          	li	a0,1
4001050c:	004a0613          	addi	a2,s4,4
40010510:	00c10593          	addi	a1,sp,12
40010514:	c39ff0ef          	jal	ra,4001014c <z_impl_net_addr_pton>
	if (ret < 0) {
40010518:	f80546e3          	bltz	a0,400104a4 <parse_ipv4+0x68>
	net_sin(addr)->sin_family = AF_INET;
4001051c:	00100793          	li	a5,1
40010520:	00fa1023          	sh	a5,0(s4)
	if (!has_port) {
40010524:	040a8463          	beqz	s5,4001056c <parse_ipv4+0x130>
	memcpy(ipaddr, ptr + 1, str_len - end);
40010528:	408484b3          	sub	s1,s1,s0
4001052c:	00048613          	mv	a2,s1
40010530:	00190593          	addi	a1,s2,1
40010534:	00c10513          	addi	a0,sp,12
40010538:	b15f80ef          	jal	ra,4000904c <memcpy>
	ipaddr[str_len - end] = '\0';
4001053c:	02048793          	addi	a5,s1,32
40010540:	002784b3          	add	s1,a5,sp
	ret = convert_port(ipaddr, &port);
40010544:	00a10593          	addi	a1,sp,10
40010548:	00c10513          	addi	a0,sp,12
	ipaddr[str_len - end] = '\0';
4001054c:	fe048623          	sb	zero,-20(s1)
	ret = convert_port(ipaddr, &port);
40010550:	ed8ff0ef          	jal	ra,4000fc28 <convert_port>
	if (!ret) {
40010554:	f40508e3          	beqz	a0,400104a4 <parse_ipv4+0x68>
	net_sin(addr)->sin_port = htons(port);
40010558:	00a15783          	lhu	a5,10(sp)
4001055c:	00879713          	slli	a4,a5,0x8
40010560:	0087d793          	srli	a5,a5,0x8
40010564:	00f767b3          	or	a5,a4,a5
40010568:	00fa1123          	sh	a5,2(s4)
		return true;
4001056c:	00100513          	li	a0,1
40010570:	f39ff06f          	j	400104a8 <parse_ipv4+0x6c>
	char *ptr = NULL;
40010574:	00000913          	li	s2,0
40010578:	f75ff06f          	j	400104ec <parse_ipv4+0xb0>

4001057c <calc_chksum>:
	int odd_start = ((uintptr_t)data & 0x01);
4001057c:	0015f893          	andi	a7,a1,1
	if (odd_start == CHECKSUM_BIG_ENDIAN) {
40010580:	12089663          	bnez	a7,400106ac <calc_chksum+0x130>
		sum = __bswap_16(sum_in);
40010584:	00851793          	slli	a5,a0,0x8
40010588:	00855513          	srli	a0,a0,0x8
4001058c:	00a7e7b3          	or	a5,a5,a0
40010590:	01079513          	slli	a0,a5,0x10
40010594:	01055513          	srli	a0,a0,0x10
40010598:	00000793          	li	a5,0
	if ((((uintptr_t)data & 0x02) != 0) && (pending >= sizeof(uint16_t))) {
4001059c:	0025f713          	andi	a4,a1,2
400105a0:	02070463          	beqz	a4,400105c8 <calc_chksum+0x4c>
400105a4:	00100713          	li	a4,1
400105a8:	02c77063          	bgeu	a4,a2,400105c8 <calc_chksum+0x4c>
		sum = sum + *((uint16_t *)data);
400105ac:	0005d703          	lhu	a4,0(a1)
		pending -= sizeof(uint16_t);
400105b0:	ffe60613          	addi	a2,a2,-2
		data += sizeof(uint16_t);
400105b4:	00258593          	addi	a1,a1,2
		sum = sum + *((uint16_t *)data);
400105b8:	00e50733          	add	a4,a0,a4
400105bc:	00a736b3          	sltu	a3,a4,a0
400105c0:	00f687b3          	add	a5,a3,a5
400105c4:	00070513          	mv	a0,a4
	while (pending >= sizeof(uint32_t) * 4) {
400105c8:	00058693          	mv	a3,a1
400105cc:	00c58eb3          	add	t4,a1,a2
400105d0:	00f00e13          	li	t3,15
400105d4:	40de8733          	sub	a4,t4,a3
400105d8:	0eee6e63          	bltu	t3,a4,400106d4 <calc_chksum+0x158>
400105dc:	00465693          	srli	a3,a2,0x4
400105e0:	ff000713          	li	a4,-16
400105e4:	02e68733          	mul	a4,a3,a4
400105e8:	00469693          	slli	a3,a3,0x4
400105ec:	00d58333          	add	t1,a1,a3
	while (pending >= sizeof(uint32_t)) {
400105f0:	00300e13          	li	t3,3
400105f4:	00c70633          	add	a2,a4,a2
	while (pending >= sizeof(uint32_t) * 4) {
400105f8:	00060813          	mv	a6,a2
	while (pending >= sizeof(uint32_t)) {
400105fc:	130e6063          	bltu	t3,a6,4001071c <calc_chksum+0x1a0>
40010600:	00265713          	srli	a4,a2,0x2
40010604:	ffc00813          	li	a6,-4
40010608:	03070733          	mul	a4,a4,a6
4001060c:	00e60733          	add	a4,a2,a4
		sum = sum + p[i++];
40010610:	ffc67613          	andi	a2,a2,-4
40010614:	00d60633          	add	a2,a2,a3
	if (pending >= 2) {
40010618:	00100693          	li	a3,1
		sum = sum + p[i++];
4001061c:	00c585b3          	add	a1,a1,a2
	if (pending >= 2) {
40010620:	02e6f063          	bgeu	a3,a4,40010640 <calc_chksum+0xc4>
		sum = sum + *((uint16_t *)data);
40010624:	0005d683          	lhu	a3,0(a1)
		pending -= sizeof(uint16_t);
40010628:	ffe70713          	addi	a4,a4,-2
		data += sizeof(uint16_t);
4001062c:	00258593          	addi	a1,a1,2
		sum = sum + *((uint16_t *)data);
40010630:	00d506b3          	add	a3,a0,a3
40010634:	00a6b633          	sltu	a2,a3,a0
40010638:	00f607b3          	add	a5,a2,a5
4001063c:	00068513          	mv	a0,a3
	if (pending == 1) {
40010640:	00100693          	li	a3,1
40010644:	02d71263          	bne	a4,a3,40010668 <calc_chksum+0xec>
	uint16_t data16 = (uint16_t)*data;
40010648:	0005c703          	lbu	a4,0(a1)
	if (((uintptr_t)(data) & 1) == CHECKSUM_BIG_ENDIAN) {
4001064c:	0015f593          	andi	a1,a1,1
40010650:	00058463          	beqz	a1,40010658 <calc_chksum+0xdc>
		return data16 << 8;
40010654:	00871713          	slli	a4,a4,0x8
		sum += offset_based_swap8(data);
40010658:	00e50733          	add	a4,a0,a4
4001065c:	00a736b3          	sltu	a3,a4,a0
40010660:	00f687b3          	add	a5,a3,a5
40010664:	00070513          	mv	a0,a4
		sum = (sum & 0xffff) + (sum >> 16);
40010668:	00010637          	lui	a2,0x10
4001066c:	fff60613          	addi	a2,a2,-1 # ffff <__kernel_ram_size+0x3d6b>
	while (sum >> 16) {
40010670:	01079693          	slli	a3,a5,0x10
40010674:	01055713          	srli	a4,a0,0x10
40010678:	00e6e733          	or	a4,a3,a4
4001067c:	0107d793          	srli	a5,a5,0x10
40010680:	00f766b3          	or	a3,a4,a5
40010684:	0a069c63          	bnez	a3,4001073c <calc_chksum+0x1c0>
		return __bswap_16((uint16_t)sum);
40010688:	01051513          	slli	a0,a0,0x10
4001068c:	01055513          	srli	a0,a0,0x10
	if (odd_start == CHECKSUM_BIG_ENDIAN) {
40010690:	00089c63          	bnez	a7,400106a8 <calc_chksum+0x12c>
		return __bswap_16((uint16_t)sum);
40010694:	00851793          	slli	a5,a0,0x8
40010698:	00855513          	srli	a0,a0,0x8
4001069c:	00a7e7b3          	or	a5,a5,a0
400106a0:	01079513          	slli	a0,a5,0x10
400106a4:	01055513          	srli	a0,a0,0x10
}
400106a8:	00008067          	ret
		sum = sum_in;
400106ac:	00000793          	li	a5,0
	if ((((uintptr_t)data & 0x01) != 0) && (pending >= 1)) {
400106b0:	f0060ce3          	beqz	a2,400105c8 <calc_chksum+0x4c>
		return data16 << 8;
400106b4:	0005c703          	lbu	a4,0(a1)
		pending--;
400106b8:	fff60613          	addi	a2,a2,-1
		data++;
400106bc:	00158593          	addi	a1,a1,1
		sum += offset_based_swap8(data);
400106c0:	00871713          	slli	a4,a4,0x8
400106c4:	00e50733          	add	a4,a0,a4
400106c8:	00a737b3          	sltu	a5,a4,a0
400106cc:	00070513          	mv	a0,a4
		pending--;
400106d0:	ecdff06f          	j	4001059c <calc_chksum+0x20>
		uint64_t sum_a = p[i];
400106d4:	0006a803          	lw	a6,0(a3)
		uint64_t sum_b = p[i + 1];
400106d8:	0046a703          	lw	a4,4(a3)
400106dc:	01068693          	addi	a3,a3,16
400106e0:	00e80733          	add	a4,a6,a4
400106e4:	01073333          	sltu	t1,a4,a6
400106e8:	00a70833          	add	a6,a4,a0
400106ec:	00e83733          	sltu	a4,a6,a4
400106f0:	00f307b3          	add	a5,t1,a5
		sum_a += p[i + 2];
400106f4:	ff86a503          	lw	a0,-8(a3)
400106f8:	00f70733          	add	a4,a4,a5
		sum_b += p[i + 3];
400106fc:	ffc6a783          	lw	a5,-4(a3)
40010700:	00a80533          	add	a0,a6,a0
40010704:	01053833          	sltu	a6,a0,a6
		sum += sum_a + sum_b;
40010708:	00a78533          	add	a0,a5,a0
4001070c:	00e80833          	add	a6,a6,a4
40010710:	00f537b3          	sltu	a5,a0,a5
40010714:	010787b3          	add	a5,a5,a6
40010718:	ebdff06f          	j	400105d4 <calc_chksum+0x58>
		sum = sum + p[i++];
4001071c:	00032703          	lw	a4,0(t1)
		pending -= sizeof(uint32_t);
40010720:	ffc80813          	addi	a6,a6,-4
		sum = sum + p[i++];
40010724:	00430313          	addi	t1,t1,4
40010728:	00e50733          	add	a4,a0,a4
4001072c:	00a73eb3          	sltu	t4,a4,a0
40010730:	00fe87b3          	add	a5,t4,a5
40010734:	00070513          	mv	a0,a4
40010738:	ec5ff06f          	j	400105fc <calc_chksum+0x80>
		sum = (sum & 0xffff) + (sum >> 16);
4001073c:	00c576b3          	and	a3,a0,a2
40010740:	00e68733          	add	a4,a3,a4
40010744:	00d736b3          	sltu	a3,a4,a3
40010748:	00070513          	mv	a0,a4
4001074c:	00f687b3          	add	a5,a3,a5
40010750:	f21ff06f          	j	40010670 <calc_chksum+0xf4>

40010754 <net_calc_chksum>:
{
40010754:	fe010113          	addi	sp,sp,-32
40010758:	00812c23          	sw	s0,24(sp)
4001075c:	00112e23          	sw	ra,28(sp)
40010760:	00912a23          	sw	s1,20(sp)
40010764:	01212823          	sw	s2,16(sp)
40010768:	01312623          	sw	s3,12(sp)
4001076c:	01412423          	sw	s4,8(sp)
40010770:	01512223          	sw	s5,4(sp)
40010774:	01612023          	sw	s6,0(sp)
40010778:	03452783          	lw	a5,52(a0)
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
4001077c:	00100713          	li	a4,1
{
40010780:	00050413          	mv	s0,a0
40010784:	01d7d793          	srli	a5,a5,0x1d
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
40010788:	12e79463          	bne	a5,a4,400108b0 <net_calc_chksum+0x15c>
		if (proto != IPPROTO_ICMP) {
4001078c:	16f58863          	beq	a1,a5,400108fc <net_calc_chksum+0x1a8>
			sum = net_pkt_get_len(pkt) -
40010790:	00852783          	lw	a5,8(a0)
	size_t bytes = 0;
40010794:	00000713          	li	a4,0
	while (buf) {
40010798:	10079463          	bnez	a5,400108a0 <net_calc_chksum+0x14c>
				net_pkt_ip_hdr_len(pkt) -
4001079c:	03644783          	lbu	a5,54(s0)
				net_pkt_ipv4_opts_len(pkt) + proto;
400107a0:	03a44683          	lbu	a3,58(s0)
			len = 2 * sizeof(struct in_addr);
400107a4:	00800a93          	li	s5,8
			sum = net_pkt_get_len(pkt) -
400107a8:	00d787b3          	add	a5,a5,a3
400107ac:	40f584b3          	sub	s1,a1,a5
400107b0:	00e484b3          	add	s1,s1,a4
400107b4:	01049493          	slli	s1,s1,0x10
400107b8:	0104d493          	srli	s1,s1,0x10
	net_pkt_cursor_init(pkt);
400107bc:	00040513          	mv	a0,s0
 * @param backup The cursor where to backup net_pkt cursor
 */
static inline void net_pkt_cursor_backup(struct net_pkt *pkt,
					 struct net_pkt_cursor *backup)
{
	backup->buf = pkt->cursor.buf;
400107c0:	00c42a03          	lw	s4,12(s0)
	backup->pos = pkt->cursor.pos;
400107c4:	01042983          	lw	s3,16(s0)
400107c8:	229020ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	pkt->overwrite = overwrite;
400107cc:	03744783          	lbu	a5,55(s0)
	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);
400107d0:	03644583          	lbu	a1,54(s0)
	return pkt->overwrite;
400107d4:	03744903          	lbu	s2,55(s0)
	pkt->overwrite = overwrite;
400107d8:	0017e793          	ori	a5,a5,1
400107dc:	02f40ba3          	sb	a5,55(s0)
400107e0:	415585b3          	sub	a1,a1,s5
400107e4:	00040513          	mv	a0,s0
400107e8:	77d020ef          	jal	ra,40013764 <net_pkt_skip>
	sum = calc_chksum(sum, pkt->cursor.pos, len);
400107ec:	01042583          	lw	a1,16(s0)
400107f0:	000a8613          	mv	a2,s5
400107f4:	00048513          	mv	a0,s1
400107f8:	d85ff0ef          	jal	ra,4001057c <calc_chksum>
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
400107fc:	03a45583          	lhu	a1,58(s0)
	sum = calc_chksum(sum, pkt->cursor.pos, len);
40010800:	00050493          	mv	s1,a0
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
40010804:	00040513          	mv	a0,s0
40010808:	015585b3          	add	a1,a1,s5
4001080c:	759020ef          	jal	ra,40013764 <net_pkt_skip>
	if (!cur->buf || !cur->pos) {
40010810:	00c42703          	lw	a4,12(s0)
	return pkt->overwrite;
40010814:	00197913          	andi	s2,s2,1
40010818:	02070263          	beqz	a4,4001083c <net_calc_chksum+0xe8>
4001081c:	01042783          	lw	a5,16(s0)
40010820:	00078e63          	beqz	a5,4001083c <net_calc_chksum+0xe8>
	len = cur->buf->len - (cur->pos - cur->buf->data);
40010824:	01075a83          	lhu	s5,16(a4)
40010828:	00c72703          	lw	a4,12(a4)
4001082c:	40e787b3          	sub	a5,a5,a4
40010830:	40fa8ab3          	sub	s5,s5,a5
	while (cur->buf) {
40010834:	00c42b03          	lw	s6,12(s0)
40010838:	0c0b1863          	bnez	s6,40010908 <net_calc_chksum+0x1b4>
	sum = (sum == 0U) ? 0xffff : htons(sum);
4001083c:	14048063          	beqz	s1,4001097c <net_calc_chksum+0x228>
40010840:	00849513          	slli	a0,s1,0x8
40010844:	0084d493          	srli	s1,s1,0x8
40010848:	00956533          	or	a0,a0,s1
4001084c:	01051513          	slli	a0,a0,0x10
40010850:	01055513          	srli	a0,a0,0x10
	pkt->overwrite = overwrite;
40010854:	03744783          	lbu	a5,55(s0)
	return ~sum;
40010858:	fff54513          	not	a0,a0
4001085c:	01051513          	slli	a0,a0,0x10
40010860:	ffe7f793          	andi	a5,a5,-2
40010864:	0127e7b3          	or	a5,a5,s2
 * @param backup The cursor from where to restore net_pkt cursor
 */
static inline void net_pkt_cursor_restore(struct net_pkt *pkt,
					  struct net_pkt_cursor *backup)
{
	pkt->cursor.buf = backup->buf;
40010868:	01442623          	sw	s4,12(s0)
	pkt->cursor.pos = backup->pos;
4001086c:	01342823          	sw	s3,16(s0)
	pkt->overwrite = overwrite;
40010870:	02f40ba3          	sb	a5,55(s0)
40010874:	01055513          	srli	a0,a0,0x10
}
40010878:	01c12083          	lw	ra,28(sp)
4001087c:	01812403          	lw	s0,24(sp)
40010880:	01412483          	lw	s1,20(sp)
40010884:	01012903          	lw	s2,16(sp)
40010888:	00c12983          	lw	s3,12(sp)
4001088c:	00812a03          	lw	s4,8(sp)
40010890:	00412a83          	lw	s5,4(sp)
40010894:	00012b03          	lw	s6,0(sp)
40010898:	02010113          	addi	sp,sp,32
4001089c:	00008067          	ret
		bytes += buf->len;
400108a0:	0107d683          	lhu	a3,16(a5)
		buf = buf->frags;
400108a4:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
400108a8:	00d70733          	add	a4,a4,a3
		buf = buf->frags;
400108ac:	eedff06f          	j	40010798 <net_calc_chksum+0x44>
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
400108b0:	00200713          	li	a4,2
		return 0;
400108b4:	00000513          	li	a0,0
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
400108b8:	fce790e3          	bne	a5,a4,40010878 <net_calc_chksum+0x124>
		sum =  net_pkt_get_len(pkt) -
400108bc:	00842783          	lw	a5,8(s0)
	size_t bytes = 0;
400108c0:	00000713          	li	a4,0
	while (buf) {
400108c4:	02079463          	bnez	a5,400108ec <net_calc_chksum+0x198>
400108c8:	03a45783          	lhu	a5,58(s0)
		len = 2 * sizeof(struct in6_addr);
400108cc:	02000a93          	li	s5,32
		sum =  net_pkt_get_len(pkt) -
400108d0:	40f584b3          	sub	s1,a1,a5
			net_pkt_ip_hdr_len(pkt) -
400108d4:	03644783          	lbu	a5,54(s0)
		sum =  net_pkt_get_len(pkt) -
400108d8:	40f484b3          	sub	s1,s1,a5
400108dc:	00e484b3          	add	s1,s1,a4
400108e0:	01049493          	slli	s1,s1,0x10
400108e4:	0104d493          	srli	s1,s1,0x10
400108e8:	ed5ff06f          	j	400107bc <net_calc_chksum+0x68>
		bytes += buf->len;
400108ec:	0107d683          	lhu	a3,16(a5)
		buf = buf->frags;
400108f0:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
400108f4:	00d70733          	add	a4,a4,a3
		buf = buf->frags;
400108f8:	fcdff06f          	j	400108c4 <net_calc_chksum+0x170>
	uint16_t sum = 0U;
400108fc:	00000493          	li	s1,0
	size_t len = 0U;
40010900:	00000a93          	li	s5,0
40010904:	eb9ff06f          	j	400107bc <net_calc_chksum+0x68>
		sum = calc_chksum(sum, cur->pos, len);
40010908:	01042583          	lw	a1,16(s0)
4001090c:	00048513          	mv	a0,s1
40010910:	000a8613          	mv	a2,s5
40010914:	c69ff0ef          	jal	ra,4001057c <calc_chksum>
		cur->buf = cur->buf->frags;
40010918:	004b2783          	lw	a5,4(s6)
		sum = calc_chksum(sum, cur->pos, len);
4001091c:	00050493          	mv	s1,a0
		cur->buf = cur->buf->frags;
40010920:	00f42623          	sw	a5,12(s0)
		if (!cur->buf || !cur->buf->len) {
40010924:	f0078ce3          	beqz	a5,4001083c <net_calc_chksum+0xe8>
40010928:	0107d703          	lhu	a4,16(a5)
4001092c:	f00708e3          	beqz	a4,4001083c <net_calc_chksum+0xe8>
		cur->pos = cur->buf->data;
40010930:	00c7a703          	lw	a4,12(a5)
		if (len % 2) {
40010934:	001afa93          	andi	s5,s5,1
		cur->pos = cur->buf->data;
40010938:	00e42823          	sw	a4,16(s0)
		if (len % 2) {
4001093c:	020a8c63          	beqz	s5,40010974 <net_calc_chksum+0x220>
			sum += *cur->pos;
40010940:	00074683          	lbu	a3,0(a4)
40010944:	00d504b3          	add	s1,a0,a3
40010948:	01049493          	slli	s1,s1,0x10
4001094c:	0104d493          	srli	s1,s1,0x10
			if (sum < *cur->pos) {
40010950:	00d4f863          	bgeu	s1,a3,40010960 <net_calc_chksum+0x20c>
				sum++;
40010954:	00148493          	addi	s1,s1,1
40010958:	01049493          	slli	s1,s1,0x10
4001095c:	0104d493          	srli	s1,s1,0x10
			cur->pos++;
40010960:	00170713          	addi	a4,a4,1
40010964:	00e42823          	sw	a4,16(s0)
			len = cur->buf->len - 1;
40010968:	0107da83          	lhu	s5,16(a5)
4001096c:	fffa8a93          	addi	s5,s5,-1
40010970:	ec5ff06f          	j	40010834 <net_calc_chksum+0xe0>
			len = cur->buf->len;
40010974:	0107da83          	lhu	s5,16(a5)
40010978:	ebdff06f          	j	40010834 <net_calc_chksum+0xe0>
	sum = (sum == 0U) ? 0xffff : htons(sum);
4001097c:	00010537          	lui	a0,0x10
40010980:	fff50513          	addi	a0,a0,-1 # ffff <__kernel_ram_size+0x3d6b>
40010984:	ed1ff06f          	j	40010854 <net_calc_chksum+0x100>

40010988 <net_calc_chksum_ipv4>:
{
40010988:	ff010113          	addi	sp,sp,-16
4001098c:	00112623          	sw	ra,12(sp)
	sum = calc_chksum(0, pkt->buffer->data,
40010990:	00852783          	lw	a5,8(a0)
			  net_pkt_ip_hdr_len(pkt) +
40010994:	03654603          	lbu	a2,54(a0)
			  net_pkt_ipv4_opts_len(pkt));
40010998:	03a54703          	lbu	a4,58(a0)
	sum = calc_chksum(0, pkt->buffer->data,
4001099c:	00c7a583          	lw	a1,12(a5)
400109a0:	00000513          	li	a0,0
400109a4:	00e60633          	add	a2,a2,a4
400109a8:	bd5ff0ef          	jal	ra,4001057c <calc_chksum>
	sum = (sum == 0U) ? 0xffff : htons(sum);
400109ac:	02050863          	beqz	a0,400109dc <net_calc_chksum_ipv4+0x54>
400109b0:	00851793          	slli	a5,a0,0x8
400109b4:	00855513          	srli	a0,a0,0x8
400109b8:	00a7e533          	or	a0,a5,a0
400109bc:	01051513          	slli	a0,a0,0x10
400109c0:	01055513          	srli	a0,a0,0x10
}
400109c4:	00c12083          	lw	ra,12(sp)
	return ~sum;
400109c8:	fff54513          	not	a0,a0
}
400109cc:	01051513          	slli	a0,a0,0x10
400109d0:	01055513          	srli	a0,a0,0x10
400109d4:	01010113          	addi	sp,sp,16
400109d8:	00008067          	ret
	sum = (sum == 0U) ? 0xffff : htons(sum);
400109dc:	00010537          	lui	a0,0x10
400109e0:	fff50513          	addi	a0,a0,-1 # ffff <__kernel_ram_size+0x3d6b>
400109e4:	fe1ff06f          	j	400109c4 <net_calc_chksum_ipv4+0x3c>

400109e8 <net_ipaddr_parse>:
	return false;
}
#endif /* CONFIG_NET_IPV4 */

bool net_ipaddr_parse(const char *str, size_t str_len, struct sockaddr *addr)
{
400109e8:	fa010113          	addi	sp,sp,-96
400109ec:	04112e23          	sw	ra,92(sp)
400109f0:	04812c23          	sw	s0,88(sp)
400109f4:	04912a23          	sw	s1,84(sp)
400109f8:	05212823          	sw	s2,80(sp)
400109fc:	05312623          	sw	s3,76(sp)
40010a00:	05412423          	sw	s4,72(sp)
40010a04:	05512223          	sw	s5,68(sp)
	int i, count;

	if (!str || str_len == 0) {
40010a08:	0c050063          	beqz	a0,40010ac8 <net_ipaddr_parse+0xe0>
40010a0c:	00058413          	mv	s0,a1
40010a10:	0a058c63          	beqz	a1,40010ac8 <net_ipaddr_parse+0xe0>
		return false;
	}

	/* We cannot accept empty string here */
	if (*str == '\0') {
40010a14:	00054783          	lbu	a5,0(a0)
40010a18:	00050a93          	mv	s5,a0
40010a1c:	0a078663          	beqz	a5,40010ac8 <net_ipaddr_parse+0xe0>
		return false;
	}

	if (*str == '[') {
40010a20:	05b00713          	li	a4,91
40010a24:	00060913          	mv	s2,a2
40010a28:	04e78e63          	beq	a5,a4,40010a84 <net_ipaddr_parse+0x9c>
		return parse_ipv6(str, str_len, addr, true);
	}

	for (count = i = 0; str[i] && i < str_len; i++) {
40010a2c:	00000713          	li	a4,0
40010a30:	00000793          	li	a5,0
		if (str[i] == ':') {
40010a34:	03a00613          	li	a2,58
	for (count = i = 0; str[i] && i < str_len; i++) {
40010a38:	00fa86b3          	add	a3,s5,a5
40010a3c:	0006c683          	lbu	a3,0(a3)
40010a40:	00068463          	beqz	a3,40010a48 <net_ipaddr_parse+0x60>
40010a44:	18879063          	bne	a5,s0,40010bc4 <net_ipaddr_parse+0x1dc>
			count++;
		}
	}

	if (count == 1) {
40010a48:	00100793          	li	a5,1
40010a4c:	18f71463          	bne	a4,a5,40010bd4 <net_ipaddr_parse+0x1ec>
		return parse_ipv4(str, str_len, addr, true);
40010a50:	00040593          	mv	a1,s0

#if defined(CONFIG_NET_IPV6) && !defined(CONFIG_NET_IPV4)
	return parse_ipv6(str, str_len, addr, false);
#endif
	return false;
}
40010a54:	05812403          	lw	s0,88(sp)
40010a58:	05c12083          	lw	ra,92(sp)
40010a5c:	05412483          	lw	s1,84(sp)
40010a60:	04c12983          	lw	s3,76(sp)
40010a64:	04812a03          	lw	s4,72(sp)
		return parse_ipv4(str, str_len, addr, true);
40010a68:	00090613          	mv	a2,s2
40010a6c:	000a8513          	mv	a0,s5
}
40010a70:	05012903          	lw	s2,80(sp)
40010a74:	04412a83          	lw	s5,68(sp)
		return parse_ipv4(str, str_len, addr, true);
40010a78:	00100693          	li	a3,1
}
40010a7c:	06010113          	addi	sp,sp,96
		return parse_ipv4(str, str_len, addr, true);
40010a80:	9bdff06f          	j	4001043c <parse_ipv4>
	len = MIN(INET6_ADDRSTRLEN, str_len);
40010a84:	02e00713          	li	a4,46
40010a88:	00058793          	mv	a5,a1
40010a8c:	00b77463          	bgeu	a4,a1,40010a94 <net_ipaddr_parse+0xac>
40010a90:	02e00793          	li	a5,46
	for (i = 0; i < len; i++) {
40010a94:	00000493          	li	s1,0
		if (!str[i]) {
40010a98:	009a8733          	add	a4,s5,s1
40010a9c:	00074703          	lbu	a4,0(a4)
40010aa0:	00070863          	beqz	a4,40010ab0 <net_ipaddr_parse+0xc8>
	for (i = 0; i < len; i++) {
40010aa4:	00148493          	addi	s1,s1,1
40010aa8:	fef4c8e3          	blt	s1,a5,40010a98 <net_ipaddr_parse+0xb0>
	len = MIN(INET6_ADDRSTRLEN, str_len);
40010aac:	00078493          	mv	s1,a5
		ptr = memchr(str, ']', len);
40010ab0:	00048613          	mv	a2,s1
40010ab4:	05d00593          	li	a1,93
40010ab8:	000a8513          	mv	a0,s5
40010abc:	dd4f80ef          	jal	ra,40009090 <memchr>
40010ac0:	00050993          	mv	s3,a0
		if (!ptr) {
40010ac4:	00051663          	bnez	a0,40010ad0 <net_ipaddr_parse+0xe8>
		return false;
40010ac8:	00000493          	li	s1,0
40010acc:	0640006f          	j	40010b30 <net_ipaddr_parse+0x148>
		end = MIN(len, ptr - (str + 1));
40010ad0:	001a8593          	addi	a1,s5,1
40010ad4:	40b50a33          	sub	s4,a0,a1
40010ad8:	0144d463          	bge	s1,s4,40010ae0 <net_ipaddr_parse+0xf8>
40010adc:	00048a13          	mv	s4,s1
		memcpy(ipaddr, str + 1, end);
40010ae0:	000a0613          	mv	a2,s4
40010ae4:	01010513          	addi	a0,sp,16
40010ae8:	d64f80ef          	jal	ra,4000904c <memcpy>
	ipaddr[end] = '\0';
40010aec:	040a0793          	addi	a5,s4,64
40010af0:	002787b3          	add	a5,a5,sp
40010af4:	fc078823          	sb	zero,-48(a5)
40010af8:	00200513          	li	a0,2
40010afc:	00490613          	addi	a2,s2,4
40010b00:	01010593          	addi	a1,sp,16
40010b04:	e48ff0ef          	jal	ra,4001014c <z_impl_net_addr_pton>
	if (ret < 0) {
40010b08:	fc0540e3          	bltz	a0,40010ac8 <net_ipaddr_parse+0xe0>
	net_sin6(addr)->sin6_family = AF_INET6;
40010b0c:	00200793          	li	a5,2
40010b10:	00f91023          	sh	a5,0(s2)
	if ((ptr + 1) < (str + str_len) && *(ptr + 1) == ':') {
40010b14:	008a8ab3          	add	s5,s5,s0
40010b18:	00198793          	addi	a5,s3,1
40010b1c:	0157f863          	bgeu	a5,s5,40010b2c <net_ipaddr_parse+0x144>
40010b20:	0019c703          	lbu	a4,1(s3)
40010b24:	03a00793          	li	a5,58
40010b28:	02f70863          	beq	a4,a5,40010b58 <net_ipaddr_parse+0x170>
		return true;
40010b2c:	00100493          	li	s1,1
}
40010b30:	05c12083          	lw	ra,92(sp)
40010b34:	05812403          	lw	s0,88(sp)
40010b38:	05012903          	lw	s2,80(sp)
40010b3c:	04c12983          	lw	s3,76(sp)
40010b40:	04812a03          	lw	s4,72(sp)
40010b44:	04412a83          	lw	s5,68(sp)
40010b48:	00048513          	mv	a0,s1
40010b4c:	05412483          	lw	s1,84(sp)
40010b50:	06010113          	addi	sp,sp,96
40010b54:	00008067          	ret
		len = str_len - end - 1 - 2;
40010b58:	ffd40413          	addi	s0,s0,-3
40010b5c:	41440433          	sub	s0,s0,s4
		ptr += 2;
40010b60:	00298593          	addi	a1,s3,2
		for (i = 0; i < len; i++) {
40010b64:	00000493          	li	s1,0
40010b68:	0484c463          	blt	s1,s0,40010bb0 <net_ipaddr_parse+0x1c8>
40010b6c:	00040493          	mv	s1,s0
		memcpy(ipaddr, ptr, len);
40010b70:	00048613          	mv	a2,s1
40010b74:	01010513          	addi	a0,sp,16
40010b78:	cd4f80ef          	jal	ra,4000904c <memcpy>
		ipaddr[len] = '\0';
40010b7c:	04048793          	addi	a5,s1,64
40010b80:	002784b3          	add	s1,a5,sp
40010b84:	fc048823          	sb	zero,-48(s1)
		ret = convert_port(ipaddr, &port);
40010b88:	00e10593          	addi	a1,sp,14
40010b8c:	01010513          	addi	a0,sp,16
40010b90:	898ff0ef          	jal	ra,4000fc28 <convert_port>
		if (!ret) {
40010b94:	f2050ae3          	beqz	a0,40010ac8 <net_ipaddr_parse+0xe0>
		net_sin6(addr)->sin6_port = htons(port);
40010b98:	00e15783          	lhu	a5,14(sp)
40010b9c:	00879713          	slli	a4,a5,0x8
40010ba0:	0087d793          	srli	a5,a5,0x8
40010ba4:	00f767b3          	or	a5,a4,a5
40010ba8:	00f91123          	sh	a5,2(s2)
		NET_DBG("IPv6 host %s port %d",
40010bac:	f81ff06f          	j	40010b2c <net_ipaddr_parse+0x144>
			if (!ptr[i]) {
40010bb0:	009987b3          	add	a5,s3,s1
40010bb4:	0027c783          	lbu	a5,2(a5)
40010bb8:	fa078ce3          	beqz	a5,40010b70 <net_ipaddr_parse+0x188>
		for (i = 0; i < len; i++) {
40010bbc:	00148493          	addi	s1,s1,1
40010bc0:	fa9ff06f          	j	40010b68 <net_ipaddr_parse+0x180>
		if (str[i] == ':') {
40010bc4:	00c69463          	bne	a3,a2,40010bcc <net_ipaddr_parse+0x1e4>
			count++;
40010bc8:	00170713          	addi	a4,a4,1
	for (count = i = 0; str[i] && i < str_len; i++) {
40010bcc:	00178793          	addi	a5,a5,1
40010bd0:	e69ff06f          	j	40010a38 <net_ipaddr_parse+0x50>
	if (!parse_ipv4(str, str_len, addr, false)) {
40010bd4:	00000693          	li	a3,0
40010bd8:	00090613          	mv	a2,s2
40010bdc:	00040593          	mv	a1,s0
40010be0:	000a8513          	mv	a0,s5
40010be4:	859ff0ef          	jal	ra,4001043c <parse_ipv4>
40010be8:	00050493          	mv	s1,a0
40010bec:	f40512e3          	bnez	a0,40010b30 <net_ipaddr_parse+0x148>
	len = MIN(INET6_ADDRSTRLEN, str_len);
40010bf0:	02e00793          	li	a5,46
40010bf4:	0087f463          	bgeu	a5,s0,40010bfc <net_ipaddr_parse+0x214>
40010bf8:	02e00413          	li	s0,46
	for (i = 0; i < len; i++) {
40010bfc:	00000993          	li	s3,0
		if (!str[i]) {
40010c00:	013a87b3          	add	a5,s5,s3
40010c04:	0007c783          	lbu	a5,0(a5)
40010c08:	00078863          	beqz	a5,40010c18 <net_ipaddr_parse+0x230>
	for (i = 0; i < len; i++) {
40010c0c:	00198993          	addi	s3,s3,1
40010c10:	fe89c8e3          	blt	s3,s0,40010c00 <net_ipaddr_parse+0x218>
	len = MIN(INET6_ADDRSTRLEN, str_len);
40010c14:	00040993          	mv	s3,s0
		memcpy(ipaddr, str, end);
40010c18:	00098613          	mv	a2,s3
40010c1c:	000a8593          	mv	a1,s5
40010c20:	01010513          	addi	a0,sp,16
40010c24:	c28f80ef          	jal	ra,4000904c <memcpy>
	ipaddr[end] = '\0';
40010c28:	04098793          	addi	a5,s3,64
40010c2c:	002789b3          	add	s3,a5,sp
40010c30:	fc098823          	sb	zero,-48(s3)
40010c34:	00200513          	li	a0,2
40010c38:	00490613          	addi	a2,s2,4
40010c3c:	01010593          	addi	a1,sp,16
40010c40:	d0cff0ef          	jal	ra,4001014c <z_impl_net_addr_pton>
	if (ret < 0) {
40010c44:	ee0546e3          	bltz	a0,40010b30 <net_ipaddr_parse+0x148>
	net_sin6(addr)->sin6_family = AF_INET6;
40010c48:	00200793          	li	a5,2
40010c4c:	00f91023          	sh	a5,0(s2)
40010c50:	eddff06f          	j	40010b2c <net_ipaddr_parse+0x144>

40010c54 <net_ipv4_unspecified_address>:

const struct in_addr *net_ipv4_unspecified_address(void)
{
	static const struct in_addr addr;

	return &addr;
40010c54:	4002c537          	lui	a0,0x4002c
}
40010c58:	b3c50513          	addi	a0,a0,-1220 # 4002bb3c <addr.1>
40010c5c:	00008067          	ret

40010c60 <net_ipv4_broadcast_address>:

const struct in_addr *net_ipv4_broadcast_address(void)
{
	static const struct in_addr addr = { { { 255, 255, 255, 255 } } };

	return &addr;
40010c60:	4002c537          	lui	a0,0x4002c
}
40010c64:	b3850513          	addi	a0,a0,-1224 # 4002bb38 <addr.0>
40010c68:	00008067          	ret

40010c6c <net_ipv6_unspecified_address>:
const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;

const struct in6_addr *net_ipv6_unspecified_address(void)
{
	return &in6addr_any;
40010c6c:	4002d537          	lui	a0,0x4002d
}
40010c70:	33450513          	addi	a0,a0,820 # 4002d334 <in6addr_any>
40010c74:	00008067          	ret

40010c78 <k_mutex_unlock.isra.0>:
40010c78:	5611706f          	j	400289d8 <z_impl_k_mutex_unlock>

40010c7c <mgmt_thread>:
	log_stack_usage(&mgmt_thread_data);
#endif
}

static void mgmt_thread(void)
{
40010c7c:	fc010113          	addi	sp,sp,-64
40010c80:	02912a23          	sw	s1,52(sp)
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
40010c84:	000104b7          	lui	s1,0x10
{
40010c88:	03212823          	sw	s2,48(sp)
40010c8c:	03312623          	sw	s3,44(sp)
40010c90:	03412423          	sw	s4,40(sp)
40010c94:	02112e23          	sw	ra,60(sp)
40010c98:	02812c23          	sw	s0,56(sp)
40010c9c:	03512223          	sw	s5,36(sp)
40010ca0:	03612023          	sw	s6,32(sp)
40010ca4:	01712e23          	sw	s7,28(sp)
40010ca8:	01812c23          	sw	s8,24(sp)
	return z_impl_k_msgq_get(msgq, data, timeout);
40010cac:	4003da37          	lui	s4,0x4003d
	return z_impl_k_mutex_lock(mutex, timeout);
40010cb0:	4003d937          	lui	s2,0x4003d
	return list->head;
40010cb4:	400319b7          	lui	s3,0x40031
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
40010cb8:	fff48493          	addi	s1,s1,-1 # ffff <__kernel_ram_size+0x3d6b>
	return z_impl_k_msgq_get(msgq, data, timeout);
40010cbc:	fff00613          	li	a2,-1
40010cc0:	fff00693          	li	a3,-1
40010cc4:	00810593          	addi	a1,sp,8
40010cc8:	b14a0513          	addi	a0,s4,-1260 # 4003cb14 <event_msgq>
40010ccc:	23d170ef          	jal	ra,40028708 <z_impl_k_msgq_get>
	} while (k_msgq_get(&event_msgq, dst, K_FOREVER) != 0);
40010cd0:	fe0516e3          	bnez	a0,40010cbc <mgmt_thread+0x40>
	return z_impl_k_mutex_lock(mutex, timeout);
40010cd4:	fff00593          	li	a1,-1
40010cd8:	fff00613          	li	a2,-1
40010cdc:	ad890513          	addi	a0,s2,-1320 # 4003cad8 <net_mgmt_callback_lock>
40010ce0:	39d170ef          	jal	ra,4002887c <z_impl_k_mutex_lock>
40010ce4:	a7c9a403          	lw	s0,-1412(s3) # 40030a7c <event_callbacks>
40010ce8:	a7c98b13          	addi	s6,s3,-1412
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
40010cec:	00040a63          	beqz	s0,40010d00 <mgmt_thread+0x84>
	return node->next;
40010cf0:	00042c03          	lw	s8,0(s0)
40010cf4:	00000b93          	li	s7,0
		if (NET_MGMT_EVENT_SYNCHRONOUS(cb->event_mask)) {
40010cf8:	08000ab7          	lui	s5,0x8000
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
40010cfc:	00041a63          	bnez	s0,40010d10 <mgmt_thread+0x94>
		/* take the lock to prevent changes to the callback structure during use */
		(void)k_mutex_lock(&net_mgmt_callback_lock, K_FOREVER);

		mgmt_run_callbacks(&mgmt_event);

		(void)k_mutex_unlock(&net_mgmt_callback_lock);
40010d00:	ad890513          	addi	a0,s2,-1320
40010d04:	f75ff0ef          	jal	ra,40010c78 <k_mutex_unlock.isra.0>
	z_impl_k_yield();
40010d08:	59c190ef          	jal	ra,4002a2a4 <z_impl_k_yield>
		mgmt_pop_event(&mgmt_event);
40010d0c:	fb1ff06f          	j	40010cbc <mgmt_thread+0x40>
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
40010d10:	00812583          	lw	a1,8(sp)
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
40010d14:	00842783          	lw	a5,8(s0)
40010d18:	00b7c733          	xor	a4,a5,a1
		      NET_MGMT_GET_LAYER_CODE(cb->event_mask)) ||
40010d1c:	00b7c6b3          	xor	a3,a5,a1
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
40010d20:	01c75713          	srli	a4,a4,0x1c
		    !(NET_MGMT_GET_LAYER_CODE(mgmt_event->event) ==
40010d24:	0106d693          	srli	a3,a3,0x10
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
40010d28:	00377713          	andi	a4,a4,3
		    !(NET_MGMT_GET_LAYER_CODE(mgmt_event->event) ==
40010d2c:	7ff6f693          	andi	a3,a3,2047
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
40010d30:	00d76733          	or	a4,a4,a3
40010d34:	06071463          	bnez	a4,40010d9c <mgmt_thread+0x120>
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
40010d38:	0095f733          	and	a4,a1,s1
		      NET_MGMT_GET_LAYER_CODE(cb->event_mask)) ||
40010d3c:	00070c63          	beqz	a4,40010d54 <mgmt_thread+0xd8>
		     NET_MGMT_GET_COMMAND(cb->event_mask) &&
40010d40:	0097f733          	and	a4,a5,s1
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
40010d44:	00070863          	beqz	a4,40010d54 <mgmt_thread+0xd8>
		     !(NET_MGMT_GET_COMMAND(mgmt_event->event) &
40010d48:	00f5f733          	and	a4,a1,a5
40010d4c:	00977733          	and	a4,a4,s1
		     NET_MGMT_GET_COMMAND(cb->event_mask) &&
40010d50:	04070663          	beqz	a4,40010d9c <mgmt_thread+0x120>
		if (NET_MGMT_EVENT_SYNCHRONOUS(cb->event_mask)) {
40010d54:	0157f7b3          	and	a5,a5,s5
			struct mgmt_event_wait *sync_data =
40010d58:	00442703          	lw	a4,4(s0)
			    sync_data->iface != mgmt_event->iface) {
40010d5c:	00c12603          	lw	a2,12(sp)
		if (NET_MGMT_EVENT_SYNCHRONOUS(cb->event_mask)) {
40010d60:	06078463          	beqz	a5,40010dc8 <mgmt_thread+0x14c>
			if (sync_data->iface &&
40010d64:	01872783          	lw	a5,24(a4)
40010d68:	00078463          	beqz	a5,40010d70 <mgmt_thread+0xf4>
40010d6c:	02c79863          	bne	a5,a2,40010d9c <mgmt_thread+0x120>
			cb->raised_event = mgmt_event->event;
40010d70:	00b42423          	sw	a1,8(s0)
			sync_data->iface = mgmt_event->iface;
40010d74:	00c72c23          	sw	a2,24(a4)
Z_GENLIST_REMOVE(slist, snode)
40010d78:	00042783          	lw	a5,0(s0)
40010d7c:	020b9c63          	bnez	s7,40010db4 <mgmt_thread+0x138>
40010d80:	004b2703          	lw	a4,4(s6)
	list->head = node;
40010d84:	00fb2023          	sw	a5,0(s6)
Z_GENLIST_REMOVE(slist, snode)
40010d88:	00e41463          	bne	s0,a4,40010d90 <mgmt_thread+0x114>
	list->tail = node;
40010d8c:	00fb2223          	sw	a5,4(s6)
			k_sem_give(cb->sync_call);
40010d90:	00442503          	lw	a0,4(s0)
	parent->next = child;
40010d94:	00042023          	sw	zero,0(s0)
	z_impl_k_sem_give(sem);
40010d98:	7ed170ef          	jal	ra,40028d84 <z_impl_k_sem_give>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
40010d9c:	00000793          	li	a5,0
40010da0:	000c0463          	beqz	s8,40010da8 <mgmt_thread+0x12c>
	return node->next;
40010da4:	000c2783          	lw	a5,0(s8)
40010da8:	000c0413          	mv	s0,s8
40010dac:	00078c13          	mv	s8,a5
40010db0:	f4dff06f          	j	40010cfc <mgmt_thread+0x80>
	parent->next = child;
40010db4:	00fba023          	sw	a5,0(s7)
Z_GENLIST_REMOVE(slist, snode)
40010db8:	004b2783          	lw	a5,4(s6)
40010dbc:	fcf41ae3          	bne	s0,a5,40010d90 <mgmt_thread+0x114>
	list->tail = node;
40010dc0:	017b2223          	sw	s7,4(s6)
}
40010dc4:	fcdff06f          	j	40010d90 <mgmt_thread+0x114>
			cb->handler(cb, mgmt_event->event, mgmt_event->iface);
40010dc8:	00040513          	mv	a0,s0
40010dcc:	000700e7          	jalr	a4
			prev = &cb->node;
40010dd0:	00040b93          	mv	s7,s0
40010dd4:	fc9ff06f          	j	40010d9c <mgmt_thread+0x120>

40010dd8 <net_mgmt_add_event_callback>:

	return ret;
}

void net_mgmt_add_event_callback(struct net_mgmt_event_callback *cb)
{
40010dd8:	ff010113          	addi	sp,sp,-16
40010ddc:	00812423          	sw	s0,8(sp)
40010de0:	00112623          	sw	ra,12(sp)
40010de4:	00912223          	sw	s1,4(sp)
40010de8:	00050413          	mv	s0,a0
	return z_impl_k_mutex_lock(mutex, timeout);
40010dec:	4003d4b7          	lui	s1,0x4003d
40010df0:	fff00593          	li	a1,-1
40010df4:	fff00613          	li	a2,-1
40010df8:	ad848513          	addi	a0,s1,-1320 # 4003cad8 <net_mgmt_callback_lock>
40010dfc:	281170ef          	jal	ra,4002887c <z_impl_k_mutex_lock>
	return list->head;
40010e00:	400317b7          	lui	a5,0x40031
40010e04:	a7c78793          	addi	a5,a5,-1412 # 40030a7c <event_callbacks>
40010e08:	0007a703          	lw	a4,0(a5)
	parent->next = child;
40010e0c:	00e42023          	sw	a4,0(s0)
Z_GENLIST_PREPEND(slist, snode)
40010e10:	0047a703          	lw	a4,4(a5)
	list->head = node;
40010e14:	0087a023          	sw	s0,0(a5)
Z_GENLIST_PREPEND(slist, snode)
40010e18:	00071463          	bnez	a4,40010e20 <net_mgmt_add_event_callback+0x48>
	list->tail = node;
40010e1c:	0087a223          	sw	s0,4(a5)
	global_event_mask |= event_mask;
40010e20:	40031737          	lui	a4,0x40031
40010e24:	00842783          	lw	a5,8(s0)
40010e28:	a8472683          	lw	a3,-1404(a4) # 40030a84 <global_event_mask>
	sys_slist_prepend(&event_callbacks, &cb->node);

	mgmt_add_event_mask(cb->event_mask);

	(void)k_mutex_unlock(&net_mgmt_callback_lock);
}
40010e2c:	00812403          	lw	s0,8(sp)
40010e30:	00c12083          	lw	ra,12(sp)
	global_event_mask |= event_mask;
40010e34:	00d7e7b3          	or	a5,a5,a3
	(void)k_mutex_unlock(&net_mgmt_callback_lock);
40010e38:	ad848513          	addi	a0,s1,-1320
}
40010e3c:	00412483          	lw	s1,4(sp)
	global_event_mask |= event_mask;
40010e40:	a8f72223          	sw	a5,-1404(a4)
}
40010e44:	01010113          	addi	sp,sp,16
	(void)k_mutex_unlock(&net_mgmt_callback_lock);
40010e48:	e31ff06f          	j	40010c78 <k_mutex_unlock.isra.0>

40010e4c <net_mgmt_del_event_callback>:

void net_mgmt_del_event_callback(struct net_mgmt_event_callback *cb)
{
40010e4c:	ff010113          	addi	sp,sp,-16
40010e50:	00812423          	sw	s0,8(sp)
40010e54:	00112623          	sw	ra,12(sp)
40010e58:	00912223          	sw	s1,4(sp)
40010e5c:	00050413          	mv	s0,a0
40010e60:	4003d4b7          	lui	s1,0x4003d
40010e64:	fff00593          	li	a1,-1
40010e68:	fff00613          	li	a2,-1
40010e6c:	ad848513          	addi	a0,s1,-1320 # 4003cad8 <net_mgmt_callback_lock>
40010e70:	20d170ef          	jal	ra,4002887c <z_impl_k_mutex_lock>
	return list->head;
40010e74:	400317b7          	lui	a5,0x40031
40010e78:	a7c7a703          	lw	a4,-1412(a5) # 40030a7c <event_callbacks>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40010e7c:	00000693          	li	a3,0
40010e80:	a7c78793          	addi	a5,a5,-1412
40010e84:	02070263          	beqz	a4,40010ea8 <net_mgmt_del_event_callback+0x5c>
40010e88:	06e41c63          	bne	s0,a4,40010f00 <net_mgmt_del_event_callback+0xb4>
	return node->next;
40010e8c:	00042703          	lw	a4,0(s0)
Z_GENLIST_REMOVE(slist, snode)
40010e90:	04069e63          	bnez	a3,40010eec <net_mgmt_del_event_callback+0xa0>
40010e94:	0047a683          	lw	a3,4(a5)
	list->head = node;
40010e98:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_REMOVE(slist, snode)
40010e9c:	00d41463          	bne	s0,a3,40010ea4 <net_mgmt_del_event_callback+0x58>
	list->tail = node;
40010ea0:	00e7a223          	sw	a4,4(a5)
	parent->next = child;
40010ea4:	00042023          	sw	zero,0(s0)
	return list->head;
40010ea8:	0007a783          	lw	a5,0(a5)
	global_event_mask = 0U;
40010eac:	40031637          	lui	a2,0x40031
40010eb0:	a8062223          	sw	zero,-1404(a2) # 40030a84 <global_event_mask>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
40010eb4:	00000713          	li	a4,0
40010eb8:	00078463          	beqz	a5,40010ec0 <net_mgmt_del_event_callback+0x74>
	return node->next;
40010ebc:	0007a703          	lw	a4,0(a5)
40010ec0:	00000593          	li	a1,0
40010ec4:	00000693          	li	a3,0
40010ec8:	04079263          	bnez	a5,40010f0c <net_mgmt_del_event_callback+0xc0>
40010ecc:	00058463          	beqz	a1,40010ed4 <net_mgmt_del_event_callback+0x88>
40010ed0:	a8d62223          	sw	a3,-1404(a2)
	sys_slist_find_and_remove(&event_callbacks, &cb->node);

	mgmt_rebuild_global_event_mask();

	(void)k_mutex_unlock(&net_mgmt_callback_lock);
}
40010ed4:	00812403          	lw	s0,8(sp)
40010ed8:	00c12083          	lw	ra,12(sp)
	(void)k_mutex_unlock(&net_mgmt_callback_lock);
40010edc:	ad848513          	addi	a0,s1,-1320
}
40010ee0:	00412483          	lw	s1,4(sp)
40010ee4:	01010113          	addi	sp,sp,16
	(void)k_mutex_unlock(&net_mgmt_callback_lock);
40010ee8:	d91ff06f          	j	40010c78 <k_mutex_unlock.isra.0>
	parent->next = child;
40010eec:	00e6a023          	sw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
40010ef0:	0047a703          	lw	a4,4(a5)
40010ef4:	fae418e3          	bne	s0,a4,40010ea4 <net_mgmt_del_event_callback+0x58>
	list->tail = node;
40010ef8:	00d7a223          	sw	a3,4(a5)
}
40010efc:	fa9ff06f          	j	40010ea4 <net_mgmt_del_event_callback+0x58>
	return node->next;
40010f00:	00070693          	mv	a3,a4
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40010f04:	00072703          	lw	a4,0(a4)
40010f08:	f7dff06f          	j	40010e84 <net_mgmt_del_event_callback+0x38>
	global_event_mask |= event_mask;
40010f0c:	0087a783          	lw	a5,8(a5)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
40010f10:	00000593          	li	a1,0
	global_event_mask |= event_mask;
40010f14:	00f6e6b3          	or	a3,a3,a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
40010f18:	00070463          	beqz	a4,40010f20 <net_mgmt_del_event_callback+0xd4>
	return node->next;
40010f1c:	00072583          	lw	a1,0(a4)
40010f20:	00070793          	mv	a5,a4
40010f24:	00058713          	mv	a4,a1
40010f28:	00100593          	li	a1,1
40010f2c:	f9dff06f          	j	40010ec8 <net_mgmt_del_event_callback+0x7c>

40010f30 <net_mgmt_event_notify_with_info>:
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
40010f30:	400317b7          	lui	a5,0x40031
40010f34:	a847a703          	lw	a4,-1404(a5) # 40030a84 <global_event_mask>
	return (((NET_MGMT_GET_LAYER(mgmt_event) &
40010f38:	01c55693          	srli	a3,a0,0x1c
		((NET_MGMT_GET_LAYER_CODE(mgmt_event) &
40010f3c:	01055613          	srli	a2,a0,0x10
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
40010f40:	01c75793          	srli	a5,a4,0x1c
40010f44:	fff7c793          	not	a5,a5
40010f48:	00d7f7b3          	and	a5,a5,a3
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
40010f4c:	01075693          	srli	a3,a4,0x10
40010f50:	fff6c693          	not	a3,a3
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
40010f54:	fff74713          	not	a4,a4
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
40010f58:	00c6f6b3          	and	a3,a3,a2
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
40010f5c:	00a77733          	and	a4,a4,a0
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
40010f60:	0037f793          	andi	a5,a5,3
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
40010f64:	7ff6f693          	andi	a3,a3,2047
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
40010f68:	01071713          	slli	a4,a4,0x10
		 NET_MGMT_GET_LAYER_CODE(mgmt_event)) &&
40010f6c:	00d7e7b3          	or	a5,a5,a3
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
40010f70:	01075713          	srli	a4,a4,0x10
		 NET_MGMT_GET_LAYER_CODE(mgmt_event)) &&
40010f74:	00e7e7b3          	or	a5,a5,a4
40010f78:	08079863          	bnez	a5,40011008 <net_mgmt_event_notify_with_info+0xd8>

void net_mgmt_event_notify_with_info(uint32_t mgmt_event, struct net_if *iface,
				     const void *info, size_t length)
{
40010f7c:	fe010113          	addi	sp,sp,-32
40010f80:	00812c23          	sw	s0,24(sp)
40010f84:	01212823          	sw	s2,16(sp)
40010f88:	00112e23          	sw	ra,28(sp)
40010f8c:	00912a23          	sw	s1,20(sp)
40010f90:	01312623          	sw	s3,12(sp)
40010f94:	00050413          	mv	s0,a0
40010f98:	00058913          	mv	s2,a1
40010f9c:	4003d9b7          	lui	s3,0x4003d
40010fa0:	fff00593          	li	a1,-1
40010fa4:	fff00613          	li	a2,-1
40010fa8:	aec98513          	addi	a0,s3,-1300 # 4003caec <net_mgmt_event_lock>
40010fac:	0d1170ef          	jal	ra,4002887c <z_impl_k_mutex_lock>
	memset(&new_event, 0, sizeof(struct mgmt_event_entry));
40010fb0:	400314b7          	lui	s1,0x40031
40010fb4:	00800613          	li	a2,8
40010fb8:	00000593          	li	a1,0
40010fbc:	a7448513          	addi	a0,s1,-1420 # 40030a74 <new_event>
40010fc0:	8b0f80ef          	jal	ra,40009070 <memset>
	new_event.event = mgmt_event;
40010fc4:	a7448793          	addi	a5,s1,-1420
40010fc8:	0087a023          	sw	s0,0(a5)
	new_event.iface = iface;
40010fcc:	0127a223          	sw	s2,4(a5)
	return z_impl_k_msgq_put(msgq, data, timeout);
40010fd0:	4003d537          	lui	a0,0x4003d
40010fd4:	a7448593          	addi	a1,s1,-1420
40010fd8:	00100613          	li	a2,1
40010fdc:	00000693          	li	a3,0
40010fe0:	b1450513          	addi	a0,a0,-1260 # 4003cb14 <event_msgq>
40010fe4:	604170ef          	jal	ra,400285e8 <z_impl_k_msgq_put>
			NET_MGMT_GET_LAYER_CODE(mgmt_event),
			NET_MGMT_GET_COMMAND(mgmt_event));

		mgmt_push_event(mgmt_event, iface, info, length);
	}
}
40010fe8:	01812403          	lw	s0,24(sp)
40010fec:	01c12083          	lw	ra,28(sp)
40010ff0:	01412483          	lw	s1,20(sp)
40010ff4:	01012903          	lw	s2,16(sp)
	(void)k_mutex_unlock(&net_mgmt_event_lock);
40010ff8:	aec98513          	addi	a0,s3,-1300
}
40010ffc:	00c12983          	lw	s3,12(sp)
40011000:	02010113          	addi	sp,sp,32
	(void)k_mutex_unlock(&net_mgmt_event_lock);
40011004:	c75ff06f          	j	40010c78 <k_mutex_unlock.isra.0>
40011008:	00008067          	ret

4001100c <net_mgmt_event_init>:
				    raised_event, NULL, info, info_length,
				    timeout);
}

void net_mgmt_event_init(void)
{
4001100c:	fe010113          	addi	sp,sp,-32
40011010:	00112e23          	sw	ra,28(sp)
40011014:	00812c23          	sw	s0,24(sp)
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
40011018:	00000793          	li	a5,0
4001101c:	00000813          	li	a6,0
40011020:	40031437          	lui	s0,0x40031
40011024:	400116b7          	lui	a3,0x40011
40011028:	400345b7          	lui	a1,0x40034
4001102c:	01012623          	sw	a6,12(sp)
40011030:	00f12423          	sw	a5,8(sp)
40011034:	00012023          	sw	zero,0(sp)
40011038:	fff00893          	li	a7,-1
4001103c:	00000813          	li	a6,0
40011040:	00000713          	li	a4,0
40011044:	c7c68693          	addi	a3,a3,-900 # 40010c7c <mgmt_thread>
40011048:	30000613          	li	a2,768
4001104c:	89058593          	addi	a1,a1,-1904 # 40033890 <mgmt_stack>
40011050:	ec840513          	addi	a0,s0,-312 # 40030ec8 <mgmt_thread_data>
40011054:	39c170ef          	jal	ra,400283f0 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
40011058:	ec840513          	addi	a0,s0,-312
	k_thread_name_set(&mgmt_thread_data, "net_mgmt");

	NET_DBG("Net MGMT initialized: queue of %u entries, stack size of %u",
		CONFIG_NET_MGMT_EVENT_QUEUE_SIZE,
		CONFIG_NET_MGMT_EVENT_STACK_SIZE);
}
4001105c:	01812403          	lw	s0,24(sp)
40011060:	01c12083          	lw	ra,28(sp)
40011064:	4002d5b7          	lui	a1,0x4002d
40011068:	34458593          	addi	a1,a1,836 # 4002d344 <in6addr_any+0x10>
4001106c:	02010113          	addi	sp,sp,32
40011070:	0b41706f          	j	40028124 <z_impl_k_thread_name_set>

40011074 <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
40011074:	00054503          	lbu	a0,0(a0)
40011078:	f00007b7          	lui	a5,0xf0000
4001107c:	01851513          	slli	a0,a0,0x18
40011080:	00f57533          	and	a0,a0,a5
40011084:	200007b7          	lui	a5,0x20000
40011088:	00f50533          	add	a0,a0,a5
}
4001108c:	00153513          	seqz	a0,a0
40011090:	00008067          	ret

40011094 <net_ipv6_is_addr_unspecified>:
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40011094:	00154703          	lbu	a4,1(a0)
40011098:	00054683          	lbu	a3,0(a0)
{
4001109c:	00050793          	mv	a5,a0
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
400110a0:	00871713          	slli	a4,a4,0x8
400110a4:	00d76733          	or	a4,a4,a3
400110a8:	00254683          	lbu	a3,2(a0)
400110ac:	01069693          	slli	a3,a3,0x10
400110b0:	00e6e6b3          	or	a3,a3,a4
400110b4:	00354703          	lbu	a4,3(a0)
400110b8:	01871713          	slli	a4,a4,0x18
400110bc:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
400110c0:	08071863          	bnez	a4,40011150 <net_ipv6_is_addr_unspecified+0xbc>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
400110c4:	00554703          	lbu	a4,5(a0)
400110c8:	00454683          	lbu	a3,4(a0)
400110cc:	00871713          	slli	a4,a4,0x8
400110d0:	00d76733          	or	a4,a4,a3
400110d4:	00654683          	lbu	a3,6(a0)
400110d8:	01069693          	slli	a3,a3,0x10
400110dc:	00e6e6b3          	or	a3,a3,a4
400110e0:	00754703          	lbu	a4,7(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
400110e4:	00000513          	li	a0,0
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
400110e8:	01871713          	slli	a4,a4,0x18
400110ec:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
400110f0:	06071263          	bnez	a4,40011154 <net_ipv6_is_addr_unspecified+0xc0>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
400110f4:	0097c703          	lbu	a4,9(a5) # 20000009 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1a0a1f09>
400110f8:	0087c683          	lbu	a3,8(a5)
400110fc:	00871713          	slli	a4,a4,0x8
40011100:	00d76733          	or	a4,a4,a3
40011104:	00a7c683          	lbu	a3,10(a5)
40011108:	01069693          	slli	a3,a3,0x10
4001110c:	00e6e6b3          	or	a3,a3,a4
40011110:	00b7c703          	lbu	a4,11(a5)
40011114:	01871713          	slli	a4,a4,0x18
40011118:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001111c:	02071c63          	bnez	a4,40011154 <net_ipv6_is_addr_unspecified+0xc0>
		UNALIGNED_GET(&addr->s6_addr32[3]) == 0;
40011120:	00d7c683          	lbu	a3,13(a5)
40011124:	00c7c703          	lbu	a4,12(a5)
40011128:	00f7c503          	lbu	a0,15(a5)
4001112c:	00869693          	slli	a3,a3,0x8
40011130:	00e6e6b3          	or	a3,a3,a4
40011134:	00e7c703          	lbu	a4,14(a5)
40011138:	01851513          	slli	a0,a0,0x18
4001113c:	01071713          	slli	a4,a4,0x10
40011140:	00d76733          	or	a4,a4,a3
40011144:	00e56533          	or	a0,a0,a4
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40011148:	00153513          	seqz	a0,a0
4001114c:	00008067          	ret
40011150:	00000513          	li	a0,0
}
40011154:	00008067          	ret

40011158 <check_used_port>:
#if defined(CONFIG_NET_UDP) || defined(CONFIG_NET_TCP)
static int check_used_port(enum net_ip_protocol proto,
			   uint16_t local_port,
			   const struct sockaddr *local_addr)

{
40011158:	fe010113          	addi	sp,sp,-32
4001115c:	00812c23          	sw	s0,24(sp)
40011160:	40032437          	lui	s0,0x40032
40011164:	ee440413          	addi	s0,s0,-284 # 40031ee4 <contexts>
40011168:	00912a23          	sw	s1,20(sp)
4001116c:	01212823          	sw	s2,16(sp)
40011170:	01312623          	sw	s3,12(sp)
40011174:	01412423          	sw	s4,8(sp)
40011178:	01512223          	sw	s5,4(sp)
4001117c:	01612023          	sw	s6,0(sp)
40011180:	00112e23          	sw	ra,28(sp)
40011184:	00050913          	mv	s2,a0
40011188:	00058993          	mv	s3,a1
4001118c:	00060493          	mv	s1,a2
40011190:	4b040a13          	addi	s4,s0,1200
		      net_sin((struct sockaddr *)&
			      contexts[i].local)->sin_port == local_port)) {
			continue;
		}

		if (IS_ENABLED(CONFIG_NET_IPV6) &&
40011194:	00200a93          	li	s5,2
							     sin6_addr,
				    &((struct sockaddr_in6 *)
				      local_addr)->sin6_addr)) {
				return -EEXIST;
			}
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40011198:	00100b13          	li	s6,1
	return context->flags & NET_CONTEXT_IN_USE;
4001119c:	07445783          	lhu	a5,116(s0)
		if (!net_context_is_used(&contexts[i])) {
400111a0:	0017f793          	andi	a5,a5,1
400111a4:	02079c63          	bnez	a5,400111dc <check_used_port+0x84>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
400111a8:	07840413          	addi	s0,s0,120
400111ac:	fe8a18e3          	bne	s4,s0,4001119c <check_used_port+0x44>
				return -EEXIST;
			}
		}
	}

	return 0;
400111b0:	00000513          	li	a0,0
}
400111b4:	01c12083          	lw	ra,28(sp)
400111b8:	01812403          	lw	s0,24(sp)
400111bc:	01412483          	lw	s1,20(sp)
400111c0:	01012903          	lw	s2,16(sp)
400111c4:	00c12983          	lw	s3,12(sp)
400111c8:	00812a03          	lw	s4,8(sp)
400111cc:	00412a83          	lw	s5,4(sp)
400111d0:	00012b03          	lw	s6,0(sp)
400111d4:	02010113          	addi	sp,sp,32
400111d8:	00008067          	ret
		if (!(net_context_get_proto(&contexts[i]) == proto &&
400111dc:	07245783          	lhu	a5,114(s0)
400111e0:	fd2794e3          	bne	a5,s2,400111a8 <check_used_port+0x50>
400111e4:	02245783          	lhu	a5,34(s0)
400111e8:	fd3790e3          	bne	a5,s3,400111a8 <check_used_port+0x50>
		    local_addr->sa_family == AF_INET6) {
400111ec:	0004d783          	lhu	a5,0(s1)
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
400111f0:	03579263          	bne	a5,s5,40011214 <check_used_port+0xbc>
			if (net_sin6_ptr(&contexts[i].local)->sin6_addr == NULL) {
400111f4:	02442503          	lw	a0,36(s0)
400111f8:	fa0508e3          	beqz	a0,400111a8 <check_used_port+0x50>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
400111fc:	01000613          	li	a2,16
40011200:	00448593          	addi	a1,s1,4
40011204:	dc9f70ef          	jal	ra,40008fcc <memcmp>
			if (net_ipv6_addr_cmp(
40011208:	fa0510e3          	bnez	a0,400111a8 <check_used_port+0x50>
				return -EEXIST;
4001120c:	fef00513          	li	a0,-17
40011210:	fa5ff06f          	j	400111b4 <check_used_port+0x5c>
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40011214:	f9679ae3          	bne	a5,s6,400111a8 <check_used_port+0x50>
			if (net_sin_ptr(&contexts[i].local)->sin_addr == NULL) {
40011218:	02442783          	lw	a5,36(s0)
4001121c:	f80786e3          	beqz	a5,400111a8 <check_used_port+0x50>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40011220:	0054c703          	lbu	a4,5(s1)
40011224:	0044c683          	lbu	a3,4(s1)
40011228:	0017c603          	lbu	a2,1(a5)
4001122c:	00871713          	slli	a4,a4,0x8
40011230:	00d76733          	or	a4,a4,a3
40011234:	0064c683          	lbu	a3,6(s1)
40011238:	00861613          	slli	a2,a2,0x8
4001123c:	01069693          	slli	a3,a3,0x10
40011240:	00e6e6b3          	or	a3,a3,a4
40011244:	0074c703          	lbu	a4,7(s1)
40011248:	01871713          	slli	a4,a4,0x18
4001124c:	00d76733          	or	a4,a4,a3
40011250:	0007c683          	lbu	a3,0(a5)
40011254:	00d66633          	or	a2,a2,a3
40011258:	0027c683          	lbu	a3,2(a5)
4001125c:	0037c783          	lbu	a5,3(a5)
40011260:	01069693          	slli	a3,a3,0x10
40011264:	00c6e6b3          	or	a3,a3,a2
40011268:	01879793          	slli	a5,a5,0x18
4001126c:	00d7e7b3          	or	a5,a5,a3
			if (net_ipv4_addr_cmp(
40011270:	f2f71ce3          	bne	a4,a5,400111a8 <check_used_port+0x50>
40011274:	f99ff06f          	j	4001120c <check_used_port+0xb4>

40011278 <find_available_port>:

static uint16_t find_available_port(struct net_context *context,
				    const struct sockaddr *addr)
{
40011278:	fe010113          	addi	sp,sp,-32
4001127c:	00912a23          	sw	s1,20(sp)
40011280:	01212823          	sw	s2,16(sp)
40011284:	01312623          	sw	s3,12(sp)
40011288:	01412423          	sw	s4,8(sp)
4001128c:	00112e23          	sw	ra,28(sp)
40011290:	00812c23          	sw	s0,24(sp)
40011294:	00050493          	mv	s1,a0
40011298:	00058913          	mv	s2,a1
	uint16_t local_port;

	do {
		local_port = sys_rand32_get() | 0x8000;
4001129c:	ffff8a37          	lui	s4,0xffff8
	} while (check_used_port(net_context_get_proto(context),
				 htons(local_port), addr) == -EEXIST);
400112a0:	fef00993          	li	s3,-17
400112a4:	ad0f80ef          	jal	ra,40009574 <z_impl_sys_rand32_get>
		local_port = sys_rand32_get() | 0x8000;
400112a8:	014567b3          	or	a5,a0,s4
400112ac:	00879413          	slli	s0,a5,0x8
400112b0:	01079793          	slli	a5,a5,0x10
400112b4:	0107d793          	srli	a5,a5,0x10
400112b8:	0087d793          	srli	a5,a5,0x8
400112bc:	00f46433          	or	s0,s0,a5
400112c0:	01041413          	slli	s0,s0,0x10
	} while (check_used_port(net_context_get_proto(context),
400112c4:	0724d503          	lhu	a0,114(s1)
400112c8:	01045413          	srli	s0,s0,0x10
400112cc:	00090613          	mv	a2,s2
400112d0:	00040593          	mv	a1,s0
400112d4:	e85ff0ef          	jal	ra,40011158 <check_used_port>
				 htons(local_port), addr) == -EEXIST);
400112d8:	fd3506e3          	beq	a0,s3,400112a4 <find_available_port+0x2c>

	return htons(local_port);
}
400112dc:	01c12083          	lw	ra,28(sp)
400112e0:	00040513          	mv	a0,s0
400112e4:	01812403          	lw	s0,24(sp)
400112e8:	01412483          	lw	s1,20(sp)
400112ec:	01012903          	lw	s2,16(sp)
400112f0:	00c12983          	lw	s3,12(sp)
400112f4:	00812a03          	lw	s4,8(sp)
400112f8:	02010113          	addi	sp,sp,32
400112fc:	00008067          	ret

40011300 <context_write_data>:
static int context_write_data(struct net_pkt *pkt, const void *buf,
			      int buf_len, const struct msghdr *msghdr)
{
	int ret = 0;

	if (msghdr) {
40011300:	06069463          	bnez	a3,40011368 <context_write_data+0x68>
			if (buf_len == 0) {
				break;
			}
		}
	} else {
		ret = net_pkt_write(pkt, buf, buf_len);
40011304:	4150206f          	j	40013f18 <net_pkt_write>
			int len = MIN(msghdr->msg_iov[i].iov_len, buf_len);
40011308:	0084a783          	lw	a5,8(s1)
4001130c:	00391713          	slli	a4,s2,0x3
40011310:	00e787b3          	add	a5,a5,a4
40011314:	0047a983          	lw	s3,4(a5)
40011318:	01347463          	bgeu	s0,s3,40011320 <context_write_data+0x20>
4001131c:	00040993          	mv	s3,s0
			ret = net_pkt_write(pkt, msghdr->msg_iov[i].iov_base,
40011320:	0007a583          	lw	a1,0(a5)
40011324:	00098613          	mv	a2,s3
40011328:	000a0513          	mv	a0,s4
4001132c:	3ed020ef          	jal	ra,40013f18 <net_pkt_write>
			if (ret < 0) {
40011330:	00054c63          	bltz	a0,40011348 <context_write_data+0x48>
			buf_len -= len;
40011334:	41340433          	sub	s0,s0,s3
			if (buf_len == 0) {
40011338:	00040863          	beqz	s0,40011348 <context_write_data+0x48>
		for (i = 0; i < msghdr->msg_iovlen; i++) {
4001133c:	00190913          	addi	s2,s2,1
40011340:	00c4a783          	lw	a5,12(s1)
40011344:	fcf962e3          	bltu	s2,a5,40011308 <context_write_data+0x8>
	}

	return ret;
}
40011348:	01c12083          	lw	ra,28(sp)
4001134c:	01812403          	lw	s0,24(sp)
40011350:	01412483          	lw	s1,20(sp)
40011354:	01012903          	lw	s2,16(sp)
40011358:	00c12983          	lw	s3,12(sp)
4001135c:	00812a03          	lw	s4,8(sp)
40011360:	02010113          	addi	sp,sp,32
40011364:	00008067          	ret
{
40011368:	fe010113          	addi	sp,sp,-32
4001136c:	00812c23          	sw	s0,24(sp)
40011370:	00912a23          	sw	s1,20(sp)
40011374:	01212823          	sw	s2,16(sp)
40011378:	01412423          	sw	s4,8(sp)
4001137c:	00112e23          	sw	ra,28(sp)
40011380:	00050a13          	mv	s4,a0
40011384:	01312623          	sw	s3,12(sp)
40011388:	00060413          	mv	s0,a2
4001138c:	00068493          	mv	s1,a3
		for (i = 0; i < msghdr->msg_iovlen; i++) {
40011390:	00000913          	li	s2,0
	int ret = 0;
40011394:	00000513          	li	a0,0
40011398:	fa9ff06f          	j	40011340 <context_write_data+0x40>

4001139c <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
4001139c:	4e01706f          	j	4002887c <z_impl_k_mutex_lock>

400113a0 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
400113a0:	6381706f          	j	400289d8 <z_impl_k_mutex_unlock>

400113a4 <net_context_packet_received>:
enum net_verdict net_context_packet_received(struct net_conn *conn,
					     struct net_pkt *pkt,
					     union net_ip_header *ip_hdr,
					     union net_proto_header *proto_hdr,
					     void *user_data)
{
400113a4:	fd010113          	addi	sp,sp,-48
400113a8:	03212023          	sw	s2,32(sp)
400113ac:	40032937          	lui	s2,0x40032
400113b0:	02912223          	sw	s1,36(sp)
400113b4:	01512a23          	sw	s5,20(sp)
400113b8:	01612823          	sw	s6,16(sp)
400113bc:	01712623          	sw	s7,12(sp)
400113c0:	00068b13          	mv	s6,a3
400113c4:	ee490793          	addi	a5,s2,-284 # 40031ee4 <contexts>
400113c8:	02112623          	sw	ra,44(sp)
400113cc:	02812423          	sw	s0,40(sp)
400113d0:	01312e23          	sw	s3,28(sp)
400113d4:	01412c23          	sw	s4,24(sp)
400113d8:	00058493          	mv	s1,a1
400113dc:	00060a93          	mv	s5,a2
400113e0:	00070b93          	mv	s7,a4
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
400113e4:	00000813          	li	a6,0
400113e8:	ee490913          	addi	s2,s2,-284
400113ec:	00a00693          	li	a3,10
400113f0:	0747d703          	lhu	a4,116(a5)
		if (!net_context_is_used(&contexts[i])) {
400113f4:	00177713          	andi	a4,a4,1
400113f8:	08070063          	beqz	a4,40011478 <net_context_packet_received+0xd4>
		if (contexts[i].conn_handler == conn_handler) {
400113fc:	0447a703          	lw	a4,68(a5)
40011400:	06e51c63          	bne	a0,a4,40011478 <net_context_packet_received+0xd4>
			return &contexts[i];
40011404:	07800793          	li	a5,120
40011408:	02f80433          	mul	s0,a6,a5
	enum net_verdict verdict = NET_DROP;

	NET_ASSERT(context);
	NET_ASSERT(net_pkt_iface(pkt));

	k_mutex_lock(&context->lock, K_FOREVER);
4001140c:	fff00593          	li	a1,-1
40011410:	fff00613          	li	a2,-1
40011414:	00c40a13          	addi	s4,s0,12
40011418:	01490a33          	add	s4,s2,s4
4001141c:	000a0513          	mv	a0,s4
40011420:	f7dff0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
static inline void net_context_set_iface(struct net_context *context,
					 struct net_if *iface)
{
	NET_ASSERT(iface);

	context->iface = net_if_get_by_iface(iface);
40011424:	0184a503          	lw	a0,24(s1)
			return &contexts[i];
40011428:	008909b3          	add	s3,s2,s0
4001142c:	9b4fe0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
40011430:	06a98b23          	sb	a0,118(s3)
	pkt->context = ctx;
40011434:	0134aa23          	sw	s3,20(s1)
	net_pkt_set_context(pkt, context);

	/* If there is no callback registered, then we can only drop
	 * the packet.
	 */
	if (!context->recv_cb) {
40011438:	0489a783          	lw	a5,72(s3)
4001143c:	06079463          	bnez	a5,400114a4 <net_context_packet_received+0x100>
	verdict = NET_OK;

	return verdict;

unlock:
	k_mutex_unlock(&context->lock);
40011440:	000a0513          	mv	a0,s4
40011444:	f5dff0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>

	return verdict;
40011448:	00200513          	li	a0,2
}
4001144c:	02c12083          	lw	ra,44(sp)
40011450:	02812403          	lw	s0,40(sp)
40011454:	02412483          	lw	s1,36(sp)
40011458:	02012903          	lw	s2,32(sp)
4001145c:	01c12983          	lw	s3,28(sp)
40011460:	01812a03          	lw	s4,24(sp)
40011464:	01412a83          	lw	s5,20(sp)
40011468:	01012b03          	lw	s6,16(sp)
4001146c:	00c12b83          	lw	s7,12(sp)
40011470:	03010113          	addi	sp,sp,48
40011474:	00008067          	ret
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
40011478:	00180813          	addi	a6,a6,1
4001147c:	07878793          	addi	a5,a5,120
40011480:	f6d818e3          	bne	a6,a3,400113f0 <net_context_packet_received+0x4c>
	k_mutex_lock(&context->lock, K_FOREVER);
40011484:	fff00593          	li	a1,-1
40011488:	fff00613          	li	a2,-1
4001148c:	00c00513          	li	a0,12
40011490:	f0dff0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
40011494:	0184a503          	lw	a0,24(s1)
40011498:	948fe0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
4001149c:	06000b23          	sb	zero,118(zero) # 76 <CONFIG_NET_TCP_PKT_ALLOC_TIMEOUT+0x12>
400114a0:	00100073          	ebreak
	k_sem_give(&context->recv_data_wait);
400114a4:	05840513          	addi	a0,s0,88
	z_impl_k_sem_give(sem);
400114a8:	00a90533          	add	a0,s2,a0
400114ac:	0d9170ef          	jal	ra,40028d84 <z_impl_k_sem_give>
	k_mutex_unlock(&context->lock);
400114b0:	000a0513          	mv	a0,s4
400114b4:	eedff0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>
	context->recv_cb(context, pkt, ip_hdr, proto_hdr, 0, user_data);
400114b8:	0489a803          	lw	a6,72(s3)
400114bc:	00098513          	mv	a0,s3
400114c0:	000b8793          	mv	a5,s7
400114c4:	00000713          	li	a4,0
400114c8:	000b0693          	mv	a3,s6
400114cc:	000a8613          	mv	a2,s5
400114d0:	00048593          	mv	a1,s1
400114d4:	000800e7          	jalr	a6
	return verdict;
400114d8:	00000513          	li	a0,0
400114dc:	f71ff06f          	j	4001144c <net_context_packet_received+0xa8>

400114e0 <net_context_get>:
{
400114e0:	fd010113          	addi	sp,sp,-48
400114e4:	03212023          	sw	s2,32(sp)
400114e8:	02112623          	sw	ra,44(sp)
400114ec:	02812423          	sw	s0,40(sp)
400114f0:	02912223          	sw	s1,36(sp)
400114f4:	01312e23          	sw	s3,28(sp)
400114f8:	01412c23          	sw	s4,24(sp)
400114fc:	01512a23          	sw	s5,20(sp)
40011500:	01612823          	sw	s6,16(sp)
40011504:	01712623          	sw	s7,12(sp)
40011508:	01812423          	sw	s8,8(sp)
4001150c:	01912223          	sw	s9,4(sp)
	switch (family) {
40011510:	00200793          	li	a5,2
{
40011514:	00050913          	mv	s2,a0
	switch (family) {
40011518:	02a7ec63          	bltu	a5,a0,40011550 <net_context_get+0x70>
		return -EAFNOSUPPORT;
4001151c:	f9600493          	li	s1,-106
	switch (family) {
40011520:	04050663          	beqz	a0,4001156c <net_context_get+0x8c>
40011524:	00058413          	mv	s0,a1
40011528:	00060a93          	mv	s5,a2
4001152c:	00068b13          	mv	s6,a3
		switch (type) {
40011530:	06f58a63          	beq	a1,a5,400115a4 <net_context_get+0xc4>
40011534:	00300793          	li	a5,3
40011538:	06f58c63          	beq	a1,a5,400115b0 <net_context_get+0xd0>
4001153c:	00100793          	li	a5,1
40011540:	f9500493          	li	s1,-107
40011544:	02f59463          	bne	a1,a5,4001156c <net_context_get+0x8c>
			if (proto != IPPROTO_TCP) {
40011548:	00600793          	li	a5,6
4001154c:	05c0006f          	j	400115a8 <net_context_get+0xc8>
	switch (family) {
40011550:	ffd50913          	addi	s2,a0,-3
40011554:	01091913          	slli	s2,s2,0x10
40011558:	01095913          	srli	s2,s2,0x10
4001155c:	00100793          	li	a5,1
		return -EAFNOSUPPORT;
40011560:	f9600493          	li	s1,-106
	switch (family) {
40011564:	0127e463          	bltu	a5,s2,4001156c <net_context_get+0x8c>
40011568:	fa000493          	li	s1,-96
}
4001156c:	02c12083          	lw	ra,44(sp)
40011570:	02812403          	lw	s0,40(sp)
40011574:	02012903          	lw	s2,32(sp)
40011578:	01c12983          	lw	s3,28(sp)
4001157c:	01812a03          	lw	s4,24(sp)
40011580:	01412a83          	lw	s5,20(sp)
40011584:	01012b03          	lw	s6,16(sp)
40011588:	00c12b83          	lw	s7,12(sp)
4001158c:	00812c03          	lw	s8,8(sp)
40011590:	00412c83          	lw	s9,4(sp)
40011594:	00048513          	mv	a0,s1
40011598:	02412483          	lw	s1,36(sp)
4001159c:	03010113          	addi	sp,sp,48
400115a0:	00008067          	ret
			if (proto != IPPROTO_UDP) {
400115a4:	01100793          	li	a5,17
				return -EPROTONOSUPPORT;
400115a8:	f8500493          	li	s1,-123
			if (proto != IPPROTO_TCP) {
400115ac:	fcfa90e3          	bne	s5,a5,4001156c <net_context_get+0x8c>
		return -EINVAL;
400115b0:	fea00493          	li	s1,-22
	if (!context) {
400115b4:	fa0b0ce3          	beqz	s6,4001156c <net_context_get+0x8c>
	return z_impl_k_sem_take(sem, timeout);
400115b8:	40032bb7          	lui	s7,0x40032
400115bc:	fff00593          	li	a1,-1
400115c0:	fff00613          	li	a2,-1
400115c4:	eccb8513          	addi	a0,s7,-308 # 40031ecc <contexts_lock>
400115c8:	400324b7          	lui	s1,0x40032
400115cc:	029170ef          	jal	ra,40028df4 <z_impl_k_sem_take>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
400115d0:	ee448793          	addi	a5,s1,-284 # 40031ee4 <contexts>
400115d4:	00000a13          	li	s4,0
400115d8:	ee448493          	addi	s1,s1,-284
	return context->flags & NET_CONTEXT_IN_USE;
400115dc:	0747d703          	lhu	a4,116(a5)
		if (net_context_is_used(&contexts[i])) {
400115e0:	00177713          	andi	a4,a4,1
400115e4:	02070263          	beqz	a4,40011608 <net_context_get+0x128>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
400115e8:	001a0a13          	addi	s4,s4,1 # ffff8001 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8002>
400115ec:	00a00713          	li	a4,10
400115f0:	07878793          	addi	a5,a5,120
400115f4:	feea14e3          	bne	s4,a4,400115dc <net_context_get+0xfc>
	ret = -ENOENT;
400115f8:	ffe00493          	li	s1,-2
	z_impl_k_sem_give(sem);
400115fc:	eccb8513          	addi	a0,s7,-308
40011600:	784170ef          	jal	ra,40028d84 <z_impl_k_sem_give>
}
40011604:	f69ff06f          	j	4001156c <net_context_get+0x8c>
		memset(&contexts[i], 0, sizeof(contexts[i]));
40011608:	07800993          	li	s3,120
4001160c:	033a09b3          	mul	s3,s4,s3
40011610:	07800613          	li	a2,120
40011614:	00000593          	li	a1,0
40011618:	01348c33          	add	s8,s1,s3
4001161c:	000c0513          	mv	a0,s8
40011620:	a51f70ef          	jal	ra,40009070 <memset>
		if (!net_if_is_ip_offloaded(net_if_get_default())
40011624:	d98fb0ef          	jal	ra,4000cbbc <net_if_get_default>
			&& proto == IPPROTO_TCP) {
40011628:	00600793          	li	a5,6
4001162c:	0efa8463          	beq	s5,a5,40011714 <net_context_get+0x234>
		contexts[i].iface = -1;
40011630:	07800c93          	li	s9,120
40011634:	039a0cb3          	mul	s9,s4,s9
40011638:	fff00793          	li	a5,-1
4001163c:	01948cb3          	add	s9,s1,s9
40011640:	06fc8b23          	sb	a5,118(s9)
		contexts[i].flags = 0U;
40011644:	060c9a23          	sh	zero,116(s9)
		atomic_set(&contexts[i].refcount, 1);
40011648:	00898513          	addi	a0,s3,8
	return z_impl_atomic_set(target, value);
4001164c:	00100593          	li	a1,1
40011650:	00a48533          	add	a0,s1,a0
40011654:	19d190ef          	jal	ra,4002aff0 <z_impl_atomic_set>
	context->flags |= flag;
40011658:	074cd703          	lhu	a4,116(s9)
		flag = family << 3;
4001165c:	00391793          	slli	a5,s2,0x3
	context->flags |= flag;
40011660:	0f87f793          	andi	a5,a5,248
40011664:	00e7e7b3          	or	a5,a5,a4
	if (type == SOCK_DGRAM || type == SOCK_STREAM || type == SOCK_RAW) {
40011668:	00200693          	li	a3,2
4001166c:	fff40713          	addi	a4,s0,-1
40011670:	0ae6fa63          	bgeu	a3,a4,40011724 <net_context_get+0x244>
	uint16_t flag = 0U;
40011674:	00000413          	li	s0,0
	context->flags |= flag;
40011678:	07800713          	li	a4,120
4001167c:	02ea0733          	mul	a4,s4,a4
40011680:	00f46433          	or	s0,s0,a5
			(void)memset(&contexts[i].remote, 0, sizeof(struct sockaddr));
40011684:	02c98513          	addi	a0,s3,44
40011688:	01800613          	li	a2,24
4001168c:	00000593          	li	a1,0
40011690:	00a48533          	add	a0,s1,a0
40011694:	00e48733          	add	a4,s1,a4
40011698:	06871a23          	sh	s0,116(a4)
			(void)memset(&contexts[i].local, 0, sizeof(struct sockaddr_ptr));
4001169c:	02098413          	addi	s0,s3,32
	context->proto = proto;
400116a0:	07571923          	sh	s5,114(a4)
400116a4:	00848433          	add	s0,s1,s0
			(void)memset(&contexts[i].remote, 0, sizeof(struct sockaddr));
400116a8:	9c9f70ef          	jal	ra,40009070 <memset>
			(void)memset(&contexts[i].local, 0, sizeof(struct sockaddr_ptr));
400116ac:	00c00613          	li	a2,12
400116b0:	00000593          	li	a1,0
400116b4:	00040513          	mv	a0,s0
400116b8:	9b9f70ef          	jal	ra,40009070 <memset>
					find_available_port(&contexts[i], (struct sockaddr *)addr6);
400116bc:	00040593          	mv	a1,s0
400116c0:	000c0513          	mv	a0,s8
400116c4:	bb5ff0ef          	jal	ra,40011278 <find_available_port>
				addr6->sin6_port =
400116c8:	00a41123          	sh	a0,2(s0)
				if (!addr6->sin6_port) {
400116cc:	06050463          	beqz	a0,40011734 <net_context_get+0x254>
			k_sem_init(&contexts[i].recv_data_wait, 1, K_SEM_MAX_LIMIT);
400116d0:	05898513          	addi	a0,s3,88
	return z_impl_k_sem_init(sem, initial_count, limit);
400116d4:	fff00613          	li	a2,-1
400116d8:	00100593          	li	a1,1
400116dc:	00a48533          	add	a0,s1,a0
400116e0:	66c170ef          	jal	ra,40028d4c <z_impl_k_sem_init>
		k_mutex_init(&contexts[i].lock);
400116e4:	00c98513          	addi	a0,s3,12
	return z_impl_k_mutex_init(mutex);
400116e8:	00a48533          	add	a0,s1,a0
400116ec:	178170ef          	jal	ra,40028864 <z_impl_k_mutex_init>
		contexts[i].flags |= NET_CONTEXT_IN_USE;
400116f0:	07800793          	li	a5,120
400116f4:	02fa07b3          	mul	a5,s4,a5
400116f8:	00f487b3          	add	a5,s1,a5
400116fc:	0747d703          	lhu	a4,116(a5)
		ret = 0;
40011700:	00000493          	li	s1,0
		contexts[i].flags |= NET_CONTEXT_IN_USE;
40011704:	00176713          	ori	a4,a4,1
40011708:	06e79a23          	sh	a4,116(a5)
		*context = &contexts[i];
4001170c:	018b2023          	sw	s8,0(s6)
		break;
40011710:	eedff06f          	j	400115fc <net_context_get+0x11c>
			if (net_tcp_get(&contexts[i]) < 0) {
40011714:	000c0513          	mv	a0,s8
40011718:	3c00a0ef          	jal	ra,4001bad8 <net_tcp_get>
4001171c:	f0055ae3          	bgez	a0,40011630 <net_context_get+0x150>
40011720:	ed9ff06f          	j	400115f8 <net_context_get+0x118>
		flag = type << 6;
40011724:	00641413          	slli	s0,s0,0x6
40011728:	01041413          	slli	s0,s0,0x10
4001172c:	01045413          	srli	s0,s0,0x10
40011730:	f49ff06f          	j	40011678 <net_context_get+0x198>
					ret = -EADDRINUSE;
40011734:	f9000493          	li	s1,-112
40011738:	ec5ff06f          	j	400115fc <net_context_get+0x11c>

4001173c <net_context_unref>:
{
4001173c:	ff010113          	addi	sp,sp,-16
40011740:	00812423          	sw	s0,8(sp)
40011744:	00112623          	sw	ra,12(sp)
40011748:	00912223          	sw	s1,4(sp)
4001174c:	00050413          	mv	s0,a0
	return z_impl_atomic_sub(target, value);
40011750:	00100593          	li	a1,1
40011754:	00850513          	addi	a0,a0,8
40011758:	071190ef          	jal	ra,4002afc8 <z_impl_atomic_sub>
	if (old_rc != 1) {
4001175c:	00100793          	li	a5,1
40011760:	00f50e63          	beq	a0,a5,4001177c <net_context_unref+0x40>
		return old_rc - 1;
40011764:	fff50513          	addi	a0,a0,-1
}
40011768:	00c12083          	lw	ra,12(sp)
4001176c:	00812403          	lw	s0,8(sp)
40011770:	00412483          	lw	s1,4(sp)
40011774:	01010113          	addi	sp,sp,16
40011778:	00008067          	ret
	k_mutex_lock(&context->lock, K_FOREVER);
4001177c:	00c40493          	addi	s1,s0,12
40011780:	00048513          	mv	a0,s1
40011784:	fff00593          	li	a1,-1
40011788:	fff00613          	li	a2,-1
4001178c:	c11ff0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
	if (context->conn_handler) {
40011790:	04442503          	lw	a0,68(s0)
40011794:	00050663          	beqz	a0,400117a0 <net_context_unref+0x64>
			net_conn_unregister(context->conn_handler);
40011798:	7dd020ef          	jal	ra,40014774 <net_conn_unregister>
		context->conn_handler = NULL;
4001179c:	04042223          	sw	zero,68(s0)
	context->flags &= ~NET_CONTEXT_IN_USE;
400117a0:	07445783          	lhu	a5,116(s0)
	k_mutex_unlock(&context->lock);
400117a4:	00048513          	mv	a0,s1
	context->flags &= ~NET_CONTEXT_IN_USE;
400117a8:	ff87f793          	andi	a5,a5,-8
400117ac:	06f41a23          	sh	a5,116(s0)
	k_mutex_unlock(&context->lock);
400117b0:	bf1ff0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>
	return 0;
400117b4:	00000513          	li	a0,0
400117b8:	fb1ff06f          	j	40011768 <net_context_unref+0x2c>

400117bc <net_context_put>:
	if (!PART_OF_ARRAY(contexts, context)) {
400117bc:	08050263          	beqz	a0,40011840 <net_context_put+0x84>
{
400117c0:	ff010113          	addi	sp,sp,-16
	if (!PART_OF_ARRAY(contexts, context)) {
400117c4:	400327b7          	lui	a5,0x40032
{
400117c8:	00812423          	sw	s0,8(sp)
400117cc:	00112623          	sw	ra,12(sp)
400117d0:	00050413          	mv	s0,a0
400117d4:	00912223          	sw	s1,4(sp)
	if (!PART_OF_ARRAY(contexts, context)) {
400117d8:	ee478793          	addi	a5,a5,-284 # 40031ee4 <contexts>
		return -EINVAL;
400117dc:	fea00513          	li	a0,-22
	if (!PART_OF_ARRAY(contexts, context)) {
400117e0:	04f46663          	bltu	s0,a5,4001182c <net_context_put+0x70>
400117e4:	400327b7          	lui	a5,0x40032
400117e8:	39478793          	addi	a5,a5,916 # 40032394 <conns>
400117ec:	04f47063          	bgeu	s0,a5,4001182c <net_context_put+0x70>
	k_mutex_lock(&context->lock, K_FOREVER);
400117f0:	00c40493          	addi	s1,s0,12
400117f4:	fff00593          	li	a1,-1
400117f8:	fff00613          	li	a2,-1
400117fc:	00048513          	mv	a0,s1
40011800:	b9dff0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
	net_tcp_put(context);
40011804:	00040513          	mv	a0,s0
	context->connect_cb = NULL;
40011808:	04042823          	sw	zero,80(s0)
	context->recv_cb = NULL;
4001180c:	04042423          	sw	zero,72(s0)
	context->send_cb = NULL;
40011810:	04042623          	sw	zero,76(s0)
	net_tcp_put(context);
40011814:	6550a0ef          	jal	ra,4001c668 <net_tcp_put>
	net_context_unref(context);
40011818:	00040513          	mv	a0,s0
4001181c:	f21ff0ef          	jal	ra,4001173c <net_context_unref>
	k_mutex_unlock(&context->lock);
40011820:	00048513          	mv	a0,s1
40011824:	b7dff0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>
	return ret;
40011828:	00000513          	li	a0,0
}
4001182c:	00c12083          	lw	ra,12(sp)
40011830:	00812403          	lw	s0,8(sp)
40011834:	00412483          	lw	s1,4(sp)
40011838:	01010113          	addi	sp,sp,16
4001183c:	00008067          	ret
		return -EINVAL;
40011840:	fea00513          	li	a0,-22
}
40011844:	00008067          	ret

40011848 <net_context_bind>:
{
40011848:	fd010113          	addi	sp,sp,-48
4001184c:	02912223          	sw	s1,36(sp)
40011850:	02112623          	sw	ra,44(sp)
40011854:	02812423          	sw	s0,40(sp)
40011858:	03212023          	sw	s2,32(sp)
4001185c:	01312e23          	sw	s3,28(sp)
40011860:	01412c23          	sw	s4,24(sp)
	if (context->conn_handler) {
40011864:	04452983          	lw	s3,68(a0)
		return -EISCONN;
40011868:	f8100493          	li	s1,-127
	if (context->conn_handler) {
4001186c:	06099663          	bnez	s3,400118d8 <net_context_bind+0x90>
	if (IS_ENABLED(CONFIG_NET_IPV6) && addr->sa_family == AF_INET6) {
40011870:	0005d783          	lhu	a5,0(a1)
40011874:	00200713          	li	a4,2
40011878:	00050413          	mv	s0,a0
4001187c:	00058913          	mv	s2,a1
40011880:	12e79863          	bne	a5,a4,400119b0 <net_context_bind+0x168>
		struct net_if *iface = NULL;
40011884:	00012623          	sw	zero,12(sp)
		if (addrlen < sizeof(struct sockaddr_in6)) {
40011888:	01700793          	li	a5,23
			return -EINVAL;
4001188c:	fea00493          	li	s1,-22
		if (addrlen < sizeof(struct sockaddr_in6)) {
40011890:	04c7f463          	bgeu	a5,a2,400118d8 <net_context_bind+0x90>
		if (net_context_is_bound_to_iface(context)) {
40011894:	07455783          	lhu	a5,116(a0)
40011898:	00b7d793          	srli	a5,a5,0xb
4001189c:	0017f793          	andi	a5,a5,1
400118a0:	00078863          	beqz	a5,400118b0 <net_context_bind+0x68>
	return net_if_get_by_index(context->iface);
400118a4:	07650503          	lb	a0,118(a0)
		union { uintptr_t x; int val; } parm0 = { .val = index };
		return (struct net_if *) arch_syscall_invoke1(parm0.x, K_SYSCALL_NET_IF_GET_BY_INDEX);
	}
#endif
	compiler_barrier();
	return z_impl_net_if_get_by_index(index);
400118a8:	a24fb0ef          	jal	ra,4000cacc <z_impl_net_if_get_by_index>
			iface = net_context_get_iface(context);
400118ac:	00a12623          	sw	a0,12(sp)
		if (net_ipv6_is_addr_mcast(&addr6->sin6_addr)) {
400118b0:	00494703          	lbu	a4,4(s2)
400118b4:	0ff00793          	li	a5,255
			maddr = net_if_ipv6_maddr_lookup(&addr6->sin6_addr,
400118b8:	00490493          	addi	s1,s2,4
		if (net_ipv6_is_addr_mcast(&addr6->sin6_addr)) {
400118bc:	04f71063          	bne	a4,a5,400118fc <net_context_bind+0xb4>
			maddr = net_if_ipv6_maddr_lookup(&addr6->sin6_addr,
400118c0:	00c10593          	addi	a1,sp,12
400118c4:	00048513          	mv	a0,s1
400118c8:	cacfc0ef          	jal	ra,4000dd74 <net_if_ipv6_maddr_lookup>
			ptr = &maddr->address.in6_addr;
400118cc:	00450993          	addi	s3,a0,4
			if (!maddr) {
400118d0:	04051a63          	bnez	a0,40011924 <net_context_bind+0xdc>
				return -ENOENT;
400118d4:	ffe00493          	li	s1,-2
}
400118d8:	02c12083          	lw	ra,44(sp)
400118dc:	02812403          	lw	s0,40(sp)
400118e0:	02012903          	lw	s2,32(sp)
400118e4:	01c12983          	lw	s3,28(sp)
400118e8:	01812a03          	lw	s4,24(sp)
400118ec:	00048513          	mv	a0,s1
400118f0:	02412483          	lw	s1,36(sp)
400118f4:	03010113          	addi	sp,sp,48
400118f8:	00008067          	ret
		} else if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
400118fc:	00048513          	mv	a0,s1
40011900:	f94ff0ef          	jal	ra,40011094 <net_ipv6_is_addr_unspecified>
			if (iface == NULL) {
40011904:	00c12783          	lw	a5,12(sp)
		} else if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
40011908:	08050463          	beqz	a0,40011990 <net_context_bind+0x148>
			if (iface == NULL) {
4001190c:	00079863          	bnez	a5,4001191c <net_context_bind+0xd4>
				iface = net_if_ipv6_select_src_iface(
40011910:	03040513          	addi	a0,s0,48
40011914:	ff5fc0ef          	jal	ra,4000e908 <net_if_ipv6_select_src_iface>
40011918:	00a12623          	sw	a0,12(sp)
			ptr = (struct in6_addr *)net_ipv6_unspecified_address();
4001191c:	b50ff0ef          	jal	ra,40010c6c <net_ipv6_unspecified_address>
40011920:	00050993          	mv	s3,a0
		if (!iface) {
40011924:	00c12783          	lw	a5,12(sp)
			return -EADDRNOTAVAIL;
40011928:	f8300493          	li	s1,-125
		if (!iface) {
4001192c:	fa0786e3          	beqz	a5,400118d8 <net_context_bind+0x90>
		k_mutex_lock(&context->lock, K_FOREVER);
40011930:	00c40a13          	addi	s4,s0,12
40011934:	fff00593          	li	a1,-1
40011938:	fff00613          	li	a2,-1
4001193c:	000a0513          	mv	a0,s4
40011940:	a5dff0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
	context->iface = net_if_get_by_iface(iface);
40011944:	00c12503          	lw	a0,12(sp)
40011948:	c99fd0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
		net_sin6_ptr(&context->local)->sin6_family = AF_INET6;
4001194c:	00200793          	li	a5,2
40011950:	06a40b23          	sb	a0,118(s0)
40011954:	02f41023          	sh	a5,32(s0)
		net_sin6_ptr(&context->local)->sin6_addr = ptr;
40011958:	03342223          	sw	s3,36(s0)
		if (addr6->sin6_port) {
4001195c:	00295583          	lhu	a1,2(s2)
40011960:	12058e63          	beqz	a1,40011a9c <net_context_bind+0x254>
			ret = check_used_port(AF_INET6, addr6->sin6_port,
40011964:	00090613          	mv	a2,s2
40011968:	00200513          	li	a0,2
			ret = check_used_port(AF_INET, addr4->sin_port,
4001196c:	fecff0ef          	jal	ra,40011158 <check_used_port>
40011970:	00050493          	mv	s1,a0
			if (!ret) {
40011974:	00051863          	bnez	a0,40011984 <net_context_bind+0x13c>
					addr4->sin_port;
40011978:	00295783          	lhu	a5,2(s2)
				net_sin_ptr(&context->local)->sin_port =
4001197c:	02f41123          	sh	a5,34(s0)
			ifaddr = net_if_ipv4_addr_lookup(
40011980:	00000493          	li	s1,0
		k_mutex_unlock(&context->lock);
40011984:	000a0513          	mv	a0,s4
40011988:	a19ff0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>
		return ret;
4001198c:	f4dff06f          	j	400118d8 <net_context_bind+0x90>
			ifaddr = net_if_ipv6_addr_lookup(
40011990:	00079463          	bnez	a5,40011998 <net_context_bind+0x150>
40011994:	00c10993          	addi	s3,sp,12
40011998:	00098593          	mv	a1,s3
4001199c:	00048513          	mv	a0,s1
400119a0:	d7cfb0ef          	jal	ra,4000cf1c <net_if_ipv6_addr_lookup>
			if (!ifaddr) {
400119a4:	f20508e3          	beqz	a0,400118d4 <net_context_bind+0x8c>
			ptr = &ifaddr->address.in6_addr;
400119a8:	00450993          	addi	s3,a0,4
400119ac:	f79ff06f          	j	40011924 <net_context_bind+0xdc>
	if (IS_ENABLED(CONFIG_NET_IPV4) && addr->sa_family == AF_INET) {
400119b0:	00100713          	li	a4,1
	return -EINVAL;
400119b4:	fea00493          	li	s1,-22
	if (IS_ENABLED(CONFIG_NET_IPV4) && addr->sa_family == AF_INET) {
400119b8:	f2e790e3          	bne	a5,a4,400118d8 <net_context_bind+0x90>
		struct net_if *iface = NULL;
400119bc:	00012623          	sw	zero,12(sp)
		if (addrlen < sizeof(struct sockaddr_in)) {
400119c0:	00700793          	li	a5,7
400119c4:	f0c7fae3          	bgeu	a5,a2,400118d8 <net_context_bind+0x90>
		if (net_context_is_bound_to_iface(context)) {
400119c8:	07455783          	lhu	a5,116(a0)
400119cc:	00b7d793          	srli	a5,a5,0xb
400119d0:	0017f793          	andi	a5,a5,1
400119d4:	00078863          	beqz	a5,400119e4 <net_context_bind+0x19c>
	return net_if_get_by_index(context->iface);
400119d8:	07650503          	lb	a0,118(a0)
400119dc:	8f0fb0ef          	jal	ra,4000cacc <z_impl_net_if_get_by_index>
			iface = net_context_get_iface(context);
400119e0:	00a12623          	sw	a0,12(sp)
		if (net_ipv4_is_addr_mcast(&addr4->sin_addr)) {
400119e4:	00490493          	addi	s1,s2,4
400119e8:	00048513          	mv	a0,s1
400119ec:	e88ff0ef          	jal	ra,40011074 <net_ipv4_is_addr_mcast>
400119f0:	06050263          	beqz	a0,40011a54 <net_context_bind+0x20c>
			maddr = net_if_ipv4_maddr_lookup(&addr4->sin_addr,
400119f4:	00c10593          	addi	a1,sp,12
400119f8:	00048513          	mv	a0,s1
400119fc:	fa8fd0ef          	jal	ra,4000f1a4 <net_if_ipv4_maddr_lookup>
			ptr = &maddr->address.in_addr;
40011a00:	00450993          	addi	s3,a0,4
			if (!maddr) {
40011a04:	ec0508e3          	beqz	a0,400118d4 <net_context_bind+0x8c>
		if (!iface) {
40011a08:	00c12783          	lw	a5,12(sp)
			return -EADDRNOTAVAIL;
40011a0c:	f8300493          	li	s1,-125
		if (!iface) {
40011a10:	ec0784e3          	beqz	a5,400118d8 <net_context_bind+0x90>
		k_mutex_lock(&context->lock, K_FOREVER);
40011a14:	00c40a13          	addi	s4,s0,12
40011a18:	fff00593          	li	a1,-1
40011a1c:	fff00613          	li	a2,-1
40011a20:	000a0513          	mv	a0,s4
40011a24:	979ff0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
	context->iface = net_if_get_by_iface(iface);
40011a28:	00c12503          	lw	a0,12(sp)
40011a2c:	bb5fd0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
		net_sin_ptr(&context->local)->sin_family = AF_INET;
40011a30:	00100793          	li	a5,1
40011a34:	06a40b23          	sb	a0,118(s0)
40011a38:	02f41023          	sh	a5,32(s0)
		net_sin_ptr(&context->local)->sin_addr = ptr;
40011a3c:	03342223          	sw	s3,36(s0)
		if (addr4->sin_port) {
40011a40:	00295583          	lhu	a1,2(s2)
40011a44:	04058c63          	beqz	a1,40011a9c <net_context_bind+0x254>
			ret = check_used_port(AF_INET, addr4->sin_port,
40011a48:	00090613          	mv	a2,s2
40011a4c:	00100513          	li	a0,1
40011a50:	f1dff06f          	j	4001196c <net_context_bind+0x124>
		} else if (addr4->sin_addr.s_addr == INADDR_ANY) {
40011a54:	00492703          	lw	a4,4(s2)
			if (iface == NULL) {
40011a58:	00c12783          	lw	a5,12(sp)
		} else if (addr4->sin_addr.s_addr == INADDR_ANY) {
40011a5c:	02071063          	bnez	a4,40011a7c <net_context_bind+0x234>
			if (iface == NULL) {
40011a60:	00079863          	bnez	a5,40011a70 <net_context_bind+0x228>
				iface = net_if_ipv4_select_src_iface(
40011a64:	03040513          	addi	a0,s0,48
40011a68:	9f8fd0ef          	jal	ra,4000ec60 <net_if_ipv4_select_src_iface>
40011a6c:	00a12623          	sw	a0,12(sp)
			ptr = (struct in_addr *)net_ipv4_unspecified_address();
40011a70:	9e4ff0ef          	jal	ra,40010c54 <net_ipv4_unspecified_address>
40011a74:	00050993          	mv	s3,a0
40011a78:	f91ff06f          	j	40011a08 <net_context_bind+0x1c0>
			ifaddr = net_if_ipv4_addr_lookup(
40011a7c:	00079463          	bnez	a5,40011a84 <net_context_bind+0x23c>
40011a80:	00c10993          	addi	s3,sp,12
40011a84:	00098593          	mv	a1,s3
40011a88:	00048513          	mv	a0,s1
40011a8c:	b80fd0ef          	jal	ra,4000ee0c <net_if_ipv4_addr_lookup>
			if (!ifaddr) {
40011a90:	e40502e3          	beqz	a0,400118d4 <net_context_bind+0x8c>
			ptr = &ifaddr->address.in_addr;
40011a94:	00450993          	addi	s3,a0,4
40011a98:	f71ff06f          	j	40011a08 <net_context_bind+0x1c0>
				net_sin_ptr(&context->local)->sin_port;
40011a9c:	02245783          	lhu	a5,34(s0)
			addr4->sin_port =
40011aa0:	00f91123          	sh	a5,2(s2)
40011aa4:	eddff06f          	j	40011980 <net_context_bind+0x138>

40011aa8 <bind_default>:
{
40011aa8:	fd010113          	addi	sp,sp,-48
40011aac:	02812423          	sw	s0,40(sp)
40011ab0:	02112623          	sw	ra,44(sp)
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40011ab4:	07455703          	lhu	a4,116(a0)
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40011ab8:	00200793          	li	a5,2
{
40011abc:	00050413          	mv	s0,a0
40011ac0:	00375713          	srli	a4,a4,0x3
40011ac4:	00777713          	andi	a4,a4,7
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40011ac8:	06f71063          	bne	a4,a5,40011b28 <bind_default+0x80>
		if (net_sin6_ptr(&context->local)->sin6_addr) {
40011acc:	02452683          	lw	a3,36(a0)
			return 0;
40011ad0:	00000793          	li	a5,0
		if (net_sin6_ptr(&context->local)->sin6_addr) {
40011ad4:	04069063          	bnez	a3,40011b14 <bind_default+0x6c>
		addr6.sin6_family = AF_INET6;
40011ad8:	00e11423          	sh	a4,8(sp)
		memcpy(&addr6.sin6_addr, net_ipv6_unspecified_address(),
40011adc:	990ff0ef          	jal	ra,40010c6c <net_ipv6_unspecified_address>
40011ae0:	00050593          	mv	a1,a0
40011ae4:	01000613          	li	a2,16
40011ae8:	00c10513          	addi	a0,sp,12
40011aec:	d60f70ef          	jal	ra,4000904c <memcpy>
			find_available_port(context,
40011af0:	00810593          	addi	a1,sp,8
40011af4:	00040513          	mv	a0,s0
40011af8:	f80ff0ef          	jal	ra,40011278 <find_available_port>
		addr6.sin6_port =
40011afc:	00a11523          	sh	a0,10(sp)
		return net_context_bind(context, (struct sockaddr *)&addr6,
40011b00:	01800613          	li	a2,24
		return net_context_bind(context, (struct sockaddr *)&addr4,
40011b04:	00810593          	addi	a1,sp,8
40011b08:	00040513          	mv	a0,s0
40011b0c:	d3dff0ef          	jal	ra,40011848 <net_context_bind>
40011b10:	00050793          	mv	a5,a0
}
40011b14:	02c12083          	lw	ra,44(sp)
40011b18:	02812403          	lw	s0,40(sp)
40011b1c:	00078513          	mv	a0,a5
40011b20:	03010113          	addi	sp,sp,48
40011b24:	00008067          	ret
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40011b28:	00100693          	li	a3,1
	return -EINVAL;
40011b2c:	fea00793          	li	a5,-22
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40011b30:	fed712e3          	bne	a4,a3,40011b14 <bind_default+0x6c>
		if (net_sin_ptr(&context->local)->sin_addr) {
40011b34:	02452683          	lw	a3,36(a0)
			return 0;
40011b38:	00000793          	li	a5,0
		if (net_sin_ptr(&context->local)->sin_addr) {
40011b3c:	fc069ce3          	bnez	a3,40011b14 <bind_default+0x6c>
			find_available_port(context,
40011b40:	00810593          	addi	a1,sp,8
		addr4.sin_family = AF_INET;
40011b44:	00e11423          	sh	a4,8(sp)
		addr4.sin_addr.s_addr = INADDR_ANY;
40011b48:	00012623          	sw	zero,12(sp)
			find_available_port(context,
40011b4c:	f2cff0ef          	jal	ra,40011278 <find_available_port>
		addr4.sin_port =
40011b50:	00a11523          	sh	a0,10(sp)
		return net_context_bind(context, (struct sockaddr *)&addr4,
40011b54:	00800613          	li	a2,8
40011b58:	fadff06f          	j	40011b04 <bind_default+0x5c>

40011b5c <net_context_listen>:
	return context->flags & NET_CONTEXT_IN_USE;
40011b5c:	07455783          	lhu	a5,116(a0)
	if (!net_context_is_used(context)) {
40011b60:	0017f793          	andi	a5,a5,1
40011b64:	06078463          	beqz	a5,40011bcc <net_context_listen+0x70>
{
40011b68:	ff010113          	addi	sp,sp,-16
40011b6c:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40011b70:	00c50493          	addi	s1,a0,12
{
40011b74:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40011b78:	fff00593          	li	a1,-1
40011b7c:	00050413          	mv	s0,a0
40011b80:	fff00613          	li	a2,-1
40011b84:	00048513          	mv	a0,s1
{
40011b88:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40011b8c:	811ff0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
	if (net_tcp_listen(context) >= 0) {
40011b90:	00040513          	mv	a0,s0
40011b94:	1740a0ef          	jal	ra,4001bd08 <net_tcp_listen>
40011b98:	02054263          	bltz	a0,40011bbc <net_context_listen+0x60>
		k_mutex_unlock(&context->lock);
40011b9c:	00048513          	mv	a0,s1
40011ba0:	801ff0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>
		return 0;
40011ba4:	00000513          	li	a0,0
}
40011ba8:	00c12083          	lw	ra,12(sp)
40011bac:	00812403          	lw	s0,8(sp)
40011bb0:	00412483          	lw	s1,4(sp)
40011bb4:	01010113          	addi	sp,sp,16
40011bb8:	00008067          	ret
	k_mutex_unlock(&context->lock);
40011bbc:	00048513          	mv	a0,s1
40011bc0:	fe0ff0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>
	return -EOPNOTSUPP;
40011bc4:	fa100513          	li	a0,-95
40011bc8:	fe1ff06f          	j	40011ba8 <net_context_listen+0x4c>
		return -EBADF;
40011bcc:	ff700513          	li	a0,-9
}
40011bd0:	00008067          	ret

40011bd4 <net_context_create_ipv4_new>:
{
40011bd4:	fe010113          	addi	sp,sp,-32
40011bd8:	00812c23          	sw	s0,24(sp)
40011bdc:	00912a23          	sw	s1,20(sp)
40011be0:	01212823          	sw	s2,16(sp)
40011be4:	01312623          	sw	s3,12(sp)
40011be8:	00112e23          	sw	ra,28(sp)
40011bec:	00050913          	mv	s2,a0
40011bf0:	00058493          	mv	s1,a1
40011bf4:	00068993          	mv	s3,a3
40011bf8:	00060413          	mv	s0,a2
	if (!src) {
40011bfc:	00061463          	bnez	a2,40011c04 <net_context_create_ipv4_new+0x30>
		src = ((struct sockaddr_in_ptr *)&context->local)->sin_addr;
40011c00:	02452403          	lw	s0,36(a0)
	return UNALIGNED_GET(&addr->s_addr) == 0;
40011c04:	00144783          	lbu	a5,1(s0)
40011c08:	00044703          	lbu	a4,0(s0)
40011c0c:	00879793          	slli	a5,a5,0x8
40011c10:	00e7e7b3          	or	a5,a5,a4
40011c14:	00244703          	lbu	a4,2(s0)
40011c18:	01071713          	slli	a4,a4,0x10
40011c1c:	00f76733          	or	a4,a4,a5
40011c20:	00344783          	lbu	a5,3(s0)
40011c24:	01879793          	slli	a5,a5,0x18
40011c28:	00e7e7b3          	or	a5,a5,a4
	if (net_ipv4_is_addr_unspecified(src)
40011c2c:	00078863          	beqz	a5,40011c3c <net_context_create_ipv4_new+0x68>
	    || net_ipv4_is_addr_mcast(src)) {
40011c30:	00040513          	mv	a0,s0
40011c34:	c40ff0ef          	jal	ra,40011074 <net_ipv4_is_addr_mcast>
40011c38:	04050063          	beqz	a0,40011c78 <net_context_create_ipv4_new+0xa4>
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
40011c3c:	0184a503          	lw	a0,24(s1)
40011c40:	00098593          	mv	a1,s3
40011c44:	8a4fd0ef          	jal	ra,4000ece8 <net_if_ipv4_select_src_addr>
40011c48:	00154783          	lbu	a5,1(a0)
40011c4c:	00054703          	lbu	a4,0(a0)
40011c50:	00050413          	mv	s0,a0
40011c54:	00879793          	slli	a5,a5,0x8
40011c58:	00e7e7b3          	or	a5,a5,a4
40011c5c:	00254703          	lbu	a4,2(a0)
40011c60:	01071713          	slli	a4,a4,0x10
40011c64:	00f76733          	or	a4,a4,a5
40011c68:	00354783          	lbu	a5,3(a0)
40011c6c:	01879793          	slli	a5,a5,0x18
40011c70:	00e7e7b3          	or	a5,a5,a4
		if (net_ipv4_is_addr_unspecified(src)) {
40011c74:	06078263          	beqz	a5,40011cd8 <net_context_create_ipv4_new+0x104>
}

static inline uint8_t net_context_get_ipv4_ttl(struct net_context *context)
{
	return context->ipv4_ttl;
40011c78:	07794783          	lbu	a5,119(s2)
	return net_ipv4_create(pkt, src, dst);
40011c7c:	00040593          	mv	a1,s0
40011c80:	00098613          	mv	a2,s3
	pkt->ipv4_ttl = ttl;
40011c84:	02f48ca3          	sb	a5,57(s1)
 *
 * @return Decoded DSCP value.
 */
static inline uint8_t net_ipv4_get_dscp(uint8_t tos)
{
	return (tos & NET_IPV4_DSCP_MASK) >> NET_IPV4_DSCP_OFFSET;
40011c88:	07094703          	lbu	a4,112(s2)
	pkt->ip_dscp = dscp;
40011c8c:	0404c783          	lbu	a5,64(s1)
40011c90:	00048513          	mv	a0,s1
40011c94:	00275713          	srli	a4,a4,0x2
40011c98:	fc07f793          	andi	a5,a5,-64
40011c9c:	00e7e7b3          	or	a5,a5,a4
40011ca0:	04f48023          	sb	a5,64(s1)
	pkt->ip_ecn = ecn;
40011ca4:	07094703          	lbu	a4,112(s2)
40011ca8:	0ff7f793          	zext.b	a5,a5
40011cac:	03f7f793          	andi	a5,a5,63
40011cb0:	00671713          	slli	a4,a4,0x6
40011cb4:	00e7e7b3          	or	a5,a5,a4
40011cb8:	04f48023          	sb	a5,64(s1)
}
40011cbc:	01812403          	lw	s0,24(sp)
40011cc0:	01c12083          	lw	ra,28(sp)
40011cc4:	01412483          	lw	s1,20(sp)
40011cc8:	01012903          	lw	s2,16(sp)
40011ccc:	00c12983          	lw	s3,12(sp)
40011cd0:	02010113          	addi	sp,sp,32
	return net_ipv4_create(pkt, src, dst);
40011cd4:	2e90306f          	j	400157bc <net_ipv4_create>
}
40011cd8:	01c12083          	lw	ra,28(sp)
40011cdc:	01812403          	lw	s0,24(sp)
40011ce0:	01412483          	lw	s1,20(sp)
40011ce4:	01012903          	lw	s2,16(sp)
40011ce8:	00c12983          	lw	s3,12(sp)
40011cec:	fea00513          	li	a0,-22
40011cf0:	02010113          	addi	sp,sp,32
40011cf4:	00008067          	ret

40011cf8 <net_context_create_ipv6_new>:
{
40011cf8:	fe010113          	addi	sp,sp,-32
40011cfc:	00812c23          	sw	s0,24(sp)
40011d00:	00912a23          	sw	s1,20(sp)
40011d04:	01212823          	sw	s2,16(sp)
40011d08:	01312623          	sw	s3,12(sp)
40011d0c:	00112e23          	sw	ra,28(sp)
40011d10:	00050913          	mv	s2,a0
40011d14:	00058493          	mv	s1,a1
40011d18:	00068993          	mv	s3,a3
40011d1c:	00060413          	mv	s0,a2
	if (!src) {
40011d20:	00061463          	bnez	a2,40011d28 <net_context_create_ipv6_new+0x30>
		src = ((struct sockaddr_in6_ptr *)&context->local)->sin6_addr;
40011d24:	02452403          	lw	s0,36(a0)
	if (net_ipv6_is_addr_unspecified(src)
40011d28:	00040513          	mv	a0,s0
40011d2c:	b68ff0ef          	jal	ra,40011094 <net_ipv6_is_addr_unspecified>
40011d30:	00051863          	bnez	a0,40011d40 <net_context_create_ipv6_new+0x48>
	    || net_ipv6_is_addr_mcast(src)) {
40011d34:	00044703          	lbu	a4,0(s0)
40011d38:	0ff00793          	li	a5,255
40011d3c:	00f71a63          	bne	a4,a5,40011d50 <net_context_create_ipv6_new+0x58>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
40011d40:	0184a503          	lw	a0,24(s1)
40011d44:	00098593          	mv	a1,s3
40011d48:	a9dfc0ef          	jal	ra,4000e7e4 <net_if_ipv6_select_src_addr>
40011d4c:	00050413          	mv	s0,a0
	context->ipv4_ttl = ttl;
}

static inline uint8_t net_context_get_ipv6_hop_limit(struct net_context *context)
{
	return context->ipv6_hop_limit;
40011d50:	07794783          	lbu	a5,119(s2)
	return net_ipv6_create(pkt, src, dst);
40011d54:	00040593          	mv	a1,s0
40011d58:	00098613          	mv	a2,s3
	pkt->ipv6_hop_limit = hop_limit;
40011d5c:	02f48ca3          	sb	a5,57(s1)
 *
 * @return Decoded DSCP value.
 */
static inline uint8_t net_ipv6_get_dscp(uint8_t tc)
{
	return (tc & NET_IPV6_DSCP_MASK) >> NET_IPV6_DSCP_OFFSET;
40011d60:	07094703          	lbu	a4,112(s2)
	pkt->ip_dscp = dscp;
40011d64:	0404c783          	lbu	a5,64(s1)
40011d68:	00048513          	mv	a0,s1
40011d6c:	00275713          	srli	a4,a4,0x2
40011d70:	fc07f793          	andi	a5,a5,-64
40011d74:	00e7e7b3          	or	a5,a5,a4
40011d78:	04f48023          	sb	a5,64(s1)
	pkt->ip_ecn = ecn;
40011d7c:	07094703          	lbu	a4,112(s2)
40011d80:	0ff7f793          	zext.b	a5,a5
40011d84:	03f7f793          	andi	a5,a5,63
40011d88:	00671713          	slli	a4,a4,0x6
40011d8c:	00e7e7b3          	or	a5,a5,a4
40011d90:	04f48023          	sb	a5,64(s1)
}
40011d94:	01812403          	lw	s0,24(sp)
40011d98:	01c12083          	lw	ra,28(sp)
40011d9c:	01412483          	lw	s1,20(sp)
40011da0:	01012903          	lw	s2,16(sp)
40011da4:	00c12983          	lw	s3,12(sp)
40011da8:	02010113          	addi	sp,sp,32
	return net_ipv6_create(pkt, src, dst);
40011dac:	3410406f          	j	400168ec <net_ipv6_create>

40011db0 <context_sendto.constprop.0>:
static int context_sendto(struct net_context *context,
40011db0:	fd010113          	addi	sp,sp,-48
40011db4:	02812423          	sw	s0,40(sp)
40011db8:	01712623          	sw	s7,12(sp)
40011dbc:	02112623          	sw	ra,44(sp)
40011dc0:	02912223          	sw	s1,36(sp)
40011dc4:	03212023          	sw	s2,32(sp)
40011dc8:	01312e23          	sw	s3,28(sp)
40011dcc:	01412c23          	sw	s4,24(sp)
40011dd0:	01512a23          	sw	s5,20(sp)
40011dd4:	01612823          	sw	s6,16(sp)
40011dd8:	01812423          	sw	s8,8(sp)
40011ddc:	01912223          	sw	s9,4(sp)
	return context->flags & NET_CONTEXT_IN_USE;
40011de0:	07455483          	lhu	s1,116(a0)
40011de4:	00078b93          	mv	s7,a5
		return -EBADF;
40011de8:	ff700413          	li	s0,-9
	if (!net_context_is_used(context)) {
40011dec:	0014f793          	andi	a5,s1,1
40011df0:	02078863          	beqz	a5,40011e20 <context_sendto.constprop.0+0x70>
40011df4:	00050993          	mv	s3,a0
40011df8:	00058a93          	mv	s5,a1
40011dfc:	00060913          	mv	s2,a2
40011e00:	00068a13          	mv	s4,a3
40011e04:	00080c13          	mv	s8,a6
	if (sendto && addrlen == 0 && dst_addr == NULL && buf != NULL) {
40011e08:	04088863          	beqz	a7,40011e58 <context_sendto.constprop.0+0xa8>
40011e0c:	04071663          	bnez	a4,40011e58 <context_sendto.constprop.0+0xa8>
			return -EINVAL;
40011e10:	fea00413          	li	s0,-22
	if (sendto && addrlen == 0 && dst_addr == NULL && buf != NULL) {
40011e14:	00069663          	bnez	a3,40011e20 <context_sendto.constprop.0+0x70>
40011e18:	06059c63          	bnez	a1,40011e90 <context_sendto.constprop.0+0xe0>
		return -EDESTADDRREQ;
40011e1c:	f8700413          	li	s0,-121
}
40011e20:	02c12083          	lw	ra,44(sp)
40011e24:	00040513          	mv	a0,s0
40011e28:	02812403          	lw	s0,40(sp)
40011e2c:	02412483          	lw	s1,36(sp)
40011e30:	02012903          	lw	s2,32(sp)
40011e34:	01c12983          	lw	s3,28(sp)
40011e38:	01812a03          	lw	s4,24(sp)
40011e3c:	01412a83          	lw	s5,20(sp)
40011e40:	01012b03          	lw	s6,16(sp)
40011e44:	00c12b83          	lw	s7,12(sp)
40011e48:	00812c03          	lw	s8,8(sp)
40011e4c:	00412c83          	lw	s9,4(sp)
40011e50:	03010113          	addi	sp,sp,48
40011e54:	00008067          	ret
		return -EDESTADDRREQ;
40011e58:	f8700413          	li	s0,-121
	if (!msghdr && !dst_addr) {
40011e5c:	fc0a02e3          	beqz	s4,40011e20 <context_sendto.constprop.0+0x70>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40011e60:	0034d793          	srli	a5,s1,0x3
40011e64:	0077f793          	andi	a5,a5,7
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40011e68:	00200693          	li	a3,2
40011e6c:	10d78863          	beq	a5,a3,40011f7c <context_sendto.constprop.0+0x1cc>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40011e70:	00100693          	li	a3,1
40011e74:	00000b13          	li	s6,0
			return -EINVAL;
40011e78:	fea00413          	li	s0,-22
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40011e7c:	fad792e3          	bne	a5,a3,40011e20 <context_sendto.constprop.0+0x70>
		if (addrlen < sizeof(struct sockaddr_in)) {
40011e80:	00700793          	li	a5,7
			return -EINVAL;
40011e84:	fea00413          	li	s0,-22
		if (addrlen < sizeof(struct sockaddr_in)) {
40011e88:	10e7e263          	bltu	a5,a4,40011f8c <context_sendto.constprop.0+0x1dc>
40011e8c:	f95ff06f          	j	40011e20 <context_sendto.constprop.0+0x70>
40011e90:	0034d793          	srli	a5,s1,0x3
40011e94:	0077f793          	andi	a5,a5,7
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40011e98:	00200713          	li	a4,2
40011e9c:	02e78063          	beq	a5,a4,40011ebc <context_sendto.constprop.0+0x10c>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40011ea0:	00100713          	li	a4,1
40011ea4:	f6e79ee3          	bne	a5,a4,40011e20 <context_sendto.constprop.0+0x70>
			addr4 = msghdr->msg_name;
40011ea8:	0005aa03          	lw	s4,0(a1)
			if (!addr4) {
40011eac:	0c0a0c63          	beqz	s4,40011f84 <context_sendto.constprop.0+0x1d4>
			addrlen = msghdr->msg_namelen;
40011eb0:	0045a703          	lw	a4,4(a1)
40011eb4:	00058b13          	mv	s6,a1
40011eb8:	fc9ff06f          	j	40011e80 <context_sendto.constprop.0+0xd0>
			addr6 = msghdr->msg_name;
40011ebc:	0005aa03          	lw	s4,0(a1)
			if (!addr6) {
40011ec0:	000a0e63          	beqz	s4,40011edc <context_sendto.constprop.0+0x12c>
			addrlen = msghdr->msg_namelen;
40011ec4:	0045a703          	lw	a4,4(a1)
40011ec8:	00058b13          	mv	s6,a1
		if (addrlen < sizeof(struct sockaddr_in6)) {
40011ecc:	01700793          	li	a5,23
			return -EINVAL;
40011ed0:	fea00413          	li	s0,-22
		if (addrlen < sizeof(struct sockaddr_in6)) {
40011ed4:	00e7e863          	bltu	a5,a4,40011ee4 <context_sendto.constprop.0+0x134>
40011ed8:	f49ff06f          	j	40011e20 <context_sendto.constprop.0+0x70>
				addr6 = net_sin6(&context->remote);
40011edc:	02c50a13          	addi	s4,a0,44
40011ee0:	00058b13          	mv	s6,a1
		if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
40011ee4:	004a0c93          	addi	s9,s4,4
40011ee8:	000c8513          	mv	a0,s9
40011eec:	9a8ff0ef          	jal	ra,40011094 <net_ipv6_is_addr_unspecified>
		return -EDESTADDRREQ;
40011ef0:	f8700413          	li	s0,-121
		if (net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
40011ef4:	f20516e3          	bnez	a0,40011e20 <context_sendto.constprop.0+0x70>
		if (net_ipv6_is_addr_unspecified(
40011ef8:	03098513          	addi	a0,s3,48
40011efc:	998ff0ef          	jal	ra,40011094 <net_ipv6_is_addr_unspecified>
40011f00:	02050063          	beqz	a0,40011f20 <context_sendto.constprop.0+0x170>
				&net_sin6(&context->remote)->sin6_addr) &&
40011f04:	00b4d493          	srli	s1,s1,0xb
40011f08:	0014f493          	andi	s1,s1,1
40011f0c:	00049a63          	bnez	s1,40011f20 <context_sendto.constprop.0+0x170>
			iface = net_if_ipv6_select_src_iface(&addr6->sin6_addr);
40011f10:	000c8513          	mv	a0,s9
40011f14:	9f5fc0ef          	jal	ra,4000e908 <net_if_ipv6_select_src_iface>
	context->iface = net_if_get_by_iface(iface);
40011f18:	ec8fd0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
40011f1c:	06a98b23          	sb	a0,118(s3)
	if (msghdr && len == 0) {
40011f20:	000b0a63          	beqz	s6,40011f34 <context_sendto.constprop.0+0x184>
40011f24:	00091863          	bnez	s2,40011f34 <context_sendto.constprop.0+0x184>
40011f28:	00cb2683          	lw	a3,12(s6)
		for (i = 0; i < msghdr->msg_iovlen; i++) {
40011f2c:	00000793          	li	a5,0
40011f30:	08d79463          	bne	a5,a3,40011fb8 <context_sendto.constprop.0+0x208>
	return net_if_get_by_index(context->iface);
40011f34:	07698503          	lb	a0,118(s3)
40011f38:	b95fa0ef          	jal	ra,4000cacc <z_impl_net_if_get_by_index>
40011f3c:	00050413          	mv	s0,a0
	if (iface && !net_if_is_up(iface)) {
40011f40:	08051a63          	bnez	a0,40011fd4 <context_sendto.constprop.0+0x224>
40011f44:	07698503          	lb	a0,118(s3)
40011f48:	b85fa0ef          	jal	ra,4000cacc <z_impl_net_if_get_by_index>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40011f4c:	0749d603          	lhu	a2,116(s3)
	pkt = net_pkt_alloc_with_buffer(net_context_get_iface(context), len,
40011f50:	0729d683          	lhu	a3,114(s3)
40011f54:	06400713          	li	a4,100
40011f58:	00365613          	srli	a2,a2,0x3
40011f5c:	00000793          	li	a5,0
40011f60:	00767613          	andi	a2,a2,7
40011f64:	00090593          	mv	a1,s2
40011f68:	7b4010ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
40011f6c:	00050493          	mv	s1,a0
	if (pkt) {
40011f70:	08051e63          	bnez	a0,4001200c <context_sendto.constprop.0+0x25c>
		return -ENOBUFS;
40011f74:	f9700413          	li	s0,-105
40011f78:	ea9ff06f          	j	40011e20 <context_sendto.constprop.0+0x70>
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40011f7c:	00000b13          	li	s6,0
40011f80:	f4dff06f          	j	40011ecc <context_sendto.constprop.0+0x11c>
				addr4 = net_sin(&context->remote);
40011f84:	02c50a13          	addi	s4,a0,44
40011f88:	00058b13          	mv	s6,a1
		if (!addr4->sin_addr.s_addr) {
40011f8c:	004a2783          	lw	a5,4(s4)
		return -EDESTADDRREQ;
40011f90:	f8700413          	li	s0,-121
		if (!addr4->sin_addr.s_addr) {
40011f94:	e80786e3          	beqz	a5,40011e20 <context_sendto.constprop.0+0x70>
		if (net_sin(&context->remote)->sin_addr.s_addr == 0U &&
40011f98:	0309a783          	lw	a5,48(s3)
40011f9c:	f80792e3          	bnez	a5,40011f20 <context_sendto.constprop.0+0x170>
40011fa0:	00b4d493          	srli	s1,s1,0xb
40011fa4:	0014f493          	andi	s1,s1,1
40011fa8:	f6049ce3          	bnez	s1,40011f20 <context_sendto.constprop.0+0x170>
			iface = net_if_ipv4_select_src_iface(&addr4->sin_addr);
40011fac:	004a0513          	addi	a0,s4,4
40011fb0:	cb1fc0ef          	jal	ra,4000ec60 <net_if_ipv4_select_src_iface>
40011fb4:	f65ff06f          	j	40011f18 <context_sendto.constprop.0+0x168>
			len += msghdr->msg_iov[i].iov_len;
40011fb8:	008b2703          	lw	a4,8(s6)
40011fbc:	00379613          	slli	a2,a5,0x3
		for (i = 0; i < msghdr->msg_iovlen; i++) {
40011fc0:	00178793          	addi	a5,a5,1
			len += msghdr->msg_iov[i].iov_len;
40011fc4:	00c70733          	add	a4,a4,a2
40011fc8:	00472703          	lw	a4,4(a4)
40011fcc:	00e90933          	add	s2,s2,a4
		for (i = 0; i < msghdr->msg_iovlen; i++) {
40011fd0:	f61ff06f          	j	40011f30 <context_sendto.constprop.0+0x180>
	return atomic_test_bit(iface->if_dev->flags, value);
40011fd4:	00052503          	lw	a0,0(a0)
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
40011fd8:	00c50513          	addi	a0,a0,12
40011fdc:	00c190ef          	jal	ra,4002afe8 <atomic_get>
	return net_if_flag_is_set(iface, NET_IF_UP) &&
40011fe0:	00157513          	andi	a0,a0,1
40011fe4:	00051663          	bnez	a0,40011ff0 <context_sendto.constprop.0+0x240>
		return -ENETDOWN;
40011fe8:	f8d00413          	li	s0,-115
40011fec:	e35ff06f          	j	40011e20 <context_sendto.constprop.0+0x70>
	return atomic_test_bit(iface->if_dev->flags, value);
40011ff0:	00042503          	lw	a0,0(s0)
40011ff4:	00c50513          	addi	a0,a0,12
40011ff8:	7f1180ef          	jal	ra,4002afe8 <atomic_get>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
40011ffc:	40855513          	srai	a0,a0,0x8
	return net_if_flag_is_set(iface, NET_IF_UP) &&
40012000:	00157513          	andi	a0,a0,1
40012004:	f40510e3          	bnez	a0,40011f44 <context_sendto.constprop.0+0x194>
40012008:	fe1ff06f          	j	40011fe8 <context_sendto.constprop.0+0x238>
	pkt->context = ctx;
4001200c:	01352a23          	sw	s3,20(a0)
	tmp_len = net_pkt_available_payload_buffer(
40012010:	0729d583          	lhu	a1,114(s3)
40012014:	06c010ef          	jal	ra,40013080 <net_pkt_available_payload_buffer>
	if (tmp_len < len) {
40012018:	0d256863          	bltu	a0,s2,400120e8 <context_sendto.constprop.0+0x338>
	return context->proto;
4001201c:	0729d783          	lhu	a5,114(s3)
	context->send_cb = cb;
40012020:	0579a623          	sw	s7,76(s3)
	context->user_data = user_data;
40012024:	0189a223          	sw	s8,4(s3)
	} else if (IS_ENABLED(CONFIG_NET_UDP) &&
40012028:	01100713          	li	a4,17
4001202c:	10e79c63          	bne	a5,a4,40012144 <context_sendto.constprop.0+0x394>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40012030:	0749d783          	lhu	a5,116(s3)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40012034:	00200713          	li	a4,2
40012038:	0037d793          	srli	a5,a5,0x3
4001203c:	0077f793          	andi	a5,a5,7
40012040:	0ce79263          	bne	a5,a4,40012104 <context_sendto.constprop.0+0x354>
		ret = net_context_create_ipv6_new(context, pkt,
40012044:	004a0693          	addi	a3,s4,4
40012048:	00000613          	li	a2,0
4001204c:	00048593          	mv	a1,s1
40012050:	00098513          	mv	a0,s3
		dst_port = addr6->sin6_port;
40012054:	002a5b83          	lhu	s7,2(s4)
		ret = net_context_create_ipv6_new(context, pkt,
40012058:	ca1ff0ef          	jal	ra,40011cf8 <net_context_create_ipv6_new>
		ret = net_context_create_ipv4_new(context, pkt,
4001205c:	00050413          	mv	s0,a0
	if (ret < 0) {
40012060:	14054063          	bltz	a0,400121a0 <context_sendto.constprop.0+0x3f0>
	ret = bind_default(context);
40012064:	00098513          	mv	a0,s3
40012068:	a41ff0ef          	jal	ra,40011aa8 <bind_default>
4001206c:	00050413          	mv	s0,a0
	if (ret) {
40012070:	02051a63          	bnez	a0,400120a4 <context_sendto.constprop.0+0x2f4>
	ret = net_udp_create(pkt,
40012074:	0229d583          	lhu	a1,34(s3)
40012078:	000b8613          	mv	a2,s7
4001207c:	00048513          	mv	a0,s1
40012080:	7390c0ef          	jal	ra,4001efb8 <net_udp_create>
40012084:	00050413          	mv	s0,a0
	if (ret) {
40012088:	00051e63          	bnez	a0,400120a4 <context_sendto.constprop.0+0x2f4>
	ret = context_write_data(pkt, buf, len, msg);
4001208c:	000b0693          	mv	a3,s6
40012090:	00090613          	mv	a2,s2
40012094:	000a8593          	mv	a1,s5
40012098:	00048513          	mv	a0,s1
4001209c:	a64ff0ef          	jal	ra,40011300 <context_write_data>
400120a0:	00050413          	mv	s0,a0
		if (ret < 0) {
400120a4:	0e044e63          	bltz	s0,400121a0 <context_sendto.constprop.0+0x3f0>
	net_pkt_cursor_init(pkt);
400120a8:	00048513          	mv	a0,s1
400120ac:	144010ef          	jal	ra,400131f0 <net_pkt_cursor_init>
400120b0:	0749d783          	lhu	a5,116(s3)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
400120b4:	00200713          	li	a4,2
400120b8:	0037d793          	srli	a5,a5,0x3
400120bc:	0077f793          	andi	a5,a5,7
400120c0:	06e79663          	bne	a5,a4,4001212c <context_sendto.constprop.0+0x37c>
		net_ipv6_finalize(pkt, net_context_get_proto(context));
400120c4:	0729c583          	lbu	a1,114(s3)
400120c8:	00048513          	mv	a0,s1
400120cc:	115040ef          	jal	ra,400169e0 <net_ipv6_finalize>
		ret = net_send_data(pkt);
400120d0:	00048513          	mv	a0,s1
400120d4:	df4f90ef          	jal	ra,4000b6c8 <net_send_data>
		ret = net_tcp_send_data(context, cb, user_data);
400120d8:	00050413          	mv	s0,a0
	if (ret < 0) {
400120dc:	0c054263          	bltz	a0,400121a0 <context_sendto.constprop.0+0x3f0>
	return len;
400120e0:	00090413          	mv	s0,s2
400120e4:	d3dff06f          	j	40011e20 <context_sendto.constprop.0+0x70>
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
400120e8:	0749d783          	lhu	a5,116(s3)
		if (net_context_get_type(context) == SOCK_DGRAM) {
400120ec:	00200713          	li	a4,2
400120f0:	0067d793          	srli	a5,a5,0x6
400120f4:	0037f793          	andi	a5,a5,3
400120f8:	0ae78263          	beq	a5,a4,4001219c <context_sendto.constprop.0+0x3ec>
400120fc:	00050913          	mv	s2,a0
40012100:	f1dff06f          	j	4001201c <context_sendto.constprop.0+0x26c>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40012104:	00100713          	li	a4,1
	int ret = -EINVAL;
40012108:	fea00413          	li	s0,-22
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
4001210c:	08e79a63          	bne	a5,a4,400121a0 <context_sendto.constprop.0+0x3f0>
		ret = net_context_create_ipv4_new(context, pkt,
40012110:	004a0693          	addi	a3,s4,4
40012114:	00000613          	li	a2,0
40012118:	00048593          	mv	a1,s1
4001211c:	00098513          	mv	a0,s3
		dst_port = addr4->sin_port;
40012120:	002a5b83          	lhu	s7,2(s4)
		ret = net_context_create_ipv4_new(context, pkt,
40012124:	ab1ff0ef          	jal	ra,40011bd4 <net_context_create_ipv4_new>
40012128:	f35ff06f          	j	4001205c <context_sendto.constprop.0+0x2ac>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
4001212c:	00100713          	li	a4,1
40012130:	fae790e3          	bne	a5,a4,400120d0 <context_sendto.constprop.0+0x320>
		net_ipv4_finalize(pkt, net_context_get_proto(context));
40012134:	0729c583          	lbu	a1,114(s3)
40012138:	00048513          	mv	a0,s1
4001213c:	6ac030ef          	jal	ra,400157e8 <net_ipv4_finalize>
40012140:	f91ff06f          	j	400120d0 <context_sendto.constprop.0+0x320>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
40012144:	00600713          	li	a4,6
		ret = -EPROTONOSUPPORT;
40012148:	f8500413          	li	s0,-123
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
4001214c:	04e79a63          	bne	a5,a4,400121a0 <context_sendto.constprop.0+0x3f0>
		ret = context_write_data(pkt, buf, len, msghdr);
40012150:	000b0693          	mv	a3,s6
40012154:	00090613          	mv	a2,s2
40012158:	000a8593          	mv	a1,s5
4001215c:	00048513          	mv	a0,s1
40012160:	9a0ff0ef          	jal	ra,40011300 <context_write_data>
40012164:	00050413          	mv	s0,a0
		if (ret < 0) {
40012168:	02054c63          	bltz	a0,400121a0 <context_sendto.constprop.0+0x3f0>
		net_pkt_cursor_init(pkt);
4001216c:	00048513          	mv	a0,s1
40012170:	080010ef          	jal	ra,400131f0 <net_pkt_cursor_init>
		ret = net_tcp_queue_data(context, pkt);
40012174:	00048593          	mv	a1,s1
40012178:	00098513          	mv	a0,s3
4001217c:	7390a0ef          	jal	ra,4001d0b4 <net_tcp_queue_data>
40012180:	00050413          	mv	s0,a0
		if (ret < 0) {
40012184:	00054e63          	bltz	a0,400121a0 <context_sendto.constprop.0+0x3f0>
		ret = net_tcp_send_data(context, cb, user_data);
40012188:	000c0613          	mv	a2,s8
4001218c:	000b8593          	mv	a1,s7
40012190:	00098513          	mv	a0,s3
40012194:	389090ef          	jal	ra,4001bd1c <net_tcp_send_data>
40012198:	f41ff06f          	j	400120d8 <context_sendto.constprop.0+0x328>
			ret = -ENOMEM;
4001219c:	ff400413          	li	s0,-12
	net_pkt_unref(pkt);
400121a0:	00048513          	mv	a0,s1
400121a4:	579000ef          	jal	ra,40012f1c <net_pkt_unref>
	return ret;
400121a8:	c79ff06f          	j	40011e20 <context_sendto.constprop.0+0x70>

400121ac <net_context_connect>:
{
400121ac:	f8010113          	addi	sp,sp,-128
400121b0:	05712e23          	sw	s7,92(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
400121b4:	00c50b93          	addi	s7,a0,12
{
400121b8:	06812c23          	sw	s0,120(sp)
400121bc:	07212823          	sw	s2,112(sp)
400121c0:	07412423          	sw	s4,104(sp)
400121c4:	00050413          	mv	s0,a0
400121c8:	00058913          	mv	s2,a1
400121cc:	00060a13          	mv	s4,a2
	k_mutex_lock(&context->lock, K_FOREVER);
400121d0:	fff00593          	li	a1,-1
400121d4:	fff00613          	li	a2,-1
400121d8:	000b8513          	mv	a0,s7
{
400121dc:	06912a23          	sw	s1,116(sp)
400121e0:	07312623          	sw	s3,108(sp)
400121e4:	07512223          	sw	s5,100(sp)
400121e8:	07612023          	sw	s6,96(sp)
400121ec:	05812c23          	sw	s8,88(sp)
400121f0:	00078b13          	mv	s6,a5
400121f4:	00070c13          	mv	s8,a4
400121f8:	06112e23          	sw	ra,124(sp)
400121fc:	05912a23          	sw	s9,84(sp)
40012200:	00068993          	mv	s3,a3
40012204:	00080a93          	mv	s5,a6
	k_mutex_lock(&context->lock, K_FOREVER);
40012208:	994ff0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
4001220c:	07445783          	lhu	a5,116(s0)
	if (net_context_get_state(context) == NET_CONTEXT_CONNECTING) {
40012210:	00100613          	li	a2,1
		ret = -EALREADY;
40012214:	f8800493          	li	s1,-120
40012218:	0017d713          	srli	a4,a5,0x1
4001221c:	00377713          	andi	a4,a4,3
	if (net_context_get_state(context) == NET_CONTEXT_CONNECTING) {
40012220:	10c70e63          	beq	a4,a2,4001233c <net_context_connect+0x190>
	if (!net_context_is_used(context)) {
40012224:	0017f693          	andi	a3,a5,1
		ret = -EBADF;
40012228:	ff700493          	li	s1,-9
	if (!net_context_is_used(context)) {
4001222c:	10068863          	beqz	a3,4001233c <net_context_connect+0x190>
	if (addr->sa_family != net_context_get_family(context)) {
40012230:	00095c83          	lhu	s9,0(s2)
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40012234:	0037d793          	srli	a5,a5,0x3
40012238:	0077f793          	andi	a5,a5,7
		ret = -EINVAL;
4001223c:	fea00493          	li	s1,-22
	if (addr->sa_family != net_context_get_family(context)) {
40012240:	0efc9e63          	bne	s9,a5,4001233c <net_context_connect+0x190>
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
40012244:	00300793          	li	a5,3
		ret = -EOPNOTSUPP;
40012248:	fa100493          	li	s1,-95
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
4001224c:	0ef70863          	beq	a4,a5,4001233c <net_context_connect+0x190>
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40012250:	00200793          	li	a5,2
40012254:	12fc9c63          	bne	s9,a5,4001238c <net_context_connect+0x1e0>
		if (addrlen < sizeof(struct sockaddr_in6)) {
40012258:	01700793          	li	a5,23
		ret = -EINVAL;
4001225c:	fea00493          	li	s1,-22
		if (addrlen < sizeof(struct sockaddr_in6)) {
40012260:	0d47fe63          	bgeu	a5,s4,4001233c <net_context_connect+0x190>
		if (net_context_get_proto(context) == IPPROTO_TCP &&
40012264:	07245703          	lhu	a4,114(s0)
40012268:	00600793          	li	a5,6
4001226c:	00f71a63          	bne	a4,a5,40012280 <net_context_connect+0xd4>
40012270:	03044703          	lbu	a4,48(s0)
40012274:	0ff00793          	li	a5,255
			ret = -EADDRNOTAVAIL;
40012278:	f8300493          	li	s1,-125
		if (net_context_get_proto(context) == IPPROTO_TCP &&
4001227c:	0cf70063          	beq	a4,a5,4001233c <net_context_connect+0x190>
		memcpy(&addr6->sin6_addr, &net_sin6(addr)->sin6_addr,
40012280:	03040493          	addi	s1,s0,48
40012284:	01000613          	li	a2,16
40012288:	00490593          	addi	a1,s2,4
4001228c:	00048513          	mv	a0,s1
40012290:	dbdf60ef          	jal	ra,4000904c <memcpy>
		addr6->sin6_port = net_sin6(addr)->sin6_port;
40012294:	00295a03          	lhu	s4,2(s2)
		addr6->sin6_family = AF_INET6;
40012298:	00200793          	li	a5,2
4001229c:	02f41623          	sh	a5,44(s0)
		addr6->sin6_port = net_sin6(addr)->sin6_port;
400122a0:	03441723          	sh	s4,46(s0)
		if (!net_ipv6_is_addr_unspecified(&addr6->sin6_addr)) {
400122a4:	00048513          	mv	a0,s1
400122a8:	dedfe0ef          	jal	ra,40011094 <net_ipv6_is_addr_unspecified>
400122ac:	07445783          	lhu	a5,116(s0)
400122b0:	0c051663          	bnez	a0,4001237c <net_context_connect+0x1d0>
			context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
400122b4:	1007e793          	ori	a5,a5,256
400122b8:	06f41a23          	sh	a5,116(s0)
		ret = bind_default(context);
400122bc:	00040513          	mv	a0,s0
400122c0:	fe8ff0ef          	jal	ra,40011aa8 <bind_default>
400122c4:	00050493          	mv	s1,a0
		if (ret) {
400122c8:	06051a63          	bnez	a0,4001233c <net_context_connect+0x190>
		net_sin6(&local_addr)->sin6_port = lport =
400122cc:	02245703          	lhu	a4,34(s0)
		if (net_sin6_ptr(&context->local)->sin6_addr) {
400122d0:	02442583          	lw	a1,36(s0)
		net_sin6_ptr(&context->local)->sin6_family = AF_INET6;
400122d4:	00200793          	li	a5,2
400122d8:	02f41023          	sh	a5,32(s0)
		net_sin6(&local_addr)->sin6_family = AF_INET6;
400122dc:	02f11c23          	sh	a5,56(sp)
		net_sin6(&local_addr)->sin6_port = lport =
400122e0:	02e11d23          	sh	a4,58(sp)
		if (net_sin6_ptr(&context->local)->sin6_addr) {
400122e4:	02058663          	beqz	a1,40012310 <net_context_connect+0x164>
			net_ipaddr_copy(&net_sin6(&local_addr)->sin6_addr,
400122e8:	01000613          	li	a2,16
400122ec:	02810513          	addi	a0,sp,40
400122f0:	00e12e23          	sw	a4,28(sp)
400122f4:	d59f60ef          	jal	ra,4000904c <memcpy>
400122f8:	02810593          	addi	a1,sp,40
400122fc:	01000613          	li	a2,16
40012300:	03c10513          	addi	a0,sp,60
40012304:	d49f60ef          	jal	ra,4000904c <memcpy>
			laddr = &local_addr;
40012308:	01c12703          	lw	a4,28(sp)
4001230c:	03810593          	addi	a1,sp,56
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
40012310:	07445783          	lhu	a5,116(s0)
	if (IS_ENABLED(CONFIG_NET_UDP) &&
40012314:	00200693          	li	a3,2
40012318:	0067d793          	srli	a5,a5,0x6
4001231c:	0037f793          	andi	a5,a5,3
40012320:	10d79e63          	bne	a5,a3,4001243c <net_context_connect+0x290>
		if (cb) {
40012324:	00098a63          	beqz	s3,40012338 <net_context_connect+0x18c>
			cb(context, 0, user_data);
40012328:	000a8613          	mv	a2,s5
4001232c:	00000593          	li	a1,0
40012330:	00040513          	mv	a0,s0
40012334:	000980e7          	jalr	s3
		ret = 0;
40012338:	00000493          	li	s1,0
	k_mutex_unlock(&context->lock);
4001233c:	000b8513          	mv	a0,s7
40012340:	860ff0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>
}
40012344:	07c12083          	lw	ra,124(sp)
40012348:	07812403          	lw	s0,120(sp)
4001234c:	07012903          	lw	s2,112(sp)
40012350:	06c12983          	lw	s3,108(sp)
40012354:	06812a03          	lw	s4,104(sp)
40012358:	06412a83          	lw	s5,100(sp)
4001235c:	06012b03          	lw	s6,96(sp)
40012360:	05c12b83          	lw	s7,92(sp)
40012364:	05812c03          	lw	s8,88(sp)
40012368:	05412c83          	lw	s9,84(sp)
4001236c:	00048513          	mv	a0,s1
40012370:	07412483          	lw	s1,116(sp)
40012374:	08010113          	addi	sp,sp,128
40012378:	00008067          	ret
			context->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;
4001237c:	eff7f793          	andi	a5,a5,-257
40012380:	01079793          	slli	a5,a5,0x10
40012384:	0107d793          	srli	a5,a5,0x10
40012388:	f31ff06f          	j	400122b8 <net_context_connect+0x10c>
		ret = -EINVAL;
4001238c:	fea00493          	li	s1,-22
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40012390:	facc96e3          	bne	s9,a2,4001233c <net_context_connect+0x190>
		if (addrlen < sizeof(struct sockaddr_in)) {
40012394:	00700793          	li	a5,7
40012398:	fb47f2e3          	bgeu	a5,s4,4001233c <net_context_connect+0x190>
		memcpy(&addr4->sin_addr, &net_sin(addr)->sin_addr,
4001239c:	00400613          	li	a2,4
400123a0:	00490593          	addi	a1,s2,4
400123a4:	03040513          	addi	a0,s0,48
400123a8:	ca5f60ef          	jal	ra,4000904c <memcpy>
		addr4->sin_port = net_sin(addr)->sin_port;
400123ac:	00295a03          	lhu	s4,2(s2)
		if (addr4->sin_addr.s_addr) {
400123b0:	03042703          	lw	a4,48(s0)
		addr4->sin_family = AF_INET;
400123b4:	03941623          	sh	s9,44(s0)
		addr4->sin_port = net_sin(addr)->sin_port;
400123b8:	03441723          	sh	s4,46(s0)
		if (addr4->sin_addr.s_addr) {
400123bc:	07445783          	lhu	a5,116(s0)
400123c0:	06070663          	beqz	a4,4001242c <net_context_connect+0x280>
			context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
400123c4:	1007e793          	ori	a5,a5,256
400123c8:	06f41a23          	sh	a5,116(s0)
		ret = bind_default(context);
400123cc:	00040513          	mv	a0,s0
400123d0:	ed8ff0ef          	jal	ra,40011aa8 <bind_default>
400123d4:	00050493          	mv	s1,a0
		if (ret) {
400123d8:	f60512e3          	bnez	a0,4001233c <net_context_connect+0x190>
		net_sin(&local_addr)->sin_port = lport =
400123dc:	02245703          	lhu	a4,34(s0)
		if (net_sin_ptr(&context->local)->sin_addr) {
400123e0:	02442583          	lw	a1,36(s0)
		net_sin_ptr(&context->local)->sin_family = AF_INET;
400123e4:	00100793          	li	a5,1
400123e8:	02f41023          	sh	a5,32(s0)
		net_sin(&local_addr)->sin_family = AF_INET;
400123ec:	02f11c23          	sh	a5,56(sp)
		net_sin(&local_addr)->sin_port = lport =
400123f0:	02e11d23          	sh	a4,58(sp)
		if (net_sin_ptr(&context->local)->sin_addr) {
400123f4:	f0058ee3          	beqz	a1,40012310 <net_context_connect+0x164>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
400123f8:	0015c783          	lbu	a5,1(a1)
400123fc:	0005c683          	lbu	a3,0(a1)
40012400:	00879793          	slli	a5,a5,0x8
40012404:	00d7e7b3          	or	a5,a5,a3
40012408:	0025c683          	lbu	a3,2(a1)
4001240c:	01069693          	slli	a3,a3,0x10
40012410:	00f6e6b3          	or	a3,a3,a5
40012414:	0035c783          	lbu	a5,3(a1)
			laddr = &local_addr;
40012418:	03810593          	addi	a1,sp,56
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
4001241c:	01879793          	slli	a5,a5,0x18
40012420:	00d7e7b3          	or	a5,a5,a3
40012424:	02f12e23          	sw	a5,60(sp)
			laddr = &local_addr;
40012428:	ee9ff06f          	j	40012310 <net_context_connect+0x164>
			context->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;
4001242c:	eff7f793          	andi	a5,a5,-257
40012430:	01079793          	slli	a5,a5,0x10
40012434:	0107d793          	srli	a5,a5,0x10
40012438:	f91ff06f          	j	400123c8 <net_context_connect+0x21c>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
4001243c:	00100693          	li	a3,1
		ret = -ENOTSUP;
40012440:	f7a00493          	li	s1,-134
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
40012444:	eed79ce3          	bne	a5,a3,4001233c <net_context_connect+0x190>
		ret = net_tcp_connect(context, addr, laddr, rport, lport,
40012448:	00058613          	mv	a2,a1
4001244c:	01512023          	sw	s5,0(sp)
40012450:	00098893          	mv	a7,s3
40012454:	000c0793          	mv	a5,s8
40012458:	000b0813          	mv	a6,s6
4001245c:	000a0693          	mv	a3,s4
40012460:	00090593          	mv	a1,s2
40012464:	00040513          	mv	a0,s0
40012468:	4bc0c0ef          	jal	ra,4001e924 <net_tcp_connect>
4001246c:	00050493          	mv	s1,a0
40012470:	ecdff06f          	j	4001233c <net_context_connect+0x190>

40012474 <net_context_accept>:
{
40012474:	fe010113          	addi	sp,sp,-32
40012478:	00912a23          	sw	s1,20(sp)
4001247c:	00112e23          	sw	ra,28(sp)
40012480:	00812c23          	sw	s0,24(sp)
40012484:	01212823          	sw	s2,16(sp)
40012488:	01312623          	sw	s3,12(sp)
4001248c:	01412423          	sw	s4,8(sp)
	return context->flags & NET_CONTEXT_IN_USE;
40012490:	07455783          	lhu	a5,116(a0)
		return -EBADF;
40012494:	ff700493          	li	s1,-9
	if (!net_context_is_used(context)) {
40012498:	0017f793          	andi	a5,a5,1
4001249c:	06078c63          	beqz	a5,40012514 <net_context_accept+0xa0>
	k_mutex_lock(&context->lock, K_FOREVER);
400124a0:	00c50a13          	addi	s4,a0,12
400124a4:	00050413          	mv	s0,a0
400124a8:	00058913          	mv	s2,a1
400124ac:	fff00613          	li	a2,-1
400124b0:	fff00593          	li	a1,-1
400124b4:	000a0513          	mv	a0,s4
400124b8:	00070993          	mv	s3,a4
400124bc:	ee1fe0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
400124c0:	07445783          	lhu	a5,116(s0)
	if ((net_context_get_state(context) != NET_CONTEXT_LISTENING) &&
400124c4:	00300693          	li	a3,3
400124c8:	0017d713          	srli	a4,a5,0x1
400124cc:	00377713          	andi	a4,a4,3
400124d0:	00d70c63          	beq	a4,a3,400124e8 <net_context_accept+0x74>
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
400124d4:	0067d793          	srli	a5,a5,0x6
400124d8:	0037f793          	andi	a5,a5,3
400124dc:	00100713          	li	a4,1
		ret = -EINVAL;
400124e0:	fea00493          	li	s1,-22
	if ((net_context_get_state(context) != NET_CONTEXT_LISTENING) &&
400124e4:	02e79463          	bne	a5,a4,4001250c <net_context_accept+0x98>
	if (net_context_get_proto(context) == IPPROTO_TCP) {
400124e8:	07245703          	lhu	a4,114(s0)
400124ec:	00600793          	li	a5,6
	int ret = 0;
400124f0:	00000493          	li	s1,0
	if (net_context_get_proto(context) == IPPROTO_TCP) {
400124f4:	00f71c63          	bne	a4,a5,4001250c <net_context_accept+0x98>
		ret = net_tcp_accept(context, cb, user_data);
400124f8:	00098613          	mv	a2,s3
400124fc:	00090593          	mv	a1,s2
40012500:	00040513          	mv	a0,s0
40012504:	049090ef          	jal	ra,4001bd4c <net_tcp_accept>
40012508:	00050493          	mv	s1,a0
	k_mutex_unlock(&context->lock);
4001250c:	000a0513          	mv	a0,s4
40012510:	e91fe0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>
}
40012514:	01c12083          	lw	ra,28(sp)
40012518:	01812403          	lw	s0,24(sp)
4001251c:	01012903          	lw	s2,16(sp)
40012520:	00c12983          	lw	s3,12(sp)
40012524:	00812a03          	lw	s4,8(sp)
40012528:	00048513          	mv	a0,s1
4001252c:	01412483          	lw	s1,20(sp)
40012530:	02010113          	addi	sp,sp,32
40012534:	00008067          	ret

40012538 <net_context_send>:
{
40012538:	fd010113          	addi	sp,sp,-48
4001253c:	01412c23          	sw	s4,24(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40012540:	00c50a13          	addi	s4,a0,12
{
40012544:	02812423          	sw	s0,40(sp)
40012548:	03212023          	sw	s2,32(sp)
4001254c:	01312e23          	sw	s3,28(sp)
40012550:	00050413          	mv	s0,a0
40012554:	00058913          	mv	s2,a1
40012558:	00060993          	mv	s3,a2
	k_mutex_lock(&context->lock, K_FOREVER);
4001255c:	fff00593          	li	a1,-1
40012560:	fff00613          	li	a2,-1
40012564:	000a0513          	mv	a0,s4
{
40012568:	02912223          	sw	s1,36(sp)
4001256c:	02112623          	sw	ra,44(sp)
40012570:	00d12623          	sw	a3,12(sp)
40012574:	01012423          	sw	a6,8(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40012578:	e25fe0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
	if (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||
4001257c:	07445883          	lhu	a7,116(s0)
		ret = -EDESTADDRREQ;
40012580:	f8700493          	li	s1,-121
	if (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||
40012584:	1008f713          	andi	a4,a7,256
40012588:	04070a63          	beqz	a4,400125dc <net_context_send+0xa4>
4001258c:	02e45703          	lhu	a4,46(s0)
		ret = -EDESTADDRREQ;
40012590:	f8700493          	li	s1,-121
	if (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||
40012594:	04070463          	beqz	a4,400125dc <net_context_send+0xa4>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40012598:	0038d893          	srli	a7,a7,0x3
4001259c:	0078f893          	andi	a7,a7,7
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
400125a0:	00200693          	li	a3,2
400125a4:	00812803          	lw	a6,8(sp)
400125a8:	00c12783          	lw	a5,12(sp)
		addrlen = sizeof(struct sockaddr_in6);
400125ac:	01800713          	li	a4,24
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
400125b0:	00d88863          	beq	a7,a3,400125c0 <net_context_send+0x88>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
400125b4:	fff88893          	addi	a7,a7,-1
400125b8:	0018b893          	seqz	a7,a7
400125bc:	00389713          	slli	a4,a7,0x3
	ret = context_sendto(context, buf, len, &context->remote,
400125c0:	00000893          	li	a7,0
400125c4:	02c40693          	addi	a3,s0,44
400125c8:	00098613          	mv	a2,s3
400125cc:	00090593          	mv	a1,s2
400125d0:	00040513          	mv	a0,s0
400125d4:	fdcff0ef          	jal	ra,40011db0 <context_sendto.constprop.0>
400125d8:	00050493          	mv	s1,a0
	k_mutex_unlock(&context->lock);
400125dc:	000a0513          	mv	a0,s4
400125e0:	dc1fe0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>
}
400125e4:	02c12083          	lw	ra,44(sp)
400125e8:	02812403          	lw	s0,40(sp)
400125ec:	02012903          	lw	s2,32(sp)
400125f0:	01c12983          	lw	s3,28(sp)
400125f4:	01812a03          	lw	s4,24(sp)
400125f8:	00048513          	mv	a0,s1
400125fc:	02412483          	lw	s1,36(sp)
40012600:	03010113          	addi	sp,sp,48
40012604:	00008067          	ret

40012608 <net_context_sendto>:
{
40012608:	fd010113          	addi	sp,sp,-48
4001260c:	01312e23          	sw	s3,28(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40012610:	00c50993          	addi	s3,a0,12
{
40012614:	02812423          	sw	s0,40(sp)
40012618:	02912223          	sw	s1,36(sp)
4001261c:	03212023          	sw	s2,32(sp)
40012620:	00050413          	mv	s0,a0
40012624:	00058493          	mv	s1,a1
40012628:	00060913          	mv	s2,a2
	k_mutex_lock(&context->lock, K_FOREVER);
4001262c:	00098513          	mv	a0,s3
40012630:	fff00593          	li	a1,-1
40012634:	fff00613          	li	a2,-1
{
40012638:	02112623          	sw	ra,44(sp)
4001263c:	00d12623          	sw	a3,12(sp)
40012640:	00e12423          	sw	a4,8(sp)
40012644:	00f12223          	sw	a5,4(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40012648:	d55fe0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
	ret = context_sendto(context, buf, len, dst_addr, addrlen,
4001264c:	03012803          	lw	a6,48(sp)
40012650:	00412783          	lw	a5,4(sp)
40012654:	00812703          	lw	a4,8(sp)
40012658:	00c12683          	lw	a3,12(sp)
4001265c:	00090613          	mv	a2,s2
40012660:	00048593          	mv	a1,s1
40012664:	00100893          	li	a7,1
40012668:	00040513          	mv	a0,s0
4001266c:	f44ff0ef          	jal	ra,40011db0 <context_sendto.constprop.0>
40012670:	00050413          	mv	s0,a0
	k_mutex_unlock(&context->lock);
40012674:	00098513          	mv	a0,s3
40012678:	d29fe0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>
}
4001267c:	02c12083          	lw	ra,44(sp)
40012680:	00040513          	mv	a0,s0
40012684:	02812403          	lw	s0,40(sp)
40012688:	02412483          	lw	s1,36(sp)
4001268c:	02012903          	lw	s2,32(sp)
40012690:	01c12983          	lw	s3,28(sp)
40012694:	03010113          	addi	sp,sp,48
40012698:	00008067          	ret

4001269c <net_context_recv>:

int net_context_recv(struct net_context *context,
		     net_context_recv_cb_t cb,
		     k_timeout_t timeout,
		     void *user_data)
{
4001269c:	f9010113          	addi	sp,sp,-112
400126a0:	06912223          	sw	s1,100(sp)
400126a4:	06112623          	sw	ra,108(sp)
400126a8:	06812423          	sw	s0,104(sp)
400126ac:	07212023          	sw	s2,96(sp)
400126b0:	05312e23          	sw	s3,92(sp)
400126b4:	05412c23          	sw	s4,88(sp)
400126b8:	05512a23          	sw	s5,84(sp)
400126bc:	05612823          	sw	s6,80(sp)
400126c0:	05712623          	sw	s7,76(sp)
	return context->flags & NET_CONTEXT_IN_USE;
400126c4:	07455783          	lhu	a5,116(a0)
	int ret;
	NET_ASSERT(context);

	if (!net_context_is_used(context)) {
		return -EBADF;
400126c8:	ff700493          	li	s1,-9
	if (!net_context_is_used(context)) {
400126cc:	0017f793          	andi	a5,a5,1
400126d0:	16078863          	beqz	a5,40012840 <net_context_recv+0x1a4>
	}

	k_mutex_lock(&context->lock, K_FOREVER);
400126d4:	00c50913          	addi	s2,a0,12
400126d8:	00050413          	mv	s0,a0
400126dc:	00058b13          	mv	s6,a1
400126e0:	00060a13          	mv	s4,a2
400126e4:	fff00593          	li	a1,-1
400126e8:	fff00613          	li	a2,-1
400126ec:	00090513          	mv	a0,s2
400126f0:	00070a93          	mv	s5,a4
400126f4:	00068993          	mv	s3,a3
400126f8:	ca5fe0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
	return context->proto;
400126fc:	07245783          	lhu	a5,114(s0)
			net_context_get_iface(context),
			context, cb, timeout, user_data);
		goto unlock;
	}

	if (IS_ENABLED(CONFIG_NET_UDP) &&
40012700:	01100713          	li	a4,17
40012704:	1ce79063          	bne	a5,a4,400128c4 <net_context_recv+0x228>
	struct sockaddr local_addr = {
40012708:	01600613          	li	a2,22
4001270c:	00000593          	li	a1,0
40012710:	02a10513          	addi	a0,sp,42
40012714:	95df60ef          	jal	ra,40009070 <memset>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40012718:	07445783          	lhu	a5,116(s0)
	if (context->conn_handler) {
4001271c:	04442503          	lw	a0,68(s0)
40012720:	0037d793          	srli	a5,a5,0x3
40012724:	0077f793          	andi	a5,a5,7
	struct sockaddr local_addr = {
40012728:	02f11423          	sh	a5,40(sp)
	if (context->conn_handler) {
4001272c:	00050663          	beqz	a0,40012738 <net_context_recv+0x9c>
		net_conn_unregister(context->conn_handler);
40012730:	044020ef          	jal	ra,40014774 <net_conn_unregister>
		context->conn_handler = NULL;
40012734:	04042223          	sw	zero,68(s0)
	ret = bind_default(context);
40012738:	00040513          	mv	a0,s0
4001273c:	b6cff0ef          	jal	ra,40011aa8 <bind_default>
40012740:	00050493          	mv	s1,a0
	if (ret) {
40012744:	0a051a63          	bnez	a0,400127f8 <net_context_recv+0x15c>
40012748:	07445b83          	lhu	s7,116(s0)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
4001274c:	00200793          	li	a5,2
40012750:	003bd493          	srli	s1,s7,0x3
40012754:	0074f493          	andi	s1,s1,7
40012758:	10f49c63          	bne	s1,a5,40012870 <net_context_recv+0x1d4>
		if (net_sin6_ptr(&context->local)->sin6_addr) {
4001275c:	02442683          	lw	a3,36(s0)
40012760:	02068463          	beqz	a3,40012788 <net_context_recv+0xec>
			net_ipaddr_copy(&net_sin6(&local_addr)->sin6_addr,
40012764:	00068593          	mv	a1,a3
40012768:	01000613          	li	a2,16
4001276c:	01810513          	addi	a0,sp,24
40012770:	8ddf60ef          	jal	ra,4000904c <memcpy>
40012774:	01000613          	li	a2,16
40012778:	01810593          	addi	a1,sp,24
4001277c:	02c10513          	addi	a0,sp,44
40012780:	8cdf60ef          	jal	ra,4000904c <memcpy>
			laddr = &local_addr;
40012784:	02810693          	addi	a3,sp,40
			net_sin6((struct sockaddr *)&context->local)->sin6_port;
40012788:	02245803          	lhu	a6,34(s0)
		net_sin6(&local_addr)->sin6_port =
4001278c:	03011523          	sh	a6,42(sp)
	context->recv_cb = cb;
40012790:	05642423          	sw	s6,72(s0)
	ret = net_conn_register(net_context_get_proto(context),
40012794:	100bfb93          	andi	s7,s7,256
	return context->proto;
40012798:	07245503          	lhu	a0,114(s0)
4001279c:	0ff4f593          	zext.b	a1,s1
400127a0:	00000613          	li	a2,0
400127a4:	000b8463          	beqz	s7,400127ac <net_context_recv+0x110>
400127a8:	02c40613          	addi	a2,s0,44
400127ac:	00881793          	slli	a5,a6,0x8
400127b0:	00885813          	srli	a6,a6,0x8
400127b4:	0107e7b3          	or	a5,a5,a6
400127b8:	02e45803          	lhu	a6,46(s0)
400127bc:	400118b7          	lui	a7,0x40011
400127c0:	01079793          	slli	a5,a5,0x10
400127c4:	00881713          	slli	a4,a6,0x8
400127c8:	00885813          	srli	a6,a6,0x8
400127cc:	01076733          	or	a4,a4,a6
400127d0:	01071713          	slli	a4,a4,0x10
400127d4:	04440813          	addi	a6,s0,68
400127d8:	01012223          	sw	a6,4(sp)
400127dc:	01512023          	sw	s5,0(sp)
400127e0:	3a488893          	addi	a7,a7,932 # 400113a4 <net_context_packet_received>
400127e4:	00040813          	mv	a6,s0
400127e8:	0107d793          	srli	a5,a5,0x10
400127ec:	01075713          	srli	a4,a4,0x10
400127f0:	359010ef          	jal	ra,40014348 <net_conn_register>
	    net_context_get_proto(context) == IPPROTO_UDP) {
		ret = recv_udp(context, cb, timeout, user_data);
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
		   net_context_get_proto(context) == IPPROTO_TCP) {
		ret = net_tcp_recv(context, cb, user_data);
400127f4:	00050493          	mv	s1,a0
		} else {
			ret = -EPROTOTYPE;
		}
	}

	if (ret < 0) {
400127f8:	0404c063          	bltz	s1,40012838 <net_context_recv+0x19c>
		goto unlock;
	}

#if defined(CONFIG_NET_CONTEXT_SYNC_RECV)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
400127fc:	013a67b3          	or	a5,s4,s3
40012800:	02078c63          	beqz	a5,40012838 <net_context_recv+0x19c>

		/* Make sure we have the lock, then the
		 * net_context_packet_received() callback will release the
		 * semaphore when data has been received.
		 */
		k_sem_reset(&context->recv_data_wait);
40012804:	05840413          	addi	s0,s0,88
	z_impl_k_sem_reset(sem);
40012808:	00040513          	mv	a0,s0
4001280c:	63c160ef          	jal	ra,40028e48 <z_impl_k_sem_reset>

		k_mutex_unlock(&context->lock);
40012810:	00090513          	mv	a0,s2
40012814:	b8dfe0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>
	return z_impl_k_sem_take(sem, timeout);
40012818:	000a0593          	mv	a1,s4
4001281c:	00098613          	mv	a2,s3
40012820:	00040513          	mv	a0,s0
40012824:	5d0160ef          	jal	ra,40028df4 <z_impl_k_sem_take>

		ret = k_sem_take(&context->recv_data_wait, timeout);

		k_mutex_lock(&context->lock, K_FOREVER);
40012828:	fff00593          	li	a1,-1
4001282c:	fff00613          	li	a2,-1
40012830:	00090513          	mv	a0,s2
40012834:	b69fe0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>
		}
	}
#endif /* CONFIG_NET_CONTEXT_SYNC_RECV */

unlock:
	k_mutex_unlock(&context->lock);
40012838:	00090513          	mv	a0,s2
4001283c:	b65fe0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>

	return ret;
}
40012840:	06c12083          	lw	ra,108(sp)
40012844:	06812403          	lw	s0,104(sp)
40012848:	06012903          	lw	s2,96(sp)
4001284c:	05c12983          	lw	s3,92(sp)
40012850:	05812a03          	lw	s4,88(sp)
40012854:	05412a83          	lw	s5,84(sp)
40012858:	05012b03          	lw	s6,80(sp)
4001285c:	04c12b83          	lw	s7,76(sp)
40012860:	00048513          	mv	a0,s1
40012864:	06412483          	lw	s1,100(sp)
40012868:	07010113          	addi	sp,sp,112
4001286c:	00008067          	ret
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40012870:	00100793          	li	a5,1
40012874:	04f49263          	bne	s1,a5,400128b8 <net_context_recv+0x21c>
		if (net_sin_ptr(&context->local)->sin_addr) {
40012878:	02442683          	lw	a3,36(s0)
4001287c:	02068a63          	beqz	a3,400128b0 <net_context_recv+0x214>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
40012880:	0016c783          	lbu	a5,1(a3)
40012884:	0006c703          	lbu	a4,0(a3)
40012888:	00879793          	slli	a5,a5,0x8
4001288c:	00e7e7b3          	or	a5,a5,a4
40012890:	0026c703          	lbu	a4,2(a3)
40012894:	01071713          	slli	a4,a4,0x10
40012898:	00f76733          	or	a4,a4,a5
4001289c:	0036c783          	lbu	a5,3(a3)
			laddr = &local_addr;
400128a0:	02810693          	addi	a3,sp,40
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
400128a4:	01879793          	slli	a5,a5,0x18
400128a8:	00e7e7b3          	or	a5,a5,a4
400128ac:	02f12623          	sw	a5,44(sp)
		lport = net_sin((struct sockaddr *)&context->local)->sin_port;
400128b0:	02245803          	lhu	a6,34(s0)
400128b4:	eddff06f          	j	40012790 <net_context_recv+0xf4>
	uint16_t lport = 0U;
400128b8:	00000813          	li	a6,0
	struct sockaddr *laddr = NULL;
400128bc:	00000693          	li	a3,0
400128c0:	ed1ff06f          	j	40012790 <net_context_recv+0xf4>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
400128c4:	00600713          	li	a4,6
			ret = -EPROTOTYPE;
400128c8:	f9500493          	li	s1,-107
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
400128cc:	f6e796e3          	bne	a5,a4,40012838 <net_context_recv+0x19c>
		ret = net_tcp_recv(context, cb, user_data);
400128d0:	000a8613          	mv	a2,s5
400128d4:	000b0593          	mv	a1,s6
400128d8:	00040513          	mv	a0,s0
400128dc:	5e4090ef          	jal	ra,4001bec0 <net_tcp_recv>
400128e0:	f15ff06f          	j	400127f4 <net_context_recv+0x158>

400128e4 <net_context_update_recv_wnd>:

int net_context_update_recv_wnd(struct net_context *context,
				int32_t delta)
{
400128e4:	ff010113          	addi	sp,sp,-16
400128e8:	01212023          	sw	s2,0(sp)
	if (IS_ENABLED(CONFIG_NET_OFFLOAD) &&
		net_if_is_ip_offloaded(net_context_get_iface(context))) {
		return 0;
	}

	k_mutex_lock(&context->lock, K_FOREVER);
400128ec:	00c50913          	addi	s2,a0,12
{
400128f0:	00812423          	sw	s0,8(sp)
400128f4:	00912223          	sw	s1,4(sp)
400128f8:	00050413          	mv	s0,a0
400128fc:	00058493          	mv	s1,a1
	k_mutex_lock(&context->lock, K_FOREVER);
40012900:	fff00613          	li	a2,-1
40012904:	00090513          	mv	a0,s2
40012908:	fff00593          	li	a1,-1
{
4001290c:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&context->lock, K_FOREVER);
40012910:	a8dfe0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>

	ret = net_tcp_update_recv_wnd(context, delta);
40012914:	00048593          	mv	a1,s1
40012918:	00040513          	mv	a0,s0
4001291c:	40c0a0ef          	jal	ra,4001cd28 <net_tcp_update_recv_wnd>
40012920:	00050413          	mv	s0,a0

	k_mutex_unlock(&context->lock);
40012924:	00090513          	mv	a0,s2
40012928:	a79fe0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>

	return ret;
}
4001292c:	00c12083          	lw	ra,12(sp)
40012930:	00040513          	mv	a0,s0
40012934:	00812403          	lw	s0,8(sp)
40012938:	00412483          	lw	s1,4(sp)
4001293c:	00012903          	lw	s2,0(sp)
40012940:	01010113          	addi	sp,sp,16
40012944:	00008067          	ret

40012948 <net_context_foreach>:

	return ret;
}

void net_context_foreach(net_context_cb_t cb, void *user_data)
{
40012948:	fe010113          	addi	sp,sp,-32
4001294c:	01212823          	sw	s2,16(sp)
40012950:	01312623          	sw	s3,12(sp)
40012954:	00112e23          	sw	ra,28(sp)
40012958:	00812c23          	sw	s0,24(sp)
4001295c:	00912a23          	sw	s1,20(sp)
40012960:	01412423          	sw	s4,8(sp)
40012964:	01512223          	sw	s5,4(sp)
40012968:	00050913          	mv	s2,a0
4001296c:	00058993          	mv	s3,a1
40012970:	40032a37          	lui	s4,0x40032
40012974:	40032437          	lui	s0,0x40032
40012978:	fff00593          	li	a1,-1
4001297c:	fff00613          	li	a2,-1
40012980:	ecca0513          	addi	a0,s4,-308 # 40031ecc <contexts_lock>
40012984:	ee440413          	addi	s0,s0,-284 # 40031ee4 <contexts>
40012988:	46c160ef          	jal	ra,40028df4 <z_impl_k_sem_take>
	int i;

	k_sem_take(&contexts_lock, K_FOREVER);

	for (i = 0; i < NET_MAX_CONTEXT; i++) {
4001298c:	4b040a93          	addi	s5,s0,1200
	return context->flags & NET_CONTEXT_IN_USE;
40012990:	07445783          	lhu	a5,116(s0)
		if (!net_context_is_used(&contexts[i])) {
40012994:	0017f793          	andi	a5,a5,1
40012998:	02078663          	beqz	a5,400129c4 <net_context_foreach+0x7c>
			continue;
		}

		k_mutex_lock(&contexts[i].lock, K_FOREVER);
4001299c:	00c40493          	addi	s1,s0,12
400129a0:	fff00593          	li	a1,-1
400129a4:	fff00613          	li	a2,-1
400129a8:	00048513          	mv	a0,s1
400129ac:	9f1fe0ef          	jal	ra,4001139c <k_mutex_lock.constprop.0.isra.0>

		cb(&contexts[i], user_data);
400129b0:	00040513          	mv	a0,s0
400129b4:	00098593          	mv	a1,s3
400129b8:	000900e7          	jalr	s2

		k_mutex_unlock(&contexts[i].lock);
400129bc:	00048513          	mv	a0,s1
400129c0:	9e1fe0ef          	jal	ra,400113a0 <k_mutex_unlock.isra.0>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
400129c4:	07840413          	addi	s0,s0,120
400129c8:	fd5414e3          	bne	s0,s5,40012990 <net_context_foreach+0x48>
	}

	k_sem_give(&contexts_lock);
}
400129cc:	01812403          	lw	s0,24(sp)
400129d0:	01c12083          	lw	ra,28(sp)
400129d4:	01412483          	lw	s1,20(sp)
400129d8:	01012903          	lw	s2,16(sp)
400129dc:	00c12983          	lw	s3,12(sp)
400129e0:	00412a83          	lw	s5,4(sp)
	z_impl_k_sem_give(sem);
400129e4:	ecca0513          	addi	a0,s4,-308
400129e8:	00812a03          	lw	s4,8(sp)
400129ec:	02010113          	addi	sp,sp,32
400129f0:	3941606f          	j	40028d84 <z_impl_k_sem_give>

400129f4 <net_context_init>:
	return z_impl_k_sem_init(sem, initial_count, limit);
400129f4:	40032537          	lui	a0,0x40032
400129f8:	fff00613          	li	a2,-1
400129fc:	00100593          	li	a1,1
40012a00:	ecc50513          	addi	a0,a0,-308 # 40031ecc <contexts_lock>
40012a04:	3481606f          	j	40028d4c <z_impl_k_sem_init>

40012a08 <pkt_cursor_jump>:
		pkt->cursor.pos = NULL;
	}
}

static void pkt_cursor_jump(struct net_pkt *pkt, bool write)
{
40012a08:	ff010113          	addi	sp,sp,-16
40012a0c:	00812423          	sw	s0,8(sp)
40012a10:	00912223          	sw	s1,4(sp)
40012a14:	00112623          	sw	ra,12(sp)
	struct net_pkt_cursor *cursor = &pkt->cursor;

	cursor->buf = cursor->buf->frags;
40012a18:	00c52783          	lw	a5,12(a0)
{
40012a1c:	00050413          	mv	s0,a0
40012a20:	00058493          	mv	s1,a1
	while (cursor->buf) {
		const size_t len =
			write ? net_buf_max_len(cursor->buf) : cursor->buf->len;

		if (!len) {
			cursor->buf = cursor->buf->frags;
40012a24:	0047a503          	lw	a0,4(a5)
	cursor->buf = cursor->buf->frags;
40012a28:	00a42623          	sw	a0,12(s0)
	while (cursor->buf) {
40012a2c:	00050c63          	beqz	a0,40012a44 <pkt_cursor_jump+0x3c>
			write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
40012a30:	02048a63          	beqz	s1,40012a64 <pkt_cursor_jump+0x5c>
	return net_buf_simple_max_len(&buf->b);
40012a34:	00c50513          	addi	a0,a0,12
40012a38:	960f70ef          	jal	ra,40009b98 <net_buf_simple_max_len>
			cursor->buf = cursor->buf->frags;
40012a3c:	00c42783          	lw	a5,12(s0)
		if (!len) {
40012a40:	fe0502e3          	beqz	a0,40012a24 <pkt_cursor_jump+0x1c>
		} else {
			break;
		}
	}

	if (cursor->buf) {
40012a44:	00c42783          	lw	a5,12(s0)
40012a48:	02079263          	bnez	a5,40012a6c <pkt_cursor_jump+0x64>
40012a4c:	00f42823          	sw	a5,16(s0)
		cursor->pos = cursor->buf->data;
	} else {
		cursor->pos = NULL;
	}
}
40012a50:	00c12083          	lw	ra,12(sp)
40012a54:	00812403          	lw	s0,8(sp)
40012a58:	00412483          	lw	s1,4(sp)
40012a5c:	01010113          	addi	sp,sp,16
40012a60:	00008067          	ret
			write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
40012a64:	01055503          	lhu	a0,16(a0)
40012a68:	fd5ff06f          	j	40012a3c <pkt_cursor_jump+0x34>
		cursor->pos = cursor->buf->data;
40012a6c:	00c7a783          	lw	a5,12(a5)
40012a70:	fddff06f          	j	40012a4c <pkt_cursor_jump+0x44>

40012a74 <pkt_cursor_advance>:

static void pkt_cursor_advance(struct net_pkt *pkt, bool write)
{
40012a74:	fe010113          	addi	sp,sp,-32
40012a78:	00812c23          	sw	s0,24(sp)
40012a7c:	00112e23          	sw	ra,28(sp)
40012a80:	00050413          	mv	s0,a0
	struct net_pkt_cursor *cursor = &pkt->cursor;
	size_t len;

	if (!cursor->buf) {
40012a84:	00c52503          	lw	a0,12(a0)
40012a88:	04050463          	beqz	a0,40012ad0 <pkt_cursor_advance+0x5c>
		return;
	}

	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
40012a8c:	02058e63          	beqz	a1,40012ac8 <pkt_cursor_advance+0x54>
40012a90:	00c50513          	addi	a0,a0,12
40012a94:	00b12623          	sw	a1,12(sp)
40012a98:	900f70ef          	jal	ra,40009b98 <net_buf_simple_max_len>
40012a9c:	00c12583          	lw	a1,12(sp)
	if ((cursor->pos - cursor->buf->data) == len) {
40012aa0:	00c42703          	lw	a4,12(s0)
40012aa4:	01042783          	lw	a5,16(s0)
40012aa8:	00c72703          	lw	a4,12(a4)
40012aac:	40e787b3          	sub	a5,a5,a4
40012ab0:	02a79063          	bne	a5,a0,40012ad0 <pkt_cursor_advance+0x5c>
		pkt_cursor_jump(pkt, write);
40012ab4:	00040513          	mv	a0,s0
	}
}
40012ab8:	01812403          	lw	s0,24(sp)
40012abc:	01c12083          	lw	ra,28(sp)
40012ac0:	02010113          	addi	sp,sp,32
		pkt_cursor_jump(pkt, write);
40012ac4:	f45ff06f          	j	40012a08 <pkt_cursor_jump>
	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
40012ac8:	01055503          	lhu	a0,16(a0)
40012acc:	fd5ff06f          	j	40012aa0 <pkt_cursor_advance+0x2c>
}
40012ad0:	01c12083          	lw	ra,28(sp)
40012ad4:	01812403          	lw	s0,24(sp)
40012ad8:	02010113          	addi	sp,sp,32
40012adc:	00008067          	ret

40012ae0 <pkt_cursor_update>:

static void pkt_cursor_update(struct net_pkt *pkt,
			      size_t length, bool write)
{
40012ae0:	fe010113          	addi	sp,sp,-32
40012ae4:	00812c23          	sw	s0,24(sp)
40012ae8:	01312623          	sw	s3,12(sp)
40012aec:	00112e23          	sw	ra,28(sp)
40012af0:	00912a23          	sw	s1,20(sp)
40012af4:	01212823          	sw	s2,16(sp)
40012af8:	00050413          	mv	s0,a0
	return pkt->overwrite;
40012afc:	03744783          	lbu	a5,55(s0)

	if (net_pkt_is_being_overwritten(pkt)) {
		write = false;
	}

	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
40012b00:	00c52503          	lw	a0,12(a0)
{
40012b04:	00058993          	mv	s3,a1
	if (net_pkt_is_being_overwritten(pkt)) {
40012b08:	0017f793          	andi	a5,a5,1
40012b0c:	06079063          	bnez	a5,40012b6c <pkt_cursor_update+0x8c>
40012b10:	00060913          	mv	s2,a2
	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
40012b14:	04060c63          	beqz	a2,40012b6c <pkt_cursor_update+0x8c>
40012b18:	00c50513          	addi	a0,a0,12
40012b1c:	87cf70ef          	jal	ra,40009b98 <net_buf_simple_max_len>
40012b20:	00050493          	mv	s1,a0
	if (length + (cursor->pos - cursor->buf->data) == len &&
40012b24:	00c42503          	lw	a0,12(s0)
40012b28:	01042783          	lw	a5,16(s0)
40012b2c:	00c52703          	lw	a4,12(a0)
40012b30:	40e787b3          	sub	a5,a5,a4
40012b34:	013787b3          	add	a5,a5,s3
40012b38:	04979663          	bne	a5,s1,40012b84 <pkt_cursor_update+0xa4>
40012b3c:	03744783          	lbu	a5,55(s0)
40012b40:	0017f793          	andi	a5,a5,1
40012b44:	02079a63          	bnez	a5,40012b78 <pkt_cursor_update+0x98>
	    !(net_pkt_is_being_overwritten(pkt) &&
	      len < net_buf_max_len(cursor->buf))) {
		pkt_cursor_jump(pkt, write);
40012b48:	00040513          	mv	a0,s0
	} else {
		cursor->pos += length;
	}
}
40012b4c:	01812403          	lw	s0,24(sp)
40012b50:	01c12083          	lw	ra,28(sp)
40012b54:	01412483          	lw	s1,20(sp)
40012b58:	00c12983          	lw	s3,12(sp)
		pkt_cursor_jump(pkt, write);
40012b5c:	00090593          	mv	a1,s2
}
40012b60:	01012903          	lw	s2,16(sp)
40012b64:	02010113          	addi	sp,sp,32
		pkt_cursor_jump(pkt, write);
40012b68:	ea1ff06f          	j	40012a08 <pkt_cursor_jump>
	len = write ? net_buf_max_len(cursor->buf) : cursor->buf->len;
40012b6c:	01055483          	lhu	s1,16(a0)
40012b70:	00000913          	li	s2,0
40012b74:	fb1ff06f          	j	40012b24 <pkt_cursor_update+0x44>
40012b78:	00c50513          	addi	a0,a0,12
40012b7c:	81cf70ef          	jal	ra,40009b98 <net_buf_simple_max_len>
	    !(net_pkt_is_being_overwritten(pkt) &&
40012b80:	fca4f4e3          	bgeu	s1,a0,40012b48 <pkt_cursor_update+0x68>
		cursor->pos += length;
40012b84:	01042783          	lw	a5,16(s0)
40012b88:	013787b3          	add	a5,a5,s3
40012b8c:	00f42823          	sw	a5,16(s0)
}
40012b90:	01c12083          	lw	ra,28(sp)
40012b94:	01812403          	lw	s0,24(sp)
40012b98:	01412483          	lw	s1,20(sp)
40012b9c:	01012903          	lw	s2,16(sp)
40012ba0:	00c12983          	lw	s3,12(sp)
40012ba4:	02010113          	addi	sp,sp,32
40012ba8:	00008067          	ret

40012bac <pkt_estimate_headers_length.part.0>:
static size_t pkt_estimate_headers_length(struct net_pkt *pkt,
40012bac:	00050793          	mv	a5,a0
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40012bb0:	00200713          	li	a4,2
		hdr_len += NET_IPV6H_LEN;
40012bb4:	02800513          	li	a0,40
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40012bb8:	00e78a63          	beq	a5,a4,40012bcc <pkt_estimate_headers_length.part.0+0x20>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40012bbc:	00100713          	li	a4,1
		hdr_len += NET_IPV4H_LEN;
40012bc0:	01400513          	li	a0,20
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40012bc4:	00e78463          	beq	a5,a4,40012bcc <pkt_estimate_headers_length.part.0+0x20>
	size_t hdr_len = 0;
40012bc8:	00000513          	li	a0,0
	if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
40012bcc:	00600793          	li	a5,6
40012bd0:	00f59663          	bne	a1,a5,40012bdc <pkt_estimate_headers_length.part.0+0x30>
		hdr_len += NET_TCPH_LEN + NET_TCP_MAX_OPT_SIZE;
40012bd4:	01c50513          	addi	a0,a0,28
40012bd8:	00008067          	ret
	} else if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
40012bdc:	01100793          	li	a5,17
40012be0:	00f59663          	bne	a1,a5,40012bec <pkt_estimate_headers_length.part.0+0x40>
		hdr_len += NET_UDPH_LEN;
40012be4:	00850513          	addi	a0,a0,8
40012be8:	00008067          	ret
	} else if (proto == IPPROTO_ICMP || proto == IPPROTO_ICMPV6) {
40012bec:	00100793          	li	a5,1
40012bf0:	00f58663          	beq	a1,a5,40012bfc <pkt_estimate_headers_length.part.0+0x50>
40012bf4:	03a00793          	li	a5,58
40012bf8:	00f59463          	bne	a1,a5,40012c00 <pkt_estimate_headers_length.part.0+0x54>
		hdr_len += NET_ICMPH_LEN;
40012bfc:	00450513          	addi	a0,a0,4
}
40012c00:	00008067          	ret

40012c04 <net_pkt_get_len.isra.0>:
static inline size_t net_pkt_get_len(struct net_pkt *pkt)
40012c04:	00050793          	mv	a5,a0
	size_t bytes = 0;
40012c08:	00000513          	li	a0,0
	while (buf) {
40012c0c:	00079463          	bnez	a5,40012c14 <net_pkt_get_len.isra.0+0x10>
}
40012c10:	00008067          	ret
		bytes += buf->len;
40012c14:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
40012c18:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
40012c1c:	00e50533          	add	a0,a0,a4
		buf = buf->frags;
40012c20:	fedff06f          	j	40012c0c <net_pkt_get_len.isra.0+0x8>

40012c24 <net_pkt_cursor_operate>:

/* Internal function that does all operation (skip/read/write/memset) */
static int net_pkt_cursor_operate(struct net_pkt *pkt,
				  void *data, size_t length,
				  bool copy, bool write)
{
40012c24:	fe010113          	addi	sp,sp,-32
40012c28:	00912a23          	sw	s1,20(sp)
40012c2c:	01212823          	sw	s2,16(sp)
40012c30:	01312623          	sw	s3,12(sp)
40012c34:	01412423          	sw	s4,8(sp)
40012c38:	01512223          	sw	s5,4(sp)
40012c3c:	00112e23          	sw	ra,28(sp)
40012c40:	00812c23          	sw	s0,24(sp)
40012c44:	00050493          	mv	s1,a0
40012c48:	00058913          	mv	s2,a1
40012c4c:	00060993          	mv	s3,a2
40012c50:	00068a93          	mv	s5,a3
40012c54:	00070a13          	mv	s4,a4
	/* We use such variable to avoid lengthy lines */
	struct net_pkt_cursor *c_op = &pkt->cursor;

	while (c_op->buf && length) {
40012c58:	00c4a783          	lw	a5,12(s1)
40012c5c:	16078463          	beqz	a5,40012dc4 <net_pkt_cursor_operate+0x1a0>
40012c60:	02099663          	bnez	s3,40012c8c <net_pkt_cursor_operate+0x68>
	if (length) {
		NET_DBG("Still some length to go %zu", length);
		return -ENOBUFS;
	}

	return 0;
40012c64:	00000513          	li	a0,0
}
40012c68:	01c12083          	lw	ra,28(sp)
40012c6c:	01812403          	lw	s0,24(sp)
40012c70:	01412483          	lw	s1,20(sp)
40012c74:	01012903          	lw	s2,16(sp)
40012c78:	00c12983          	lw	s3,12(sp)
40012c7c:	00812a03          	lw	s4,8(sp)
40012c80:	00412a83          	lw	s5,4(sp)
40012c84:	02010113          	addi	sp,sp,32
40012c88:	00008067          	ret
	return pkt->overwrite;
40012c8c:	0374c783          	lbu	a5,55(s1)
		pkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?
40012c90:	00000593          	li	a1,0
40012c94:	0017f793          	andi	a5,a5,1
40012c98:	00079463          	bnez	a5,40012ca0 <net_pkt_cursor_operate+0x7c>
40012c9c:	000a0593          	mv	a1,s4
40012ca0:	00048513          	mv	a0,s1
40012ca4:	dd1ff0ef          	jal	ra,40012a74 <pkt_cursor_advance>
		if (c_op->buf == NULL) {
40012ca8:	00c4a783          	lw	a5,12(s1)
40012cac:	12078063          	beqz	a5,40012dcc <net_pkt_cursor_operate+0x1a8>
		if (write && !net_pkt_is_being_overwritten(pkt)) {
40012cb0:	040a0a63          	beqz	s4,40012d04 <net_pkt_cursor_operate+0xe0>
40012cb4:	0374c703          	lbu	a4,55(s1)
40012cb8:	00177713          	andi	a4,a4,1
40012cbc:	04071463          	bnez	a4,40012d04 <net_pkt_cursor_operate+0xe0>
	return net_buf_simple_max_len(&buf->b);
40012cc0:	00c78513          	addi	a0,a5,12
40012cc4:	ed5f60ef          	jal	ra,40009b98 <net_buf_simple_max_len>
				(c_op->pos - c_op->buf->data);
40012cc8:	00c4a783          	lw	a5,12(s1)
40012ccc:	0104a703          	lw	a4,16(s1)
40012cd0:	00c7a783          	lw	a5,12(a5)
40012cd4:	40f707b3          	sub	a5,a4,a5
			d_len = net_buf_max_len(c_op->buf) -
40012cd8:	40f50433          	sub	s0,a0,a5
		if (!d_len) {
40012cdc:	0ef50863          	beq	a0,a5,40012dcc <net_pkt_cursor_operate+0x1a8>
		if (length < d_len) {
40012ce0:	0089f463          	bgeu	s3,s0,40012ce8 <net_pkt_cursor_operate+0xc4>
40012ce4:	00098413          	mv	s0,s3
		if (copy) {
40012ce8:	0a0a9663          	bnez	s5,40012d94 <net_pkt_cursor_operate+0x170>
		} else if (data) {
40012cec:	06090a63          	beqz	s2,40012d60 <net_pkt_cursor_operate+0x13c>
			memset(c_op->pos, *(int *)data, len);
40012cf0:	00092583          	lw	a1,0(s2)
40012cf4:	0104a503          	lw	a0,16(s1)
40012cf8:	00040613          	mv	a2,s0
40012cfc:	b74f60ef          	jal	ra,40009070 <memset>
		if (write && !net_pkt_is_being_overwritten(pkt)) {
40012d00:	0a80006f          	j	40012da8 <net_pkt_cursor_operate+0x184>
			d_len = c_op->buf->len - (c_op->pos - c_op->buf->data);
40012d04:	0107d703          	lhu	a4,16(a5)
40012d08:	0104a503          	lw	a0,16(s1)
40012d0c:	00c7a783          	lw	a5,12(a5)
40012d10:	40f507b3          	sub	a5,a0,a5
40012d14:	40f70433          	sub	s0,a4,a5
		if (!d_len) {
40012d18:	0af70a63          	beq	a4,a5,40012dcc <net_pkt_cursor_operate+0x1a8>
		if (length < d_len) {
40012d1c:	0089f463          	bgeu	s3,s0,40012d24 <net_pkt_cursor_operate+0x100>
40012d20:	00098413          	mv	s0,s3
		if (copy) {
40012d24:	080a8063          	beqz	s5,40012da4 <net_pkt_cursor_operate+0x180>
			memcpy(write ? c_op->pos : data,
40012d28:	00040613          	mv	a2,s0
40012d2c:	020a1663          	bnez	s4,40012d58 <net_pkt_cursor_operate+0x134>
40012d30:	00050593          	mv	a1,a0
40012d34:	00090513          	mv	a0,s2
40012d38:	b14f60ef          	jal	ra,4000904c <memcpy>
		pkt_cursor_update(pkt, len, write);
40012d3c:	00000613          	li	a2,0
40012d40:	00040593          	mv	a1,s0
40012d44:	00048513          	mv	a0,s1
40012d48:	d99ff0ef          	jal	ra,40012ae0 <pkt_cursor_update>
		if (copy && data) {
40012d4c:	06090863          	beqz	s2,40012dbc <net_pkt_cursor_operate+0x198>
			data = (uint8_t *) data + len;
40012d50:	00890933          	add	s2,s2,s0
40012d54:	0680006f          	j	40012dbc <net_pkt_cursor_operate+0x198>
			memcpy(write ? c_op->pos : data,
40012d58:	00090593          	mv	a1,s2
40012d5c:	af0f60ef          	jal	ra,4000904c <memcpy>
40012d60:	0374c783          	lbu	a5,55(s1)
		if (write && !net_pkt_is_being_overwritten(pkt)) {
40012d64:	0017f793          	andi	a5,a5,1
40012d68:	00079a63          	bnez	a5,40012d7c <net_pkt_cursor_operate+0x158>
	return net_buf_simple_add(&buf->b, len);
40012d6c:	00c4a503          	lw	a0,12(s1)
40012d70:	00040593          	mv	a1,s0
40012d74:	00c50513          	addi	a0,a0,12
40012d78:	da5f60ef          	jal	ra,40009b1c <net_buf_simple_add>
		pkt_cursor_update(pkt, len, write);
40012d7c:	00100613          	li	a2,1
40012d80:	00040593          	mv	a1,s0
40012d84:	00048513          	mv	a0,s1
40012d88:	d59ff0ef          	jal	ra,40012ae0 <pkt_cursor_update>
		if (copy && data) {
40012d8c:	020a8863          	beqz	s5,40012dbc <net_pkt_cursor_operate+0x198>
40012d90:	fbdff06f          	j	40012d4c <net_pkt_cursor_operate+0x128>
			memcpy(write ? c_op->pos : data,
40012d94:	00040613          	mv	a2,s0
40012d98:	00090593          	mv	a1,s2
40012d9c:	00070513          	mv	a0,a4
40012da0:	fbdff06f          	j	40012d5c <net_pkt_cursor_operate+0x138>
		} else if (data) {
40012da4:	f40916e3          	bnez	s2,40012cf0 <net_pkt_cursor_operate+0xcc>
		if (write && !net_pkt_is_being_overwritten(pkt)) {
40012da8:	fa0a1ce3          	bnez	s4,40012d60 <net_pkt_cursor_operate+0x13c>
		pkt_cursor_update(pkt, len, write);
40012dac:	00000613          	li	a2,0
40012db0:	00040593          	mv	a1,s0
40012db4:	00048513          	mv	a0,s1
40012db8:	d29ff0ef          	jal	ra,40012ae0 <pkt_cursor_update>
		length -= len;
40012dbc:	408989b3          	sub	s3,s3,s0
40012dc0:	e99ff06f          	j	40012c58 <net_pkt_cursor_operate+0x34>
	return 0;
40012dc4:	00000513          	li	a0,0
	if (length) {
40012dc8:	ea0980e3          	beqz	s3,40012c68 <net_pkt_cursor_operate+0x44>
		return -ENOBUFS;
40012dcc:	f9700513          	li	a0,-105
40012dd0:	e99ff06f          	j	40012c68 <net_pkt_cursor_operate+0x44>

40012dd4 <net_pkt_get_reserve_data>:
{
40012dd4:	fe010113          	addi	sp,sp,-32
40012dd8:	00812c23          	sw	s0,24(sp)
40012ddc:	00912a23          	sw	s1,20(sp)
40012de0:	01212823          	sw	s2,16(sp)
40012de4:	01312623          	sw	s3,12(sp)
40012de8:	00112e23          	sw	ra,28(sp)
40012dec:	00050913          	mv	s2,a0
40012df0:	00058993          	mv	s3,a1
40012df4:	00060493          	mv	s1,a2
40012df8:	00068413          	mv	s0,a3
	if (k_is_in_isr()) {
40012dfc:	2d4150ef          	jal	ra,400280d0 <k_is_in_isr>
40012e00:	00050663          	beqz	a0,40012e0c <net_pkt_get_reserve_data+0x38>
		timeout = K_NO_WAIT;
40012e04:	00000493          	li	s1,0
40012e08:	00000413          	li	s0,0
	if (min_len > CONFIG_NET_BUF_DATA_SIZE) {
40012e0c:	08000793          	li	a5,128
40012e10:	0337e663          	bltu	a5,s3,40012e3c <net_pkt_get_reserve_data+0x68>
	return net_buf_alloc_fixed(pool, timeout);
40012e14:	00040613          	mv	a2,s0
}
40012e18:	01812403          	lw	s0,24(sp)
40012e1c:	01c12083          	lw	ra,28(sp)
40012e20:	00c12983          	lw	s3,12(sp)
40012e24:	00048593          	mv	a1,s1
40012e28:	00090513          	mv	a0,s2
40012e2c:	01412483          	lw	s1,20(sp)
40012e30:	01012903          	lw	s2,16(sp)
40012e34:	02010113          	addi	sp,sp,32
40012e38:	ac1f606f          	j	400098f8 <net_buf_alloc_fixed>
40012e3c:	01c12083          	lw	ra,28(sp)
40012e40:	01812403          	lw	s0,24(sp)
40012e44:	01412483          	lw	s1,20(sp)
40012e48:	01012903          	lw	s2,16(sp)
40012e4c:	00c12983          	lw	s3,12(sp)
40012e50:	00000513          	li	a0,0
40012e54:	02010113          	addi	sp,sp,32
40012e58:	00008067          	ret

40012e5c <net_pkt_get_reserve_rx_data>:
{
40012e5c:	00060693          	mv	a3,a2
40012e60:	00058613          	mv	a2,a1
	return net_pkt_get_reserve_data(&rx_bufs, min_len, timeout);
40012e64:	00050593          	mv	a1,a0
40012e68:	4003d537          	lui	a0,0x4003d
40012e6c:	be450513          	addi	a0,a0,-1052 # 4003cbe4 <rx_bufs>
40012e70:	f65ff06f          	j	40012dd4 <net_pkt_get_reserve_data>

40012e74 <net_pkt_get_reserve_tx_data>:
{
40012e74:	00060693          	mv	a3,a2
40012e78:	00058613          	mv	a2,a1
	return net_pkt_get_reserve_data(&tx_bufs, min_len, timeout);
40012e7c:	00050593          	mv	a1,a0
40012e80:	4003d537          	lui	a0,0x4003d
40012e84:	c1050513          	addi	a0,a0,-1008 # 4003cc10 <tx_bufs>
40012e88:	f4dff06f          	j	40012dd4 <net_pkt_get_reserve_data>

40012e8c <net_pkt_get_frag>:
{
40012e8c:	00050793          	mv	a5,a0
	if (pkt->slab == &rx_pkts) {
40012e90:	0047a703          	lw	a4,4(a5)
40012e94:	4003d7b7          	lui	a5,0x4003d
40012e98:	a3478793          	addi	a5,a5,-1484 # 4003ca34 <rx_pkts>
{
40012e9c:	00058513          	mv	a0,a1
40012ea0:	00060593          	mv	a1,a2
40012ea4:	00068613          	mv	a2,a3
	if (pkt->slab == &rx_pkts) {
40012ea8:	00f71463          	bne	a4,a5,40012eb0 <net_pkt_get_frag+0x24>
		return net_pkt_get_reserve_rx_data(min_len, timeout);
40012eac:	fb1ff06f          	j	40012e5c <net_pkt_get_reserve_rx_data>
	return net_pkt_get_reserve_tx_data(min_len, timeout);
40012eb0:	fc5ff06f          	j	40012e74 <net_pkt_get_reserve_tx_data>

40012eb4 <net_pkt_ref>:
{
40012eb4:	ff010113          	addi	sp,sp,-16
40012eb8:	00112623          	sw	ra,12(sp)
40012ebc:	00812423          	sw	s0,8(sp)
40012ec0:	00912223          	sw	s1,4(sp)
		ref = pkt ? atomic_get(&pkt->atomic_ref) : 0;
40012ec4:	04050263          	beqz	a0,40012f08 <net_pkt_ref+0x54>
40012ec8:	00050413          	mv	s0,a0
40012ecc:	02050493          	addi	s1,a0,32
40012ed0:	00048513          	mv	a0,s1
40012ed4:	114180ef          	jal	ra,4002afe8 <atomic_get>
40012ed8:	00050593          	mv	a1,a0
		if (!ref) {
40012edc:	02050663          	beqz	a0,40012f08 <net_pkt_ref+0x54>
	return z_impl_atomic_cas(target, old_value, new_value);
40012ee0:	00150613          	addi	a2,a0,1
40012ee4:	00048513          	mv	a0,s1
40012ee8:	098180ef          	jal	ra,4002af80 <z_impl_atomic_cas>
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref + 1));
40012eec:	fe0502e3          	beqz	a0,40012ed0 <net_pkt_ref+0x1c>
}
40012ef0:	00c12083          	lw	ra,12(sp)
40012ef4:	00040513          	mv	a0,s0
40012ef8:	00812403          	lw	s0,8(sp)
40012efc:	00412483          	lw	s1,4(sp)
40012f00:	01010113          	addi	sp,sp,16
40012f04:	00008067          	ret
			return NULL;
40012f08:	00000413          	li	s0,0
40012f0c:	fe5ff06f          	j	40012ef0 <net_pkt_ref+0x3c>

40012f10 <net_pkt_frag_unref>:
	if (!frag) {
40012f10:	00050463          	beqz	a0,40012f18 <net_pkt_frag_unref+0x8>
	net_buf_unref(frag);
40012f14:	9fdf606f          	j	40009910 <net_buf_unref>
}
40012f18:	00008067          	ret

40012f1c <net_pkt_unref>:
{
40012f1c:	fe010113          	addi	sp,sp,-32
40012f20:	00112e23          	sw	ra,28(sp)
40012f24:	00812c23          	sw	s0,24(sp)
40012f28:	00a12623          	sw	a0,12(sp)
	if (!pkt) {
40012f2c:	04050c63          	beqz	a0,40012f84 <net_pkt_unref+0x68>
		ref = atomic_get(&pkt->atomic_ref);
40012f30:	00c12503          	lw	a0,12(sp)
40012f34:	02050513          	addi	a0,a0,32
40012f38:	0b0180ef          	jal	ra,4002afe8 <atomic_get>
40012f3c:	00050413          	mv	s0,a0
		if (!ref) {
40012f40:	04050263          	beqz	a0,40012f84 <net_pkt_unref+0x68>
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref - 1));
40012f44:	00c12503          	lw	a0,12(sp)
40012f48:	02050513          	addi	a0,a0,32
40012f4c:	fff40613          	addi	a2,s0,-1
40012f50:	00040593          	mv	a1,s0
40012f54:	02c180ef          	jal	ra,4002af80 <z_impl_atomic_cas>
40012f58:	fc050ce3          	beqz	a0,40012f30 <net_pkt_unref+0x14>
	if (ref > 1) {
40012f5c:	00100793          	li	a5,1
40012f60:	0287c263          	blt	a5,s0,40012f84 <net_pkt_unref+0x68>
	if (pkt->frags) {
40012f64:	00c12783          	lw	a5,12(sp)
40012f68:	0087a503          	lw	a0,8(a5)
40012f6c:	00050463          	beqz	a0,40012f74 <net_pkt_unref+0x58>
		net_pkt_frag_unref(pkt->frags);
40012f70:	fa1ff0ef          	jal	ra,40012f10 <net_pkt_frag_unref>
	k_mem_slab_free(pkt->slab, (void **)&pkt);
40012f74:	00c12783          	lw	a5,12(sp)
40012f78:	00c10593          	addi	a1,sp,12
40012f7c:	0047a503          	lw	a0,4(a5)
40012f80:	048150ef          	jal	ra,40027fc8 <k_mem_slab_free>
}
40012f84:	01c12083          	lw	ra,28(sp)
40012f88:	01812403          	lw	s0,24(sp)
40012f8c:	02010113          	addi	sp,sp,32
40012f90:	00008067          	ret

40012f94 <net_pkt_frag_insert>:
{
40012f94:	ff010113          	addi	sp,sp,-16
40012f98:	00812423          	sw	s0,8(sp)
40012f9c:	00050413          	mv	s0,a0
	net_buf_frag_last(frag)->frags = pkt->frags;
40012fa0:	00058513          	mv	a0,a1
{
40012fa4:	00912223          	sw	s1,4(sp)
40012fa8:	00112623          	sw	ra,12(sp)
40012fac:	00058493          	mv	s1,a1
	net_buf_frag_last(frag)->frags = pkt->frags;
40012fb0:	a31f60ef          	jal	ra,400099e0 <net_buf_frag_last>
40012fb4:	00842783          	lw	a5,8(s0)
40012fb8:	00f52223          	sw	a5,4(a0)
	pkt->frags = frag;
40012fbc:	00942423          	sw	s1,8(s0)
}
40012fc0:	00c12083          	lw	ra,12(sp)
40012fc4:	00812403          	lw	s0,8(sp)
40012fc8:	00412483          	lw	s1,4(sp)
40012fcc:	01010113          	addi	sp,sp,16
40012fd0:	00008067          	ret

40012fd4 <net_pkt_get_info>:
	if (rx) {
40012fd4:	00050863          	beqz	a0,40012fe4 <net_pkt_get_info+0x10>
		*rx = &rx_pkts;
40012fd8:	4003d7b7          	lui	a5,0x4003d
40012fdc:	a3478793          	addi	a5,a5,-1484 # 4003ca34 <rx_pkts>
40012fe0:	00f52023          	sw	a5,0(a0)
	if (tx) {
40012fe4:	00058863          	beqz	a1,40012ff4 <net_pkt_get_info+0x20>
		*tx = &tx_pkts;
40012fe8:	4003d7b7          	lui	a5,0x4003d
40012fec:	a6c78793          	addi	a5,a5,-1428 # 4003ca6c <tx_pkts>
40012ff0:	00f5a023          	sw	a5,0(a1)
	if (rx_data) {
40012ff4:	00060863          	beqz	a2,40013004 <net_pkt_get_info+0x30>
		*rx_data = &rx_bufs;
40012ff8:	4003d7b7          	lui	a5,0x4003d
40012ffc:	be478793          	addi	a5,a5,-1052 # 4003cbe4 <rx_bufs>
40013000:	00f62023          	sw	a5,0(a2)
	if (tx_data) {
40013004:	00068863          	beqz	a3,40013014 <net_pkt_get_info+0x40>
		*tx_data = &tx_bufs;
40013008:	4003d7b7          	lui	a5,0x4003d
4001300c:	c1078793          	addi	a5,a5,-1008 # 4003cc10 <tx_bufs>
40013010:	00f6a023          	sw	a5,0(a3)
}
40013014:	00008067          	ret

40013018 <net_pkt_available_buffer>:
	if (!pkt) {
40013018:	06050063          	beqz	a0,40013078 <net_pkt_available_buffer+0x60>
{
4001301c:	ff010113          	addi	sp,sp,-16
40013020:	00812423          	sw	s0,8(sp)
40013024:	00912223          	sw	s1,4(sp)
40013028:	00112623          	sw	ra,12(sp)
4001302c:	01212023          	sw	s2,0(sp)
40013030:	00852903          	lw	s2,8(a0)
40013034:	00050493          	mv	s1,a0
	size_t size = 0;
40013038:	00000413          	li	s0,0
	while (buf) {
4001303c:	02091463          	bnez	s2,40013064 <net_pkt_available_buffer+0x4c>
	return pkt_get_max_len(pkt) - net_pkt_get_len(pkt);
40013040:	0084a503          	lw	a0,8(s1)
40013044:	bc1ff0ef          	jal	ra,40012c04 <net_pkt_get_len.isra.0>
}
40013048:	00c12083          	lw	ra,12(sp)
	return pkt_get_max_len(pkt) - net_pkt_get_len(pkt);
4001304c:	40a40533          	sub	a0,s0,a0
}
40013050:	00812403          	lw	s0,8(sp)
40013054:	00412483          	lw	s1,4(sp)
40013058:	00012903          	lw	s2,0(sp)
4001305c:	01010113          	addi	sp,sp,16
40013060:	00008067          	ret
	return net_buf_simple_max_len(&buf->b);
40013064:	00c90513          	addi	a0,s2,12
40013068:	b31f60ef          	jal	ra,40009b98 <net_buf_simple_max_len>
		size += net_buf_max_len(buf);
4001306c:	00a40433          	add	s0,s0,a0
		buf = buf->frags;
40013070:	00492903          	lw	s2,4(s2)
40013074:	fc9ff06f          	j	4001303c <net_pkt_available_buffer+0x24>
		return 0;
40013078:	00000513          	li	a0,0
}
4001307c:	00008067          	ret

40013080 <net_pkt_available_payload_buffer>:
	if (!pkt) {
40013080:	06050e63          	beqz	a0,400130fc <net_pkt_available_payload_buffer+0x7c>
{
40013084:	ff010113          	addi	sp,sp,-16
40013088:	00812423          	sw	s0,8(sp)
4001308c:	00112623          	sw	ra,12(sp)
40013090:	00912223          	sw	s1,4(sp)
40013094:	01212023          	sw	s2,0(sp)
40013098:	00050413          	mv	s0,a0
	return pkt->family;
4001309c:	03452503          	lw	a0,52(a0)
400130a0:	00842903          	lw	s2,8(s0)
	hdr_len = pkt_estimate_headers_length(pkt, net_pkt_family(pkt), proto);
400130a4:	01d55513          	srli	a0,a0,0x1d
	if (family == AF_UNSPEC) {
400130a8:	02051a63          	bnez	a0,400130dc <net_pkt_available_payload_buffer+0x5c>
	len = net_pkt_get_len(pkt);
400130ac:	00090513          	mv	a0,s2
400130b0:	b55ff0ef          	jal	ra,40012c04 <net_pkt_get_len.isra.0>
	hdr_len = hdr_len <= len ? 0 : hdr_len - len;
400130b4:	00000913          	li	s2,0
	len = net_pkt_available_buffer(pkt) - hdr_len;
400130b8:	00040513          	mv	a0,s0
400130bc:	f5dff0ef          	jal	ra,40013018 <net_pkt_available_buffer>
}
400130c0:	00c12083          	lw	ra,12(sp)
400130c4:	00812403          	lw	s0,8(sp)
400130c8:	00412483          	lw	s1,4(sp)
	len = net_pkt_available_buffer(pkt) - hdr_len;
400130cc:	41250533          	sub	a0,a0,s2
}
400130d0:	00012903          	lw	s2,0(sp)
400130d4:	01010113          	addi	sp,sp,16
400130d8:	00008067          	ret
400130dc:	ad1ff0ef          	jal	ra,40012bac <pkt_estimate_headers_length.part.0>
400130e0:	00050493          	mv	s1,a0
	len = net_pkt_get_len(pkt);
400130e4:	00090513          	mv	a0,s2
400130e8:	b1dff0ef          	jal	ra,40012c04 <net_pkt_get_len.isra.0>
	hdr_len = hdr_len <= len ? 0 : hdr_len - len;
400130ec:	00000913          	li	s2,0
400130f0:	fc9574e3          	bgeu	a0,s1,400130b8 <net_pkt_available_payload_buffer+0x38>
400130f4:	40a48933          	sub	s2,s1,a0
400130f8:	fc1ff06f          	j	400130b8 <net_pkt_available_payload_buffer+0x38>
		return 0;
400130fc:	00000513          	li	a0,0
}
40013100:	00008067          	ret

40013104 <net_pkt_trim_buffer>:
{
40013104:	ff010113          	addi	sp,sp,-16
40013108:	00812423          	sw	s0,8(sp)
4001310c:	00912223          	sw	s1,4(sp)
40013110:	00112623          	sw	ra,12(sp)
40013114:	01212023          	sw	s2,0(sp)
40013118:	00050413          	mv	s0,a0
	buf = pkt->buffer;
4001311c:	00852503          	lw	a0,8(a0)
	prev = buf;
40013120:	00050493          	mv	s1,a0
	while (buf) {
40013124:	00051e63          	bnez	a0,40013140 <net_pkt_trim_buffer+0x3c>
}
40013128:	00c12083          	lw	ra,12(sp)
4001312c:	00812403          	lw	s0,8(sp)
40013130:	00412483          	lw	s1,4(sp)
40013134:	00012903          	lw	s2,0(sp)
40013138:	01010113          	addi	sp,sp,16
4001313c:	00008067          	ret
		if (!buf->len) {
40013140:	01055783          	lhu	a5,16(a0)
		struct net_buf *next = buf->frags;
40013144:	00452903          	lw	s2,4(a0)
		if (!buf->len) {
40013148:	00079e63          	bnez	a5,40013164 <net_pkt_trim_buffer+0x60>
			if (buf == pkt->buffer) {
4001314c:	00842783          	lw	a5,8(s0)
40013150:	02a79063          	bne	a5,a0,40013170 <net_pkt_trim_buffer+0x6c>
				pkt->buffer = next;
40013154:	01242423          	sw	s2,8(s0)
			buf->frags = NULL;
40013158:	00052223          	sw	zero,4(a0)
			net_buf_unref(buf);
4001315c:	fb4f60ef          	jal	ra,40009910 <net_buf_unref>
40013160:	00048513          	mv	a0,s1
40013164:	00050493          	mv	s1,a0
40013168:	00090513          	mv	a0,s2
4001316c:	fb9ff06f          	j	40013124 <net_pkt_trim_buffer+0x20>
			} else if (buf == prev->frags) {
40013170:	0044a783          	lw	a5,4(s1)
40013174:	fea792e3          	bne	a5,a0,40013158 <net_pkt_trim_buffer+0x54>
				prev->frags = next;
40013178:	0124a223          	sw	s2,4(s1)
4001317c:	fddff06f          	j	40013158 <net_pkt_trim_buffer+0x54>

40013180 <net_pkt_remove_tail>:
{
40013180:	ff010113          	addi	sp,sp,-16
40013184:	00912223          	sw	s1,4(sp)
40013188:	00112623          	sw	ra,12(sp)
4001318c:	00812423          	sw	s0,8(sp)
	struct net_buf *buf = pkt->buffer;
40013190:	00852403          	lw	s0,8(a0)
{
40013194:	00058493          	mv	s1,a1
	size_t remaining_len = net_pkt_get_len(pkt);
40013198:	00040513          	mv	a0,s0
4001319c:	a69ff0ef          	jal	ra,40012c04 <net_pkt_get_len.isra.0>
	remaining_len -= length;
400131a0:	409505b3          	sub	a1,a0,s1
	if (remaining_len < length) {
400131a4:	00957a63          	bgeu	a0,s1,400131b8 <net_pkt_remove_tail+0x38>
		return -EINVAL;
400131a8:	fea00513          	li	a0,-22
400131ac:	0300006f          	j	400131dc <net_pkt_remove_tail+0x5c>
		remaining_len -= buf->len;
400131b0:	40f585b3          	sub	a1,a1,a5
			if (buf->frags) {
400131b4:	00050413          	mv	s0,a0
	while (buf) {
400131b8:	02040063          	beqz	s0,400131d8 <net_pkt_remove_tail+0x58>
		if (buf->len >= remaining_len) {
400131bc:	01045783          	lhu	a5,16(s0)
			if (buf->frags) {
400131c0:	00442503          	lw	a0,4(s0)
		if (buf->len >= remaining_len) {
400131c4:	feb7e6e3          	bltu	a5,a1,400131b0 <net_pkt_remove_tail+0x30>
			buf->len = remaining_len;
400131c8:	00b41823          	sh	a1,16(s0)
			if (buf->frags) {
400131cc:	00050663          	beqz	a0,400131d8 <net_pkt_remove_tail+0x58>
				net_pkt_frag_unref(buf->frags);
400131d0:	d41ff0ef          	jal	ra,40012f10 <net_pkt_frag_unref>
				buf->frags = NULL;
400131d4:	00042223          	sw	zero,4(s0)
	return 0;
400131d8:	00000513          	li	a0,0
}
400131dc:	00c12083          	lw	ra,12(sp)
400131e0:	00812403          	lw	s0,8(sp)
400131e4:	00412483          	lw	s1,4(sp)
400131e8:	01010113          	addi	sp,sp,16
400131ec:	00008067          	ret

400131f0 <net_pkt_cursor_init>:
	pkt->cursor.buf = pkt->buffer;
400131f0:	00852783          	lw	a5,8(a0)
400131f4:	00f52623          	sw	a5,12(a0)
	if (pkt->cursor.buf) {
400131f8:	00078463          	beqz	a5,40013200 <net_pkt_cursor_init+0x10>
		pkt->cursor.pos = pkt->cursor.buf->data;
400131fc:	00c7a783          	lw	a5,12(a5)
40013200:	00f52823          	sw	a5,16(a0)
}
40013204:	00008067          	ret

40013208 <pkt_alloc>:
{
40013208:	fd010113          	addi	sp,sp,-48
4001320c:	02912223          	sw	s1,36(sp)
40013210:	00c12423          	sw	a2,8(sp)
40013214:	02112623          	sw	ra,44(sp)
40013218:	02812423          	sw	s0,40(sp)
4001321c:	00050493          	mv	s1,a0
40013220:	00b12623          	sw	a1,12(sp)
	if (k_is_in_isr()) {
40013224:	6ad140ef          	jal	ra,400280d0 <k_is_in_isr>
40013228:	00812683          	lw	a3,8(sp)
4001322c:	00c12603          	lw	a2,12(sp)
40013230:	00050663          	beqz	a0,4001323c <pkt_alloc+0x34>
		timeout = K_NO_WAIT;
40013234:	00000613          	li	a2,0
40013238:	00000693          	li	a3,0
	ret = k_mem_slab_alloc(slab, (void **)&pkt, timeout);
4001323c:	01c10593          	addi	a1,sp,28
40013240:	00048513          	mv	a0,s1
40013244:	4f5140ef          	jal	ra,40027f38 <k_mem_slab_alloc>
		return NULL;
40013248:	00000413          	li	s0,0
	if (ret) {
4001324c:	04051263          	bnez	a0,40013290 <pkt_alloc+0x88>
	memset(pkt, 0, sizeof(struct net_pkt));
40013250:	01c12503          	lw	a0,28(sp)
40013254:	04400613          	li	a2,68
40013258:	00000593          	li	a1,0
4001325c:	e15f50ef          	jal	ra,40009070 <memset>
	pkt->atomic_ref = ATOMIC_INIT(1);
40013260:	01c12403          	lw	s0,28(sp)
	pkt->ipv6_next_hdr = next_hdr;
40013264:	fff00793          	li	a5,-1
40013268:	00100713          	li	a4,1
4001326c:	02f40fa3          	sb	a5,63(s0)
	if (&tx_pkts == slab) {
40013270:	4003d7b7          	lui	a5,0x4003d
	pkt->atomic_ref = ATOMIC_INIT(1);
40013274:	02e42023          	sw	a4,32(s0)
	pkt->slab = slab;
40013278:	00942223          	sw	s1,4(s0)
	if (&tx_pkts == slab) {
4001327c:	a6c78793          	addi	a5,a5,-1428 # 4003ca6c <tx_pkts>
40013280:	02f49463          	bne	s1,a5,400132a8 <pkt_alloc+0xa0>
	pkt->priority = priority;
40013284:	04e400a3          	sb	a4,65(s0)
	net_pkt_cursor_init(pkt);
40013288:	00040513          	mv	a0,s0
4001328c:	f65ff0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
}
40013290:	02c12083          	lw	ra,44(sp)
40013294:	00040513          	mv	a0,s0
40013298:	02812403          	lw	s0,40(sp)
4001329c:	02412483          	lw	s1,36(sp)
400132a0:	03010113          	addi	sp,sp,48
400132a4:	00008067          	ret
	} else if (&rx_pkts == slab) {
400132a8:	4003d7b7          	lui	a5,0x4003d
400132ac:	a3478793          	addi	a5,a5,-1484 # 4003ca34 <rx_pkts>
400132b0:	fcf49ce3          	bne	s1,a5,40013288 <pkt_alloc+0x80>
400132b4:	040400a3          	sb	zero,65(s0)
}
400132b8:	fd1ff06f          	j	40013288 <pkt_alloc+0x80>

400132bc <net_pkt_alloc>:
	return pkt_alloc(&tx_pkts, timeout);
400132bc:	00058613          	mv	a2,a1
400132c0:	00050593          	mv	a1,a0
400132c4:	4003d537          	lui	a0,0x4003d
400132c8:	a6c50513          	addi	a0,a0,-1428 # 4003ca6c <tx_pkts>
400132cc:	f3dff06f          	j	40013208 <pkt_alloc>

400132d0 <net_pkt_rx_alloc>:
	return pkt_alloc(&rx_pkts, timeout);
400132d0:	00058613          	mv	a2,a1
400132d4:	00050593          	mv	a1,a0
400132d8:	4003d537          	lui	a0,0x4003d
400132dc:	a3450513          	addi	a0,a0,-1484 # 4003ca34 <rx_pkts>
400132e0:	f29ff06f          	j	40013208 <pkt_alloc>

400132e4 <pkt_alloc_on_iface>:
{
400132e4:	ff010113          	addi	sp,sp,-16
400132e8:	00812423          	sw	s0,8(sp)
400132ec:	00058413          	mv	s0,a1
	pkt = pkt_alloc(slab, timeout);
400132f0:	00060593          	mv	a1,a2
400132f4:	00068613          	mv	a2,a3
{
400132f8:	00112623          	sw	ra,12(sp)
	pkt = pkt_alloc(slab, timeout);
400132fc:	f0dff0ef          	jal	ra,40013208 <pkt_alloc>
	if (pkt) {
40013300:	02050263          	beqz	a0,40013324 <pkt_alloc_on_iface+0x40>
	pkt->iface = iface;
40013304:	00852c23          	sw	s0,24(a0)
	if (iface) {
40013308:	00040e63          	beqz	s0,40013324 <pkt_alloc_on_iface+0x40>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
4001330c:	00042783          	lw	a5,0(s0)
40013310:	0157c783          	lbu	a5,21(a5)
40013314:	02f504a3          	sb	a5,41(a0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
40013318:	00042783          	lw	a5,0(s0)
4001331c:	0157c783          	lbu	a5,21(a5)
40013320:	02f508a3          	sb	a5,49(a0)
}
40013324:	00c12083          	lw	ra,12(sp)
40013328:	00812403          	lw	s0,8(sp)
4001332c:	01010113          	addi	sp,sp,16
40013330:	00008067          	ret

40013334 <net_pkt_append_buffer>:
	if (!pkt->buffer) {
40013334:	00852703          	lw	a4,8(a0)
40013338:	00071663          	bnez	a4,40013344 <net_pkt_append_buffer+0x10>
		pkt->buffer = buffer;
4001333c:	00b52423          	sw	a1,8(a0)
		net_pkt_cursor_init(pkt);
40013340:	eb1ff06f          	j	400131f0 <net_pkt_cursor_init>
{
40013344:	fe010113          	addi	sp,sp,-32
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
40013348:	00070513          	mv	a0,a4
{
4001334c:	00112e23          	sw	ra,28(sp)
40013350:	00b12623          	sw	a1,12(sp)
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
40013354:	e8cf60ef          	jal	ra,400099e0 <net_buf_frag_last>
40013358:	00c12583          	lw	a1,12(sp)
}
4001335c:	01c12083          	lw	ra,28(sp)
40013360:	02010113          	addi	sp,sp,32
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
40013364:	e90f606f          	j	400099f4 <net_buf_frag_insert>

40013368 <net_pkt_alloc_buffer>:
{
40013368:	fd010113          	addi	sp,sp,-48
4001336c:	02912223          	sw	s1,36(sp)
40013370:	01412c23          	sw	s4,24(sp)
40013374:	00058493          	mv	s1,a1
40013378:	00050a13          	mv	s4,a0
4001337c:	00070593          	mv	a1,a4
40013380:	00068513          	mv	a0,a3
40013384:	02812423          	sw	s0,40(sp)
40013388:	01312e23          	sw	s3,28(sp)
4001338c:	01512a23          	sw	s5,20(sp)
40013390:	01612823          	sw	s6,16(sp)
40013394:	01812423          	sw	s8,8(sp)
40013398:	02112623          	sw	ra,44(sp)
4001339c:	00060c13          	mv	s8,a2
400133a0:	03212023          	sw	s2,32(sp)
400133a4:	01712623          	sw	s7,12(sp)
400133a8:	01912223          	sw	s9,4(sp)
400133ac:	01a12023          	sw	s10,0(sp)
400133b0:	00068413          	mv	s0,a3
400133b4:	00070993          	mv	s3,a4
	uint64_t end = sys_clock_timeout_end_calc(timeout);
400133b8:	069170ef          	jal	ra,4002ac20 <sys_clock_timeout_end_calc>
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
400133bc:	009c67b3          	or	a5,s8,s1
	uint64_t end = sys_clock_timeout_end_calc(timeout);
400133c0:	00050a93          	mv	s5,a0
400133c4:	00058b13          	mv	s6,a1
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
400133c8:	00079863          	bnez	a5,400133d8 <net_pkt_alloc_buffer+0x70>
	return pkt->family;
400133cc:	034a2783          	lw	a5,52(s4)
400133d0:	01d7d793          	srli	a5,a5,0x1d
400133d4:	20078863          	beqz	a5,400135e4 <net_pkt_alloc_buffer+0x27c>
	if (k_is_in_isr()) {
400133d8:	4f9140ef          	jal	ra,400280d0 <k_is_in_isr>
400133dc:	00050663          	beqz	a0,400133e8 <net_pkt_alloc_buffer+0x80>
		timeout = K_NO_WAIT;
400133e0:	00000413          	li	s0,0
400133e4:	00000993          	li	s3,0
	alloc_len = net_pkt_available_buffer(pkt);
400133e8:	000a0513          	mv	a0,s4
400133ec:	c2dff0ef          	jal	ra,40013018 <net_pkt_available_buffer>
400133f0:	00050b93          	mv	s7,a0
	if (!alloc_len) {
400133f4:	034a2903          	lw	s2,52(s4)
	size_t hdr_len = 0;
400133f8:	00000793          	li	a5,0
	if (!alloc_len) {
400133fc:	00051c63          	bnez	a0,40013414 <net_pkt_alloc_buffer+0xac>
		hdr_len = pkt_estimate_headers_length(pkt,
40013400:	01d95513          	srli	a0,s2,0x1d
	if (family == AF_UNSPEC) {
40013404:	00050863          	beqz	a0,40013414 <net_pkt_alloc_buffer+0xac>
40013408:	000c0593          	mv	a1,s8
4001340c:	fa0ff0ef          	jal	ra,40012bac <pkt_estimate_headers_length.part.0>
40013410:	00050793          	mv	a5,a0
	return pkt->iface;
40013414:	018a2683          	lw	a3,24(s4)
	alloc_len = pkt_buffer_length(pkt, size + hdr_len, proto, alloc_len);
40013418:	00f48733          	add	a4,s1,a5
	sa_family_t family = net_pkt_family(pkt);
4001341c:	01d95793          	srli	a5,s2,0x1d
	if (net_pkt_iface(pkt)) {
40013420:	0e069663          	bnez	a3,4001350c <net_pkt_alloc_buffer+0x1a4>
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40013424:	00200693          	li	a3,2
40013428:	10d78863          	beq	a5,a3,40013538 <net_pkt_alloc_buffer+0x1d0>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
4001342c:	00100693          	li	a3,1
40013430:	12d78063          	beq	a5,a3,40013550 <net_pkt_alloc_buffer+0x1e8>
			max_len = size;
40013434:	00070793          	mv	a5,a4
	max_len -= existing;
40013438:	41778933          	sub	s2,a5,s7
	return MIN(size, max_len);
4001343c:	01277463          	bgeu	a4,s2,40013444 <net_pkt_alloc_buffer+0xdc>
40013440:	00070913          	mv	s2,a4
		pool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;
40013444:	004a2703          	lw	a4,4(s4)
40013448:	4003d7b7          	lui	a5,0x4003d
4001344c:	a6c78793          	addi	a5,a5,-1428 # 4003ca6c <tx_pkts>
40013450:	12f71263          	bne	a4,a5,40013574 <net_pkt_alloc_buffer+0x20c>
40013454:	4003dbb7          	lui	s7,0x4003d
40013458:	c10b8b93          	addi	s7,s7,-1008 # 4003cc10 <tx_bufs>
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
4001345c:	013467b3          	or	a5,s0,s3
40013460:	02078863          	beqz	a5,40013490 <net_pkt_alloc_buffer+0x128>
40013464:	fff00793          	li	a5,-1
40013468:	00f41463          	bne	s0,a5,40013470 <net_pkt_alloc_buffer+0x108>
4001346c:	02898263          	beq	s3,s0,40013490 <net_pkt_alloc_buffer+0x128>
		int64_t remaining = end - sys_clock_tick_get();
40013470:	6e8170ef          	jal	ra,4002ab58 <sys_clock_tick_get>
40013474:	40aa8433          	sub	s0,s5,a0
40013478:	008abab3          	sltu	s5,s5,s0
4001347c:	40bb0b33          	sub	s6,s6,a1
40013480:	415b09b3          	sub	s3,s6,s5
		if (remaining <= 0) {
40013484:	0009d663          	bgez	s3,40013490 <net_pkt_alloc_buffer+0x128>
40013488:	00000413          	li	s0,0
4001348c:	00000993          	li	s3,0
	uint64_t end = sys_clock_timeout_end_calc(timeout);
40013490:	00040513          	mv	a0,s0
40013494:	00098593          	mv	a1,s3
40013498:	788170ef          	jal	ra,4002ac20 <sys_clock_timeout_end_calc>
4001349c:	00050b13          	mv	s6,a0
400134a0:	00058c13          	mv	s8,a1
	struct net_buf *current = NULL;
400134a4:	00000493          	li	s1,0
	struct net_buf *first = NULL;
400134a8:	00000a93          	li	s5,0
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
400134ac:	fff00c93          	li	s9,-1
		new = net_buf_alloc_fixed(pool, timeout);
400134b0:	00040593          	mv	a1,s0
400134b4:	00098613          	mv	a2,s3
400134b8:	000b8513          	mv	a0,s7
400134bc:	c3cf60ef          	jal	ra,400098f8 <net_buf_alloc_fixed>
400134c0:	00048d13          	mv	s10,s1
400134c4:	00050493          	mv	s1,a0
		if (!new) {
400134c8:	0a051c63          	bnez	a0,40013580 <net_pkt_alloc_buffer+0x218>
	if (first) {
400134cc:	120a9463          	bnez	s5,400135f4 <net_pkt_alloc_buffer+0x28c>
		return -ENOMEM;
400134d0:	ff400513          	li	a0,-12
}
400134d4:	02c12083          	lw	ra,44(sp)
400134d8:	02812403          	lw	s0,40(sp)
400134dc:	02412483          	lw	s1,36(sp)
400134e0:	02012903          	lw	s2,32(sp)
400134e4:	01c12983          	lw	s3,28(sp)
400134e8:	01812a03          	lw	s4,24(sp)
400134ec:	01412a83          	lw	s5,20(sp)
400134f0:	01012b03          	lw	s6,16(sp)
400134f4:	00c12b83          	lw	s7,12(sp)
400134f8:	00812c03          	lw	s8,8(sp)
400134fc:	00412c83          	lw	s9,4(sp)
40013500:	00012d03          	lw	s10,0(sp)
40013504:	03010113          	addi	sp,sp,48
40013508:	00008067          	ret
	return iface->if_dev->mtu;
4001350c:	0006a603          	lw	a2,0(a3)
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40013510:	00200593          	li	a1,2
		max_len = net_if_get_mtu(net_pkt_iface(pkt));
40013514:	01865683          	lhu	a3,24(a2)
	if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
40013518:	02b78263          	beq	a5,a1,4001353c <net_pkt_alloc_buffer+0x1d4>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
4001351c:	00100593          	li	a1,1
40013520:	02b79c63          	bne	a5,a1,40013558 <net_pkt_alloc_buffer+0x1f0>
		max_len = MAX(max_len, NET_IPV4_MTU);
40013524:	00068793          	mv	a5,a3
40013528:	24000693          	li	a3,576
4001352c:	f0d7f6e3          	bgeu	a5,a3,40013438 <net_pkt_alloc_buffer+0xd0>
40013530:	24000793          	li	a5,576
40013534:	f05ff06f          	j	40013438 <net_pkt_alloc_buffer+0xd0>
		max_len = 0;
40013538:	00000693          	li	a3,0
		max_len = MAX(max_len, NET_IPV6_MTU);
4001353c:	00068793          	mv	a5,a3
40013540:	50000693          	li	a3,1280
40013544:	eed7fae3          	bgeu	a5,a3,40013438 <net_pkt_alloc_buffer+0xd0>
40013548:	50000793          	li	a5,1280
4001354c:	eedff06f          	j	40013438 <net_pkt_alloc_buffer+0xd0>
		max_len = 0;
40013550:	00000693          	li	a3,0
40013554:	fd1ff06f          	j	40013524 <net_pkt_alloc_buffer+0x1bc>
		if (net_if_l2(net_pkt_iface(pkt)) ==
40013558:	00462583          	lw	a1,4(a2)
4001355c:	4003d637          	lui	a2,0x4003d
40013560:	c6460613          	addi	a2,a2,-924 # 4003cc64 <_net_l2_ETHERNET>
			max_len = size;
40013564:	00070793          	mv	a5,a4
		if (net_if_l2(net_pkt_iface(pkt)) ==
40013568:	ecc598e3          	bne	a1,a2,40013438 <net_pkt_alloc_buffer+0xd0>
			max_len += NET_ETH_MAX_HDR_SIZE;
4001356c:	00e68793          	addi	a5,a3,14
40013570:	ec9ff06f          	j	40013438 <net_pkt_alloc_buffer+0xd0>
		pool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;
40013574:	4003dbb7          	lui	s7,0x4003d
40013578:	be4b8b93          	addi	s7,s7,-1052 # 4003cbe4 <rx_bufs>
4001357c:	ee1ff06f          	j	4001345c <net_pkt_alloc_buffer+0xf4>
		if (!first && !current) {
40013580:	000a9463          	bnez	s5,40013588 <net_pkt_alloc_buffer+0x220>
40013584:	060d0463          	beqz	s10,400135ec <net_pkt_alloc_buffer+0x284>
			current->frags = new;
40013588:	009d2223          	sw	s1,4(s10)
		if (current->size > size) {
4001358c:	0124d783          	lhu	a5,18(s1)
40013590:	00f97463          	bgeu	s2,a5,40013598 <net_pkt_alloc_buffer+0x230>
			current->size = size;
40013594:	01249923          	sh	s2,18(s1)
		size -= current->size;
40013598:	0124d783          	lhu	a5,18(s1)
4001359c:	40f90933          	sub	s2,s2,a5
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
400135a0:	013467b3          	or	a5,s0,s3
400135a4:	02078663          	beqz	a5,400135d0 <net_pkt_alloc_buffer+0x268>
400135a8:	01941463          	bne	s0,s9,400135b0 <net_pkt_alloc_buffer+0x248>
400135ac:	02898263          	beq	s3,s0,400135d0 <net_pkt_alloc_buffer+0x268>
			int64_t remaining = end - sys_clock_tick_get();
400135b0:	5a8170ef          	jal	ra,4002ab58 <sys_clock_tick_get>
400135b4:	40ab0433          	sub	s0,s6,a0
400135b8:	008b37b3          	sltu	a5,s6,s0
400135bc:	40bc05b3          	sub	a1,s8,a1
400135c0:	40f589b3          	sub	s3,a1,a5
			if (remaining <= 0) {
400135c4:	01304663          	bgtz	s3,400135d0 <net_pkt_alloc_buffer+0x268>
400135c8:	00099663          	bnez	s3,400135d4 <net_pkt_alloc_buffer+0x26c>
400135cc:	00040463          	beqz	s0,400135d4 <net_pkt_alloc_buffer+0x26c>
	} while (size);
400135d0:	ee0910e3          	bnez	s2,400134b0 <net_pkt_alloc_buffer+0x148>
	if (!buf) {
400135d4:	ee0a8ee3          	beqz	s5,400134d0 <net_pkt_alloc_buffer+0x168>
	net_pkt_append_buffer(pkt, buf);
400135d8:	000a8593          	mv	a1,s5
400135dc:	000a0513          	mv	a0,s4
400135e0:	d55ff0ef          	jal	ra,40013334 <net_pkt_append_buffer>
		return 0;
400135e4:	00000513          	li	a0,0
400135e8:	eedff06f          	j	400134d4 <net_pkt_alloc_buffer+0x16c>
400135ec:	00050a93          	mv	s5,a0
400135f0:	f9dff06f          	j	4001358c <net_pkt_alloc_buffer+0x224>
		net_buf_unref(first);
400135f4:	000a8513          	mv	a0,s5
400135f8:	b18f60ef          	jal	ra,40009910 <net_buf_unref>
	if (!buf) {
400135fc:	ed5ff06f          	j	400134d0 <net_pkt_alloc_buffer+0x168>

40013600 <pkt_alloc_with_buffer>:
{
40013600:	fd010113          	addi	sp,sp,-48
40013604:	03212023          	sw	s2,32(sp)
40013608:	01812423          	sw	s8,8(sp)
4001360c:	00050913          	mv	s2,a0
40013610:	00058c13          	mv	s8,a1
	uint64_t end = sys_clock_timeout_end_calc(timeout);
40013614:	00078513          	mv	a0,a5
40013618:	00080593          	mv	a1,a6
{
4001361c:	02812423          	sw	s0,40(sp)
40013620:	02912223          	sw	s1,36(sp)
40013624:	01312e23          	sw	s3,28(sp)
40013628:	01412c23          	sw	s4,24(sp)
4001362c:	01512a23          	sw	s5,20(sp)
40013630:	01612823          	sw	s6,16(sp)
40013634:	01712623          	sw	s7,12(sp)
40013638:	02112623          	sw	ra,44(sp)
4001363c:	00060a93          	mv	s5,a2
40013640:	00068b93          	mv	s7,a3
40013644:	00078413          	mv	s0,a5
40013648:	00080493          	mv	s1,a6
4001364c:	00070b13          	mv	s6,a4
	uint64_t end = sys_clock_timeout_end_calc(timeout);
40013650:	5d0170ef          	jal	ra,4002ac20 <sys_clock_timeout_end_calc>
40013654:	00050993          	mv	s3,a0
40013658:	00058a13          	mv	s4,a1
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
4001365c:	00040613          	mv	a2,s0
40013660:	00048693          	mv	a3,s1
40013664:	000c0593          	mv	a1,s8
40013668:	00090513          	mv	a0,s2
4001366c:	c79ff0ef          	jal	ra,400132e4 <pkt_alloc_on_iface>
	if (!pkt) {
40013670:	06050a63          	beqz	a0,400136e4 <pkt_alloc_with_buffer+0xe4>
	pkt->family = family;
40013674:	03754783          	lbu	a5,55(a0)
40013678:	005b9b93          	slli	s7,s7,0x5
4001367c:	00050913          	mv	s2,a0
40013680:	01f7f793          	andi	a5,a5,31
40013684:	0177e7b3          	or	a5,a5,s7
40013688:	02f50ba3          	sb	a5,55(a0)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
4001368c:	009467b3          	or	a5,s0,s1
40013690:	02078863          	beqz	a5,400136c0 <pkt_alloc_with_buffer+0xc0>
40013694:	fff00793          	li	a5,-1
40013698:	00f41463          	bne	s0,a5,400136a0 <pkt_alloc_with_buffer+0xa0>
4001369c:	02848263          	beq	s1,s0,400136c0 <pkt_alloc_with_buffer+0xc0>
		int64_t remaining = end - sys_clock_tick_get();
400136a0:	4b8170ef          	jal	ra,4002ab58 <sys_clock_tick_get>
400136a4:	40a98433          	sub	s0,s3,a0
400136a8:	0089b9b3          	sltu	s3,s3,s0
400136ac:	40ba0a33          	sub	s4,s4,a1
400136b0:	413a04b3          	sub	s1,s4,s3
		if (remaining <= 0) {
400136b4:	0004d663          	bgez	s1,400136c0 <pkt_alloc_with_buffer+0xc0>
400136b8:	00000413          	li	s0,0
400136bc:	00000493          	li	s1,0
	ret = net_pkt_alloc_buffer(pkt, size, proto, timeout);
400136c0:	00040693          	mv	a3,s0
400136c4:	00048713          	mv	a4,s1
400136c8:	000b0613          	mv	a2,s6
400136cc:	000a8593          	mv	a1,s5
400136d0:	00090513          	mv	a0,s2
400136d4:	c95ff0ef          	jal	ra,40013368 <net_pkt_alloc_buffer>
	if (ret) {
400136d8:	00050863          	beqz	a0,400136e8 <pkt_alloc_with_buffer+0xe8>
		net_pkt_unref(pkt);
400136dc:	00090513          	mv	a0,s2
400136e0:	83dff0ef          	jal	ra,40012f1c <net_pkt_unref>
		return NULL;
400136e4:	00000913          	li	s2,0
}
400136e8:	02c12083          	lw	ra,44(sp)
400136ec:	02812403          	lw	s0,40(sp)
400136f0:	02412483          	lw	s1,36(sp)
400136f4:	01c12983          	lw	s3,28(sp)
400136f8:	01812a03          	lw	s4,24(sp)
400136fc:	01412a83          	lw	s5,20(sp)
40013700:	01012b03          	lw	s6,16(sp)
40013704:	00c12b83          	lw	s7,12(sp)
40013708:	00812c03          	lw	s8,8(sp)
4001370c:	00090513          	mv	a0,s2
40013710:	02012903          	lw	s2,32(sp)
40013714:	03010113          	addi	sp,sp,48
40013718:	00008067          	ret

4001371c <net_pkt_alloc_with_buffer>:
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
4001371c:	00078813          	mv	a6,a5
40013720:	00070793          	mv	a5,a4
40013724:	00068713          	mv	a4,a3
40013728:	00060693          	mv	a3,a2
4001372c:	00058613          	mv	a2,a1
40013730:	00050593          	mv	a1,a0
40013734:	4003d537          	lui	a0,0x4003d
40013738:	a6c50513          	addi	a0,a0,-1428 # 4003ca6c <tx_pkts>
4001373c:	ec5ff06f          	j	40013600 <pkt_alloc_with_buffer>

40013740 <net_pkt_rx_alloc_with_buffer>:
	return pkt_alloc_with_buffer(&rx_pkts, iface, size, family,
40013740:	00078813          	mv	a6,a5
40013744:	00070793          	mv	a5,a4
40013748:	00068713          	mv	a4,a3
4001374c:	00060693          	mv	a3,a2
40013750:	00058613          	mv	a2,a1
40013754:	00050593          	mv	a1,a0
40013758:	4003d537          	lui	a0,0x4003d
4001375c:	a3450513          	addi	a0,a0,-1484 # 4003ca34 <rx_pkts>
40013760:	ea1ff06f          	j	40013600 <pkt_alloc_with_buffer>

40013764 <net_pkt_skip>:

int net_pkt_skip(struct net_pkt *pkt, size_t skip)
{
40013764:	00058613          	mv	a2,a1
	NET_DBG("pkt %p skip %zu", pkt, skip);

	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
40013768:	00100713          	li	a4,1
4001376c:	00000693          	li	a3,0
40013770:	00000593          	li	a1,0
40013774:	cb0ff06f          	j	40012c24 <net_pkt_cursor_operate>

40013778 <clone_pkt_lladdr>:
static void clone_pkt_lladdr(struct net_pkt *pkt, struct net_pkt *clone_pkt,
			     struct net_linkaddr *lladdr)
{
	int32_t ll_addr_offset;

	if (!lladdr->addr)
40013778:	00062783          	lw	a5,0(a2)
4001377c:	08078c63          	beqz	a5,40013814 <clone_pkt_lladdr+0x9c>
	if (!ptr || !pkt || !pkt->buffer) {
40013780:	08050a63          	beqz	a0,40013814 <clone_pkt_lladdr+0x9c>
40013784:	00852703          	lw	a4,8(a0)
40013788:	08070663          	beqz	a4,40013814 <clone_pkt_lladdr+0x9c>
{
4001378c:	ff010113          	addi	sp,sp,-16
40013790:	00912223          	sw	s1,4(sp)
40013794:	01212023          	sw	s2,0(sp)
40013798:	00112623          	sw	ra,12(sp)
4001379c:	00812423          	sw	s0,8(sp)
400137a0:	00058493          	mv	s1,a1
400137a4:	00060913          	mv	s2,a2
	offset = 0U;
400137a8:	00000693          	li	a3,0
		if (buf->data <= ptr && ptr <= (buf->data + buf->len)) {
400137ac:	00c72603          	lw	a2,12(a4)
400137b0:	01075583          	lhu	a1,16(a4)
400137b4:	04c7e463          	bltu	a5,a2,400137fc <clone_pkt_lladdr+0x84>
400137b8:	00b60533          	add	a0,a2,a1
400137bc:	04f56063          	bltu	a0,a5,400137fc <clone_pkt_lladdr+0x84>
			ret = offset + (ptr - buf->data);
400137c0:	40c787b3          	sub	a5,a5,a2
		return;

	ll_addr_offset = net_pkt_find_offset(pkt, lladdr->addr);

	if (ll_addr_offset >= 0) {
		net_pkt_cursor_init(clone_pkt);
400137c4:	00048513          	mv	a0,s1
			ret = offset + (ptr - buf->data);
400137c8:	00d78433          	add	s0,a5,a3
		net_pkt_cursor_init(clone_pkt);
400137cc:	a25ff0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
		net_pkt_skip(clone_pkt, ll_addr_offset);
400137d0:	00040593          	mv	a1,s0
400137d4:	00048513          	mv	a0,s1
400137d8:	f8dff0ef          	jal	ra,40013764 <net_pkt_skip>
 *
 * @return cursor's position
 */
static inline void *net_pkt_cursor_get_pos(struct net_pkt *pkt)
{
	return pkt->cursor.pos;
400137dc:	0104a783          	lw	a5,16(s1)
		lladdr->addr = net_pkt_cursor_get_pos(clone_pkt);
400137e0:	00f92023          	sw	a5,0(s2)
	}
}
400137e4:	00c12083          	lw	ra,12(sp)
400137e8:	00812403          	lw	s0,8(sp)
400137ec:	00412483          	lw	s1,4(sp)
400137f0:	00012903          	lw	s2,0(sp)
400137f4:	01010113          	addi	sp,sp,16
400137f8:	00008067          	ret
		buf = buf->frags;
400137fc:	00472703          	lw	a4,4(a4)
		offset += buf->len;
40013800:	00b686b3          	add	a3,a3,a1
40013804:	01069693          	slli	a3,a3,0x10
40013808:	0106d693          	srli	a3,a3,0x10
	while (buf) {
4001380c:	fa0710e3          	bnez	a4,400137ac <clone_pkt_lladdr+0x34>
40013810:	fd5ff06f          	j	400137e4 <clone_pkt_lladdr+0x6c>
40013814:	00008067          	ret

40013818 <clone_pkt_attributes>:
	ARG_UNUSED(clone_pkt);
}
#endif

static void clone_pkt_attributes(struct net_pkt *pkt, struct net_pkt *clone_pkt)
{
40013818:	fe010113          	addi	sp,sp,-32
4001381c:	00812c23          	sw	s0,24(sp)
40013820:	00912a23          	sw	s1,20(sp)
40013824:	00112e23          	sw	ra,28(sp)
40013828:	01212823          	sw	s2,16(sp)
4001382c:	01312623          	sw	s3,12(sp)
	return pkt->family;
40013830:	03754703          	lbu	a4,55(a0)
	pkt->family = family;
40013834:	0375c783          	lbu	a5,55(a1)
40013838:	00050493          	mv	s1,a0
4001383c:	0e077713          	andi	a4,a4,224
40013840:	01f7f793          	andi	a5,a5,31
40013844:	00e7e7b3          	or	a5,a5,a4
40013848:	02f58ba3          	sb	a5,55(a1)
	return pkt->context;
4001384c:	01452783          	lw	a5,20(a0)
40013850:	00058413          	mv	s0,a1
	pkt->context = ctx;
40013854:	00f5aa23          	sw	a5,20(a1)
	return pkt->ip_hdr_len;
40013858:	03654783          	lbu	a5,54(a0)
	pkt->ip_hdr_len = len;
4001385c:	02f58b23          	sb	a5,54(a1)
	return pkt->ip_dscp;
40013860:	04052703          	lw	a4,64(a0)
	pkt->ip_dscp = dscp;
40013864:	0405c783          	lbu	a5,64(a1)
40013868:	03f77713          	andi	a4,a4,63
4001386c:	fc07f793          	andi	a5,a5,-64
40013870:	00e7e7b3          	or	a5,a5,a4
40013874:	04f58023          	sb	a5,64(a1)
	return pkt->ip_ecn;
40013878:	04052703          	lw	a4,64(a0)
	pkt->ip_ecn = ecn;
4001387c:	0ff7f793          	zext.b	a5,a5
40013880:	03f7f793          	andi	a5,a5,63
40013884:	0c077713          	andi	a4,a4,192
40013888:	00e7e7b3          	or	a5,a5,a4
4001388c:	04f58023          	sb	a5,64(a1)
	return pkt->priority;
40013890:	04154783          	lbu	a5,65(a0)
	pkt->priority = priority;
40013894:	04f580a3          	sb	a5,65(a1)
	return !!(pkt->captured);
40013898:	03854703          	lbu	a4,56(a0)
	pkt->captured = is_captured;
4001389c:	0385c783          	lbu	a5,56(a1)
400138a0:	00477713          	andi	a4,a4,4
400138a4:	ffb7f793          	andi	a5,a5,-5
400138a8:	00e7e7b3          	or	a5,a5,a4
400138ac:	02f58c23          	sb	a5,56(a1)
	return !!(pkt->l2_processed);
400138b0:	03854703          	lbu	a4,56(a0)
	pkt->l2_processed = is_l2_processed;
400138b4:	0ff7f793          	zext.b	a5,a5
400138b8:	fef7f793          	andi	a5,a5,-17
400138bc:	01077713          	andi	a4,a4,16
400138c0:	00e7e7b3          	or	a5,a5,a4
400138c4:	02f58c23          	sb	a5,56(a1)
	return pkt->ll_proto_type;
400138c8:	03455783          	lhu	a5,52(a0)
	pkt->ll_proto_type = type;
400138cc:	02f59a23          	sh	a5,52(a1)

	net_pkt_set_l2_bridged(clone_pkt, net_pkt_is_l2_bridged(pkt));
	net_pkt_set_l2_processed(clone_pkt, net_pkt_is_l2_processed(pkt));
	net_pkt_set_ll_proto_type(clone_pkt, net_pkt_ll_proto_type(pkt));

	if (pkt->buffer && clone_pkt->buffer) {
400138d0:	00852783          	lw	a5,8(a0)
400138d4:	06078063          	beqz	a5,40013934 <clone_pkt_attributes+0x11c>
400138d8:	0085a783          	lw	a5,8(a1)
400138dc:	04078c63          	beqz	a5,40013934 <clone_pkt_attributes+0x11c>
	return &pkt->lladdr_src;
400138e0:	02458993          	addi	s3,a1,36
		memcpy(net_pkt_lladdr_src(clone_pkt), net_pkt_lladdr_src(pkt),
400138e4:	00800613          	li	a2,8
400138e8:	02450593          	addi	a1,a0,36
400138ec:	00098513          	mv	a0,s3
400138f0:	f5cf50ef          	jal	ra,4000904c <memcpy>
	return &pkt->lladdr_dst;
400138f4:	02c40913          	addi	s2,s0,44
		       sizeof(struct net_linkaddr));
		memcpy(net_pkt_lladdr_dst(clone_pkt), net_pkt_lladdr_dst(pkt),
400138f8:	00800613          	li	a2,8
400138fc:	02c48593          	addi	a1,s1,44
40013900:	00090513          	mv	a0,s2
40013904:	f48f50ef          	jal	ra,4000904c <memcpy>
		 * into the fragment memory of the buffer,
		 * otherwise we have to set the ll address pointer
		 * relative to the new buffer to avoid dangling
		 * pointers into the source packet.
		 */
		if (pkt->buffer != clone_pkt->buffer) {
40013908:	0084a703          	lw	a4,8(s1)
4001390c:	00842783          	lw	a5,8(s0)
40013910:	02f70263          	beq	a4,a5,40013934 <clone_pkt_attributes+0x11c>
			clone_pkt_lladdr(pkt, clone_pkt, net_pkt_lladdr_src(clone_pkt));
40013914:	00098613          	mv	a2,s3
40013918:	00040593          	mv	a1,s0
4001391c:	00048513          	mv	a0,s1
40013920:	e59ff0ef          	jal	ra,40013778 <clone_pkt_lladdr>
			clone_pkt_lladdr(pkt, clone_pkt, net_pkt_lladdr_dst(clone_pkt));
40013924:	00090613          	mv	a2,s2
40013928:	00040593          	mv	a1,s0
4001392c:	00048513          	mv	a0,s1
40013930:	e49ff0ef          	jal	ra,40013778 <clone_pkt_lladdr>
	return pkt->family;
40013934:	0344a783          	lw	a5,52(s1)
		}
	}

	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
40013938:	00100713          	li	a4,1
4001393c:	01d7d793          	srli	a5,a5,0x1d
40013940:	02e79863          	bne	a5,a4,40013970 <clone_pkt_attributes+0x158>
	return pkt->ipv4_ttl;
40013944:	0394c783          	lbu	a5,57(s1)
	pkt->ipv4_ttl = ttl;
40013948:	02f40ca3          	sb	a5,57(s0)
	return pkt->ipv4_opts_len;
4001394c:	03a4c783          	lbu	a5,58(s1)
	pkt->ipv4_opts_len = opts_len;
40013950:	02f40d23          	sb	a5,58(s0)
		net_pkt_set_ipv6_next_hdr(clone_pkt,
					  net_pkt_ipv6_next_hdr(pkt));
	}

	clone_pkt_cb(pkt, clone_pkt);
}
40013954:	01c12083          	lw	ra,28(sp)
40013958:	01812403          	lw	s0,24(sp)
4001395c:	01412483          	lw	s1,20(sp)
40013960:	01012903          	lw	s2,16(sp)
40013964:	00c12983          	lw	s3,12(sp)
40013968:	02010113          	addi	sp,sp,32
4001396c:	00008067          	ret
	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
40013970:	00200713          	li	a4,2
40013974:	fee790e3          	bne	a5,a4,40013954 <clone_pkt_attributes+0x13c>
	return pkt->ipv6_hop_limit;
40013978:	0394c783          	lbu	a5,57(s1)
	pkt->ipv6_hop_limit = hop_limit;
4001397c:	02f40ca3          	sb	a5,57(s0)
	return pkt->ipv6_ext_len;
40013980:	03a4d783          	lhu	a5,58(s1)
	pkt->ipv6_ext_len = len;
40013984:	02f41d23          	sh	a5,58(s0)
	return pkt->ipv6_ext_opt_len;
40013988:	03e4c783          	lbu	a5,62(s1)
	pkt->ipv6_ext_opt_len = len;
4001398c:	02f40f23          	sb	a5,62(s0)
	return pkt->ipv6_prev_hdr_start;
40013990:	03c4d783          	lhu	a5,60(s1)
	pkt->ipv6_prev_hdr_start = offset;
40013994:	02f41e23          	sh	a5,60(s0)
	return pkt->ipv6_next_hdr;
40013998:	03f4c783          	lbu	a5,63(s1)
	pkt->ipv6_next_hdr = next_hdr;
4001399c:	02f40fa3          	sb	a5,63(s0)
}
400139a0:	fb5ff06f          	j	40013954 <clone_pkt_attributes+0x13c>

400139a4 <net_pkt_memset>:
{
400139a4:	fe010113          	addi	sp,sp,-32
400139a8:	00b12623          	sw	a1,12(sp)
	return net_pkt_cursor_operate(pkt, &byte, amount, false, true);
400139ac:	00100713          	li	a4,1
400139b0:	00c10593          	addi	a1,sp,12
400139b4:	00000693          	li	a3,0
{
400139b8:	00112e23          	sw	ra,28(sp)
	return net_pkt_cursor_operate(pkt, &byte, amount, false, true);
400139bc:	a68ff0ef          	jal	ra,40012c24 <net_pkt_cursor_operate>
}
400139c0:	01c12083          	lw	ra,28(sp)
400139c4:	02010113          	addi	sp,sp,32
400139c8:	00008067          	ret

400139cc <net_pkt_read>:
	return net_pkt_cursor_operate(pkt, data, length, true, false);
400139cc:	00000713          	li	a4,0
400139d0:	00100693          	li	a3,1
400139d4:	a50ff06f          	j	40012c24 <net_pkt_cursor_operate>

400139d8 <net_pkt_read_be32>:
{
400139d8:	fe010113          	addi	sp,sp,-32
400139dc:	00812c23          	sw	s0,24(sp)
	ret = net_pkt_read(pkt, d32, sizeof(uint32_t));
400139e0:	00400613          	li	a2,4
{
400139e4:	00058413          	mv	s0,a1
	ret = net_pkt_read(pkt, d32, sizeof(uint32_t));
400139e8:	00c10593          	addi	a1,sp,12
{
400139ec:	00112e23          	sw	ra,28(sp)
	ret = net_pkt_read(pkt, d32, sizeof(uint32_t));
400139f0:	fddff0ef          	jal	ra,400139cc <net_pkt_read>
	*data = d32[0] << 24 | d32[1] << 16 | d32[2] << 8 | d32[3];
400139f4:	00c14783          	lbu	a5,12(sp)
400139f8:	00d14703          	lbu	a4,13(sp)
400139fc:	01879793          	slli	a5,a5,0x18
40013a00:	01071713          	slli	a4,a4,0x10
40013a04:	00e7e7b3          	or	a5,a5,a4
40013a08:	00f14703          	lbu	a4,15(sp)
40013a0c:	00e7e7b3          	or	a5,a5,a4
40013a10:	00e14703          	lbu	a4,14(sp)
40013a14:	00871713          	slli	a4,a4,0x8
40013a18:	00e7e7b3          	or	a5,a5,a4
40013a1c:	00f42023          	sw	a5,0(s0)
}
40013a20:	01c12083          	lw	ra,28(sp)
40013a24:	01812403          	lw	s0,24(sp)
40013a28:	02010113          	addi	sp,sp,32
40013a2c:	00008067          	ret

40013a30 <net_pkt_copy>:
{
40013a30:	fe010113          	addi	sp,sp,-32
40013a34:	00912a23          	sw	s1,20(sp)
40013a38:	01212823          	sw	s2,16(sp)
40013a3c:	01312623          	sw	s3,12(sp)
40013a40:	00112e23          	sw	ra,28(sp)
40013a44:	00812c23          	sw	s0,24(sp)
40013a48:	01412423          	sw	s4,8(sp)
40013a4c:	00050493          	mv	s1,a0
40013a50:	00058993          	mv	s3,a1
40013a54:	00060913          	mv	s2,a2
	while (c_dst->buf && c_src->buf && length) {
40013a58:	00c4a783          	lw	a5,12(s1)
40013a5c:	10078063          	beqz	a5,40013b5c <net_pkt_copy+0x12c>
40013a60:	00c9a783          	lw	a5,12(s3)
40013a64:	0e078c63          	beqz	a5,40013b5c <net_pkt_copy+0x12c>
40013a68:	02091463          	bnez	s2,40013a90 <net_pkt_copy+0x60>
	return 0;
40013a6c:	00000513          	li	a0,0
}
40013a70:	01c12083          	lw	ra,28(sp)
40013a74:	01812403          	lw	s0,24(sp)
40013a78:	01412483          	lw	s1,20(sp)
40013a7c:	01012903          	lw	s2,16(sp)
40013a80:	00c12983          	lw	s3,12(sp)
40013a84:	00812a03          	lw	s4,8(sp)
40013a88:	02010113          	addi	sp,sp,32
40013a8c:	00008067          	ret
		pkt_cursor_advance(pkt_dst, true);
40013a90:	00100593          	li	a1,1
40013a94:	00048513          	mv	a0,s1
40013a98:	fddfe0ef          	jal	ra,40012a74 <pkt_cursor_advance>
		pkt_cursor_advance(pkt_src, false);
40013a9c:	00098513          	mv	a0,s3
40013aa0:	00000593          	li	a1,0
40013aa4:	fd1fe0ef          	jal	ra,40012a74 <pkt_cursor_advance>
		if (!c_dst->buf || !c_src->buf) {
40013aa8:	00c4a503          	lw	a0,12(s1)
40013aac:	04050a63          	beqz	a0,40013b00 <net_pkt_copy+0xd0>
40013ab0:	00c9a703          	lw	a4,12(s3)
40013ab4:	04070663          	beqz	a4,40013b00 <net_pkt_copy+0xd0>
		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
40013ab8:	01075a03          	lhu	s4,16(a4)
40013abc:	0109a783          	lw	a5,16(s3)
40013ac0:	00c72703          	lw	a4,12(a4)
40013ac4:	00c50513          	addi	a0,a0,12
40013ac8:	40e787b3          	sub	a5,a5,a4
40013acc:	40fa0a33          	sub	s4,s4,a5
40013ad0:	8c8f60ef          	jal	ra,40009b98 <net_buf_simple_max_len>
		d_len = net_buf_max_len(c_dst->buf) - (c_dst->pos - c_dst->buf->data);
40013ad4:	00c4a783          	lw	a5,12(s1)
40013ad8:	00050413          	mv	s0,a0
40013adc:	0104a503          	lw	a0,16(s1)
40013ae0:	00c7a783          	lw	a5,12(a5)
40013ae4:	40f507b3          	sub	a5,a0,a5
40013ae8:	40f40433          	sub	s0,s0,a5
		if (length < s_len && length < d_len) {
40013aec:	01497463          	bgeu	s2,s4,40013af4 <net_pkt_copy+0xc4>
40013af0:	00896c63          	bltu	s2,s0,40013b08 <net_pkt_copy+0xd8>
			if (d_len < s_len) {
40013af4:	008a7463          	bgeu	s4,s0,40013afc <net_pkt_copy+0xcc>
40013af8:	000a0413          	mv	s0,s4
		if (!len) {
40013afc:	00041863          	bnez	s0,40013b0c <net_pkt_copy+0xdc>
		return -ENOBUFS;
40013b00:	f9700513          	li	a0,-105
40013b04:	f6dff06f          	j	40013a70 <net_pkt_copy+0x40>
40013b08:	00090413          	mv	s0,s2
		memcpy(c_dst->pos, c_src->pos, len);
40013b0c:	0109a583          	lw	a1,16(s3)
40013b10:	00040613          	mv	a2,s0
40013b14:	d38f50ef          	jal	ra,4000904c <memcpy>
	return pkt->overwrite;
40013b18:	0374c783          	lbu	a5,55(s1)
		if (!net_pkt_is_being_overwritten(pkt_dst)) {
40013b1c:	0017f793          	andi	a5,a5,1
40013b20:	00079a63          	bnez	a5,40013b34 <net_pkt_copy+0x104>
	return net_buf_simple_add(&buf->b, len);
40013b24:	00c4a503          	lw	a0,12(s1)
40013b28:	00040593          	mv	a1,s0
40013b2c:	00c50513          	addi	a0,a0,12
40013b30:	fedf50ef          	jal	ra,40009b1c <net_buf_simple_add>
		pkt_cursor_update(pkt_dst, len, true);
40013b34:	00100613          	li	a2,1
40013b38:	00040593          	mv	a1,s0
40013b3c:	00048513          	mv	a0,s1
40013b40:	fa1fe0ef          	jal	ra,40012ae0 <pkt_cursor_update>
		pkt_cursor_update(pkt_src, len, false);
40013b44:	00000613          	li	a2,0
40013b48:	00040593          	mv	a1,s0
40013b4c:	00098513          	mv	a0,s3
40013b50:	f91fe0ef          	jal	ra,40012ae0 <pkt_cursor_update>
		length -= len;
40013b54:	40890933          	sub	s2,s2,s0
40013b58:	f01ff06f          	j	40013a58 <net_pkt_copy+0x28>
	return 0;
40013b5c:	00000513          	li	a0,0
	if (length) {
40013b60:	f00908e3          	beqz	s2,40013a70 <net_pkt_copy+0x40>
40013b64:	f9dff06f          	j	40013b00 <net_pkt_copy+0xd0>

40013b68 <net_pkt_remaining_data>:

	return clone_pkt;
}

size_t net_pkt_remaining_data(struct net_pkt *pkt)
{
40013b68:	00050793          	mv	a5,a0
	struct net_buf *buf;
	size_t data_length;

	if (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {
40013b6c:	04050263          	beqz	a0,40013bb0 <net_pkt_remaining_data+0x48>
40013b70:	00c52703          	lw	a4,12(a0)
		return 0;
40013b74:	00000513          	li	a0,0
	if (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {
40013b78:	02070e63          	beqz	a4,40013bb4 <net_pkt_remaining_data+0x4c>
40013b7c:	0107a783          	lw	a5,16(a5)
40013b80:	02078a63          	beqz	a5,40013bb4 <net_pkt_remaining_data+0x4c>
	}

	buf = pkt->cursor.buf;
	data_length = buf->len - (pkt->cursor.pos - buf->data);
40013b84:	00c72683          	lw	a3,12(a4)
40013b88:	01075503          	lhu	a0,16(a4)
40013b8c:	40d787b3          	sub	a5,a5,a3
40013b90:	40f50533          	sub	a0,a0,a5

	buf = buf->frags;
40013b94:	00472783          	lw	a5,4(a4)
	while (buf) {
40013b98:	00079463          	bnez	a5,40013ba0 <net_pkt_remaining_data+0x38>
40013b9c:	00008067          	ret
		data_length += buf->len;
40013ba0:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
40013ba4:	0047a783          	lw	a5,4(a5)
		data_length += buf->len;
40013ba8:	00e50533          	add	a0,a0,a4
		buf = buf->frags;
40013bac:	fedff06f          	j	40013b98 <net_pkt_remaining_data+0x30>
		return 0;
40013bb0:	00000513          	li	a0,0
	}

	return data_length;
}
40013bb4:	00008067          	ret

40013bb8 <net_pkt_update_length>:

int net_pkt_update_length(struct net_pkt *pkt, size_t length)
{
	struct net_buf *buf;

	for (buf = pkt->buffer; buf; buf = buf->frags) {
40013bb8:	00852783          	lw	a5,8(a0)
40013bbc:	00079a63          	bnez	a5,40013bd0 <net_pkt_update_length+0x18>
			buf->len = length;
			length = 0;
		}
	}

	return !length ? 0 : -EINVAL;
40013bc0:	fea00513          	li	a0,-22
40013bc4:	00059463          	bnez	a1,40013bcc <net_pkt_update_length+0x14>
40013bc8:	00000513          	li	a0,0
}
40013bcc:	00008067          	ret
		if (buf->len < length) {
40013bd0:	0107d703          	lhu	a4,16(a5)
40013bd4:	00b77863          	bgeu	a4,a1,40013be4 <net_pkt_update_length+0x2c>
			length -= buf->len;
40013bd8:	40e585b3          	sub	a1,a1,a4
	for (buf = pkt->buffer; buf; buf = buf->frags) {
40013bdc:	0047a783          	lw	a5,4(a5)
40013be0:	fddff06f          	j	40013bbc <net_pkt_update_length+0x4>
			buf->len = length;
40013be4:	00b79823          	sh	a1,16(a5)
			length = 0;
40013be8:	00000593          	li	a1,0
40013bec:	ff1ff06f          	j	40013bdc <net_pkt_update_length+0x24>

40013bf0 <net_pkt_pull>:

int net_pkt_pull(struct net_pkt *pkt, size_t length)
{
40013bf0:	ff010113          	addi	sp,sp,-16
40013bf4:	00812423          	sw	s0,8(sp)
40013bf8:	00912223          	sw	s1,4(sp)
40013bfc:	00112623          	sw	ra,12(sp)
40013c00:	01212023          	sw	s2,0(sp)
40013c04:	00050413          	mv	s0,a0
40013c08:	00058493          	mv	s1,a1
	struct net_pkt_cursor *c_op = &pkt->cursor;

	while (length) {
40013c0c:	02049863          	bnez	s1,40013c3c <net_pkt_pull+0x4c>
		}

		length -= rem;
	}

	net_pkt_cursor_init(pkt);
40013c10:	00040513          	mv	a0,s0
40013c14:	ddcff0ef          	jal	ra,400131f0 <net_pkt_cursor_init>

	if (length) {
		NET_DBG("Still some length to go %zu", length);
		return -ENOBUFS;
40013c18:	f9700513          	li	a0,-105
	if (length) {
40013c1c:	00049463          	bnez	s1,40013c24 <net_pkt_pull+0x34>
	}

	return 0;
40013c20:	00000513          	li	a0,0
}
40013c24:	00c12083          	lw	ra,12(sp)
40013c28:	00812403          	lw	s0,8(sp)
40013c2c:	00412483          	lw	s1,4(sp)
40013c30:	00012903          	lw	s2,0(sp)
40013c34:	01010113          	addi	sp,sp,16
40013c38:	00008067          	ret
		pkt_cursor_advance(pkt, false);
40013c3c:	00000593          	li	a1,0
40013c40:	00040513          	mv	a0,s0
40013c44:	e31fe0ef          	jal	ra,40012a74 <pkt_cursor_advance>
		if (!c_op->buf) {
40013c48:	00c42683          	lw	a3,12(s0)
40013c4c:	fc0682e3          	beqz	a3,40013c10 <net_pkt_pull+0x20>
		left = c_op->buf->len - (c_op->pos - c_op->buf->data);
40013c50:	00c6a703          	lw	a4,12(a3)
40013c54:	01042603          	lw	a2,16(s0)
40013c58:	0106d783          	lhu	a5,16(a3)
40013c5c:	40e60633          	sub	a2,a2,a4
40013c60:	40c78733          	sub	a4,a5,a2
		if (!left) {
40013c64:	fac786e3          	beq	a5,a2,40013c10 <net_pkt_pull+0x20>
		if (rem > length) {
40013c68:	00070913          	mv	s2,a4
40013c6c:	00e4f463          	bgeu	s1,a4,40013c74 <net_pkt_pull+0x84>
40013c70:	00048913          	mv	s2,s1
		c_op->buf->len -= rem;
40013c74:	412787b3          	sub	a5,a5,s2
40013c78:	00f69823          	sh	a5,16(a3)
		left -= rem;
40013c7c:	41270633          	sub	a2,a4,s2
		if (left) {
40013c80:	01270c63          	beq	a4,s2,40013c98 <net_pkt_pull+0xa8>
			memmove(c_op->pos, c_op->pos+rem, left);
40013c84:	01042503          	lw	a0,16(s0)
40013c88:	012505b3          	add	a1,a0,s2
40013c8c:	b78f50ef          	jal	ra,40009004 <memmove>
		length -= rem;
40013c90:	412484b3          	sub	s1,s1,s2
40013c94:	f79ff06f          	j	40013c0c <net_pkt_pull+0x1c>
			struct net_buf *buf = pkt->buffer;
40013c98:	00842503          	lw	a0,8(s0)
			if (buf) {
40013c9c:	00050a63          	beqz	a0,40013cb0 <net_pkt_pull+0xc0>
				pkt->buffer = buf->frags;
40013ca0:	00452783          	lw	a5,4(a0)
40013ca4:	00f42423          	sw	a5,8(s0)
				buf->frags = NULL;
40013ca8:	00052223          	sw	zero,4(a0)
				net_buf_unref(buf);
40013cac:	c65f50ef          	jal	ra,40009910 <net_buf_unref>
			net_pkt_cursor_init(pkt);
40013cb0:	00040513          	mv	a0,s0
40013cb4:	d3cff0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
40013cb8:	fd9ff06f          	j	40013c90 <net_pkt_pull+0xa0>

40013cbc <net_pkt_get_current_offset>:
uint16_t net_pkt_get_current_offset(struct net_pkt *pkt)
{
	struct net_buf *buf = pkt->buffer;
	uint16_t offset;

	if (!pkt->cursor.buf || !pkt->cursor.pos) {
40013cbc:	00c52683          	lw	a3,12(a0)
{
40013cc0:	00050793          	mv	a5,a0
	if (!pkt->cursor.buf || !pkt->cursor.pos) {
40013cc4:	04068463          	beqz	a3,40013d0c <net_pkt_get_current_offset+0x50>
40013cc8:	01052703          	lw	a4,16(a0)
		return 0;
40013ccc:	00000513          	li	a0,0
	if (!pkt->cursor.buf || !pkt->cursor.pos) {
40013cd0:	04070063          	beqz	a4,40013d10 <net_pkt_get_current_offset+0x54>
	struct net_buf *buf = pkt->buffer;
40013cd4:	0087a783          	lw	a5,8(a5)
	}

	offset = 0U;

	while (buf != pkt->cursor.buf) {
40013cd8:	00f69e63          	bne	a3,a5,40013cf4 <net_pkt_get_current_offset+0x38>
		offset += buf->len;
		buf = buf->frags;
	}

	offset += pkt->cursor.pos - buf->data;
40013cdc:	00c6a783          	lw	a5,12(a3)
40013ce0:	40f70733          	sub	a4,a4,a5
40013ce4:	00e50533          	add	a0,a0,a4
40013ce8:	01051513          	slli	a0,a0,0x10
40013cec:	01055513          	srli	a0,a0,0x10

	return offset;
40013cf0:	00008067          	ret
		offset += buf->len;
40013cf4:	0107d603          	lhu	a2,16(a5)
		buf = buf->frags;
40013cf8:	0047a783          	lw	a5,4(a5)
		offset += buf->len;
40013cfc:	00c50533          	add	a0,a0,a2
40013d00:	01051513          	slli	a0,a0,0x10
40013d04:	01055513          	srli	a0,a0,0x10
		buf = buf->frags;
40013d08:	fd1ff06f          	j	40013cd8 <net_pkt_get_current_offset+0x1c>
		return 0;
40013d0c:	00000513          	li	a0,0
}
40013d10:	00008067          	ret

40013d14 <net_pkt_clone_internal>:
{
40013d14:	fd010113          	addi	sp,sp,-48
40013d18:	02112623          	sw	ra,44(sp)
40013d1c:	02812423          	sw	s0,40(sp)
40013d20:	02912223          	sw	s1,36(sp)
40013d24:	00050413          	mv	s0,a0
40013d28:	03212023          	sw	s2,32(sp)
40013d2c:	01312e23          	sw	s3,28(sp)
40013d30:	00058493          	mv	s1,a1
40013d34:	00c12623          	sw	a2,12(sp)
40013d38:	00d12423          	sw	a3,8(sp)
40013d3c:	01412c23          	sw	s4,24(sp)
40013d40:	01512a23          	sw	s5,20(sp)
	size_t cursor_offset = net_pkt_get_current_offset(pkt);
40013d44:	f79ff0ef          	jal	ra,40013cbc <net_pkt_get_current_offset>
	return pkt->iface;
40013d48:	01842583          	lw	a1,24(s0)
40013d4c:	00050993          	mv	s3,a0
	clone_pkt = pkt_alloc_with_buffer(slab, net_pkt_iface(pkt),
40013d50:	00842503          	lw	a0,8(s0)
40013d54:	00b12223          	sw	a1,4(sp)
	return pkt->overwrite;
40013d58:	03744903          	lbu	s2,55(s0)
40013d5c:	ea9fe0ef          	jal	ra,40012c04 <net_pkt_get_len.isra.0>
40013d60:	00c12783          	lw	a5,12(sp)
40013d64:	00812803          	lw	a6,8(sp)
40013d68:	00412583          	lw	a1,4(sp)
40013d6c:	00050613          	mv	a2,a0
40013d70:	00000713          	li	a4,0
40013d74:	00000693          	li	a3,0
40013d78:	00048513          	mv	a0,s1
40013d7c:	885ff0ef          	jal	ra,40013600 <pkt_alloc_with_buffer>
	if (!clone_pkt) {
40013d80:	06050463          	beqz	a0,40013de8 <net_pkt_clone_internal+0xd4>
	pkt->overwrite = overwrite;
40013d84:	03744783          	lbu	a5,55(s0)
40013d88:	00050493          	mv	s1,a0
	net_pkt_cursor_init(pkt);
40013d8c:	00040513          	mv	a0,s0
40013d90:	0017e793          	ori	a5,a5,1
40013d94:	02f40ba3          	sb	a5,55(s0)
	backup->buf = pkt->cursor.buf;
40013d98:	00c42a83          	lw	s5,12(s0)
	backup->pos = pkt->cursor.pos;
40013d9c:	01042a03          	lw	s4,16(s0)
40013da0:	c50ff0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	if (net_pkt_copy(clone_pkt, pkt, net_pkt_get_len(pkt))) {
40013da4:	00842503          	lw	a0,8(s0)
40013da8:	00197913          	andi	s2,s2,1
40013dac:	00197913          	andi	s2,s2,1
40013db0:	e55fe0ef          	jal	ra,40012c04 <net_pkt_get_len.isra.0>
40013db4:	00050613          	mv	a2,a0
40013db8:	00040593          	mv	a1,s0
40013dbc:	00048513          	mv	a0,s1
40013dc0:	c71ff0ef          	jal	ra,40013a30 <net_pkt_copy>
40013dc4:	04050863          	beqz	a0,40013e14 <net_pkt_clone_internal+0x100>
		net_pkt_unref(clone_pkt);
40013dc8:	00048513          	mv	a0,s1
40013dcc:	950ff0ef          	jal	ra,40012f1c <net_pkt_unref>
	pkt->overwrite = overwrite;
40013dd0:	03744783          	lbu	a5,55(s0)
	pkt->cursor.buf = backup->buf;
40013dd4:	01542623          	sw	s5,12(s0)
	pkt->cursor.pos = backup->pos;
40013dd8:	01442823          	sw	s4,16(s0)
	pkt->overwrite = overwrite;
40013ddc:	ffe7f793          	andi	a5,a5,-2
40013de0:	0127e7b3          	or	a5,a5,s2
40013de4:	02f40ba3          	sb	a5,55(s0)
		return NULL;
40013de8:	00000493          	li	s1,0
}
40013dec:	02c12083          	lw	ra,44(sp)
40013df0:	02812403          	lw	s0,40(sp)
40013df4:	02012903          	lw	s2,32(sp)
40013df8:	01c12983          	lw	s3,28(sp)
40013dfc:	01812a03          	lw	s4,24(sp)
40013e00:	01412a83          	lw	s5,20(sp)
40013e04:	00048513          	mv	a0,s1
40013e08:	02412483          	lw	s1,36(sp)
40013e0c:	03010113          	addi	sp,sp,48
40013e10:	00008067          	ret
40013e14:	0374c783          	lbu	a5,55(s1)
	clone_pkt_attributes(pkt, clone_pkt);
40013e18:	00040513          	mv	a0,s0
40013e1c:	00048593          	mv	a1,s1
40013e20:	0017e793          	ori	a5,a5,1
40013e24:	02f48ba3          	sb	a5,55(s1)
40013e28:	9f1ff0ef          	jal	ra,40013818 <clone_pkt_attributes>
	net_pkt_cursor_init(clone_pkt);
40013e2c:	00048513          	mv	a0,s1
40013e30:	bc0ff0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	if (cursor_offset) {
40013e34:	00098863          	beqz	s3,40013e44 <net_pkt_clone_internal+0x130>
		net_pkt_skip(clone_pkt, cursor_offset);
40013e38:	00098593          	mv	a1,s3
40013e3c:	00048513          	mv	a0,s1
40013e40:	925ff0ef          	jal	ra,40013764 <net_pkt_skip>
40013e44:	0374c783          	lbu	a5,55(s1)
40013e48:	ffe7f793          	andi	a5,a5,-2
40013e4c:	0127e7b3          	or	a5,a5,s2
40013e50:	02f48ba3          	sb	a5,55(s1)
40013e54:	03744783          	lbu	a5,55(s0)
	pkt->cursor.buf = backup->buf;
40013e58:	01542623          	sw	s5,12(s0)
	pkt->cursor.pos = backup->pos;
40013e5c:	01442823          	sw	s4,16(s0)
	pkt->overwrite = overwrite;
40013e60:	ffe7f793          	andi	a5,a5,-2
40013e64:	00f96933          	or	s2,s2,a5
40013e68:	03240ba3          	sb	s2,55(s0)
	return clone_pkt;
40013e6c:	f81ff06f          	j	40013dec <net_pkt_clone_internal+0xd8>

40013e70 <net_pkt_clone>:
{
40013e70:	00060693          	mv	a3,a2
40013e74:	00058613          	mv	a2,a1
	return net_pkt_clone_internal(pkt, pkt->slab, timeout);
40013e78:	00452583          	lw	a1,4(a0)
40013e7c:	e99ff06f          	j	40013d14 <net_pkt_clone_internal>

40013e80 <net_pkt_get_contiguous_len>:

	return len >= size;
}

size_t net_pkt_get_contiguous_len(struct net_pkt *pkt)
{
40013e80:	ff010113          	addi	sp,sp,-16
40013e84:	00812423          	sw	s0,8(sp)
40013e88:	00112623          	sw	ra,12(sp)
	return pkt->overwrite;
40013e8c:	03754583          	lbu	a1,55(a0)
40013e90:	00050413          	mv	s0,a0
40013e94:	0015f593          	andi	a1,a1,1
	pkt_cursor_advance(pkt, !net_pkt_is_being_overwritten(pkt));
40013e98:	0015c593          	xori	a1,a1,1
40013e9c:	bd9fe0ef          	jal	ra,40012a74 <pkt_cursor_advance>

	if (pkt->cursor.buf && pkt->cursor.pos) {
40013ea0:	00c42703          	lw	a4,12(s0)
			pkt->cursor.buf->len : pkt->cursor.buf->size;
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
		return len;
	}

	return 0;
40013ea4:	00000513          	li	a0,0
	if (pkt->cursor.buf && pkt->cursor.pos) {
40013ea8:	02070663          	beqz	a4,40013ed4 <net_pkt_get_contiguous_len+0x54>
40013eac:	01042783          	lw	a5,16(s0)
	return 0;
40013eb0:	00000513          	li	a0,0
	if (pkt->cursor.buf && pkt->cursor.pos) {
40013eb4:	02078063          	beqz	a5,40013ed4 <net_pkt_get_contiguous_len+0x54>
40013eb8:	03744683          	lbu	a3,55(s0)
			pkt->cursor.buf->len : pkt->cursor.buf->size;
40013ebc:	0016f693          	andi	a3,a3,1
40013ec0:	02068263          	beqz	a3,40013ee4 <net_pkt_get_contiguous_len+0x64>
40013ec4:	01075503          	lhu	a0,16(a4)
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
40013ec8:	00c72703          	lw	a4,12(a4)
40013ecc:	40e787b3          	sub	a5,a5,a4
40013ed0:	40f50533          	sub	a0,a0,a5
}
40013ed4:	00c12083          	lw	ra,12(sp)
40013ed8:	00812403          	lw	s0,8(sp)
40013edc:	01010113          	addi	sp,sp,16
40013ee0:	00008067          	ret
			pkt->cursor.buf->len : pkt->cursor.buf->size;
40013ee4:	01275503          	lhu	a0,18(a4)
40013ee8:	fe1ff06f          	j	40013ec8 <net_pkt_get_contiguous_len+0x48>

40013eec <net_pkt_is_contiguous>:
{
40013eec:	ff010113          	addi	sp,sp,-16
40013ef0:	00812423          	sw	s0,8(sp)
40013ef4:	00112623          	sw	ra,12(sp)
40013ef8:	00058413          	mv	s0,a1
	size_t len = net_pkt_get_contiguous_len(pkt);
40013efc:	f85ff0ef          	jal	ra,40013e80 <net_pkt_get_contiguous_len>
}
40013f00:	00c12083          	lw	ra,12(sp)
	return len >= size;
40013f04:	00853533          	sltu	a0,a0,s0
}
40013f08:	00812403          	lw	s0,8(sp)
40013f0c:	00154513          	xori	a0,a0,1
40013f10:	01010113          	addi	sp,sp,16
40013f14:	00008067          	ret

40013f18 <net_pkt_write>:
{
40013f18:	fe010113          	addi	sp,sp,-32
40013f1c:	00812c23          	sw	s0,24(sp)
40013f20:	00112e23          	sw	ra,28(sp)
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
40013f24:	01052783          	lw	a5,16(a0)
{
40013f28:	00050413          	mv	s0,a0
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
40013f2c:	02f59a63          	bne	a1,a5,40013f60 <net_pkt_write+0x48>
40013f30:	00c12623          	sw	a2,12(sp)
40013f34:	00b12423          	sw	a1,8(sp)
	size_t len = net_pkt_get_contiguous_len(pkt);
40013f38:	f49ff0ef          	jal	ra,40013e80 <net_pkt_get_contiguous_len>
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
40013f3c:	00c12603          	lw	a2,12(sp)
40013f40:	00812583          	lw	a1,8(sp)
40013f44:	00c56e63          	bltu	a0,a2,40013f60 <net_pkt_write+0x48>
		return net_pkt_skip(pkt, length);
40013f48:	00040513          	mv	a0,s0
}
40013f4c:	01812403          	lw	s0,24(sp)
40013f50:	01c12083          	lw	ra,28(sp)
		return net_pkt_skip(pkt, length);
40013f54:	00060593          	mv	a1,a2
}
40013f58:	02010113          	addi	sp,sp,32
		return net_pkt_skip(pkt, length);
40013f5c:	809ff06f          	j	40013764 <net_pkt_skip>
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
40013f60:	00040513          	mv	a0,s0
}
40013f64:	01812403          	lw	s0,24(sp)
40013f68:	01c12083          	lw	ra,28(sp)
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
40013f6c:	00100713          	li	a4,1
40013f70:	00100693          	li	a3,1
}
40013f74:	02010113          	addi	sp,sp,32
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
40013f78:	cadfe06f          	j	40012c24 <net_pkt_cursor_operate>

40013f7c <net_pkt_get_data>:

void *net_pkt_get_data(struct net_pkt *pkt,
		       struct net_pkt_data_access *access)
{
40013f7c:	fe010113          	addi	sp,sp,-32
40013f80:	00812c23          	sw	s0,24(sp)
40013f84:	00912a23          	sw	s1,20(sp)
40013f88:	00112e23          	sw	ra,28(sp)
40013f8c:	01212823          	sw	s2,16(sp)
40013f90:	01312623          	sw	s3,12(sp)
			return NULL;
		}

		return pkt->cursor.pos;
	} else {
		if (net_pkt_is_contiguous(pkt, access->size)) {
40013f94:	0045a903          	lw	s2,4(a1)
{
40013f98:	00050413          	mv	s0,a0
40013f9c:	00058493          	mv	s1,a1
	size_t len = net_pkt_get_contiguous_len(pkt);
40013fa0:	ee1ff0ef          	jal	ra,40013e80 <net_pkt_get_contiguous_len>
		if (net_pkt_is_contiguous(pkt, access->size)) {
40013fa4:	01256a63          	bltu	a0,s2,40013fb8 <net_pkt_get_data+0x3c>
			access->data = pkt->cursor.pos;
40013fa8:	01042783          	lw	a5,16(s0)
40013fac:	00f4a023          	sw	a5,0(s1)
			}

			net_pkt_cursor_restore(pkt, &backup);
		}

		return access->data;
40013fb0:	0004a503          	lw	a0,0(s1)
40013fb4:	03c0006f          	j	40013ff0 <net_pkt_get_data+0x74>
40013fb8:	03744783          	lbu	a5,55(s0)
			if (!access->data) {
40013fbc:	0004a583          	lw	a1,0(s1)
		} else if (net_pkt_is_being_overwritten(pkt)) {
40013fc0:	0017f793          	andi	a5,a5,1
40013fc4:	fe0786e3          	beqz	a5,40013fb0 <net_pkt_get_data+0x34>
			if (!access->data) {
40013fc8:	02058263          	beqz	a1,40013fec <net_pkt_get_data+0x70>
	backup->buf = pkt->cursor.buf;
40013fcc:	00c42983          	lw	s3,12(s0)
	backup->pos = pkt->cursor.pos;
40013fd0:	01042903          	lw	s2,16(s0)
			if (net_pkt_read(pkt, access->data, access->size)) {
40013fd4:	0044a603          	lw	a2,4(s1)
40013fd8:	00040513          	mv	a0,s0
40013fdc:	9f1ff0ef          	jal	ra,400139cc <net_pkt_read>
	pkt->cursor.buf = backup->buf;
40013fe0:	01342623          	sw	s3,12(s0)
	pkt->cursor.pos = backup->pos;
40013fe4:	01242823          	sw	s2,16(s0)
40013fe8:	fc0504e3          	beqz	a0,40013fb0 <net_pkt_get_data+0x34>
{
40013fec:	00000513          	li	a0,0
	}

	return NULL;
}
40013ff0:	01c12083          	lw	ra,28(sp)
40013ff4:	01812403          	lw	s0,24(sp)
40013ff8:	01412483          	lw	s1,20(sp)
40013ffc:	01012903          	lw	s2,16(sp)
40014000:	00c12983          	lw	s3,12(sp)
40014004:	02010113          	addi	sp,sp,32
40014008:	00008067          	ret

4001400c <net_pkt_set_data>:
{
	if (IS_ENABLED(CONFIG_NET_HEADERS_ALWAYS_CONTIGUOUS)) {
		return net_pkt_skip(pkt, access->size);
	}

	return net_pkt_write(pkt, access->data, access->size);
4001400c:	0045a603          	lw	a2,4(a1)
40014010:	0005a583          	lw	a1,0(a1)
40014014:	f05ff06f          	j	40013f18 <net_pkt_write>

40014018 <net_pkt_init>:
		(size_t)(k_mem_slab_num_free_get(&tx_pkts) *
			 sizeof(struct net_pkt)),
		get_frees(&rx_bufs), get_size(&rx_bufs),
		get_frees(&tx_bufs), get_size(&tx_bufs));
#endif
}
40014018:	00008067          	ret

4001401c <tc_rx_handler>:
#endif
#endif

#if NET_TC_RX_COUNT > 0
static void tc_rx_handler(struct k_fifo *fifo)
{
4001401c:	ff010113          	addi	sp,sp,-16
40014020:	00812423          	sw	s0,8(sp)
40014024:	00112623          	sw	ra,12(sp)
40014028:	00050413          	mv	s0,a0
	return z_impl_k_queue_get(queue, timeout);
4001402c:	fff00593          	li	a1,-1
40014030:	fff00613          	li	a2,-1
40014034:	00040513          	mv	a0,s0
40014038:	435140ef          	jal	ra,40028c6c <z_impl_k_queue_get>
	struct net_pkt *pkt;

	while (1) {
		pkt = k_fifo_get(fifo, K_FOREVER);
		if (pkt == NULL) {
4001403c:	fe0508e3          	beqz	a0,4001402c <tc_rx_handler+0x10>
			continue;
		}

		net_process_rx_packet(pkt);
40014040:	a15f70ef          	jal	ra,4000ba54 <net_process_rx_packet>
40014044:	fe9ff06f          	j	4001402c <tc_rx_handler+0x10>

40014048 <net_tc_submit_to_rx_queue>:
	k_fifo_put(queue, pkt);
40014048:	0e800793          	li	a5,232
4001404c:	02f50533          	mul	a0,a0,a5
40014050:	400317b7          	lui	a5,0x40031
40014054:	f9078793          	addi	a5,a5,-112 # 40030f90 <rx_classes>
40014058:	00a78533          	add	a0,a5,a0
4001405c:	3e91406f          	j	40028c44 <k_queue_append>

40014060 <net_tx_priority2tc>:
}
40014060:	00000513          	li	a0,0
40014064:	00008067          	ret

40014068 <net_rx_priority2tc>:
	if (prio > NET_PRIORITY_NC) {
40014068:	00700793          	li	a5,7
4001406c:	00a7f463          	bgeu	a5,a0,40014074 <net_rx_priority2tc+0xc>
		prio = NET_PRIORITY_BE;
40014070:	00000513          	li	a0,0
	return rx_prio2tc_map[prio];
40014074:	4002c7b7          	lui	a5,0x4002c
40014078:	b6078793          	addi	a5,a5,-1184 # 4002bb60 <priority2tc_strict_1>
4001407c:	00f50533          	add	a0,a0,a5
}
40014080:	00054503          	lbu	a0,0(a0)
40014084:	00008067          	ret

40014088 <net_tc_tx_init>:
		}

		k_thread_start(tid);
	}
#endif
}
40014088:	00008067          	ret

4001408c <net_tc_rx_init>:

void net_tc_rx_init(void)
{
4001408c:	fd010113          	addi	sp,sp,-48
40014090:	02112623          	sw	ra,44(sp)
40014094:	02812423          	sw	s0,40(sp)
	z_impl_k_queue_init(queue);
40014098:	40031437          	lui	s0,0x40031
4001409c:	f9040513          	addi	a0,s0,-112 # 40030f90 <rx_classes>
400140a0:	381140ef          	jal	ra,40028c20 <z_impl_k_queue_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
400140a4:	fff00713          	li	a4,-1
400140a8:	fff00793          	li	a5,-1
400140ac:	400146b7          	lui	a3,0x40014
400140b0:	400345b7          	lui	a1,0x40034
400140b4:	40031537          	lui	a0,0x40031
400140b8:	00e12423          	sw	a4,8(sp)
400140bc:	00f12623          	sw	a5,12(sp)
400140c0:	00012023          	sw	zero,0(sp)
400140c4:	fff00893          	li	a7,-1
400140c8:	00000813          	li	a6,0
400140cc:	00000793          	li	a5,0
400140d0:	f9040713          	addi	a4,s0,-112
400140d4:	01c68693          	addi	a3,a3,28 # 4001401c <tc_rx_handler>
400140d8:	5e000613          	li	a2,1504
400140dc:	b9058593          	addi	a1,a1,-1136 # 40033b90 <rx_stack>
400140e0:	fa850513          	addi	a0,a0,-88 # 40030fa8 <rx_classes+0x18>
400140e4:	30c140ef          	jal	ra,400283f0 <z_impl_k_thread_create>
		tid = k_thread_create(&rx_classes[i].handler, rx_stack[i],
				      K_KERNEL_STACK_SIZEOF(rx_stack[i]),
				      (k_thread_entry_t)tc_rx_handler,
				      &rx_classes[i].fifo, NULL, NULL,
				      priority, 0, K_FOREVER);
		if (!tid) {
400140e8:	04050063          	beqz	a0,40014128 <net_tc_rx_init+0x9c>
		}

		if (IS_ENABLED(CONFIG_THREAD_NAME)) {
			char name[MAX_NAME_LEN];

			snprintk(name, sizeof(name), "rx_q[%d]", i);
400140ec:	4002d637          	lui	a2,0x4002d
400140f0:	00050413          	mv	s0,a0
400140f4:	00000693          	li	a3,0
400140f8:	38460613          	addi	a2,a2,900 # 4002d384 <in6addr_any+0x50>
400140fc:	00800593          	li	a1,8
40014100:	01810513          	addi	a0,sp,24
40014104:	ec5ec0ef          	jal	ra,40000fc8 <snprintk>
	return z_impl_k_thread_name_set(thread, str);
40014108:	01810593          	addi	a1,sp,24
4001410c:	00040513          	mv	a0,s0
40014110:	014140ef          	jal	ra,40028124 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
40014114:	00040513          	mv	a0,s0
		}

		k_thread_start(tid);
	}
#endif
}
40014118:	02812403          	lw	s0,40(sp)
4001411c:	02c12083          	lw	ra,44(sp)
40014120:	03010113          	addi	sp,sp,48
40014124:	1781406f          	j	4002829c <z_impl_k_thread_start>
40014128:	02c12083          	lw	ra,44(sp)
4001412c:	02812403          	lw	s0,40(sp)
40014130:	03010113          	addi	sp,sp,48
40014134:	00008067          	ret

40014138 <net_ipv6_is_addr_unspecified>:
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40014138:	00154703          	lbu	a4,1(a0)
4001413c:	00054683          	lbu	a3,0(a0)
{
40014140:	00050793          	mv	a5,a0
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40014144:	00871713          	slli	a4,a4,0x8
40014148:	00d76733          	or	a4,a4,a3
4001414c:	00254683          	lbu	a3,2(a0)
40014150:	01069693          	slli	a3,a3,0x10
40014154:	00e6e6b3          	or	a3,a3,a4
40014158:	00354703          	lbu	a4,3(a0)
4001415c:	01871713          	slli	a4,a4,0x18
40014160:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40014164:	08071863          	bnez	a4,400141f4 <net_ipv6_is_addr_unspecified+0xbc>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
40014168:	00554703          	lbu	a4,5(a0)
4001416c:	00454683          	lbu	a3,4(a0)
40014170:	00871713          	slli	a4,a4,0x8
40014174:	00d76733          	or	a4,a4,a3
40014178:	00654683          	lbu	a3,6(a0)
4001417c:	01069693          	slli	a3,a3,0x10
40014180:	00e6e6b3          	or	a3,a3,a4
40014184:	00754703          	lbu	a4,7(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40014188:	00000513          	li	a0,0
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001418c:	01871713          	slli	a4,a4,0x18
40014190:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40014194:	06071263          	bnez	a4,400141f8 <net_ipv6_is_addr_unspecified+0xc0>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40014198:	0097c703          	lbu	a4,9(a5)
4001419c:	0087c683          	lbu	a3,8(a5)
400141a0:	00871713          	slli	a4,a4,0x8
400141a4:	00d76733          	or	a4,a4,a3
400141a8:	00a7c683          	lbu	a3,10(a5)
400141ac:	01069693          	slli	a3,a3,0x10
400141b0:	00e6e6b3          	or	a3,a3,a4
400141b4:	00b7c703          	lbu	a4,11(a5)
400141b8:	01871713          	slli	a4,a4,0x18
400141bc:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
400141c0:	02071c63          	bnez	a4,400141f8 <net_ipv6_is_addr_unspecified+0xc0>
		UNALIGNED_GET(&addr->s6_addr32[3]) == 0;
400141c4:	00d7c683          	lbu	a3,13(a5)
400141c8:	00c7c703          	lbu	a4,12(a5)
400141cc:	00f7c503          	lbu	a0,15(a5)
400141d0:	00869693          	slli	a3,a3,0x8
400141d4:	00e6e6b3          	or	a3,a3,a4
400141d8:	00e7c703          	lbu	a4,14(a5)
400141dc:	01851513          	slli	a0,a0,0x18
400141e0:	01071713          	slli	a4,a4,0x10
400141e4:	00d76733          	or	a4,a4,a3
400141e8:	00e56533          	or	a0,a0,a4
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
400141ec:	00153513          	seqz	a0,a0
400141f0:	00008067          	ret
400141f4:	00000513          	li	a0,0
}
400141f8:	00008067          	ret

400141fc <conn_addr_cmp>:
	return pkt->family;
400141fc:	03452703          	lw	a4,52(a0)
static bool conn_addr_cmp(struct net_pkt *pkt,
			  union net_ip_header *ip_hdr,
			  struct sockaddr *addr,
			  bool is_remote)
{
	if (addr->sa_family != net_pkt_family(pkt)) {
40014200:	00065783          	lhu	a5,0(a2)
40014204:	01d75713          	srli	a4,a4,0x1d
40014208:	0ae79e63          	bne	a5,a4,400142c4 <conn_addr_cmp+0xc8>
		return false;
	}

	if (IS_ENABLED(CONFIG_NET_IPV6) &&
4001420c:	00200713          	li	a4,2
40014210:	04e79c63          	bne	a5,a4,40014268 <conn_addr_cmp+0x6c>
{
40014214:	fe010113          	addi	sp,sp,-32
40014218:	00112e23          	sw	ra,28(sp)
4001421c:	00812c23          	sw	s0,24(sp)
	    net_pkt_family(pkt) == AF_INET6 &&
	    addr->sa_family == AF_INET6) {
		uint8_t *addr6;

		if (is_remote) {
			addr6 = ip_hdr->ipv6->src;
40014220:	0005a783          	lw	a5,0(a1)
		} else {
			addr6 = ip_hdr->ipv6->dst;
40014224:	01878593          	addi	a1,a5,24
		if (is_remote) {
40014228:	00068463          	beqz	a3,40014230 <conn_addr_cmp+0x34>
			addr6 = ip_hdr->ipv6->src;
4001422c:	00878593          	addi	a1,a5,8
		}

		if (!net_ipv6_is_addr_unspecified(
			    &net_sin6(addr)->sin6_addr)) {
40014230:	00460413          	addi	s0,a2,4
		if (!net_ipv6_is_addr_unspecified(
40014234:	00040513          	mv	a0,s0
40014238:	00b12623          	sw	a1,12(sp)
4001423c:	efdff0ef          	jal	ra,40014138 <net_ipv6_is_addr_unspecified>
40014240:	00051c63          	bnez	a0,40014258 <conn_addr_cmp+0x5c>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
40014244:	00c12583          	lw	a1,12(sp)
40014248:	01000613          	li	a2,16
4001424c:	00040513          	mv	a0,s0
40014250:	d7df40ef          	jal	ra,40008fcc <memcmp>
			if (!net_ipv6_addr_cmp_raw((uint8_t *)&net_sin6(addr)->sin6_addr,
40014254:	00153513          	seqz	a0,a0
			}
		}
	}

	return true;
}
40014258:	01c12083          	lw	ra,28(sp)
4001425c:	01812403          	lw	s0,24(sp)
40014260:	02010113          	addi	sp,sp,32
40014264:	00008067          	ret
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40014268:	00100713          	li	a4,1
		return true;
4001426c:	00100513          	li	a0,1
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40014270:	04e79e63          	bne	a5,a4,400142cc <conn_addr_cmp+0xd0>
			addr6 = ip_hdr->ipv6->src;
40014274:	0005a783          	lw	a5,0(a1)
			addr4 = ip_hdr->ipv4->dst;
40014278:	01078713          	addi	a4,a5,16
		if (is_remote) {
4001427c:	00068463          	beqz	a3,40014284 <conn_addr_cmp+0x88>
			addr4 = ip_hdr->ipv4->src;
40014280:	00c78713          	addi	a4,a5,12
		if (net_sin(addr)->sin_addr.s_addr) {
40014284:	00462603          	lw	a2,4(a2)
		return true;
40014288:	00100513          	li	a0,1
		if (net_sin(addr)->sin_addr.s_addr) {
4001428c:	04060063          	beqz	a2,400142cc <conn_addr_cmp+0xd0>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40014290:	00174683          	lbu	a3,1(a4)
40014294:	00074783          	lbu	a5,0(a4)
40014298:	00374503          	lbu	a0,3(a4)
4001429c:	00869693          	slli	a3,a3,0x8
400142a0:	00f6e6b3          	or	a3,a3,a5
400142a4:	00274783          	lbu	a5,2(a4)
400142a8:	01851513          	slli	a0,a0,0x18
400142ac:	01079793          	slli	a5,a5,0x10
400142b0:	00d7e7b3          	or	a5,a5,a3
400142b4:	00f56533          	or	a0,a0,a5
			if (!net_ipv4_addr_cmp_raw((uint8_t *)&net_sin(addr)->sin_addr,
400142b8:	40c50533          	sub	a0,a0,a2
400142bc:	00153513          	seqz	a0,a0
400142c0:	00008067          	ret
		return false;
400142c4:	00000513          	li	a0,0
400142c8:	00008067          	ret
}
400142cc:	00008067          	ret

400142d0 <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
400142d0:	00058613          	mv	a2,a1
400142d4:	00050593          	mv	a1,a0
	return z_impl_k_mutex_lock(mutex, timeout);
400142d8:	4003d537          	lui	a0,0x4003d
400142dc:	a9c50513          	addi	a0,a0,-1380 # 4003ca9c <conn_lock>
400142e0:	59c1406f          	j	4002887c <z_impl_k_mutex_lock>

400142e4 <k_mutex_unlock.constprop.0.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
400142e4:	4003d537          	lui	a0,0x4003d
400142e8:	a9c50513          	addi	a0,a0,-1380 # 4003ca9c <conn_lock>
400142ec:	6ec1406f          	j	400289d8 <z_impl_k_mutex_unlock>

400142f0 <conn_set_unused>:
{
400142f0:	ff010113          	addi	sp,sp,-16
	(void)memset(conn, 0, sizeof(*conn));
400142f4:	04400613          	li	a2,68
400142f8:	00000593          	li	a1,0
{
400142fc:	00112623          	sw	ra,12(sp)
40014300:	00812423          	sw	s0,8(sp)
40014304:	00050413          	mv	s0,a0
	(void)memset(conn, 0, sizeof(*conn));
40014308:	d69f40ef          	jal	ra,40009070 <memset>
	k_mutex_lock(&conn_lock, K_FOREVER);
4001430c:	fff00513          	li	a0,-1
40014310:	fff00593          	li	a1,-1
40014314:	fbdff0ef          	jal	ra,400142d0 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
40014318:	400317b7          	lui	a5,0x40031
4001431c:	a9078793          	addi	a5,a5,-1392 # 40030a90 <conn_unused>
40014320:	0007a703          	lw	a4,0(a5)
	parent->next = child;
40014324:	00e42023          	sw	a4,0(s0)
Z_GENLIST_PREPEND(slist, snode)
40014328:	0047a703          	lw	a4,4(a5)
	list->head = node;
4001432c:	0087a023          	sw	s0,0(a5)
Z_GENLIST_PREPEND(slist, snode)
40014330:	00071463          	bnez	a4,40014338 <conn_set_unused+0x48>
	list->tail = node;
40014334:	0087a223          	sw	s0,4(a5)
}
40014338:	00812403          	lw	s0,8(sp)
4001433c:	00c12083          	lw	ra,12(sp)
40014340:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&conn_lock);
40014344:	fa1ff06f          	j	400142e4 <k_mutex_unlock.constprop.0.isra.0>

40014348 <net_conn_register>:
{
40014348:	fb010113          	addi	sp,sp,-80
4001434c:	03512a23          	sw	s5,52(sp)
40014350:	03612823          	sw	s6,48(sp)
40014354:	03712623          	sw	s7,44(sp)
	return list->head;
40014358:	40031ab7          	lui	s5,0x40031
4001435c:	00050b93          	mv	s7,a0
40014360:	00058b13          	mv	s6,a1
	k_mutex_lock(&conn_lock, K_FOREVER);
40014364:	fff00513          	li	a0,-1
40014368:	fff00593          	li	a1,-1
{
4001436c:	04912223          	sw	s1,68(sp)
40014370:	05212023          	sw	s2,64(sp)
40014374:	03312e23          	sw	s3,60(sp)
40014378:	03412c23          	sw	s4,56(sp)
4001437c:	03912223          	sw	s9,36(sp)
40014380:	03a12023          	sw	s10,32(sp)
40014384:	04112623          	sw	ra,76(sp)
40014388:	04812423          	sw	s0,72(sp)
4001438c:	03812423          	sw	s8,40(sp)
40014390:	01b12e23          	sw	s11,28(sp)
40014394:	00060493          	mv	s1,a2
40014398:	00068913          	mv	s2,a3
4001439c:	00070a13          	mv	s4,a4
400143a0:	00078993          	mv	s3,a5
400143a4:	01012623          	sw	a6,12(sp)
400143a8:	00088c93          	mv	s9,a7
	k_mutex_lock(&conn_lock, K_FOREVER);
400143ac:	f25ff0ef          	jal	ra,400142d0 <k_mutex_lock.constprop.0.isra.0>
400143b0:	a88aad03          	lw	s10,-1400(s5) # 40030a88 <conn_used>
400143b4:	a88a8a93          	addi	s5,s5,-1400
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {
400143b8:	000d0a63          	beqz	s10,400143cc <net_conn_register+0x84>
	return node->next;
400143bc:	000d2c03          	lw	s8,0(s10)
			if (IS_ENABLED(CONFIG_NET_IPV6) &&
400143c0:	00200413          	li	s0,2
			} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
400143c4:	00100d93          	li	s11,1
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {
400143c8:	020d1863          	bnez	s10,400143f8 <net_conn_register+0xb0>
	k_mutex_unlock(&conn_lock);
400143cc:	f19ff0ef          	jal	ra,400142e4 <k_mutex_unlock.constprop.0.isra.0>
	k_mutex_lock(&conn_lock, K_FOREVER);
400143d0:	fff00513          	li	a0,-1
400143d4:	fff00593          	li	a1,-1
400143d8:	ef9ff0ef          	jal	ra,400142d0 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
400143dc:	400317b7          	lui	a5,0x40031
400143e0:	a9078793          	addi	a5,a5,-1392 # 40030a90 <conn_unused>
400143e4:	0007ad83          	lw	s11,0(a5)
	if (!node) {
400143e8:	1e0d9c63          	bnez	s11,400145e0 <net_conn_register+0x298>
		k_mutex_unlock(&conn_lock);
400143ec:	ef9ff0ef          	jal	ra,400142e4 <k_mutex_unlock.constprop.0.isra.0>
		return -ENOENT;
400143f0:	ffe00513          	li	a0,-2
400143f4:	1480006f          	j	4001453c <net_conn_register+0x1f4>
		if (conn->proto != proto) {
400143f8:	040d5703          	lhu	a4,64(s10)
400143fc:	0b771a63          	bne	a4,s7,400144b0 <net_conn_register+0x168>
		if (conn->family != family) {
40014400:	042d4703          	lbu	a4,66(s10)
40014404:	0b671663          	bne	a4,s6,400144b0 <net_conn_register+0x168>
		if (remote_addr) {
40014408:	043d4703          	lbu	a4,67(s10)
4001440c:	00277713          	andi	a4,a4,2
40014410:	0a048c63          	beqz	s1,400144c8 <net_conn_register+0x180>
			if (!(conn->flags & NET_CONN_REMOTE_ADDR_SET)) {
40014414:	08070e63          	beqz	a4,400144b0 <net_conn_register+0x168>
			    remote_addr->sa_family == AF_INET6 &&
40014418:	0004d703          	lhu	a4,0(s1)
			if (IS_ENABLED(CONFIG_NET_IPV6) &&
4001441c:	02871a63          	bne	a4,s0,40014450 <net_conn_register+0x108>
			    remote_addr->sa_family == AF_INET6 &&
40014420:	004d5703          	lhu	a4,4(s10)
40014424:	08871663          	bne	a4,s0,400144b0 <net_conn_register+0x168>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
40014428:	01000613          	li	a2,16
4001442c:	008d0593          	addi	a1,s10,8
40014430:	00448513          	addi	a0,s1,4
40014434:	b99f40ef          	jal	ra,40008fcc <memcmp>
				if (!net_ipv6_addr_cmp(
40014438:	06051c63          	bnez	a0,400144b0 <net_conn_register+0x168>
		if (local_addr) {
4001443c:	043d4703          	lbu	a4,67(s10)
40014440:	00477713          	andi	a4,a4,4
40014444:	08091663          	bnez	s2,400144d0 <net_conn_register+0x188>
		} else if (conn->flags & NET_CONN_LOCAL_ADDR_SET) {
40014448:	0a070a63          	beqz	a4,400144fc <net_conn_register+0x1b4>
4001444c:	0640006f          	j	400144b0 <net_conn_register+0x168>
			} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40014450:	07b71063          	bne	a4,s11,400144b0 <net_conn_register+0x168>
				   remote_addr->sa_family == AF_INET &&
40014454:	004d5703          	lhu	a4,4(s10)
40014458:	05b71c63          	bne	a4,s11,400144b0 <net_conn_register+0x168>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4001445c:	0054c603          	lbu	a2,5(s1)
40014460:	0044c703          	lbu	a4,4(s1)
40014464:	008d4583          	lbu	a1,8(s10)
40014468:	00861613          	slli	a2,a2,0x8
4001446c:	00e66633          	or	a2,a2,a4
40014470:	0064c703          	lbu	a4,6(s1)
40014474:	01071713          	slli	a4,a4,0x10
40014478:	00c76733          	or	a4,a4,a2
4001447c:	0074c603          	lbu	a2,7(s1)
40014480:	01861613          	slli	a2,a2,0x18
40014484:	00e66633          	or	a2,a2,a4
40014488:	009d4703          	lbu	a4,9(s10)
4001448c:	00871713          	slli	a4,a4,0x8
40014490:	00b76733          	or	a4,a4,a1
40014494:	00ad4583          	lbu	a1,10(s10)
40014498:	01059593          	slli	a1,a1,0x10
4001449c:	00e5e5b3          	or	a1,a1,a4
400144a0:	00bd4703          	lbu	a4,11(s10)
400144a4:	01871713          	slli	a4,a4,0x18
400144a8:	00b76733          	or	a4,a4,a1
				if (!net_ipv4_addr_cmp(
400144ac:	f8e608e3          	beq	a2,a4,4001443c <net_conn_register+0xf4>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {
400144b0:	00000713          	li	a4,0
400144b4:	000c0463          	beqz	s8,400144bc <net_conn_register+0x174>
	return node->next;
400144b8:	000c2703          	lw	a4,0(s8)
400144bc:	000c0d13          	mv	s10,s8
400144c0:	00070c13          	mv	s8,a4
400144c4:	f05ff06f          	j	400143c8 <net_conn_register+0x80>
		} else if (conn->flags & NET_CONN_REMOTE_ADDR_SET) {
400144c8:	f6070ae3          	beqz	a4,4001443c <net_conn_register+0xf4>
400144cc:	fe5ff06f          	j	400144b0 <net_conn_register+0x168>
			if (!(conn->flags & NET_CONN_LOCAL_ADDR_SET)) {
400144d0:	fe0700e3          	beqz	a4,400144b0 <net_conn_register+0x168>
			    local_addr->sa_family == AF_INET6 &&
400144d4:	00095703          	lhu	a4,0(s2)
			if (IS_ENABLED(CONFIG_NET_IPV6) &&
400144d8:	00200613          	li	a2,2
400144dc:	08c71e63          	bne	a4,a2,40014578 <net_conn_register+0x230>
			    local_addr->sa_family == AF_INET6 &&
400144e0:	01cd5603          	lhu	a2,28(s10)
400144e4:	fce616e3          	bne	a2,a4,400144b0 <net_conn_register+0x168>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
400144e8:	01000613          	li	a2,16
400144ec:	020d0593          	addi	a1,s10,32
400144f0:	00490513          	addi	a0,s2,4
400144f4:	ad9f40ef          	jal	ra,40008fcc <memcmp>
				if (!net_ipv6_addr_cmp(
400144f8:	fa051ce3          	bnez	a0,400144b0 <net_conn_register+0x168>
		if (net_sin(&conn->remote_addr)->sin_port !=
400144fc:	008a5613          	srli	a2,s4,0x8
40014500:	008a1713          	slli	a4,s4,0x8
40014504:	00c76733          	or	a4,a4,a2
40014508:	006d5603          	lhu	a2,6(s10)
4001450c:	01071713          	slli	a4,a4,0x10
40014510:	01075713          	srli	a4,a4,0x10
40014514:	f8e61ee3          	bne	a2,a4,400144b0 <net_conn_register+0x168>
		if (net_sin(&conn->local_addr)->sin_port !=
40014518:	0089d613          	srli	a2,s3,0x8
4001451c:	00899713          	slli	a4,s3,0x8
40014520:	00c76733          	or	a4,a4,a2
40014524:	01ed5603          	lhu	a2,30(s10)
40014528:	01071793          	slli	a5,a4,0x10
4001452c:	0107d793          	srli	a5,a5,0x10
40014530:	f8f610e3          	bne	a2,a5,400144b0 <net_conn_register+0x168>
		k_mutex_unlock(&conn_lock);
40014534:	db1ff0ef          	jal	ra,400142e4 <k_mutex_unlock.constprop.0.isra.0>
		return -EALREADY;
40014538:	f8800513          	li	a0,-120
}
4001453c:	04c12083          	lw	ra,76(sp)
40014540:	04812403          	lw	s0,72(sp)
40014544:	04412483          	lw	s1,68(sp)
40014548:	04012903          	lw	s2,64(sp)
4001454c:	03c12983          	lw	s3,60(sp)
40014550:	03812a03          	lw	s4,56(sp)
40014554:	03412a83          	lw	s5,52(sp)
40014558:	03012b03          	lw	s6,48(sp)
4001455c:	02c12b83          	lw	s7,44(sp)
40014560:	02812c03          	lw	s8,40(sp)
40014564:	02412c83          	lw	s9,36(sp)
40014568:	02012d03          	lw	s10,32(sp)
4001456c:	01c12d83          	lw	s11,28(sp)
40014570:	05010113          	addi	sp,sp,80
40014574:	00008067          	ret
			} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40014578:	00100613          	li	a2,1
4001457c:	f2c71ae3          	bne	a4,a2,400144b0 <net_conn_register+0x168>
				   local_addr->sa_family == AF_INET &&
40014580:	01cd5603          	lhu	a2,28(s10)
40014584:	f2e616e3          	bne	a2,a4,400144b0 <net_conn_register+0x168>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40014588:	00594603          	lbu	a2,5(s2)
4001458c:	00494703          	lbu	a4,4(s2)
40014590:	020d4583          	lbu	a1,32(s10)
40014594:	00861613          	slli	a2,a2,0x8
40014598:	00e66633          	or	a2,a2,a4
4001459c:	00694703          	lbu	a4,6(s2)
400145a0:	01071713          	slli	a4,a4,0x10
400145a4:	00c76733          	or	a4,a4,a2
400145a8:	00794603          	lbu	a2,7(s2)
400145ac:	01861613          	slli	a2,a2,0x18
400145b0:	00e66633          	or	a2,a2,a4
400145b4:	021d4703          	lbu	a4,33(s10)
400145b8:	00871713          	slli	a4,a4,0x8
400145bc:	00b76733          	or	a4,a4,a1
400145c0:	022d4583          	lbu	a1,34(s10)
400145c4:	01059593          	slli	a1,a1,0x10
400145c8:	00e5e5b3          	or	a1,a1,a4
400145cc:	023d4703          	lbu	a4,35(s10)
400145d0:	01871713          	slli	a4,a4,0x18
400145d4:	00b76733          	or	a4,a4,a1
				if (!net_ipv4_addr_cmp(
400145d8:	f2e602e3          	beq	a2,a4,400144fc <net_conn_register+0x1b4>
400145dc:	ed5ff06f          	j	400144b0 <net_conn_register+0x168>
400145e0:	000da703          	lw	a4,0(s11)
Z_GENLIST_REMOVE(slist, snode)
400145e4:	0047a683          	lw	a3,4(a5)
	list->head = node;
400145e8:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_REMOVE(slist, snode)
400145ec:	00dd9463          	bne	s11,a3,400145f4 <net_conn_register+0x2ac>
	list->tail = node;
400145f0:	00e7a223          	sw	a4,4(a5)
	parent->next = child;
400145f4:	000da023          	sw	zero,0(s11)
	k_mutex_unlock(&conn_lock);
400145f8:	cedff0ef          	jal	ra,400142e4 <k_mutex_unlock.constprop.0.isra.0>
	if (remote_addr) {
400145fc:	08048a63          	beqz	s1,40014690 <net_conn_register+0x348>
		    remote_addr->sa_family == AF_INET6) {
40014600:	0004d783          	lhu	a5,0(s1)
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
40014604:	00200713          	li	a4,2
40014608:	06e79063          	bne	a5,a4,40014668 <net_conn_register+0x320>
			memcpy(&conn->remote_addr, remote_addr,
4001460c:	01800613          	li	a2,24
40014610:	00048593          	mv	a1,s1
40014614:	004d8513          	addi	a0,s11,4
40014618:	a35f40ef          	jal	ra,4000904c <memcpy>
			if (!net_ipv6_is_addr_unspecified(
4001461c:	00448513          	addi	a0,s1,4
40014620:	b19ff0ef          	jal	ra,40014138 <net_ipv6_is_addr_unspecified>
40014624:	00154413          	xori	s0,a0,1
40014628:	00541413          	slli	s0,s0,0x5
4001462c:	0ff47413          	zext.b	s0,s0
		flags |= NET_CONN_REMOTE_ADDR_SET;
40014630:	00246413          	ori	s0,s0,2
	if (local_addr) {
40014634:	08090c63          	beqz	s2,400146cc <net_conn_register+0x384>
		    local_addr->sa_family == AF_INET6) {
40014638:	00095783          	lhu	a5,0(s2)
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
4001463c:	00200713          	li	a4,2
40014640:	04e79c63          	bne	a5,a4,40014698 <net_conn_register+0x350>
			memcpy(&conn->local_addr, local_addr,
40014644:	01800613          	li	a2,24
40014648:	00090593          	mv	a1,s2
4001464c:	01cd8513          	addi	a0,s11,28
40014650:	9fdf40ef          	jal	ra,4000904c <memcpy>
			if (!net_ipv6_is_addr_unspecified(
40014654:	00490513          	addi	a0,s2,4
40014658:	ae1ff0ef          	jal	ra,40014138 <net_ipv6_is_addr_unspecified>
4001465c:	04051e63          	bnez	a0,400146b8 <net_conn_register+0x370>
				flags |= NET_CONN_LOCAL_ADDR_SPEC;
40014660:	04046413          	ori	s0,s0,64
40014664:	0540006f          	j	400146b8 <net_conn_register+0x370>
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40014668:	00100713          	li	a4,1
4001466c:	0ee79c63          	bne	a5,a4,40014764 <net_conn_register+0x41c>
			memcpy(&conn->remote_addr, remote_addr,
40014670:	00800613          	li	a2,8
40014674:	00048593          	mv	a1,s1
40014678:	004d8513          	addi	a0,s11,4
4001467c:	9d1f40ef          	jal	ra,4000904c <memcpy>
			if (net_sin(remote_addr)->sin_addr.s_addr) {
40014680:	0044a403          	lw	s0,4(s1)
40014684:	00803433          	snez	s0,s0
40014688:	00541413          	slli	s0,s0,0x5
4001468c:	fa5ff06f          	j	40014630 <net_conn_register+0x2e8>
	uint8_t flags = 0U;
40014690:	00000413          	li	s0,0
40014694:	fa1ff06f          	j	40014634 <net_conn_register+0x2ec>
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40014698:	00100713          	li	a4,1
4001469c:	0ce79463          	bne	a5,a4,40014764 <net_conn_register+0x41c>
			memcpy(&conn->local_addr, local_addr,
400146a0:	00800613          	li	a2,8
400146a4:	00090593          	mv	a1,s2
400146a8:	01cd8513          	addi	a0,s11,28
400146ac:	9a1f40ef          	jal	ra,4000904c <memcpy>
			if (net_sin(local_addr)->sin_addr.s_addr) {
400146b0:	00492783          	lw	a5,4(s2)
400146b4:	fa0796e3          	bnez	a5,40014660 <net_conn_register+0x318>
		flags |= NET_CONN_LOCAL_ADDR_SET;
400146b8:	00446413          	ori	s0,s0,4
	if (remote_addr && local_addr) {
400146bc:	00048863          	beqz	s1,400146cc <net_conn_register+0x384>
		if (remote_addr->sa_family != local_addr->sa_family) {
400146c0:	0004d703          	lhu	a4,0(s1)
400146c4:	00095783          	lhu	a5,0(s2)
400146c8:	08f71e63          	bne	a4,a5,40014764 <net_conn_register+0x41c>
	if (remote_port) {
400146cc:	000a0c63          	beqz	s4,400146e4 <net_conn_register+0x39c>
		net_sin(&conn->remote_addr)->sin_port = htons(remote_port);
400146d0:	008a1793          	slli	a5,s4,0x8
400146d4:	008a5a13          	srli	s4,s4,0x8
400146d8:	0147e7b3          	or	a5,a5,s4
		flags |= NET_CONN_REMOTE_PORT_SPEC;
400146dc:	00846413          	ori	s0,s0,8
		net_sin(&conn->remote_addr)->sin_port = htons(remote_port);
400146e0:	00fd9323          	sh	a5,6(s11)
	if (local_port) {
400146e4:	00098c63          	beqz	s3,400146fc <net_conn_register+0x3b4>
		net_sin(&conn->local_addr)->sin_port = htons(local_port);
400146e8:	00899793          	slli	a5,s3,0x8
400146ec:	0089d993          	srli	s3,s3,0x8
400146f0:	0137e7b3          	or	a5,a5,s3
		flags |= NET_CONN_LOCAL_PORT_SPEC;
400146f4:	01046413          	ori	s0,s0,16
		net_sin(&conn->local_addr)->sin_port = htons(local_port);
400146f8:	00fd9f23          	sh	a5,30(s11)
	conn->user_data = user_data;
400146fc:	05012783          	lw	a5,80(sp)
	conn->cb = cb;
40014700:	039daa23          	sw	s9,52(s11)
	conn->flags = flags;
40014704:	048d81a3          	sb	s0,67(s11)
	conn->user_data = user_data;
40014708:	02fdae23          	sw	a5,60(s11)
	conn->context = context;
4001470c:	00c12783          	lw	a5,12(sp)
	conn->proto = proto;
40014710:	057d9023          	sh	s7,64(s11)
	conn->family = family;
40014714:	056d8123          	sb	s6,66(s11)
	conn->context = context;
40014718:	02fdac23          	sw	a5,56(s11)
	if (handle) {
4001471c:	05412783          	lw	a5,84(sp)
40014720:	00078463          	beqz	a5,40014728 <net_conn_register+0x3e0>
		*handle = (struct net_conn_handle *)conn;
40014724:	01b7a023          	sw	s11,0(a5)
	conn->flags |= NET_CONN_IN_USE;
40014728:	043dc783          	lbu	a5,67(s11)
	k_mutex_lock(&conn_lock, K_FOREVER);
4001472c:	fff00513          	li	a0,-1
40014730:	fff00593          	li	a1,-1
	conn->flags |= NET_CONN_IN_USE;
40014734:	0017e793          	ori	a5,a5,1
40014738:	04fd81a3          	sb	a5,67(s11)
	k_mutex_lock(&conn_lock, K_FOREVER);
4001473c:	b95ff0ef          	jal	ra,400142d0 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
40014740:	000aa783          	lw	a5,0(s5)
	parent->next = child;
40014744:	00fda023          	sw	a5,0(s11)
Z_GENLIST_PREPEND(slist, snode)
40014748:	004aa783          	lw	a5,4(s5)
	list->head = node;
4001474c:	01baa023          	sw	s11,0(s5)
Z_GENLIST_PREPEND(slist, snode)
40014750:	00079463          	bnez	a5,40014758 <net_conn_register+0x410>
	list->tail = node;
40014754:	01baa223          	sw	s11,4(s5)
	k_mutex_unlock(&conn_lock);
40014758:	b8dff0ef          	jal	ra,400142e4 <k_mutex_unlock.constprop.0.isra.0>
	return 0;
4001475c:	00000513          	li	a0,0
}
40014760:	dddff06f          	j	4001453c <net_conn_register+0x1f4>
	conn_set_unused(conn);
40014764:	000d8513          	mv	a0,s11
40014768:	b89ff0ef          	jal	ra,400142f0 <conn_set_unused>
	return -EINVAL;
4001476c:	fea00513          	li	a0,-22
40014770:	dcdff06f          	j	4001453c <net_conn_register+0x1f4>

40014774 <net_conn_unregister>:
	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
40014774:	400327b7          	lui	a5,0x40032
40014778:	39478793          	addi	a5,a5,916 # 40032394 <conns>
4001477c:	0af56a63          	bltu	a0,a5,40014830 <net_conn_unregister+0xbc>
{
40014780:	ff010113          	addi	sp,sp,-16
	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
40014784:	400327b7          	lui	a5,0x40032
{
40014788:	00812423          	sw	s0,8(sp)
4001478c:	00112623          	sw	ra,12(sp)
40014790:	00050413          	mv	s0,a0
	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
40014794:	5b478793          	addi	a5,a5,1460 # 400325b4 <net_neighbor_lladdr>
		return -EINVAL;
40014798:	fea00513          	li	a0,-22
	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
4001479c:	0687e263          	bltu	a5,s0,40014800 <net_conn_unregister+0x8c>
	if (!(conn->flags & NET_CONN_IN_USE)) {
400147a0:	04344783          	lbu	a5,67(s0)
		return -ENOENT;
400147a4:	ffe00513          	li	a0,-2
	if (!(conn->flags & NET_CONN_IN_USE)) {
400147a8:	0017f793          	andi	a5,a5,1
400147ac:	04078a63          	beqz	a5,40014800 <net_conn_unregister+0x8c>
	k_mutex_lock(&conn_lock, K_FOREVER);
400147b0:	fff00513          	li	a0,-1
400147b4:	fff00593          	li	a1,-1
400147b8:	b19ff0ef          	jal	ra,400142d0 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
400147bc:	400317b7          	lui	a5,0x40031
400147c0:	a887a703          	lw	a4,-1400(a5) # 40030a88 <conn_used>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
400147c4:	00000693          	li	a3,0
400147c8:	a8878793          	addi	a5,a5,-1400
400147cc:	02070263          	beqz	a4,400147f0 <net_conn_unregister+0x7c>
400147d0:	04e41a63          	bne	s0,a4,40014824 <net_conn_unregister+0xb0>
	return node->next;
400147d4:	00042703          	lw	a4,0(s0)
Z_GENLIST_REMOVE(slist, snode)
400147d8:	02069c63          	bnez	a3,40014810 <net_conn_unregister+0x9c>
400147dc:	0047a683          	lw	a3,4(a5)
	list->head = node;
400147e0:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_REMOVE(slist, snode)
400147e4:	00d41463          	bne	s0,a3,400147ec <net_conn_unregister+0x78>
	list->tail = node;
400147e8:	00e7a223          	sw	a4,4(a5)
	parent->next = child;
400147ec:	00042023          	sw	zero,0(s0)
	k_mutex_unlock(&conn_lock);
400147f0:	af5ff0ef          	jal	ra,400142e4 <k_mutex_unlock.constprop.0.isra.0>
	conn_set_unused(conn);
400147f4:	00040513          	mv	a0,s0
400147f8:	af9ff0ef          	jal	ra,400142f0 <conn_set_unused>
	return 0;
400147fc:	00000513          	li	a0,0
}
40014800:	00c12083          	lw	ra,12(sp)
40014804:	00812403          	lw	s0,8(sp)
40014808:	01010113          	addi	sp,sp,16
4001480c:	00008067          	ret
40014810:	00e6a023          	sw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
40014814:	0047a703          	lw	a4,4(a5)
40014818:	fce41ae3          	bne	s0,a4,400147ec <net_conn_unregister+0x78>
	list->tail = node;
4001481c:	00d7a223          	sw	a3,4(a5)
}
40014820:	fcdff06f          	j	400147ec <net_conn_unregister+0x78>
	return node->next;
40014824:	00070693          	mv	a3,a4
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40014828:	00072703          	lw	a4,0(a4)
4001482c:	fa1ff06f          	j	400147cc <net_conn_unregister+0x58>
		return -EINVAL;
40014830:	fea00513          	li	a0,-22
}
40014834:	00008067          	ret

40014838 <net_conn_input>:

enum net_verdict net_conn_input(struct net_pkt *pkt,
				union net_ip_header *ip_hdr,
				uint8_t proto,
				union net_proto_header *proto_hdr)
{
40014838:	fb010113          	addi	sp,sp,-80
4001483c:	04112623          	sw	ra,76(sp)
40014840:	04812423          	sw	s0,72(sp)
40014844:	04912223          	sw	s1,68(sp)
40014848:	05212023          	sw	s2,64(sp)
4001484c:	03312e23          	sw	s3,60(sp)
40014850:	03412c23          	sw	s4,56(sp)
40014854:	03512a23          	sw	s5,52(sp)
40014858:	03612823          	sw	s6,48(sp)
4001485c:	03712623          	sw	s7,44(sp)
40014860:	03812423          	sw	s8,40(sp)
40014864:	03912223          	sw	s9,36(sp)
40014868:	03a12023          	sw	s10,32(sp)
4001486c:	01b12e23          	sw	s11,28(sp)
40014870:	03452c03          	lw	s8,52(a0)
	struct net_if *pkt_iface = net_pkt_iface(pkt);
	uint8_t pkt_family = net_pkt_family(pkt);
	uint16_t src_port = 0U, dst_port = 0U;

	if (IS_ENABLED(CONFIG_NET_IP) && (pkt_family == AF_INET || pkt_family == AF_INET6)) {
40014874:	00100713          	li	a4,1
	return pkt->iface;
40014878:	01852a83          	lw	s5,24(a0)
	return pkt->family;
4001487c:	01dc5c13          	srli	s8,s8,0x1d
40014880:	fffc0793          	addi	a5,s8,-1
40014884:	0ff7f793          	zext.b	a5,a5
40014888:	04f77263          	bgeu	a4,a5,400148cc <net_conn_input+0x94>
		if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
			src_port = proto_hdr->udp->src_port;
			dst_port = proto_hdr->udp->dst_port;
		} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
			if (proto_hdr->tcp == NULL) {
				return NET_DROP;
4001488c:	00200513          	li	a0,2

drop:
	net_stats_update_per_proto_drop(pkt_iface, proto);

	return NET_DROP;
}
40014890:	04c12083          	lw	ra,76(sp)
40014894:	04812403          	lw	s0,72(sp)
40014898:	04412483          	lw	s1,68(sp)
4001489c:	04012903          	lw	s2,64(sp)
400148a0:	03c12983          	lw	s3,60(sp)
400148a4:	03812a03          	lw	s4,56(sp)
400148a8:	03412a83          	lw	s5,52(sp)
400148ac:	03012b03          	lw	s6,48(sp)
400148b0:	02c12b83          	lw	s7,44(sp)
400148b4:	02812c03          	lw	s8,40(sp)
400148b8:	02412c83          	lw	s9,36(sp)
400148bc:	02012d03          	lw	s10,32(sp)
400148c0:	01c12d83          	lw	s11,28(sp)
400148c4:	05010113          	addi	sp,sp,80
400148c8:	00008067          	ret
		if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
400148cc:	01100793          	li	a5,17
400148d0:	00050913          	mv	s2,a0
400148d4:	00058993          	mv	s3,a1
400148d8:	00060b13          	mv	s6,a2
400148dc:	00068b93          	mv	s7,a3
400148e0:	10f61663          	bne	a2,a5,400149ec <net_conn_input+0x1b4>
			src_port = proto_hdr->udp->src_port;
400148e4:	0006a783          	lw	a5,0(a3)
			src_port = proto_hdr->tcp->src_port;
400148e8:	0017c483          	lbu	s1,1(a5)
400148ec:	0007c703          	lbu	a4,0(a5)
			dst_port = proto_hdr->tcp->dst_port;
400148f0:	0037c403          	lbu	s0,3(a5)
			src_port = proto_hdr->tcp->src_port;
400148f4:	00849493          	slli	s1,s1,0x8
400148f8:	00e4e4b3          	or	s1,s1,a4
			dst_port = proto_hdr->tcp->dst_port;
400148fc:	0027c703          	lbu	a4,2(a5)
40014900:	00841413          	slli	s0,s0,0x8
40014904:	00e46433          	or	s0,s0,a4
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40014908:	00100793          	li	a5,1
			(struct in_addr *)ip_hdr->ipv4->src);
4001490c:	0009aa03          	lw	s4,0(s3)
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
40014910:	0efc1e63          	bne	s8,a5,40014a0c <net_conn_input+0x1d4>
			(struct in_addr *)ip_hdr->ipv4->src);
40014914:	00ca0c93          	addi	s9,s4,12
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
40014918:	00000593          	li	a1,0
4001491c:	000c8513          	mv	a0,s9
40014920:	cecfa0ef          	jal	ra,4000ee0c <net_if_ipv4_addr_lookup>
	if (!ret) {
40014924:	0c051063          	bnez	a0,400149e4 <net_conn_input+0x1ac>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
40014928:	b38fc0ef          	jal	ra,40010c60 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4001492c:	00da4703          	lbu	a4,13(s4)
40014930:	00ca4783          	lbu	a5,12(s4)
40014934:	00054683          	lbu	a3,0(a0)
40014938:	00871713          	slli	a4,a4,0x8
4001493c:	00f76733          	or	a4,a4,a5
40014940:	00ea4783          	lbu	a5,14(s4)
40014944:	01079793          	slli	a5,a5,0x10
40014948:	00e7e7b3          	or	a5,a5,a4
4001494c:	00fa4703          	lbu	a4,15(s4)
40014950:	01871713          	slli	a4,a4,0x18
40014954:	00f76733          	or	a4,a4,a5
40014958:	00154783          	lbu	a5,1(a0)
4001495c:	00879793          	slli	a5,a5,0x8
40014960:	00d7e7b3          	or	a5,a5,a3
40014964:	00254683          	lbu	a3,2(a0)
40014968:	01069693          	slli	a3,a3,0x10
4001496c:	00f6e6b3          	or	a3,a3,a5
40014970:	00354783          	lbu	a5,3(a0)
40014974:	01879793          	slli	a5,a5,0x18
40014978:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4001497c:	06f70463          	beq	a4,a5,400149e4 <net_conn_input+0x1ac>
	return net_if_ipv4_is_addr_bcast(iface, addr);
40014980:	000c8593          	mv	a1,s9
40014984:	00000513          	li	a0,0
40014988:	a48fa0ef          	jal	ra,4000ebd0 <net_if_ipv4_is_addr_bcast>
			ip_hdr->ipv4->src, ip_hdr->ipv4->dst);
4001498c:	0009a783          	lw	a5,0(s3)
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40014990:	00d7c703          	lbu	a4,13(a5)
40014994:	00c7c683          	lbu	a3,12(a5)
40014998:	0117c603          	lbu	a2,17(a5)
4001499c:	00871713          	slli	a4,a4,0x8
400149a0:	00d76733          	or	a4,a4,a3
400149a4:	00e7c683          	lbu	a3,14(a5)
400149a8:	00861613          	slli	a2,a2,0x8
400149ac:	01069693          	slli	a3,a3,0x10
400149b0:	00e6e6b3          	or	a3,a3,a4
400149b4:	00f7c703          	lbu	a4,15(a5)
400149b8:	01871713          	slli	a4,a4,0x18
400149bc:	00d76733          	or	a4,a4,a3
400149c0:	0107c683          	lbu	a3,16(a5)
400149c4:	00d66633          	or	a2,a2,a3
400149c8:	0127c683          	lbu	a3,18(a5)
400149cc:	0137c783          	lbu	a5,19(a5)
400149d0:	01069693          	slli	a3,a3,0x10
400149d4:	00c6e6b3          	or	a3,a3,a2
400149d8:	01879793          	slli	a5,a5,0x18
400149dc:	00d7e7b3          	or	a5,a5,a3
		(is_same_src_and_dst_addr || is_my_src_addr) && is_same_src_and_dst_port;
400149e0:	04f71e63          	bne	a4,a5,40014a3c <net_conn_input+0x204>
400149e4:	04849e63          	bne	s1,s0,40014a40 <net_conn_input+0x208>
400149e8:	ea5ff06f          	j	4001488c <net_conn_input+0x54>
		} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
400149ec:	00600793          	li	a5,6
400149f0:	00f61863          	bne	a2,a5,40014a00 <net_conn_input+0x1c8>
			if (proto_hdr->tcp == NULL) {
400149f4:	0006a783          	lw	a5,0(a3)
400149f8:	ee0798e3          	bnez	a5,400148e8 <net_conn_input+0xb0>
400149fc:	e91ff06f          	j	4001488c <net_conn_input+0x54>
	uint16_t src_port = 0U, dst_port = 0U;
40014a00:	00000413          	li	s0,0
40014a04:	00000493          	li	s1,0
40014a08:	f01ff06f          	j	40014908 <net_conn_input+0xd0>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
40014a0c:	00000593          	li	a1,0
40014a10:	008a0513          	addi	a0,s4,8
40014a14:	d08f80ef          	jal	ra,4000cf1c <net_if_ipv6_addr_lookup>
40014a18:	00050a13          	mv	s4,a0
			ip_hdr->ipv6->src, ip_hdr->ipv6->dst);
40014a1c:	0009a503          	lw	a0,0(s3)
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
40014a20:	01000613          	li	a2,16
40014a24:	01850593          	addi	a1,a0,24
40014a28:	00850513          	addi	a0,a0,8
40014a2c:	da0f40ef          	jal	ra,40008fcc <memcmp>
		(is_same_src_and_dst_addr || is_my_src_addr) && is_same_src_and_dst_port;
40014a30:	04051263          	bnez	a0,40014a74 <net_conn_input+0x23c>
40014a34:	04849263          	bne	s1,s0,40014a78 <net_conn_input+0x240>
40014a38:	e55ff06f          	j	4001488c <net_conn_input+0x54>
40014a3c:	fa0514e3          	bnez	a0,400149e4 <net_conn_input+0x1ac>
			if (net_ipv4_is_addr_mcast((struct in_addr *)ip_hdr->ipv4->dst)) {
40014a40:	0009a583          	lw	a1,0(s3)
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
40014a44:	f0000737          	lui	a4,0xf0000
40014a48:	0105c783          	lbu	a5,16(a1)
40014a4c:	01879793          	slli	a5,a5,0x18
40014a50:	00e7f7b3          	and	a5,a5,a4
40014a54:	e0000737          	lui	a4,0xe0000
40014a58:	06e78a63          	beq	a5,a4,40014acc <net_conn_input+0x294>
			} else if (net_if_ipv4_is_addr_bcast(pkt_iface,
40014a5c:	01058593          	addi	a1,a1,16
40014a60:	000a8513          	mv	a0,s5
40014a64:	96cfa0ef          	jal	ra,4000ebd0 <net_if_ipv4_is_addr_bcast>
40014a68:	00050c93          	mv	s9,a0
	bool is_mcast_pkt = false;
40014a6c:	00000a13          	li	s4,0
40014a70:	01c0006f          	j	40014a8c <net_conn_input+0x254>
		(is_same_src_and_dst_addr || is_my_src_addr) && is_same_src_and_dst_port;
40014a74:	fc0a10e3          	bnez	s4,40014a34 <net_conn_input+0x1fc>
			is_mcast_pkt = net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->ipv6->dst);
40014a78:	0009a783          	lw	a5,0(s3)
	bool is_bcast_pkt = false;
40014a7c:	00000c93          	li	s9,0
	return addr->s6_addr[0] == 0xFF;
40014a80:	0187ca03          	lbu	s4,24(a5)
40014a84:	f01a0a13          	addi	s4,s4,-255
40014a88:	001a3a13          	seqz	s4,s4
	return list->head;
40014a8c:	400317b7          	lui	a5,0x40031
40014a90:	a887ad83          	lw	s11,-1400(a5) # 40030a88 <conn_used>
		if (conn->context != NULL &&
40014a94:	00001737          	lui	a4,0x1
40014a98:	fff00793          	li	a5,-1
40014a9c:	00f12223          	sw	a5,4(sp)
40014aa0:	80070793          	addi	a5,a4,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
40014aa4:	00000d13          	li	s10,0
40014aa8:	00000a93          	li	s5,0
40014aac:	00f12423          	sw	a5,8(sp)
	SYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {
40014ab0:	020d9463          	bnez	s11,40014ad8 <net_conn_input+0x2a0>
	if (IS_ENABLED(CONFIG_NET_IP) && is_mcast_pkt && mcast_pkt_delivered) {
40014ab4:	180a0863          	beqz	s4,40014c44 <net_conn_input+0x40c>
40014ab8:	140d0e63          	beqz	s10,40014c14 <net_conn_input+0x3dc>
		net_pkt_unref(pkt);
40014abc:	00090513          	mv	a0,s2
40014ac0:	c5cfe0ef          	jal	ra,40012f1c <net_pkt_unref>
		return NET_OK;
40014ac4:	00000513          	li	a0,0
		return NET_OK;
40014ac8:	dc9ff06f          	j	40014890 <net_conn_input+0x58>
	bool is_bcast_pkt = false;
40014acc:	00000c93          	li	s9,0
				is_mcast_pkt = true;
40014ad0:	00100a13          	li	s4,1
40014ad4:	fb9ff06f          	j	40014a8c <net_conn_input+0x254>
		if (conn->context != NULL &&
40014ad8:	038da703          	lw	a4,56(s11)
40014adc:	08071463          	bnez	a4,40014b64 <net_conn_input+0x32c>
		if (conn->family != AF_UNSPEC &&
40014ae0:	042dc703          	lbu	a4,66(s11)
40014ae4:	0a071863          	bnez	a4,40014b94 <net_conn_input+0x35c>
		if (conn->proto != proto) {
40014ae8:	040dd703          	lhu	a4,64(s11)
40014aec:	0b671063          	bne	a4,s6,40014b8c <net_conn_input+0x354>
			if (net_sin(&conn->remote_addr)->sin_port &&
40014af0:	006dd703          	lhu	a4,6(s11)
40014af4:	00070463          	beqz	a4,40014afc <net_conn_input+0x2c4>
40014af8:	08971a63          	bne	a4,s1,40014b8c <net_conn_input+0x354>
			if (net_sin(&conn->local_addr)->sin_port &&
40014afc:	01edd703          	lhu	a4,30(s11)
40014b00:	00070463          	beqz	a4,40014b08 <net_conn_input+0x2d0>
40014b04:	08871463          	bne	a4,s0,40014b8c <net_conn_input+0x354>
			if ((conn->flags & NET_CONN_REMOTE_ADDR_SET) &&
40014b08:	043dc703          	lbu	a4,67(s11)
40014b0c:	00277713          	andi	a4,a4,2
40014b10:	08071663          	bnez	a4,40014b9c <net_conn_input+0x364>
			if ((conn->flags & NET_CONN_LOCAL_ADDR_SET) &&
40014b14:	043dc703          	lbu	a4,67(s11)
40014b18:	00477713          	andi	a4,a4,4
40014b1c:	00070e63          	beqz	a4,40014b38 <net_conn_input+0x300>
			    !conn_addr_cmp(pkt, ip_hdr, &conn->local_addr, false)) {
40014b20:	00000693          	li	a3,0
40014b24:	01cd8613          	addi	a2,s11,28
40014b28:	00098593          	mv	a1,s3
40014b2c:	00090513          	mv	a0,s2
40014b30:	eccff0ef          	jal	ra,400141fc <conn_addr_cmp>
			if ((conn->flags & NET_CONN_LOCAL_ADDR_SET) &&
40014b34:	04050c63          	beqz	a0,40014b8c <net_conn_input+0x354>
			if (best_match != NULL && best_match->flags & NET_CONN_REMOTE_PORT_SPEC) {
40014b38:	080a9063          	bnez	s5,40014bb8 <net_conn_input+0x380>
			if (best_rank < NET_CONN_RANK(conn->flags)) {
40014b3c:	043dc703          	lbu	a4,67(s11)
40014b40:	00412783          	lw	a5,4(sp)
40014b44:	07877713          	andi	a4,a4,120
40014b48:	04e7d263          	bge	a5,a4,40014b8c <net_conn_input+0x354>
				if (!is_mcast_pkt) {
40014b4c:	060a1e63          	bnez	s4,40014bc8 <net_conn_input+0x390>
					best_rank = NET_CONN_RANK(conn->flags);
40014b50:	01071793          	slli	a5,a4,0x10
40014b54:	4107d793          	srai	a5,a5,0x10
40014b58:	00f12223          	sw	a5,4(sp)
					continue; /* found a match - but maybe not yet the best */
40014b5c:	000d8a93          	mv	s5,s11
40014b60:	02c0006f          	j	40014b8c <net_conn_input+0x354>
		if (conn->context != NULL &&
40014b64:	07475683          	lhu	a3,116(a4)
40014b68:	00812783          	lw	a5,8(sp)
40014b6c:	00f6f6b3          	and	a3,a3,a5
40014b70:	f60688e3          	beqz	a3,40014ae0 <net_conn_input+0x2a8>
	return pkt->iface;
40014b74:	01892683          	lw	a3,24(s2)
	return net_if_get_by_index(context->iface);
40014b78:	07670503          	lb	a0,118(a4)
40014b7c:	00d12623          	sw	a3,12(sp)
40014b80:	f4df70ef          	jal	ra,4000cacc <z_impl_net_if_get_by_index>
		    net_context_is_bound_to_iface(conn->context) &&
40014b84:	00c12683          	lw	a3,12(sp)
40014b88:	f4a68ce3          	beq	a3,a0,40014ae0 <net_conn_input+0x2a8>
	return node->next;
40014b8c:	000dad83          	lw	s11,0(s11)
40014b90:	f21ff06f          	j	40014ab0 <net_conn_input+0x278>
		if (conn->family != AF_UNSPEC &&
40014b94:	f5870ae3          	beq	a4,s8,40014ae8 <net_conn_input+0x2b0>
40014b98:	ff5ff06f          	j	40014b8c <net_conn_input+0x354>
			    !conn_addr_cmp(pkt, ip_hdr, &conn->remote_addr, true)) {
40014b9c:	00100693          	li	a3,1
40014ba0:	004d8613          	addi	a2,s11,4
40014ba4:	00098593          	mv	a1,s3
40014ba8:	00090513          	mv	a0,s2
40014bac:	e50ff0ef          	jal	ra,400141fc <conn_addr_cmp>
			if ((conn->flags & NET_CONN_REMOTE_ADDR_SET) &&
40014bb0:	f60512e3          	bnez	a0,40014b14 <net_conn_input+0x2dc>
40014bb4:	fd9ff06f          	j	40014b8c <net_conn_input+0x354>
			if (best_match != NULL && best_match->flags & NET_CONN_REMOTE_PORT_SPEC) {
40014bb8:	043ac703          	lbu	a4,67(s5)
40014bbc:	00877713          	andi	a4,a4,8
40014bc0:	f6070ee3          	beqz	a4,40014b3c <net_conn_input+0x304>
40014bc4:	fc9ff06f          	j	40014b8c <net_conn_input+0x354>
				mcast_pkt = net_pkt_clone(pkt, CLONE_TIMEOUT);
40014bc8:	00a00593          	li	a1,10
40014bcc:	00000613          	li	a2,0
40014bd0:	00090513          	mv	a0,s2
40014bd4:	a9cff0ef          	jal	ra,40013e70 <net_pkt_clone>
40014bd8:	00050d13          	mv	s10,a0
				if (!mcast_pkt) {
40014bdc:	ca0508e3          	beqz	a0,4001488c <net_conn_input+0x54>
				if (conn->cb(conn, mcast_pkt, ip_hdr, proto_hdr, conn->user_data) ==
40014be0:	03cda703          	lw	a4,60(s11)
40014be4:	034da803          	lw	a6,52(s11)
40014be8:	00050593          	mv	a1,a0
40014bec:	000b8693          	mv	a3,s7
40014bf0:	00098613          	mv	a2,s3
40014bf4:	000d8513          	mv	a0,s11
40014bf8:	000800e7          	jalr	a6
40014bfc:	00200713          	li	a4,2
40014c00:	00e51663          	bne	a0,a4,40014c0c <net_conn_input+0x3d4>
					net_pkt_unref(mcast_pkt);
40014c04:	000d0513          	mv	a0,s10
40014c08:	b14fe0ef          	jal	ra,40012f1c <net_pkt_unref>
				mcast_pkt_delivered = true;
40014c0c:	000a0d13          	mv	s10,s4
40014c10:	f7dff06f          	j	40014b8c <net_conn_input+0x354>
	if (best_match) {
40014c14:	c60a8ce3          	beqz	s5,4001488c <net_conn_input+0x54>
		if (best_match->cb(best_match, pkt, ip_hdr, proto_hdr, best_match->user_data)
40014c18:	034aa783          	lw	a5,52(s5)
40014c1c:	03caa703          	lw	a4,60(s5)
40014c20:	000b8693          	mv	a3,s7
40014c24:	00098613          	mv	a2,s3
40014c28:	00090593          	mv	a1,s2
40014c2c:	000a8513          	mv	a0,s5
40014c30:	000780e7          	jalr	a5
40014c34:	ffe50513          	addi	a0,a0,-2
40014c38:	00153513          	seqz	a0,a0
40014c3c:	00151513          	slli	a0,a0,0x1
40014c40:	c51ff06f          	j	40014890 <net_conn_input+0x58>
	if (best_match) {
40014c44:	fc0a9ae3          	bnez	s5,40014c18 <net_conn_input+0x3e0>
	    !(is_mcast_pkt || is_bcast_pkt)) {
40014c48:	c40c92e3          	bnez	s9,4001488c <net_conn_input+0x54>
	return pkt->family;
40014c4c:	03492783          	lw	a5,52(s2)
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
40014c50:	00200713          	li	a4,2
40014c54:	01d7d793          	srli	a5,a5,0x1d
40014c58:	00e79e63          	bne	a5,a4,40014c74 <net_conn_input+0x43c>
		net_icmpv6_send_error(pkt, NET_ICMPV6_DST_UNREACH,
40014c5c:	00000693          	li	a3,0
40014c60:	00400613          	li	a2,4
40014c64:	00100593          	li	a1,1
40014c68:	00090513          	mv	a0,s2
40014c6c:	274010ef          	jal	ra,40015ee0 <net_icmpv6_send_error>
40014c70:	c1dff06f          	j	4001488c <net_conn_input+0x54>
		net_icmpv4_send_error(pkt, NET_ICMPV4_DST_UNREACH,
40014c74:	00300613          	li	a2,3
40014c78:	00300593          	li	a1,3
40014c7c:	00090513          	mv	a0,s2
40014c80:	5e0000ef          	jal	ra,40015260 <net_icmpv4_send_error>
40014c84:	c09ff06f          	j	4001488c <net_conn_input+0x54>

40014c88 <net_conn_init>:
	list->head = NULL;
40014c88:	400317b7          	lui	a5,0x40031
40014c8c:	a8878793          	addi	a5,a5,-1400 # 40030a88 <conn_used>
40014c90:	0007a023          	sw	zero,0(a5)
	list->tail = NULL;
40014c94:	0007a223          	sw	zero,4(a5)
	int i;

	sys_slist_init(&conn_unused);
	sys_slist_init(&conn_used);

	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
40014c98:	400327b7          	lui	a5,0x40032
40014c9c:	39478713          	addi	a4,a5,916 # 40032394 <conns>
		sys_slist_prepend(&conn_unused, &conns[i].node);
40014ca0:	39478693          	addi	a3,a5,916
40014ca4:	22070593          	addi	a1,a4,544
	return list->tail;
40014ca8:	00000613          	li	a2,0
40014cac:	39478793          	addi	a5,a5,916
	parent->next = child;
40014cb0:	00c6a023          	sw	a2,0(a3)
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
40014cb4:	04470713          	addi	a4,a4,68
40014cb8:	00b70863          	beq	a4,a1,40014cc8 <net_conn_init+0x40>
		sys_slist_prepend(&conn_unused, &conns[i].node);
40014cbc:	00068613          	mv	a2,a3
40014cc0:	00070693          	mv	a3,a4
40014cc4:	fedff06f          	j	40014cb0 <net_conn_init+0x28>
40014cc8:	40031737          	lui	a4,0x40031
40014ccc:	400326b7          	lui	a3,0x40032
40014cd0:	a9070713          	addi	a4,a4,-1392 # 40030a90 <conn_unused>
40014cd4:	57068693          	addi	a3,a3,1392 # 40032570 <conns+0x1dc>
40014cd8:	00d72023          	sw	a3,0(a4)
40014cdc:	00f72223          	sw	a5,4(a4)
	}
}
40014ce0:	00008067          	ret

40014ce4 <icmpv4_create>:
	struct net_pkt *reply;
	const struct in_addr *src;
};

static int icmpv4_create(struct net_pkt *pkt, uint8_t icmp_type, uint8_t icmp_code)
{
40014ce4:	fe010113          	addi	sp,sp,-32
40014ce8:	01212823          	sw	s2,16(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
40014cec:	00400793          	li	a5,4
{
40014cf0:	00058913          	mv	s2,a1
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
40014cf4:	00810593          	addi	a1,sp,8
{
40014cf8:	00812c23          	sw	s0,24(sp)
40014cfc:	00912a23          	sw	s1,20(sp)
40014d00:	00112e23          	sw	ra,28(sp)
40014d04:	00050413          	mv	s0,a0
40014d08:	00060493          	mv	s1,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
40014d0c:	00012423          	sw	zero,8(sp)
40014d10:	00f12623          	sw	a5,12(sp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
40014d14:	a68ff0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!icmp_hdr) {
40014d18:	02050c63          	beqz	a0,40014d50 <icmpv4_create+0x6c>
		return -ENOBUFS;
	}

	icmp_hdr->type   = icmp_type;
40014d1c:	01250023          	sb	s2,0(a0)
	icmp_hdr->code   = icmp_code;
40014d20:	009500a3          	sb	s1,1(a0)
	icmp_hdr->chksum = 0U;
40014d24:	00050123          	sb	zero,2(a0)
40014d28:	000501a3          	sb	zero,3(a0)

	return net_pkt_set_data(pkt, &icmpv4_access);
40014d2c:	00810593          	addi	a1,sp,8
40014d30:	00040513          	mv	a0,s0
40014d34:	ad8ff0ef          	jal	ra,4001400c <net_pkt_set_data>
}
40014d38:	01c12083          	lw	ra,28(sp)
40014d3c:	01812403          	lw	s0,24(sp)
40014d40:	01412483          	lw	s1,20(sp)
40014d44:	01012903          	lw	s2,16(sp)
40014d48:	02010113          	addi	sp,sp,32
40014d4c:	00008067          	ret
		return -ENOBUFS;
40014d50:	f9700513          	li	a0,-105
40014d54:	fe5ff06f          	j	40014d38 <icmpv4_create+0x54>

40014d58 <net_ipv4_is_addr_bcast>:
{
40014d58:	fe010113          	addi	sp,sp,-32
40014d5c:	00812c23          	sw	s0,24(sp)
40014d60:	00b12623          	sw	a1,12(sp)
40014d64:	00112e23          	sw	ra,28(sp)
40014d68:	00050413          	mv	s0,a0
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
40014d6c:	ef5fb0ef          	jal	ra,40010c60 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40014d70:	00c12583          	lw	a1,12(sp)
40014d74:	00054683          	lbu	a3,0(a0)
40014d78:	0015c703          	lbu	a4,1(a1)
40014d7c:	0005c783          	lbu	a5,0(a1)
40014d80:	00871713          	slli	a4,a4,0x8
40014d84:	00f76733          	or	a4,a4,a5
40014d88:	0025c783          	lbu	a5,2(a1)
40014d8c:	01079793          	slli	a5,a5,0x10
40014d90:	00e7e7b3          	or	a5,a5,a4
40014d94:	0035c703          	lbu	a4,3(a1)
40014d98:	01871713          	slli	a4,a4,0x18
40014d9c:	00f76733          	or	a4,a4,a5
40014da0:	00154783          	lbu	a5,1(a0)
40014da4:	00879793          	slli	a5,a5,0x8
40014da8:	00d7e7b3          	or	a5,a5,a3
40014dac:	00254683          	lbu	a3,2(a0)
40014db0:	01069693          	slli	a3,a3,0x10
40014db4:	00f6e6b3          	or	a3,a3,a5
40014db8:	00354783          	lbu	a5,3(a0)
40014dbc:	01879793          	slli	a5,a5,0x18
40014dc0:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
40014dc4:	00f70c63          	beq	a4,a5,40014ddc <net_ipv4_is_addr_bcast+0x84>
	return net_if_ipv4_is_addr_bcast(iface, addr);
40014dc8:	00040513          	mv	a0,s0
}
40014dcc:	01812403          	lw	s0,24(sp)
40014dd0:	01c12083          	lw	ra,28(sp)
40014dd4:	02010113          	addi	sp,sp,32
	return net_if_ipv4_is_addr_bcast(iface, addr);
40014dd8:	df9f906f          	j	4000ebd0 <net_if_ipv4_is_addr_bcast>
}
40014ddc:	01c12083          	lw	ra,28(sp)
40014de0:	01812403          	lw	s0,24(sp)
40014de4:	00100513          	li	a0,1
40014de8:	02010113          	addi	sp,sp,32
40014dec:	00008067          	ret

40014df0 <icmpv4_handle_echo_request>:
	return UNALIGNED_GET(&addr->s_addr) == 0;
40014df0:	00d5c783          	lbu	a5,13(a1)
40014df4:	00c5c703          	lbu	a4,12(a1)
40014df8:	00879793          	slli	a5,a5,0x8
40014dfc:	00e7e7b3          	or	a5,a5,a4
40014e00:	00e5c703          	lbu	a4,14(a1)
40014e04:	01071713          	slli	a4,a4,0x10
40014e08:	00f76733          	or	a4,a4,a5
40014e0c:	00f5c783          	lbu	a5,15(a1)
40014e10:	01879793          	slli	a5,a5,0x18
40014e14:	00e7e7b3          	or	a5,a5,a4
	int16_t payload_len;

	/* If interface can not select src address based on dst addr
	 * and src address is unspecified, drop the echo request.
	 */
	if (net_ipv4_is_addr_unspecified((struct in_addr *)ip_hdr->src)) {
40014e18:	00079663          	bnez	a5,40014e24 <icmpv4_handle_echo_request+0x34>
		net_pkt_unref(reply);
	}

	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
40014e1c:	00200513          	li	a0,2
}
40014e20:	00008067          	ret
{
40014e24:	fd010113          	addi	sp,sp,-48
40014e28:	02912223          	sw	s1,36(sp)
40014e2c:	03212023          	sw	s2,32(sp)
40014e30:	02112623          	sw	ra,44(sp)
40014e34:	02812423          	sw	s0,40(sp)
40014e38:	01312e23          	sw	s3,28(sp)
40014e3c:	00852703          	lw	a4,8(a0)
40014e40:	00050493          	mv	s1,a0
40014e44:	00058913          	mv	s2,a1
	size_t bytes = 0;
40014e48:	00000793          	li	a5,0
	while (buf) {
40014e4c:	10071c63          	bnez	a4,40014f64 <icmpv4_handle_echo_request+0x174>
	return pkt->ipv4_opts_len;
40014e50:	03a4c583          	lbu	a1,58(s1)
		      net_pkt_ip_hdr_len(pkt) -
40014e54:	0364c703          	lbu	a4,54(s1)
		      net_pkt_ipv4_opts_len(pkt) - NET_ICMPH_LEN;
40014e58:	00e58733          	add	a4,a1,a4
40014e5c:	40e787b3          	sub	a5,a5,a4
40014e60:	ffc78793          	addi	a5,a5,-4
40014e64:	01079993          	slli	s3,a5,0x10
	if (payload_len < NET_ICMPV4_UNUSED_LEN) {
40014e68:	01079793          	slli	a5,a5,0x10
40014e6c:	4107d793          	srai	a5,a5,0x10
40014e70:	00300713          	li	a4,3
		      net_pkt_ipv4_opts_len(pkt) - NET_ICMPH_LEN;
40014e74:	0109d993          	srli	s3,s3,0x10
	if (payload_len < NET_ICMPV4_UNUSED_LEN) {
40014e78:	10f75c63          	bge	a4,a5,40014f90 <icmpv4_handle_echo_request+0x1a0>
	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt),
40014e7c:	0184a503          	lw	a0,24(s1)
40014e80:	06400713          	li	a4,100
40014e84:	00000793          	li	a5,0
40014e88:	00100693          	li	a3,1
40014e8c:	00100613          	li	a2,1
40014e90:	013585b3          	add	a1,a1,s3
40014e94:	889fe0ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
40014e98:	00050413          	mv	s0,a0
	if (!reply) {
40014e9c:	0e050a63          	beqz	a0,40014f90 <icmpv4_handle_echo_request+0x1a0>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
40014ea0:	01094783          	lbu	a5,16(s2)
40014ea4:	f0000737          	lui	a4,0xf0000
	return pkt->iface;
40014ea8:	0184a503          	lw	a0,24(s1)
40014eac:	01879793          	slli	a5,a5,0x18
40014eb0:	00e7f7b3          	and	a5,a5,a4
	if (net_ipv4_is_addr_mcast((struct in_addr *)ip_hdr->dst) ||
40014eb4:	e0000737          	lui	a4,0xe0000
40014eb8:	01090593          	addi	a1,s2,16
40014ebc:	0ae79c63          	bne	a5,a4,40014f74 <icmpv4_handle_echo_request+0x184>
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
40014ec0:	0184a503          	lw	a0,24(s1)
40014ec4:	e25f90ef          	jal	ra,4000ece8 <net_if_ipv4_select_src_addr>
40014ec8:	00050593          	mv	a1,a0
	return pkt->ip_dscp;
40014ecc:	0404a703          	lw	a4,64(s1)
	pkt->ip_dscp = dscp;
40014ed0:	04044783          	lbu	a5,64(s0)
	if (net_ipv4_create(reply, src, (struct in_addr *)ip_hdr->src)) {
40014ed4:	00c90613          	addi	a2,s2,12
40014ed8:	03f77713          	andi	a4,a4,63
40014edc:	fc07f793          	andi	a5,a5,-64
40014ee0:	00e7e7b3          	or	a5,a5,a4
40014ee4:	04f40023          	sb	a5,64(s0)
	return pkt->ip_ecn;
40014ee8:	0404a703          	lw	a4,64(s1)
	pkt->ip_ecn = ecn;
40014eec:	0ff7f793          	zext.b	a5,a5
40014ef0:	03f7f793          	andi	a5,a5,63
40014ef4:	0c077713          	andi	a4,a4,192
40014ef8:	00e7e7b3          	or	a5,a5,a4
40014efc:	04f40023          	sb	a5,64(s0)
40014f00:	00040513          	mv	a0,s0
40014f04:	0b9000ef          	jal	ra,400157bc <net_ipv4_create>
40014f08:	08051063          	bnez	a0,40014f88 <icmpv4_handle_echo_request+0x198>
	if (icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
40014f0c:	00000613          	li	a2,0
40014f10:	00000593          	li	a1,0
40014f14:	00040513          	mv	a0,s0
40014f18:	dcdff0ef          	jal	ra,40014ce4 <icmpv4_create>
40014f1c:	06051663          	bnez	a0,40014f88 <icmpv4_handle_echo_request+0x198>
	    net_pkt_copy(reply, pkt, payload_len)) {
40014f20:	00098613          	mv	a2,s3
40014f24:	00048593          	mv	a1,s1
40014f28:	00040513          	mv	a0,s0
40014f2c:	b05fe0ef          	jal	ra,40013a30 <net_pkt_copy>
	if (icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
40014f30:	04051c63          	bnez	a0,40014f88 <icmpv4_handle_echo_request+0x198>
	net_pkt_cursor_init(reply);
40014f34:	00040513          	mv	a0,s0
40014f38:	ab8fe0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	net_ipv4_finalize(reply, IPPROTO_ICMP);
40014f3c:	00100593          	li	a1,1
40014f40:	00040513          	mv	a0,s0
40014f44:	0a5000ef          	jal	ra,400157e8 <net_ipv4_finalize>
	if (net_send_data(reply) < 0) {
40014f48:	00040513          	mv	a0,s0
40014f4c:	f7cf60ef          	jal	ra,4000b6c8 <net_send_data>
40014f50:	02054c63          	bltz	a0,40014f88 <icmpv4_handle_echo_request+0x198>
	net_pkt_unref(pkt);
40014f54:	00048513          	mv	a0,s1
40014f58:	fc5fd0ef          	jal	ra,40012f1c <net_pkt_unref>
	return NET_OK;
40014f5c:	00000513          	li	a0,0
40014f60:	0340006f          	j	40014f94 <icmpv4_handle_echo_request+0x1a4>
		bytes += buf->len;
40014f64:	01075683          	lhu	a3,16(a4) # e0000010 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0000011>
		buf = buf->frags;
40014f68:	00472703          	lw	a4,4(a4)
		bytes += buf->len;
40014f6c:	00d787b3          	add	a5,a5,a3
		buf = buf->frags;
40014f70:	eddff06f          	j	40014e4c <icmpv4_handle_echo_request+0x5c>
	    net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
40014f74:	00b12623          	sw	a1,12(sp)
40014f78:	de1ff0ef          	jal	ra,40014d58 <net_ipv4_is_addr_bcast>
	if (net_ipv4_is_addr_mcast((struct in_addr *)ip_hdr->dst) ||
40014f7c:	00c12583          	lw	a1,12(sp)
40014f80:	f40510e3          	bnez	a0,40014ec0 <icmpv4_handle_echo_request+0xd0>
40014f84:	f49ff06f          	j	40014ecc <icmpv4_handle_echo_request+0xdc>
		net_pkt_unref(reply);
40014f88:	00040513          	mv	a0,s0
40014f8c:	f91fd0ef          	jal	ra,40012f1c <net_pkt_unref>
	return NET_DROP;
40014f90:	00200513          	li	a0,2
}
40014f94:	02c12083          	lw	ra,44(sp)
40014f98:	02812403          	lw	s0,40(sp)
40014f9c:	02412483          	lw	s1,36(sp)
40014fa0:	02012903          	lw	s2,32(sp)
40014fa4:	01c12983          	lw	s3,28(sp)
40014fa8:	03010113          	addi	sp,sp,48
40014fac:	00008067          	ret

40014fb0 <net_icmpv4_finalize>:
{
40014fb0:	fe010113          	addi	sp,sp,-32
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
40014fb4:	00400793          	li	a5,4
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
40014fb8:	00810593          	addi	a1,sp,8
{
40014fbc:	00912a23          	sw	s1,20(sp)
40014fc0:	00112e23          	sw	ra,28(sp)
40014fc4:	00812c23          	sw	s0,24(sp)
40014fc8:	00050493          	mv	s1,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
40014fcc:	00012423          	sw	zero,8(sp)
40014fd0:	00f12623          	sw	a5,12(sp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
40014fd4:	fa9fe0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!icmp_hdr) {
40014fd8:	04050a63          	beqz	a0,4001502c <net_icmpv4_finalize+0x7c>
	icmp_hdr->chksum = 0U;
40014fdc:	00050123          	sb	zero,2(a0)
40014fe0:	000501a3          	sb	zero,3(a0)
40014fe4:	00050413          	mv	s0,a0
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
40014fe8:	0184a503          	lw	a0,24(s1)
40014fec:	de4fa0ef          	jal	ra,4000f5d0 <net_if_need_calc_tx_checksum>
40014ff0:	00050e63          	beqz	a0,4001500c <net_icmpv4_finalize+0x5c>
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
}

static inline uint16_t net_calc_chksum_icmpv4(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_ICMP);
40014ff4:	00100593          	li	a1,1
40014ff8:	00048513          	mv	a0,s1
40014ffc:	f58fb0ef          	jal	ra,40010754 <net_calc_chksum>
		icmp_hdr->chksum = net_calc_chksum_icmpv4(pkt);
40015000:	00855793          	srli	a5,a0,0x8
40015004:	00a40123          	sb	a0,2(s0)
40015008:	00f401a3          	sb	a5,3(s0)
	return net_pkt_set_data(pkt, &icmpv4_access);
4001500c:	00810593          	addi	a1,sp,8
40015010:	00048513          	mv	a0,s1
40015014:	ff9fe0ef          	jal	ra,4001400c <net_pkt_set_data>
}
40015018:	01c12083          	lw	ra,28(sp)
4001501c:	01812403          	lw	s0,24(sp)
40015020:	01412483          	lw	s1,20(sp)
40015024:	02010113          	addi	sp,sp,32
40015028:	00008067          	ret
		return -ENOBUFS;
4001502c:	f9700513          	li	a0,-105
40015030:	fe9ff06f          	j	40015018 <net_icmpv4_finalize+0x68>

40015034 <net_icmpv4_send_echo_request>:
				 uint16_t identifier,
				 uint16_t sequence,
				 uint8_t tos,
				 const void *data,
				 size_t data_size)
{
40015034:	fc010113          	addi	sp,sp,-64
40015038:	03312623          	sw	s3,44(sp)
4001503c:	03612023          	sw	s6,32(sp)
40015040:	01712e23          	sw	s7,28(sp)
40015044:	02112e23          	sw	ra,60(sp)
40015048:	02812c23          	sw	s0,56(sp)
4001504c:	02912a23          	sw	s1,52(sp)
40015050:	03212823          	sw	s2,48(sp)
40015054:	03412423          	sw	s4,40(sp)
40015058:	03512223          	sw	s5,36(sp)
4001505c:	01812c23          	sw	s8,24(sp)
40015060:	00058b93          	mv	s7,a1

	if (IS_ENABLED(CONFIG_NET_OFFLOAD) && net_if_is_ip_offloaded(iface)) {
		return -ENOTSUP;
	}

	if (!iface->config.ip.ipv4) {
40015064:	00852583          	lw	a1,8(a0)
{
40015068:	00078b13          	mv	s6,a5
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
4001506c:	00400793          	li	a5,4
40015070:	00012423          	sw	zero,8(sp)
40015074:	00f12623          	sw	a5,12(sp)
		return -ENETUNREACH;
40015078:	f8e00993          	li	s3,-114
	if (!iface->config.ip.ipv4) {
4001507c:	06058463          	beqz	a1,400150e4 <net_icmpv4_send_echo_request+0xb0>
40015080:	00060a13          	mv	s4,a2
40015084:	00068493          	mv	s1,a3
40015088:	00070a93          	mv	s5,a4
	}

	/* Take the first address of the network interface */
	src = &iface->config.ip.ipv4->unicast[0].address.in_addr;
4001508c:	00458c13          	addi	s8,a1,4

	pkt = net_pkt_alloc_with_buffer(iface,
40015090:	06400713          	li	a4,100
40015094:	00000793          	li	a5,0
40015098:	00100693          	li	a3,1
4001509c:	00100613          	li	a2,1
400150a0:	00480593          	addi	a1,a6,4
400150a4:	00080913          	mv	s2,a6
400150a8:	e74fe0ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
400150ac:	00050413          	mv	s0,a0
					sizeof(struct net_icmpv4_echo_req)
					+ data_size,
					AF_INET, IPPROTO_ICMP,
					PKT_WAIT_TIME);
	if (!pkt) {
		return -ENOMEM;
400150b0:	ff400993          	li	s3,-12
	if (!pkt) {
400150b4:	02050863          	beqz	a0,400150e4 <net_icmpv4_send_echo_request+0xb0>
	pkt->ip_dscp = dscp;
400150b8:	006a9793          	slli	a5,s5,0x6
400150bc:	002ada93          	srli	s5,s5,0x2
400150c0:	0157e7b3          	or	a5,a5,s5
400150c4:	04f50023          	sb	a5,64(a0)
	}

	net_pkt_set_ip_dscp(pkt, net_ipv4_get_dscp(tos));
	net_pkt_set_ip_ecn(pkt, net_ipv4_get_ecn(tos));

	if (net_ipv4_create(pkt, src, dst) ||
400150c8:	000b8613          	mv	a2,s7
400150cc:	000c0593          	mv	a1,s8
400150d0:	6ec000ef          	jal	ra,400157bc <net_ipv4_create>
400150d4:	04050263          	beqz	a0,40015118 <net_icmpv4_send_echo_request+0xe4>
	int ret = -ENOBUFS;
400150d8:	f9700993          	li	s3,-105
	net_stats_update_icmp_drop(iface);

	ret = -EIO;

drop:
	net_pkt_unref(pkt);
400150dc:	00040513          	mv	a0,s0
400150e0:	e3dfd0ef          	jal	ra,40012f1c <net_pkt_unref>

	return ret;
}
400150e4:	03c12083          	lw	ra,60(sp)
400150e8:	03812403          	lw	s0,56(sp)
400150ec:	03412483          	lw	s1,52(sp)
400150f0:	03012903          	lw	s2,48(sp)
400150f4:	02812a03          	lw	s4,40(sp)
400150f8:	02412a83          	lw	s5,36(sp)
400150fc:	02012b03          	lw	s6,32(sp)
40015100:	01c12b83          	lw	s7,28(sp)
40015104:	01812c03          	lw	s8,24(sp)
40015108:	00098513          	mv	a0,s3
4001510c:	02c12983          	lw	s3,44(sp)
40015110:	04010113          	addi	sp,sp,64
40015114:	00008067          	ret
	    icmpv4_create(pkt, NET_ICMPV4_ECHO_REQUEST, 0)) {
40015118:	00000613          	li	a2,0
4001511c:	00800593          	li	a1,8
40015120:	00040513          	mv	a0,s0
40015124:	bc1ff0ef          	jal	ra,40014ce4 <icmpv4_create>
40015128:	00050993          	mv	s3,a0
	if (net_ipv4_create(pkt, src, dst) ||
4001512c:	fa0516e3          	bnez	a0,400150d8 <net_icmpv4_send_echo_request+0xa4>
	echo_req = (struct net_icmpv4_echo_req *)net_pkt_get_data(
40015130:	00810593          	addi	a1,sp,8
40015134:	00040513          	mv	a0,s0
40015138:	e45fe0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!echo_req) {
4001513c:	f8050ee3          	beqz	a0,400150d8 <net_icmpv4_send_echo_request+0xa4>
	echo_req->identifier = htons(identifier);
40015140:	008a1793          	slli	a5,s4,0x8
40015144:	008a5a13          	srli	s4,s4,0x8
40015148:	0147ea33          	or	s4,a5,s4
4001514c:	010a1793          	slli	a5,s4,0x10
40015150:	0107d793          	srli	a5,a5,0x10
40015154:	0087d793          	srli	a5,a5,0x8
40015158:	00f500a3          	sb	a5,1(a0)
	echo_req->sequence   = htons(sequence);
4001515c:	00849793          	slli	a5,s1,0x8
40015160:	0084d493          	srli	s1,s1,0x8
40015164:	0097e4b3          	or	s1,a5,s1
40015168:	01049793          	slli	a5,s1,0x10
4001516c:	0107d793          	srli	a5,a5,0x10
40015170:	0087d793          	srli	a5,a5,0x8
	echo_req->identifier = htons(identifier);
40015174:	01450023          	sb	s4,0(a0)
	echo_req->sequence   = htons(sequence);
40015178:	00950123          	sb	s1,2(a0)
4001517c:	00f501a3          	sb	a5,3(a0)
	net_pkt_set_data(pkt, &icmpv4_access);
40015180:	00810593          	addi	a1,sp,8
40015184:	00040513          	mv	a0,s0
40015188:	e85fe0ef          	jal	ra,4001400c <net_pkt_set_data>
	if (data != NULL && data_size > 0) {
4001518c:	040b0063          	beqz	s6,400151cc <net_icmpv4_send_echo_request+0x198>
40015190:	00090a63          	beqz	s2,400151a4 <net_icmpv4_send_echo_request+0x170>
		net_pkt_write(pkt, data, data_size);
40015194:	00090613          	mv	a2,s2
40015198:	000b0593          	mv	a1,s6
4001519c:	00040513          	mv	a0,s0
400151a0:	d79fe0ef          	jal	ra,40013f18 <net_pkt_write>
	net_pkt_cursor_init(pkt);
400151a4:	00040513          	mv	a0,s0
400151a8:	848fe0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	net_ipv4_finalize(pkt, IPPROTO_ICMP);
400151ac:	00100593          	li	a1,1
400151b0:	00040513          	mv	a0,s0
400151b4:	634000ef          	jal	ra,400157e8 <net_ipv4_finalize>
	if (net_send_data(pkt) >= 0) {
400151b8:	00040513          	mv	a0,s0
400151bc:	d0cf60ef          	jal	ra,4000b6c8 <net_send_data>
400151c0:	f20552e3          	bgez	a0,400150e4 <net_icmpv4_send_echo_request+0xb0>
	ret = -EIO;
400151c4:	ffb00993          	li	s3,-5
400151c8:	f15ff06f          	j	400150dc <net_icmpv4_send_echo_request+0xa8>
	} else if (data == NULL && data_size > 0) {
400151cc:	fc090ce3          	beqz	s2,400151a4 <net_icmpv4_send_echo_request+0x170>
		if (data_size >= sizeof(uint32_t)) {
400151d0:	00300793          	li	a5,3
400151d4:	0727f463          	bgeu	a5,s2,4001523c <net_icmpv4_send_echo_request+0x208>
	return sys_clock_cycle_get_32();
400151d8:	358110ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
400151dc:	00050493          	mv	s1,a0
400151e0:	350110ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
400151e4:	00050a93          	mv	s5,a0
400151e8:	348110ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
400151ec:	00050a13          	mv	s4,a0
400151f0:	340110ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
			uint32_t time_stamp = htonl(k_cycle_get_32());
400151f4:	000107b7          	lui	a5,0x10
400151f8:	01851513          	slli	a0,a0,0x18
400151fc:	f0078793          	addi	a5,a5,-256 # ff00 <__kernel_ram_size+0x3c6c>
40015200:	0184d493          	srli	s1,s1,0x18
40015204:	008ada93          	srli	s5,s5,0x8
40015208:	00a4e4b3          	or	s1,s1,a0
4001520c:	00fafab3          	and	s5,s5,a5
40015210:	008a1a13          	slli	s4,s4,0x8
40015214:	00ff07b7          	lui	a5,0xff0
40015218:	00fa7a33          	and	s4,s4,a5
4001521c:	0154e4b3          	or	s1,s1,s5
40015220:	0144e4b3          	or	s1,s1,s4
			net_pkt_write(pkt, &time_stamp, sizeof(time_stamp));
40015224:	00400613          	li	a2,4
40015228:	00410593          	addi	a1,sp,4
4001522c:	00040513          	mv	a0,s0
			uint32_t time_stamp = htonl(k_cycle_get_32());
40015230:	00912223          	sw	s1,4(sp)
			data_size -= sizeof(time_stamp);
40015234:	ffc90913          	addi	s2,s2,-4
			net_pkt_write(pkt, &time_stamp, sizeof(time_stamp));
40015238:	ce1fe0ef          	jal	ra,40013f18 <net_pkt_write>
		for (size_t i = 0; i < data_size; i++) {
4001523c:	00000493          	li	s1,0
40015240:	f69902e3          	beq	s2,s1,400151a4 <net_icmpv4_send_echo_request+0x170>
int net_pkt_write(struct net_pkt *pkt, const void *data, size_t length);

/* Write uint8_t data into a net_pkt. */
static inline int net_pkt_write_u8(struct net_pkt *pkt, uint8_t data)
{
	return net_pkt_write(pkt, &data, sizeof(uint8_t));
40015244:	00100613          	li	a2,1
40015248:	00410593          	addi	a1,sp,4
4001524c:	00040513          	mv	a0,s0
40015250:	00910223          	sb	s1,4(sp)
40015254:	cc5fe0ef          	jal	ra,40013f18 <net_pkt_write>
40015258:	00148493          	addi	s1,s1,1
4001525c:	fe5ff06f          	j	40015240 <net_icmpv4_send_echo_request+0x20c>

40015260 <net_icmpv4_send_error>:

int net_icmpv4_send_error(struct net_pkt *orig, uint8_t type, uint8_t code)
{
40015260:	fc010113          	addi	sp,sp,-64
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
40015264:	01400793          	li	a5,20
{
40015268:	02912a23          	sw	s1,52(sp)
4001526c:	03512223          	sw	s5,36(sp)
40015270:	03612023          	sw	s6,32(sp)
40015274:	02112e23          	sw	ra,60(sp)
40015278:	02812c23          	sw	s0,56(sp)
4001527c:	03212823          	sw	s2,48(sp)
40015280:	03312623          	sw	s3,44(sp)
40015284:	03412423          	sw	s4,40(sp)
40015288:	01712e23          	sw	s7,28(sp)
4001528c:	00050493          	mv	s1,a0
40015290:	00058a93          	mv	s5,a1
40015294:	00060b13          	mv	s6,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
40015298:	00012023          	sw	zero,0(sp)
4001529c:	00f12223          	sw	a5,4(sp)
	int err = -EIO;
	struct net_ipv4_hdr *ip_hdr;
	struct net_pkt *pkt;
	size_t copy_len;

	net_pkt_cursor_init(orig);
400152a0:	f51fd0ef          	jal	ra,400131f0 <net_pkt_cursor_init>

	ip_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(orig, &ipv4_access);
400152a4:	00010593          	mv	a1,sp
400152a8:	00048513          	mv	a0,s1
400152ac:	cd1fe0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!ip_hdr) {
400152b0:	0e050263          	beqz	a0,40015394 <net_icmpv4_send_error+0x134>
		goto drop_no_pkt;
	}

	if (ip_hdr->proto == IPPROTO_ICMP) {
400152b4:	00954703          	lbu	a4,9(a0)
400152b8:	00100793          	li	a5,1
400152bc:	00050993          	mv	s3,a0
400152c0:	06f71063          	bne	a4,a5,40015320 <net_icmpv4_send_error+0xc0>
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
400152c4:	00400793          	li	a5,4
						      struct net_icmp_hdr);
		struct net_icmp_hdr *icmp_hdr;

		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
400152c8:	00810593          	addi	a1,sp,8
400152cc:	00048513          	mv	a0,s1
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
400152d0:	00012423          	sw	zero,8(sp)
400152d4:	00f12623          	sw	a5,12(sp)
		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
400152d8:	ca5fe0ef          	jal	ra,40013f7c <net_pkt_get_data>
							orig, &icmpv4_access);
		if (!icmp_hdr || icmp_hdr->code < 8) {
400152dc:	00050863          	beqz	a0,400152ec <net_icmpv4_send_error+0x8c>
400152e0:	00154703          	lbu	a4,1(a0)
400152e4:	00700793          	li	a5,7
400152e8:	02e7ec63          	bltu	a5,a4,40015320 <net_icmpv4_send_error+0xc0>
			/* We must not send ICMP errors back */
			err = -EINVAL;
400152ec:	fea00913          	li	s2,-22
drop_no_pkt:
	net_stats_update_icmp_drop(net_pkt_iface(orig));

	return err;

}
400152f0:	03c12083          	lw	ra,60(sp)
400152f4:	03812403          	lw	s0,56(sp)
400152f8:	03412483          	lw	s1,52(sp)
400152fc:	02c12983          	lw	s3,44(sp)
40015300:	02812a03          	lw	s4,40(sp)
40015304:	02412a83          	lw	s5,36(sp)
40015308:	02012b03          	lw	s6,32(sp)
4001530c:	01c12b83          	lw	s7,28(sp)
40015310:	00090513          	mv	a0,s2
40015314:	03012903          	lw	s2,48(sp)
40015318:	04010113          	addi	sp,sp,64
4001531c:	00008067          	ret
	if (net_ipv4_is_addr_bcast(net_pkt_iface(orig),
40015320:	0184a503          	lw	a0,24(s1)
				   (struct in_addr *)ip_hdr->dst)) {
40015324:	01098b93          	addi	s7,s3,16
	if (net_ipv4_is_addr_bcast(net_pkt_iface(orig),
40015328:	000b8593          	mv	a1,s7
4001532c:	a2dff0ef          	jal	ra,40014d58 <net_ipv4_is_addr_bcast>
40015330:	06051263          	bnez	a0,40015394 <net_icmpv4_send_error+0x134>
	if (ip_hdr->proto == IPPROTO_UDP) {
40015334:	0099c783          	lbu	a5,9(s3)
40015338:	01100713          	li	a4,17
		copy_len = sizeof(struct net_ipv4_hdr) +
4001533c:	01c00a13          	li	s4,28
	if (ip_hdr->proto == IPPROTO_UDP) {
40015340:	00e78a63          	beq	a5,a4,40015354 <net_icmpv4_send_error+0xf4>
	} else if (ip_hdr->proto == IPPROTO_TCP) {
40015344:	00600713          	li	a4,6
		copy_len = 0;
40015348:	00000a13          	li	s4,0
	} else if (ip_hdr->proto == IPPROTO_TCP) {
4001534c:	00e79463          	bne	a5,a4,40015354 <net_icmpv4_send_error+0xf4>
		copy_len = sizeof(struct net_ipv4_hdr) +
40015350:	02800a13          	li	s4,40
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
40015354:	0184a503          	lw	a0,24(s1)
40015358:	06400713          	li	a4,100
4001535c:	00000793          	li	a5,0
40015360:	00100693          	li	a3,1
40015364:	00100613          	li	a2,1
40015368:	004a0593          	addi	a1,s4,4
4001536c:	bb0fe0ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
40015370:	00050413          	mv	s0,a0
		err =  -ENOMEM;
40015374:	ff400913          	li	s2,-12
	if (!pkt) {
40015378:	f6050ce3          	beqz	a0,400152f0 <net_icmpv4_send_error+0x90>
	if (net_ipv4_create(pkt, (struct in_addr *)ip_hdr->dst,
4001537c:	00c98613          	addi	a2,s3,12
40015380:	000b8593          	mv	a1,s7
40015384:	438000ef          	jal	ra,400157bc <net_ipv4_create>
40015388:	00050a63          	beqz	a0,4001539c <net_icmpv4_send_error+0x13c>
	net_pkt_unref(pkt);
4001538c:	00040513          	mv	a0,s0
40015390:	b8dfd0ef          	jal	ra,40012f1c <net_pkt_unref>
	int err = -EIO;
40015394:	ffb00913          	li	s2,-5
40015398:	f59ff06f          	j	400152f0 <net_icmpv4_send_error+0x90>
	    icmpv4_create(pkt, type, code) ||
4001539c:	000b0613          	mv	a2,s6
400153a0:	000a8593          	mv	a1,s5
400153a4:	00040513          	mv	a0,s0
400153a8:	93dff0ef          	jal	ra,40014ce4 <icmpv4_create>
			    (struct in_addr *)ip_hdr->src) ||
400153ac:	fe0510e3          	bnez	a0,4001538c <net_icmpv4_send_error+0x12c>
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
400153b0:	00400613          	li	a2,4
400153b4:	00000593          	li	a1,0
400153b8:	00040513          	mv	a0,s0
400153bc:	de8fe0ef          	jal	ra,400139a4 <net_pkt_memset>
	    icmpv4_create(pkt, type, code) ||
400153c0:	fc0516e3          	bnez	a0,4001538c <net_icmpv4_send_error+0x12c>
	    net_pkt_copy(pkt, orig, copy_len)) {
400153c4:	000a0613          	mv	a2,s4
400153c8:	00048593          	mv	a1,s1
400153cc:	00040513          	mv	a0,s0
400153d0:	e60fe0ef          	jal	ra,40013a30 <net_pkt_copy>
400153d4:	00050913          	mv	s2,a0
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
400153d8:	fa051ae3          	bnez	a0,4001538c <net_icmpv4_send_error+0x12c>
	net_pkt_cursor_init(pkt);
400153dc:	00040513          	mv	a0,s0
400153e0:	e11fd0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	net_ipv4_finalize(pkt, IPPROTO_ICMP);
400153e4:	00100593          	li	a1,1
400153e8:	00040513          	mv	a0,s0
400153ec:	3fc000ef          	jal	ra,400157e8 <net_ipv4_finalize>
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
400153f0:	0244a783          	lw	a5,36(s1)
	if (net_send_data(pkt) >= 0) {
400153f4:	00040513          	mv	a0,s0
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
400153f8:	02f42623          	sw	a5,44(s0)
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;
400153fc:	0284c783          	lbu	a5,40(s1)
40015400:	02f40823          	sb	a5,48(s0)
	if (net_send_data(pkt) >= 0) {
40015404:	ac4f60ef          	jal	ra,4000b6c8 <net_send_data>
40015408:	ee0554e3          	bgez	a0,400152f0 <net_icmpv4_send_error+0x90>
drop:
4001540c:	f81ff06f          	j	4001538c <net_icmpv4_send_error+0x12c>

40015410 <net_icmpv4_register_handler>:
	return list->head;
40015410:	400317b7          	lui	a5,0x40031
40015414:	a9878793          	addi	a5,a5,-1384 # 40030a98 <handlers>
40015418:	0007a703          	lw	a4,0(a5)
	parent->next = child;
4001541c:	00e52023          	sw	a4,0(a0)
Z_GENLIST_PREPEND(slist, snode)
40015420:	0047a703          	lw	a4,4(a5)
	list->head = node;
40015424:	00a7a023          	sw	a0,0(a5)
Z_GENLIST_PREPEND(slist, snode)
40015428:	00071463          	bnez	a4,40015430 <net_icmpv4_register_handler+0x20>
	list->tail = node;
4001542c:	00a7a223          	sw	a0,4(a5)

void net_icmpv4_register_handler(struct net_icmpv4_handler *handler)
{
	sys_slist_prepend(&handlers, &handler->node);
}
40015430:	00008067          	ret

40015434 <net_icmpv4_unregister_handler>:
	return list->head;
40015434:	400317b7          	lui	a5,0x40031
40015438:	a987a703          	lw	a4,-1384(a5) # 40030a98 <handlers>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4001543c:	00000693          	li	a3,0
40015440:	a9878793          	addi	a5,a5,-1384
40015444:	00071463          	bnez	a4,4001544c <net_icmpv4_unregister_handler+0x18>

void net_icmpv4_unregister_handler(struct net_icmpv4_handler *handler)
{
	sys_slist_find_and_remove(&handlers, &handler->node);
}
40015448:	00008067          	ret
4001544c:	02e51c63          	bne	a0,a4,40015484 <net_icmpv4_unregister_handler+0x50>
	return node->next;
40015450:	00052703          	lw	a4,0(a0)
Z_GENLIST_REMOVE(slist, snode)
40015454:	00069e63          	bnez	a3,40015470 <net_icmpv4_unregister_handler+0x3c>
40015458:	0047a683          	lw	a3,4(a5)
	list->head = node;
4001545c:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_REMOVE(slist, snode)
40015460:	00d51463          	bne	a0,a3,40015468 <net_icmpv4_unregister_handler+0x34>
	list->tail = node;
40015464:	00e7a223          	sw	a4,4(a5)
	parent->next = child;
40015468:	00052023          	sw	zero,0(a0)
Z_GENLIST_REMOVE(slist, snode)
4001546c:	00008067          	ret
	parent->next = child;
40015470:	00e6a023          	sw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
40015474:	0047a703          	lw	a4,4(a5)
40015478:	fee518e3          	bne	a0,a4,40015468 <net_icmpv4_unregister_handler+0x34>
	list->tail = node;
4001547c:	00d7a223          	sw	a3,4(a5)
}
40015480:	fe9ff06f          	j	40015468 <net_icmpv4_unregister_handler+0x34>
	return node->next;
40015484:	00070693          	mv	a3,a4
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40015488:	00072703          	lw	a4,0(a4)
4001548c:	fb9ff06f          	j	40015444 <net_icmpv4_unregister_handler+0x10>

40015490 <net_icmpv4_input>:

enum net_verdict net_icmpv4_input(struct net_pkt *pkt,
				  struct net_ipv4_hdr *ip_hdr)
{
40015490:	fe010113          	addi	sp,sp,-32
40015494:	01212823          	sw	s2,16(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
40015498:	00400793          	li	a5,4
{
4001549c:	00058913          	mv	s2,a1
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;
	struct net_icmpv4_handler *cb;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
400154a0:	00810593          	addi	a1,sp,8
{
400154a4:	00812c23          	sw	s0,24(sp)
400154a8:	00112e23          	sw	ra,28(sp)
400154ac:	00912a23          	sw	s1,20(sp)
400154b0:	00050413          	mv	s0,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
400154b4:	00012423          	sw	zero,8(sp)
400154b8:	00f12623          	sw	a5,12(sp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
400154bc:	ac1fe0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!icmp_hdr) {
400154c0:	02051063          	bnez	a0,400154e0 <net_icmpv4_input+0x50>
		NET_DBG("DROP: NULL ICMPv4 header");
		return NET_DROP;
400154c4:	00200513          	li	a0,2

drop:
	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
400154c8:	01c12083          	lw	ra,28(sp)
400154cc:	01812403          	lw	s0,24(sp)
400154d0:	01412483          	lw	s1,20(sp)
400154d4:	01012903          	lw	s2,16(sp)
400154d8:	02010113          	addi	sp,sp,32
400154dc:	00008067          	ret
400154e0:	00050493          	mv	s1,a0
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
400154e4:	01842503          	lw	a0,24(s0)
400154e8:	8f0fa0ef          	jal	ra,4000f5d8 <net_if_need_calc_rx_checksum>
400154ec:	06051063          	bnez	a0,4001554c <net_icmpv4_input+0xbc>
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
400154f0:	01842503          	lw	a0,24(s0)
400154f4:	01090593          	addi	a1,s2,16
400154f8:	861ff0ef          	jal	ra,40014d58 <net_ipv4_is_addr_bcast>
400154fc:	fc0514e3          	bnez	a0,400154c4 <net_icmpv4_input+0x34>
 * Packet needs to be set to overwrite mode.
 */
static inline int net_pkt_acknowledge_data(struct net_pkt *pkt,
					   struct net_pkt_data_access *access)
{
	return net_pkt_skip(pkt, access->size);
40015500:	00c12583          	lw	a1,12(sp)
40015504:	00040513          	mv	a0,s0
40015508:	a5cfe0ef          	jal	ra,40013764 <net_pkt_skip>
	return list->head;
4001550c:	400317b7          	lui	a5,0x40031
40015510:	a987a783          	lw	a5,-1384(a5) # 40030a98 <handlers>
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
40015514:	fa0788e3          	beqz	a5,400154c4 <net_icmpv4_input+0x34>
		if (cb->type == icmp_hdr->type &&
40015518:	0087c683          	lbu	a3,8(a5)
4001551c:	0004c703          	lbu	a4,0(s1)
40015520:	04e69063          	bne	a3,a4,40015560 <net_icmpv4_input+0xd0>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
40015524:	0097c703          	lbu	a4,9(a5)
		if (cb->type == icmp_hdr->type &&
40015528:	0014c683          	lbu	a3,1(s1)
4001552c:	00e68463          	beq	a3,a4,40015534 <net_icmpv4_input+0xa4>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
40015530:	02071863          	bnez	a4,40015560 <net_icmpv4_input+0xd0>
			return cb->handler(pkt, ip_hdr, icmp_hdr);
40015534:	0047a783          	lw	a5,4(a5)
40015538:	00048613          	mv	a2,s1
4001553c:	00090593          	mv	a1,s2
40015540:	00040513          	mv	a0,s0
40015544:	000780e7          	jalr	a5
40015548:	f81ff06f          	j	400154c8 <net_icmpv4_input+0x38>
4001554c:	00100593          	li	a1,1
40015550:	00040513          	mv	a0,s0
40015554:	a00fb0ef          	jal	ra,40010754 <net_calc_chksum>
		if (net_calc_chksum_icmpv4(pkt) != 0U) {
40015558:	f8050ce3          	beqz	a0,400154f0 <net_icmpv4_input+0x60>
4001555c:	f69ff06f          	j	400154c4 <net_icmpv4_input+0x34>
	return node->next;
40015560:	0007a783          	lw	a5,0(a5)
40015564:	fb1ff06f          	j	40015514 <net_icmpv4_input+0x84>

40015568 <net_icmpv4_init>:
	.handler = icmpv4_handle_echo_request,
};

void net_icmpv4_init(void)
{
	net_icmpv4_register_handler(&echo_request_handler);
40015568:	4003c537          	lui	a0,0x4003c
4001556c:	39050513          	addi	a0,a0,912 # 4003c390 <echo_request_handler>
40015570:	ea1ff06f          	j	40015410 <net_icmpv4_register_handler>

40015574 <net_ipv4_is_addr_mcast>:
40015574:	00054503          	lbu	a0,0(a0)
40015578:	f00007b7          	lui	a5,0xf0000
4001557c:	01851513          	slli	a0,a0,0x18
40015580:	00f57533          	and	a0,a0,a5
40015584:	200007b7          	lui	a5,0x20000
40015588:	00f50533          	add	a0,a0,a5
}
4001558c:	00153513          	seqz	a0,a0
40015590:	00008067          	ret

40015594 <net_ipv4_is_addr_bcast>:
{
40015594:	fe010113          	addi	sp,sp,-32
40015598:	00812c23          	sw	s0,24(sp)
4001559c:	00b12623          	sw	a1,12(sp)
400155a0:	00112e23          	sw	ra,28(sp)
400155a4:	00050413          	mv	s0,a0
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
400155a8:	eb8fb0ef          	jal	ra,40010c60 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
400155ac:	00c12583          	lw	a1,12(sp)
400155b0:	00054683          	lbu	a3,0(a0)
400155b4:	0015c703          	lbu	a4,1(a1)
400155b8:	0005c783          	lbu	a5,0(a1)
400155bc:	00871713          	slli	a4,a4,0x8
400155c0:	00f76733          	or	a4,a4,a5
400155c4:	0025c783          	lbu	a5,2(a1)
400155c8:	01079793          	slli	a5,a5,0x10
400155cc:	00e7e7b3          	or	a5,a5,a4
400155d0:	0035c703          	lbu	a4,3(a1)
400155d4:	01871713          	slli	a4,a4,0x18
400155d8:	00f76733          	or	a4,a4,a5
400155dc:	00154783          	lbu	a5,1(a0)
400155e0:	00879793          	slli	a5,a5,0x8
400155e4:	00d7e7b3          	or	a5,a5,a3
400155e8:	00254683          	lbu	a3,2(a0)
400155ec:	01069693          	slli	a3,a3,0x10
400155f0:	00f6e6b3          	or	a3,a3,a5
400155f4:	00354783          	lbu	a5,3(a0)
400155f8:	01879793          	slli	a5,a5,0x18
400155fc:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
40015600:	00f70c63          	beq	a4,a5,40015618 <net_ipv4_is_addr_bcast+0x84>
	return net_if_ipv4_is_addr_bcast(iface, addr);
40015604:	00040513          	mv	a0,s0
}
40015608:	01812403          	lw	s0,24(sp)
4001560c:	01c12083          	lw	ra,28(sp)
40015610:	02010113          	addi	sp,sp,32
	return net_if_ipv4_is_addr_bcast(iface, addr);
40015614:	dbcf906f          	j	4000ebd0 <net_if_ipv4_is_addr_bcast>
}
40015618:	01c12083          	lw	ra,28(sp)
4001561c:	01812403          	lw	s0,24(sp)
40015620:	00100513          	li	a0,1
40015624:	02010113          	addi	sp,sp,32
40015628:	00008067          	ret

4001562c <net_ipv4_create_full>:
			 uint8_t tos,
			 uint16_t id,
			 uint8_t flags,
			 uint16_t offset,
			 uint8_t ttl)
{
4001562c:	fc010113          	addi	sp,sp,-64
40015630:	03212823          	sw	s2,48(sp)
40015634:	03412423          	sw	s4,40(sp)
40015638:	00058913          	mv	s2,a1
4001563c:	00078a13          	mv	s4,a5
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
	struct net_ipv4_hdr *ipv4_hdr;

	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
40015640:	00810593          	addi	a1,sp,8
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
40015644:	01400793          	li	a5,20
{
40015648:	02912a23          	sw	s1,52(sp)
4001564c:	03312623          	sw	s3,44(sp)
40015650:	03512223          	sw	s5,36(sp)
40015654:	03612023          	sw	s6,32(sp)
40015658:	01712e23          	sw	s7,28(sp)
4001565c:	01812c23          	sw	s8,24(sp)
40015660:	02112e23          	sw	ra,60(sp)
40015664:	02812c23          	sw	s0,56(sp)
40015668:	00050493          	mv	s1,a0
4001566c:	00060993          	mv	s3,a2
40015670:	00068c13          	mv	s8,a3
40015674:	00070b93          	mv	s7,a4
40015678:	00080b13          	mv	s6,a6
4001567c:	00088a93          	mv	s5,a7
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
40015680:	00012423          	sw	zero,8(sp)
40015684:	00f12623          	sw	a5,12(sp)
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
40015688:	8f5fe0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!ipv4_hdr) {
4001568c:	12050463          	beqz	a0,400157b4 <net_ipv4_create_full+0x188>
		return -ENOBUFS;
	}

	ipv4_hdr->vhl       = 0x45;
40015690:	04500793          	li	a5,69
40015694:	00f50023          	sb	a5,0(a0)
	ipv4_hdr->tos       = tos;
	ipv4_hdr->len       = 0U;
	ipv4_hdr->id[0]     = id >> 8;
40015698:	008bd793          	srli	a5,s7,0x8
4001569c:	00f50223          	sb	a5,4(a0)
	ipv4_hdr->id[1]     = id;
	ipv4_hdr->offset[0] = (offset >> 8) | (flags << 5);
400156a0:	005a1a13          	slli	s4,s4,0x5
400156a4:	008b5793          	srli	a5,s6,0x8
400156a8:	0147e7b3          	or	a5,a5,s4
	ipv4_hdr->tos       = tos;
400156ac:	018500a3          	sb	s8,1(a0)
	ipv4_hdr->len       = 0U;
400156b0:	00050123          	sb	zero,2(a0)
400156b4:	000501a3          	sb	zero,3(a0)
	ipv4_hdr->id[1]     = id;
400156b8:	017502a3          	sb	s7,5(a0)
	ipv4_hdr->offset[0] = (offset >> 8) | (flags << 5);
400156bc:	00f50323          	sb	a5,6(a0)
	ipv4_hdr->offset[1] = offset;
400156c0:	016503a3          	sb	s6,7(a0)
	ipv4_hdr->ttl       = ttl;
400156c4:	01550423          	sb	s5,8(a0)
400156c8:	00050413          	mv	s0,a0

	if (ttl == 0U) {
400156cc:	000a9863          	bnez	s5,400156dc <net_ipv4_create_full+0xb0>
		ipv4_hdr->ttl = net_if_ipv4_get_ttl(net_pkt_iface(pkt));
400156d0:	0184a503          	lw	a0,24(s1)
400156d4:	b90f90ef          	jal	ra,4000ea64 <net_if_ipv4_get_ttl>
400156d8:	00a40423          	sb	a0,8(s0)
	}

	ipv4_hdr->proto     = 0U;
400156dc:	000404a3          	sb	zero,9(s0)
	ipv4_hdr->chksum    = 0U;
400156e0:	00040523          	sb	zero,10(s0)
400156e4:	000405a3          	sb	zero,11(s0)
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
400156e8:	0019c783          	lbu	a5,1(s3)
400156ec:	0009c703          	lbu	a4,0(s3)
	net_ipv4_addr_copy_raw(ipv4_hdr->dst, (uint8_t *)dst);
	net_ipv4_addr_copy_raw(ipv4_hdr->src, (uint8_t *)src);

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv4_hdr));

	return net_pkt_set_data(pkt, &ipv4_access);
400156f0:	00810593          	addi	a1,sp,8
400156f4:	00879793          	slli	a5,a5,0x8
400156f8:	00e7e7b3          	or	a5,a5,a4
400156fc:	0029c703          	lbu	a4,2(s3)
40015700:	00048513          	mv	a0,s1
40015704:	01071713          	slli	a4,a4,0x10
40015708:	00f76733          	or	a4,a4,a5
4001570c:	0039c783          	lbu	a5,3(s3)
40015710:	00e40823          	sb	a4,16(s0)
40015714:	01879793          	slli	a5,a5,0x18
40015718:	00e7e7b3          	or	a5,a5,a4
4001571c:	0087d713          	srli	a4,a5,0x8
40015720:	00e408a3          	sb	a4,17(s0)
40015724:	0107d713          	srli	a4,a5,0x10
40015728:	0187d793          	srli	a5,a5,0x18
4001572c:	00e40923          	sb	a4,18(s0)
40015730:	00f409a3          	sb	a5,19(s0)
40015734:	00194783          	lbu	a5,1(s2)
40015738:	00094703          	lbu	a4,0(s2)
4001573c:	00879793          	slli	a5,a5,0x8
40015740:	00e7e7b3          	or	a5,a5,a4
40015744:	00294703          	lbu	a4,2(s2)
40015748:	01071713          	slli	a4,a4,0x10
4001574c:	00f76733          	or	a4,a4,a5
40015750:	00394783          	lbu	a5,3(s2)
40015754:	00e40623          	sb	a4,12(s0)
40015758:	01879793          	slli	a5,a5,0x18
4001575c:	00e7e7b3          	or	a5,a5,a4
40015760:	0087d713          	srli	a4,a5,0x8
40015764:	00e406a3          	sb	a4,13(s0)
40015768:	0107d713          	srli	a4,a5,0x10
4001576c:	0187d793          	srli	a5,a5,0x18
40015770:	00f407a3          	sb	a5,15(s0)
40015774:	00e40723          	sb	a4,14(s0)
	pkt->ip_hdr_len = len;
40015778:	01400793          	li	a5,20
4001577c:	02f48b23          	sb	a5,54(s1)
40015780:	88dfe0ef          	jal	ra,4001400c <net_pkt_set_data>
}
40015784:	03c12083          	lw	ra,60(sp)
40015788:	03812403          	lw	s0,56(sp)
4001578c:	03412483          	lw	s1,52(sp)
40015790:	03012903          	lw	s2,48(sp)
40015794:	02c12983          	lw	s3,44(sp)
40015798:	02812a03          	lw	s4,40(sp)
4001579c:	02412a83          	lw	s5,36(sp)
400157a0:	02012b03          	lw	s6,32(sp)
400157a4:	01c12b83          	lw	s7,28(sp)
400157a8:	01812c03          	lw	s8,24(sp)
400157ac:	04010113          	addi	sp,sp,64
400157b0:	00008067          	ret
		return -ENOBUFS;
400157b4:	f9700513          	li	a0,-105
400157b8:	fcdff06f          	j	40015784 <net_ipv4_create_full+0x158>

400157bc <net_ipv4_create>:
	return pkt->ip_dscp;
400157bc:	04052783          	lw	a5,64(a0)
	if (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {
		net_ipv4_set_dscp(&tos, net_pkt_ip_dscp(pkt));
		net_ipv4_set_ecn(&tos, net_pkt_ip_ecn(pkt));
	}

	return net_ipv4_create_full(pkt, src, dst, tos, 0U, 0U, 0U,
400157c0:	03954883          	lbu	a7,57(a0)
400157c4:	00000813          	li	a6,0
 * @param dscp DSCP value to set.
 */
static inline void net_ipv4_set_dscp(uint8_t *tos, uint8_t dscp)
{
	*tos &= ~NET_IPV4_DSCP_MASK;
	*tos |= (dscp << NET_IPV4_DSCP_OFFSET) & NET_IPV4_DSCP_MASK;
400157c8:	03f7f313          	andi	t1,a5,63
	return pkt->ip_ecn;
400157cc:	0067d793          	srli	a5,a5,0x6
400157d0:	0037f693          	andi	a3,a5,3
400157d4:	00231313          	slli	t1,t1,0x2
400157d8:	00000793          	li	a5,0
400157dc:	00000713          	li	a4,0
400157e0:	00d366b3          	or	a3,t1,a3
400157e4:	e49ff06f          	j	4001562c <net_ipv4_create_full>

400157e8 <net_ipv4_finalize>:
				    net_pkt_ipv4_ttl(pkt));
}

int net_ipv4_finalize(struct net_pkt *pkt, uint8_t next_header_proto)
{
400157e8:	fe010113          	addi	sp,sp,-32
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
400157ec:	01400793          	li	a5,20
{
400157f0:	00812c23          	sw	s0,24(sp)
400157f4:	01212823          	sw	s2,16(sp)
400157f8:	00112e23          	sw	ra,28(sp)
400157fc:	00912a23          	sw	s1,20(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
40015800:	00012423          	sw	zero,8(sp)
40015804:	00f12623          	sw	a5,12(sp)
	pkt->overwrite = overwrite;
40015808:	03754783          	lbu	a5,55(a0)
{
4001580c:	00058913          	mv	s2,a1
	struct net_ipv4_hdr *ipv4_hdr;

	net_pkt_set_overwrite(pkt, true);

	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
40015810:	00810593          	addi	a1,sp,8
40015814:	0017e793          	ori	a5,a5,1
40015818:	02f50ba3          	sb	a5,55(a0)
{
4001581c:	00050413          	mv	s0,a0
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
40015820:	f5cfe0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!ipv4_hdr) {
40015824:	0c050863          	beqz	a0,400158f4 <net_ipv4_finalize+0x10c>
40015828:	00842703          	lw	a4,8(s0)
4001582c:	00050493          	mv	s1,a0
	size_t bytes = 0;
40015830:	00000793          	li	a5,0
	while (buf) {
40015834:	08071263          	bnez	a4,400158b8 <net_ipv4_finalize+0xd0>
					((net_pkt_ip_hdr_len(pkt) +
					  net_pkt_ipv4_opts_len(pkt)) / 4U));
		}
	}

	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
40015838:	00879713          	slli	a4,a5,0x8
4001583c:	01079793          	slli	a5,a5,0x10
40015840:	0107d793          	srli	a5,a5,0x10
40015844:	0087d793          	srli	a5,a5,0x8
40015848:	00f767b3          	or	a5,a4,a5
4001584c:	01079713          	slli	a4,a5,0x10
40015850:	01075713          	srli	a4,a4,0x10
40015854:	00f48123          	sb	a5,2(s1)
40015858:	00875793          	srli	a5,a4,0x8
4001585c:	00f481a3          	sb	a5,3(s1)
	ipv4_hdr->proto = next_header_proto;
40015860:	012484a3          	sb	s2,9(s1)

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
40015864:	01842503          	lw	a0,24(s0)
40015868:	d69f90ef          	jal	ra,4000f5d0 <net_if_need_calc_tx_checksum>
4001586c:	00050c63          	beqz	a0,40015884 <net_ipv4_finalize+0x9c>
		ipv4_hdr->chksum = net_calc_chksum_ipv4(pkt);
40015870:	00040513          	mv	a0,s0
40015874:	914fb0ef          	jal	ra,40010988 <net_calc_chksum_ipv4>
40015878:	00a48523          	sb	a0,10(s1)
4001587c:	00855513          	srli	a0,a0,0x8
40015880:	00a485a3          	sb	a0,11(s1)
	}

	net_pkt_set_data(pkt, &ipv4_access);
40015884:	00810593          	addi	a1,sp,8
40015888:	00040513          	mv	a0,s0
4001588c:	f80fe0ef          	jal	ra,4001400c <net_pkt_set_data>

	if (IS_ENABLED(CONFIG_NET_UDP) &&
40015890:	01100793          	li	a5,17
40015894:	02f91a63          	bne	s2,a5,400158c8 <net_ipv4_finalize+0xe0>
	    next_header_proto == IPPROTO_UDP) {
		return net_udp_finalize(pkt);
40015898:	00040513          	mv	a0,s0
4001589c:	7a8090ef          	jal	ra,4001f044 <net_udp_finalize>
	} else if (next_header_proto == IPPROTO_ICMP) {
		return net_icmpv4_finalize(pkt);
	}

	return 0;
}
400158a0:	01c12083          	lw	ra,28(sp)
400158a4:	01812403          	lw	s0,24(sp)
400158a8:	01412483          	lw	s1,20(sp)
400158ac:	01012903          	lw	s2,16(sp)
400158b0:	02010113          	addi	sp,sp,32
400158b4:	00008067          	ret
		bytes += buf->len;
400158b8:	01075683          	lhu	a3,16(a4)
		buf = buf->frags;
400158bc:	00472703          	lw	a4,4(a4)
		bytes += buf->len;
400158c0:	00d787b3          	add	a5,a5,a3
		buf = buf->frags;
400158c4:	f71ff06f          	j	40015834 <net_ipv4_finalize+0x4c>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
400158c8:	00600793          	li	a5,6
400158cc:	00f91863          	bne	s2,a5,400158dc <net_ipv4_finalize+0xf4>
		return net_tcp_finalize(pkt);
400158d0:	00040513          	mv	a0,s0
400158d4:	604060ef          	jal	ra,4001bed8 <net_tcp_finalize>
400158d8:	fc9ff06f          	j	400158a0 <net_ipv4_finalize+0xb8>
	} else if (next_header_proto == IPPROTO_ICMP) {
400158dc:	00100793          	li	a5,1
	return 0;
400158e0:	00000513          	li	a0,0
	} else if (next_header_proto == IPPROTO_ICMP) {
400158e4:	faf91ee3          	bne	s2,a5,400158a0 <net_ipv4_finalize+0xb8>
		return net_icmpv4_finalize(pkt);
400158e8:	00040513          	mv	a0,s0
400158ec:	ec4ff0ef          	jal	ra,40014fb0 <net_icmpv4_finalize>
400158f0:	fb1ff06f          	j	400158a0 <net_ipv4_finalize+0xb8>
		return -ENOBUFS;
400158f4:	f9700513          	li	a0,-105
400158f8:	fa9ff06f          	j	400158a0 <net_ipv4_finalize+0xb8>

400158fc <net_ipv4_input>:
	return 0;
}
#endif

enum net_verdict net_ipv4_input(struct net_pkt *pkt)
{
400158fc:	f9010113          	addi	sp,sp,-112
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
40015900:	01400793          	li	a5,20
{
40015904:	06912223          	sw	s1,100(sp)
40015908:	05312e23          	sw	s3,92(sp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
4001590c:	02410713          	addi	a4,sp,36
{
40015910:	06112623          	sw	ra,108(sp)
40015914:	06812423          	sw	s0,104(sp)
40015918:	07212023          	sw	s2,96(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
4001591c:	02f12023          	sw	a5,32(sp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
40015920:	02e12623          	sw	a4,44(sp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
40015924:	02f12c23          	sw	a5,56(sp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
40015928:	00800713          	li	a4,8
4001592c:	00852783          	lw	a5,8(a0)
40015930:	02e12823          	sw	a4,48(sp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
40015934:	03c10713          	addi	a4,sp,60
{
40015938:	00050493          	mv	s1,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
4001593c:	00012e23          	sw	zero,28(sp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
40015940:	02e12a23          	sw	a4,52(sp)
	size_t bytes = 0;
40015944:	00000993          	li	s3,0
	while (buf) {
40015948:	02079c63          	bnez	a5,40015980 <net_ipv4_input+0x84>
	net_pkt_cursor_backup(pkt, &hdr_start);
#endif

	net_stats_update_ipv4_recv(net_pkt_iface(pkt));

	hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
4001594c:	01c10593          	addi	a1,sp,28
40015950:	00048513          	mv	a0,s1
40015954:	e28fe0ef          	jal	ra,40013f7c <net_pkt_get_data>
40015958:	00050413          	mv	s0,a0
	if (!hdr) {
4001595c:	02051a63          	bnez	a0,40015990 <net_ipv4_input+0x94>
		return verdict;
	}

drop:
	net_stats_update_ipv4_drop(net_pkt_iface(pkt));
	return NET_DROP;
40015960:	00200513          	li	a0,2
}
40015964:	06c12083          	lw	ra,108(sp)
40015968:	06812403          	lw	s0,104(sp)
4001596c:	06412483          	lw	s1,100(sp)
40015970:	06012903          	lw	s2,96(sp)
40015974:	05c12983          	lw	s3,92(sp)
40015978:	07010113          	addi	sp,sp,112
4001597c:	00008067          	ret
		bytes += buf->len;
40015980:	0107d703          	lhu	a4,16(a5) # 20000010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1a0a1f10>
		buf = buf->frags;
40015984:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
40015988:	00e989b3          	add	s3,s3,a4
		buf = buf->frags;
4001598c:	fbdff06f          	j	40015948 <net_ipv4_input+0x4c>
	hdr_len = (hdr->vhl & NET_IPV4_IHL_MASK) * 4U;
40015990:	00054903          	lbu	s2,0(a0)
	if (hdr_len < sizeof(struct net_ipv4_hdr)) {
40015994:	01300793          	li	a5,19
	hdr_len = (hdr->vhl & NET_IPV4_IHL_MASK) * 4U;
40015998:	00f97913          	andi	s2,s2,15
4001599c:	00291913          	slli	s2,s2,0x2
	if (hdr_len < sizeof(struct net_ipv4_hdr)) {
400159a0:	fd27f0e3          	bgeu	a5,s2,40015960 <net_ipv4_input+0x64>
	pkt->ip_hdr_len = len;
400159a4:	01400793          	li	a5,20
400159a8:	02f48b23          	sb	a5,54(s1)
	return (tos & NET_IPV4_DSCP_MASK) >> NET_IPV4_DSCP_OFFSET;
400159ac:	00154703          	lbu	a4,1(a0)
	pkt->ip_dscp = dscp;
400159b0:	0404c783          	lbu	a5,64(s1)
	opts_len = hdr_len - sizeof(struct net_ipv4_hdr);
400159b4:	fec90913          	addi	s2,s2,-20
400159b8:	00275713          	srli	a4,a4,0x2
400159bc:	fc07f793          	andi	a5,a5,-64
400159c0:	00e7e7b3          	or	a5,a5,a4
400159c4:	04f48023          	sb	a5,64(s1)
	pkt->ip_ecn = ecn;
400159c8:	00154703          	lbu	a4,1(a0)
400159cc:	0ff7f793          	zext.b	a5,a5
400159d0:	03f7f793          	andi	a5,a5,63
400159d4:	00671713          	slli	a4,a4,0x6
400159d8:	00e7e7b3          	or	a5,a5,a4
400159dc:	04f48023          	sb	a5,64(s1)
	if (hdr->ttl == 0) {
400159e0:	00854783          	lbu	a5,8(a0)
	opts_len = hdr_len - sizeof(struct net_ipv4_hdr);
400159e4:	0ff97913          	zext.b	s2,s2
	if (hdr->ttl == 0) {
400159e8:	f6078ce3          	beqz	a5,40015960 <net_ipv4_input+0x64>
	pkt->ipv4_opts_len = opts_len;
400159ec:	03248d23          	sb	s2,58(s1)
	pkt_len = ntohs(hdr->len);
400159f0:	00354783          	lbu	a5,3(a0)
400159f4:	00254703          	lbu	a4,2(a0)
400159f8:	00879793          	slli	a5,a5,0x8
400159fc:	00e7e7b3          	or	a5,a5,a4
40015a00:	00879593          	slli	a1,a5,0x8
40015a04:	0087d793          	srli	a5,a5,0x8
40015a08:	00f5e5b3          	or	a1,a1,a5
40015a0c:	01059593          	slli	a1,a1,0x10
40015a10:	0105d593          	srli	a1,a1,0x10
	if (real_len < pkt_len) {
40015a14:	f4b9c6e3          	blt	s3,a1,40015960 <net_ipv4_input+0x64>
	} else if (real_len > pkt_len) {
40015a18:	0135d663          	bge	a1,s3,40015a24 <net_ipv4_input+0x128>
		net_pkt_update_length(pkt, pkt_len);
40015a1c:	00048513          	mv	a0,s1
40015a20:	998fe0ef          	jal	ra,40013bb8 <net_pkt_update_length>
	if (net_ipv4_is_addr_mcast((struct in_addr *)hdr->src)) {
40015a24:	00c40593          	addi	a1,s0,12
40015a28:	00058513          	mv	a0,a1
40015a2c:	00b12623          	sw	a1,12(sp)
40015a30:	b45ff0ef          	jal	ra,40015574 <net_ipv4_is_addr_mcast>
40015a34:	f20516e3          	bnez	a0,40015960 <net_ipv4_input+0x64>
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt), (struct in_addr *)hdr->src)) {
40015a38:	00c12583          	lw	a1,12(sp)
40015a3c:	0184a503          	lw	a0,24(s1)
40015a40:	b55ff0ef          	jal	ra,40015594 <net_ipv4_is_addr_bcast>
40015a44:	f0051ee3          	bnez	a0,40015960 <net_ipv4_input+0x64>
	return UNALIGNED_GET(&addr->s_addr) == 0;
40015a48:	00d44783          	lbu	a5,13(s0)
40015a4c:	00c44703          	lbu	a4,12(s0)
	return pkt->iface;
40015a50:	0184a503          	lw	a0,24(s1)
40015a54:	00879793          	slli	a5,a5,0x8
40015a58:	00e7e7b3          	or	a5,a5,a4
40015a5c:	00e44703          	lbu	a4,14(s0)
40015a60:	01071713          	slli	a4,a4,0x10
40015a64:	00f76733          	or	a4,a4,a5
40015a68:	00f44783          	lbu	a5,15(s0)
40015a6c:	01879793          	slli	a5,a5,0x18
40015a70:	00e7e7b3          	or	a5,a5,a4
	if (net_ipv4_is_addr_unspecified((struct in_addr *)hdr->src) &&
40015a74:	12078063          	beqz	a5,40015b94 <net_ipv4_input+0x298>
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
40015a78:	0184a503          	lw	a0,24(s1)
40015a7c:	b5df90ef          	jal	ra,4000f5d8 <net_if_need_calc_rx_checksum>
40015a80:	12051263          	bnez	a0,40015ba4 <net_ipv4_input+0x2a8>
	if ((!net_ipv4_is_my_addr((struct in_addr *)hdr->dst) &&
40015a84:	01040993          	addi	s3,s0,16
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
40015a88:	00000593          	li	a1,0
40015a8c:	00098513          	mv	a0,s3
40015a90:	b7cf90ef          	jal	ra,4000ee0c <net_if_ipv4_addr_lookup>
	if (!ret) {
40015a94:	08051063          	bnez	a0,40015b14 <net_ipv4_input+0x218>
		ret = net_ipv4_is_addr_bcast(NULL, addr);
40015a98:	00098593          	mv	a1,s3
40015a9c:	af9ff0ef          	jal	ra,40015594 <net_ipv4_is_addr_bcast>
40015aa0:	06051a63          	bnez	a0,40015b14 <net_ipv4_input+0x218>
	     !net_ipv4_is_addr_mcast((struct in_addr *)hdr->dst) &&
40015aa4:	00098513          	mv	a0,s3
40015aa8:	acdff0ef          	jal	ra,40015574 <net_ipv4_is_addr_mcast>
	     !(hdr->proto == IPPROTO_UDP &&
40015aac:	00944703          	lbu	a4,9(s0)
	if ((!net_ipv4_is_my_addr((struct in_addr *)hdr->dst) &&
40015ab0:	06051263          	bnez	a0,40015b14 <net_ipv4_input+0x218>
	     !net_ipv4_is_addr_mcast((struct in_addr *)hdr->dst) &&
40015ab4:	01100793          	li	a5,17
40015ab8:	eaf714e3          	bne	a4,a5,40015960 <net_ipv4_input+0x64>
	       (net_ipv4_addr_cmp((struct in_addr *)hdr->dst, net_ipv4_broadcast_address()) ||
40015abc:	9a4fb0ef          	jal	ra,40010c60 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40015ac0:	01144703          	lbu	a4,17(s0)
40015ac4:	01044783          	lbu	a5,16(s0)
40015ac8:	00054683          	lbu	a3,0(a0)
40015acc:	00871713          	slli	a4,a4,0x8
40015ad0:	00f76733          	or	a4,a4,a5
40015ad4:	01244783          	lbu	a5,18(s0)
40015ad8:	01079793          	slli	a5,a5,0x10
40015adc:	00e7e7b3          	or	a5,a5,a4
40015ae0:	01344703          	lbu	a4,19(s0)
40015ae4:	01871713          	slli	a4,a4,0x18
40015ae8:	00f76733          	or	a4,a4,a5
40015aec:	00154783          	lbu	a5,1(a0)
40015af0:	00879793          	slli	a5,a5,0x8
40015af4:	00d7e7b3          	or	a5,a5,a3
40015af8:	00254683          	lbu	a3,2(a0)
40015afc:	01069693          	slli	a3,a3,0x10
40015b00:	00f6e6b3          	or	a3,a3,a5
40015b04:	00354783          	lbu	a5,3(a0)
40015b08:	01879793          	slli	a5,a5,0x18
40015b0c:	00d7e7b3          	or	a5,a5,a3
	     !(hdr->proto == IPPROTO_UDP &&
40015b10:	e4f718e3          	bne	a4,a5,40015960 <net_ipv4_input+0x64>
				   net_ipv4_unspecified_address()))))) ||
40015b14:	00944703          	lbu	a4,9(s0)
40015b18:	00600793          	li	a5,6
40015b1c:	00f71a63          	bne	a4,a5,40015b30 <net_ipv4_input+0x234>
	     net_ipv4_is_addr_bcast(net_pkt_iface(pkt), (struct in_addr *)hdr->dst))) {
40015b20:	0184a503          	lw	a0,24(s1)
40015b24:	00098593          	mv	a1,s3
40015b28:	a6dff0ef          	jal	ra,40015594 <net_ipv4_is_addr_bcast>
	    (hdr->proto == IPPROTO_TCP &&
40015b2c:	e2051ae3          	bnez	a0,40015960 <net_ipv4_input+0x64>
	return net_pkt_skip(pkt, access->size);
40015b30:	02012583          	lw	a1,32(sp)
40015b34:	00048513          	mv	a0,s1
40015b38:	c2dfd0ef          	jal	ra,40013764 <net_pkt_skip>
	if (opts_len) {
40015b3c:	00090a63          	beqz	s2,40015b50 <net_ipv4_input+0x254>
		if (net_pkt_skip(pkt, opts_len)) {
40015b40:	00090593          	mv	a1,s2
40015b44:	00048513          	mv	a0,s1
40015b48:	c1dfd0ef          	jal	ra,40013764 <net_pkt_skip>
40015b4c:	e0051ae3          	bnez	a0,40015960 <net_ipv4_input+0x64>
	net_pkt_set_ipv4_ttl(pkt, hdr->ttl);
40015b50:	00844783          	lbu	a5,8(s0)
	switch (hdr->proto) {
40015b54:	00600713          	li	a4,6
	pkt->ipv4_ttl = ttl;
40015b58:	02f48ca3          	sb	a5,57(s1)
	pkt->family = family;
40015b5c:	0374c783          	lbu	a5,55(s1)
40015b60:	01f7f793          	andi	a5,a5,31
40015b64:	0207e793          	ori	a5,a5,32
40015b68:	02f48ba3          	sb	a5,55(s1)
40015b6c:	00944783          	lbu	a5,9(s0)
40015b70:	04e78263          	beq	a5,a4,40015bb4 <net_ipv4_input+0x2b8>
40015b74:	01100713          	li	a4,17
40015b78:	06e78663          	beq	a5,a4,40015be4 <net_ipv4_input+0x2e8>
40015b7c:	00100713          	li	a4,1
40015b80:	dee790e3          	bne	a5,a4,40015960 <net_ipv4_input+0x64>
		verdict = net_icmpv4_input(pkt, hdr);
40015b84:	00040593          	mv	a1,s0
40015b88:	00048513          	mv	a0,s1
40015b8c:	905ff0ef          	jal	ra,40015490 <net_icmpv4_input>
		if (verdict == NET_DROP) {
40015b90:	dd5ff06f          	j	40015964 <net_ipv4_input+0x68>
	    !net_ipv4_is_addr_bcast(net_pkt_iface(pkt), (struct in_addr *)hdr->dst)) {
40015b94:	01040593          	addi	a1,s0,16
40015b98:	9fdff0ef          	jal	ra,40015594 <net_ipv4_is_addr_bcast>
	if (net_ipv4_is_addr_unspecified((struct in_addr *)hdr->src) &&
40015b9c:	ec051ee3          	bnez	a0,40015a78 <net_ipv4_input+0x17c>
40015ba0:	dc1ff06f          	j	40015960 <net_ipv4_input+0x64>
	    net_calc_chksum_ipv4(pkt) != 0U) {
40015ba4:	00048513          	mv	a0,s1
40015ba8:	de1fa0ef          	jal	ra,40010988 <net_calc_chksum_ipv4>
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
40015bac:	ec050ce3          	beqz	a0,40015a84 <net_ipv4_input+0x188>
40015bb0:	db1ff06f          	j	40015960 <net_ipv4_input+0x64>
		proto_hdr.tcp = net_tcp_input(pkt, &tcp_access);
40015bb4:	03410593          	addi	a1,sp,52
40015bb8:	00048513          	mv	a0,s1
40015bbc:	3a4060ef          	jal	ra,4001bf60 <net_tcp_input>
40015bc0:	00a12a23          	sw	a0,20(sp)
		if (proto_hdr.tcp) {
40015bc4:	d8050ee3          	beqz	a0,40015960 <net_ipv4_input+0x64>
	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
40015bc8:	00944603          	lbu	a2,9(s0)
40015bcc:	01410693          	addi	a3,sp,20
40015bd0:	01810593          	addi	a1,sp,24
40015bd4:	00048513          	mv	a0,s1
	ip.ipv4 = hdr;
40015bd8:	00812c23          	sw	s0,24(sp)
	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
40015bdc:	c5dfe0ef          	jal	ra,40014838 <net_conn_input>
drop:
40015be0:	d85ff06f          	j	40015964 <net_ipv4_input+0x68>
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
40015be4:	02c10593          	addi	a1,sp,44
40015be8:	00048513          	mv	a0,s1
40015bec:	534090ef          	jal	ra,4001f120 <net_udp_input>
40015bf0:	fd1ff06f          	j	40015bc0 <net_ipv4_input+0x2c4>

40015bf4 <net_ipv4_init>:
void net_ipv4_init(void)
{
	if (IS_ENABLED(CONFIG_NET_IPV4_FRAGMENT)) {
		net_ipv4_setup_fragment_buffers();
	}
}
40015bf4:	00008067          	ret

40015bf8 <net_icmpv6_register_handler>:
	return list->head;
40015bf8:	400317b7          	lui	a5,0x40031
40015bfc:	aa078793          	addi	a5,a5,-1376 # 40030aa0 <handlers>
40015c00:	0007a703          	lw	a4,0(a5)
	parent->next = child;
40015c04:	00e52023          	sw	a4,0(a0)
Z_GENLIST_PREPEND(slist, snode)
40015c08:	0047a703          	lw	a4,4(a5)
	list->head = node;
40015c0c:	00a7a023          	sw	a0,0(a5)
Z_GENLIST_PREPEND(slist, snode)
40015c10:	00071463          	bnez	a4,40015c18 <net_icmpv6_register_handler+0x20>
	list->tail = node;
40015c14:	00a7a223          	sw	a0,4(a5)
}

void net_icmpv6_register_handler(struct net_icmpv6_handler *handler)
{
	sys_slist_prepend(&handlers, &handler->node);
}
40015c18:	00008067          	ret

40015c1c <net_icmpv6_unregister_handler>:
	return list->head;
40015c1c:	400317b7          	lui	a5,0x40031
40015c20:	aa07a703          	lw	a4,-1376(a5) # 40030aa0 <handlers>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40015c24:	00000693          	li	a3,0
40015c28:	aa078793          	addi	a5,a5,-1376
40015c2c:	00071463          	bnez	a4,40015c34 <net_icmpv6_unregister_handler+0x18>

void net_icmpv6_unregister_handler(struct net_icmpv6_handler *handler)
{
	sys_slist_find_and_remove(&handlers, &handler->node);
}
40015c30:	00008067          	ret
40015c34:	02e51c63          	bne	a0,a4,40015c6c <net_icmpv6_unregister_handler+0x50>
	return node->next;
40015c38:	00052703          	lw	a4,0(a0)
Z_GENLIST_REMOVE(slist, snode)
40015c3c:	00069e63          	bnez	a3,40015c58 <net_icmpv6_unregister_handler+0x3c>
40015c40:	0047a683          	lw	a3,4(a5)
	list->head = node;
40015c44:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_REMOVE(slist, snode)
40015c48:	00d51463          	bne	a0,a3,40015c50 <net_icmpv6_unregister_handler+0x34>
	list->tail = node;
40015c4c:	00e7a223          	sw	a4,4(a5)
	parent->next = child;
40015c50:	00052023          	sw	zero,0(a0)
Z_GENLIST_REMOVE(slist, snode)
40015c54:	00008067          	ret
	parent->next = child;
40015c58:	00e6a023          	sw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
40015c5c:	0047a703          	lw	a4,4(a5)
40015c60:	fee518e3          	bne	a0,a4,40015c50 <net_icmpv6_unregister_handler+0x34>
	list->tail = node;
40015c64:	00d7a223          	sw	a3,4(a5)
}
40015c68:	fe9ff06f          	j	40015c50 <net_icmpv6_unregister_handler+0x34>
	return node->next;
40015c6c:	00070693          	mv	a3,a4
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40015c70:	00072703          	lw	a4,0(a4)
40015c74:	fb9ff06f          	j	40015c2c <net_icmpv6_unregister_handler+0x10>

40015c78 <net_icmpv6_finalize>:

int net_icmpv6_finalize(struct net_pkt *pkt)
{
40015c78:	fe010113          	addi	sp,sp,-32
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
40015c7c:	00400793          	li	a5,4
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
40015c80:	00810593          	addi	a1,sp,8
{
40015c84:	00912a23          	sw	s1,20(sp)
40015c88:	00112e23          	sw	ra,28(sp)
40015c8c:	00812c23          	sw	s0,24(sp)
40015c90:	00050493          	mv	s1,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
40015c94:	00012423          	sw	zero,8(sp)
40015c98:	00f12623          	sw	a5,12(sp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
40015c9c:	ae0fe0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!icmp_hdr) {
40015ca0:	04050a63          	beqz	a0,40015cf4 <net_icmpv6_finalize+0x7c>
		return -ENOBUFS;
	}

	icmp_hdr->chksum = 0U;
40015ca4:	00050123          	sb	zero,2(a0)
40015ca8:	000501a3          	sb	zero,3(a0)
40015cac:	00050413          	mv	s0,a0
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
40015cb0:	0184a503          	lw	a0,24(s1)
40015cb4:	91df90ef          	jal	ra,4000f5d0 <net_if_need_calc_tx_checksum>
40015cb8:	00050e63          	beqz	a0,40015cd4 <net_icmpv6_finalize+0x5c>
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
40015cbc:	03a00593          	li	a1,58
40015cc0:	00048513          	mv	a0,s1
40015cc4:	a91fa0ef          	jal	ra,40010754 <net_calc_chksum>
		icmp_hdr->chksum = net_calc_chksum_icmpv6(pkt);
40015cc8:	00855793          	srli	a5,a0,0x8
40015ccc:	00a40123          	sb	a0,2(s0)
40015cd0:	00f401a3          	sb	a5,3(s0)
	}

	return net_pkt_set_data(pkt, &icmp_access);
40015cd4:	00810593          	addi	a1,sp,8
40015cd8:	00048513          	mv	a0,s1
40015cdc:	b30fe0ef          	jal	ra,4001400c <net_pkt_set_data>
}
40015ce0:	01c12083          	lw	ra,28(sp)
40015ce4:	01812403          	lw	s0,24(sp)
40015ce8:	01412483          	lw	s1,20(sp)
40015cec:	02010113          	addi	sp,sp,32
40015cf0:	00008067          	ret
		return -ENOBUFS;
40015cf4:	f9700513          	li	a0,-105
40015cf8:	fe9ff06f          	j	40015ce0 <net_icmpv6_finalize+0x68>

40015cfc <net_icmpv6_create>:

int net_icmpv6_create(struct net_pkt *pkt, uint8_t icmp_type, uint8_t icmp_code)
{
40015cfc:	fe010113          	addi	sp,sp,-32
40015d00:	01212823          	sw	s2,16(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
40015d04:	00400793          	li	a5,4
{
40015d08:	00058913          	mv	s2,a1
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
40015d0c:	00810593          	addi	a1,sp,8
{
40015d10:	00812c23          	sw	s0,24(sp)
40015d14:	00912a23          	sw	s1,20(sp)
40015d18:	00112e23          	sw	ra,28(sp)
40015d1c:	00050413          	mv	s0,a0
40015d20:	00060493          	mv	s1,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
40015d24:	00012423          	sw	zero,8(sp)
40015d28:	00f12623          	sw	a5,12(sp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
40015d2c:	a50fe0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!icmp_hdr) {
40015d30:	02050c63          	beqz	a0,40015d68 <net_icmpv6_create+0x6c>
		return -ENOBUFS;
	}

	icmp_hdr->type   = icmp_type;
40015d34:	01250023          	sb	s2,0(a0)
	icmp_hdr->code   = icmp_code;
40015d38:	009500a3          	sb	s1,1(a0)
	icmp_hdr->chksum = 0U;
40015d3c:	00050123          	sb	zero,2(a0)
40015d40:	000501a3          	sb	zero,3(a0)

	return net_pkt_set_data(pkt, &icmp_access);
40015d44:	00810593          	addi	a1,sp,8
40015d48:	00040513          	mv	a0,s0
40015d4c:	ac0fe0ef          	jal	ra,4001400c <net_pkt_set_data>
}
40015d50:	01c12083          	lw	ra,28(sp)
40015d54:	01812403          	lw	s0,24(sp)
40015d58:	01412483          	lw	s1,20(sp)
40015d5c:	01012903          	lw	s2,16(sp)
40015d60:	02010113          	addi	sp,sp,32
40015d64:	00008067          	ret
		return -ENOBUFS;
40015d68:	f9700513          	li	a0,-105
40015d6c:	fe5ff06f          	j	40015d50 <net_icmpv6_create+0x54>

40015d70 <icmpv6_handle_echo_request>:

static
enum net_verdict icmpv6_handle_echo_request(struct net_pkt *pkt,
					    struct net_ipv6_hdr *ip_hdr,
					    struct net_icmp_hdr *icmp_hdr)
{
40015d70:	fe010113          	addi	sp,sp,-32
40015d74:	01312623          	sw	s3,12(sp)
40015d78:	00112e23          	sw	ra,28(sp)
40015d7c:	00812c23          	sw	s0,24(sp)
40015d80:	00912a23          	sw	s1,20(sp)
40015d84:	01212823          	sw	s2,16(sp)
	NET_DBG("Received Echo Request from %s to %s",
		net_sprint_ipv6_addr(&ip_hdr->src),
		net_sprint_ipv6_addr(&ip_hdr->dst));

	payload_len = ntohs(ip_hdr->len) -
		net_pkt_ipv6_ext_len(pkt) - NET_ICMPH_LEN;
40015d88:	03a55703          	lhu	a4,58(a0)
40015d8c:	ffc00793          	li	a5,-4
40015d90:	0045c683          	lbu	a3,4(a1)
40015d94:	40e787b3          	sub	a5,a5,a4
40015d98:	0055c703          	lbu	a4,5(a1)
40015d9c:	00871713          	slli	a4,a4,0x8
40015da0:	00d76733          	or	a4,a4,a3
40015da4:	00871693          	slli	a3,a4,0x8
40015da8:	00875713          	srli	a4,a4,0x8
40015dac:	00e6e733          	or	a4,a3,a4
40015db0:	00e787b3          	add	a5,a5,a4
40015db4:	01079993          	slli	s3,a5,0x10
	if (payload_len < NET_ICMPV6_UNUSED_LEN) {
40015db8:	01079793          	slli	a5,a5,0x10
40015dbc:	4107d793          	srai	a5,a5,0x10
40015dc0:	00300713          	li	a4,3
40015dc4:	02f74263          	blt	a4,a5,40015de8 <icmpv6_handle_echo_request+0x78>
		net_pkt_unref(reply);
	}

	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
40015dc8:	00200513          	li	a0,2
}
40015dcc:	01c12083          	lw	ra,28(sp)
40015dd0:	01812403          	lw	s0,24(sp)
40015dd4:	01412483          	lw	s1,20(sp)
40015dd8:	01012903          	lw	s2,16(sp)
40015ddc:	00c12983          	lw	s3,12(sp)
40015de0:	02010113          	addi	sp,sp,32
40015de4:	00008067          	ret
40015de8:	00050493          	mv	s1,a0
	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt), payload_len,
40015dec:	01852503          	lw	a0,24(a0)
40015df0:	0109d993          	srli	s3,s3,0x10
	return pkt->iface;
40015df4:	00058913          	mv	s2,a1
40015df8:	06400713          	li	a4,100
40015dfc:	00000793          	li	a5,0
40015e00:	03a00693          	li	a3,58
40015e04:	00200613          	li	a2,2
40015e08:	00098593          	mv	a1,s3
40015e0c:	911fd0ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
40015e10:	00050413          	mv	s0,a0
	if (!reply) {
40015e14:	fa050ae3          	beqz	a0,40015dc8 <icmpv6_handle_echo_request+0x58>
	if (net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst)) {
40015e18:	01894703          	lbu	a4,24(s2)
40015e1c:	0ff00793          	li	a5,255
						  (struct in6_addr *)ip_hdr->dst);
40015e20:	01890593          	addi	a1,s2,24
	if (net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst)) {
40015e24:	00f71863          	bne	a4,a5,40015e34 <icmpv6_handle_echo_request+0xc4>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
40015e28:	0184a503          	lw	a0,24(s1)
40015e2c:	9b9f80ef          	jal	ra,4000e7e4 <net_if_ipv6_select_src_addr>
40015e30:	00050593          	mv	a1,a0
	net_pkt_lladdr_dst(reply)->addr = NULL;
40015e34:	02042623          	sw	zero,44(s0)
	net_pkt_lladdr_src(reply)->addr = NULL;
40015e38:	02042223          	sw	zero,36(s0)
	return pkt->ip_dscp;
40015e3c:	0404a703          	lw	a4,64(s1)
	pkt->ip_dscp = dscp;
40015e40:	04044783          	lbu	a5,64(s0)
	if (net_ipv6_create(reply, src, (struct in6_addr *)ip_hdr->src)) {
40015e44:	00890613          	addi	a2,s2,8
40015e48:	03f77713          	andi	a4,a4,63
40015e4c:	fc07f793          	andi	a5,a5,-64
40015e50:	00e7e7b3          	or	a5,a5,a4
40015e54:	04f40023          	sb	a5,64(s0)
	return pkt->ip_ecn;
40015e58:	0404a703          	lw	a4,64(s1)
	pkt->ip_ecn = ecn;
40015e5c:	0ff7f793          	zext.b	a5,a5
40015e60:	03f7f793          	andi	a5,a5,63
40015e64:	0c077713          	andi	a4,a4,192
40015e68:	00e7e7b3          	or	a5,a5,a4
40015e6c:	04f40023          	sb	a5,64(s0)
40015e70:	00040513          	mv	a0,s0
40015e74:	279000ef          	jal	ra,400168ec <net_ipv6_create>
40015e78:	04051e63          	bnez	a0,40015ed4 <icmpv6_handle_echo_request+0x164>
	if (net_icmpv6_create(reply, NET_ICMPV6_ECHO_REPLY, 0) ||
40015e7c:	00000613          	li	a2,0
40015e80:	08100593          	li	a1,129
40015e84:	00040513          	mv	a0,s0
40015e88:	e75ff0ef          	jal	ra,40015cfc <net_icmpv6_create>
40015e8c:	04051463          	bnez	a0,40015ed4 <icmpv6_handle_echo_request+0x164>
	    net_pkt_copy(reply, pkt, payload_len)) {
40015e90:	00098613          	mv	a2,s3
40015e94:	00048593          	mv	a1,s1
40015e98:	00040513          	mv	a0,s0
40015e9c:	b95fd0ef          	jal	ra,40013a30 <net_pkt_copy>
	if (net_icmpv6_create(reply, NET_ICMPV6_ECHO_REPLY, 0) ||
40015ea0:	02051a63          	bnez	a0,40015ed4 <icmpv6_handle_echo_request+0x164>
	net_pkt_cursor_init(reply);
40015ea4:	00040513          	mv	a0,s0
40015ea8:	b48fd0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	net_ipv6_finalize(reply, IPPROTO_ICMPV6);
40015eac:	03a00593          	li	a1,58
40015eb0:	00040513          	mv	a0,s0
40015eb4:	32d000ef          	jal	ra,400169e0 <net_ipv6_finalize>
	if (net_send_data(reply) < 0) {
40015eb8:	00040513          	mv	a0,s0
40015ebc:	80df50ef          	jal	ra,4000b6c8 <net_send_data>
40015ec0:	00054a63          	bltz	a0,40015ed4 <icmpv6_handle_echo_request+0x164>
	net_pkt_unref(pkt);
40015ec4:	00048513          	mv	a0,s1
40015ec8:	854fd0ef          	jal	ra,40012f1c <net_pkt_unref>
	return NET_OK;
40015ecc:	00000513          	li	a0,0
40015ed0:	efdff06f          	j	40015dcc <icmpv6_handle_echo_request+0x5c>
		net_pkt_unref(reply);
40015ed4:	00040513          	mv	a0,s0
40015ed8:	844fd0ef          	jal	ra,40012f1c <net_pkt_unref>
40015edc:	eedff06f          	j	40015dc8 <icmpv6_handle_echo_request+0x58>

40015ee0 <net_icmpv6_send_error>:

int net_icmpv6_send_error(struct net_pkt *orig, uint8_t type, uint8_t code,
			  uint32_t param)
{
40015ee0:	fc010113          	addi	sp,sp,-64
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
40015ee4:	02800793          	li	a5,40
{
40015ee8:	02112e23          	sw	ra,60(sp)
40015eec:	02912a23          	sw	s1,52(sp)
40015ef0:	03312623          	sw	s3,44(sp)
40015ef4:	03412423          	sw	s4,40(sp)
40015ef8:	03612023          	sw	s6,32(sp)
40015efc:	01712e23          	sw	s7,28(sp)
40015f00:	00050493          	mv	s1,a0
40015f04:	00058b13          	mv	s6,a1
40015f08:	00060b93          	mv	s7,a2
40015f0c:	00068993          	mv	s3,a3
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
40015f10:	00f12223          	sw	a5,4(sp)
{
40015f14:	02812c23          	sw	s0,56(sp)
40015f18:	03212823          	sw	s2,48(sp)
40015f1c:	03512223          	sw	s5,36(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
40015f20:	00012023          	sw	zero,0(sp)
	const struct in6_addr *src;
	struct net_pkt *pkt;
	size_t copy_len;
	int ret;

	net_pkt_cursor_init(orig);
40015f24:	accfd0ef          	jal	ra,400131f0 <net_pkt_cursor_init>

	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(orig, &ipv6_access);
40015f28:	00010593          	mv	a1,sp
40015f2c:	00048513          	mv	a0,s1
40015f30:	84cfe0ef          	jal	ra,40013f7c <net_pkt_get_data>
	int err = -EIO;
40015f34:	ffb00a13          	li	s4,-5
	if (!ip_hdr) {
40015f38:	04050463          	beqz	a0,40015f80 <net_icmpv6_send_error+0xa0>
		goto drop_no_pkt;
	}

	if (ip_hdr->nexthdr == IPPROTO_ICMPV6) {
40015f3c:	00654703          	lbu	a4,6(a0)
40015f40:	03a00793          	li	a5,58
40015f44:	00050a93          	mv	s5,a0
40015f48:	06f71863          	bne	a4,a5,40015fb8 <net_icmpv6_send_error+0xd8>
	return net_pkt_skip(pkt, access->size);
40015f4c:	00412583          	lw	a1,4(sp)
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,
40015f50:	00400793          	li	a5,4
40015f54:	00048513          	mv	a0,s1
40015f58:	00012423          	sw	zero,8(sp)
40015f5c:	00f12623          	sw	a5,12(sp)
40015f60:	805fd0ef          	jal	ra,40013764 <net_pkt_skip>
						      struct net_icmp_hdr);
		struct net_icmp_hdr *icmp_hdr;

		net_pkt_acknowledge_data(orig, &ipv6_access);

		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
40015f64:	00810593          	addi	a1,sp,8
40015f68:	00048513          	mv	a0,s1
40015f6c:	810fe0ef          	jal	ra,40013f7c <net_pkt_get_data>
							orig, &icmpv6_access);
		if (!icmp_hdr || icmp_hdr->code < 128) {
40015f70:	00050663          	beqz	a0,40015f7c <net_icmpv6_send_error+0x9c>
40015f74:	00150783          	lb	a5,1(a0)
40015f78:	0207cc63          	bltz	a5,40015fb0 <net_icmpv6_send_error+0xd0>
			/* We must not send ICMP errors back */
			err = -EINVAL;
40015f7c:	fea00a13          	li	s4,-22

drop_no_pkt:
	net_stats_update_icmp_drop(net_pkt_iface(orig));

	return err;
}
40015f80:	03c12083          	lw	ra,60(sp)
40015f84:	03812403          	lw	s0,56(sp)
40015f88:	03412483          	lw	s1,52(sp)
40015f8c:	03012903          	lw	s2,48(sp)
40015f90:	02c12983          	lw	s3,44(sp)
40015f94:	02412a83          	lw	s5,36(sp)
40015f98:	02012b03          	lw	s6,32(sp)
40015f9c:	01c12b83          	lw	s7,28(sp)
40015fa0:	000a0513          	mv	a0,s4
40015fa4:	02812a03          	lw	s4,40(sp)
40015fa8:	04010113          	addi	sp,sp,64
40015fac:	00008067          	ret
		net_pkt_cursor_init(orig);
40015fb0:	00048513          	mv	a0,s1
40015fb4:	a3cfd0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	if (ip_hdr->nexthdr == IPPROTO_UDP) {
40015fb8:	006ac783          	lbu	a5,6(s5)
40015fbc:	01100713          	li	a4,17
		copy_len = sizeof(struct net_ipv6_hdr) +
40015fc0:	03000513          	li	a0,48
	if (ip_hdr->nexthdr == IPPROTO_UDP) {
40015fc4:	00e78e63          	beq	a5,a4,40015fe0 <net_icmpv6_send_error+0x100>
	} else if (ip_hdr->nexthdr == IPPROTO_TCP) {
40015fc8:	00600713          	li	a4,6
		copy_len = sizeof(struct net_ipv6_hdr) +
40015fcc:	03c00513          	li	a0,60
	} else if (ip_hdr->nexthdr == IPPROTO_TCP) {
40015fd0:	00e78863          	beq	a5,a4,40015fe0 <net_icmpv6_send_error+0x100>
		copy_len = net_pkt_get_len(orig);
40015fd4:	0084a783          	lw	a5,8(s1)
	size_t bytes = 0;
40015fd8:	00000513          	li	a0,0
	while (buf) {
40015fdc:	0e079463          	bnez	a5,400160c4 <net_icmpv6_send_error+0x1e4>
					net_pkt_lladdr_src(orig)->len * 2 +
40015fe0:	0284c583          	lbu	a1,40(s1)
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
40015fe4:	06400713          	li	a4,100
40015fe8:	00000793          	li	a5,0
					net_pkt_lladdr_src(orig)->len * 2 +
40015fec:	00159593          	slli	a1,a1,0x1
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
40015ff0:	00458593          	addi	a1,a1,4
40015ff4:	00a585b3          	add	a1,a1,a0
40015ff8:	0184a503          	lw	a0,24(s1)
40015ffc:	03a00693          	li	a3,58
40016000:	00200613          	li	a2,2
40016004:	f18fd0ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
40016008:	00050413          	mv	s0,a0
		err = -ENOMEM;
4001600c:	ff400a13          	li	s4,-12
	if (!pkt) {
40016010:	f60508e3          	beqz	a0,40015f80 <net_icmpv6_send_error+0xa0>
	ret = net_pkt_write(pkt, net_pkt_lladdr_src(orig)->addr,
40016014:	0284c603          	lbu	a2,40(s1)
40016018:	0244a583          	lw	a1,36(s1)
4001601c:	efdfd0ef          	jal	ra,40013f18 <net_pkt_write>
40016020:	00050913          	mv	s2,a0
	if (ret < 0) {
40016024:	08054863          	bltz	a0,400160b4 <net_icmpv6_send_error+0x1d4>
	net_pkt_lladdr_dst(pkt)->addr = pkt->buffer->data;
40016028:	00842783          	lw	a5,8(s0)
	ret = net_pkt_write(pkt, net_pkt_lladdr_dst(orig)->addr,
4001602c:	00040513          	mv	a0,s0
	net_pkt_lladdr_dst(pkt)->addr = pkt->buffer->data;
40016030:	00c7a783          	lw	a5,12(a5)
40016034:	02f42623          	sw	a5,44(s0)
	ret = net_pkt_write(pkt, net_pkt_lladdr_dst(orig)->addr,
40016038:	0304c603          	lbu	a2,48(s1)
4001603c:	02c4a583          	lw	a1,44(s1)
40016040:	ed9fd0ef          	jal	ra,40013f18 <net_pkt_write>
40016044:	00050913          	mv	s2,a0
	if (ret < 0) {
40016048:	06054663          	bltz	a0,400160b4 <net_icmpv6_send_error+0x1d4>
	return net_buf_simple_pull_mem(&buf->b, len);
4001604c:	00842503          	lw	a0,8(s0)
40016050:	0304c583          	lbu	a1,48(s1)
40016054:	00c50513          	addi	a0,a0,12
40016058:	b21f30ef          	jal	ra,40009b78 <net_buf_simple_pull_mem>
	net_pkt_lladdr_src(pkt)->addr = pkt->buffer->data;
4001605c:	00842503          	lw	a0,8(s0)
40016060:	00c52783          	lw	a5,12(a0)
40016064:	00c50513          	addi	a0,a0,12
40016068:	02f42223          	sw	a5,36(s0)
4001606c:	0284c583          	lbu	a1,40(s1)
40016070:	b09f30ef          	jal	ra,40009b78 <net_buf_simple_pull_mem>
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;
40016074:	0304c783          	lbu	a5,48(s1)
						  (struct in6_addr *)ip_hdr->dst);
40016078:	018a8593          	addi	a1,s5,24
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_dst(orig)->len;
4001607c:	02f40423          	sb	a5,40(s0)
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;
40016080:	0284c783          	lbu	a5,40(s1)
40016084:	02f40823          	sb	a5,48(s0)
	if (net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst)) {
40016088:	018ac703          	lbu	a4,24(s5)
4001608c:	0ff00793          	li	a5,255
40016090:	00f71863          	bne	a4,a5,400160a0 <net_icmpv6_send_error+0x1c0>
		src = net_if_ipv6_select_src_addr(net_pkt_iface(pkt),
40016094:	01842503          	lw	a0,24(s0)
40016098:	f4cf80ef          	jal	ra,4000e7e4 <net_if_ipv6_select_src_addr>
4001609c:	00050593          	mv	a1,a0
	if (net_ipv6_create(pkt, src, (struct in6_addr *)ip_hdr->src) ||
400160a0:	008a8613          	addi	a2,s5,8
400160a4:	00040513          	mv	a0,s0
400160a8:	045000ef          	jal	ra,400168ec <net_ipv6_create>
400160ac:	02050463          	beqz	a0,400160d4 <net_icmpv6_send_error+0x1f4>
	int err = -EIO;
400160b0:	ffb00913          	li	s2,-5
	net_pkt_unref(pkt);
400160b4:	00040513          	mv	a0,s0
400160b8:	e65fc0ef          	jal	ra,40012f1c <net_pkt_unref>
400160bc:	00090a13          	mv	s4,s2
400160c0:	ec1ff06f          	j	40015f80 <net_icmpv6_send_error+0xa0>
		bytes += buf->len;
400160c4:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
400160c8:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
400160cc:	00e50533          	add	a0,a0,a4
		buf = buf->frags;
400160d0:	f0dff06f          	j	40015fdc <net_icmpv6_send_error+0xfc>
	    net_icmpv6_create(pkt, type, code)) {
400160d4:	000b8613          	mv	a2,s7
400160d8:	000b0593          	mv	a1,s6
400160dc:	00040513          	mv	a0,s0
400160e0:	c1dff0ef          	jal	ra,40015cfc <net_icmpv6_create>
	if (net_ipv6_create(pkt, src, (struct in6_addr *)ip_hdr->src) ||
400160e4:	fc0516e3          	bnez	a0,400160b0 <net_icmpv6_send_error+0x1d0>
	if (type == NET_ICMPV6_PARAM_PROBLEM) {
400160e8:	00400793          	li	a5,4
400160ec:	08fb1a63          	bne	s6,a5,40016180 <net_icmpv6_send_error+0x2a0>
	uint32_t data_be32 = htonl(data);
400160f0:	01899713          	slli	a4,s3,0x18
400160f4:	0189d793          	srli	a5,s3,0x18
400160f8:	000106b7          	lui	a3,0x10
400160fc:	00e7e7b3          	or	a5,a5,a4
40016100:	f0068693          	addi	a3,a3,-256 # ff00 <__kernel_ram_size+0x3c6c>
40016104:	0089d713          	srli	a4,s3,0x8
40016108:	00d77733          	and	a4,a4,a3
4001610c:	00e7e7b3          	or	a5,a5,a4
40016110:	00899993          	slli	s3,s3,0x8
40016114:	00ff0737          	lui	a4,0xff0
40016118:	00e9f9b3          	and	s3,s3,a4
4001611c:	0137e7b3          	or	a5,a5,s3
	return net_pkt_write(pkt, &data_be32, sizeof(uint32_t));
40016120:	00400613          	li	a2,4
40016124:	00810593          	addi	a1,sp,8
40016128:	00040513          	mv	a0,s0
	uint32_t data_be32 = htonl(data);
4001612c:	00f12423          	sw	a5,8(sp)
	return net_pkt_write(pkt, &data_be32, sizeof(uint32_t));
40016130:	de9fd0ef          	jal	ra,40013f18 <net_pkt_write>
		err = net_pkt_memset(pkt, 0, NET_ICMPV6_UNUSED_LEN);
40016134:	00050913          	mv	s2,a0
	copy_len = net_pkt_available_buffer(pkt);
40016138:	00040513          	mv	a0,s0
4001613c:	eddfc0ef          	jal	ra,40013018 <net_pkt_available_buffer>
40016140:	00050613          	mv	a2,a0
	if (err || net_pkt_copy(pkt, orig, copy_len)) {
40016144:	f60918e3          	bnez	s2,400160b4 <net_icmpv6_send_error+0x1d4>
40016148:	00048593          	mv	a1,s1
4001614c:	00040513          	mv	a0,s0
40016150:	8e1fd0ef          	jal	ra,40013a30 <net_pkt_copy>
40016154:	00050a13          	mv	s4,a0
40016158:	f4051ee3          	bnez	a0,400160b4 <net_icmpv6_send_error+0x1d4>
	net_pkt_cursor_init(pkt);
4001615c:	00040513          	mv	a0,s0
40016160:	890fd0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
40016164:	03a00593          	li	a1,58
40016168:	00040513          	mv	a0,s0
4001616c:	075000ef          	jal	ra,400169e0 <net_ipv6_finalize>
	if (net_send_data(pkt) >= 0) {
40016170:	00040513          	mv	a0,s0
40016174:	d54f50ef          	jal	ra,4000b6c8 <net_send_data>
40016178:	f2054ee3          	bltz	a0,400160b4 <net_icmpv6_send_error+0x1d4>
4001617c:	e05ff06f          	j	40015f80 <net_icmpv6_send_error+0xa0>
		err = net_pkt_memset(pkt, 0, NET_ICMPV6_UNUSED_LEN);
40016180:	00400613          	li	a2,4
40016184:	00000593          	li	a1,0
40016188:	00040513          	mv	a0,s0
4001618c:	819fd0ef          	jal	ra,400139a4 <net_pkt_memset>
40016190:	fa5ff06f          	j	40016134 <net_icmpv6_send_error+0x254>

40016194 <net_icmpv6_send_echo_request>:
				 uint16_t identifier,
				 uint16_t sequence,
				 uint8_t tc,
				 const void *data,
				 size_t data_size)
{
40016194:	fc010113          	addi	sp,sp,-64
40016198:	03512223          	sw	s5,36(sp)
4001619c:	00078a93          	mv	s5,a5
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,
400161a0:	00400793          	li	a5,4
{
400161a4:	02812c23          	sw	s0,56(sp)
400161a8:	02912a23          	sw	s1,52(sp)
400161ac:	03212823          	sw	s2,48(sp)
400161b0:	03312623          	sw	s3,44(sp)
400161b4:	03412423          	sw	s4,40(sp)
400161b8:	03612023          	sw	s6,32(sp)
400161bc:	01712e23          	sw	s7,28(sp)
400161c0:	02112e23          	sw	ra,60(sp)
400161c4:	00050413          	mv	s0,a0
400161c8:	00058b93          	mv	s7,a1
400161cc:	00060a13          	mv	s4,a2
400161d0:	00068493          	mv	s1,a3
400161d4:	00070993          	mv	s3,a4
400161d8:	00080913          	mv	s2,a6
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv6_access,
400161dc:	00f12623          	sw	a5,12(sp)
400161e0:	00012423          	sw	zero,8(sp)
	int ret = -ENOBUFS;
	struct net_icmpv6_echo_req *echo_req;
	const struct in6_addr *src;
	struct net_pkt *pkt;

	src = net_if_ipv6_select_src_addr(iface, dst);
400161e4:	e00f80ef          	jal	ra,4000e7e4 <net_if_ipv6_select_src_addr>
400161e8:	00050b13          	mv	s6,a0

	pkt = net_pkt_alloc_with_buffer(iface,
400161ec:	06400713          	li	a4,100
400161f0:	00000793          	li	a5,0
400161f4:	03a00693          	li	a3,58
400161f8:	00200613          	li	a2,2
400161fc:	00490593          	addi	a1,s2,4
40016200:	00040513          	mv	a0,s0
40016204:	d18fd0ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
					sizeof(struct net_icmpv6_echo_req)
					+ data_size,
					AF_INET6, IPPROTO_ICMPV6,
					PKT_WAIT_TIME);
	if (!pkt) {
40016208:	1a050663          	beqz	a0,400163b4 <net_icmpv6_send_echo_request+0x220>
	pkt->ip_dscp = dscp;
4001620c:	00699793          	slli	a5,s3,0x6
40016210:	0029d993          	srli	s3,s3,0x2
40016214:	0137e7b3          	or	a5,a5,s3
40016218:	04f50023          	sb	a5,64(a0)
	}

	net_pkt_set_ip_dscp(pkt, net_ipv6_get_dscp(tc));
	net_pkt_set_ip_ecn(pkt, net_ipv6_get_ecn(tc));

	if (net_ipv6_create(pkt, src, dst) ||
4001621c:	000b8613          	mv	a2,s7
40016220:	000b0593          	mv	a1,s6
40016224:	00050413          	mv	s0,a0
40016228:	6c4000ef          	jal	ra,400168ec <net_ipv6_create>
4001622c:	04050063          	beqz	a0,4001626c <net_icmpv6_send_echo_request+0xd8>
	int ret = -ENOBUFS;
40016230:	f9700993          	li	s3,-105
	net_stats_update_icmp_drop(iface);

	ret = -EIO;

drop:
	net_pkt_unref(pkt);
40016234:	00040513          	mv	a0,s0
40016238:	ce5fc0ef          	jal	ra,40012f1c <net_pkt_unref>

	return ret;
}
4001623c:	03c12083          	lw	ra,60(sp)
40016240:	03812403          	lw	s0,56(sp)
40016244:	03412483          	lw	s1,52(sp)
40016248:	03012903          	lw	s2,48(sp)
4001624c:	02812a03          	lw	s4,40(sp)
40016250:	02412a83          	lw	s5,36(sp)
40016254:	02012b03          	lw	s6,32(sp)
40016258:	01c12b83          	lw	s7,28(sp)
4001625c:	00098513          	mv	a0,s3
40016260:	02c12983          	lw	s3,44(sp)
40016264:	04010113          	addi	sp,sp,64
40016268:	00008067          	ret
	    net_icmpv6_create(pkt, NET_ICMPV6_ECHO_REQUEST, 0)) {
4001626c:	00000613          	li	a2,0
40016270:	08000593          	li	a1,128
40016274:	00040513          	mv	a0,s0
40016278:	a85ff0ef          	jal	ra,40015cfc <net_icmpv6_create>
4001627c:	00050993          	mv	s3,a0
	if (net_ipv6_create(pkt, src, dst) ||
40016280:	fa0518e3          	bnez	a0,40016230 <net_icmpv6_send_echo_request+0x9c>
	echo_req = (struct net_icmpv6_echo_req *)net_pkt_get_data(
40016284:	00810593          	addi	a1,sp,8
40016288:	00040513          	mv	a0,s0
4001628c:	cf1fd0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!echo_req) {
40016290:	fa0500e3          	beqz	a0,40016230 <net_icmpv6_send_echo_request+0x9c>
	echo_req->identifier = htons(identifier);
40016294:	008a1793          	slli	a5,s4,0x8
40016298:	008a5a13          	srli	s4,s4,0x8
4001629c:	0147ea33          	or	s4,a5,s4
400162a0:	010a1793          	slli	a5,s4,0x10
400162a4:	0107d793          	srli	a5,a5,0x10
400162a8:	0087d793          	srli	a5,a5,0x8
400162ac:	00f500a3          	sb	a5,1(a0)
	echo_req->sequence   = htons(sequence);
400162b0:	00849793          	slli	a5,s1,0x8
400162b4:	0084d493          	srli	s1,s1,0x8
400162b8:	0097e4b3          	or	s1,a5,s1
400162bc:	01049793          	slli	a5,s1,0x10
400162c0:	0107d793          	srli	a5,a5,0x10
400162c4:	0087d793          	srli	a5,a5,0x8
	echo_req->identifier = htons(identifier);
400162c8:	01450023          	sb	s4,0(a0)
	echo_req->sequence   = htons(sequence);
400162cc:	00950123          	sb	s1,2(a0)
400162d0:	00f501a3          	sb	a5,3(a0)
	net_pkt_set_data(pkt, &icmpv6_access);
400162d4:	00810593          	addi	a1,sp,8
400162d8:	00040513          	mv	a0,s0
400162dc:	d31fd0ef          	jal	ra,4001400c <net_pkt_set_data>
	if (data != NULL && data_size > 0) {
400162e0:	040a8063          	beqz	s5,40016320 <net_icmpv6_send_echo_request+0x18c>
400162e4:	00090a63          	beqz	s2,400162f8 <net_icmpv6_send_echo_request+0x164>
		net_pkt_write(pkt, data, data_size);
400162e8:	00090613          	mv	a2,s2
400162ec:	000a8593          	mv	a1,s5
400162f0:	00040513          	mv	a0,s0
400162f4:	c25fd0ef          	jal	ra,40013f18 <net_pkt_write>
	net_pkt_cursor_init(pkt);
400162f8:	00040513          	mv	a0,s0
400162fc:	ef5fc0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
40016300:	03a00593          	li	a1,58
40016304:	00040513          	mv	a0,s0
40016308:	6d8000ef          	jal	ra,400169e0 <net_ipv6_finalize>
	if (net_send_data(pkt) >= 0) {
4001630c:	00040513          	mv	a0,s0
40016310:	bb8f50ef          	jal	ra,4000b6c8 <net_send_data>
40016314:	f20554e3          	bgez	a0,4001623c <net_icmpv6_send_echo_request+0xa8>
	ret = -EIO;
40016318:	ffb00993          	li	s3,-5
4001631c:	f19ff06f          	j	40016234 <net_icmpv6_send_echo_request+0xa0>
	} else if (data == NULL && data_size > 0) {
40016320:	fc090ce3          	beqz	s2,400162f8 <net_icmpv6_send_echo_request+0x164>
		if (data_size >= sizeof(uint32_t)) {
40016324:	00300793          	li	a5,3
40016328:	0727f463          	bgeu	a5,s2,40016390 <net_icmpv6_send_echo_request+0x1fc>
4001632c:	204100ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
40016330:	00050493          	mv	s1,a0
40016334:	1fc100ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
40016338:	00050a93          	mv	s5,a0
4001633c:	1f4100ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
40016340:	00050a13          	mv	s4,a0
40016344:	1ec100ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
			uint32_t time_stamp = htonl(k_cycle_get_32());
40016348:	000107b7          	lui	a5,0x10
4001634c:	01851513          	slli	a0,a0,0x18
40016350:	f0078793          	addi	a5,a5,-256 # ff00 <__kernel_ram_size+0x3c6c>
40016354:	0184d493          	srli	s1,s1,0x18
40016358:	008ada93          	srli	s5,s5,0x8
4001635c:	00a4e4b3          	or	s1,s1,a0
40016360:	00fafab3          	and	s5,s5,a5
40016364:	008a1a13          	slli	s4,s4,0x8
40016368:	00ff07b7          	lui	a5,0xff0
4001636c:	00fa7a33          	and	s4,s4,a5
40016370:	0154e4b3          	or	s1,s1,s5
40016374:	0144e4b3          	or	s1,s1,s4
			net_pkt_write(pkt, &time_stamp, sizeof(time_stamp));
40016378:	00400613          	li	a2,4
4001637c:	00410593          	addi	a1,sp,4
40016380:	00040513          	mv	a0,s0
			uint32_t time_stamp = htonl(k_cycle_get_32());
40016384:	00912223          	sw	s1,4(sp)
			data_size -= sizeof(time_stamp);
40016388:	ffc90913          	addi	s2,s2,-4
			net_pkt_write(pkt, &time_stamp, sizeof(time_stamp));
4001638c:	b8dfd0ef          	jal	ra,40013f18 <net_pkt_write>
		for (size_t i = 0; i < data_size; i++) {
40016390:	00000493          	li	s1,0
40016394:	f69902e3          	beq	s2,s1,400162f8 <net_icmpv6_send_echo_request+0x164>
	return net_pkt_write(pkt, &data, sizeof(uint8_t));
40016398:	00100613          	li	a2,1
4001639c:	00410593          	addi	a1,sp,4
400163a0:	00040513          	mv	a0,s0
400163a4:	00910223          	sb	s1,4(sp)
400163a8:	b71fd0ef          	jal	ra,40013f18 <net_pkt_write>
400163ac:	00148493          	addi	s1,s1,1
400163b0:	fe5ff06f          	j	40016394 <net_icmpv6_send_echo_request+0x200>
		return -ENOMEM;
400163b4:	ff400993          	li	s3,-12
400163b8:	e85ff06f          	j	4001623c <net_icmpv6_send_echo_request+0xa8>

400163bc <net_icmpv6_input>:

enum net_verdict net_icmpv6_input(struct net_pkt *pkt,
				  struct net_ipv6_hdr *ip_hdr)
{
400163bc:	fe010113          	addi	sp,sp,-32
400163c0:	01212823          	sw	s2,16(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
400163c4:	00400793          	li	a5,4
{
400163c8:	00058913          	mv	s2,a1
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;
	struct net_icmpv6_handler *cb;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
400163cc:	00810593          	addi	a1,sp,8
{
400163d0:	00912a23          	sw	s1,20(sp)
400163d4:	00112e23          	sw	ra,28(sp)
400163d8:	00812c23          	sw	s0,24(sp)
400163dc:	00050493          	mv	s1,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
400163e0:	00012423          	sw	zero,8(sp)
400163e4:	00f12623          	sw	a5,12(sp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
400163e8:	b95fd0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!icmp_hdr) {
400163ec:	02051063          	bnez	a0,4001640c <net_icmpv6_input+0x50>
		NET_DBG("DROP: NULL ICMPv6 header");
		return NET_DROP;
400163f0:	00200513          	li	a0,2
	}
drop:
	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
400163f4:	01c12083          	lw	ra,28(sp)
400163f8:	01812403          	lw	s0,24(sp)
400163fc:	01412483          	lw	s1,20(sp)
40016400:	01012903          	lw	s2,16(sp)
40016404:	02010113          	addi	sp,sp,32
40016408:	00008067          	ret
4001640c:	00050413          	mv	s0,a0
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
40016410:	0184a503          	lw	a0,24(s1)
40016414:	9c4f90ef          	jal	ra,4000f5d8 <net_if_need_calc_rx_checksum>
40016418:	04051863          	bnez	a0,40016468 <net_icmpv6_input+0xac>
	return net_pkt_skip(pkt, access->size);
4001641c:	00c12583          	lw	a1,12(sp)
40016420:	00048513          	mv	a0,s1
40016424:	b40fd0ef          	jal	ra,40013764 <net_pkt_skip>
	return list->head;
40016428:	400317b7          	lui	a5,0x40031
4001642c:	aa07a783          	lw	a5,-1376(a5) # 40030aa0 <handlers>
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
40016430:	fc0780e3          	beqz	a5,400163f0 <net_icmpv6_input+0x34>
		if (cb->type == icmp_hdr->type &&
40016434:	0087c683          	lbu	a3,8(a5)
40016438:	00044703          	lbu	a4,0(s0)
4001643c:	04e69063          	bne	a3,a4,4001647c <net_icmpv6_input+0xc0>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
40016440:	0097c703          	lbu	a4,9(a5)
		if (cb->type == icmp_hdr->type &&
40016444:	00144683          	lbu	a3,1(s0)
40016448:	00e68463          	beq	a3,a4,40016450 <net_icmpv6_input+0x94>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
4001644c:	02071863          	bnez	a4,4001647c <net_icmpv6_input+0xc0>
			return cb->handler(pkt, ip_hdr, icmp_hdr);
40016450:	0047a783          	lw	a5,4(a5)
40016454:	00040613          	mv	a2,s0
40016458:	00090593          	mv	a1,s2
4001645c:	00048513          	mv	a0,s1
40016460:	000780e7          	jalr	a5
40016464:	f91ff06f          	j	400163f4 <net_icmpv6_input+0x38>
40016468:	03a00593          	li	a1,58
4001646c:	00048513          	mv	a0,s1
40016470:	ae4fa0ef          	jal	ra,40010754 <net_calc_chksum>
		if (net_calc_chksum_icmpv6(pkt) != 0U) {
40016474:	fa0504e3          	beqz	a0,4001641c <net_icmpv6_input+0x60>
40016478:	f79ff06f          	j	400163f0 <net_icmpv6_input+0x34>
	return node->next;
4001647c:	0007a783          	lw	a5,0(a5)
40016480:	fb1ff06f          	j	40016430 <net_icmpv6_input+0x74>

40016484 <net_icmpv6_init>:
	.handler = icmpv6_handle_echo_request,
};

void net_icmpv6_init(void)
{
	net_icmpv6_register_handler(&echo_request_handler);
40016484:	4003c537          	lui	a0,0x4003c
40016488:	39c50513          	addi	a0,a0,924 # 4003c39c <echo_request_handler>
4001648c:	f6cff06f          	j	40015bf8 <net_icmpv6_register_handler>

40016490 <net_nbr_unref>:
#if defined(CONFIG_NET_IPV6_NBR_CACHE_LOG_LEVEL_DBG)
	NET_DBG("nbr %p ref %u (%s():%d)", nbr, nbr->ref - 1, caller, line);
#else
	NET_DBG("nbr %p ref %u", nbr, nbr->ref - 1);
#endif
	if (--nbr->ref) {
40016490:	00054783          	lbu	a5,0(a0)
40016494:	fff78793          	addi	a5,a5,-1
40016498:	0ff7f793          	zext.b	a5,a5
4001649c:	00f50023          	sb	a5,0(a0)
400164a0:	00079863          	bnez	a5,400164b0 <net_nbr_unref+0x20>
		return;
	}

	if (nbr->remove) {
400164a4:	01052783          	lw	a5,16(a0)
400164a8:	00078463          	beqz	a5,400164b0 <net_nbr_unref+0x20>
		nbr->remove(nbr);
400164ac:	00078067          	jr	a5
	}
}
400164b0:	00008067          	ret

400164b4 <net_nbr_ref>:
#if defined(CONFIG_NET_IPV6_NBR_CACHE_LOG_LEVEL_DBG)
	NET_DBG("nbr %p ref %u (%s():%d)", nbr, nbr->ref + 1, caller, line);
#else
	NET_DBG("nbr %p ref %u", nbr, nbr->ref + 1);
#endif
	nbr->ref++;
400164b4:	00054703          	lbu	a4,0(a0)
400164b8:	00170713          	addi	a4,a4,1 # ff0001 <__rom_region_size+0xfbf625>
400164bc:	00e50023          	sb	a4,0(a0)

	return nbr;
}
400164c0:	00008067          	ret

400164c4 <net_nbr_get>:

struct net_nbr *net_nbr_get(struct net_nbr_table *table)
{
	int i;

	for (i = 0; i < table->nbr_count; i++) {
400164c4:	00855583          	lhu	a1,8(a0)
{
400164c8:	00050613          	mv	a2,a0
	for (i = 0; i < table->nbr_count; i++) {
400164cc:	00000693          	li	a3,0
400164d0:	00b6c663          	blt	a3,a1,400164dc <net_nbr_get+0x18>

			return net_nbr_ref(nbr);
		}
	}

	return NULL;
400164d4:	00000513          	li	a0,0
}
400164d8:	00008067          	ret
		struct net_nbr *nbr = get_nbr(table->nbr, i);
400164dc:	00062783          	lw	a5,0(a2)
			  start->size + start->extra_data_size) * idx));
400164e0:	0047d503          	lhu	a0,4(a5)
400164e4:	0027d703          	lhu	a4,2(a5)
400164e8:	00a70733          	add	a4,a4,a0
400164ec:	01470713          	addi	a4,a4,20
400164f0:	02d70733          	mul	a4,a4,a3
	return (struct net_nbr *)((uint8_t *)start +
400164f4:	00e78533          	add	a0,a5,a4
		if (!nbr->ref) {
400164f8:	00054783          	lbu	a5,0(a0)
400164fc:	00079c63          	bnez	a5,40016514 <net_nbr_get+0x50>
			nbr->data = nbr->__nbr;
40016500:	01450793          	addi	a5,a0,20
40016504:	00f52623          	sw	a5,12(a0)
	nbr->ref++;
40016508:	00100793          	li	a5,1
4001650c:	00f50023          	sb	a5,0(a0)
			return net_nbr_ref(nbr);
40016510:	00008067          	ret
	for (i = 0; i < table->nbr_count; i++) {
40016514:	00168693          	addi	a3,a3,1
40016518:	fb9ff06f          	j	400164d0 <net_nbr_get+0xc>

4001651c <net_nbr_link>:
int net_nbr_link(struct net_nbr *nbr, struct net_if *iface,
		 const struct net_linkaddr *lladdr)
{
	int i, avail = -1;

	if (nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
4001651c:	00154703          	lbu	a4,1(a0)
40016520:	0ff00793          	li	a5,255
40016524:	14f71863          	bne	a4,a5,40016674 <net_nbr_link+0x158>
{
40016528:	fd010113          	addi	sp,sp,-48
4001652c:	02812423          	sw	s0,40(sp)
40016530:	40032437          	lui	s0,0x40032
40016534:	02912223          	sw	s1,36(sp)
40016538:	03212023          	sw	s2,32(sp)
4001653c:	01312e23          	sw	s3,28(sp)
40016540:	01412c23          	sw	s4,24(sp)
40016544:	01512a23          	sw	s5,20(sp)
40016548:	01612823          	sw	s6,16(sp)
4001654c:	01712623          	sw	s7,12(sp)
40016550:	01812423          	sw	s8,8(sp)
40016554:	5b440b13          	addi	s6,s0,1460 # 400325b4 <net_neighbor_lladdr>
40016558:	02112623          	sw	ra,44(sp)
4001655c:	00050993          	mv	s3,a0
40016560:	00058a93          	mv	s5,a1
40016564:	00060493          	mv	s1,a2
	int i, avail = -1;
40016568:	fff00913          	li	s2,-1
		return -EALREADY;
	}

	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001656c:	00000a13          	li	s4,0
40016570:	5b440413          	addi	s0,s0,1460
		if (avail < 0 && !net_neighbor_lladdr[i].ref) {
40016574:	fff00c13          	li	s8,-1
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
40016578:	00800b93          	li	s7,8
		if (avail < 0 && !net_neighbor_lladdr[i].ref) {
4001657c:	008b4783          	lbu	a5,8(s6)
40016580:	07891863          	bne	s2,s8,400165f0 <net_nbr_link+0xd4>
40016584:	0e078463          	beqz	a5,4001666c <net_nbr_link+0x150>
			avail = i;
		}

		if (net_neighbor_lladdr[i].ref &&
		    !memcmp(lladdr->addr,
40016588:	0044c603          	lbu	a2,4(s1)
4001658c:	0004a503          	lw	a0,0(s1)
40016590:	002b0593          	addi	a1,s6,2
40016594:	a39f20ef          	jal	ra,40008fcc <memcmp>
		if (net_neighbor_lladdr[i].ref &&
40016598:	04051e63          	bnez	a0,400165f4 <net_nbr_link+0xd8>
			    net_neighbor_lladdr[i].lladdr.addr,
			    lladdr->len)) {
			/* We found same lladdr in nbr cache so just
			 * increase the ref count.
			 */
			net_neighbor_lladdr[i].ref++;
4001659c:	00900793          	li	a5,9
400165a0:	02fa07b3          	mul	a5,s4,a5
400165a4:	00f407b3          	add	a5,s0,a5
400165a8:	0087c703          	lbu	a4,8(a5)
400165ac:	00170713          	addi	a4,a4,1
400165b0:	00e78423          	sb	a4,8(a5)

			nbr->idx = i;
400165b4:	014980a3          	sb	s4,1(s3)
	net_linkaddr_set(&net_neighbor_lladdr[avail].lladdr, lladdr->addr,
			 lladdr->len);
	net_neighbor_lladdr[avail].lladdr.len = lladdr->len;
	net_neighbor_lladdr[avail].lladdr.type = lladdr->type;

	nbr->iface = iface;
400165b8:	0159a423          	sw	s5,8(s3)
			return 0;
400165bc:	00000513          	li	a0,0

	return 0;
}
400165c0:	02c12083          	lw	ra,44(sp)
400165c4:	02812403          	lw	s0,40(sp)
400165c8:	02412483          	lw	s1,36(sp)
400165cc:	02012903          	lw	s2,32(sp)
400165d0:	01c12983          	lw	s3,28(sp)
400165d4:	01812a03          	lw	s4,24(sp)
400165d8:	01412a83          	lw	s5,20(sp)
400165dc:	01012b03          	lw	s6,16(sp)
400165e0:	00c12b83          	lw	s7,12(sp)
400165e4:	00812c03          	lw	s8,8(sp)
400165e8:	03010113          	addi	sp,sp,48
400165ec:	00008067          	ret
		if (net_neighbor_lladdr[i].ref &&
400165f0:	f8079ce3          	bnez	a5,40016588 <net_nbr_link+0x6c>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
400165f4:	001a0a13          	addi	s4,s4,1
400165f8:	009b0b13          	addi	s6,s6,9
400165fc:	f97a10e3          	bne	s4,s7,4001657c <net_nbr_link+0x60>
	if (avail < 0) {
40016600:	fff00793          	li	a5,-1
		return -ENOENT;
40016604:	ffe00513          	li	a0,-2
	if (avail < 0) {
40016608:	faf90ce3          	beq	s2,a5,400165c0 <net_nbr_link+0xa4>
	net_neighbor_lladdr[avail].ref++;
4001660c:	00900513          	li	a0,9
40016610:	02a90533          	mul	a0,s2,a0
40016614:	00a407b3          	add	a5,s0,a0
40016618:	0087c703          	lbu	a4,8(a5)
4001661c:	00170713          	addi	a4,a4,1
40016620:	00e78423          	sb	a4,8(a5)
	nbr->idx = avail;
40016624:	012980a3          	sb	s2,1(s3)
	net_linkaddr_set(&net_neighbor_lladdr[avail].lladdr, lladdr->addr,
40016628:	0004a583          	lw	a1,0(s1)
			 lladdr->len);
4001662c:	0044c603          	lbu	a2,4(s1)
	if (!lladdr_store || !new_addr) {
40016630:	00058e63          	beqz	a1,4001664c <net_nbr_link+0x130>
	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
40016634:	00600713          	li	a4,6
40016638:	00c76a63          	bltu	a4,a2,4001664c <net_nbr_link+0x130>
	memcpy(lladdr_store->addr, new_addr, new_len);
4001663c:	00250513          	addi	a0,a0,2
40016640:	00a40533          	add	a0,s0,a0
	lladdr_store->len = new_len;
40016644:	00c780a3          	sb	a2,1(a5)
	memcpy(lladdr_store->addr, new_addr, new_len);
40016648:	a05f20ef          	jal	ra,4000904c <memcpy>
	net_neighbor_lladdr[avail].lladdr.len = lladdr->len;
4001664c:	00900713          	li	a4,9
40016650:	02e90933          	mul	s2,s2,a4
40016654:	0044c783          	lbu	a5,4(s1)
40016658:	01240433          	add	s0,s0,s2
4001665c:	00f400a3          	sb	a5,1(s0)
	net_neighbor_lladdr[avail].lladdr.type = lladdr->type;
40016660:	0054c783          	lbu	a5,5(s1)
40016664:	00f40023          	sb	a5,0(s0)
	return 0;
40016668:	f51ff06f          	j	400165b8 <net_nbr_link+0x9c>
4001666c:	000a0913          	mv	s2,s4
40016670:	f85ff06f          	j	400165f4 <net_nbr_link+0xd8>
		return -EALREADY;
40016674:	f8800513          	li	a0,-120
}
40016678:	00008067          	ret

4001667c <net_nbr_unlink>:

int net_nbr_unlink(struct net_nbr *nbr, struct net_linkaddr *lladdr)
{
	ARG_UNUSED(lladdr);

	if (nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
4001667c:	00154783          	lbu	a5,1(a0)
40016680:	0ff00713          	li	a4,255
40016684:	06e78e63          	beq	a5,a4,40016700 <net_nbr_unlink+0x84>
	}

	NET_ASSERT(nbr->idx < CONFIG_NET_IPV6_MAX_NEIGHBORS);
	NET_ASSERT(net_neighbor_lladdr[nbr->idx].ref > 0);

	net_neighbor_lladdr[nbr->idx].ref--;
40016688:	00900693          	li	a3,9
4001668c:	02d787b3          	mul	a5,a5,a3
{
40016690:	ff010113          	addi	sp,sp,-16
40016694:	00812423          	sw	s0,8(sp)
40016698:	00050413          	mv	s0,a0
	net_neighbor_lladdr[nbr->idx].ref--;
4001669c:	40032537          	lui	a0,0x40032
400166a0:	5b450513          	addi	a0,a0,1460 # 400325b4 <net_neighbor_lladdr>
{
400166a4:	00112623          	sw	ra,12(sp)
	net_neighbor_lladdr[nbr->idx].ref--;
400166a8:	00f507b3          	add	a5,a0,a5
400166ac:	0087c703          	lbu	a4,8(a5)
400166b0:	fff70713          	addi	a4,a4,-1
400166b4:	00e78423          	sb	a4,8(a5)

	if (!net_neighbor_lladdr[nbr->idx].ref) {
400166b8:	00144783          	lbu	a5,1(s0)
400166bc:	02d787b3          	mul	a5,a5,a3
400166c0:	00f50733          	add	a4,a0,a5
400166c4:	00874703          	lbu	a4,8(a4)
400166c8:	00071c63          	bnez	a4,400166e0 <net_nbr_unlink+0x64>
		(void)memset(net_neighbor_lladdr[nbr->idx].lladdr.addr, 0,
400166cc:	00278793          	addi	a5,a5,2
400166d0:	00600613          	li	a2,6
400166d4:	00000593          	li	a1,0
400166d8:	00f50533          	add	a0,a0,a5
400166dc:	995f20ef          	jal	ra,40009070 <memset>
			     sizeof(net_neighbor_lladdr[nbr->idx].lladdr.addr));
	}

	nbr->idx = NET_NBR_LLADDR_UNKNOWN;
400166e0:	fff00793          	li	a5,-1
400166e4:	00f400a3          	sb	a5,1(s0)
	nbr->iface = NULL;
400166e8:	00042423          	sw	zero,8(s0)

	return 0;
}
400166ec:	00c12083          	lw	ra,12(sp)
400166f0:	00812403          	lw	s0,8(sp)
	return 0;
400166f4:	00000513          	li	a0,0
}
400166f8:	01010113          	addi	sp,sp,16
400166fc:	00008067          	ret
		return -EALREADY;
40016700:	f8800513          	li	a0,-120
}
40016704:	00008067          	ret

40016708 <net_nbr_get_lladdr>:
{
	NET_ASSERT(idx < CONFIG_NET_IPV6_MAX_NEIGHBORS,
		   "idx %d >= max %d", idx,
		   CONFIG_NET_IPV6_MAX_NEIGHBORS);

	return &net_neighbor_lladdr[idx].lladdr;
40016708:	00900793          	li	a5,9
4001670c:	02f50533          	mul	a0,a0,a5
}
40016710:	400327b7          	lui	a5,0x40032
40016714:	5b478793          	addi	a5,a5,1460 # 400325b4 <net_neighbor_lladdr>
40016718:	00a78533          	add	a0,a5,a0
4001671c:	00008067          	ret

40016720 <net_ipv6_is_addr_loopback>:
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40016720:	00154703          	lbu	a4,1(a0)
40016724:	00054683          	lbu	a3,0(a0)
{
40016728:	00050793          	mv	a5,a0
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001672c:	00871713          	slli	a4,a4,0x8
40016730:	00d76733          	or	a4,a4,a3
40016734:	00254683          	lbu	a3,2(a0)
40016738:	01069693          	slli	a3,a3,0x10
4001673c:	00e6e6b3          	or	a3,a3,a4
40016740:	00354703          	lbu	a4,3(a0)
40016744:	01871713          	slli	a4,a4,0x18
40016748:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001674c:	0c071263          	bnez	a4,40016810 <net_ipv6_is_addr_loopback+0xf0>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
40016750:	00554703          	lbu	a4,5(a0)
40016754:	00454683          	lbu	a3,4(a0)
40016758:	00871713          	slli	a4,a4,0x8
4001675c:	00d76733          	or	a4,a4,a3
40016760:	00654683          	lbu	a3,6(a0)
40016764:	01069693          	slli	a3,a3,0x10
40016768:	00e6e6b3          	or	a3,a3,a4
4001676c:	00754703          	lbu	a4,7(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40016770:	00000513          	li	a0,0
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
40016774:	01871713          	slli	a4,a4,0x18
40016778:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001677c:	08071c63          	bnez	a4,40016814 <net_ipv6_is_addr_loopback+0xf4>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40016780:	0097c703          	lbu	a4,9(a5)
40016784:	0087c683          	lbu	a3,8(a5)
40016788:	00871713          	slli	a4,a4,0x8
4001678c:	00d76733          	or	a4,a4,a3
40016790:	00a7c683          	lbu	a3,10(a5)
40016794:	01069693          	slli	a3,a3,0x10
40016798:	00e6e6b3          	or	a3,a3,a4
4001679c:	00b7c703          	lbu	a4,11(a5)
400167a0:	01871713          	slli	a4,a4,0x18
400167a4:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
400167a8:	06071663          	bnez	a4,40016814 <net_ipv6_is_addr_loopback+0xf4>
		ntohl(UNALIGNED_GET(&addr->s6_addr32[3])) == 1;
400167ac:	00d7c683          	lbu	a3,13(a5)
400167b0:	00c7c703          	lbu	a4,12(a5)
400167b4:	00869693          	slli	a3,a3,0x8
400167b8:	00e6e6b3          	or	a3,a3,a4
400167bc:	00e7c703          	lbu	a4,14(a5)
400167c0:	00f7c783          	lbu	a5,15(a5)
400167c4:	01071713          	slli	a4,a4,0x10
400167c8:	01879793          	slli	a5,a5,0x18
400167cc:	00d76733          	or	a4,a4,a3
400167d0:	00e7e6b3          	or	a3,a5,a4
400167d4:	0187d513          	srli	a0,a5,0x18
400167d8:	01871713          	slli	a4,a4,0x18
400167dc:	00e56533          	or	a0,a0,a4
400167e0:	00010737          	lui	a4,0x10
400167e4:	0086d793          	srli	a5,a3,0x8
400167e8:	f0070713          	addi	a4,a4,-256 # ff00 <__kernel_ram_size+0x3c6c>
400167ec:	00e7f7b3          	and	a5,a5,a4
400167f0:	00f56533          	or	a0,a0,a5
400167f4:	00869693          	slli	a3,a3,0x8
400167f8:	00ff07b7          	lui	a5,0xff0
400167fc:	00f6f6b3          	and	a3,a3,a5
40016800:	00d56533          	or	a0,a0,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40016804:	fff50513          	addi	a0,a0,-1
40016808:	00153513          	seqz	a0,a0
4001680c:	00008067          	ret
40016810:	00000513          	li	a0,0
}
40016814:	00008067          	ret

40016818 <net_ipv6_is_addr_mcast_group>:
	return UNALIGNED_GET(&addr->s6_addr16[1]) == group->s6_addr16[1] &&
40016818:	00354703          	lbu	a4,3(a0)
4001681c:	00254603          	lbu	a2,2(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
40016820:	0025d683          	lhu	a3,2(a1)
	return UNALIGNED_GET(&addr->s6_addr16[1]) == group->s6_addr16[1] &&
40016824:	00871713          	slli	a4,a4,0x8
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
40016828:	00c76733          	or	a4,a4,a2
{
4001682c:	00050793          	mv	a5,a0
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
40016830:	00000513          	li	a0,0
40016834:	0ae69a63          	bne	a3,a4,400168e8 <net_ipv6_is_addr_mcast_group+0xd0>
		UNALIGNED_GET(&addr->s6_addr16[2]) == group->s6_addr16[2] &&
40016838:	0057c703          	lbu	a4,5(a5) # ff0005 <__rom_region_size+0xfbf629>
4001683c:	0047c683          	lbu	a3,4(a5)
	return UNALIGNED_GET(&addr->s6_addr16[1]) == group->s6_addr16[1] &&
40016840:	0045d603          	lhu	a2,4(a1)
		UNALIGNED_GET(&addr->s6_addr16[2]) == group->s6_addr16[2] &&
40016844:	00871713          	slli	a4,a4,0x8
40016848:	00d76833          	or	a6,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
4001684c:	00000513          	li	a0,0
	return UNALIGNED_GET(&addr->s6_addr16[1]) == group->s6_addr16[1] &&
40016850:	09061c63          	bne	a2,a6,400168e8 <net_ipv6_is_addr_mcast_group+0xd0>
		UNALIGNED_GET(&addr->s6_addr16[3]) == group->s6_addr16[3] &&
40016854:	0077c703          	lbu	a4,7(a5)
40016858:	0067c683          	lbu	a3,6(a5)
		UNALIGNED_GET(&addr->s6_addr16[2]) == group->s6_addr16[2] &&
4001685c:	0065d883          	lhu	a7,6(a1)
		UNALIGNED_GET(&addr->s6_addr16[3]) == group->s6_addr16[3] &&
40016860:	00871613          	slli	a2,a4,0x8
		UNALIGNED_GET(&addr->s6_addr16[2]) == group->s6_addr16[2] &&
40016864:	00d66633          	or	a2,a2,a3
40016868:	08c89063          	bne	a7,a2,400168e8 <net_ipv6_is_addr_mcast_group+0xd0>
		UNALIGNED_GET(&addr->s6_addr32[1]) == group->s6_addr32[1] &&
4001686c:	01069693          	slli	a3,a3,0x10
40016870:	0045a603          	lw	a2,4(a1)
40016874:	0106e6b3          	or	a3,a3,a6
40016878:	01871713          	slli	a4,a4,0x18
4001687c:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr16[3]) == group->s6_addr16[3] &&
40016880:	06e61463          	bne	a2,a4,400168e8 <net_ipv6_is_addr_mcast_group+0xd0>
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
40016884:	0097c703          	lbu	a4,9(a5)
40016888:	0087c683          	lbu	a3,8(a5)
4001688c:	00871713          	slli	a4,a4,0x8
40016890:	00d76733          	or	a4,a4,a3
40016894:	00a7c683          	lbu	a3,10(a5)
40016898:	01069693          	slli	a3,a3,0x10
4001689c:	00e6e6b3          	or	a3,a3,a4
400168a0:	00b7c703          	lbu	a4,11(a5)
400168a4:	01871713          	slli	a4,a4,0x18
400168a8:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == group->s6_addr32[1] &&
400168ac:	02e61e63          	bne	a2,a4,400168e8 <net_ipv6_is_addr_mcast_group+0xd0>
		UNALIGNED_GET(&addr->s6_addr32[3]) == group->s6_addr32[3];
400168b0:	00d7c683          	lbu	a3,13(a5)
400168b4:	00c7c703          	lbu	a4,12(a5)
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
400168b8:	00c5a503          	lw	a0,12(a1)
		UNALIGNED_GET(&addr->s6_addr32[3]) == group->s6_addr32[3];
400168bc:	00869693          	slli	a3,a3,0x8
400168c0:	00e6e6b3          	or	a3,a3,a4
400168c4:	00e7c703          	lbu	a4,14(a5)
400168c8:	00f7c783          	lbu	a5,15(a5)
400168cc:	01071713          	slli	a4,a4,0x10
400168d0:	00d76733          	or	a4,a4,a3
400168d4:	01879793          	slli	a5,a5,0x18
400168d8:	00e7e7b3          	or	a5,a5,a4
		UNALIGNED_GET(&addr->s6_addr32[2]) == group->s6_addr32[1] &&
400168dc:	40f50533          	sub	a0,a0,a5
400168e0:	00153513          	seqz	a0,a0
400168e4:	00008067          	ret
}
400168e8:	00008067          	ret

400168ec <net_ipv6_create>:
#define MAX_REACHABLE_TIME 3600000

int net_ipv6_create(struct net_pkt *pkt,
		    const struct in6_addr *src,
		    const struct in6_addr *dst)
{
400168ec:	fd010113          	addi	sp,sp,-48
400168f0:	03212023          	sw	s2,32(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
400168f4:	02800793          	li	a5,40
{
400168f8:	00058913          	mv	s2,a1
	struct net_ipv6_hdr *ipv6_hdr;
	uint8_t tc = 0;

	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
400168fc:	00810593          	addi	a1,sp,8
{
40016900:	02912223          	sw	s1,36(sp)
40016904:	01312e23          	sw	s3,28(sp)
40016908:	02112623          	sw	ra,44(sp)
4001690c:	02812423          	sw	s0,40(sp)
40016910:	00050493          	mv	s1,a0
40016914:	00060993          	mv	s3,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
40016918:	00012423          	sw	zero,8(sp)
4001691c:	00f12623          	sw	a5,12(sp)
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
40016920:	e5cfd0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!ipv6_hdr) {
40016924:	0a050a63          	beqz	a0,400169d8 <net_ipv6_create+0xec>
	return pkt->ip_dscp;
40016928:	0404a783          	lw	a5,64(s1)
		net_ipv6_set_ecn(&tc, net_pkt_ip_ecn(pkt));
	}

	ipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);
	ipv6_hdr->tcflow  = (tc << 4) & 0xF0;
	ipv6_hdr->flow    = 0U;
4001692c:	00050123          	sb	zero,2(a0)
40016930:	000501a3          	sb	zero,3(a0)
 * @param dscp DSCP value to set.
 */
static inline void net_ipv6_set_dscp(uint8_t *tc, uint8_t dscp)
{
	*tc &= ~NET_IPV6_DSCP_MASK;
	*tc |= (dscp << NET_IPV6_DSCP_OFFSET) & NET_IPV6_DSCP_MASK;
40016934:	03f7f713          	andi	a4,a5,63
	return pkt->ip_ecn;
40016938:	0067d793          	srli	a5,a5,0x6
4001693c:	00271713          	slli	a4,a4,0x2
40016940:	0037f793          	andi	a5,a5,3
40016944:	00f767b3          	or	a5,a4,a5
	ipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);
40016948:	00475713          	srli	a4,a4,0x4
	ipv6_hdr->tcflow  = (tc << 4) & 0xF0;
4001694c:	00479793          	slli	a5,a5,0x4
	ipv6_hdr->vtc     = 0x60 | ((tc >> 4) & 0x0F);
40016950:	06076713          	ori	a4,a4,96
40016954:	00e50023          	sb	a4,0(a0)
	ipv6_hdr->tcflow  = (tc << 4) & 0xF0;
40016958:	00f500a3          	sb	a5,1(a0)
	ipv6_hdr->len     = 0U;
4001695c:	00050223          	sb	zero,4(a0)
40016960:	000502a3          	sb	zero,5(a0)
	ipv6_hdr->nexthdr = 0U;
40016964:	00050323          	sb	zero,6(a0)
	return pkt->ipv6_hop_limit;
40016968:	0394c783          	lbu	a5,57(s1)
4001696c:	00050413          	mv	s0,a0

	/* User can tweak the default hop limit if needed */
	ipv6_hdr->hop_limit = net_pkt_ipv6_hop_limit(pkt);
40016970:	00f503a3          	sb	a5,7(a0)
	if (ipv6_hdr->hop_limit == 0U) {
40016974:	00079863          	bnez	a5,40016984 <net_ipv6_create+0x98>
		ipv6_hdr->hop_limit =
			net_if_ipv6_get_hop_limit(net_pkt_iface(pkt));
40016978:	0184a503          	lw	a0,24(s1)
4001697c:	d19f70ef          	jal	ra,4000e694 <net_if_ipv6_get_hop_limit>
		ipv6_hdr->hop_limit =
40016980:	00a403a3          	sb	a0,7(s0)
	memcpy(dest, src, sizeof(struct in6_addr));
40016984:	01000613          	li	a2,16
40016988:	00098593          	mv	a1,s3
4001698c:	01840513          	addi	a0,s0,24
40016990:	ebcf20ef          	jal	ra,4000904c <memcpy>
40016994:	00090593          	mv	a1,s2
40016998:	01000613          	li	a2,16
4001699c:	00840513          	addi	a0,s0,8
400169a0:	eacf20ef          	jal	ra,4000904c <memcpy>
	pkt->ip_hdr_len = len;
400169a4:	02800793          	li	a5,40
400169a8:	02f48b23          	sb	a5,54(s1)
	pkt->ipv6_ext_len = len;
400169ac:	02049d23          	sh	zero,58(s1)
	net_ipv6_addr_copy_raw(ipv6_hdr->src, (uint8_t *)src);

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv6_hdr));
	net_pkt_set_ipv6_ext_len(pkt, 0);

	return net_pkt_set_data(pkt, &ipv6_access);
400169b0:	00810593          	addi	a1,sp,8
400169b4:	00048513          	mv	a0,s1
400169b8:	e54fd0ef          	jal	ra,4001400c <net_pkt_set_data>
}
400169bc:	02c12083          	lw	ra,44(sp)
400169c0:	02812403          	lw	s0,40(sp)
400169c4:	02412483          	lw	s1,36(sp)
400169c8:	02012903          	lw	s2,32(sp)
400169cc:	01c12983          	lw	s3,28(sp)
400169d0:	03010113          	addi	sp,sp,48
400169d4:	00008067          	ret
		return -ENOBUFS;
400169d8:	f9700513          	li	a0,-105
400169dc:	fe1ff06f          	j	400169bc <net_ipv6_create+0xd0>

400169e0 <net_ipv6_finalize>:

int net_ipv6_finalize(struct net_pkt *pkt, uint8_t next_header_proto)
{
400169e0:	fe010113          	addi	sp,sp,-32
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
400169e4:	02800793          	li	a5,40
{
400169e8:	00812c23          	sw	s0,24(sp)
400169ec:	00912a23          	sw	s1,20(sp)
400169f0:	00112e23          	sw	ra,28(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
400169f4:	00012423          	sw	zero,8(sp)
400169f8:	00f12623          	sw	a5,12(sp)
	pkt->overwrite = overwrite;
400169fc:	03754783          	lbu	a5,55(a0)
{
40016a00:	00058493          	mv	s1,a1
	struct net_ipv6_hdr *ipv6_hdr;

	net_pkt_set_overwrite(pkt, true);

	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
40016a04:	00810593          	addi	a1,sp,8
40016a08:	0017e793          	ori	a5,a5,1
40016a0c:	02f50ba3          	sb	a5,55(a0)
{
40016a10:	00050413          	mv	s0,a0
	ipv6_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
40016a14:	d68fd0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!ipv6_hdr) {
40016a18:	00051e63          	bnez	a0,40016a34 <net_ipv6_finalize+0x54>
		return -ENOBUFS;
40016a1c:	f9700513          	li	a0,-105
	} else if (next_header_proto == IPPROTO_ICMPV6) {
		return net_icmpv6_finalize(pkt);
	}

	return 0;
}
40016a20:	01c12083          	lw	ra,28(sp)
40016a24:	01812403          	lw	s0,24(sp)
40016a28:	01412483          	lw	s1,20(sp)
40016a2c:	02010113          	addi	sp,sp,32
40016a30:	00008067          	ret
	ipv6_hdr->len = htons(net_pkt_get_len(pkt) -
40016a34:	00842703          	lw	a4,8(s0)
	size_t bytes = 0;
40016a38:	00000793          	li	a5,0
	while (buf) {
40016a3c:	06071663          	bnez	a4,40016aa8 <net_ipv6_finalize+0xc8>
40016a40:	fd878793          	addi	a5,a5,-40
40016a44:	0087d713          	srli	a4,a5,0x8
40016a48:	0ff77713          	zext.b	a4,a4
40016a4c:	00879793          	slli	a5,a5,0x8
40016a50:	00f767b3          	or	a5,a4,a5
40016a54:	01079713          	slli	a4,a5,0x10
40016a58:	01075713          	srli	a4,a4,0x10
40016a5c:	00f50223          	sb	a5,4(a0)
40016a60:	00875793          	srli	a5,a4,0x8
40016a64:	00f502a3          	sb	a5,5(a0)
	return pkt->ipv6_next_hdr;
40016a68:	03f44783          	lbu	a5,63(s0)
	if (net_pkt_ipv6_next_hdr(pkt) != 255U) {
40016a6c:	0ff00713          	li	a4,255
40016a70:	00e79463          	bne	a5,a4,40016a78 <net_ipv6_finalize+0x98>
		ipv6_hdr->nexthdr = next_header_proto;
40016a74:	00048793          	mv	a5,s1
40016a78:	00f50323          	sb	a5,6(a0)
	net_pkt_set_data(pkt, &ipv6_access);
40016a7c:	00810593          	addi	a1,sp,8
40016a80:	00040513          	mv	a0,s0
40016a84:	d88fd0ef          	jal	ra,4001400c <net_pkt_set_data>
	if (net_pkt_ipv6_next_hdr(pkt) != 255U &&
40016a88:	03f44703          	lbu	a4,63(s0)
40016a8c:	0ff00793          	li	a5,255
40016a90:	02f71463          	bne	a4,a5,40016ab8 <net_ipv6_finalize+0xd8>
	if (IS_ENABLED(CONFIG_NET_UDP) &&
40016a94:	01100793          	li	a5,17
40016a98:	02f49a63          	bne	s1,a5,40016acc <net_ipv6_finalize+0xec>
		return net_udp_finalize(pkt);
40016a9c:	00040513          	mv	a0,s0
40016aa0:	5a4080ef          	jal	ra,4001f044 <net_udp_finalize>
40016aa4:	f7dff06f          	j	40016a20 <net_ipv6_finalize+0x40>
		bytes += buf->len;
40016aa8:	01075683          	lhu	a3,16(a4)
		buf = buf->frags;
40016aac:	00472703          	lw	a4,4(a4)
		bytes += buf->len;
40016ab0:	00d787b3          	add	a5,a5,a3
		buf = buf->frags;
40016ab4:	f89ff06f          	j	40016a3c <net_ipv6_finalize+0x5c>
	    net_pkt_skip(pkt, net_pkt_ipv6_ext_len(pkt))) {
40016ab8:	03a45583          	lhu	a1,58(s0)
40016abc:	00040513          	mv	a0,s0
40016ac0:	ca5fc0ef          	jal	ra,40013764 <net_pkt_skip>
	if (net_pkt_ipv6_next_hdr(pkt) != 255U &&
40016ac4:	fc0508e3          	beqz	a0,40016a94 <net_ipv6_finalize+0xb4>
40016ac8:	f55ff06f          	j	40016a1c <net_ipv6_finalize+0x3c>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
40016acc:	00600793          	li	a5,6
40016ad0:	00f49863          	bne	s1,a5,40016ae0 <net_ipv6_finalize+0x100>
		return net_tcp_finalize(pkt);
40016ad4:	00040513          	mv	a0,s0
40016ad8:	400050ef          	jal	ra,4001bed8 <net_tcp_finalize>
40016adc:	f45ff06f          	j	40016a20 <net_ipv6_finalize+0x40>
	} else if (next_header_proto == IPPROTO_ICMPV6) {
40016ae0:	03a00793          	li	a5,58
	return 0;
40016ae4:	00000513          	li	a0,0
	} else if (next_header_proto == IPPROTO_ICMPV6) {
40016ae8:	f2f49ce3          	bne	s1,a5,40016a20 <net_ipv6_finalize+0x40>
		return net_icmpv6_finalize(pkt);
40016aec:	00040513          	mv	a0,s0
40016af0:	988ff0ef          	jal	ra,40015c78 <net_icmpv6_finalize>
40016af4:	f2dff06f          	j	40016a20 <net_ipv6_finalize+0x40>

40016af8 <net_ipv6_input>:
		return 0;
	}
}

enum net_verdict net_ipv6_input(struct net_pkt *pkt, bool is_loopback)
{
40016af8:	f6010113          	addi	sp,sp,-160
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
40016afc:	02800793          	li	a5,40
40016b00:	02f12823          	sw	a5,48(sp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
40016b04:	03410793          	addi	a5,sp,52
40016b08:	02f12e23          	sw	a5,60(sp)
40016b0c:	00800793          	li	a5,8
40016b10:	04f12023          	sw	a5,64(sp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
40016b14:	04c10793          	addi	a5,sp,76
{
40016b18:	08812c23          	sw	s0,152(sp)
40016b1c:	09212823          	sw	s2,144(sp)
40016b20:	09312623          	sw	s3,140(sp)
40016b24:	08112e23          	sw	ra,156(sp)
40016b28:	08912a23          	sw	s1,148(sp)
40016b2c:	09412423          	sw	s4,136(sp)
40016b30:	09512223          	sw	s5,132(sp)
40016b34:	09612023          	sw	s6,128(sp)
40016b38:	07712e23          	sw	s7,124(sp)
40016b3c:	07812c23          	sw	s8,120(sp)
40016b40:	07912a23          	sw	s9,116(sp)
40016b44:	07a12823          	sw	s10,112(sp)
40016b48:	07b12623          	sw	s11,108(sp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
40016b4c:	04f12223          	sw	a5,68(sp)
40016b50:	01400793          	li	a5,20
40016b54:	04f12423          	sw	a5,72(sp)
	struct net_if *pkt_iface = net_pkt_iface(pkt);
40016b58:	01852783          	lw	a5,24(a0)
{
40016b5c:	00050413          	mv	s0,a0
40016b60:	00058993          	mv	s3,a1
	struct net_if *pkt_iface = net_pkt_iface(pkt);
40016b64:	00f12e23          	sw	a5,28(sp)
	enum net_verdict verdict = NET_DROP;
	int real_len = net_pkt_get_len(pkt);
40016b68:	00852783          	lw	a5,8(a0)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
40016b6c:	02012623          	sw	zero,44(sp)
	size_t bytes = 0;
40016b70:	00000913          	li	s2,0
	while (buf) {
40016b74:	22079a63          	bnez	a5,40016da8 <net_ipv6_input+0x2b0>
	net_pkt_cursor_backup(pkt, &hdr_start);
#endif

	net_stats_update_ipv6_recv(pkt_iface);

	hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
40016b78:	02c10593          	addi	a1,sp,44
40016b7c:	00040513          	mv	a0,s0
40016b80:	bfcfd0ef          	jal	ra,40013f7c <net_pkt_get_data>
40016b84:	00050b93          	mv	s7,a0
	if (!hdr) {
40016b88:	28050863          	beqz	a0,40016e18 <net_ipv6_input+0x320>
		NET_DBG("DROP: no buffer");
		goto drop;
	}

	pkt_len = ntohs(hdr->len) + sizeof(struct net_ipv6_hdr);
40016b8c:	00554703          	lbu	a4,5(a0)
40016b90:	00454683          	lbu	a3,4(a0)
40016b94:	00871713          	slli	a4,a4,0x8
40016b98:	00d76733          	or	a4,a4,a3
40016b9c:	00871493          	slli	s1,a4,0x8
40016ba0:	00875713          	srli	a4,a4,0x8
40016ba4:	00e4e4b3          	or	s1,s1,a4
40016ba8:	01049493          	slli	s1,s1,0x10
40016bac:	0104d493          	srli	s1,s1,0x10
40016bb0:	02848493          	addi	s1,s1,40
	if (real_len < pkt_len) {
40016bb4:	26994263          	blt	s2,s1,40016e18 <net_ipv6_input+0x320>
		NET_DBG("DROP: pkt len per hdr %d != pkt real len %d",
			pkt_len, real_len);
		goto drop;
	} else if (real_len > pkt_len) {
40016bb8:	0124d863          	bge	s1,s2,40016bc8 <net_ipv6_input+0xd0>
		net_pkt_update_length(pkt, pkt_len);
40016bbc:	00048593          	mv	a1,s1
40016bc0:	00040513          	mv	a0,s0
40016bc4:	ff5fc0ef          	jal	ra,40013bb8 <net_pkt_update_length>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40016bc8:	009bc703          	lbu	a4,9(s7)
40016bcc:	008bc683          	lbu	a3,8(s7)
40016bd0:	00871713          	slli	a4,a4,0x8
40016bd4:	00d76733          	or	a4,a4,a3
40016bd8:	00abc683          	lbu	a3,10(s7)
40016bdc:	01069693          	slli	a3,a3,0x10
40016be0:	00e6e6b3          	or	a3,a3,a4
40016be4:	00bbc703          	lbu	a4,11(s7)
40016be8:	01871713          	slli	a4,a4,0x18
40016bec:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40016bf0:	08071463          	bnez	a4,40016c78 <net_ipv6_input+0x180>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
40016bf4:	00dbc703          	lbu	a4,13(s7)
40016bf8:	00cbc683          	lbu	a3,12(s7)
40016bfc:	00871713          	slli	a4,a4,0x8
40016c00:	00d76733          	or	a4,a4,a3
40016c04:	00ebc683          	lbu	a3,14(s7)
40016c08:	01069693          	slli	a3,a3,0x10
40016c0c:	00e6e6b3          	or	a3,a3,a4
40016c10:	00fbc703          	lbu	a4,15(s7)
40016c14:	01871713          	slli	a4,a4,0x18
40016c18:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40016c1c:	04071e63          	bnez	a4,40016c78 <net_ipv6_input+0x180>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40016c20:	011bc703          	lbu	a4,17(s7)
40016c24:	010bc683          	lbu	a3,16(s7)
40016c28:	00871713          	slli	a4,a4,0x8
40016c2c:	00d76733          	or	a4,a4,a3
40016c30:	012bc683          	lbu	a3,18(s7)
40016c34:	01069693          	slli	a3,a3,0x10
40016c38:	00e6e6b3          	or	a3,a3,a4
40016c3c:	013bc703          	lbu	a4,19(s7)
40016c40:	01871713          	slli	a4,a4,0x18
40016c44:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
40016c48:	02071863          	bnez	a4,40016c78 <net_ipv6_input+0x180>
		UNALIGNED_GET(&addr->s6_addr32[3]) == 0;
40016c4c:	015bc703          	lbu	a4,21(s7)
40016c50:	014bc683          	lbu	a3,20(s7)
40016c54:	00871713          	slli	a4,a4,0x8
40016c58:	00d76733          	or	a4,a4,a3
40016c5c:	016bc683          	lbu	a3,22(s7)
40016c60:	01069693          	slli	a3,a3,0x10
40016c64:	00e6e6b3          	or	a3,a3,a4
40016c68:	017bc703          	lbu	a4,23(s7)
40016c6c:	01871713          	slli	a4,a4,0x18
40016c70:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40016c74:	1a070263          	beqz	a4,40016e18 <net_ipv6_input+0x320>
	if (net_ipv6_is_addr_unspecified((struct in6_addr *)hdr->src)) {
		NET_DBG("DROP: src addr is %s", "unspecified");
		goto drop;
	}

	if (net_ipv6_is_addr_mcast((struct in6_addr *)hdr->src) ||
40016c78:	008bc683          	lbu	a3,8(s7)
40016c7c:	0ff00713          	li	a4,255
40016c80:	18e68c63          	beq	a3,a4,40016e18 <net_ipv6_input+0x320>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
40016c84:	018bca03          	lbu	s4,24(s7)
	    net_ipv6_is_addr_mcast_scope((struct in6_addr *)hdr->dst, 0)) {
40016c88:	018b8913          	addi	s2,s7,24
40016c8c:	00ea1663          	bne	s4,a4,40016c98 <net_ipv6_input+0x1a0>
40016c90:	019bc703          	lbu	a4,25(s7)
40016c94:	18070263          	beqz	a4,40016e18 <net_ipv6_input+0x320>
		NET_DBG("DROP: multicast packet");
		goto drop;
	}

	if (!is_loopback) {
40016c98:	12098063          	beqz	s3,40016db8 <net_ipv6_input+0x2c0>
	}

	/* Reconstruct TC field. */

	if (IS_ENABLED(CONFIG_NET_IP_DSCP_ECN)) {
		uint8_t tc = ((hdr->vtc << 4) & 0xF0) | ((hdr->tcflow >> 4) & 0x0F);
40016c9c:	000bc703          	lbu	a4,0(s7)
40016ca0:	001bc683          	lbu	a3,1(s7)
		if (ipv6_forward_mcast_packet(pkt, hdr) == NET_DROP) {
			goto drop;
		}
	}

	if (!net_ipv6_is_addr_mcast((struct in6_addr *)hdr->dst)) {
40016ca4:	0ff00993          	li	s3,255
		uint8_t tc = ((hdr->vtc << 4) & 0xF0) | ((hdr->tcflow >> 4) & 0x0F);
40016ca8:	00471713          	slli	a4,a4,0x4
40016cac:	0046d693          	srli	a3,a3,0x4
40016cb0:	00d76733          	or	a4,a4,a3
40016cb4:	0ff77713          	zext.b	a4,a4
	pkt->ip_dscp = dscp;
40016cb8:	00671693          	slli	a3,a4,0x6
	return (tc & NET_IPV6_DSCP_MASK) >> NET_IPV6_DSCP_OFFSET;
40016cbc:	00275713          	srli	a4,a4,0x2
40016cc0:	00e6e733          	or	a4,a3,a4
40016cc4:	04e40023          	sb	a4,64(s0)
	net_pkt_set_ipv6_next_hdr(pkt, hdr->nexthdr);
40016cc8:	006bc703          	lbu	a4,6(s7)
	pkt->ipv6_ext_len = len;
40016ccc:	02041d23          	sh	zero,58(s0)
	pkt->ipv6_next_hdr = next_hdr;
40016cd0:	02e40fa3          	sb	a4,63(s0)
	pkt->ip_hdr_len = len;
40016cd4:	02800713          	li	a4,40
40016cd8:	02e40b23          	sb	a4,54(s0)
	return pkt->frags->data;
40016cdc:	00842703          	lw	a4,8(s0)
	net_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_HDR(pkt)->hop_limit);
40016ce0:	00c72703          	lw	a4,12(a4)
40016ce4:	00774703          	lbu	a4,7(a4)
	pkt->ipv6_hop_limit = hop_limit;
40016ce8:	02e40ca3          	sb	a4,57(s0)
	pkt->family = family;
40016cec:	03744703          	lbu	a4,55(s0)
40016cf0:	01f77713          	andi	a4,a4,31
40016cf4:	04076713          	ori	a4,a4,64
40016cf8:	02e40ba3          	sb	a4,55(s0)
	if (!net_ipv6_is_addr_mcast((struct in6_addr *)hdr->dst)) {
40016cfc:	018bc703          	lbu	a4,24(s7)
40016d00:	15370663          	beq	a4,s3,40016e4c <net_ipv6_input+0x354>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
40016d04:	00000593          	li	a1,0
40016d08:	00090513          	mv	a0,s2
40016d0c:	a10f60ef          	jal	ra,4000cf1c <net_if_ipv6_addr_lookup>
		if (!net_ipv6_is_my_addr((struct in6_addr *)hdr->dst)) {
40016d10:	12051a63          	bnez	a0,40016e44 <net_ipv6_input+0x34c>
		found = net_route_get_info(net_pkt_iface(pkt),
40016d14:	01842503          	lw	a0,24(s0)
40016d18:	02410693          	addi	a3,sp,36
40016d1c:	02010613          	addi	a2,sp,32
40016d20:	00090593          	mv	a1,s2
40016d24:	479030ef          	jal	ra,4001a99c <net_route_get_info>
	if (found) {
40016d28:	0e050c63          	beqz	a0,40016e20 <net_ipv6_input+0x328>
		if (route) {
40016d2c:	02012783          	lw	a5,32(sp)
40016d30:	02078463          	beqz	a5,40016d58 <net_ipv6_input+0x260>
			net_pkt_set_iface(pkt, route->iface);
40016d34:	00c7a783          	lw	a5,12(a5)
	pkt->iface = iface;
40016d38:	00f42c23          	sw	a5,24(s0)
	if (iface) {
40016d3c:	00078e63          	beqz	a5,40016d58 <net_ipv6_input+0x260>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
40016d40:	0007a703          	lw	a4,0(a5)
40016d44:	01574703          	lbu	a4,21(a4)
40016d48:	02e404a3          	sb	a4,41(s0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
40016d4c:	0007a783          	lw	a5,0(a5)
40016d50:	0157c783          	lbu	a5,21(a5)
40016d54:	02f408a3          	sb	a5,49(s0)
		ret = net_route_packet(pkt, nexthop);
40016d58:	02412583          	lw	a1,36(sp)
40016d5c:	00040513          	mv	a0,s0
40016d60:	4f5030ef          	jal	ra,4001aa54 <net_route_packet>
		if (ret < 0) {
40016d64:	0a054a63          	bltz	a0,40016e18 <net_ipv6_input+0x320>
			if (ipv6_route_packet(pkt, hdr) == NET_OK) {
				return NET_OK;
40016d68:	00000513          	li	a0,0

	NET_DBG("DROP: Unknown/wrong nexthdr type");
	net_stats_update_ip_errors_protoerr(pkt_iface);

	return NET_DROP;
}
40016d6c:	09c12083          	lw	ra,156(sp)
40016d70:	09812403          	lw	s0,152(sp)
40016d74:	09412483          	lw	s1,148(sp)
40016d78:	09012903          	lw	s2,144(sp)
40016d7c:	08c12983          	lw	s3,140(sp)
40016d80:	08812a03          	lw	s4,136(sp)
40016d84:	08412a83          	lw	s5,132(sp)
40016d88:	08012b03          	lw	s6,128(sp)
40016d8c:	07c12b83          	lw	s7,124(sp)
40016d90:	07812c03          	lw	s8,120(sp)
40016d94:	07412c83          	lw	s9,116(sp)
40016d98:	07012d03          	lw	s10,112(sp)
40016d9c:	06c12d83          	lw	s11,108(sp)
40016da0:	0a010113          	addi	sp,sp,160
40016da4:	00008067          	ret
		bytes += buf->len;
40016da8:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
40016dac:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
40016db0:	00e90933          	add	s2,s2,a4
		buf = buf->frags;
40016db4:	dc1ff06f          	j	40016b74 <net_ipv6_input+0x7c>
		if (net_ipv6_is_addr_loopback((struct in6_addr *)hdr->dst) ||
40016db8:	00090513          	mv	a0,s2
40016dbc:	965ff0ef          	jal	ra,40016720 <net_ipv6_is_addr_loopback>
40016dc0:	04051c63          	bnez	a0,40016e18 <net_ipv6_input+0x320>
		    net_ipv6_is_addr_loopback((struct in6_addr *)hdr->src)) {
40016dc4:	008b8513          	addi	a0,s7,8
40016dc8:	959ff0ef          	jal	ra,40016720 <net_ipv6_is_addr_loopback>
		if (net_ipv6_is_addr_loopback((struct in6_addr *)hdr->dst) ||
40016dcc:	04051663          	bnez	a0,40016e18 <net_ipv6_input+0x320>
	return (addr->s6_addr[0] == 0xff) && (addr->s6_addr[1] == scope);
40016dd0:	0ff00713          	li	a4,255
40016dd4:	00ea1863          	bne	s4,a4,40016de4 <net_ipv6_input+0x2ec>
40016dd8:	019bc683          	lbu	a3,25(s7)
40016ddc:	00100713          	li	a4,1
40016de0:	02e68c63          	beq	a3,a4,40016e18 <net_ipv6_input+0x320>
		    (net_ipv6_is_addr_mcast_group(
40016de4:	e89f90ef          	jal	ra,40010c6c <net_ipv6_unspecified_address>
40016de8:	00050593          	mv	a1,a0
40016dec:	00090513          	mv	a0,s2
40016df0:	a29ff0ef          	jal	ra,40016818 <net_ipv6_is_addr_mcast_group>
		if (net_ipv6_is_addr_mcast_iface((struct in6_addr *)hdr->dst) ||
40016df4:	ea0504e3          	beqz	a0,40016c9c <net_ipv6_input+0x1a4>
40016df8:	018bc683          	lbu	a3,24(s7)
40016dfc:	0ff00713          	li	a4,255
40016e00:	e8e69ee3          	bne	a3,a4,40016c9c <net_ipv6_input+0x1a4>
40016e04:	019bc703          	lbu	a4,25(s7)
40016e08:	00500693          	li	a3,5
40016e0c:	00d70663          	beq	a4,a3,40016e18 <net_ipv6_input+0x320>
40016e10:	00800693          	li	a3,8
40016e14:	e8d714e3          	bne	a4,a3,40016c9c <net_ipv6_input+0x1a4>
			return NET_DROP;
40016e18:	00200513          	li	a0,2
40016e1c:	f51ff06f          	j	40016d6c <net_ipv6_input+0x274>
		if (net_if_ipv6_addr_onlink(&iface, (struct in6_addr *)hdr->dst)) {
40016e20:	00090593          	mv	a1,s2
40016e24:	02810513          	addi	a0,sp,40
		struct net_if *iface = NULL;
40016e28:	02012423          	sw	zero,40(sp)
		if (net_if_ipv6_addr_onlink(&iface, (struct in6_addr *)hdr->dst)) {
40016e2c:	cdcf70ef          	jal	ra,4000e308 <net_if_ipv6_addr_onlink>
40016e30:	fe0504e3          	beqz	a0,40016e18 <net_ipv6_input+0x320>
			ret = net_route_packet_if(pkt, iface);
40016e34:	02812583          	lw	a1,40(sp)
40016e38:	00040513          	mv	a0,s0
40016e3c:	551030ef          	jal	ra,4001ab8c <net_route_packet_if>
40016e40:	f25ff06f          	j	40016d64 <net_ipv6_input+0x26c>
	if (net_ipv6_is_addr_mcast((struct in6_addr *)hdr->dst) &&
40016e44:	018bc703          	lbu	a4,24(s7)
40016e48:	01371863          	bne	a4,s3,40016e58 <net_ipv6_input+0x360>
40016e4c:	019bc703          	lbu	a4,25(s7)
40016e50:	00100693          	li	a3,1
40016e54:	0cd71863          	bne	a4,a3,40016f24 <net_ipv6_input+0x42c>
	return net_pkt_skip(pkt, access->size);
40016e58:	03012583          	lw	a1,48(sp)
40016e5c:	00040513          	mv	a0,s0
		return NET_IPV6_EXT_HDR_BITMAP_FRAG;
40016e60:	00800c13          	li	s8,8
40016e64:	901fc0ef          	jal	ra,40013764 <net_pkt_skip>
	current_hdr = hdr->nexthdr;
40016e68:	006bc903          	lbu	s2,6(s7)
	switch (header) {
40016e6c:	02c00693          	li	a3,44
40016e70:	00d90e63          	beq	s2,a3,40016e8c <net_ipv6_input+0x394>
40016e74:	0b26e063          	bltu	a3,s2,40016f14 <net_ipv6_input+0x41c>
40016e78:	00100c13          	li	s8,1
40016e7c:	00090863          	beqz	s2,40016e8c <net_ipv6_input+0x394>
40016e80:	fd590713          	addi	a4,s2,-43
40016e84:	00173713          	seqz	a4,a4
40016e88:	00271c13          	slli	s8,a4,0x2
}
40016e8c:	00600993          	li	s3,6
	uint16_t ext_len = 0U;
40016e90:	00000a13          	li	s4,0
		nexthdr == IPPROTO_TCP ||
40016e94:	03a00a93          	li	s5,58
	switch (header) {
40016e98:	02c00b13          	li	s6,44
	pkt->ipv6_prev_hdr_start = offset;
40016e9c:	03341e23          	sh	s3,60(s0)
40016ea0:	25590863          	beq	s2,s5,400170f0 <net_ipv6_input+0x5f8>
	return (nexthdr == IPPROTO_ICMPV6 || nexthdr == IPPROTO_UDP ||
40016ea4:	01100c93          	li	s9,17
40016ea8:	25990463          	beq	s2,s9,400170f0 <net_ipv6_input+0x5f8>
		nexthdr == IPPROTO_TCP ||
40016eac:	00600693          	li	a3,6
40016eb0:	24d90063          	beq	s2,a3,400170f0 <net_ipv6_input+0x5f8>
		if (current_hdr == NET_IPV6_NEXTHDR_NONE) {
40016eb4:	03b00793          	li	a5,59
40016eb8:	f6f900e3          	beq	s2,a5,40016e18 <net_ipv6_input+0x320>
		prev_hdr_offset = net_pkt_get_current_offset(pkt);
40016ebc:	00040513          	mv	a0,s0
40016ec0:	dfdfc0ef          	jal	ra,40013cbc <net_pkt_get_current_offset>
40016ec4:	00050993          	mv	s3,a0
	return net_pkt_read(pkt, data, 1);
40016ec8:	00100613          	li	a2,1
40016ecc:	02010593          	addi	a1,sp,32
40016ed0:	00040513          	mv	a0,s0
40016ed4:	af9fc0ef          	jal	ra,400139cc <net_pkt_read>
		if (net_pkt_read_u8(pkt, &nexthdr)) {
40016ed8:	f40510e3          	bnez	a0,40016e18 <net_ipv6_input+0x320>
		ext_bit = extension_to_bitmap(nexthdr, ext_bitmap);
40016edc:	02014683          	lbu	a3,32(sp)
	switch (header) {
40016ee0:	17668463          	beq	a3,s6,40017048 <net_ipv6_input+0x550>
40016ee4:	08db6063          	bltu	s6,a3,40016f64 <net_ipv6_input+0x46c>
40016ee8:	00068c63          	beqz	a3,40016f00 <net_ipv6_input+0x408>
40016eec:	02b00613          	li	a2,43
40016ef0:	00c68863          	beq	a3,a2,40016f00 <net_ipv6_input+0x408>
	return (nexthdr == IPPROTO_ICMPV6 || nexthdr == IPPROTO_UDP ||
40016ef4:	09968263          	beq	a3,s9,40016f78 <net_ipv6_input+0x480>
		nexthdr == IPPROTO_TCP ||
40016ef8:	00600613          	li	a2,6
40016efc:	06c68e63          	beq	a3,a2,40016f78 <net_ipv6_input+0x480>
			      net_pkt_get_current_offset(pkt) - 1);
40016f00:	00040513          	mv	a0,s0
40016f04:	db9fc0ef          	jal	ra,40013cbc <net_pkt_get_current_offset>
	net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
40016f08:	fff50693          	addi	a3,a0,-1
40016f0c:	00100613          	li	a2,1
40016f10:	1d00006f          	j	400170e0 <net_ipv6_input+0x5e8>
	switch (header) {
40016f14:	fc490713          	addi	a4,s2,-60
40016f18:	00173713          	seqz	a4,a4
40016f1c:	00171c13          	slli	s8,a4,0x1
40016f20:	f6dff06f          	j	40016e8c <net_ipv6_input+0x394>
40016f24:	00200693          	li	a3,2
40016f28:	00d71c63          	bne	a4,a3,40016f40 <net_ipv6_input+0x448>
	return net_ipv6_is_addr_mcast_group(addr, &all_nodes_mcast_group);
40016f2c:	4002d5b7          	lui	a1,0x4002d
40016f30:	3d058593          	addi	a1,a1,976 # 4002d3d0 <all_nodes_mcast_group.0>
40016f34:	00090513          	mv	a0,s2
40016f38:	8e1ff0ef          	jal	ra,40016818 <net_ipv6_is_addr_mcast_group>
	return net_ipv6_is_addr_mcast_link(addr) &&
40016f3c:	f0051ee3          	bnez	a0,40016e58 <net_ipv6_input+0x360>
		if_mcast_addr = net_if_ipv6_maddr_lookup(
40016f40:	01c10593          	addi	a1,sp,28
40016f44:	00090513          	mv	a0,s2
40016f48:	e2df60ef          	jal	ra,4000dd74 <net_if_ipv6_maddr_lookup>
		if (!if_mcast_addr ||
40016f4c:	ec0506e3          	beqz	a0,40016e18 <net_ipv6_input+0x320>
	return addr->is_joined;
40016f50:	01452703          	lw	a4,20(a0)
40016f54:	00175713          	srli	a4,a4,0x1
40016f58:	00177713          	andi	a4,a4,1
40016f5c:	ee071ee3          	bnez	a4,40016e58 <net_ipv6_input+0x360>
40016f60:	eb9ff06f          	j	40016e18 <net_ipv6_input+0x320>
	switch (header) {
40016f64:	03c00793          	li	a5,60
40016f68:	0ef69863          	bne	a3,a5,40017058 <net_ipv6_input+0x560>
		if (ext_bitmap & NET_IPV6_EXT_HDR_BITMAP_DESTO1) {
40016f6c:	002c7693          	andi	a3,s8,2
40016f70:	0c069463          	bnez	a3,40017038 <net_ipv6_input+0x540>
		ext_bitmap |= ext_bit;
40016f74:	002c6c13          	ori	s8,s8,2
		switch (current_hdr) {
40016f78:	00090663          	beqz	s2,40016f84 <net_ipv6_input+0x48c>
40016f7c:	03c00693          	li	a3,60
40016f80:	f8d910e3          	bne	s2,a3,40016f00 <net_ipv6_input+0x408>
		exthdr_len = ipv6_handle_ext_hdr_options(pkt, hdr, pkt_len);
40016f84:	01049c93          	slli	s9,s1,0x10
40016f88:	00100613          	li	a2,1
40016f8c:	02810593          	addi	a1,sp,40
40016f90:	00040513          	mv	a0,s0
40016f94:	010cdc93          	srli	s9,s9,0x10
		uint8_t val = 0U;
40016f98:	02010423          	sb	zero,40(sp)
40016f9c:	a31fc0ef          	jal	ra,400139cc <net_pkt_read>
		if (net_pkt_read_u8(pkt, &val)) {
40016fa0:	e6051ce3          	bnez	a0,40016e18 <net_ipv6_input+0x320>
		exthdr_len = val * 8U + 8;
40016fa4:	02814903          	lbu	s2,40(sp)
40016fa8:	00190913          	addi	s2,s2,1
40016fac:	00391913          	slli	s2,s2,0x3
	if (exthdr_len > pkt_len) {
40016fb0:	e72ce4e3          	bltu	s9,s2,40016e18 <net_ipv6_input+0x320>
			if (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {
40016fb4:	ffd90793          	addi	a5,s2,-3
	length += 2U;
40016fb8:	00200c93          	li	s9,2
			if (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {
40016fbc:	00f12623          	sw	a5,12(sp)
	switch (opt_type & 0xc0) {
40016fc0:	08000d13          	li	s10,128
40016fc4:	0c000d93          	li	s11,192
		opt_type_offset = net_pkt_get_current_offset(pkt);
40016fc8:	00040513          	mv	a0,s0
40016fcc:	cf1fc0ef          	jal	ra,40013cbc <net_pkt_get_current_offset>
40016fd0:	00a12423          	sw	a0,8(sp)
40016fd4:	00100613          	li	a2,1
40016fd8:	02410593          	addi	a1,sp,36
40016fdc:	00040513          	mv	a0,s0
40016fe0:	9edfc0ef          	jal	ra,400139cc <net_pkt_read>
		if (net_pkt_read_u8(pkt, &opt_type)) {
40016fe4:	e2051ae3          	bnez	a0,40016e18 <net_ipv6_input+0x320>
		if (opt_type != NET_IPV6_EXT_HDR_OPT_PAD1) {
40016fe8:	02414603          	lbu	a2,36(sp)
40016fec:	08061263          	bnez	a2,40017070 <net_ipv6_input+0x578>
		switch (opt_type) {
40016ff0:	02414603          	lbu	a2,36(sp)
40016ff4:	08060a63          	beqz	a2,40017088 <net_ipv6_input+0x590>
40016ff8:	00100513          	li	a0,1
40016ffc:	02814583          	lbu	a1,40(sp)
40017000:	08a60c63          	beq	a2,a0,40017098 <net_ipv6_input+0x5a0>
			if (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {
40017004:	00c12783          	lw	a5,12(sp)
40017008:	e0f5d8e3          	bge	a1,a5,40016e18 <net_ipv6_input+0x320>
	switch (opt_type & 0xc0) {
4001700c:	0c067613          	andi	a2,a2,192
40017010:	0da60463          	beq	a2,s10,400170d8 <net_ipv6_input+0x5e0>
40017014:	0bb60c63          	beq	a2,s11,400170cc <net_ipv6_input+0x5d4>
40017018:	e00610e3          	bnez	a2,40016e18 <net_ipv6_input+0x320>
			if (net_pkt_skip(pkt, opt_len)) {
4001701c:	00040513          	mv	a0,s0
40017020:	f44fc0ef          	jal	ra,40013764 <net_pkt_skip>
40017024:	de051ae3          	bnez	a0,40016e18 <net_ipv6_input+0x320>
			length += opt_len + 2;
40017028:	02814603          	lbu	a2,40(sp)
4001702c:	00260613          	addi	a2,a2,2
40017030:	00cc86b3          	add	a3,s9,a2
40017034:	0580006f          	j	4001708c <net_ipv6_input+0x594>
		if (ext_bit & ext_bitmap) {
40017038:	040c7693          	andi	a3,s8,64
4001703c:	ec0692e3          	bnez	a3,40016f00 <net_ipv6_input+0x408>
		ext_bitmap |= ext_bit;
40017040:	040c6c13          	ori	s8,s8,64
		switch (nexthdr) {
40017044:	f35ff06f          	j	40016f78 <net_ipv6_input+0x480>
		if (ext_bit & ext_bitmap) {
40017048:	008c7693          	andi	a3,s8,8
4001704c:	ea069ae3          	bnez	a3,40016f00 <net_ipv6_input+0x408>
		ext_bitmap |= ext_bit;
40017050:	008c6c13          	ori	s8,s8,8
		switch (nexthdr) {
40017054:	f25ff06f          	j	40016f78 <net_ipv6_input+0x480>
40017058:	fc568613          	addi	a2,a3,-59
4001705c:	0ff67613          	zext.b	a2,a2
40017060:	00100593          	li	a1,1
40017064:	f0c5fae3          	bgeu	a1,a2,40016f78 <net_ipv6_input+0x480>
40017068:	f15688e3          	beq	a3,s5,40016f78 <net_ipv6_input+0x480>
4001706c:	e95ff06f          	j	40016f00 <net_ipv6_input+0x408>
40017070:	00100613          	li	a2,1
40017074:	02810593          	addi	a1,sp,40
40017078:	00040513          	mv	a0,s0
4001707c:	951fc0ef          	jal	ra,400139cc <net_pkt_read>
			if (net_pkt_read_u8(pkt, &opt_len)) {
40017080:	f60508e3          	beqz	a0,40016ff0 <net_ipv6_input+0x4f8>
40017084:	d95ff06f          	j	40016e18 <net_ipv6_input+0x320>
			length++;
40017088:	001c8693          	addi	a3,s9,1
			length += opt_len + 2;
4001708c:	01069c93          	slli	s9,a3,0x10
40017090:	010cdc93          	srli	s9,s9,0x10
			break;
40017094:	01c0006f          	j	400170b0 <net_ipv6_input+0x5b8>
			length += opt_len + 2;
40017098:	00258613          	addi	a2,a1,2
4001709c:	00cc86b3          	add	a3,s9,a2
400170a0:	01069c93          	slli	s9,a3,0x10
			net_pkt_skip(pkt, opt_len);
400170a4:	00040513          	mv	a0,s0
			length += opt_len + 2;
400170a8:	010cdc93          	srli	s9,s9,0x10
			net_pkt_skip(pkt, opt_len);
400170ac:	eb8fc0ef          	jal	ra,40013764 <net_pkt_skip>
	while (length < exthdr_len) {
400170b0:	f12cece3          	bltu	s9,s2,40016fc8 <net_ipv6_input+0x4d0>
		ext_len += exthdr_len;
400170b4:	012a0933          	add	s2,s4,s2
400170b8:	01091a13          	slli	s4,s2,0x10
400170bc:	010a5a13          	srli	s4,s4,0x10
		current_hdr = nexthdr;
400170c0:	02014903          	lbu	s2,32(sp)
		net_pkt_set_ipv6_hdr_prev(pkt, prev_hdr_offset);
400170c4:	0ff9f993          	zext.b	s3,s3
}
400170c8:	dd5ff06f          	j	40016e9c <net_ipv6_input+0x3a4>
		if (net_ipv6_is_addr_mcast((struct in6_addr *)hdr->dst)) {
400170cc:	018bc703          	lbu	a4,24(s7)
400170d0:	0ff00793          	li	a5,255
400170d4:	d4f702e3          	beq	a4,a5,40016e18 <net_ipv6_input+0x320>
		net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
400170d8:	00812683          	lw	a3,8(sp)
400170dc:	00200613          	li	a2,2
	net_icmpv6_send_error(pkt, NET_ICMPV6_PARAM_PROBLEM,
400170e0:	00400593          	li	a1,4
400170e4:	00040513          	mv	a0,s0
400170e8:	df9fe0ef          	jal	ra,40015ee0 <net_icmpv6_send_error>
	return NET_DROP;
400170ec:	d2dff06f          	j	40016e18 <net_ipv6_input+0x320>
	pkt->ipv6_ext_len = len;
400170f0:	03441d23          	sh	s4,58(s0)
	switch (current_hdr) {
400170f4:	01100713          	li	a4,17
400170f8:	04e90663          	beq	s2,a4,40017144 <net_ipv6_input+0x64c>
400170fc:	03a00713          	li	a4,58
40017100:	00e91a63          	bne	s2,a4,40017114 <net_ipv6_input+0x61c>
		verdict = net_icmpv6_input(pkt, hdr);
40017104:	000b8593          	mv	a1,s7
40017108:	00040513          	mv	a0,s0
4001710c:	ab0ff0ef          	jal	ra,400163bc <net_icmpv6_input>
	if (verdict == NET_DROP) {
40017110:	c5dff06f          	j	40016d6c <net_ipv6_input+0x274>
		proto_hdr.tcp = net_tcp_input(pkt, &tcp_access);
40017114:	04410593          	addi	a1,sp,68
40017118:	00040513          	mv	a0,s0
4001711c:	645040ef          	jal	ra,4001bf60 <net_tcp_input>
40017120:	02a12223          	sw	a0,36(sp)
		if (proto_hdr.tcp) {
40017124:	ce050ae3          	beqz	a0,40016e18 <net_ipv6_input+0x320>
	verdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);
40017128:	02410693          	addi	a3,sp,36
4001712c:	00090613          	mv	a2,s2
40017130:	02810593          	addi	a1,sp,40
40017134:	00040513          	mv	a0,s0
	ip.ipv6 = hdr;
40017138:	03712423          	sw	s7,40(sp)
	verdict = net_conn_input(pkt, &ip, current_hdr, &proto_hdr);
4001713c:	efcfd0ef          	jal	ra,40014838 <net_conn_input>
drop:
40017140:	c2dff06f          	j	40016d6c <net_ipv6_input+0x274>
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
40017144:	03c10593          	addi	a1,sp,60
40017148:	00040513          	mv	a0,s0
4001714c:	7d5070ef          	jal	ra,4001f120 <net_udp_input>
40017150:	fd1ff06f          	j	40017120 <net_ipv6_input+0x628>

40017154 <net_ipv6_init>:

void net_ipv6_init(void)
{
40017154:	ff010113          	addi	sp,sp,-16
40017158:	00112623          	sw	ra,12(sp)
	net_ipv6_nbr_init();
4001715c:	6bc020ef          	jal	ra,40019818 <net_ipv6_nbr_init>

#if defined(CONFIG_NET_IPV6_MLD)
	net_ipv6_mld_init();
#endif
}
40017160:	00c12083          	lw	ra,12(sp)
40017164:	01010113          	addi	sp,sp,16
	net_ipv6_mld_init();
40017168:	6310206f          	j	40019f98 <net_ipv6_mld_init>

4001716c <net_ipv6_is_addr_unspecified>:
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001716c:	00154703          	lbu	a4,1(a0)
40017170:	00054683          	lbu	a3,0(a0)
{
40017174:	00050793          	mv	a5,a0
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
40017178:	00871713          	slli	a4,a4,0x8
4001717c:	00d76733          	or	a4,a4,a3
40017180:	00254683          	lbu	a3,2(a0)
40017184:	01069693          	slli	a3,a3,0x10
40017188:	00e6e6b3          	or	a3,a3,a4
4001718c:	00354703          	lbu	a4,3(a0)
40017190:	01871713          	slli	a4,a4,0x18
40017194:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40017198:	08071863          	bnez	a4,40017228 <net_ipv6_is_addr_unspecified+0xbc>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001719c:	00554703          	lbu	a4,5(a0)
400171a0:	00454683          	lbu	a3,4(a0)
400171a4:	00871713          	slli	a4,a4,0x8
400171a8:	00d76733          	or	a4,a4,a3
400171ac:	00654683          	lbu	a3,6(a0)
400171b0:	01069693          	slli	a3,a3,0x10
400171b4:	00e6e6b3          	or	a3,a3,a4
400171b8:	00754703          	lbu	a4,7(a0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
400171bc:	00000513          	li	a0,0
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
400171c0:	01871713          	slli	a4,a4,0x18
400171c4:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
400171c8:	06071263          	bnez	a4,4001722c <net_ipv6_is_addr_unspecified+0xc0>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
400171cc:	0097c703          	lbu	a4,9(a5)
400171d0:	0087c683          	lbu	a3,8(a5)
400171d4:	00871713          	slli	a4,a4,0x8
400171d8:	00d76733          	or	a4,a4,a3
400171dc:	00a7c683          	lbu	a3,10(a5)
400171e0:	01069693          	slli	a3,a3,0x10
400171e4:	00e6e6b3          	or	a3,a3,a4
400171e8:	00b7c703          	lbu	a4,11(a5)
400171ec:	01871713          	slli	a4,a4,0x18
400171f0:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
400171f4:	02071c63          	bnez	a4,4001722c <net_ipv6_is_addr_unspecified+0xc0>
		UNALIGNED_GET(&addr->s6_addr32[3]) == 0;
400171f8:	00d7c683          	lbu	a3,13(a5)
400171fc:	00c7c703          	lbu	a4,12(a5)
40017200:	00f7c503          	lbu	a0,15(a5)
40017204:	00869693          	slli	a3,a3,0x8
40017208:	00e6e6b3          	or	a3,a3,a4
4001720c:	00e7c703          	lbu	a4,14(a5)
40017210:	01851513          	slli	a0,a0,0x18
40017214:	01071713          	slli	a4,a4,0x10
40017218:	00d76733          	or	a4,a4,a3
4001721c:	00e56533          	or	a0,a0,a4
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
40017220:	00153513          	seqz	a0,a0
40017224:	00008067          	ret
40017228:	00000513          	li	a0,0
}
4001722c:	00008067          	ret

40017230 <iface_cb>:
	net_nbr_cb_t cb;
	void *user_data;
};

static void iface_cb(struct net_if *iface, void *user_data)
{
40017230:	fe010113          	addi	sp,sp,-32
40017234:	00812c23          	sw	s0,24(sp)
40017238:	4003c437          	lui	s0,0x4003c
4001723c:	3d840413          	addi	s0,s0,984 # 4003c3d8 <net_neighbor_pool>
40017240:	00912a23          	sw	s1,20(sp)
40017244:	01212823          	sw	s2,16(sp)
40017248:	01312623          	sw	s3,12(sp)
4001724c:	00112e23          	sw	ra,28(sp)
40017250:	00050913          	mv	s2,a0
40017254:	00058493          	mv	s1,a1
	struct iface_cb_data *data = user_data;
	int i;

	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
40017258:	2a040993          	addi	s3,s0,672
		struct net_nbr *nbr = get_nbr(i);

		if (!nbr->ref || nbr->iface != iface) {
4001725c:	00044783          	lbu	a5,0(s0)
40017260:	00078e63          	beqz	a5,4001727c <iface_cb+0x4c>
40017264:	00842783          	lw	a5,8(s0)
40017268:	01279a63          	bne	a5,s2,4001727c <iface_cb+0x4c>
			continue;
		}

		data->cb(nbr, data->user_data);
4001726c:	0004a783          	lw	a5,0(s1)
40017270:	0044a583          	lw	a1,4(s1)
40017274:	00040513          	mv	a0,s0
40017278:	000780e7          	jalr	a5
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001727c:	05440413          	addi	s0,s0,84
40017280:	fd341ee3          	bne	s0,s3,4001725c <iface_cb+0x2c>
	}
}
40017284:	01c12083          	lw	ra,28(sp)
40017288:	01812403          	lw	s0,24(sp)
4001728c:	01412483          	lw	s1,20(sp)
40017290:	01012903          	lw	s2,16(sp)
40017294:	00c12983          	lw	s3,12(sp)
40017298:	02010113          	addi	sp,sp,32
4001729c:	00008067          	ret

400172a0 <net_neighbor_data_remove>:
void net_neighbor_data_remove(struct net_nbr *nbr)
{
	NET_DBG("Neighbor %p removed", nbr);

	return;
}
400172a0:	00008067          	ret

400172a4 <nbr_clear_ns_pending>:
{
400172a4:	ff010113          	addi	sp,sp,-16
400172a8:	00812423          	sw	s0,8(sp)
400172ac:	00112623          	sw	ra,12(sp)
	data->send_ns = 0;
400172b0:	00000793          	li	a5,0
400172b4:	00000813          	li	a6,0
{
400172b8:	00050413          	mv	s0,a0
	data->send_ns = 0;
400172bc:	02f52423          	sw	a5,40(a0)
400172c0:	03052623          	sw	a6,44(a0)
	if (data->pending) {
400172c4:	00052503          	lw	a0,0(a0)
400172c8:	00050663          	beqz	a0,400172d4 <nbr_clear_ns_pending+0x30>
		net_pkt_unref(data->pending);
400172cc:	c51fb0ef          	jal	ra,40012f1c <net_pkt_unref>
		data->pending = NULL;
400172d0:	00042023          	sw	zero,0(s0)
}
400172d4:	00c12083          	lw	ra,12(sp)
400172d8:	00812403          	lw	s0,8(sp)
400172dc:	01010113          	addi	sp,sp,16
400172e0:	00008067          	ret

400172e4 <nbr_free>:
{
400172e4:	ff010113          	addi	sp,sp,-16
400172e8:	00112623          	sw	ra,12(sp)
400172ec:	00812423          	sw	s0,8(sp)
400172f0:	00050413          	mv	s0,a0
	nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
400172f4:	00c52503          	lw	a0,12(a0)
400172f8:	fadff0ef          	jal	ra,400172a4 <nbr_clear_ns_pending>
	return (struct net_ipv6_nbr_data *)nbr->data;
400172fc:	00c42783          	lw	a5,12(s0)
	net_ipv6_nbr_data(nbr)->reachable = 0;
40017300:	00000693          	li	a3,0
40017304:	00000713          	li	a4,0
40017308:	00d7ac23          	sw	a3,24(a5)
4001730c:	00e7ae23          	sw	a4,28(a5)
40017310:	00c42783          	lw	a5,12(s0)
	net_nbr_unref(nbr);
40017314:	00040513          	mv	a0,s0
	net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
40017318:	0207a023          	sw	zero,32(a5)
	net_nbr_unref(nbr);
4001731c:	974ff0ef          	jal	ra,40016490 <net_nbr_unref>
	net_nbr_unlink(nbr, NULL);
40017320:	00040513          	mv	a0,s0
}
40017324:	00812403          	lw	s0,8(sp)
40017328:	00c12083          	lw	ra,12(sp)
	net_nbr_unlink(nbr, NULL);
4001732c:	00000593          	li	a1,0
}
40017330:	01010113          	addi	sp,sp,16
	net_nbr_unlink(nbr, NULL);
40017334:	b48ff06f          	j	4001667c <net_nbr_unlink>

40017338 <k_uptime_get>:
{
40017338:	ff010113          	addi	sp,sp,-16
4001733c:	00112623          	sw	ra,12(sp)
	return z_impl_k_uptime_ticks();
40017340:	075130ef          	jal	ra,4002abb4 <z_impl_k_uptime_ticks>
		} else {
			return t * ((uint64_t)to_hz / from_hz);
40017344:	00a00793          	li	a5,10
40017348:	02a7b733          	mulhu	a4,a5,a0
}
4001734c:	00c12083          	lw	ra,12(sp)
40017350:	01010113          	addi	sp,sp,16
40017354:	02b785b3          	mul	a1,a5,a1
40017358:	02a78533          	mul	a0,a5,a0
4001735c:	00e585b3          	add	a1,a1,a4
40017360:	00008067          	ret

40017364 <ipv6_ns_reply_timeout>:
{
40017364:	fe010113          	addi	sp,sp,-32
40017368:	00912a23          	sw	s1,20(sp)
4001736c:	4003c4b7          	lui	s1,0x4003c
40017370:	01412423          	sw	s4,8(sp)
40017374:	01512223          	sw	s5,4(sp)
40017378:	01612023          	sw	s6,0(sp)
4001737c:	00112e23          	sw	ra,28(sp)
40017380:	00812c23          	sw	s0,24(sp)
40017384:	01212823          	sw	s2,16(sp)
40017388:	01312623          	sw	s3,12(sp)
4001738c:	3d848493          	addi	s1,s1,984 # 4003c3d8 <net_neighbor_pool>
	int64_t current = k_uptime_get();
40017390:	fa9ff0ef          	jal	ra,40017338 <k_uptime_get>
40017394:	00050a13          	mv	s4,a0
40017398:	00058a93          	mv	s5,a1
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001739c:	2a048b13          	addi	s6,s1,672
		if (!nbr || !nbr->ref) {
400173a0:	0004c783          	lbu	a5,0(s1)
400173a4:	08078263          	beqz	a5,40017428 <ipv6_ns_reply_timeout+0xc4>
400173a8:	00c4a903          	lw	s2,12(s1)
		if (!data) {
400173ac:	06090e63          	beqz	s2,40017428 <ipv6_ns_reply_timeout+0xc4>
		if (!data->send_ns) {
400173b0:	02892403          	lw	s0,40(s2)
400173b4:	02c92703          	lw	a4,44(s2)
400173b8:	00e467b3          	or	a5,s0,a4
400173bc:	06078663          	beqz	a5,40017428 <ipv6_ns_reply_timeout+0xc4>
		remaining = data->send_ns + NS_REPLY_TIMEOUT - current;
400173c0:	3e840793          	addi	a5,s0,1000
400173c4:	0087b433          	sltu	s0,a5,s0
400173c8:	00e40433          	add	s0,s0,a4
400173cc:	414789b3          	sub	s3,a5,s4
400173d0:	0137b7b3          	sltu	a5,a5,s3
400173d4:	41540433          	sub	s0,s0,s5
400173d8:	40f40433          	sub	s0,s0,a5
		if (remaining > 0) {
400173dc:	00804663          	bgtz	s0,400173e8 <ipv6_ns_reply_timeout+0x84>
400173e0:	06041c63          	bnez	s0,40017458 <ipv6_ns_reply_timeout+0xf4>
400173e4:	06098a63          	beqz	s3,40017458 <ipv6_ns_reply_timeout+0xf4>
	return z_timeout_remaining(&dwork->timeout);
400173e8:	40031537          	lui	a0,0x40031
400173ec:	08850513          	addi	a0,a0,136 # 40031088 <ipv6_ns_reply_timer+0x10>
400173f0:	5f8130ef          	jal	ra,4002a9e8 <z_timeout_remaining>
			if (!k_work_delayable_remaining_get(
400173f4:	00b56533          	or	a0,a0,a1
400173f8:	02051863          	bnez	a0,40017428 <ipv6_ns_reply_timeout+0xc4>
		t += off;
400173fc:	00998513          	addi	a0,s3,9
40017400:	013539b3          	sltu	s3,a0,s3
			return t / ((uint64_t)from_hz / to_hz);
40017404:	00a00613          	li	a2,10
40017408:	00000693          	li	a3,0
4001740c:	008985b3          	add	a1,s3,s0
40017410:	ea9e80ef          	jal	ra,400002b8 <__udivdi3>
				k_work_reschedule(&ipv6_ns_reply_timer,
40017414:	00058613          	mv	a2,a1
40017418:	00050593          	mv	a1,a0
4001741c:	40031537          	lui	a0,0x40031
40017420:	07850513          	addi	a0,a0,120 # 40031078 <ipv6_ns_reply_timer>
40017424:	200120ef          	jal	ra,40029624 <k_work_reschedule>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
40017428:	05448493          	addi	s1,s1,84
4001742c:	f7649ae3          	bne	s1,s6,400173a0 <ipv6_ns_reply_timeout+0x3c>
}
40017430:	01c12083          	lw	ra,28(sp)
40017434:	01812403          	lw	s0,24(sp)
40017438:	01412483          	lw	s1,20(sp)
4001743c:	01012903          	lw	s2,16(sp)
40017440:	00c12983          	lw	s3,12(sp)
40017444:	00812a03          	lw	s4,8(sp)
40017448:	00412a83          	lw	s5,4(sp)
4001744c:	00012b03          	lw	s6,0(sp)
40017450:	02010113          	addi	sp,sp,32
40017454:	00008067          	ret
		if (!data->pending) {
40017458:	00092503          	lw	a0,0(s2)
		data->send_ns = 0;
4001745c:	00000793          	li	a5,0
40017460:	00000813          	li	a6,0
40017464:	02f92423          	sw	a5,40(s2)
40017468:	03092623          	sw	a6,44(s2)
		if (!data->pending) {
4001746c:	fa050ee3          	beqz	a0,40017428 <ipv6_ns_reply_timeout+0xc4>
		net_pkt_unref(data->pending);
40017470:	aadfb0ef          	jal	ra,40012f1c <net_pkt_unref>
		net_pkt_unref(data->pending);
40017474:	00092503          	lw	a0,0(s2)
40017478:	aa5fb0ef          	jal	ra,40012f1c <net_pkt_unref>
		net_nbr_unref(nbr);
4001747c:	00048513          	mv	a0,s1
		data->pending = NULL;
40017480:	00092023          	sw	zero,0(s2)
		net_nbr_unref(nbr);
40017484:	80cff0ef          	jal	ra,40016490 <net_nbr_unref>
40017488:	fa1ff06f          	j	40017428 <ipv6_ns_reply_timeout+0xc4>

4001748c <set_llao>:
}

static inline bool set_llao(struct net_pkt *pkt,
			    struct net_linkaddr *lladdr,
			    uint8_t llao_len, uint8_t type)
{
4001748c:	fe010113          	addi	sp,sp,-32
40017490:	00812c23          	sw	s0,24(sp)
40017494:	00912a23          	sw	s1,20(sp)
	struct net_icmpv6_nd_opt_hdr opt_hdr = {
40017498:	00365793          	srli	a5,a2,0x3
{
4001749c:	00058493          	mv	s1,a1
400174a0:	00060413          	mv	s0,a2
		.type = type,
		.len  = llao_len >> 3,
	};

	if (net_pkt_write(pkt, &opt_hdr,
400174a4:	00c10593          	addi	a1,sp,12
400174a8:	00200613          	li	a2,2
{
400174ac:	01212823          	sw	s2,16(sp)
400174b0:	00112e23          	sw	ra,28(sp)
400174b4:	00050913          	mv	s2,a0
	struct net_icmpv6_nd_opt_hdr opt_hdr = {
400174b8:	00d10623          	sb	a3,12(sp)
400174bc:	00f106a3          	sb	a5,13(sp)
	if (net_pkt_write(pkt, &opt_hdr,
400174c0:	a59fc0ef          	jal	ra,40013f18 <net_pkt_write>
400174c4:	02050063          	beqz	a0,400174e4 <set_llao+0x58>
			  sizeof(struct net_icmpv6_nd_opt_hdr)) ||
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
	    net_pkt_memset(pkt, 0, llao_len - lladdr->len - 2)) {
		return false;
400174c8:	00000513          	li	a0,0
	}

	return true;
}
400174cc:	01c12083          	lw	ra,28(sp)
400174d0:	01812403          	lw	s0,24(sp)
400174d4:	01412483          	lw	s1,20(sp)
400174d8:	01012903          	lw	s2,16(sp)
400174dc:	02010113          	addi	sp,sp,32
400174e0:	00008067          	ret
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
400174e4:	0044c603          	lbu	a2,4(s1)
400174e8:	0004a583          	lw	a1,0(s1)
400174ec:	00090513          	mv	a0,s2
400174f0:	a29fc0ef          	jal	ra,40013f18 <net_pkt_write>
			  sizeof(struct net_icmpv6_nd_opt_hdr)) ||
400174f4:	fc051ae3          	bnez	a0,400174c8 <set_llao+0x3c>
	    net_pkt_memset(pkt, 0, llao_len - lladdr->len - 2)) {
400174f8:	0044c783          	lbu	a5,4(s1)
400174fc:	00000593          	li	a1,0
40017500:	00090513          	mv	a0,s2
40017504:	40f40633          	sub	a2,s0,a5
40017508:	ffe60613          	addi	a2,a2,-2
4001750c:	c98fc0ef          	jal	ra,400139a4 <net_pkt_memset>
	    net_pkt_write(pkt, lladdr->addr, lladdr->len) ||
40017510:	00153513          	seqz	a0,a0
40017514:	fb9ff06f          	j	400174cc <set_llao+0x40>

40017518 <read_llao>:

static bool read_llao(struct net_pkt *pkt,
		      uint8_t len,
		      struct net_linkaddr_storage *llstorage)
{
40017518:	ff010113          	addi	sp,sp,-16
4001751c:	00812423          	sw	s0,8(sp)
40017520:	00912223          	sw	s1,4(sp)
40017524:	01212023          	sw	s2,0(sp)
40017528:	00112623          	sw	ra,12(sp)
	uint8_t padding;

	llstorage->len = NET_LINK_ADDR_MAX_LENGTH;
4001752c:	00600793          	li	a5,6
40017530:	00f600a3          	sb	a5,1(a2)
	if (net_pkt_lladdr_src(pkt)->len < llstorage->len) {
40017534:	02854703          	lbu	a4,40(a0)
{
40017538:	00060493          	mv	s1,a2
4001753c:	00050913          	mv	s2,a0
40017540:	00058413          	mv	s0,a1
	if (net_pkt_lladdr_src(pkt)->len < llstorage->len) {
40017544:	00600613          	li	a2,6
40017548:	00e7e463          	bltu	a5,a4,40017550 <read_llao+0x38>
4001754c:	0ff77613          	zext.b	a2,a4
40017550:	00c480a3          	sb	a2,1(s1)
		llstorage->len = net_pkt_lladdr_src(pkt)->len;
	}

	if (net_pkt_read(pkt, llstorage->addr, llstorage->len)) {
40017554:	00248593          	addi	a1,s1,2
40017558:	00090513          	mv	a0,s2
4001755c:	c70fc0ef          	jal	ra,400139cc <net_pkt_read>
		return false;
40017560:	00000793          	li	a5,0
	if (net_pkt_read(pkt, llstorage->addr, llstorage->len)) {
40017564:	02051663          	bnez	a0,40017590 <read_llao+0x78>
	}

	padding = len * 8U - 2 - llstorage->len;
40017568:	0014c783          	lbu	a5,1(s1)
4001756c:	00341593          	slli	a1,s0,0x3
40017570:	ffe58593          	addi	a1,a1,-2
40017574:	40f585b3          	sub	a1,a1,a5
40017578:	0ff5f593          	zext.b	a1,a1
		if (net_pkt_skip(pkt, padding)) {
			return false;
		}
	}

	return true;
4001757c:	00100793          	li	a5,1
	if (padding) {
40017580:	00058863          	beqz	a1,40017590 <read_llao+0x78>
		if (net_pkt_skip(pkt, padding)) {
40017584:	00090513          	mv	a0,s2
40017588:	9dcfc0ef          	jal	ra,40013764 <net_pkt_skip>
4001758c:	00153793          	seqz	a5,a0
}
40017590:	00c12083          	lw	ra,12(sp)
40017594:	00812403          	lw	s0,8(sp)
40017598:	00412483          	lw	s1,4(sp)
4001759c:	00012903          	lw	s2,0(sp)
400175a0:	00078513          	mv	a0,a5
400175a4:	01010113          	addi	sp,sp,16
400175a8:	00008067          	ret

400175ac <ipv6_nd_restart_reachable_timer>:
}
#endif /* CONFIG_NET_IPV6_NBR_CACHE */

#if defined(CONFIG_NET_IPV6_ND)
static void ipv6_nd_restart_reachable_timer(struct net_nbr *nbr, int64_t time)
{
400175ac:	fe010113          	addi	sp,sp,-32
400175b0:	00812c23          	sw	s0,24(sp)
400175b4:	00912a23          	sw	s1,20(sp)
400175b8:	00112e23          	sw	ra,28(sp)
400175bc:	01212823          	sw	s2,16(sp)
400175c0:	01312623          	sw	s3,12(sp)
400175c4:	00058413          	mv	s0,a1
400175c8:	00060493          	mv	s1,a2
	int64_t remaining;

	if (nbr) {
400175cc:	02050063          	beqz	a0,400175ec <ipv6_nd_restart_reachable_timer+0x40>
400175d0:	00c52983          	lw	s3,12(a0)
400175d4:	00050913          	mv	s2,a0
		net_ipv6_nbr_data(nbr)->reachable = k_uptime_get();
400175d8:	d61ff0ef          	jal	ra,40017338 <k_uptime_get>
400175dc:	00a9ac23          	sw	a0,24(s3)
400175e0:	00b9ae23          	sw	a1,28(s3)
400175e4:	00c92783          	lw	a5,12(s2)
		net_ipv6_nbr_data(nbr)->reachable_timeout = time;
400175e8:	0287a023          	sw	s0,32(a5)
400175ec:	40031537          	lui	a0,0x40031
400175f0:	0b850513          	addi	a0,a0,184 # 400310b8 <ipv6_nd_reachable_timer+0x10>
400175f4:	3f4130ef          	jal	ra,4002a9e8 <z_timeout_remaining>
			return ((uint32_t)t) * (to_hz / from_hz);
400175f8:	00a00793          	li	a5,10
400175fc:	02a78533          	mul	a0,a5,a0
	}

	remaining = k_ticks_to_ms_ceil32(
40017600:	00000793          	li	a5,0
		k_work_delayable_remaining_get(&ipv6_nd_reachable_timer));
	if (!remaining || remaining > time) {
40017604:	00050863          	beqz	a0,40017614 <ipv6_nd_restart_reachable_timer+0x68>
40017608:	00f4c663          	blt	s1,a5,40017614 <ipv6_nd_restart_reachable_timer+0x68>
4001760c:	04049c63          	bnez	s1,40017664 <ipv6_nd_restart_reachable_timer+0xb8>
40017610:	04a47a63          	bgeu	s0,a0,40017664 <ipv6_nd_restart_reachable_timer+0xb8>
		k_work_reschedule(&ipv6_nd_reachable_timer, K_MSEC(time));
40017614:	0004d663          	bgez	s1,40017620 <ipv6_nd_restart_reachable_timer+0x74>
40017618:	00000413          	li	s0,0
4001761c:	00000493          	li	s1,0
		t += off;
40017620:	00940513          	addi	a0,s0,9
40017624:	00853433          	sltu	s0,a0,s0
			return t / ((uint64_t)from_hz / to_hz);
40017628:	009405b3          	add	a1,s0,s1
4001762c:	00a00613          	li	a2,10
40017630:	00000693          	li	a3,0
40017634:	c85e80ef          	jal	ra,400002b8 <__udivdi3>
	}
}
40017638:	01812403          	lw	s0,24(sp)
4001763c:	01c12083          	lw	ra,28(sp)
40017640:	01412483          	lw	s1,20(sp)
40017644:	01012903          	lw	s2,16(sp)
40017648:	00c12983          	lw	s3,12(sp)
		k_work_reschedule(&ipv6_nd_reachable_timer, K_MSEC(time));
4001764c:	00058613          	mv	a2,a1
40017650:	00050593          	mv	a1,a0
40017654:	40031537          	lui	a0,0x40031
40017658:	0a850513          	addi	a0,a0,168 # 400310a8 <ipv6_nd_reachable_timer>
}
4001765c:	02010113          	addi	sp,sp,32
		k_work_reschedule(&ipv6_nd_reachable_timer, K_MSEC(time));
40017660:	7c51106f          	j	40029624 <k_work_reschedule>
}
40017664:	01c12083          	lw	ra,28(sp)
40017668:	01812403          	lw	s0,24(sp)
4001766c:	01412483          	lw	s1,20(sp)
40017670:	01012903          	lw	s2,16(sp)
40017674:	00c12983          	lw	s3,12(sp)
40017678:	02010113          	addi	sp,sp,32
4001767c:	00008067          	ret

40017680 <dbg_update_neighbor_lladdr.constprop.0>:
static void dbg_update_neighbor_lladdr(const struct net_linkaddr *new_lladdr,
40017680:	fd010113          	addi	sp,sp,-48
40017684:	02112623          	sw	ra,44(sp)

static inline char *net_sprint_ll_addr(const uint8_t *ll, uint8_t ll_len)
{
	static char buf[sizeof("xx:xx:xx:xx:xx:xx:xx:xx")];

	return net_sprint_ll_addr_buf(ll, ll_len, (char *)buf, sizeof(buf));
40017688:	00154583          	lbu	a1,1(a0)
4001768c:	40032637          	lui	a2,0x40032
40017690:	01800693          	li	a3,24
40017694:	5fc60613          	addi	a2,a2,1532 # 400325fc <buf.0>
40017698:	00250513          	addi	a0,a0,2
4001769c:	e5cf80ef          	jal	ra,4000fcf8 <net_sprint_ll_addr_buf>
	snprintk(out, sizeof(out), "%s",
400176a0:	4002c637          	lui	a2,0x4002c
400176a4:	00050693          	mv	a3,a0
400176a8:	78460613          	addi	a2,a2,1924 # 4002c784 <shell_telnet_fprintf+0x128>
400176ac:	00810513          	addi	a0,sp,8
400176b0:	01800593          	li	a1,24
400176b4:	915e90ef          	jal	ra,40000fc8 <snprintk>
}
400176b8:	02c12083          	lw	ra,44(sp)
400176bc:	03010113          	addi	sp,sp,48
400176c0:	00008067          	ret

400176c4 <nbr_lookup.constprop.0>:
static struct net_nbr *nbr_lookup(struct net_nbr_table *table,
400176c4:	fe010113          	addi	sp,sp,-32
400176c8:	4003c7b7          	lui	a5,0x4003c
400176cc:	00812c23          	sw	s0,24(sp)
400176d0:	00912a23          	sw	s1,20(sp)
400176d4:	01212823          	sw	s2,16(sp)
400176d8:	01312623          	sw	s3,12(sp)
400176dc:	01412423          	sw	s4,8(sp)
400176e0:	01512223          	sw	s5,4(sp)
400176e4:	00112e23          	sw	ra,28(sp)
400176e8:	00050993          	mv	s3,a0
400176ec:	00058a13          	mv	s4,a1
400176f0:	3d878913          	addi	s2,a5,984 # 4003c3d8 <net_neighbor_pool>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
400176f4:	00000493          	li	s1,0
400176f8:	3d878413          	addi	s0,a5,984
400176fc:	00800a93          	li	s5,8
		if (!nbr->ref) {
40017700:	00094783          	lbu	a5,0(s2)
40017704:	02079c63          	bnez	a5,4001773c <nbr_lookup.constprop.0+0x78>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
40017708:	00148493          	addi	s1,s1,1
4001770c:	05490913          	addi	s2,s2,84
40017710:	ff5498e3          	bne	s1,s5,40017700 <nbr_lookup.constprop.0+0x3c>
	return NULL;
40017714:	00000513          	li	a0,0
}
40017718:	01c12083          	lw	ra,28(sp)
4001771c:	01812403          	lw	s0,24(sp)
40017720:	01412483          	lw	s1,20(sp)
40017724:	01012903          	lw	s2,16(sp)
40017728:	00c12983          	lw	s3,12(sp)
4001772c:	00812a03          	lw	s4,8(sp)
40017730:	00412a83          	lw	s5,4(sp)
40017734:	02010113          	addi	sp,sp,32
40017738:	00008067          	ret
		if (iface && nbr->iface != iface) {
4001773c:	00098663          	beqz	s3,40017748 <nbr_lookup.constprop.0+0x84>
40017740:	00892783          	lw	a5,8(s2)
40017744:	fcf992e3          	bne	s3,a5,40017708 <nbr_lookup.constprop.0+0x44>
		if (net_ipv6_addr_cmp(&net_ipv6_nbr_data(nbr)->addr, addr)) {
40017748:	00c92503          	lw	a0,12(s2)
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4001774c:	01000613          	li	a2,16
40017750:	000a0593          	mv	a1,s4
40017754:	00450513          	addi	a0,a0,4
40017758:	875f10ef          	jal	ra,40008fcc <memcmp>
4001775c:	fa0516e3          	bnez	a0,40017708 <nbr_lookup.constprop.0+0x44>
	return &net_neighbor_pool[idx].nbr;
40017760:	05400793          	li	a5,84
40017764:	02f484b3          	mul	s1,s1,a5
40017768:	00940533          	add	a0,s0,s1
4001776c:	fadff06f          	j	40017718 <nbr_lookup.constprop.0+0x54>

40017770 <net_if_flag_is_set>:
	if (iface == NULL) {
40017770:	02050c63          	beqz	a0,400177a8 <net_if_flag_is_set+0x38>
{
40017774:	ff010113          	addi	sp,sp,-16
40017778:	00812423          	sw	s0,8(sp)
4001777c:	00112623          	sw	ra,12(sp)
	return atomic_test_bit(iface->if_dev->flags, value);
40017780:	00052503          	lw	a0,0(a0)
40017784:	00058413          	mv	s0,a1
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
40017788:	00c50513          	addi	a0,a0,12
4001778c:	05d130ef          	jal	ra,4002afe8 <atomic_get>
}
40017790:	00c12083          	lw	ra,12(sp)
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
40017794:	40855533          	sra	a0,a0,s0
40017798:	00812403          	lw	s0,8(sp)
4001779c:	00157513          	andi	a0,a0,1
400177a0:	01010113          	addi	sp,sp,16
400177a4:	00008067          	ret
		return false;
400177a8:	00000513          	li	a0,0
}
400177ac:	00008067          	ret

400177b0 <net_pkt_acknowledge_data.isra.0>:
	return net_pkt_skip(pkt, access->size);
400177b0:	fb5fb06f          	j	40013764 <net_pkt_skip>

400177b4 <net_linkaddr_set.isra.0>:
	if (!lladdr_store || !new_addr) {
400177b4:	00050e63          	beqz	a0,400177d0 <net_linkaddr_set.isra.0+0x1c>
400177b8:	00058c63          	beqz	a1,400177d0 <net_linkaddr_set.isra.0+0x1c>
	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
400177bc:	00600713          	li	a4,6
400177c0:	00c76863          	bltu	a4,a2,400177d0 <net_linkaddr_set.isra.0+0x1c>
	lladdr_store->len = new_len;
400177c4:	00c500a3          	sb	a2,1(a0)
	memcpy(lladdr_store->addr, new_addr, new_len);
400177c8:	00250513          	addi	a0,a0,2
400177cc:	881f106f          	j	4000904c <memcpy>

	return 0;
}
400177d0:	00008067          	ret

400177d4 <net_neighbor_table_clear>:
void net_neighbor_table_clear(struct net_nbr_table *table)
400177d4:	00008067          	ret

400177d8 <ipv6_nbr_set_state>:
400177d8:	00c52783          	lw	a5,12(a0)
	if (new_state == net_ipv6_nbr_data(nbr)->state ||
400177dc:	0307a703          	lw	a4,48(a5)
400177e0:	0eb70663          	beq	a4,a1,400178cc <ipv6_nbr_set_state+0xf4>
400177e4:	00500693          	li	a3,5
400177e8:	0ed70263          	beq	a4,a3,400178cc <ipv6_nbr_set_state+0xf4>
{
400177ec:	ff010113          	addi	sp,sp,-16
400177f0:	00812423          	sw	s0,8(sp)
400177f4:	00112623          	sw	ra,12(sp)
400177f8:	00912223          	sw	s1,4(sp)
400177fc:	01212023          	sw	s2,0(sp)
	net_ipv6_nbr_data(nbr)->state = new_state;
40017800:	02b7a823          	sw	a1,48(a5)
40017804:	00c52703          	lw	a4,12(a0)
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_STALE) {
40017808:	00200793          	li	a5,2
4001780c:	00050413          	mv	s0,a0
40017810:	03072683          	lw	a3,48(a4)
40017814:	02f69063          	bne	a3,a5,40017834 <ipv6_nbr_set_state+0x5c>
		if (stale_counter + 1 != UINT32_MAX) {
40017818:	400314b7          	lui	s1,0x40031
4001781c:	aa84a783          	lw	a5,-1368(s1) # 40030aa8 <stale_counter>
40017820:	ffe00693          	li	a3,-2
40017824:	02d78463          	beq	a5,a3,4001784c <ipv6_nbr_set_state+0x74>
			net_ipv6_nbr_data(nbr)->stale_counter = stale_counter++;
40017828:	00178693          	addi	a3,a5,1
4001782c:	aad4a423          	sw	a3,-1368(s1)
40017830:	02f72c23          	sw	a5,56(a4)
}
40017834:	00c12083          	lw	ra,12(sp)
40017838:	00812403          	lw	s0,8(sp)
4001783c:	00412483          	lw	s1,4(sp)
40017840:	00012903          	lw	s2,0(sp)
40017844:	01010113          	addi	sp,sp,16
40017848:	00008067          	ret
	return z_impl_k_sem_take(sem, timeout);
4001784c:	40032937          	lui	s2,0x40032
40017850:	fff00593          	li	a1,-1
40017854:	fff00613          	li	a2,-1
40017858:	61490513          	addi	a0,s2,1556 # 40032614 <nbr_lock>
4001785c:	598110ef          	jal	ra,40028df4 <z_impl_k_sem_take>
			stale_counter = 0U;
40017860:	4003c7b7          	lui	a5,0x4003c
40017864:	3d878793          	addi	a5,a5,984 # 4003c3d8 <net_neighbor_pool>
40017868:	aa04a423          	sw	zero,-1368(s1)
			for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
4001786c:	2a078593          	addi	a1,a5,672
			stale_counter = 0U;
40017870:	00000613          	li	a2,0
40017874:	00000713          	li	a4,0
				if (data->state != NET_IPV6_NBR_STATE_STALE) {
40017878:	00200513          	li	a0,2
				if (!n || !n->ref) {
4001787c:	0007c683          	lbu	a3,0(a5)
40017880:	02068063          	beqz	a3,400178a0 <ipv6_nbr_set_state+0xc8>
40017884:	00c42683          	lw	a3,12(s0)
				if (!data) {
40017888:	00068c63          	beqz	a3,400178a0 <ipv6_nbr_set_state+0xc8>
				if (data->state != NET_IPV6_NBR_STATE_STALE) {
4001788c:	0306a803          	lw	a6,48(a3)
40017890:	00a81863          	bne	a6,a0,400178a0 <ipv6_nbr_set_state+0xc8>
				data->stale_counter = stale_counter++;
40017894:	02e6ac23          	sw	a4,56(a3)
40017898:	00100613          	li	a2,1
4001789c:	00170713          	addi	a4,a4,1
			for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
400178a0:	05478793          	addi	a5,a5,84
400178a4:	fcb79ce3          	bne	a5,a1,4001787c <ipv6_nbr_set_state+0xa4>
400178a8:	00060463          	beqz	a2,400178b0 <ipv6_nbr_set_state+0xd8>
400178ac:	aae4a423          	sw	a4,-1368(s1)
}
400178b0:	00812403          	lw	s0,8(sp)
400178b4:	00c12083          	lw	ra,12(sp)
400178b8:	00412483          	lw	s1,4(sp)
	z_impl_k_sem_give(sem);
400178bc:	61490513          	addi	a0,s2,1556
400178c0:	00012903          	lw	s2,0(sp)
400178c4:	01010113          	addi	sp,sp,16
400178c8:	4bc1106f          	j	40028d84 <z_impl_k_sem_give>
400178cc:	00008067          	ret

400178d0 <nbr_new>:
{
400178d0:	fc010113          	addi	sp,sp,-64
400178d4:	03312623          	sw	s3,44(sp)
400178d8:	00050993          	mv	s3,a0
	struct net_nbr *nbr = net_nbr_get(&net_neighbor.table);
400178dc:	4003c537          	lui	a0,0x4003c
400178e0:	3cc50513          	addi	a0,a0,972 # 4003c3cc <net_neighbor>
{
400178e4:	02812c23          	sw	s0,56(sp)
400178e8:	02912a23          	sw	s1,52(sp)
400178ec:	03212823          	sw	s2,48(sp)
400178f0:	02112e23          	sw	ra,60(sp)
400178f4:	00b12623          	sw	a1,12(sp)
400178f8:	00060493          	mv	s1,a2
400178fc:	00068913          	mv	s2,a3
	struct net_nbr *nbr = net_nbr_get(&net_neighbor.table);
40017900:	bc5fe0ef          	jal	ra,400164c4 <net_nbr_get>
40017904:	00050413          	mv	s0,a0
	if (!nbr) {
40017908:	06050c63          	beqz	a0,40017980 <nbr_new+0xb0>
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
4001790c:	00c12583          	lw	a1,12(sp)
	nbr->idx = NET_NBR_LLADDR_UNKNOWN;
40017910:	fff00793          	li	a5,-1
	nbr->iface = iface;
40017914:	01352423          	sw	s3,8(a0)
40017918:	00c52983          	lw	s3,12(a0)
	nbr->idx = NET_NBR_LLADDR_UNKNOWN;
4001791c:	00f500a3          	sb	a5,1(a0)
	net_ipaddr_copy(&net_ipv6_nbr_data(nbr)->addr, addr);
40017920:	01000613          	li	a2,16
40017924:	01010513          	addi	a0,sp,16
40017928:	f24f10ef          	jal	ra,4000904c <memcpy>
4001792c:	01000613          	li	a2,16
40017930:	01010593          	addi	a1,sp,16
40017934:	00498513          	addi	a0,s3,4
40017938:	f14f10ef          	jal	ra,4000904c <memcpy>
	ipv6_nbr_set_state(nbr, state);
4001793c:	00090593          	mv	a1,s2
40017940:	00040513          	mv	a0,s0
40017944:	e95ff0ef          	jal	ra,400177d8 <ipv6_nbr_set_state>
40017948:	00c42783          	lw	a5,12(s0)
	net_ipv6_nbr_data(nbr)->send_ns = 0;
4001794c:	00000693          	li	a3,0
40017950:	00000713          	li	a4,0
	net_ipv6_nbr_data(nbr)->is_router = is_router;
40017954:	02978ba3          	sb	s1,55(a5)
40017958:	00c42783          	lw	a5,12(s0)
	net_ipv6_nbr_data(nbr)->pending = NULL;
4001795c:	0007a023          	sw	zero,0(a5)
40017960:	00c42783          	lw	a5,12(s0)
	net_ipv6_nbr_data(nbr)->send_ns = 0;
40017964:	02d7a423          	sw	a3,40(a5)
40017968:	02e7a623          	sw	a4,44(a5)
4001796c:	00c42783          	lw	a5,12(s0)
	net_ipv6_nbr_data(nbr)->reachable = 0;
40017970:	00d7ac23          	sw	a3,24(a5)
40017974:	00e7ae23          	sw	a4,28(a5)
40017978:	00c42783          	lw	a5,12(s0)
	net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
4001797c:	0207a023          	sw	zero,32(a5)
}
40017980:	03c12083          	lw	ra,60(sp)
40017984:	00040513          	mv	a0,s0
40017988:	03812403          	lw	s0,56(sp)
4001798c:	03412483          	lw	s1,52(sp)
40017990:	03012903          	lw	s2,48(sp)
40017994:	02c12983          	lw	s3,44(sp)
40017998:	04010113          	addi	sp,sp,64
4001799c:	00008067          	ret

400179a0 <net_ipv6_nbr_state2str>:
	switch (state) {
400179a0:	00500793          	li	a5,5
400179a4:	00a7ee63          	bltu	a5,a0,400179c0 <net_ipv6_nbr_state2str+0x20>
400179a8:	4002d7b7          	lui	a5,0x4002d
400179ac:	00251513          	slli	a0,a0,0x2
400179b0:	44878793          	addi	a5,a5,1096 # 4002d448 <CSWTCH.15321>
400179b4:	00a787b3          	add	a5,a5,a0
400179b8:	0007a503          	lw	a0,0(a5)
400179bc:	00008067          	ret
{
400179c0:	4002d537          	lui	a0,0x4002d
400179c4:	3ec50513          	addi	a0,a0,1004 # 4002d3ec <all_nodes_mcast_group.0+0x1c>
}
400179c8:	00008067          	ret

400179cc <net_ipv6_nbr_foreach>:
{
400179cc:	fe010113          	addi	sp,sp,-32
	struct iface_cb_data cb_data = {
400179d0:	00a12423          	sw	a0,8(sp)
	net_if_foreach(iface_cb, &cb_data);
400179d4:	40017537          	lui	a0,0x40017
	struct iface_cb_data cb_data = {
400179d8:	00b12623          	sw	a1,12(sp)
	net_if_foreach(iface_cb, &cb_data);
400179dc:	23050513          	addi	a0,a0,560 # 40017230 <iface_cb>
400179e0:	00810593          	addi	a1,sp,8
{
400179e4:	00112e23          	sw	ra,28(sp)
	net_if_foreach(iface_cb, &cb_data);
400179e8:	c3df70ef          	jal	ra,4000f624 <net_if_foreach>
}
400179ec:	01c12083          	lw	ra,28(sp)
400179f0:	02010113          	addi	sp,sp,32
400179f4:	00008067          	ret

400179f8 <net_ipv6_nbr_rm>:
{
400179f8:	ff010113          	addi	sp,sp,-16
400179fc:	00812423          	sw	s0,8(sp)
40017a00:	01212023          	sw	s2,0(sp)
40017a04:	00112623          	sw	ra,12(sp)
40017a08:	00912223          	sw	s1,4(sp)
40017a0c:	00050413          	mv	s0,a0
40017a10:	00058913          	mv	s2,a1
	nbr = nbr_lookup(&net_neighbor.table, iface, addr);
40017a14:	cb1ff0ef          	jal	ra,400176c4 <nbr_lookup.constprop.0>
	if (!nbr) {
40017a18:	04050863          	beqz	a0,40017a68 <net_ipv6_nbr_rm+0x70>
	net_route_del_by_nexthop(iface, addr);
40017a1c:	00090593          	mv	a1,s2
40017a20:	00050493          	mv	s1,a0
40017a24:	00040513          	mv	a0,s0
40017a28:	345020ef          	jal	ra,4001a56c <net_route_del_by_nexthop>
	nbr_free(nbr);
40017a2c:	00048513          	mv	a0,s1
40017a30:	8b5ff0ef          	jal	ra,400172e4 <nbr_free>
40017a34:	e0600537          	lui	a0,0xe0600
40017a38:	01050513          	addi	a0,a0,16 # e0600010 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600011>
40017a3c:	00000693          	li	a3,0
40017a40:	00000613          	li	a2,0
40017a44:	00040593          	mv	a1,s0
40017a48:	ce8f90ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
	return true;
40017a4c:	00100513          	li	a0,1
}
40017a50:	00c12083          	lw	ra,12(sp)
40017a54:	00812403          	lw	s0,8(sp)
40017a58:	00412483          	lw	s1,4(sp)
40017a5c:	00012903          	lw	s2,0(sp)
40017a60:	01010113          	addi	sp,sp,16
40017a64:	00008067          	ret
		return false;
40017a68:	00000513          	li	a0,0
40017a6c:	fe5ff06f          	j	40017a50 <net_ipv6_nbr_rm+0x58>

40017a70 <add_nbr>:
{
40017a70:	fe010113          	addi	sp,sp,-32
40017a74:	00812c23          	sw	s0,24(sp)
40017a78:	00912a23          	sw	s1,20(sp)
40017a7c:	01212823          	sw	s2,16(sp)
40017a80:	01312623          	sw	s3,12(sp)
40017a84:	00112e23          	sw	ra,28(sp)
40017a88:	01412423          	sw	s4,8(sp)
40017a8c:	00050413          	mv	s0,a0
40017a90:	00058493          	mv	s1,a1
40017a94:	00060913          	mv	s2,a2
40017a98:	00068993          	mv	s3,a3
	nbr = nbr_lookup(&net_neighbor.table, iface, addr);
40017a9c:	c29ff0ef          	jal	ra,400176c4 <nbr_lookup.constprop.0>
	if (nbr) {
40017aa0:	0e051a63          	bnez	a0,40017b94 <add_nbr+0x124>
	nbr = nbr_new(iface, addr, is_router, state);
40017aa4:	00098693          	mv	a3,s3
40017aa8:	00090613          	mv	a2,s2
40017aac:	00048593          	mv	a1,s1
40017ab0:	00040513          	mv	a0,s0
40017ab4:	e1dff0ef          	jal	ra,400178d0 <nbr_new>
	if (nbr) {
40017ab8:	0c051e63          	bnez	a0,40017b94 <add_nbr+0x124>
	return z_impl_k_sem_take(sem, timeout);
40017abc:	40032a37          	lui	s4,0x40032
40017ac0:	fff00613          	li	a2,-1
40017ac4:	fff00593          	li	a1,-1
40017ac8:	614a0513          	addi	a0,s4,1556 # 40032614 <nbr_lock>
40017acc:	328110ef          	jal	ra,40028df4 <z_impl_k_sem_take>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
40017ad0:	4003c7b7          	lui	a5,0x4003c
40017ad4:	3d878613          	addi	a2,a5,984 # 4003c3d8 <net_neighbor_pool>
	uint32_t oldest = UINT32_MAX;
40017ad8:	fff00513          	li	a0,-1
	int nbr_idx = -1;
40017adc:	fff00713          	li	a4,-1
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
40017ae0:	00000693          	li	a3,0
40017ae4:	3d878793          	addi	a5,a5,984
		if (!data || data->is_router ||
40017ae8:	00200893          	li	a7,2
		if (nbr_idx == -1) {
40017aec:	fff00313          	li	t1,-1
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
40017af0:	00800813          	li	a6,8
		if (!nbr || !nbr->ref) {
40017af4:	00064583          	lbu	a1,0(a2)
40017af8:	02058a63          	beqz	a1,40017b2c <add_nbr+0xbc>
40017afc:	00c62583          	lw	a1,12(a2)
		if (!data || data->is_router ||
40017b00:	02058663          	beqz	a1,40017b2c <add_nbr+0xbc>
40017b04:	0375ce03          	lbu	t3,55(a1)
40017b08:	020e1263          	bnez	t3,40017b2c <add_nbr+0xbc>
40017b0c:	0305ae03          	lw	t3,48(a1)
40017b10:	011e1e63          	bne	t3,a7,40017b2c <add_nbr+0xbc>
		if (nbr_idx == -1) {
40017b14:	0385a583          	lw	a1,56(a1)
40017b18:	00671863          	bne	a4,t1,40017b28 <add_nbr+0xb8>
40017b1c:	00058513          	mv	a0,a1
40017b20:	00068713          	mv	a4,a3
40017b24:	0080006f          	j	40017b2c <add_nbr+0xbc>
		if (oldest == MIN(oldest, data->stale_counter)) {
40017b28:	fea5eae3          	bltu	a1,a0,40017b1c <add_nbr+0xac>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
40017b2c:	00168693          	addi	a3,a3,1
40017b30:	05460613          	addi	a2,a2,84
40017b34:	fd0690e3          	bne	a3,a6,40017af4 <add_nbr+0x84>
	if (nbr_idx != -1) {
40017b38:	fff00693          	li	a3,-1
40017b3c:	02d70063          	beq	a4,a3,40017b5c <add_nbr+0xec>
40017b40:	05400693          	li	a3,84
40017b44:	02d70733          	mul	a4,a4,a3
40017b48:	00e787b3          	add	a5,a5,a4
		net_ipv6_nbr_rm(nbr->iface,
40017b4c:	00c7a583          	lw	a1,12(a5)
40017b50:	0087a503          	lw	a0,8(a5)
40017b54:	00458593          	addi	a1,a1,4
40017b58:	ea1ff0ef          	jal	ra,400179f8 <net_ipv6_nbr_rm>
	z_impl_k_sem_give(sem);
40017b5c:	614a0513          	addi	a0,s4,1556
40017b60:	224110ef          	jal	ra,40028d84 <z_impl_k_sem_give>
	nbr = nbr_new(iface, addr, is_router, state);
40017b64:	00040513          	mv	a0,s0
}
40017b68:	01812403          	lw	s0,24(sp)
40017b6c:	01c12083          	lw	ra,28(sp)
40017b70:	00812a03          	lw	s4,8(sp)
	nbr = nbr_new(iface, addr, is_router, state);
40017b74:	00098693          	mv	a3,s3
40017b78:	00090613          	mv	a2,s2
}
40017b7c:	00c12983          	lw	s3,12(sp)
40017b80:	01012903          	lw	s2,16(sp)
	nbr = nbr_new(iface, addr, is_router, state);
40017b84:	00048593          	mv	a1,s1
}
40017b88:	01412483          	lw	s1,20(sp)
40017b8c:	02010113          	addi	sp,sp,32
	nbr = nbr_new(iface, addr, is_router, state);
40017b90:	d41ff06f          	j	400178d0 <nbr_new>
}
40017b94:	01c12083          	lw	ra,28(sp)
40017b98:	01812403          	lw	s0,24(sp)
40017b9c:	01412483          	lw	s1,20(sp)
40017ba0:	01012903          	lw	s2,16(sp)
40017ba4:	00c12983          	lw	s3,12(sp)
40017ba8:	00812a03          	lw	s4,8(sp)
40017bac:	02010113          	addi	sp,sp,32
40017bb0:	00008067          	ret

40017bb4 <net_ipv6_nbr_lookup>:
	return nbr_lookup(&net_neighbor.table, iface, addr);
40017bb4:	b11ff06f          	j	400176c4 <nbr_lookup.constprop.0>

40017bb8 <net_ipv6_send_na>:
{
40017bb8:	fd010113          	addi	sp,sp,-48
40017bbc:	02912223          	sw	s1,36(sp)
40017bc0:	01312e23          	sw	s3,28(sp)
40017bc4:	01412c23          	sw	s4,24(sp)
40017bc8:	01512a23          	sw	s5,20(sp)
40017bcc:	01612823          	sw	s6,16(sp)
40017bd0:	02112623          	sw	ra,44(sp)
40017bd4:	02812423          	sw	s0,40(sp)
40017bd8:	03212023          	sw	s2,32(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
40017bdc:	01400793          	li	a5,20
40017be0:	00f12623          	sw	a5,12(sp)
	uint8_t total_len = net_if_get_link_addr(iface)->len +
40017be4:	00052783          	lw	a5,0(a0)
{
40017be8:	00058493          	mv	s1,a1
40017bec:	00060a93          	mv	s5,a2
	return ROUND_UP(total_len, 8U);
40017bf0:	0147c903          	lbu	s2,20(a5)
{
40017bf4:	00068993          	mv	s3,a3
40017bf8:	00070a13          	mv	s4,a4
	return ROUND_UP(total_len, 8U);
40017bfc:	00990913          	addi	s2,s2,9
40017c00:	0f897913          	andi	s2,s2,248
	pkt = net_pkt_alloc_with_buffer(iface,
40017c04:	00a00713          	li	a4,10
40017c08:	00000793          	li	a5,0
40017c0c:	03a00693          	li	a3,58
40017c10:	00200613          	li	a2,2
40017c14:	01490593          	addi	a1,s2,20
{
40017c18:	00050b13          	mv	s6,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
40017c1c:	00012423          	sw	zero,8(sp)
	pkt = net_pkt_alloc_with_buffer(iface,
40017c20:	afdfb0ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
	if (!pkt) {
40017c24:	0e050c63          	beqz	a0,40017d1c <net_ipv6_send_na+0x164>
	pkt->ipv6_hop_limit = hop_limit;
40017c28:	fff00793          	li	a5,-1
40017c2c:	02f50ca3          	sb	a5,57(a0)
	if (net_ipv6_create(pkt, src, dst) ||
40017c30:	000a8613          	mv	a2,s5
40017c34:	00048593          	mv	a1,s1
40017c38:	00050413          	mv	s0,a0
40017c3c:	cb1fe0ef          	jal	ra,400168ec <net_ipv6_create>
40017c40:	02050e63          	beqz	a0,40017c7c <net_ipv6_send_na+0xc4>
	int ret = -ENOBUFS;
40017c44:	f9700493          	li	s1,-105
	net_pkt_unref(pkt);
40017c48:	00040513          	mv	a0,s0
40017c4c:	ad0fb0ef          	jal	ra,40012f1c <net_pkt_unref>
}
40017c50:	02c12083          	lw	ra,44(sp)
40017c54:	02812403          	lw	s0,40(sp)
40017c58:	02012903          	lw	s2,32(sp)
40017c5c:	01c12983          	lw	s3,28(sp)
40017c60:	01812a03          	lw	s4,24(sp)
40017c64:	01412a83          	lw	s5,20(sp)
40017c68:	01012b03          	lw	s6,16(sp)
40017c6c:	00048513          	mv	a0,s1
40017c70:	02412483          	lw	s1,36(sp)
40017c74:	03010113          	addi	sp,sp,48
40017c78:	00008067          	ret
	    net_icmpv6_create(pkt, NET_ICMPV6_NA, 0)) {
40017c7c:	00000613          	li	a2,0
40017c80:	08800593          	li	a1,136
40017c84:	00040513          	mv	a0,s0
40017c88:	874fe0ef          	jal	ra,40015cfc <net_icmpv6_create>
	if (net_ipv6_create(pkt, src, dst) ||
40017c8c:	fa051ce3          	bnez	a0,40017c44 <net_ipv6_send_na+0x8c>
	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
40017c90:	00810593          	addi	a1,sp,8
40017c94:	00040513          	mv	a0,s0
40017c98:	ae4fc0ef          	jal	ra,40013f7c <net_pkt_get_data>
40017c9c:	00050493          	mv	s1,a0
	if (!na_hdr) {
40017ca0:	fa0502e3          	beqz	a0,40017c44 <net_ipv6_send_na+0x8c>
	memset(na_hdr, 0, sizeof(struct net_icmpv6_na_hdr));
40017ca4:	01400613          	li	a2,20
40017ca8:	00000593          	li	a1,0
40017cac:	bc4f10ef          	jal	ra,40009070 <memset>
	memcpy(dest, src, sizeof(struct in6_addr));
40017cb0:	01000613          	li	a2,16
	na_hdr->flags = flags;
40017cb4:	01448023          	sb	s4,0(s1)
40017cb8:	00098593          	mv	a1,s3
40017cbc:	00448513          	addi	a0,s1,4
40017cc0:	b8cf10ef          	jal	ra,4000904c <memcpy>
	if (net_pkt_set_data(pkt, &na_access)) {
40017cc4:	00810593          	addi	a1,sp,8
40017cc8:	00040513          	mv	a0,s0
40017ccc:	b40fc0ef          	jal	ra,4001400c <net_pkt_set_data>
40017cd0:	00050493          	mv	s1,a0
40017cd4:	f60518e3          	bnez	a0,40017c44 <net_ipv6_send_na+0x8c>
	return &iface->if_dev->link_addr;
40017cd8:	000b2583          	lw	a1,0(s6)
	if (!set_llao(pkt, net_if_get_link_addr(iface),
40017cdc:	00200693          	li	a3,2
40017ce0:	00090613          	mv	a2,s2
40017ce4:	01058593          	addi	a1,a1,16
40017ce8:	00040513          	mv	a0,s0
40017cec:	fa0ff0ef          	jal	ra,4001748c <set_llao>
40017cf0:	f4050ae3          	beqz	a0,40017c44 <net_ipv6_send_na+0x8c>
	net_pkt_cursor_init(pkt);
40017cf4:	00040513          	mv	a0,s0
40017cf8:	cf8fb0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
40017cfc:	03a00593          	li	a1,58
40017d00:	00040513          	mv	a0,s0
40017d04:	cddfe0ef          	jal	ra,400169e0 <net_ipv6_finalize>
	if (net_send_data(pkt) < 0) {
40017d08:	00040513          	mv	a0,s0
40017d0c:	9bdf30ef          	jal	ra,4000b6c8 <net_send_data>
40017d10:	f40550e3          	bgez	a0,40017c50 <net_ipv6_send_na+0x98>
		ret = -EINVAL;
40017d14:	fea00493          	li	s1,-22
40017d18:	f31ff06f          	j	40017c48 <net_ipv6_send_na+0x90>
		return -ENOMEM;
40017d1c:	ff400493          	li	s1,-12
40017d20:	f31ff06f          	j	40017c50 <net_ipv6_send_na+0x98>

40017d24 <net_ipv6_nbr_set_reachable_timer>:
	}
}

void net_ipv6_nbr_set_reachable_timer(struct net_if *iface,
				      struct net_nbr *nbr)
{
40017d24:	00050793          	mv	a5,a0
	uint32_t time;

	time = net_if_ipv6_get_reachable_time(iface);
40017d28:	0047a783          	lw	a5,4(a5)
{
40017d2c:	00058513          	mv	a0,a1
		return 0;
40017d30:	00000593          	li	a1,0
	if (!iface->config.ip.ipv6) {
40017d34:	00078463          	beqz	a5,40017d3c <net_ipv6_nbr_set_reachable_timer+0x18>
	return iface->config.ip.ipv6->reachable_time;
40017d38:	1147a583          	lw	a1,276(a5)
	NET_ASSERT(time, "Zero reachable timeout!");

	NET_DBG("Starting reachable timer nbr %p data %p time %d ms",
		nbr, net_ipv6_nbr_data(nbr), time);

	ipv6_nd_restart_reachable_timer(nbr, time);
40017d3c:	00000613          	li	a2,0
40017d40:	86dff06f          	j	400175ac <ipv6_nd_restart_reachable_timer>

40017d44 <handle_na_input>:
}

static enum net_verdict handle_na_input(struct net_pkt *pkt,
					struct net_ipv6_hdr *ip_hdr,
					struct net_icmp_hdr *icmp_hdr)
{
40017d44:	fa010113          	addi	sp,sp,-96
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
40017d48:	01400793          	li	a5,20
40017d4c:	02f12223          	sw	a5,36(sp)
					      struct net_icmpv6_na_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
40017d50:	01c10793          	addi	a5,sp,28
{
40017d54:	04812c23          	sw	s0,88(sp)
40017d58:	04912a23          	sw	s1,84(sp)
40017d5c:	05312623          	sw	s3,76(sp)
40017d60:	05412423          	sw	s4,72(sp)
40017d64:	04112e23          	sw	ra,92(sp)
40017d68:	05212823          	sw	s2,80(sp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
40017d6c:	02f12423          	sw	a5,40(sp)
40017d70:	00200793          	li	a5,2
40017d74:	02f12623          	sw	a5,44(sp)
	uint16_t length = net_pkt_get_len(pkt);
40017d78:	00852783          	lw	a5,8(a0)
{
40017d7c:	00050493          	mv	s1,a0
40017d80:	00058993          	mv	s3,a1
40017d84:	00060a13          	mv	s4,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(na_access,
40017d88:	02012023          	sw	zero,32(sp)
	size_t bytes = 0;
40017d8c:	00000413          	li	s0,0
	while (buf) {
40017d90:	02079c63          	bnez	a5,40017dc8 <handle_na_input+0x84>
	uint16_t tllao_offset = 0U;
	struct net_icmpv6_nd_opt_hdr *nd_opt_hdr;
	struct net_icmpv6_na_hdr *na_hdr;
	struct net_if_addr *ifaddr;

	if (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {
40017d94:	0184a503          	lw	a0,24(s1)
40017d98:	00b00593          	li	a1,11
40017d9c:	9d5ff0ef          	jal	ra,40017770 <net_if_flag_is_set>
40017da0:	02050c63          	beqz	a0,40017dd8 <handle_na_input+0x94>
	return NET_OK;

drop:
	net_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));

	return NET_DROP;
40017da4:	00200513          	li	a0,2
}
40017da8:	05c12083          	lw	ra,92(sp)
40017dac:	05812403          	lw	s0,88(sp)
40017db0:	05412483          	lw	s1,84(sp)
40017db4:	05012903          	lw	s2,80(sp)
40017db8:	04c12983          	lw	s3,76(sp)
40017dbc:	04812a03          	lw	s4,72(sp)
40017dc0:	06010113          	addi	sp,sp,96
40017dc4:	00008067          	ret
		bytes += buf->len;
40017dc8:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
40017dcc:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
40017dd0:	00e40433          	add	s0,s0,a4
		buf = buf->frags;
40017dd4:	fbdff06f          	j	40017d90 <handle_na_input+0x4c>
	na_hdr = (struct net_icmpv6_na_hdr *)net_pkt_get_data(pkt, &na_access);
40017dd8:	02010593          	addi	a1,sp,32
40017ddc:	00048513          	mv	a0,s1
40017de0:	99cfc0ef          	jal	ra,40013f7c <net_pkt_get_data>
40017de4:	00050913          	mv	s2,a0
	if (!na_hdr) {
40017de8:	fa050ee3          	beqz	a0,40017da4 <handle_na_input+0x60>
	uint16_t length = net_pkt_get_len(pkt);
40017dec:	01041413          	slli	s0,s0,0x10
40017df0:	01045413          	srli	s0,s0,0x10
	if (((length < (sizeof(struct net_ipv6_hdr) +
40017df4:	04100793          	li	a5,65
40017df8:	0287f663          	bgeu	a5,s0,40017e24 <handle_na_input+0xe0>
			sizeof(struct net_icmpv6_nd_opt_hdr))) ||
40017dfc:	0079c783          	lbu	a5,7(s3)
40017e00:	0ff00713          	li	a4,255
40017e04:	02e79063          	bne	a5,a4,40017e24 <handle_na_input+0xe0>
	     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||
40017e08:	00454703          	lbu	a4,4(a0)
40017e0c:	00f70c63          	beq	a4,a5,40017e24 <handle_na_input+0xe0>
	     net_ipv6_is_addr_mcast((struct in6_addr *)na_hdr->tgt) ||
40017e10:	00054703          	lbu	a4,0(a0)
40017e14:	04077713          	andi	a4,a4,64
40017e18:	00070a63          	beqz	a4,40017e2c <handle_na_input+0xe8>
	     (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED &&
40017e1c:	0189c703          	lbu	a4,24(s3)
40017e20:	00f71663          	bne	a4,a5,40017e2c <handle_na_input+0xe8>
	      net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst))) &&
40017e24:	001a4783          	lbu	a5,1(s4)
40017e28:	f6079ee3          	bnez	a5,40017da4 <handle_na_input+0x60>
	net_pkt_acknowledge_data(pkt, &na_access);
40017e2c:	02412583          	lw	a1,36(sp)
40017e30:	00048513          	mv	a0,s1
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
40017e34:	fd440413          	addi	s0,s0,-44
	net_pkt_acknowledge_data(pkt, &na_access);
40017e38:	979ff0ef          	jal	ra,400177b0 <net_pkt_acknowledge_data.isra.0>
	pkt->ipv6_ext_opt_len = len;
40017e3c:	01400793          	li	a5,20
40017e40:	02f48f23          	sb	a5,62(s1)
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
40017e44:	01041413          	slli	s0,s0,0x10
				net_pkt_get_data(pkt, &nd_access);
40017e48:	02810593          	addi	a1,sp,40
40017e4c:	00048513          	mv	a0,s1
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
40017e50:	01045413          	srli	s0,s0,0x10
				net_pkt_get_data(pkt, &nd_access);
40017e54:	928fc0ef          	jal	ra,40013f7c <net_pkt_get_data>
	uint16_t tllao_offset = 0U;
40017e58:	00000993          	li	s3,0
		switch (nd_opt_hdr->type) {
40017e5c:	00200a13          	li	s4,2
	while (nd_opt_hdr && nd_opt_hdr->len &&
40017e60:	00050a63          	beqz	a0,40017e74 <handle_na_input+0x130>
40017e64:	00154783          	lbu	a5,1(a0)
40017e68:	00078663          	beqz	a5,40017e74 <handle_na_input+0x130>
	return pkt->ipv6_ext_opt_len;
40017e6c:	03e4c703          	lbu	a4,62(s1)
40017e70:	04876663          	bltu	a4,s0,40017ebc <handle_na_input+0x178>
	ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
40017e74:	0184a503          	lw	a0,24(s1)
						  (struct in6_addr *)na_hdr->tgt);
40017e78:	00490593          	addi	a1,s2,4
	ifaddr = net_if_ipv6_addr_lookup_by_iface(net_pkt_iface(pkt),
40017e7c:	00b12623          	sw	a1,12(sp)
40017e80:	b00f50ef          	jal	ra,4000d180 <net_if_ipv6_addr_lookup_by_iface>
	if (ifaddr) {
40017e84:	00c12583          	lw	a1,12(sp)
40017e88:	08050463          	beqz	a0,40017f10 <handle_na_input+0x1cc>
		if (ifaddr->addr_state == NET_ADDR_TENTATIVE) {
40017e8c:	02d50783          	lb	a5,45(a0)
40017e90:	f0079ae3          	bnez	a5,40017da4 <handle_na_input+0x60>
	return UNALIGNED_GET(&addr->s6_addr16[0]) == htons(0xFE80);
40017e94:	00594783          	lbu	a5,5(s2)
40017e98:	00494703          	lbu	a4,4(s2)
	return pkt->iface;
40017e9c:	0184a503          	lw	a0,24(s1)
40017ea0:	00879793          	slli	a5,a5,0x8
	if (net_ipv6_is_ll_addr(addr)) {
40017ea4:	00e7e7b3          	or	a5,a5,a4
40017ea8:	00008737          	lui	a4,0x8
40017eac:	0fe70713          	addi	a4,a4,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
40017eb0:	eee78ae3          	beq	a5,a4,40017da4 <handle_na_input+0x60>
	net_if_ipv6_dad_failed(iface, addr);
40017eb4:	c31f50ef          	jal	ra,4000dae4 <net_if_ipv6_dad_failed>
	return true;
40017eb8:	eedff06f          	j	40017da4 <handle_na_input+0x60>
		switch (nd_opt_hdr->type) {
40017ebc:	00054683          	lbu	a3,0(a0)
40017ec0:	03469063          	bne	a3,s4,40017ee0 <handle_na_input+0x19c>
			tllao_offset = net_pkt_ip_hdr_len(pkt) +
40017ec4:	03a4d983          	lhu	s3,58(s1)
40017ec8:	0364c683          	lbu	a3,54(s1)
40017ecc:	00698993          	addi	s3,s3,6
40017ed0:	013709b3          	add	s3,a4,s3
40017ed4:	00d989b3          	add	s3,s3,a3
40017ed8:	01099993          	slli	s3,s3,0x10
40017edc:	0109d993          	srli	s3,s3,0x10
					     (nd_opt_hdr->len << 3));
40017ee0:	00379793          	slli	a5,a5,0x3
		net_pkt_set_ipv6_ext_opt_len(pkt,
40017ee4:	00f707b3          	add	a5,a4,a5
40017ee8:	0ff7f793          	zext.b	a5,a5
	pkt->ipv6_ext_opt_len = len;
40017eec:	02f48f23          	sb	a5,62(s1)
		if (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {
40017ef0:	eaf77ae3          	bgeu	a4,a5,40017da4 <handle_na_input+0x60>
		net_pkt_acknowledge_data(pkt, &nd_access);
40017ef4:	02c12583          	lw	a1,44(sp)
40017ef8:	00048513          	mv	a0,s1
40017efc:	8b5ff0ef          	jal	ra,400177b0 <net_pkt_acknowledge_data.isra.0>
					net_pkt_get_data(pkt, &nd_access);
40017f00:	02810593          	addi	a1,sp,40
40017f04:	00048513          	mv	a0,s1
40017f08:	874fc0ef          	jal	ra,40013f7c <net_pkt_get_data>
40017f0c:	f55ff06f          	j	40017e60 <handle_na_input+0x11c>
	nbr = nbr_lookup(&net_neighbor.table, net_pkt_iface(pkt),
40017f10:	0184a503          	lw	a0,24(s1)
	struct net_linkaddr_storage lladdr = { 0 };
40017f14:	02012823          	sw	zero,48(sp)
40017f18:	02012a23          	sw	zero,52(sp)
	nbr = nbr_lookup(&net_neighbor.table, net_pkt_iface(pkt),
40017f1c:	fa8ff0ef          	jal	ra,400176c4 <nbr_lookup.constprop.0>
40017f20:	00050413          	mv	s0,a0
	if (!nbr) {
40017f24:	e80500e3          	beqz	a0,40017da4 <handle_na_input+0x60>
	if (tllao_offset) {
40017f28:	06099e63          	bnez	s3,40017fa4 <handle_na_input+0x260>
	if (nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
40017f2c:	00154503          	lbu	a0,1(a0)
40017f30:	0ff00793          	li	a5,255
40017f34:	e6f508e3          	beq	a0,a5,40017da4 <handle_na_input+0x60>
	cached_lladdr = net_nbr_get_lladdr(nbr->idx);
40017f38:	fd0fe0ef          	jal	ra,40016708 <net_nbr_get_lladdr>
	if (!cached_lladdr) {
40017f3c:	e60504e3          	beqz	a0,40017da4 <handle_na_input+0x60>
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_INCOMPLETE) {
40017f40:	00c42783          	lw	a5,12(s0)
40017f44:	0307a783          	lw	a5,48(a5)
40017f48:	e4078ee3          	beqz	a5,40017da4 <handle_na_input+0x60>
	if (!(na_hdr->flags & NET_ICMPV6_NA_FLAG_OVERRIDE) && lladdr_changed) {
40017f4c:	00094783          	lbu	a5,0(s2)
40017f50:	0207f793          	andi	a5,a5,32
40017f54:	1a079a63          	bnez	a5,40018108 <handle_na_input+0x3c4>
		(na_hdr->flags & NET_ICMPV6_NA_FLAG_ROUTER);
40017f58:	00094783          	lbu	a5,0(s2)
40017f5c:	00c42703          	lw	a4,12(s0)
40017f60:	0077d793          	srli	a5,a5,0x7
	net_ipv6_nbr_data(nbr)->is_router =
40017f64:	02f70ba3          	sb	a5,55(a4)
	pending = net_ipv6_nbr_data(nbr)->pending;
40017f68:	00c42783          	lw	a5,12(s0)
40017f6c:	0007a903          	lw	s2,0(a5)
	if (pending) {
40017f70:	02090263          	beqz	s2,40017f94 <handle_na_input+0x250>
		if (net_send_data(pending) < 0) {
40017f74:	00090513          	mv	a0,s2
40017f78:	f50f30ef          	jal	ra,4000b6c8 <net_send_data>
40017f7c:	00c42783          	lw	a5,12(s0)
40017f80:	1a055463          	bgez	a0,40018128 <handle_na_input+0x3e4>
			nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
40017f84:	00078513          	mv	a0,a5
40017f88:	b1cff0ef          	jal	ra,400172a4 <nbr_clear_ns_pending>
		net_pkt_unref(pending);
40017f8c:	00090513          	mv	a0,s2
40017f90:	f8dfa0ef          	jal	ra,40012f1c <net_pkt_unref>
	net_pkt_unref(pkt);
40017f94:	00048513          	mv	a0,s1
40017f98:	f85fa0ef          	jal	ra,40012f1c <net_pkt_unref>
	return NET_OK;
40017f9c:	00000513          	li	a0,0
40017fa0:	e09ff06f          	j	40017da8 <handle_na_input+0x64>
		lladdr.len = net_pkt_lladdr_src(pkt)->len;
40017fa4:	0284c783          	lbu	a5,40(s1)
		net_pkt_cursor_init(pkt);
40017fa8:	00048513          	mv	a0,s1
		lladdr.len = net_pkt_lladdr_src(pkt)->len;
40017fac:	02f108a3          	sb	a5,49(sp)
		net_pkt_cursor_init(pkt);
40017fb0:	a40fb0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
		if (net_pkt_skip(pkt, tllao_offset) ||
40017fb4:	00098593          	mv	a1,s3
40017fb8:	00048513          	mv	a0,s1
40017fbc:	fa8fb0ef          	jal	ra,40013764 <net_pkt_skip>
40017fc0:	de0512e3          	bnez	a0,40017da4 <handle_na_input+0x60>
		    net_pkt_read(pkt, lladdr.addr, lladdr.len)) {
40017fc4:	03114603          	lbu	a2,49(sp)
40017fc8:	03210a13          	addi	s4,sp,50
40017fcc:	000a0593          	mv	a1,s4
40017fd0:	00048513          	mv	a0,s1
40017fd4:	9f9fb0ef          	jal	ra,400139cc <net_pkt_read>
		if (net_pkt_skip(pkt, tllao_offset) ||
40017fd8:	dc0516e3          	bnez	a0,40017da4 <handle_na_input+0x60>
	if (nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
40017fdc:	00144503          	lbu	a0,1(s0)
40017fe0:	0ff00793          	li	a5,255
40017fe4:	02f51a63          	bne	a0,a5,40018018 <handle_na_input+0x2d4>
		nbr_lladdr.len = lladdr.len;
40017fe8:	03114783          	lbu	a5,49(sp)
		if (net_nbr_link(nbr, net_pkt_iface(pkt), &nbr_lladdr)) {
40017fec:	0184a583          	lw	a1,24(s1)
40017ff0:	03810613          	addi	a2,sp,56
40017ff4:	00040513          	mv	a0,s0
		nbr_lladdr.len = lladdr.len;
40017ff8:	02f10e23          	sb	a5,60(sp)
		nbr_lladdr.addr = lladdr.addr;
40017ffc:	03412c23          	sw	s4,56(sp)
		if (net_nbr_link(nbr, net_pkt_iface(pkt), &nbr_lladdr)) {
40018000:	d1cfe0ef          	jal	ra,4001651c <net_nbr_link>
40018004:	00050863          	beqz	a0,40018014 <handle_na_input+0x2d0>
			nbr_free(nbr);
40018008:	00040513          	mv	a0,s0
4001800c:	ad8ff0ef          	jal	ra,400172e4 <nbr_free>
			return false;
40018010:	d95ff06f          	j	40017da4 <handle_na_input+0x60>
	cached_lladdr = net_nbr_get_lladdr(nbr->idx);
40018014:	00144503          	lbu	a0,1(s0)
40018018:	ef0fe0ef          	jal	ra,40016708 <net_nbr_get_lladdr>
4001801c:	00050993          	mv	s3,a0
	if (!cached_lladdr) {
40018020:	d80502e3          	beqz	a0,40017da4 <handle_na_input+0x60>
		lladdr_changed = memcmp(lladdr.addr,
40018024:	00154603          	lbu	a2,1(a0)
40018028:	00250593          	addi	a1,a0,2
4001802c:	000a0513          	mv	a0,s4
40018030:	f9df00ef          	jal	ra,40008fcc <memcmp>
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_INCOMPLETE) {
40018034:	00c42783          	lw	a5,12(s0)
40018038:	0307a703          	lw	a4,48(a5)
4001803c:	06071663          	bnez	a4,400180a8 <handle_na_input+0x364>
		if (lladdr_changed) {
40018040:	00050e63          	beqz	a0,4001805c <handle_na_input+0x318>
	dbg_update_neighbor_lladdr(&lladdr, old_lladdr, addr);
40018044:	00098513          	mv	a0,s3
40018048:	e38ff0ef          	jal	ra,40017680 <dbg_update_neighbor_lladdr.constprop.0>
			net_linkaddr_set(cached_lladdr, lladdr.addr,
4001804c:	0019c603          	lbu	a2,1(s3)
40018050:	000a0593          	mv	a1,s4
40018054:	00098513          	mv	a0,s3
40018058:	f5cff0ef          	jal	ra,400177b4 <net_linkaddr_set.isra.0>
		if (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED) {
4001805c:	00094783          	lbu	a5,0(s2)
40018060:	0407f793          	andi	a5,a5,64
40018064:	0a078a63          	beqz	a5,40018118 <handle_na_input+0x3d4>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_REACHABLE);
40018068:	00100593          	li	a1,1
4001806c:	00040513          	mv	a0,s0
40018070:	f68ff0ef          	jal	ra,400177d8 <ipv6_nbr_set_state>
40018074:	00c42783          	lw	a5,12(s0)
			net_ipv6_nbr_data(nbr)->ns_count = 0U;
40018078:	02078b23          	sb	zero,54(a5)
4001807c:	00c42783          	lw	a5,12(s0)
			net_ipv6_nbr_data(nbr)->reachable = 0;
40018080:	00000693          	li	a3,0
40018084:	00000713          	li	a4,0
40018088:	00d7ac23          	sw	a3,24(a5)
4001808c:	00e7ae23          	sw	a4,28(a5)
40018090:	00c42783          	lw	a5,12(s0)
			net_ipv6_nbr_set_reachable_timer(net_pkt_iface(pkt),
40018094:	00040593          	mv	a1,s0
			net_ipv6_nbr_data(nbr)->reachable_timeout = 0;
40018098:	0207a023          	sw	zero,32(a5)
			net_ipv6_nbr_set_reachable_timer(net_pkt_iface(pkt),
4001809c:	0184a503          	lw	a0,24(s1)
400180a0:	c85ff0ef          	jal	ra,40017d24 <net_ipv6_nbr_set_reachable_timer>
400180a4:	eb5ff06f          	j	40017f58 <handle_na_input+0x214>
	if (!(na_hdr->flags & NET_ICMPV6_NA_FLAG_OVERRIDE) && lladdr_changed) {
400180a8:	00094783          	lbu	a5,0(s2)
400180ac:	0207f693          	andi	a3,a5,32
400180b0:	02069063          	bnez	a3,400180d0 <handle_na_input+0x38c>
400180b4:	04050c63          	beqz	a0,4001810c <handle_na_input+0x3c8>
		if (net_ipv6_nbr_data(nbr)->state ==
400180b8:	00100793          	li	a5,1
400180bc:	cef714e3          	bne	a4,a5,40017da4 <handle_na_input+0x60>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
400180c0:	00200593          	li	a1,2
400180c4:	00040513          	mv	a0,s0
400180c8:	f10ff0ef          	jal	ra,400177d8 <ipv6_nbr_set_state>
400180cc:	cd9ff06f          	j	40017da4 <handle_na_input+0x60>
		if (lladdr_changed) {
400180d0:	02050c63          	beqz	a0,40018108 <handle_na_input+0x3c4>
	dbg_update_neighbor_lladdr(&lladdr, old_lladdr, addr);
400180d4:	00098513          	mv	a0,s3
400180d8:	da8ff0ef          	jal	ra,40017680 <dbg_update_neighbor_lladdr.constprop.0>
			net_linkaddr_set(cached_lladdr, lladdr.addr,
400180dc:	0019c603          	lbu	a2,1(s3)
400180e0:	000a0593          	mv	a1,s4
400180e4:	00098513          	mv	a0,s3
400180e8:	eccff0ef          	jal	ra,400177b4 <net_linkaddr_set.isra.0>
		if (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED) {
400180ec:	00094783          	lbu	a5,0(s2)
400180f0:	0407f793          	andi	a5,a5,64
400180f4:	02078263          	beqz	a5,40018118 <handle_na_input+0x3d4>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_REACHABLE);
400180f8:	00100593          	li	a1,1
400180fc:	00040513          	mv	a0,s0
40018100:	ed8ff0ef          	jal	ra,400177d8 <ipv6_nbr_set_state>
40018104:	f79ff06f          	j	4001807c <handle_na_input+0x338>
		if (na_hdr->flags & NET_ICMPV6_NA_FLAG_SOLICITED) {
40018108:	00094783          	lbu	a5,0(s2)
4001810c:	0407f793          	andi	a5,a5,64
40018110:	e40784e3          	beqz	a5,40017f58 <handle_na_input+0x214>
40018114:	fe5ff06f          	j	400180f8 <handle_na_input+0x3b4>
				ipv6_nbr_set_state(nbr,
40018118:	00200593          	li	a1,2
4001811c:	00040513          	mv	a0,s0
40018120:	eb8ff0ef          	jal	ra,400177d8 <ipv6_nbr_set_state>
40018124:	e35ff06f          	j	40017f58 <handle_na_input+0x214>
			net_ipv6_nbr_data(nbr)->pending = NULL;
40018128:	0007a023          	sw	zero,0(a5)
4001812c:	e61ff06f          	j	40017f8c <handle_na_input+0x248>

40018130 <net_ipv6_send_ns>:
		     struct net_pkt *pending,
		     const struct in6_addr *src,
		     const struct in6_addr *dst,
		     const struct in6_addr *tgt,
		     bool is_my_address)
{
40018130:	fb010113          	addi	sp,sp,-80
40018134:	03712623          	sw	s7,44(sp)
40018138:	00078b93          	mv	s7,a5
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
4001813c:	01400793          	li	a5,20
{
40018140:	04912223          	sw	s1,68(sp)
40018144:	05212023          	sw	s2,64(sp)
40018148:	03312e23          	sw	s3,60(sp)
4001814c:	03412c23          	sw	s4,56(sp)
40018150:	03612823          	sw	s6,48(sp)
40018154:	04112623          	sw	ra,76(sp)
40018158:	04812423          	sw	s0,72(sp)
4001815c:	03512a23          	sw	s5,52(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
40018160:	00012423          	sw	zero,8(sp)
40018164:	00f12623          	sw	a5,12(sp)
{
40018168:	00050a13          	mv	s4,a0
4001816c:	00058913          	mv	s2,a1
40018170:	00060493          	mv	s1,a2
40018174:	00070993          	mv	s3,a4
40018178:	00068b13          	mv	s6,a3
	struct net_icmpv6_ns_hdr *ns_hdr;
	struct in6_addr node_dst;
	struct net_nbr *nbr;
	uint8_t llao_len;

	if (!dst) {
4001817c:	04069063          	bnez	a3,400181bc <net_ipv6_send_ns+0x8c>
	dst->s6_addr[0]   = 0xFF;
40018180:	2ff00793          	li	a5,767
40018184:	00f12823          	sw	a5,16(sp)
	UNALIGNED_PUT(0, &dst->s6_addr16[4]);
40018188:	010007b7          	lui	a5,0x1000
4001818c:	00f12c23          	sw	a5,24(sp)
	dst->s6_addr[12]  = 0xFF;
40018190:	fff00793          	li	a5,-1
40018194:	00f10e23          	sb	a5,28(sp)
	dst->s6_addr[13]  = src->s6_addr[13];
40018198:	00d74783          	lbu	a5,13(a4)
	UNALIGNED_PUT(0, &dst->s6_addr16[2]);
4001819c:	00012a23          	sw	zero,20(sp)
		net_ipv6_addr_create_solicited_node(tgt, &node_dst);
		dst = &node_dst;
400181a0:	01010b13          	addi	s6,sp,16
	dst->s6_addr[13]  = src->s6_addr[13];
400181a4:	00f10ea3          	sb	a5,29(sp)
	UNALIGNED_PUT(UNALIGNED_GET(&src->s6_addr16[7]), &dst->s6_addr16[7]);
400181a8:	00e74783          	lbu	a5,14(a4)
400181ac:	00f74703          	lbu	a4,15(a4)
400181b0:	00871713          	slli	a4,a4,0x8
400181b4:	00f76733          	or	a4,a4,a5
400181b8:	00e11f23          	sh	a4,30(sp)
	uint8_t total_len = net_if_get_link_addr(iface)->len +
400181bc:	000a2783          	lw	a5,0(s4)
400181c0:	0147ca83          	lbu	s5,20(a5) # 1000014 <__rom_region_size+0xfcf638>
	}

	llao_len = get_llao_len(iface);

	if (is_my_address) {
400181c4:	060b8463          	beqz	s7,4001822c <net_ipv6_send_ns+0xfc>
		src = net_ipv6_unspecified_address();
400181c8:	aa5f80ef          	jal	ra,40010c6c <net_ipv6_unspecified_address>
400181cc:	00050493          	mv	s1,a0
		llao_len = 0U;
400181d0:	00000a93          	li	s5,0

			goto drop;
		}
	}

	pkt = net_pkt_alloc_with_buffer(iface,
400181d4:	00a00713          	li	a4,10
400181d8:	00000793          	li	a5,0
400181dc:	03a00693          	li	a3,58
400181e0:	00200613          	li	a2,2
400181e4:	014a8593          	addi	a1,s5,20
400181e8:	000a0513          	mv	a0,s4
400181ec:	d30fb0ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
400181f0:	00050413          	mv	s0,a0
					sizeof(struct net_icmpv6_ns_hdr) +
					llao_len,
					AF_INET6, IPPROTO_ICMPV6,
					ND_NET_BUF_TIMEOUT);
	if (!pkt) {
400181f4:	1a050c63          	beqz	a0,400183ac <net_ipv6_send_ns+0x27c>
	pkt->ipv6_hop_limit = hop_limit;
400181f8:	fff00793          	li	a5,-1
400181fc:	02f50ca3          	sb	a5,57(a0)
		net_pkt_set_captured(pkt, net_pkt_is_captured(pending));
	}

	net_pkt_set_ipv6_hop_limit(pkt, NET_IPV6_ND_HOP_LIMIT);

	if (net_ipv6_create(pkt, src, dst) ||
40018200:	000b0613          	mv	a2,s6
40018204:	00048593          	mv	a1,s1
40018208:	ee4fe0ef          	jal	ra,400168ec <net_ipv6_create>
4001820c:	04050663          	beqz	a0,40018258 <net_ipv6_send_ns+0x128>
	net_stats_update_ipv6_nd_sent(iface);

	return 0;

drop:
	if (pending) {
40018210:	00090663          	beqz	s2,4001821c <net_ipv6_send_ns+0xec>
		net_pkt_unref(pending);
40018214:	00090513          	mv	a0,s2
40018218:	d05fa0ef          	jal	ra,40012f1c <net_pkt_unref>
	}

	if (pkt) {
		net_pkt_unref(pkt);
4001821c:	00040513          	mv	a0,s0
40018220:	cfdfa0ef          	jal	ra,40012f1c <net_pkt_unref>
40018224:	f9700493          	li	s1,-105
40018228:	1540006f          	j	4001837c <net_ipv6_send_ns+0x24c>
		if (!src) {
4001822c:	00049a63          	bnez	s1,40018240 <net_ipv6_send_ns+0x110>
			src = net_if_ipv6_select_src_addr(iface, tgt);
40018230:	00098593          	mv	a1,s3
40018234:	000a0513          	mv	a0,s4
40018238:	dacf60ef          	jal	ra,4000e7e4 <net_if_ipv6_select_src_addr>
4001823c:	00050493          	mv	s1,a0
		if (net_ipv6_is_addr_unspecified(src)) {
40018240:	00048513          	mv	a0,s1
40018244:	f29fe0ef          	jal	ra,4001716c <net_ipv6_is_addr_unspecified>
40018248:	16051e63          	bnez	a0,400183c4 <net_ipv6_send_ns+0x294>
	return ROUND_UP(total_len, 8U);
4001824c:	009a8a93          	addi	s5,s5,9
40018250:	0f8afa93          	andi	s5,s5,248
40018254:	f81ff06f          	j	400181d4 <net_ipv6_send_ns+0xa4>
	    net_icmpv6_create(pkt, NET_ICMPV6_NS, 0)) {
40018258:	00000613          	li	a2,0
4001825c:	08700593          	li	a1,135
40018260:	00040513          	mv	a0,s0
40018264:	a99fd0ef          	jal	ra,40015cfc <net_icmpv6_create>
	if (net_ipv6_create(pkt, src, dst) ||
40018268:	fa0514e3          	bnez	a0,40018210 <net_ipv6_send_ns+0xe0>
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
4001826c:	00810593          	addi	a1,sp,8
40018270:	00040513          	mv	a0,s0
40018274:	d09fb0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!ns_hdr) {
40018278:	f8050ce3          	beqz	a0,40018210 <net_ipv6_send_ns+0xe0>
	ns_hdr->reserved = 0U;
4001827c:	00050023          	sb	zero,0(a0)
40018280:	000500a3          	sb	zero,1(a0)
40018284:	00050123          	sb	zero,2(a0)
40018288:	000501a3          	sb	zero,3(a0)
	memcpy(dest, src, sizeof(struct in6_addr));
4001828c:	01000613          	li	a2,16
40018290:	00098593          	mv	a1,s3
40018294:	00450513          	addi	a0,a0,4
40018298:	db5f00ef          	jal	ra,4000904c <memcpy>
	if (net_pkt_set_data(pkt, &ns_access)) {
4001829c:	00810593          	addi	a1,sp,8
400182a0:	00040513          	mv	a0,s0
400182a4:	d69fb0ef          	jal	ra,4001400c <net_pkt_set_data>
400182a8:	00050493          	mv	s1,a0
400182ac:	f60512e3          	bnez	a0,40018210 <net_ipv6_send_ns+0xe0>
	if (!is_my_address) {
400182b0:	020b9063          	bnez	s7,400182d0 <net_ipv6_send_ns+0x1a0>
	return &iface->if_dev->link_addr;
400182b4:	000a2583          	lw	a1,0(s4)
		if (!set_llao(pkt, net_if_get_link_addr(iface),
400182b8:	00100693          	li	a3,1
400182bc:	000a8613          	mv	a2,s5
400182c0:	01058593          	addi	a1,a1,16
400182c4:	00040513          	mv	a0,s0
400182c8:	9c4ff0ef          	jal	ra,4001748c <set_llao>
400182cc:	f40502e3          	beqz	a0,40018210 <net_ipv6_send_ns+0xe0>
	net_pkt_cursor_init(pkt);
400182d0:	00040513          	mv	a0,s0
400182d4:	f1dfa0ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
400182d8:	03a00593          	li	a1,58
400182dc:	00040513          	mv	a0,s0
400182e0:	f00fe0ef          	jal	ra,400169e0 <net_ipv6_finalize>
	nbr = add_nbr(iface, tgt, false,
400182e4:	00098593          	mv	a1,s3
400182e8:	00000693          	li	a3,0
400182ec:	00000613          	li	a2,0
400182f0:	000a0513          	mv	a0,s4
400182f4:	f7cff0ef          	jal	ra,40017a70 <add_nbr>
400182f8:	00050993          	mv	s3,a0
	if (!nbr) {
400182fc:	f0050ae3          	beqz	a0,40018210 <net_ipv6_send_ns+0xe0>
	if (pending) {
40018300:	06090863          	beqz	s2,40018370 <net_ipv6_send_ns+0x240>
40018304:	00c52a03          	lw	s4,12(a0)
		if (!net_ipv6_nbr_data(nbr)->pending) {
40018308:	000a2783          	lw	a5,0(s4)
4001830c:	f00794e3          	bnez	a5,40018214 <net_ipv6_send_ns+0xe4>
			net_ipv6_nbr_data(nbr)->pending = net_pkt_ref(pending);
40018310:	00090513          	mv	a0,s2
40018314:	ba1fa0ef          	jal	ra,40012eb4 <net_pkt_ref>
40018318:	00aa2023          	sw	a0,0(s4)
4001831c:	00c9a903          	lw	s2,12(s3)
		net_ipv6_nbr_data(nbr)->send_ns = k_uptime_get();
40018320:	818ff0ef          	jal	ra,40017338 <k_uptime_get>
40018324:	02a92423          	sw	a0,40(s2)
40018328:	40031537          	lui	a0,0x40031
4001832c:	02b92623          	sw	a1,44(s2)
40018330:	08850513          	addi	a0,a0,136 # 40031088 <ipv6_ns_reply_timer+0x10>
40018334:	6b4120ef          	jal	ra,4002a9e8 <z_timeout_remaining>
		if (!k_work_delayable_remaining_get(&ipv6_ns_reply_timer)) {
40018338:	00b565b3          	or	a1,a0,a1
4001833c:	00058e63          	beqz	a1,40018358 <net_ipv6_send_ns+0x228>
	if (net_send_data(pkt) < 0) {
40018340:	00040513          	mv	a0,s0
40018344:	b84f30ef          	jal	ra,4000b6c8 <net_send_data>
40018348:	02055a63          	bgez	a0,4001837c <net_ipv6_send_ns+0x24c>
			nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
4001834c:	00c9a503          	lw	a0,12(s3)
40018350:	f55fe0ef          	jal	ra,400172a4 <nbr_clear_ns_pending>
	if (pkt) {
40018354:	ec9ff06f          	j	4001821c <net_ipv6_send_ns+0xec>
			k_work_reschedule(&ipv6_ns_reply_timer,
40018358:	40031537          	lui	a0,0x40031
4001835c:	06400593          	li	a1,100
40018360:	00000613          	li	a2,0
40018364:	07850513          	addi	a0,a0,120 # 40031078 <ipv6_ns_reply_timer>
40018368:	2bc110ef          	jal	ra,40029624 <k_work_reschedule>
4001836c:	fd5ff06f          	j	40018340 <net_ipv6_send_ns+0x210>
	if (net_send_data(pkt) < 0) {
40018370:	00040513          	mv	a0,s0
40018374:	b54f30ef          	jal	ra,4000b6c8 <net_send_data>
40018378:	ea0542e3          	bltz	a0,4001821c <net_ipv6_send_ns+0xec>
	}

	net_stats_update_ipv6_nd_drop(iface);

	return ret;
}
4001837c:	04c12083          	lw	ra,76(sp)
40018380:	04812403          	lw	s0,72(sp)
40018384:	04012903          	lw	s2,64(sp)
40018388:	03c12983          	lw	s3,60(sp)
4001838c:	03812a03          	lw	s4,56(sp)
40018390:	03412a83          	lw	s5,52(sp)
40018394:	03012b03          	lw	s6,48(sp)
40018398:	02c12b83          	lw	s7,44(sp)
4001839c:	00048513          	mv	a0,s1
400183a0:	04412483          	lw	s1,68(sp)
400183a4:	05010113          	addi	sp,sp,80
400183a8:	00008067          	ret
	if (pending) {
400183ac:	00091663          	bnez	s2,400183b8 <net_ipv6_send_ns+0x288>
		ret = -ENOMEM;
400183b0:	ff400493          	li	s1,-12
400183b4:	fc9ff06f          	j	4001837c <net_ipv6_send_ns+0x24c>
		net_pkt_unref(pending);
400183b8:	00090513          	mv	a0,s2
400183bc:	b61fa0ef          	jal	ra,40012f1c <net_pkt_unref>
	if (pkt) {
400183c0:	ff1ff06f          	j	400183b0 <net_ipv6_send_ns+0x280>
	if (pending) {
400183c4:	00091663          	bnez	s2,400183d0 <net_ipv6_send_ns+0x2a0>
			ret = -EINVAL;
400183c8:	fea00493          	li	s1,-22
400183cc:	fb1ff06f          	j	4001837c <net_ipv6_send_ns+0x24c>
		net_pkt_unref(pending);
400183d0:	00090513          	mv	a0,s2
400183d4:	b49fa0ef          	jal	ra,40012f1c <net_pkt_unref>
	if (pkt) {
400183d8:	ff1ff06f          	j	400183c8 <net_ipv6_send_ns+0x298>

400183dc <net_ipv6_nbr_add>:
{
400183dc:	fe010113          	addi	sp,sp,-32
400183e0:	00912a23          	sw	s1,20(sp)
400183e4:	00060493          	mv	s1,a2
400183e8:	00068613          	mv	a2,a3
	nbr = add_nbr(iface, addr, is_router, state);
400183ec:	00070693          	mv	a3,a4
{
400183f0:	00812c23          	sw	s0,24(sp)
400183f4:	01212823          	sw	s2,16(sp)
400183f8:	01412423          	sw	s4,8(sp)
400183fc:	00112e23          	sw	ra,28(sp)
40018400:	01312623          	sw	s3,12(sp)
40018404:	00050913          	mv	s2,a0
40018408:	00058a13          	mv	s4,a1
	nbr = add_nbr(iface, addr, is_router, state);
4001840c:	e64ff0ef          	jal	ra,40017a70 <add_nbr>
40018410:	00050413          	mv	s0,a0
	if (!nbr) {
40018414:	0a050e63          	beqz	a0,400184d0 <net_ipv6_nbr_add+0xf4>
	if (lladdr && net_nbr_link(nbr, iface, lladdr) == -EALREADY &&
40018418:	06048663          	beqz	s1,40018484 <net_ipv6_nbr_add+0xa8>
4001841c:	00048613          	mv	a2,s1
40018420:	00090593          	mv	a1,s2
40018424:	8f8fe0ef          	jal	ra,4001651c <net_nbr_link>
40018428:	f8800793          	li	a5,-120
4001842c:	04f51c63          	bne	a0,a5,40018484 <net_ipv6_nbr_add+0xa8>
	    net_ipv6_nbr_data(nbr)->state != NET_IPV6_NBR_STATE_STATIC) {
40018430:	00c42783          	lw	a5,12(s0)
	if (lladdr && net_nbr_link(nbr, iface, lladdr) == -EALREADY &&
40018434:	0307a703          	lw	a4,48(a5)
40018438:	00500793          	li	a5,5
4001843c:	06f70e63          	beq	a4,a5,400184b8 <net_ipv6_nbr_add+0xdc>
		cached_lladdr = net_nbr_get_lladdr(nbr->idx);
40018440:	00144503          	lbu	a0,1(s0)
40018444:	ac4fe0ef          	jal	ra,40016708 <net_nbr_get_lladdr>
		if (memcmp(cached_lladdr->addr, lladdr->addr, lladdr->len)) {
40018448:	0044c603          	lbu	a2,4(s1)
4001844c:	0004a583          	lw	a1,0(s1)
		cached_lladdr = net_nbr_get_lladdr(nbr->idx);
40018450:	00050993          	mv	s3,a0
		if (memcmp(cached_lladdr->addr, lladdr->addr, lladdr->len)) {
40018454:	00250513          	addi	a0,a0,2
40018458:	b75f00ef          	jal	ra,40008fcc <memcmp>
4001845c:	04050863          	beqz	a0,400184ac <net_ipv6_nbr_add+0xd0>
			dbg_update_neighbor_lladdr(lladdr, cached_lladdr, addr);
40018460:	00098513          	mv	a0,s3
40018464:	a1cff0ef          	jal	ra,40017680 <dbg_update_neighbor_lladdr.constprop.0>
			net_linkaddr_set(cached_lladdr, lladdr->addr,
40018468:	0044c603          	lbu	a2,4(s1)
4001846c:	0004a583          	lw	a1,0(s1)
40018470:	00098513          	mv	a0,s3
40018474:	b40ff0ef          	jal	ra,400177b4 <net_linkaddr_set.isra.0>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_STALE);
40018478:	00200593          	li	a1,2
4001847c:	00040513          	mv	a0,s0
40018480:	b58ff0ef          	jal	ra,400177d8 <ipv6_nbr_set_state>
	if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_INCOMPLETE) {
40018484:	00c42783          	lw	a5,12(s0)
40018488:	0307a783          	lw	a5,48(a5)
4001848c:	02079663          	bnez	a5,400184b8 <net_ipv6_nbr_add+0xdc>
		ret = net_ipv6_send_ns(iface, NULL, NULL, NULL, addr, false);
40018490:	000a0713          	mv	a4,s4
40018494:	00000693          	li	a3,0
40018498:	00000613          	li	a2,0
4001849c:	00000593          	li	a1,0
400184a0:	00090513          	mv	a0,s2
400184a4:	c8dff0ef          	jal	ra,40018130 <net_ipv6_send_ns>
		if (ret < 0) {
400184a8:	0100006f          	j	400184b8 <net_ipv6_nbr_add+0xdc>
		} else if (net_ipv6_nbr_data(nbr)->state ==
400184ac:	00c42783          	lw	a5,12(s0)
400184b0:	0307a783          	lw	a5,48(a5)
400184b4:	fc0782e3          	beqz	a5,40018478 <net_ipv6_nbr_add+0x9c>
400184b8:	e0600537          	lui	a0,0xe0600
400184bc:	00000693          	li	a3,0
400184c0:	00000613          	li	a2,0
400184c4:	00090593          	mv	a1,s2
400184c8:	00f50513          	addi	a0,a0,15 # e060000f <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600010>
400184cc:	a65f80ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
}
400184d0:	01c12083          	lw	ra,28(sp)
400184d4:	00040513          	mv	a0,s0
400184d8:	01812403          	lw	s0,24(sp)
400184dc:	01412483          	lw	s1,20(sp)
400184e0:	01012903          	lw	s2,16(sp)
400184e4:	00c12983          	lw	s3,12(sp)
400184e8:	00812a03          	lw	s4,8(sp)
400184ec:	02010113          	addi	sp,sp,32
400184f0:	00008067          	ret

400184f4 <handle_ra_input>:
#endif

static enum net_verdict handle_ra_input(struct net_pkt *pkt,
					struct net_ipv6_hdr *ip_hdr,
					struct net_icmp_hdr *icmp_hdr)
{
400184f4:	f5010113          	addi	sp,sp,-176
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,
400184f8:	00c00793          	li	a5,12
400184fc:	02f12623          	sw	a5,44(sp)
					      struct net_icmpv6_ra_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
40018500:	01810793          	addi	a5,sp,24
{
40018504:	0a812423          	sw	s0,168(sp)
40018508:	0b212023          	sw	s2,160(sp)
4001850c:	09312e23          	sw	s3,156(sp)
40018510:	09412c23          	sw	s4,152(sp)
40018514:	0a112623          	sw	ra,172(sp)
40018518:	0a912223          	sw	s1,164(sp)
4001851c:	09512a23          	sw	s5,148(sp)
40018520:	09612823          	sw	s6,144(sp)
40018524:	09712623          	sw	s7,140(sp)
40018528:	09812423          	sw	s8,136(sp)
4001852c:	09912223          	sw	s9,132(sp)
40018530:	09a12023          	sw	s10,128(sp)
40018534:	07b12e23          	sw	s11,124(sp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
40018538:	02f12823          	sw	a5,48(sp)
4001853c:	00200793          	li	a5,2
40018540:	02f12a23          	sw	a5,52(sp)
	uint16_t length = net_pkt_get_len(pkt);
40018544:	00852783          	lw	a5,8(a0)
{
40018548:	00050413          	mv	s0,a0
4001854c:	00058993          	mv	s3,a1
40018550:	00060a13          	mv	s4,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ra_access,
40018554:	02012423          	sw	zero,40(sp)
	size_t bytes = 0;
40018558:	00000913          	li	s2,0
	while (buf) {
4001855c:	04079a63          	bnez	a5,400185b0 <handle_ra_input+0xbc>
	struct net_icmpv6_ra_hdr *ra_hdr;
	struct net_if_router *router;
	uint32_t mtu, reachable_time, retrans_timer;
	uint16_t router_lifetime;

	if (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {
40018560:	01842503          	lw	a0,24(s0)
40018564:	00b00593          	li	a1,11
40018568:	a08ff0ef          	jal	ra,40017770 <net_if_flag_is_set>
4001856c:	04050a63          	beqz	a0,400185c0 <handle_ra_input+0xcc>
	return NET_OK;

drop:
	net_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));

	return NET_DROP;
40018570:	00200513          	li	a0,2
}
40018574:	0ac12083          	lw	ra,172(sp)
40018578:	0a812403          	lw	s0,168(sp)
4001857c:	0a412483          	lw	s1,164(sp)
40018580:	0a012903          	lw	s2,160(sp)
40018584:	09c12983          	lw	s3,156(sp)
40018588:	09812a03          	lw	s4,152(sp)
4001858c:	09412a83          	lw	s5,148(sp)
40018590:	09012b03          	lw	s6,144(sp)
40018594:	08c12b83          	lw	s7,140(sp)
40018598:	08812c03          	lw	s8,136(sp)
4001859c:	08412c83          	lw	s9,132(sp)
400185a0:	08012d03          	lw	s10,128(sp)
400185a4:	07c12d83          	lw	s11,124(sp)
400185a8:	0b010113          	addi	sp,sp,176
400185ac:	00008067          	ret
		bytes += buf->len;
400185b0:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
400185b4:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
400185b8:	00e90933          	add	s2,s2,a4
		buf = buf->frags;
400185bc:	fa1ff06f          	j	4001855c <handle_ra_input+0x68>
	ra_hdr = (struct net_icmpv6_ra_hdr *)net_pkt_get_data(pkt, &ra_access);
400185c0:	02810593          	addi	a1,sp,40
400185c4:	00040513          	mv	a0,s0
400185c8:	9b5fb0ef          	jal	ra,40013f7c <net_pkt_get_data>
400185cc:	00050493          	mv	s1,a0
	if (!ra_hdr) {
400185d0:	fa0500e3          	beqz	a0,40018570 <handle_ra_input+0x7c>
	if (((length < (sizeof(struct net_ipv6_hdr) +
400185d4:	01091913          	slli	s2,s2,0x10
400185d8:	01095913          	srli	s2,s2,0x10
400185dc:	03900793          	li	a5,57
400185e0:	0327f663          	bgeu	a5,s2,4001860c <handle_ra_input+0x118>
			sizeof(struct net_icmpv6_nd_opt_hdr))) ||
400185e4:	0079c703          	lbu	a4,7(s3)
400185e8:	0ff00793          	li	a5,255
400185ec:	02f71063          	bne	a4,a5,4001860c <handle_ra_input+0x118>
	return UNALIGNED_GET(&addr->s6_addr16[0]) == htons(0xFE80);
400185f0:	0099c783          	lbu	a5,9(s3)
400185f4:	0089c703          	lbu	a4,8(s3)
400185f8:	00879793          	slli	a5,a5,0x8
	     (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT) ||
400185fc:	00e7e7b3          	or	a5,a5,a4
40018600:	00008737          	lui	a4,0x8
40018604:	0fe70713          	addi	a4,a4,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
40018608:	00e78663          	beq	a5,a4,40018614 <handle_ra_input+0x120>
	     !net_ipv6_is_ll_addr((struct in6_addr *)ip_hdr->src)) &&
4001860c:	001a4783          	lbu	a5,1(s4)
40018610:	f60790e3          	bnez	a5,40018570 <handle_ra_input+0x7c>
	net_pkt_acknowledge_data(pkt, &ra_access);
40018614:	02c12583          	lw	a1,44(sp)
40018618:	00040513          	mv	a0,s0
4001861c:	994ff0ef          	jal	ra,400177b0 <net_pkt_acknowledge_data.isra.0>
	router_lifetime = ntohs(ra_hdr->router_lifetime);
40018620:	0034ca03          	lbu	s4,3(s1)
40018624:	0024c783          	lbu	a5,2(s1)
	reachable_time = ntohl(ra_hdr->reachable_time);
40018628:	0054c703          	lbu	a4,5(s1)
4001862c:	008a1a13          	slli	s4,s4,0x8
40018630:	00fa6a33          	or	s4,s4,a5
40018634:	0044c783          	lbu	a5,4(s1)
40018638:	00871713          	slli	a4,a4,0x8
4001863c:	0074c903          	lbu	s2,7(s1)
40018640:	00f76733          	or	a4,a4,a5
40018644:	0064c783          	lbu	a5,6(s1)
40018648:	01891913          	slli	s2,s2,0x18
4001864c:	00010637          	lui	a2,0x10
40018650:	01079793          	slli	a5,a5,0x10
40018654:	00e7e7b3          	or	a5,a5,a4
40018658:	00f96733          	or	a4,s2,a5
4001865c:	01879793          	slli	a5,a5,0x18
40018660:	01895913          	srli	s2,s2,0x18
40018664:	00f96933          	or	s2,s2,a5
40018668:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001866c:	00875793          	srli	a5,a4,0x8
40018670:	00ff05b7          	lui	a1,0xff0
40018674:	00c7f7b3          	and	a5,a5,a2
40018678:	00871713          	slli	a4,a4,0x8
4001867c:	00b77733          	and	a4,a4,a1
40018680:	00f96933          	or	s2,s2,a5
	retrans_timer = ntohl(ra_hdr->retrans_timer);
40018684:	0094c783          	lbu	a5,9(s1)
	reachable_time = ntohl(ra_hdr->reachable_time);
40018688:	00e96933          	or	s2,s2,a4
	retrans_timer = ntohl(ra_hdr->retrans_timer);
4001868c:	0084c703          	lbu	a4,8(s1)
40018690:	00879793          	slli	a5,a5,0x8
40018694:	00e7e7b3          	or	a5,a5,a4
40018698:	00a4c703          	lbu	a4,10(s1)
4001869c:	01071713          	slli	a4,a4,0x10
400186a0:	00f76733          	or	a4,a4,a5
400186a4:	00b4c783          	lbu	a5,11(s1)
400186a8:	01879793          	slli	a5,a5,0x18
400186ac:	00e7e6b3          	or	a3,a5,a4
400186b0:	01871713          	slli	a4,a4,0x18
400186b4:	0187d793          	srli	a5,a5,0x18
400186b8:	00e7e7b3          	or	a5,a5,a4
400186bc:	0086d713          	srli	a4,a3,0x8
400186c0:	00869693          	slli	a3,a3,0x8
400186c4:	00b6f6b3          	and	a3,a3,a1
	if (ra_hdr->cur_hop_limit) {
400186c8:	0004c583          	lbu	a1,0(s1)
	retrans_timer = ntohl(ra_hdr->retrans_timer);
400186cc:	00c77733          	and	a4,a4,a2
400186d0:	00e7e7b3          	or	a5,a5,a4
400186d4:	00d7eab3          	or	s5,a5,a3
	if (ra_hdr->cur_hop_limit) {
400186d8:	00058663          	beqz	a1,400186e4 <handle_ra_input+0x1f0>
		net_ipv6_set_hop_limit(net_pkt_iface(pkt),
400186dc:	01842503          	lw	a0,24(s0)
400186e0:	ffdf50ef          	jal	ra,4000e6dc <net_ipv6_set_hop_limit>
	if (reachable_time && reachable_time <= MAX_REACHABLE_TIME &&
400186e4:	0036f7b7          	lui	a5,0x36f
400186e8:	fff90713          	addi	a4,s2,-1
400186ec:	e7f78793          	addi	a5,a5,-385 # 36ee7f <__rom_region_size+0x33e4a3>
400186f0:	02e7ea63          	bltu	a5,a4,40018724 <handle_ra_input+0x230>
	return pkt->iface;
400186f4:	01842783          	lw	a5,24(s0)
400186f8:	0047a783          	lw	a5,4(a5)
	if (!iface->config.ip.ipv6) {
400186fc:	00078863          	beqz	a5,4001870c <handle_ra_input+0x218>
40018700:	1147a703          	lw	a4,276(a5)
40018704:	02e90063          	beq	s2,a4,40018724 <handle_ra_input+0x230>
	iface->config.ip.ipv6->base_reachable_time = reachable_time;
40018708:	1127a823          	sw	s2,272(a5)
		net_if_ipv6_set_reachable_time(
4001870c:	01842783          	lw	a5,24(s0)
40018710:	0047a903          	lw	s2,4(a5)
	if (ipv6 == NULL) {
40018714:	00090863          	beqz	s2,40018724 <handle_ra_input+0x230>
	ipv6->reachable_time = net_if_ipv6_calc_reachable_time(ipv6);
40018718:	00090513          	mv	a0,s2
4001871c:	a5cf60ef          	jal	ra,4000e978 <net_if_ipv6_calc_reachable_time>
40018720:	10a92a23          	sw	a0,276(s2)
	if (retrans_timer) {
40018724:	020a8e63          	beqz	s5,40018760 <handle_ra_input+0x26c>
40018728:	01842783          	lw	a5,24(s0)
4001872c:	0047a683          	lw	a3,4(a5)
	if (!iface->config.ip.ipv6) {
40018730:	02068863          	beqz	a3,40018760 <handle_ra_input+0x26c>
		net_if_ipv6_set_retrans_timer(net_pkt_iface(pkt),
40018734:	0094c783          	lbu	a5,9(s1)
40018738:	0084c703          	lbu	a4,8(s1)
4001873c:	00879793          	slli	a5,a5,0x8
40018740:	00e7e7b3          	or	a5,a5,a4
40018744:	00a4c703          	lbu	a4,10(s1)
40018748:	01071713          	slli	a4,a4,0x10
4001874c:	00f76733          	or	a4,a4,a5
40018750:	00b4c783          	lbu	a5,11(s1)
40018754:	01879793          	slli	a5,a5,0x18
40018758:	00e7e7b3          	or	a5,a5,a4
	iface->config.ip.ipv6->retrans_timer = retrans_timer;
4001875c:	10f6ac23          	sw	a5,280(a3)
	pkt->ipv6_ext_opt_len = len;
40018760:	00c00793          	li	a5,12
40018764:	02f40f23          	sb	a5,62(s0)
				net_pkt_get_data(pkt, &nd_access);
40018768:	03010593          	addi	a1,sp,48
4001876c:	00040513          	mv	a0,s0
40018770:	80dfb0ef          	jal	ra,40013f7c <net_pkt_get_data>
	return pkt->frags->data;
40018774:	00842783          	lw	a5,8(s0)
40018778:	00050493          	mv	s1,a0
	nbr = net_ipv6_nbr_add(net_pkt_iface(pkt), (struct in6_addr *)NET_IPV6_HDR(pkt)->src, NULL,
4001877c:	01842503          	lw	a0,24(s0)
40018780:	00c7a583          	lw	a1,12(a5)
40018784:	00000713          	li	a4,0
40018788:	00100693          	li	a3,1
4001878c:	00000613          	li	a2,0
40018790:	00858593          	addi	a1,a1,8 # ff0008 <__rom_region_size+0xfbf62c>
40018794:	c49ff0ef          	jal	ra,400183dc <net_ipv6_nbr_add>
			if (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {
40018798:	00010bb7          	lui	s7,0x10
	rdnss_size = len * 8U - 2 - sizeof(struct net_icmpv6_nd_opt_rdnss);
4001879c:	20000b37          	lui	s6,0x20000
	nbr = net_ipv6_nbr_add(net_pkt_iface(pkt), (struct in6_addr *)NET_IPV6_HDR(pkt)->src, NULL,
400187a0:	00050913          	mv	s2,a0
			if (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {
400187a4:	affb8c13          	addi	s8,s7,-1281 # faff <__kernel_ram_size+0x386b>
	NET_PKT_DATA_ACCESS_DEFINE(routeinfo_access,
400187a8:	03810a93          	addi	s5,sp,56
	rdnss_size = len * 8U - 2 - sizeof(struct net_icmpv6_nd_opt_rdnss);
400187ac:	fffb0b13          	addi	s6,s6,-1 # 1fffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1a0a1eff>
	while (nd_opt_hdr) {
400187b0:	04049463          	bnez	s1,400187f8 <handle_ra_input+0x304>
400187b4:	008a5793          	srli	a5,s4,0x8
400187b8:	008a1613          	slli	a2,s4,0x8
400187bc:	00f66633          	or	a2,a2,a5
	router = net_if_ipv6_router_lookup(net_pkt_iface(pkt),
400187c0:	01842503          	lw	a0,24(s0)
400187c4:	01061613          	slli	a2,a2,0x10
400187c8:	01065613          	srli	a2,a2,0x10
					   (struct in6_addr *)ip_hdr->src);
400187cc:	00898593          	addi	a1,s3,8
400187d0:	00c12623          	sw	a2,12(sp)
	router = net_if_ipv6_router_lookup(net_pkt_iface(pkt),
400187d4:	00b12423          	sw	a1,8(sp)
400187d8:	e59f50ef          	jal	ra,4000e630 <net_if_ipv6_router_lookup>
	if (router) {
400187dc:	00812583          	lw	a1,8(sp)
400187e0:	00c12603          	lw	a2,12(sp)
400187e4:	6e050863          	beqz	a0,40018ed4 <handle_ra_input+0x9e0>
		if (!router_lifetime) {
400187e8:	680a1463          	bnez	s4,40018e70 <handle_ra_input+0x97c>
			net_if_ipv6_router_rm(router);
400187ec:	ea5f50ef          	jal	ra,4000e690 <net_if_ipv6_router_rm>
	if (nbr && net_ipv6_nbr_data(nbr)->pending) {
400187f0:	68090663          	beqz	s2,40018e7c <handle_ra_input+0x988>
400187f4:	6b40006f          	j	40018ea8 <handle_ra_input+0x9b4>
		net_pkt_acknowledge_data(pkt, &nd_access);
400187f8:	03412583          	lw	a1,52(sp)
400187fc:	00040513          	mv	a0,s0
40018800:	fb1fe0ef          	jal	ra,400177b0 <net_pkt_acknowledge_data.isra.0>
		switch (nd_opt_hdr->type) {
40018804:	0004c783          	lbu	a5,0(s1)
40018808:	00500713          	li	a4,5
4001880c:	14e78063          	beq	a5,a4,4001894c <handle_ra_input+0x458>
40018810:	0014c483          	lbu	s1,1(s1)
40018814:	02f76663          	bltu	a4,a5,40018840 <handle_ra_input+0x34c>
40018818:	00100713          	li	a4,1
4001881c:	0ce78863          	beq	a5,a4,400188ec <handle_ra_input+0x3f8>
40018820:	00300713          	li	a4,3
40018824:	16e78863          	beq	a5,a4,40018994 <handle_ra_input+0x4a0>
			if (net_pkt_skip(pkt, nd_opt_hdr->len * 8U - 2)) {
40018828:	00349593          	slli	a1,s1,0x3
4001882c:	ffe58593          	addi	a1,a1,-2
40018830:	00040513          	mv	a0,s0
40018834:	f31fa0ef          	jal	ra,40013764 <net_pkt_skip>
40018838:	10050063          	beqz	a0,40018938 <handle_ra_input+0x444>
4001883c:	d35ff06f          	j	40018570 <handle_ra_input+0x7c>
		switch (nd_opt_hdr->type) {
40018840:	01800713          	li	a4,24
40018844:	50e78e63          	beq	a5,a4,40018d60 <handle_ra_input+0x86c>
40018848:	01900713          	li	a4,25
4001884c:	fce79ee3          	bne	a5,a4,40018828 <handle_ra_input+0x334>
	NET_PKT_DATA_ACCESS_DEFINE(rdnss_access, struct net_icmpv6_nd_opt_rdnss);
40018850:	02010793          	addi	a5,sp,32
40018854:	02f12c23          	sw	a5,56(sp)
	struct sockaddr_in6 dns = {
40018858:	00000593          	li	a1,0
	NET_PKT_DATA_ACCESS_DEFINE(rdnss_access, struct net_icmpv6_nd_opt_rdnss);
4001885c:	00600793          	li	a5,6
	struct sockaddr_in6 dns = {
40018860:	01600613          	li	a2,22
40018864:	05210513          	addi	a0,sp,82
	NET_PKT_DATA_ACCESS_DEFINE(rdnss_access, struct net_icmpv6_nd_opt_rdnss);
40018868:	02f12e23          	sw	a5,60(sp)
	struct sockaddr_in6 dns = {
4001886c:	805f00ef          	jal	ra,40009070 <memset>
40018870:	00200793          	li	a5,2
40018874:	04f11823          	sh	a5,80(sp)
	rdnss = (struct net_icmpv6_nd_opt_rdnss *) net_pkt_get_data(pkt, &rdnss_access);
40018878:	000a8593          	mv	a1,s5
	const struct sockaddr *dns_servers[] = {
4001887c:	05010793          	addi	a5,sp,80
	rdnss = (struct net_icmpv6_nd_opt_rdnss *) net_pkt_get_data(pkt, &rdnss_access);
40018880:	00040513          	mv	a0,s0
	const struct sockaddr *dns_servers[] = {
40018884:	04f12023          	sw	a5,64(sp)
40018888:	04012223          	sw	zero,68(sp)
	rdnss = (struct net_icmpv6_nd_opt_rdnss *) net_pkt_get_data(pkt, &rdnss_access);
4001888c:	ef0fb0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!rdnss) {
40018890:	ce0500e3          	beqz	a0,40018570 <handle_ra_input+0x7c>
	ret = net_pkt_acknowledge_data(pkt, &rdnss_access);
40018894:	03c12583          	lw	a1,60(sp)
40018898:	00040513          	mv	a0,s0
4001889c:	f15fe0ef          	jal	ra,400177b0 <net_pkt_acknowledge_data.isra.0>
	if (ret < 0) {
400188a0:	cc0548e3          	bltz	a0,40018570 <handle_ra_input+0x7c>
	rdnss_size = len * 8U - 2 - sizeof(struct net_icmpv6_nd_opt_rdnss);
400188a4:	016484b3          	add	s1,s1,s6
400188a8:	00349493          	slli	s1,s1,0x3
	if ((rdnss_size % NET_IPV6_ADDR_SIZE) != 0) {
400188ac:	00f4f793          	andi	a5,s1,15
400188b0:	cc0790e3          	bnez	a5,40018570 <handle_ra_input+0x7c>
	ret = net_pkt_read(pkt, dns.sin6_addr.s6_addr, NET_IPV6_ADDR_SIZE);
400188b4:	01000613          	li	a2,16
400188b8:	05410593          	addi	a1,sp,84
400188bc:	00040513          	mv	a0,s0
400188c0:	90cfb0ef          	jal	ra,400139cc <net_pkt_read>
	if (ret < 0) {
400188c4:	ca0546e3          	bltz	a0,40018570 <handle_ra_input+0x7c>
	if (net_pkt_skip(pkt, rdnss_size - NET_IPV6_ADDR_SIZE)) {
400188c8:	ff048593          	addi	a1,s1,-16
400188cc:	00040513          	mv	a0,s0
400188d0:	e95fa0ef          	jal	ra,40013764 <net_pkt_skip>
400188d4:	c8051ee3          	bnez	a0,40018570 <handle_ra_input+0x7c>
	ctx = dns_resolve_get_default();
400188d8:	0180d0ef          	jal	ra,400258f0 <dns_resolve_get_default>
	ret = dns_resolve_reconfigure(ctx, NULL, dns_servers);
400188dc:	04010613          	addi	a2,sp,64
400188e0:	00000593          	li	a1,0
400188e4:	6dd0c0ef          	jal	ra,400257c0 <dns_resolve_reconfigure>
	if (ret < 0) {
400188e8:	0500006f          	j	40018938 <handle_ra_input+0x444>
	if (!read_llao(pkt, len, &llstorage)) {
400188ec:	05010613          	addi	a2,sp,80
400188f0:	00048593          	mv	a1,s1
400188f4:	00040513          	mv	a0,s0
400188f8:	c21fe0ef          	jal	ra,40017518 <read_llao>
400188fc:	c6050ae3          	beqz	a0,40018570 <handle_ra_input+0x7c>
	lladdr.len = llstorage.len;
40018900:	05114783          	lbu	a5,81(sp)
	return net_ipv6_nbr_add(net_pkt_iface(pkt),
40018904:	01842503          	lw	a0,24(s0)
40018908:	00200713          	li	a4,2
	lladdr.len = llstorage.len;
4001890c:	04f10223          	sb	a5,68(sp)
	lladdr.addr = llstorage.addr;
40018910:	05210793          	addi	a5,sp,82
40018914:	04f12023          	sw	a5,64(sp)
40018918:	00842783          	lw	a5,8(s0)
	return net_ipv6_nbr_add(net_pkt_iface(pkt),
4001891c:	00100693          	li	a3,1
40018920:	04010613          	addi	a2,sp,64
				(struct in6_addr *)NET_IPV6_HDR(pkt)->src,
40018924:	00c7a583          	lw	a1,12(a5)
	return net_ipv6_nbr_add(net_pkt_iface(pkt),
40018928:	00858593          	addi	a1,a1,8
4001892c:	ab1ff0ef          	jal	ra,400183dc <net_ipv6_nbr_add>
40018930:	00050913          	mv	s2,a0
			if (!nbr) {
40018934:	c2050ee3          	beqz	a0,40018570 <handle_ra_input+0x7c>
					net_pkt_get_data(pkt, &nd_access);
40018938:	03010593          	addi	a1,sp,48
4001893c:	00040513          	mv	a0,s0
40018940:	e3cfb0ef          	jal	ra,40013f7c <net_pkt_get_data>
40018944:	00050493          	mv	s1,a0
40018948:	e69ff06f          	j	400187b0 <handle_ra_input+0x2bc>
			if (net_pkt_skip(pkt, 2) ||
4001894c:	00200593          	li	a1,2
40018950:	00040513          	mv	a0,s0
40018954:	e11fa0ef          	jal	ra,40013764 <net_pkt_skip>
40018958:	c0051ce3          	bnez	a0,40018570 <handle_ra_input+0x7c>
			    net_pkt_read_be32(pkt, &mtu)) {
4001895c:	01c10593          	addi	a1,sp,28
40018960:	00040513          	mv	a0,s0
40018964:	874fb0ef          	jal	ra,400139d8 <net_pkt_read_be32>
			if (net_pkt_skip(pkt, 2) ||
40018968:	c00514e3          	bnez	a0,40018570 <handle_ra_input+0x7c>
			if (mtu < MIN_IPV6_MTU || mtu > MAX_IPV6_MTU) {
4001896c:	01c12783          	lw	a5,28(sp)
40018970:	b0078713          	addi	a4,a5,-1280
40018974:	beec6ee3          	bltu	s8,a4,40018570 <handle_ra_input+0x7c>
	return pkt->iface;
40018978:	01842703          	lw	a4,24(s0)
			net_if_set_mtu(net_pkt_iface(pkt), mtu);
4001897c:	01079793          	slli	a5,a5,0x10
40018980:	0107d793          	srli	a5,a5,0x10
	if (iface == NULL) {
40018984:	fa070ae3          	beqz	a4,40018938 <handle_ra_input+0x444>
	iface->if_dev->mtu = mtu;
40018988:	00072703          	lw	a4,0(a4)
4001898c:	00f71c23          	sh	a5,24(a4)
40018990:	fa9ff06f          	j	40018938 <handle_ra_input+0x444>
			if (nd_opt_hdr->len != 4) {
40018994:	00400793          	li	a5,4
40018998:	bcf49ce3          	bne	s1,a5,40018570 <handle_ra_input+0x7c>
	NET_PKT_DATA_ACCESS_DEFINE(rapfx_access,
4001899c:	05010793          	addi	a5,sp,80
400189a0:	02f12c23          	sw	a5,56(sp)
				net_pkt_get_data(pkt, &rapfx_access);
400189a4:	000a8593          	mv	a1,s5
	NET_PKT_DATA_ACCESS_DEFINE(rapfx_access,
400189a8:	01e00793          	li	a5,30
				net_pkt_get_data(pkt, &rapfx_access);
400189ac:	00040513          	mv	a0,s0
	NET_PKT_DATA_ACCESS_DEFINE(rapfx_access,
400189b0:	02f12e23          	sw	a5,60(sp)
				net_pkt_get_data(pkt, &rapfx_access);
400189b4:	dc8fb0ef          	jal	ra,40013f7c <net_pkt_get_data>
400189b8:	00050493          	mv	s1,a0
	if (!pfx_info) {
400189bc:	ba050ae3          	beqz	a0,40018570 <handle_ra_input+0x7c>
	net_pkt_acknowledge_data(pkt, &rapfx_access);
400189c0:	03c12583          	lw	a1,60(sp)
400189c4:	00040513          	mv	a0,s0
400189c8:	de9fe0ef          	jal	ra,400177b0 <net_pkt_acknowledge_data.isra.0>
	valid_lifetime = ntohl(pfx_info->valid_lifetime);
400189cc:	0034c703          	lbu	a4,3(s1)
400189d0:	0024c783          	lbu	a5,2(s1)
400189d4:	0054cc83          	lbu	s9,5(s1)
400189d8:	00871713          	slli	a4,a4,0x8
400189dc:	00f76733          	or	a4,a4,a5
400189e0:	0044c783          	lbu	a5,4(s1)
400189e4:	018c9c93          	slli	s9,s9,0x18
400189e8:	f00b8593          	addi	a1,s7,-256
400189ec:	01079793          	slli	a5,a5,0x10
400189f0:	00e7e7b3          	or	a5,a5,a4
400189f4:	00fce733          	or	a4,s9,a5
400189f8:	01879793          	slli	a5,a5,0x18
400189fc:	018cdc93          	srli	s9,s9,0x18
40018a00:	00fcecb3          	or	s9,s9,a5
40018a04:	00875793          	srli	a5,a4,0x8
40018a08:	00b7f7b3          	and	a5,a5,a1
40018a0c:	00ff0637          	lui	a2,0xff0
40018a10:	00871713          	slli	a4,a4,0x8
40018a14:	00fcecb3          	or	s9,s9,a5
40018a18:	00c77733          	and	a4,a4,a2
	preferred_lifetime = ntohl(pfx_info->preferred_lifetime);
40018a1c:	0074c783          	lbu	a5,7(s1)
	valid_lifetime = ntohl(pfx_info->valid_lifetime);
40018a20:	00ececb3          	or	s9,s9,a4
	preferred_lifetime = ntohl(pfx_info->preferred_lifetime);
40018a24:	0064c703          	lbu	a4,6(s1)
40018a28:	00879793          	slli	a5,a5,0x8
40018a2c:	00e7e7b3          	or	a5,a5,a4
40018a30:	0084c703          	lbu	a4,8(s1)
40018a34:	01071713          	slli	a4,a4,0x10
40018a38:	00f76733          	or	a4,a4,a5
40018a3c:	0094c783          	lbu	a5,9(s1)
40018a40:	01879793          	slli	a5,a5,0x18
40018a44:	00e7e6b3          	or	a3,a5,a4
40018a48:	01871713          	slli	a4,a4,0x18
40018a4c:	0187d793          	srli	a5,a5,0x18
40018a50:	00e7e7b3          	or	a5,a5,a4
40018a54:	0086d713          	srli	a4,a3,0x8
40018a58:	00b77733          	and	a4,a4,a1
40018a5c:	00869693          	slli	a3,a3,0x8
40018a60:	00e7e7b3          	or	a5,a5,a4
40018a64:	00c6f6b3          	and	a3,a3,a2
40018a68:	00d7e7b3          	or	a5,a5,a3
	if (valid_lifetime >= preferred_lifetime &&
40018a6c:	ecfce6e3          	bltu	s9,a5,40018938 <handle_ra_input+0x444>
40018a70:	00f4c783          	lbu	a5,15(s1)
40018a74:	00e4c703          	lbu	a4,14(s1)
40018a78:	00879793          	slli	a5,a5,0x8
40018a7c:	00e7e7b3          	or	a5,a5,a4
40018a80:	00008737          	lui	a4,0x8
40018a84:	0fe70713          	addi	a4,a4,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
40018a88:	eae788e3          	beq	a5,a4,40018938 <handle_ra_input+0x444>
		if (pfx_info->flags & NET_ICMPV6_RA_FLAG_ONLINK) {
40018a8c:	00148783          	lb	a5,1(s1)
40018a90:	0c07de63          	bgez	a5,40018b6c <handle_ra_input+0x678>
	prefix = net_if_ipv6_prefix_lookup(net_pkt_iface(pkt),
40018a94:	0004c603          	lbu	a2,0(s1)
40018a98:	01842503          	lw	a0,24(s0)
					   (struct in6_addr *)prefix_info->prefix,
40018a9c:	00e48593          	addi	a1,s1,14
	prefix = net_if_ipv6_prefix_lookup(net_pkt_iface(pkt),
40018aa0:	00b12423          	sw	a1,8(sp)
40018aa4:	fa4f50ef          	jal	ra,4000e248 <net_if_ipv6_prefix_lookup>
	if (!prefix) {
40018aa8:	00812583          	lw	a1,8(sp)
40018aac:	04051063          	bnez	a0,40018aec <handle_ra_input+0x5f8>
		if (!prefix_info->valid_lifetime) {
40018ab0:	0034c703          	lbu	a4,3(s1)
40018ab4:	0024c783          	lbu	a5,2(s1)
40018ab8:	0054c683          	lbu	a3,5(s1)
40018abc:	00871713          	slli	a4,a4,0x8
40018ac0:	00f76733          	or	a4,a4,a5
40018ac4:	0044c783          	lbu	a5,4(s1)
40018ac8:	01869693          	slli	a3,a3,0x18
40018acc:	01079793          	slli	a5,a5,0x10
40018ad0:	00e7e7b3          	or	a5,a5,a4
40018ad4:	00f6e6b3          	or	a3,a3,a5
40018ad8:	08068a63          	beqz	a3,40018b6c <handle_ra_input+0x678>
		prefix = net_if_ipv6_prefix_add(net_pkt_iface(pkt),
40018adc:	0004c603          	lbu	a2,0(s1)
40018ae0:	01842503          	lw	a0,24(s0)
40018ae4:	cecf50ef          	jal	ra,4000dfd0 <net_if_ipv6_prefix_add>
		if (prefix) {
40018ae8:	08050263          	beqz	a0,40018b6c <handle_ra_input+0x678>
	switch (prefix_info->valid_lifetime) {
40018aec:	0034c703          	lbu	a4,3(s1)
40018af0:	0024c783          	lbu	a5,2(s1)
40018af4:	00871713          	slli	a4,a4,0x8
40018af8:	00f76733          	or	a4,a4,a5
40018afc:	0044c783          	lbu	a5,4(s1)
40018b00:	01079793          	slli	a5,a5,0x10
40018b04:	00e7e7b3          	or	a5,a5,a4
40018b08:	0054c703          	lbu	a4,5(s1)
40018b0c:	01871713          	slli	a4,a4,0x18
40018b10:	00f76733          	or	a4,a4,a5
40018b14:	04070463          	beqz	a4,40018b5c <handle_ra_input+0x668>
40018b18:	fff00693          	li	a3,-1
40018b1c:	02554783          	lbu	a5,37(a0)
40018b20:	14d70463          	beq	a4,a3,40018c68 <handle_ra_input+0x774>
	prefix->is_infinite = is_infinite;
40018b24:	ffe7f793          	andi	a5,a5,-2
40018b28:	02f502a3          	sb	a5,37(a0)
		net_if_ipv6_prefix_set_timer(prefix,
40018b2c:	0034c703          	lbu	a4,3(s1)
40018b30:	0024c783          	lbu	a5,2(s1)
40018b34:	0054c583          	lbu	a1,5(s1)
40018b38:	00871713          	slli	a4,a4,0x8
40018b3c:	00f76733          	or	a4,a4,a5
40018b40:	0044c783          	lbu	a5,4(s1)
40018b44:	01859593          	slli	a1,a1,0x18
40018b48:	01079793          	slli	a5,a5,0x10
40018b4c:	00e7e7b3          	or	a5,a5,a4
40018b50:	00f5e5b3          	or	a1,a1,a5
40018b54:	8b9f50ef          	jal	ra,4000e40c <net_if_ipv6_prefix_set_timer>
		break;
40018b58:	0140006f          	j	40018b6c <handle_ra_input+0x678>
		net_if_ipv6_prefix_rm(net_pkt_iface(pkt),
40018b5c:	02454603          	lbu	a2,36(a0)
40018b60:	01050593          	addi	a1,a0,16
40018b64:	01842503          	lw	a0,24(s0)
40018b68:	991f50ef          	jal	ra,4000e4f8 <net_if_ipv6_prefix_rm>
		if ((pfx_info->flags & NET_ICMPV6_RA_FLAG_AUTONOMOUS) &&
40018b6c:	0014c783          	lbu	a5,1(s1)
40018b70:	0407f793          	andi	a5,a5,64
40018b74:	dc0782e3          	beqz	a5,40018938 <handle_ra_input+0x444>
40018b78:	dc0c80e3          	beqz	s9,40018938 <handle_ra_input+0x444>
		    valid_lifetime &&
40018b7c:	0004c703          	lbu	a4,0(s1)
40018b80:	04000793          	li	a5,64
40018b84:	daf71ae3          	bne	a4,a5,40018938 <handle_ra_input+0x444>
	return &iface->if_dev->link_addr;
40018b88:	01842783          	lw	a5,24(s0)
	struct in6_addr addr = { };
40018b8c:	04012023          	sw	zero,64(sp)
40018b90:	04012223          	sw	zero,68(sp)
40018b94:	04012423          	sw	zero,72(sp)
40018b98:	04012623          	sw	zero,76(sp)
40018b9c:	0007ac83          	lw	s9,0(a5)
	UNALIGNED_PUT(htonl(0xfe800000), &addr->s6_addr32[0]);
40018ba0:	000087b7          	lui	a5,0x8
40018ba4:	0fe78793          	addi	a5,a5,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
40018ba8:	04f12023          	sw	a5,64(sp)
	switch (lladdr->len) {
40018bac:	014cc783          	lbu	a5,20(s9)
40018bb0:	00600713          	li	a4,6
40018bb4:	0ce78063          	beq	a5,a4,40018c74 <handle_ra_input+0x780>
40018bb8:	00800713          	li	a4,8
40018bbc:	10e78463          	beq	a5,a4,40018cc4 <handle_ra_input+0x7d0>
40018bc0:	00200713          	li	a4,2
40018bc4:	02e79a63          	bne	a5,a4,40018bf8 <handle_ra_input+0x704>
		if (lladdr->type == NET_LINK_IEEE802154) {
40018bc8:	015cc703          	lbu	a4,21(s9)
40018bcc:	00100793          	li	a5,1
40018bd0:	02f71463          	bne	a4,a5,40018bf8 <handle_ra_input+0x704>
			addr->s6_addr[11] = 0xff;
40018bd4:	fff00793          	li	a5,-1
40018bd8:	04f105a3          	sb	a5,75(sp)
			addr->s6_addr[12] = 0xfe;
40018bdc:	ffe00793          	li	a5,-2
40018be0:	04f10623          	sb	a5,76(sp)
			addr->s6_addr[14] = lladdr->addr[0];
40018be4:	010ca783          	lw	a5,16(s9)
40018be8:	0007c703          	lbu	a4,0(a5)
40018bec:	04e10723          	sb	a4,78(sp)
			addr->s6_addr[15] = lladdr->addr[1];
40018bf0:	0017c783          	lbu	a5,1(a5)
40018bf4:	04f107a3          	sb	a5,79(sp)
	memcpy(&addr, prefix_info->prefix, sizeof(prefix_info->prefix) / 2);
40018bf8:	00800613          	li	a2,8
40018bfc:	00e48593          	addi	a1,s1,14
40018c00:	04010513          	addi	a0,sp,64
40018c04:	c48f00ef          	jal	ra,4000904c <memcpy>
	ifaddr = net_if_ipv6_addr_lookup(&addr, NULL);
40018c08:	00000593          	li	a1,0
40018c0c:	04010513          	addi	a0,sp,64
40018c10:	b0cf40ef          	jal	ra,4000cf1c <net_if_ipv6_addr_lookup>
40018c14:	0034c703          	lbu	a4,3(s1)
40018c18:	0024c603          	lbu	a2,2(s1)
40018c1c:	0044c783          	lbu	a5,4(s1)
40018c20:	0054c683          	lbu	a3,5(s1)
		if (prefix_info->valid_lifetime ==
40018c24:	00871713          	slli	a4,a4,0x8
40018c28:	00c76733          	or	a4,a4,a2
40018c2c:	01079793          	slli	a5,a5,0x10
	ifaddr = net_if_ipv6_addr_lookup(&addr, NULL);
40018c30:	00050d13          	mv	s10,a0
		if (prefix_info->valid_lifetime ==
40018c34:	00e7e7b3          	or	a5,a5,a4
40018c38:	01869693          	slli	a3,a3,0x18
	if (ifaddr && ifaddr->addr_type == NET_ADDR_AUTOCONF) {
40018c3c:	10050063          	beqz	a0,40018d3c <handle_ra_input+0x848>
40018c40:	02c54503          	lbu	a0,44(a0)
40018c44:	00100593          	li	a1,1
40018c48:	0eb51a63          	bne	a0,a1,40018d3c <handle_ra_input+0x848>
		if (prefix_info->valid_lifetime ==
40018c4c:	00f6ecb3          	or	s9,a3,a5
40018c50:	fff00793          	li	a5,-1
40018c54:	08fc9263          	bne	s9,a5,40018cd8 <handle_ra_input+0x7e4>
	ifaddr->is_infinite = is_infinite;
40018c58:	02fd4783          	lbu	a5,47(s10)
40018c5c:	0017e793          	ori	a5,a5,1
40018c60:	02fd07a3          	sb	a5,47(s10)
}
40018c64:	cd5ff06f          	j	40018938 <handle_ra_input+0x444>
	prefix->is_infinite = is_infinite;
40018c68:	0017e793          	ori	a5,a5,1
40018c6c:	02f502a3          	sb	a5,37(a0)
}
40018c70:	efdff06f          	j	40018b6c <handle_ra_input+0x678>
		memcpy(&addr->s6_addr[8], lladdr->addr, 3);
40018c74:	010ca583          	lw	a1,16(s9)
40018c78:	00300613          	li	a2,3
40018c7c:	04810513          	addi	a0,sp,72
40018c80:	bccf00ef          	jal	ra,4000904c <memcpy>
		addr->s6_addr[11] = 0xff;
40018c84:	fff00793          	li	a5,-1
40018c88:	04f105a3          	sb	a5,75(sp)
		addr->s6_addr[12] = 0xfe;
40018c8c:	ffe00793          	li	a5,-2
40018c90:	04f10623          	sb	a5,76(sp)
		memcpy(&addr->s6_addr[13], lladdr->addr + 3, 3);
40018c94:	010ca583          	lw	a1,16(s9)
40018c98:	00300613          	li	a2,3
40018c9c:	04d10513          	addi	a0,sp,77
40018ca0:	00358593          	addi	a1,a1,3
40018ca4:	ba8f00ef          	jal	ra,4000904c <memcpy>
		if (lladdr->type == NET_LINK_ETHERNET) {
40018ca8:	015cc703          	lbu	a4,21(s9)
40018cac:	00300793          	li	a5,3
40018cb0:	f4f714e3          	bne	a4,a5,40018bf8 <handle_ra_input+0x704>
		addr->s6_addr[8] ^= 0x02;
40018cb4:	04814783          	lbu	a5,72(sp)
40018cb8:	0027c793          	xori	a5,a5,2
40018cbc:	04f10423          	sb	a5,72(sp)
		break;
40018cc0:	f39ff06f          	j	40018bf8 <handle_ra_input+0x704>
		memcpy(&addr->s6_addr[8], lladdr->addr, lladdr->len);
40018cc4:	010ca583          	lw	a1,16(s9)
40018cc8:	00800613          	li	a2,8
40018ccc:	04810513          	addi	a0,sp,72
40018cd0:	b7cf00ef          	jal	ra,4000904c <memcpy>
40018cd4:	fe1ff06f          	j	40018cb4 <handle_ra_input+0x7c0>
		if ((prefix_info->valid_lifetime > TWO_HOURS) ||
40018cd8:	00002db7          	lui	s11,0x2
40018cdc:	c20d8d93          	addi	s11,s11,-992 # 1c20 <CONFIG_HEAP_MEM_POOL_SIZE+0xc20>
40018ce0:	059df063          	bgeu	s11,s9,40018d20 <handle_ra_input+0x82c>
			net_if_ipv6_addr_update_lifetime(
40018ce4:	0034c703          	lbu	a4,3(s1)
40018ce8:	0024c783          	lbu	a5,2(s1)
40018cec:	0054c583          	lbu	a1,5(s1)
40018cf0:	00871713          	slli	a4,a4,0x8
40018cf4:	00f76733          	or	a4,a4,a5
40018cf8:	0044c783          	lbu	a5,4(s1)
40018cfc:	01859593          	slli	a1,a1,0x18
40018d00:	01079793          	slli	a5,a5,0x10
40018d04:	00e7e7b3          	or	a5,a5,a4
40018d08:	00f5e5b3          	or	a1,a1,a5
			net_if_ipv6_addr_update_lifetime(ifaddr, TWO_HOURS);
40018d0c:	000d0513          	mv	a0,s10
40018d10:	d40f40ef          	jal	ra,4000d250 <net_if_ipv6_addr_update_lifetime>
	ifaddr->is_infinite = is_infinite;
40018d14:	02fd4783          	lbu	a5,47(s10)
40018d18:	ffe7f793          	andi	a5,a5,-2
40018d1c:	f45ff06f          	j	40018c60 <handle_ra_input+0x76c>
	return (uint32_t)k_uptime_get();
40018d20:	e18fe0ef          	jal	ra,40017338 <k_uptime_get>
40018d24:	00050593          	mv	a1,a0
	return net_timeout_remaining(&ifaddr->lifetime, k_uptime_get_32());
40018d28:	014d0513          	addi	a0,s10,20
40018d2c:	de9f60ef          	jal	ra,4000fb14 <net_timeout_remaining>
		if ((prefix_info->valid_lifetime > TWO_HOURS) ||
40018d30:	fb956ae3          	bltu	a0,s9,40018ce4 <handle_ra_input+0x7f0>
			net_if_ipv6_addr_update_lifetime(ifaddr, TWO_HOURS);
40018d34:	000d8593          	mv	a1,s11
40018d38:	fd5ff06f          	j	40018d0c <handle_ra_input+0x818>
		if (prefix_info->valid_lifetime ==
40018d3c:	00f6e6b3          	or	a3,a3,a5
40018d40:	fff00793          	li	a5,-1
40018d44:	01842503          	lw	a0,24(s0)
40018d48:	00f69463          	bne	a3,a5,40018d50 <handle_ra_input+0x85c>
			net_if_ipv6_addr_add(net_pkt_iface(pkt),
40018d4c:	00000693          	li	a3,0
			net_if_ipv6_addr_add(net_pkt_iface(pkt),
40018d50:	00100613          	li	a2,1
40018d54:	04010593          	addi	a1,sp,64
40018d58:	d74f40ef          	jal	ra,4000d2cc <net_if_ipv6_addr_add>
40018d5c:	bddff06f          	j	40018938 <handle_ra_input+0x444>
			if (nd_opt_hdr->len == 0U || nd_opt_hdr->len > 3U) {
40018d60:	fff48493          	addi	s1,s1,-1
40018d64:	0ff4f493          	zext.b	s1,s1
40018d68:	00200793          	li	a5,2
40018d6c:	8097e2e3          	bltu	a5,s1,40018570 <handle_ra_input+0x7c>
	NET_PKT_DATA_ACCESS_DEFINE(routeinfo_access,
40018d70:	00600793          	li	a5,6
				net_pkt_get_data(pkt, &routeinfo_access);
40018d74:	04010593          	addi	a1,sp,64
40018d78:	00040513          	mv	a0,s0
	NET_PKT_DATA_ACCESS_DEFINE(routeinfo_access,
40018d7c:	05512023          	sw	s5,64(sp)
40018d80:	04f12223          	sw	a5,68(sp)
	struct in6_addr prefix_buf = { 0 };
40018d84:	04012823          	sw	zero,80(sp)
40018d88:	04012a23          	sw	zero,84(sp)
40018d8c:	04012c23          	sw	zero,88(sp)
40018d90:	04012e23          	sw	zero,92(sp)
				net_pkt_get_data(pkt, &routeinfo_access);
40018d94:	9e8fb0ef          	jal	ra,40013f7c <net_pkt_get_data>
40018d98:	00050d13          	mv	s10,a0
	if (!route_info) {
40018d9c:	fc050a63          	beqz	a0,40018570 <handle_ra_input+0x7c>
	ret = net_pkt_acknowledge_data(pkt, &routeinfo_access);
40018da0:	04412583          	lw	a1,68(sp)
40018da4:	00040513          	mv	a0,s0
40018da8:	a09fe0ef          	jal	ra,400177b0 <net_pkt_acknowledge_data.isra.0>
	if (ret < 0) {
40018dac:	fc054263          	bltz	a0,40018570 <handle_ra_input+0x7c>
	route_lifetime = ntohl(route_info->route_lifetime);
40018db0:	003d4703          	lbu	a4,3(s10)
40018db4:	002d4783          	lbu	a5,2(s10)
40018db8:	005d4c83          	lbu	s9,5(s10)
40018dbc:	00871713          	slli	a4,a4,0x8
40018dc0:	00f76733          	or	a4,a4,a5
40018dc4:	004d4783          	lbu	a5,4(s10)
40018dc8:	018c9c93          	slli	s9,s9,0x18
	uint8_t prefix_field_len = (len - 1) * 8;
40018dcc:	00349493          	slli	s1,s1,0x3
	route_lifetime = ntohl(route_info->route_lifetime);
40018dd0:	01079793          	slli	a5,a5,0x10
40018dd4:	00e7e7b3          	or	a5,a5,a4
40018dd8:	00fcecb3          	or	s9,s9,a5
	preference = route_info->flags.prf;
40018ddc:	001d4783          	lbu	a5,1(s10)
	ret = net_pkt_read(pkt, &prefix_buf, prefix_field_len);
40018de0:	0f84f613          	andi	a2,s1,248
40018de4:	05010593          	addi	a1,sp,80
	preference = route_info->flags.prf;
40018de8:	0037d793          	srli	a5,a5,0x3
40018dec:	0037f793          	andi	a5,a5,3
	ret = net_pkt_read(pkt, &prefix_buf, prefix_field_len);
40018df0:	00040513          	mv	a0,s0
	prefix_len = route_info->prefix_len;
40018df4:	000d4d83          	lbu	s11,0(s10)
	preference = route_info->flags.prf;
40018df8:	00f12423          	sw	a5,8(sp)
	ret = net_pkt_read(pkt, &prefix_buf, prefix_field_len);
40018dfc:	bd1fa0ef          	jal	ra,400139cc <net_pkt_read>
	if (ret < 0) {
40018e00:	f6054863          	bltz	a0,40018570 <handle_ra_input+0x7c>
	route_lifetime = ntohl(route_info->route_lifetime);
40018e04:	018c9693          	slli	a3,s9,0x18
40018e08:	018cd713          	srli	a4,s9,0x18
40018e0c:	00010637          	lui	a2,0x10
40018e10:	00d76733          	or	a4,a4,a3
40018e14:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
40018e18:	008cd693          	srli	a3,s9,0x8
40018e1c:	00c6f6b3          	and	a3,a3,a2
40018e20:	00d76733          	or	a4,a4,a3
40018e24:	008c9c93          	slli	s9,s9,0x8
40018e28:	00ff06b7          	lui	a3,0xff0
40018e2c:	00dcfcb3          	and	s9,s9,a3
40018e30:	01976733          	or	a4,a4,s9
	return pkt->iface;
40018e34:	01842503          	lw	a0,24(s0)
	if (route_lifetime == 0) {
40018e38:	00812783          	lw	a5,8(sp)
40018e3c:	00071c63          	bnez	a4,40018e54 <handle_ra_input+0x960>
		route = net_route_lookup(net_pkt_orig_iface(pkt), &prefix_buf);
40018e40:	05010593          	addi	a1,sp,80
40018e44:	2e0010ef          	jal	ra,4001a124 <net_route_lookup>
		if (route != NULL) {
40018e48:	ae0508e3          	beqz	a0,40018938 <handle_ra_input+0x444>
			ret = net_route_del(route);
40018e4c:	534010ef          	jal	ra,4001a380 <net_route_del>
			if (ret < 0) {
40018e50:	ae9ff06f          	j	40018938 <handle_ra_input+0x444>
	return pkt->frags->data;
40018e54:	00842683          	lw	a3,8(s0)
		route = net_route_add(net_pkt_orig_iface(pkt),
40018e58:	000d8613          	mv	a2,s11
40018e5c:	05010593          	addi	a1,sp,80
				      (struct in6_addr *)NET_IPV6_HDR(pkt)->src,
40018e60:	00c6a683          	lw	a3,12(a3) # ff000c <__rom_region_size+0xfbf630>
		route = net_route_add(net_pkt_orig_iface(pkt),
40018e64:	00868693          	addi	a3,a3,8
40018e68:	03d010ef          	jal	ra,4001a6a4 <net_route_add>
		if (route == NULL) {
40018e6c:	acdff06f          	j	40018938 <handle_ra_input+0x444>
			if (nbr) {
40018e70:	02091263          	bnez	s2,40018e94 <handle_ra_input+0x9a0>
			net_if_ipv6_router_update_lifetime(
40018e74:	00060593          	mv	a1,a2
40018e78:	fccf50ef          	jal	ra,4000e644 <net_if_ipv6_router_update_lifetime>
	net_if_stop_rs(net_pkt_iface(pkt));
40018e7c:	01842503          	lw	a0,24(s0)
40018e80:	858f40ef          	jal	ra,4000ced8 <net_if_stop_rs>
	net_pkt_unref(pkt);
40018e84:	00040513          	mv	a0,s0
40018e88:	894fa0ef          	jal	ra,40012f1c <net_pkt_unref>
	return NET_OK;
40018e8c:	00000513          	li	a0,0
40018e90:	ee4ff06f          	j	40018574 <handle_ra_input+0x80>
40018e94:	00c92783          	lw	a5,12(s2)
				net_ipv6_nbr_data(nbr)->is_router = true;
40018e98:	00100713          	li	a4,1
			net_if_ipv6_router_update_lifetime(
40018e9c:	00060593          	mv	a1,a2
				net_ipv6_nbr_data(nbr)->is_router = true;
40018ea0:	02e78ba3          	sb	a4,55(a5)
			net_if_ipv6_router_update_lifetime(
40018ea4:	fa0f50ef          	jal	ra,4000e644 <net_if_ipv6_router_update_lifetime>
	if (nbr && net_ipv6_nbr_data(nbr)->pending) {
40018ea8:	00c92783          	lw	a5,12(s2)
40018eac:	0007a503          	lw	a0,0(a5)
40018eb0:	fc0506e3          	beqz	a0,40018e7c <handle_ra_input+0x988>
		if (net_send_data(net_ipv6_nbr_data(nbr)->pending) < 0) {
40018eb4:	815f20ef          	jal	ra,4000b6c8 <net_send_data>
40018eb8:	00055863          	bgez	a0,40018ec8 <handle_ra_input+0x9d4>
			net_pkt_unref(net_ipv6_nbr_data(nbr)->pending);
40018ebc:	00c92783          	lw	a5,12(s2)
40018ec0:	0007a503          	lw	a0,0(a5)
40018ec4:	858fa0ef          	jal	ra,40012f1c <net_pkt_unref>
		nbr_clear_ns_pending(net_ipv6_nbr_data(nbr));
40018ec8:	00c92503          	lw	a0,12(s2)
40018ecc:	bd8fe0ef          	jal	ra,400172a4 <nbr_clear_ns_pending>
40018ed0:	fadff06f          	j	40018e7c <handle_ra_input+0x988>
		net_if_ipv6_router_add(net_pkt_iface(pkt),
40018ed4:	01842503          	lw	a0,24(s0)
40018ed8:	fa4f50ef          	jal	ra,4000e67c <net_if_ipv6_router_add>
40018edc:	915ff06f          	j	400187f0 <handle_ra_input+0x2fc>

40018ee0 <handle_ns_input>:
{
40018ee0:	f9010113          	addi	sp,sp,-112
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
40018ee4:	01400793          	li	a5,20
40018ee8:	00f12a23          	sw	a5,20(sp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
40018eec:	00c10793          	addi	a5,sp,12
{
40018ef0:	06812423          	sw	s0,104(sp)
40018ef4:	06912223          	sw	s1,100(sp)
40018ef8:	07212023          	sw	s2,96(sp)
40018efc:	05312e23          	sw	s3,92(sp)
40018f00:	06112623          	sw	ra,108(sp)
40018f04:	05412c23          	sw	s4,88(sp)
40018f08:	05512a23          	sw	s5,84(sp)
40018f0c:	05612823          	sw	s6,80(sp)
40018f10:	05712623          	sw	s7,76(sp)
	NET_PKT_DATA_ACCESS_DEFINE(nd_access, struct net_icmpv6_nd_opt_hdr);
40018f14:	00f12c23          	sw	a5,24(sp)
40018f18:	00200793          	li	a5,2
40018f1c:	00f12e23          	sw	a5,28(sp)
40018f20:	00852783          	lw	a5,8(a0)
{
40018f24:	00050493          	mv	s1,a0
40018f28:	00058413          	mv	s0,a1
40018f2c:	00060993          	mv	s3,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ns_access,
40018f30:	00012823          	sw	zero,16(sp)
	size_t bytes = 0;
40018f34:	00000913          	li	s2,0
	while (buf) {
40018f38:	1c079a63          	bnez	a5,4001910c <handle_ns_input+0x22c>
	if (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {
40018f3c:	0184a503          	lw	a0,24(s1)
40018f40:	00b00593          	li	a1,11
	src_lladdr.len = 0;
40018f44:	02010623          	sb	zero,44(sp)
	if (net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {
40018f48:	829fe0ef          	jal	ra,40017770 <net_if_flag_is_set>
40018f4c:	18051863          	bnez	a0,400190dc <handle_ns_input+0x1fc>
	ns_hdr = (struct net_icmpv6_ns_hdr *)net_pkt_get_data(pkt, &ns_access);
40018f50:	01010593          	addi	a1,sp,16
40018f54:	00048513          	mv	a0,s1
40018f58:	824fb0ef          	jal	ra,40013f7c <net_pkt_get_data>
40018f5c:	00050a13          	mv	s4,a0
	if (!ns_hdr) {
40018f60:	16050e63          	beqz	a0,400190dc <handle_ns_input+0x1fc>
	uint16_t length = net_pkt_get_len(pkt);
40018f64:	01091913          	slli	s2,s2,0x10
40018f68:	01095913          	srli	s2,s2,0x10
	if (((length < (sizeof(struct net_ipv6_hdr) +
40018f6c:	03f00793          	li	a5,63
40018f70:	0127f863          	bgeu	a5,s2,40018f80 <handle_ns_input+0xa0>
			  sizeof(struct net_icmpv6_ns_hdr))) ||
40018f74:	00744703          	lbu	a4,7(s0)
40018f78:	0ff00793          	li	a5,255
40018f7c:	00f70c63          	beq	a4,a5,40018f94 <handle_ns_input+0xb4>
	    (ip_hdr->hop_limit != NET_IPV6_ND_HOP_LIMIT)) &&
40018f80:	004a4703          	lbu	a4,4(s4)
40018f84:	0ff00793          	li	a5,255
40018f88:	00f71663          	bne	a4,a5,40018f94 <handle_ns_input+0xb4>
	    (net_ipv6_is_addr_mcast((struct in6_addr *)ns_hdr->tgt) &&
40018f8c:	0019c783          	lbu	a5,1(s3)
40018f90:	14079663          	bnez	a5,400190dc <handle_ns_input+0x1fc>
	net_pkt_acknowledge_data(pkt, &ns_access);
40018f94:	01412583          	lw	a1,20(sp)
40018f98:	00048513          	mv	a0,s1
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
40018f9c:	fd490913          	addi	s2,s2,-44
	net_pkt_acknowledge_data(pkt, &ns_access);
40018fa0:	811fe0ef          	jal	ra,400177b0 <net_pkt_acknowledge_data.isra.0>
	pkt->ipv6_ext_opt_len = len;
40018fa4:	01400793          	li	a5,20
40018fa8:	02f48f23          	sb	a5,62(s1)
				net_pkt_get_data(pkt, &nd_access);
40018fac:	01810593          	addi	a1,sp,24
40018fb0:	00048513          	mv	a0,s1
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
40018fb4:	01091913          	slli	s2,s2,0x10
				net_pkt_get_data(pkt, &nd_access);
40018fb8:	fc5fa0ef          	jal	ra,40013f7c <net_pkt_get_data>
	length -= (sizeof(struct net_ipv6_hdr) + sizeof(struct net_icmp_hdr));
40018fbc:	01095913          	srli	s2,s2,0x10
				net_pkt_get_data(pkt, &nd_access);
40018fc0:	00050993          	mv	s3,a0
		switch (nd_opt_hdr->type) {
40018fc4:	00100a93          	li	s5,1
					(struct in6_addr *)ip_hdr->src)) {
40018fc8:	00840b13          	addi	s6,s0,8
			src_lladdr.addr = src_lladdr_s.addr;
40018fcc:	02210b93          	addi	s7,sp,34
	while (nd_opt_hdr && nd_opt_hdr->len > 0 &&
40018fd0:	00098a63          	beqz	s3,40018fe4 <handle_ns_input+0x104>
40018fd4:	0019c783          	lbu	a5,1(s3)
40018fd8:	00078663          	beqz	a5,40018fe4 <handle_ns_input+0x104>
40018fdc:	03e4c783          	lbu	a5,62(s1)
40018fe0:	1327ee63          	bltu	a5,s2,4001911c <handle_ns_input+0x23c>
		ifaddr = net_if_ipv6_addr_lookup_by_iface(
40018fe4:	0184a503          	lw	a0,24(s1)
			    net_pkt_iface(pkt), (struct in6_addr *)ns_hdr->tgt);
40018fe8:	004a0a13          	addi	s4,s4,4
		ifaddr = net_if_ipv6_addr_lookup_by_iface(
40018fec:	000a0593          	mv	a1,s4
40018ff0:	990f40ef          	jal	ra,4000d180 <net_if_ipv6_addr_lookup_by_iface>
40018ff4:	00050a93          	mv	s5,a0
	if (!ifaddr) {
40018ff8:	0e050263          	beqz	a0,400190dc <handle_ns_input+0x1fc>
	if (net_ipv6_is_addr_unspecified((struct in6_addr *)ip_hdr->src)) {
40018ffc:	00840993          	addi	s3,s0,8
		tgt = &ifaddr->address.in6_addr;
40019000:	00450913          	addi	s2,a0,4
	if (net_ipv6_is_addr_unspecified((struct in6_addr *)ip_hdr->src)) {
40019004:	00098513          	mv	a0,s3
		na_src = (struct in6_addr *)ip_hdr->dst;
40019008:	01840b13          	addi	s6,s0,24
	if (net_ipv6_is_addr_unspecified((struct in6_addr *)ip_hdr->src)) {
4001900c:	960fe0ef          	jal	ra,4001716c <net_ipv6_is_addr_unspecified>
40019010:	22050a63          	beqz	a0,40019244 <handle_ns_input+0x364>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
40019014:	01944783          	lbu	a5,25(s0)
40019018:	01844703          	lbu	a4,24(s0)
4001901c:	00879793          	slli	a5,a5,0x8
40019020:	00e7e7b3          	or	a5,a5,a4
40019024:	01a44703          	lbu	a4,26(s0)
40019028:	01071713          	slli	a4,a4,0x10
4001902c:	00f76733          	or	a4,a4,a5
40019030:	01b44783          	lbu	a5,27(s0)
40019034:	01879793          	slli	a5,a5,0x18
40019038:	00e7e7b3          	or	a5,a5,a4
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
4001903c:	2ff00713          	li	a4,767
40019040:	08e79e63          	bne	a5,a4,400190dc <handle_ns_input+0x1fc>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
40019044:	01d44783          	lbu	a5,29(s0)
40019048:	01c44703          	lbu	a4,28(s0)
4001904c:	00879793          	slli	a5,a5,0x8
40019050:	00e7e7b3          	or	a5,a5,a4
40019054:	01e44703          	lbu	a4,30(s0)
40019058:	01071713          	slli	a4,a4,0x10
4001905c:	00f76733          	or	a4,a4,a5
40019060:	01f44783          	lbu	a5,31(s0)
40019064:	01879793          	slli	a5,a5,0x18
40019068:	00e7e7b3          	or	a5,a5,a4
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
4001906c:	06079863          	bnez	a5,400190dc <handle_ns_input+0x1fc>
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
40019070:	02144783          	lbu	a5,33(s0)
40019074:	02044703          	lbu	a4,32(s0)
40019078:	00879793          	slli	a5,a5,0x8
4001907c:	00e7e7b3          	or	a5,a5,a4
40019080:	02244703          	lbu	a4,34(s0)
40019084:	01071713          	slli	a4,a4,0x10
40019088:	00f76733          	or	a4,a4,a5
4001908c:	02344783          	lbu	a5,35(s0)
40019090:	01879793          	slli	a5,a5,0x18
40019094:	00e7e7b3          	or	a5,a5,a4
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
40019098:	01000737          	lui	a4,0x1000
4001909c:	04e79063          	bne	a5,a4,400190dc <handle_ns_input+0x1fc>
		((UNALIGNED_GET(&addr->s6_addr32[3]) & htonl(0xff000000)) ==
400190a0:	02444703          	lbu	a4,36(s0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
400190a4:	0ff00793          	li	a5,255
400190a8:	02f71a63          	bne	a4,a5,400190dc <handle_ns_input+0x1fc>
		if (ifaddr->addr_state == NET_ADDR_TENTATIVE) {
400190ac:	02da8783          	lb	a5,45(s5)
400190b0:	0c079e63          	bnez	a5,4001918c <handle_ns_input+0x2ac>
	return UNALIGNED_GET(&addr->s6_addr16[0]) == htons(0xFE80);
400190b4:	005ac783          	lbu	a5,5(s5)
400190b8:	004ac703          	lbu	a4,4(s5)
	return pkt->iface;
400190bc:	0184a503          	lw	a0,24(s1)
400190c0:	00879793          	slli	a5,a5,0x8
	if (net_ipv6_is_ll_addr(addr)) {
400190c4:	00e7e7b3          	or	a5,a5,a4
400190c8:	00008737          	lui	a4,0x8
400190cc:	0fe70713          	addi	a4,a4,254 # 80fe <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x40fe>
400190d0:	00e78663          	beq	a5,a4,400190dc <handle_ns_input+0x1fc>
	net_if_ipv6_dad_failed(iface, addr);
400190d4:	00090593          	mv	a1,s2
400190d8:	a0df40ef          	jal	ra,4000dae4 <net_if_ipv6_dad_failed>
	return NET_DROP;
400190dc:	00200513          	li	a0,2
}
400190e0:	06c12083          	lw	ra,108(sp)
400190e4:	06812403          	lw	s0,104(sp)
400190e8:	06412483          	lw	s1,100(sp)
400190ec:	06012903          	lw	s2,96(sp)
400190f0:	05c12983          	lw	s3,92(sp)
400190f4:	05812a03          	lw	s4,88(sp)
400190f8:	05412a83          	lw	s5,84(sp)
400190fc:	05012b03          	lw	s6,80(sp)
40019100:	04c12b83          	lw	s7,76(sp)
40019104:	07010113          	addi	sp,sp,112
40019108:	00008067          	ret
		bytes += buf->len;
4001910c:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
40019110:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
40019114:	00e90933          	add	s2,s2,a4
		buf = buf->frags;
40019118:	e21ff06f          	j	40018f38 <handle_ns_input+0x58>
		net_pkt_acknowledge_data(pkt, &nd_access);
4001911c:	01c12583          	lw	a1,28(sp)
40019120:	00048513          	mv	a0,s1
40019124:	e8cfe0ef          	jal	ra,400177b0 <net_pkt_acknowledge_data.isra.0>
		switch (nd_opt_hdr->type) {
40019128:	0009c783          	lbu	a5,0(s3)
4001912c:	03579863          	bne	a5,s5,4001915c <handle_ns_input+0x27c>
			if (net_ipv6_is_addr_unspecified(
40019130:	000b0513          	mv	a0,s6
40019134:	838fe0ef          	jal	ra,4001716c <net_ipv6_is_addr_unspecified>
40019138:	fa0512e3          	bnez	a0,400190dc <handle_ns_input+0x1fc>
			if (!read_llao(pkt, nd_opt_hdr->len, &src_lladdr_s)) {
4001913c:	0019c583          	lbu	a1,1(s3)
40019140:	02010613          	addi	a2,sp,32
40019144:	00048513          	mv	a0,s1
40019148:	bd0fe0ef          	jal	ra,40017518 <read_llao>
4001914c:	f80508e3          	beqz	a0,400190dc <handle_ns_input+0x1fc>
			src_lladdr.len = src_lladdr_s.len;
40019150:	02114783          	lbu	a5,33(sp)
			src_lladdr.addr = src_lladdr_s.addr;
40019154:	03712423          	sw	s7,40(sp)
			src_lladdr.len = src_lladdr_s.len;
40019158:	02f10623          	sb	a5,44(sp)
					     (nd_opt_hdr->len << 3));
4001915c:	0019c783          	lbu	a5,1(s3)
	return pkt->ipv6_ext_opt_len;
40019160:	03e4c703          	lbu	a4,62(s1)
40019164:	00379793          	slli	a5,a5,0x3
		net_pkt_set_ipv6_ext_opt_len(pkt,
40019168:	00f707b3          	add	a5,a4,a5
4001916c:	0ff7f793          	zext.b	a5,a5
	pkt->ipv6_ext_opt_len = len;
40019170:	02f48f23          	sb	a5,62(s1)
		if (prev_opt_len >= net_pkt_ipv6_ext_opt_len(pkt)) {
40019174:	f6f774e3          	bgeu	a4,a5,400190dc <handle_ns_input+0x1fc>
					net_pkt_get_data(pkt, &nd_access);
40019178:	01810593          	addi	a1,sp,24
4001917c:	00048513          	mv	a0,s1
40019180:	dfdfa0ef          	jal	ra,40013f7c <net_pkt_get_data>
40019184:	00050993          	mv	s3,a0
40019188:	e49ff06f          	j	40018fd0 <handle_ns_input+0xf0>
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
4001918c:	fff00793          	li	a5,-1
40019190:	00f40c23          	sb	a5,24(s0)
40019194:	00200793          	li	a5,2
40019198:	00f40ca3          	sb	a5,25(s0)
	UNALIGNED_PUT(htons(addr7), &addr->s6_addr16[7]);
4001919c:	00100793          	li	a5,1
400191a0:	02f403a3          	sb	a5,39(s0)
	UNALIGNED_PUT(htons(addr1), &addr->s6_addr16[1]);
400191a4:	00040d23          	sb	zero,26(s0)
400191a8:	00040da3          	sb	zero,27(s0)
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
400191ac:	00040e23          	sb	zero,28(s0)
400191b0:	00040ea3          	sb	zero,29(s0)
	UNALIGNED_PUT(htons(addr3), &addr->s6_addr16[3]);
400191b4:	00040f23          	sb	zero,30(s0)
400191b8:	00040fa3          	sb	zero,31(s0)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
400191bc:	02040023          	sb	zero,32(s0)
400191c0:	020400a3          	sb	zero,33(s0)
	UNALIGNED_PUT(htons(addr5), &addr->s6_addr16[5]);
400191c4:	02040123          	sb	zero,34(s0)
400191c8:	020401a3          	sb	zero,35(s0)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
400191cc:	02040223          	sb	zero,36(s0)
400191d0:	020402a3          	sb	zero,37(s0)
	UNALIGNED_PUT(htons(addr7), &addr->s6_addr16[7]);
400191d4:	02040323          	sb	zero,38(s0)
		net_ipaddr_copy((struct in6_addr *)ip_hdr->src,
400191d8:	0184a503          	lw	a0,24(s1)
400191dc:	000b0593          	mv	a1,s6
		na_src = (struct in6_addr *)ip_hdr->src;
400191e0:	00098a13          	mv	s4,s3
		net_ipaddr_copy((struct in6_addr *)ip_hdr->src,
400191e4:	e00f50ef          	jal	ra,4000e7e4 <net_if_ipv6_select_src_addr>
400191e8:	00050593          	mv	a1,a0
400191ec:	01000613          	li	a2,16
400191f0:	03010513          	addi	a0,sp,48
400191f4:	e59ef0ef          	jal	ra,4000904c <memcpy>
400191f8:	01000613          	li	a2,16
400191fc:	03010593          	addi	a1,sp,48
40019200:	00098513          	mv	a0,s3
40019204:	e49ef0ef          	jal	ra,4000904c <memcpy>
		flags = NET_ICMPV6_NA_FLAG_OVERRIDE;
40019208:	02000413          	li	s0,32
	if (src_lladdr.len) {
4001920c:	02c14783          	lbu	a5,44(sp)
	return pkt->iface;
40019210:	0184a503          	lw	a0,24(s1)
40019214:	0e079c63          	bnez	a5,4001930c <handle_ns_input+0x42c>
	if (!net_ipv6_send_na(net_pkt_iface(pkt), na_src,
40019218:	0184a503          	lw	a0,24(s1)
4001921c:	00040713          	mv	a4,s0
40019220:	00090693          	mv	a3,s2
40019224:	000b0613          	mv	a2,s6
40019228:	000a0593          	mv	a1,s4
4001922c:	98dfe0ef          	jal	ra,40017bb8 <net_ipv6_send_na>
40019230:	ea0516e3          	bnez	a0,400190dc <handle_ns_input+0x1fc>
		net_pkt_unref(pkt);
40019234:	00048513          	mv	a0,s1
40019238:	ce5f90ef          	jal	ra,40012f1c <net_pkt_unref>
		return NET_OK;
4001923c:	00000513          	li	a0,0
40019240:	ea1ff06f          	j	400190e0 <handle_ns_input+0x200>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
40019244:	00000593          	li	a1,0
40019248:	00098513          	mv	a0,s3
4001924c:	cd1f30ef          	jal	ra,4000cf1c <net_if_ipv6_addr_lookup>
	if (net_ipv6_is_my_addr((struct in6_addr *)ip_hdr->src)) {
40019250:	e80516e3          	bnez	a0,400190dc <handle_ns_input+0x1fc>
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
40019254:	01944783          	lbu	a5,25(s0)
40019258:	01844703          	lbu	a4,24(s0)
4001925c:	00879793          	slli	a5,a5,0x8
40019260:	00e7e7b3          	or	a5,a5,a4
40019264:	01a44703          	lbu	a4,26(s0)
40019268:	01071713          	slli	a4,a4,0x10
4001926c:	00f76733          	or	a4,a4,a5
40019270:	01b44783          	lbu	a5,27(s0)
40019274:	01879793          	slli	a5,a5,0x18
40019278:	00e7e7b3          	or	a5,a5,a4
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
4001927c:	2ff00713          	li	a4,767
40019280:	06e79663          	bne	a5,a4,400192ec <handle_ns_input+0x40c>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
40019284:	01d44783          	lbu	a5,29(s0)
40019288:	01c44703          	lbu	a4,28(s0)
4001928c:	00879793          	slli	a5,a5,0x8
40019290:	00e7e7b3          	or	a5,a5,a4
40019294:	01e44703          	lbu	a4,30(s0)
40019298:	01071713          	slli	a4,a4,0x10
4001929c:	00f76733          	or	a4,a4,a5
400192a0:	01f44783          	lbu	a5,31(s0)
400192a4:	01879793          	slli	a5,a5,0x18
400192a8:	00e7e7b3          	or	a5,a5,a4
	return UNALIGNED_GET(&addr->s6_addr32[0]) == htonl(0xff020000) &&
400192ac:	04079063          	bnez	a5,400192ec <handle_ns_input+0x40c>
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
400192b0:	02144783          	lbu	a5,33(s0)
400192b4:	02044703          	lbu	a4,32(s0)
400192b8:	00879793          	slli	a5,a5,0x8
400192bc:	00e7e7b3          	or	a5,a5,a4
400192c0:	02244703          	lbu	a4,34(s0)
400192c4:	01071713          	slli	a4,a4,0x10
400192c8:	00f76733          	or	a4,a4,a5
400192cc:	02344783          	lbu	a5,35(s0)
400192d0:	01879793          	slli	a5,a5,0x18
400192d4:	00e7e7b3          	or	a5,a5,a4
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0x00000000 &&
400192d8:	01000737          	lui	a4,0x1000
400192dc:	00e79863          	bne	a5,a4,400192ec <handle_ns_input+0x40c>
		((UNALIGNED_GET(&addr->s6_addr32[3]) & htonl(0xff000000)) ==
400192e0:	02444703          	lbu	a4,36(s0)
		UNALIGNED_GET(&addr->s6_addr32[2]) == htonl(0x00000001) &&
400192e4:	0ff00793          	li	a5,255
400192e8:	00f70c63          	beq	a4,a5,40019300 <handle_ns_input+0x420>
		ifaddr = net_if_ipv6_addr_lookup_by_iface(
400192ec:	0184a503          	lw	a0,24(s1)
400192f0:	000b0593          	mv	a1,s6
400192f4:	e8df30ef          	jal	ra,4000d180 <net_if_ipv6_addr_lookup_by_iface>
	if (ifaddr) {
400192f8:	de0502e3          	beqz	a0,400190dc <handle_ns_input+0x1fc>
		tgt = &ifaddr->address.in6_addr;
400192fc:	00450913          	addi	s2,a0,4
		na_dst = (struct in6_addr *)ip_hdr->src;
40019300:	00098b13          	mv	s6,s3
		flags = NET_ICMPV6_NA_FLAG_SOLICITED |
40019304:	06000413          	li	s0,96
40019308:	f05ff06f          	j	4001920c <handle_ns_input+0x32c>
		if (!net_ipv6_nbr_add(net_pkt_iface(pkt),
4001930c:	00000713          	li	a4,0
40019310:	00000693          	li	a3,0
40019314:	02810613          	addi	a2,sp,40
40019318:	00098593          	mv	a1,s3
4001931c:	8c0ff0ef          	jal	ra,400183dc <net_ipv6_nbr_add>
40019320:	ee051ce3          	bnez	a0,40019218 <handle_ns_input+0x338>
40019324:	db9ff06f          	j	400190dc <handle_ns_input+0x1fc>

40019328 <net_ipv6_start_dad>:
	return net_ipv6_send_ns(iface, NULL, NULL, NULL,
40019328:	00458713          	addi	a4,a1,4
4001932c:	00100793          	li	a5,1
40019330:	00000693          	li	a3,0
40019334:	00000613          	li	a2,0
40019338:	00000593          	li	a1,0
4001933c:	df5fe06f          	j	40018130 <net_ipv6_send_ns>

40019340 <net_ipv6_prepare_for_send>:
{
40019340:	fd010113          	addi	sp,sp,-48
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
40019344:	02800793          	li	a5,40
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
40019348:	00810593          	addi	a1,sp,8
{
4001934c:	02812423          	sw	s0,40(sp)
40019350:	02112623          	sw	ra,44(sp)
40019354:	02912223          	sw	s1,36(sp)
40019358:	03212023          	sw	s2,32(sp)
4001935c:	01312e23          	sw	s3,28(sp)
40019360:	00050413          	mv	s0,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv6_access, struct net_ipv6_hdr);
40019364:	00012423          	sw	zero,8(sp)
40019368:	00f12623          	sw	a5,12(sp)
	struct net_if *iface = NULL;
4001936c:	00012223          	sw	zero,4(sp)
	ip_hdr = (struct net_ipv6_hdr *)net_pkt_get_data(pkt, &ipv6_access);
40019370:	c0dfa0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!ip_hdr) {
40019374:	14050063          	beqz	a0,400194b4 <net_ipv6_prepare_for_send+0x174>
	if ((net_pkt_lladdr_dst(pkt)->addr &&
40019378:	02c42783          	lw	a5,44(s0)
4001937c:	10079663          	bnez	a5,40019488 <net_ipv6_prepare_for_send+0x148>
	      !IS_ENABLED(CONFIG_NET_ROUTING))) ||
40019380:	01854703          	lbu	a4,24(a0)
40019384:	0ff00793          	li	a5,255
40019388:	00050993          	mv	s3,a0
4001938c:	0ef70e63          	beq	a4,a5,40019488 <net_ipv6_prepare_for_send+0x148>
	    net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_POINTOPOINT) ||
40019390:	01842503          	lw	a0,24(s0)
40019394:	00100593          	li	a1,1
40019398:	bd8fe0ef          	jal	ra,40017770 <net_if_flag_is_set>
	    net_ipv6_is_addr_mcast((struct in6_addr *)ip_hdr->dst) ||
4001939c:	0e051663          	bnez	a0,40019488 <net_ipv6_prepare_for_send+0x148>
	    net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_IPV6_NO_ND)) {
400193a0:	01842503          	lw	a0,24(s0)
400193a4:	00b00593          	li	a1,11
400193a8:	bc8fe0ef          	jal	ra,40017770 <net_if_flag_is_set>
	    net_if_flag_is_set(net_pkt_iface(pkt), NET_IF_POINTOPOINT) ||
400193ac:	0c051e63          	bnez	a0,40019488 <net_ipv6_prepare_for_send+0x148>
	if (net_if_ipv6_addr_onlink(&iface, (struct in6_addr *)ip_hdr->dst)) {
400193b0:	01898493          	addi	s1,s3,24
400193b4:	00048593          	mv	a1,s1
400193b8:	00410513          	addi	a0,sp,4
400193bc:	f4df40ef          	jal	ra,4000e308 <net_if_ipv6_addr_onlink>
400193c0:	0c050863          	beqz	a0,40019490 <net_ipv6_prepare_for_send+0x150>
		net_pkt_set_iface(pkt, iface);
400193c4:	00412783          	lw	a5,4(sp)
	pkt->iface = iface;
400193c8:	00f42c23          	sw	a5,24(s0)
	if (iface) {
400193cc:	00078e63          	beqz	a5,400193e8 <net_ipv6_prepare_for_send+0xa8>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
400193d0:	0007a703          	lw	a4,0(a5)
400193d4:	01574703          	lbu	a4,21(a4) # 1000015 <__rom_region_size+0xfcf639>
400193d8:	02e404a3          	sb	a4,41(s0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
400193dc:	0007a783          	lw	a5,0(a5)
400193e0:	0157c783          	lbu	a5,21(a5)
400193e4:	02f408a3          	sb	a5,49(s0)
	if (!iface) {
400193e8:	00412783          	lw	a5,4(sp)
400193ec:	02079c63          	bnez	a5,40019424 <net_ipv6_prepare_for_send+0xe4>
		if (net_if_ipv6_addr_onlink(&iface, nexthop)) {
400193f0:	00048593          	mv	a1,s1
400193f4:	00410513          	addi	a0,sp,4
400193f8:	f11f40ef          	jal	ra,4000e308 <net_if_ipv6_addr_onlink>
400193fc:	0e050663          	beqz	a0,400194e8 <net_ipv6_prepare_for_send+0x1a8>
			net_pkt_set_iface(pkt, iface);
40019400:	00412783          	lw	a5,4(sp)
	pkt->iface = iface;
40019404:	00f42c23          	sw	a5,24(s0)
	if (iface) {
40019408:	00078e63          	beqz	a5,40019424 <net_ipv6_prepare_for_send+0xe4>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
4001940c:	0007a703          	lw	a4,0(a5)
40019410:	01574703          	lbu	a4,21(a4)
40019414:	02e404a3          	sb	a4,41(s0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
40019418:	0007a783          	lw	a5,0(a5)
4001941c:	0157c783          	lbu	a5,21(a5)
40019420:	02f408a3          	sb	a5,49(s0)
	nbr = nbr_lookup(&net_neighbor.table, iface, nexthop);
40019424:	00412503          	lw	a0,4(sp)
40019428:	00048593          	mv	a1,s1
4001942c:	a98fe0ef          	jal	ra,400176c4 <nbr_lookup.constprop.0>
40019430:	00050913          	mv	s2,a0
	if (nbr && nbr->idx != NET_NBR_LLADDR_UNKNOWN) {
40019434:	0c050c63          	beqz	a0,4001950c <net_ipv6_prepare_for_send+0x1cc>
40019438:	00154503          	lbu	a0,1(a0)
4001943c:	0ff00793          	li	a5,255
40019440:	0cf50663          	beq	a0,a5,4001950c <net_ipv6_prepare_for_send+0x1cc>
		lladdr = net_nbr_get_lladdr(nbr->idx);
40019444:	ac4fd0ef          	jal	ra,40016708 <net_nbr_get_lladdr>
		net_pkt_lladdr_dst(pkt)->addr = lladdr->addr;
40019448:	00250793          	addi	a5,a0,2
4001944c:	02f42623          	sw	a5,44(s0)
		net_pkt_lladdr_dst(pkt)->len = lladdr->len;
40019450:	00154783          	lbu	a5,1(a0)
40019454:	02f40823          	sb	a5,48(s0)
		if (net_ipv6_nbr_data(nbr)->state == NET_IPV6_NBR_STATE_STALE) {
40019458:	00c92783          	lw	a5,12(s2)
4001945c:	0307a703          	lw	a4,48(a5)
40019460:	00200793          	li	a5,2
40019464:	02f71263          	bne	a4,a5,40019488 <net_ipv6_prepare_for_send+0x148>
			ipv6_nbr_set_state(nbr, NET_IPV6_NBR_STATE_DELAY);
40019468:	00300593          	li	a1,3
4001946c:	00090513          	mv	a0,s2
40019470:	b68fe0ef          	jal	ra,400177d8 <ipv6_nbr_set_state>
			ipv6_nd_restart_reachable_timer(nbr,
40019474:	000015b7          	lui	a1,0x1
40019478:	38858593          	addi	a1,a1,904 # 1388 <CONFIG_HEAP_MEM_POOL_SIZE+0x388>
4001947c:	00000613          	li	a2,0
40019480:	00090513          	mv	a0,s2
40019484:	928fe0ef          	jal	ra,400175ac <ipv6_nd_restart_reachable_timer>
		return NET_OK;
40019488:	00000513          	li	a0,0
4001948c:	02c0006f          	j	400194b8 <net_ipv6_prepare_for_send+0x178>
	route = net_route_lookup(iface, dst);
40019490:	00048593          	mv	a1,s1
40019494:	491000ef          	jal	ra,4001a124 <net_route_lookup>
40019498:	00050913          	mv	s2,a0
	if (route) {
4001949c:	02050c63          	beqz	a0,400194d4 <net_ipv6_prepare_for_send+0x194>
		nexthop = net_route_get_nexthop(route);
400194a0:	194010ef          	jal	ra,4001a634 <net_route_get_nexthop>
400194a4:	00050493          	mv	s1,a0
		if (!nexthop) {
400194a8:	f40510e3          	bnez	a0,400193e8 <net_ipv6_prepare_for_send+0xa8>
			net_route_del(route);
400194ac:	00090513          	mv	a0,s2
400194b0:	6d1000ef          	jal	ra,4001a380 <net_route_del>
		return NET_DROP;
400194b4:	00200513          	li	a0,2
}
400194b8:	02c12083          	lw	ra,44(sp)
400194bc:	02812403          	lw	s0,40(sp)
400194c0:	02412483          	lw	s1,36(sp)
400194c4:	02012903          	lw	s2,32(sp)
400194c8:	01c12983          	lw	s3,28(sp)
400194cc:	03010113          	addi	sp,sp,48
400194d0:	00008067          	ret
		router = net_if_ipv6_router_find_default(NULL, dst);
400194d4:	00048593          	mv	a1,s1
400194d8:	964f50ef          	jal	ra,4000e63c <net_if_ipv6_router_find_default>
		if (!router) {
400194dc:	f40504e3          	beqz	a0,40019424 <net_ipv6_prepare_for_send+0xe4>
		nexthop = &router->address.in6_addr;
400194e0:	00850493          	addi	s1,a0,8
		if (!nexthop) {
400194e4:	f05ff06f          	j	400193e8 <net_ipv6_prepare_for_send+0xa8>
			nbr = net_ipv6_nbr_lookup(NULL, nexthop);
400194e8:	00048593          	mv	a1,s1
400194ec:	ec8fe0ef          	jal	ra,40017bb4 <net_ipv6_nbr_lookup>
			if (nbr) {
400194f0:	00050863          	beqz	a0,40019500 <net_ipv6_prepare_for_send+0x1c0>
				iface = nbr->iface;
400194f4:	00852783          	lw	a5,8(a0)
400194f8:	00f12223          	sw	a5,4(sp)
400194fc:	f09ff06f          	j	40019404 <net_ipv6_prepare_for_send+0xc4>
				iface = net_pkt_iface(pkt);
40019500:	01842783          	lw	a5,24(s0)
40019504:	00f12223          	sw	a5,4(sp)
40019508:	f1dff06f          	j	40019424 <net_ipv6_prepare_for_send+0xe4>
	ret = net_ipv6_send_ns(net_pkt_iface(pkt), pkt,
4001950c:	01842503          	lw	a0,24(s0)
40019510:	00000793          	li	a5,0
40019514:	00048713          	mv	a4,s1
40019518:	00000693          	li	a3,0
4001951c:	00898613          	addi	a2,s3,8
40019520:	00040593          	mv	a1,s0
40019524:	c0dfe0ef          	jal	ra,40018130 <net_ipv6_send_ns>
	return NET_CONTINUE;
40019528:	00100513          	li	a0,1
4001952c:	f8dff06f          	j	400194b8 <net_ipv6_prepare_for_send+0x178>

40019530 <ipv6_nd_reachable_timeout>:
{
40019530:	fe010113          	addi	sp,sp,-32
40019534:	00812c23          	sw	s0,24(sp)
40019538:	4003c437          	lui	s0,0x4003c
4001953c:	00912a23          	sw	s1,20(sp)
40019540:	01212823          	sw	s2,16(sp)
40019544:	01312623          	sw	s3,12(sp)
40019548:	01412423          	sw	s4,8(sp)
4001954c:	01512223          	sw	s5,4(sp)
40019550:	00112e23          	sw	ra,28(sp)
40019554:	3d840413          	addi	s0,s0,984 # 4003c3d8 <net_neighbor_pool>
	int64_t current = k_uptime_get();
40019558:	de1fd0ef          	jal	ra,40017338 <k_uptime_get>
		switch (data->state) {
4001955c:	4002d9b7          	lui	s3,0x4002d
	int64_t current = k_uptime_get();
40019560:	00050493          	mv	s1,a0
40019564:	00058913          	mv	s2,a1
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
40019568:	2a040a13          	addi	s4,s0,672
		switch (data->state) {
4001956c:	00400a93          	li	s5,4
40019570:	3fc98993          	addi	s3,s3,1020 # 4002d3fc <all_nodes_mcast_group.0+0x2c>
		if (!nbr || !nbr->ref) {
40019574:	00044783          	lbu	a5,0(s0)
40019578:	0a078e63          	beqz	a5,40019634 <ipv6_nd_reachable_timeout+0x104>
4001957c:	00c42783          	lw	a5,12(s0)
		if (!data) {
40019580:	0a078a63          	beqz	a5,40019634 <ipv6_nd_reachable_timeout+0x104>
		if (!data->reachable) {
40019584:	0187a703          	lw	a4,24(a5)
40019588:	01c7a583          	lw	a1,28(a5)
4001958c:	00b766b3          	or	a3,a4,a1
40019590:	0a068263          	beqz	a3,40019634 <ipv6_nd_reachable_timeout+0x104>
		remaining = data->reachable + data->reachable_timeout - current;
40019594:	0207a603          	lw	a2,32(a5)
40019598:	00e60733          	add	a4,a2,a4
4001959c:	41f65693          	srai	a3,a2,0x1f
400195a0:	00b686b3          	add	a3,a3,a1
400195a4:	00c73633          	sltu	a2,a4,a2
400195a8:	00d60633          	add	a2,a2,a3
400195ac:	409705b3          	sub	a1,a4,s1
400195b0:	00b73733          	sltu	a4,a4,a1
400195b4:	41260633          	sub	a2,a2,s2
400195b8:	40e60633          	sub	a2,a2,a4
		if (remaining > 0) {
400195bc:	00c04663          	bgtz	a2,400195c8 <ipv6_nd_reachable_timeout+0x98>
400195c0:	00061a63          	bnez	a2,400195d4 <ipv6_nd_reachable_timeout+0xa4>
400195c4:	00058863          	beqz	a1,400195d4 <ipv6_nd_reachable_timeout+0xa4>
			ipv6_nd_restart_reachable_timer(NULL, remaining);
400195c8:	00000513          	li	a0,0
				ipv6_nd_restart_reachable_timer(nbr,
400195cc:	fe1fd0ef          	jal	ra,400175ac <ipv6_nd_restart_reachable_timer>
400195d0:	0640006f          	j	40019634 <ipv6_nd_reachable_timeout+0x104>
		data->reachable = 0;
400195d4:	00000713          	li	a4,0
400195d8:	00e7ae23          	sw	a4,28(a5)
		switch (data->state) {
400195dc:	0307a703          	lw	a4,48(a5)
		data->reachable = 0;
400195e0:	00000693          	li	a3,0
400195e4:	00d7ac23          	sw	a3,24(a5)
		switch (data->state) {
400195e8:	04eae663          	bltu	s5,a4,40019634 <ipv6_nd_reachable_timeout+0x104>
400195ec:	00271713          	slli	a4,a4,0x2
400195f0:	01370733          	add	a4,a4,s3
400195f4:	00072703          	lw	a4,0(a4)
400195f8:	00070067          	jr	a4
			if (data->ns_count >= MAX_MULTICAST_SOLICIT) {
400195fc:	0367c683          	lbu	a3,54(a5)
40019600:	00200613          	li	a2,2
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
40019604:	00478713          	addi	a4,a5,4
			if (data->ns_count >= MAX_MULTICAST_SOLICIT) {
40019608:	00d67663          	bgeu	a2,a3,40019614 <ipv6_nd_reachable_timeout+0xe4>
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
4001960c:	00070593          	mv	a1,a4
40019610:	0600006f          	j	40019670 <ipv6_nd_reachable_timeout+0x140>
				data->ns_count++;
40019614:	00168693          	addi	a3,a3,1
40019618:	02d78b23          	sb	a3,54(a5)
				ret = net_ipv6_send_ns(nbr->iface, NULL, NULL,
4001961c:	00842503          	lw	a0,8(s0)
40019620:	00000793          	li	a5,0
40019624:	00000693          	li	a3,0
40019628:	00000613          	li	a2,0
4001962c:	00000593          	li	a1,0
40019630:	b01fe0ef          	jal	ra,40018130 <net_ipv6_send_ns>
	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
40019634:	05440413          	addi	s0,s0,84
40019638:	f3441ee3          	bne	s0,s4,40019574 <ipv6_nd_reachable_timeout+0x44>
}
4001963c:	01c12083          	lw	ra,28(sp)
40019640:	01812403          	lw	s0,24(sp)
40019644:	01412483          	lw	s1,20(sp)
40019648:	01012903          	lw	s2,16(sp)
4001964c:	00c12983          	lw	s3,12(sp)
40019650:	00812a03          	lw	s4,8(sp)
40019654:	00412a83          	lw	s5,4(sp)
40019658:	02010113          	addi	sp,sp,32
4001965c:	00008067          	ret
			data->state = NET_IPV6_NBR_STATE_STALE;
40019660:	00200713          	li	a4,2
40019664:	02e7a823          	sw	a4,48(a5)
			NET_DBG("nbr %p moving %s state to STALE (%d)",
40019668:	fcdff06f          	j	40019634 <ipv6_nd_reachable_timeout+0x104>
			net_ipv6_nbr_rm(nbr->iface, &data->addr);
4001966c:	00478593          	addi	a1,a5,4
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
40019670:	00842503          	lw	a0,8(s0)
40019674:	b84fe0ef          	jal	ra,400179f8 <net_ipv6_nbr_rm>
40019678:	fbdff06f          	j	40019634 <ipv6_nd_reachable_timeout+0x104>
			data->state = NET_IPV6_NBR_STATE_PROBE;
4001967c:	00400713          	li	a4,4
40019680:	02e7a823          	sw	a4,48(a5)
			data->ns_count = 0U;
40019684:	02078b23          	sb	zero,54(a5)
			if (data->ns_count >= MAX_UNICAST_SOLICIT) {
40019688:	0367c683          	lbu	a3,54(a5)
4001968c:	00200613          	li	a2,2
				net_ipv6_nbr_rm(nbr->iface, &data->addr);
40019690:	00478713          	addi	a4,a5,4
			if (data->ns_count >= MAX_UNICAST_SOLICIT) {
40019694:	f6d66ce3          	bltu	a2,a3,4001960c <ipv6_nd_reachable_timeout+0xdc>
				data->ns_count++;
40019698:	00168693          	addi	a3,a3,1
4001969c:	02d78b23          	sb	a3,54(a5)
				ret = net_ipv6_send_ns(nbr->iface, NULL, NULL,
400196a0:	00842503          	lw	a0,8(s0)
400196a4:	00000613          	li	a2,0
400196a8:	00000593          	li	a1,0
400196ac:	00000793          	li	a5,0
400196b0:	00000693          	li	a3,0
400196b4:	a7dfe0ef          	jal	ra,40018130 <net_ipv6_send_ns>
				ipv6_nd_restart_reachable_timer(nbr,
400196b8:	3e800593          	li	a1,1000
400196bc:	00000613          	li	a2,0
400196c0:	00040513          	mv	a0,s0
400196c4:	f09ff06f          	j	400195cc <ipv6_nd_reachable_timeout+0x9c>

400196c8 <net_ipv6_send_rs>:
{
400196c8:	fd010113          	addi	sp,sp,-48
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
400196cc:	2ff00793          	li	a5,767
400196d0:	00f12023          	sw	a5,0(sp)
	src = net_if_ipv6_select_src_addr(iface, &dst);
400196d4:	00010593          	mv	a1,sp
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
400196d8:	020007b7          	lui	a5,0x2000
{
400196dc:	02112623          	sw	ra,44(sp)
400196e0:	02912223          	sw	s1,36(sp)
400196e4:	01312e23          	sw	s3,28(sp)
400196e8:	01412c23          	sw	s4,24(sp)
400196ec:	00f12623          	sw	a5,12(sp)
400196f0:	02812423          	sw	s0,40(sp)
400196f4:	03212023          	sw	s2,32(sp)
400196f8:	00050a13          	mv	s4,a0
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
400196fc:	00012223          	sw	zero,4(sp)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
40019700:	00012423          	sw	zero,8(sp)
	src = net_if_ipv6_select_src_addr(iface, &dst);
40019704:	8e0f50ef          	jal	ra,4000e7e4 <net_if_ipv6_select_src_addr>
40019708:	00050993          	mv	s3,a0
	if (!net_ipv6_is_addr_unspecified(src)) {
4001970c:	a61fd0ef          	jal	ra,4001716c <net_ipv6_is_addr_unspecified>
40019710:	00000493          	li	s1,0
40019714:	00051a63          	bnez	a0,40019728 <net_ipv6_send_rs+0x60>
	uint8_t total_len = net_if_get_link_addr(iface)->len +
40019718:	000a2783          	lw	a5,0(s4)
	return ROUND_UP(total_len, 8U);
4001971c:	0147c483          	lbu	s1,20(a5) # 2000014 <__rom_region_size+0x1fcf638>
40019720:	00948493          	addi	s1,s1,9
40019724:	0f84f493          	andi	s1,s1,248
	pkt = net_pkt_alloc_with_buffer(iface,
40019728:	00448593          	addi	a1,s1,4
4001972c:	00a00713          	li	a4,10
40019730:	00000793          	li	a5,0
40019734:	03a00693          	li	a3,58
40019738:	00200613          	li	a2,2
4001973c:	0fc5f593          	andi	a1,a1,252
40019740:	000a0513          	mv	a0,s4
40019744:	fd9f90ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
40019748:	00050413          	mv	s0,a0
		return -ENOMEM;
4001974c:	ff400913          	li	s2,-12
	if (!pkt) {
40019750:	02050463          	beqz	a0,40019778 <net_ipv6_send_rs+0xb0>
	pkt->ipv6_hop_limit = hop_limit;
40019754:	fff00793          	li	a5,-1
40019758:	02f50ca3          	sb	a5,57(a0)
	if (net_ipv6_create(pkt, src, &dst) ||
4001975c:	00010613          	mv	a2,sp
40019760:	00098593          	mv	a1,s3
40019764:	988fd0ef          	jal	ra,400168ec <net_ipv6_create>
40019768:	02050a63          	beqz	a0,4001979c <net_ipv6_send_rs+0xd4>
	int ret = -ENOBUFS;
4001976c:	f9700913          	li	s2,-105
	net_pkt_unref(pkt);
40019770:	00040513          	mv	a0,s0
40019774:	fa8f90ef          	jal	ra,40012f1c <net_pkt_unref>
}
40019778:	02c12083          	lw	ra,44(sp)
4001977c:	02812403          	lw	s0,40(sp)
40019780:	02412483          	lw	s1,36(sp)
40019784:	01c12983          	lw	s3,28(sp)
40019788:	01812a03          	lw	s4,24(sp)
4001978c:	00090513          	mv	a0,s2
40019790:	02012903          	lw	s2,32(sp)
40019794:	03010113          	addi	sp,sp,48
40019798:	00008067          	ret
	    net_icmpv6_create(pkt, NET_ICMPV6_RS, 0) ||
4001979c:	00000613          	li	a2,0
400197a0:	08500593          	li	a1,133
400197a4:	00040513          	mv	a0,s0
400197a8:	d54fc0ef          	jal	ra,40015cfc <net_icmpv6_create>
	if (net_ipv6_create(pkt, src, &dst) ||
400197ac:	fc0510e3          	bnez	a0,4001976c <net_ipv6_send_rs+0xa4>
	    net_pkt_memset(pkt, 0, sizeof(struct net_icmpv6_rs_hdr))) {
400197b0:	00400613          	li	a2,4
400197b4:	00000593          	li	a1,0
400197b8:	00040513          	mv	a0,s0
400197bc:	9e8fa0ef          	jal	ra,400139a4 <net_pkt_memset>
400197c0:	00050913          	mv	s2,a0
	    net_icmpv6_create(pkt, NET_ICMPV6_RS, 0) ||
400197c4:	fa0514e3          	bnez	a0,4001976c <net_ipv6_send_rs+0xa4>
	if (llao_len > 0) {
400197c8:	02049663          	bnez	s1,400197f4 <net_ipv6_send_rs+0x12c>
	net_pkt_cursor_init(pkt);
400197cc:	00040513          	mv	a0,s0
400197d0:	a21f90ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
400197d4:	03a00593          	li	a1,58
400197d8:	00040513          	mv	a0,s0
400197dc:	a04fd0ef          	jal	ra,400169e0 <net_ipv6_finalize>
	if (net_send_data(pkt) < 0) {
400197e0:	00040513          	mv	a0,s0
400197e4:	ee5f10ef          	jal	ra,4000b6c8 <net_send_data>
400197e8:	f80558e3          	bgez	a0,40019778 <net_ipv6_send_rs+0xb0>
		ret = -EINVAL;
400197ec:	fea00913          	li	s2,-22
400197f0:	f81ff06f          	j	40019770 <net_ipv6_send_rs+0xa8>
	return &iface->if_dev->link_addr;
400197f4:	000a2583          	lw	a1,0(s4)
		if (!set_llao(pkt, net_if_get_link_addr(iface),
400197f8:	00100693          	li	a3,1
400197fc:	00048613          	mv	a2,s1
40019800:	01058593          	addi	a1,a1,16
40019804:	00040513          	mv	a0,s0
40019808:	c85fd0ef          	jal	ra,4001748c <set_llao>
4001980c:	fc0510e3          	bnez	a0,400197cc <net_ipv6_send_rs+0x104>
40019810:	f5dff06f          	j	4001976c <net_ipv6_send_rs+0xa4>

40019814 <net_ipv6_start_rs>:
	return net_ipv6_send_rs(iface);
40019814:	eb5ff06f          	j	400196c8 <net_ipv6_send_rs>

40019818 <net_ipv6_nbr_init>:
#endif /* CONFIG_NET_IPV6_ND */

void net_ipv6_nbr_init(void)
{
#if defined(CONFIG_NET_IPV6_NBR_CACHE)
	net_icmpv6_register_handler(&ns_input_handler);
40019818:	4003c537          	lui	a0,0x4003c
{
4001981c:	ff010113          	addi	sp,sp,-16
	net_icmpv6_register_handler(&ns_input_handler);
40019820:	3c050513          	addi	a0,a0,960 # 4003c3c0 <ns_input_handler>
{
40019824:	00112623          	sw	ra,12(sp)
	net_icmpv6_register_handler(&ns_input_handler);
40019828:	bd0fc0ef          	jal	ra,40015bf8 <net_icmpv6_register_handler>
	net_icmpv6_register_handler(&na_input_handler);
4001982c:	4003c537          	lui	a0,0x4003c
40019830:	3b450513          	addi	a0,a0,948 # 4003c3b4 <na_input_handler>
40019834:	bc4fc0ef          	jal	ra,40015bf8 <net_icmpv6_register_handler>
	k_work_init_delayable(&ipv6_ns_reply_timer, ipv6_ns_reply_timeout);
40019838:	400175b7          	lui	a1,0x40017
4001983c:	40031537          	lui	a0,0x40031
40019840:	36458593          	addi	a1,a1,868 # 40017364 <ipv6_ns_reply_timeout>
40019844:	07850513          	addi	a0,a0,120 # 40031078 <ipv6_ns_reply_timer>
40019848:	48d0f0ef          	jal	ra,400294d4 <k_work_init_delayable>
	return z_impl_k_sem_init(sem, initial_count, limit);
4001984c:	40032537          	lui	a0,0x40032
40019850:	00100593          	li	a1,1
40019854:	fff00613          	li	a2,-1
40019858:	61450513          	addi	a0,a0,1556 # 40032614 <nbr_lock>
4001985c:	4f00f0ef          	jal	ra,40028d4c <z_impl_k_sem_init>
	k_sem_init(&nbr_lock, 1, K_SEM_MAX_LIMIT);
#endif
#if defined(CONFIG_NET_IPV6_ND)
	net_icmpv6_register_handler(&ra_input_handler);
40019860:	4003c537          	lui	a0,0x4003c
40019864:	3a850513          	addi	a0,a0,936 # 4003c3a8 <ra_input_handler>
40019868:	b90fc0ef          	jal	ra,40015bf8 <net_icmpv6_register_handler>
	k_work_init_delayable(&ipv6_nd_reachable_timer,
			      ipv6_nd_reachable_timeout);
#endif
}
4001986c:	00c12083          	lw	ra,12(sp)
	k_work_init_delayable(&ipv6_nd_reachable_timer,
40019870:	400195b7          	lui	a1,0x40019
40019874:	40031537          	lui	a0,0x40031
40019878:	53058593          	addi	a1,a1,1328 # 40019530 <ipv6_nd_reachable_timeout>
4001987c:	0a850513          	addi	a0,a0,168 # 400310a8 <ipv6_nd_reachable_timer>
}
40019880:	01010113          	addi	sp,sp,16
	k_work_init_delayable(&ipv6_nd_reachable_timer,
40019884:	4510f06f          	j	400294d4 <k_work_init_delayable>

40019888 <net_pkt_write_be16>:
{
40019888:	fe010113          	addi	sp,sp,-32
	uint16_t data_be16 = htons(data);
4001988c:	00859793          	slli	a5,a1,0x8
40019890:	0085d593          	srli	a1,a1,0x8
40019894:	00b7e7b3          	or	a5,a5,a1
	return net_pkt_write(pkt, &data_be16, sizeof(uint16_t));
40019898:	00200613          	li	a2,2
4001989c:	00e10593          	addi	a1,sp,14
{
400198a0:	00112e23          	sw	ra,28(sp)
	uint16_t data_be16 = htons(data);
400198a4:	00f11723          	sh	a5,14(sp)
	return net_pkt_write(pkt, &data_be16, sizeof(uint16_t));
400198a8:	e70fa0ef          	jal	ra,40013f18 <net_pkt_write>
}
400198ac:	01c12083          	lw	ra,28(sp)
400198b0:	02010113          	addi	sp,sp,32
400198b4:	00008067          	ret

400198b8 <mld_create>:

static int mld_create(struct net_pkt *pkt,
		      const struct in6_addr *addr,
		      uint8_t record_type,
		      uint16_t num_sources)
{
400198b8:	fc010113          	addi	sp,sp,-64
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
400198bc:	00c10793          	addi	a5,sp,12
{
400198c0:	02812c23          	sw	s0,56(sp)
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
400198c4:	00f12223          	sw	a5,4(sp)
{
400198c8:	00058413          	mv	s0,a1
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
400198cc:	01400793          	li	a5,20
				   struct net_icmpv6_mld_mcast_record);
	struct net_icmpv6_mld_mcast_record *mld;

	mld = (struct net_icmpv6_mld_mcast_record *)
				net_pkt_get_data(pkt, &mld_access);
400198d0:	00410593          	addi	a1,sp,4
{
400198d4:	02912a23          	sw	s1,52(sp)
400198d8:	03212823          	sw	s2,48(sp)
400198dc:	03312623          	sw	s3,44(sp)
400198e0:	02112e23          	sw	ra,60(sp)
400198e4:	00050493          	mv	s1,a0
400198e8:	00060993          	mv	s3,a2
400198ec:	00068913          	mv	s2,a3
	NET_PKT_DATA_ACCESS_DEFINE(mld_access,
400198f0:	00f12423          	sw	a5,8(sp)
				net_pkt_get_data(pkt, &mld_access);
400198f4:	e88fa0ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!mld) {
400198f8:	02051463          	bnez	a0,40019920 <mld_create+0x68>
		return -ENOBUFS;
400198fc:	f9700413          	li	s0,-105
			return -ENOBUFS;
		}
	}

	return 0;
}
40019900:	03c12083          	lw	ra,60(sp)
40019904:	00040513          	mv	a0,s0
40019908:	03812403          	lw	s0,56(sp)
4001990c:	03412483          	lw	s1,52(sp)
40019910:	03012903          	lw	s2,48(sp)
40019914:	02c12983          	lw	s3,44(sp)
40019918:	04010113          	addi	sp,sp,64
4001991c:	00008067          	ret
	memcpy(dest, src, sizeof(struct in6_addr));
40019920:	00040593          	mv	a1,s0
	mld->record_type = record_type;
40019924:	01350023          	sb	s3,0(a0)
	mld->aux_data_len = 0U;
40019928:	000500a3          	sb	zero,1(a0)
	mld->num_sources = htons(num_sources);
4001992c:	00050123          	sb	zero,2(a0)
40019930:	012501a3          	sb	s2,3(a0)
40019934:	01000613          	li	a2,16
40019938:	00450513          	addi	a0,a0,4
4001993c:	f10ef0ef          	jal	ra,4000904c <memcpy>
	if (net_pkt_set_data(pkt, &mld_access)) {
40019940:	00410593          	addi	a1,sp,4
40019944:	00048513          	mv	a0,s1
40019948:	ec4fa0ef          	jal	ra,4001400c <net_pkt_set_data>
4001994c:	00050413          	mv	s0,a0
40019950:	fa0516e3          	bnez	a0,400198fc <mld_create+0x44>
	if (num_sources > 0) {
40019954:	fa0906e3          	beqz	s2,40019900 <mld_create+0x48>
				  net_ipv6_unspecified_address()->s6_addr,
40019958:	b14f70ef          	jal	ra,40010c6c <net_ipv6_unspecified_address>
4001995c:	00050593          	mv	a1,a0
		if (net_pkt_write(pkt,
40019960:	01000613          	li	a2,16
40019964:	00048513          	mv	a0,s1
40019968:	db0fa0ef          	jal	ra,40013f18 <net_pkt_write>
4001996c:	f8050ae3          	beqz	a0,40019900 <mld_create+0x48>
40019970:	f8dff06f          	j	400198fc <mld_create+0x44>

40019974 <mld_send>:

	return 0;
}

static int mld_send(struct net_pkt *pkt)
{
40019974:	ff010113          	addi	sp,sp,-16
40019978:	00112623          	sw	ra,12(sp)
4001997c:	00812423          	sw	s0,8(sp)
40019980:	00050413          	mv	s0,a0
	net_pkt_cursor_init(pkt);
40019984:	86df90ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	net_ipv6_finalize(pkt, IPPROTO_ICMPV6);
40019988:	03a00593          	li	a1,58
4001998c:	00040513          	mv	a0,s0
40019990:	850fd0ef          	jal	ra,400169e0 <net_ipv6_finalize>

	if (net_send_data(pkt) < 0) {
40019994:	00040513          	mv	a0,s0
40019998:	d31f10ef          	jal	ra,4000b6c8 <net_send_data>
4001999c:	02055063          	bgez	a0,400199bc <mld_send+0x48>
		net_stats_update_icmp_drop(net_pkt_iface(pkt));
		net_stats_update_ipv6_mld_drop(net_pkt_iface(pkt));

		net_pkt_unref(pkt);
400199a0:	00040513          	mv	a0,s0
400199a4:	d78f90ef          	jal	ra,40012f1c <net_pkt_unref>

		return -1;
400199a8:	fff00513          	li	a0,-1

	net_stats_update_icmp_sent(net_pkt_iface(pkt));
	net_stats_update_ipv6_mld_sent(net_pkt_iface(pkt));

	return 0;
}
400199ac:	00c12083          	lw	ra,12(sp)
400199b0:	00812403          	lw	s0,8(sp)
400199b4:	01010113          	addi	sp,sp,16
400199b8:	00008067          	ret
	return 0;
400199bc:	00000513          	li	a0,0
400199c0:	fedff06f          	j	400199ac <mld_send+0x38>

400199c4 <net_if_flag_is_set>:
	if (iface == NULL) {
400199c4:	02050c63          	beqz	a0,400199fc <net_if_flag_is_set+0x38>
{
400199c8:	ff010113          	addi	sp,sp,-16
400199cc:	00812423          	sw	s0,8(sp)
400199d0:	00112623          	sw	ra,12(sp)
	return atomic_test_bit(iface->if_dev->flags, value);
400199d4:	00052503          	lw	a0,0(a0)
400199d8:	00058413          	mv	s0,a1
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
400199dc:	00c50513          	addi	a0,a0,12
400199e0:	608110ef          	jal	ra,4002afe8 <atomic_get>
}
400199e4:	00c12083          	lw	ra,12(sp)
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
400199e8:	40855533          	sra	a0,a0,s0
400199ec:	00812403          	lw	s0,8(sp)
400199f0:	00157513          	andi	a0,a0,1
400199f4:	01010113          	addi	sp,sp,16
400199f8:	00008067          	ret
		return false;
400199fc:	00000513          	li	a0,0
}
40019a00:	00008067          	ret

40019a04 <mld_create_packet>:
{
40019a04:	fd010113          	addi	sp,sp,-48
	UNALIGNED_PUT(htons(addr0), &addr->s6_addr16[0]);
40019a08:	2ff00793          	li	a5,767
40019a0c:	00f12823          	sw	a5,16(sp)
	UNALIGNED_PUT(htons(addr6), &addr->s6_addr16[6]);
40019a10:	160007b7          	lui	a5,0x16000
40019a14:	02812423          	sw	s0,40(sp)
40019a18:	02912223          	sw	s1,36(sp)
40019a1c:	02112623          	sw	ra,44(sp)
40019a20:	00f12e23          	sw	a5,28(sp)
	pkt->ipv6_hop_limit = hop_limit;
40019a24:	00100793          	li	a5,1
40019a28:	00050413          	mv	s0,a0
40019a2c:	02f50ca3          	sb	a5,57(a0)
	if (net_ipv6_create(pkt, net_if_ipv6_select_src_addr(
40019a30:	01852503          	lw	a0,24(a0)
{
40019a34:	00058493          	mv	s1,a1
	if (net_ipv6_create(pkt, net_if_ipv6_select_src_addr(
40019a38:	01010593          	addi	a1,sp,16
	UNALIGNED_PUT(htons(addr2), &addr->s6_addr16[2]);
40019a3c:	00012a23          	sw	zero,20(sp)
	UNALIGNED_PUT(htons(addr4), &addr->s6_addr16[4]);
40019a40:	00012c23          	sw	zero,24(sp)
40019a44:	da1f40ef          	jal	ra,4000e7e4 <net_if_ipv6_select_src_addr>
40019a48:	00050593          	mv	a1,a0
40019a4c:	01010613          	addi	a2,sp,16
40019a50:	00040513          	mv	a0,s0
40019a54:	e99fc0ef          	jal	ra,400168ec <net_ipv6_create>
40019a58:	00050e63          	beqz	a0,40019a74 <mld_create_packet+0x70>
		return -ENOBUFS;
40019a5c:	f9700513          	li	a0,-105
}
40019a60:	02c12083          	lw	ra,44(sp)
40019a64:	02812403          	lw	s0,40(sp)
40019a68:	02412483          	lw	s1,36(sp)
40019a6c:	03010113          	addi	sp,sp,48
40019a70:	00008067          	ret
	if (net_pkt_write_u8(pkt, IPPROTO_ICMPV6) ||
40019a74:	03a00793          	li	a5,58
	return net_pkt_write(pkt, &data, sizeof(uint8_t));
40019a78:	00100613          	li	a2,1
40019a7c:	00f10593          	addi	a1,sp,15
40019a80:	00040513          	mv	a0,s0
40019a84:	00f107a3          	sb	a5,15(sp)
40019a88:	c90fa0ef          	jal	ra,40013f18 <net_pkt_write>
40019a8c:	fc0518e3          	bnez	a0,40019a5c <mld_create_packet+0x58>
40019a90:	00100613          	li	a2,1
40019a94:	00f10593          	addi	a1,sp,15
40019a98:	00040513          	mv	a0,s0
40019a9c:	000107a3          	sb	zero,15(sp)
40019aa0:	c78fa0ef          	jal	ra,40013f18 <net_pkt_write>
40019aa4:	fa051ce3          	bnez	a0,40019a5c <mld_create_packet+0x58>
	if (net_pkt_write_be16(pkt, 0x0502) ||
40019aa8:	50200593          	li	a1,1282
40019aac:	00040513          	mv	a0,s0
40019ab0:	dd9ff0ef          	jal	ra,40019888 <net_pkt_write_be16>
40019ab4:	fa0514e3          	bnez	a0,40019a5c <mld_create_packet+0x58>
	    net_pkt_write_be16(pkt, 0) ||
40019ab8:	00000593          	li	a1,0
40019abc:	00040513          	mv	a0,s0
40019ac0:	dc9ff0ef          	jal	ra,40019888 <net_pkt_write_be16>
	if (net_pkt_write_be16(pkt, 0x0502) ||
40019ac4:	f8051ce3          	bnez	a0,40019a5c <mld_create_packet+0x58>
	    net_pkt_write_be16(pkt, 0)) {
40019ac8:	00000593          	li	a1,0
40019acc:	00040513          	mv	a0,s0
40019ad0:	db9ff0ef          	jal	ra,40019888 <net_pkt_write_be16>
	    net_pkt_write_be16(pkt, 0) ||
40019ad4:	f80514e3          	bnez	a0,40019a5c <mld_create_packet+0x58>
	pkt->ipv6_ext_len = len;
40019ad8:	00800793          	li	a5,8
40019adc:	02f41d23          	sh	a5,58(s0)
	if (net_icmpv6_create(pkt, NET_ICMPV6_MLDv2, 0) ||
40019ae0:	00000613          	li	a2,0
40019ae4:	08f00593          	li	a1,143
40019ae8:	00040513          	mv	a0,s0
40019aec:	a10fc0ef          	jal	ra,40015cfc <net_icmpv6_create>
40019af0:	f60516e3          	bnez	a0,40019a5c <mld_create_packet+0x58>
	    net_pkt_write_be16(pkt, 0) ||
40019af4:	00000593          	li	a1,0
40019af8:	00040513          	mv	a0,s0
40019afc:	d8dff0ef          	jal	ra,40019888 <net_pkt_write_be16>
	if (net_icmpv6_create(pkt, NET_ICMPV6_MLDv2, 0) ||
40019b00:	f4051ee3          	bnez	a0,40019a5c <mld_create_packet+0x58>
	    net_pkt_write_be16(pkt, count)) {
40019b04:	00048593          	mv	a1,s1
40019b08:	00040513          	mv	a0,s0
40019b0c:	d7dff0ef          	jal	ra,40019888 <net_pkt_write_be16>
	    net_pkt_write_be16(pkt, 0) ||
40019b10:	f40516e3          	bnez	a0,40019a5c <mld_create_packet+0x58>
	pkt->ipv6_next_hdr = next_hdr;
40019b14:	02040fa3          	sb	zero,63(s0)
	return 0;
40019b18:	f49ff06f          	j	40019a60 <mld_create_packet+0x5c>

40019b1c <mld_send_generic>:

static int mld_send_generic(struct net_if *iface,
			    const struct in6_addr *addr,
			    uint8_t mode)
{
40019b1c:	ff010113          	addi	sp,sp,-16
40019b20:	00812423          	sw	s0,8(sp)
40019b24:	01212023          	sw	s2,0(sp)
40019b28:	00058413          	mv	s0,a1
40019b2c:	00060913          	mv	s2,a2
	struct net_pkt *pkt;
	int ret;

	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
40019b30:	00500713          	li	a4,5
40019b34:	00000793          	li	a5,0
40019b38:	03a00693          	li	a3,58
40019b3c:	00200613          	li	a2,2
40019b40:	03000593          	li	a1,48
{
40019b44:	00112623          	sw	ra,12(sp)
40019b48:	00912223          	sw	s1,4(sp)
	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
40019b4c:	bd1f90ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
					NET_ICMPV6_UNUSED_LEN +
					MLDv2_MCAST_RECORD_LEN +
					sizeof(struct in6_addr),
					AF_INET6, IPPROTO_ICMPV6,
					PKT_WAIT_TIME);
	if (!pkt) {
40019b50:	06050463          	beqz	a0,40019bb8 <mld_send_generic+0x9c>
		return -ENOMEM;
	}

	if (mld_create_packet(pkt, 1) ||
40019b54:	00100593          	li	a1,1
40019b58:	00050493          	mv	s1,a0
40019b5c:	ea9ff0ef          	jal	ra,40019a04 <mld_create_packet>
40019b60:	00050a63          	beqz	a0,40019b74 <mld_send_generic+0x58>
	    mld_create(pkt, addr, mode, 1)) {
		ret = -ENOBUFS;
40019b64:	f9700413          	li	s0,-105
	}

	return 0;

drop:
	net_pkt_unref(pkt);
40019b68:	00048513          	mv	a0,s1
40019b6c:	bb0f90ef          	jal	ra,40012f1c <net_pkt_unref>

	return ret;
40019b70:	02c0006f          	j	40019b9c <mld_send_generic+0x80>
	    mld_create(pkt, addr, mode, 1)) {
40019b74:	00100693          	li	a3,1
40019b78:	00090613          	mv	a2,s2
40019b7c:	00040593          	mv	a1,s0
40019b80:	00048513          	mv	a0,s1
40019b84:	d35ff0ef          	jal	ra,400198b8 <mld_create>
	if (mld_create_packet(pkt, 1) ||
40019b88:	fc051ee3          	bnez	a0,40019b64 <mld_send_generic+0x48>
	ret = mld_send(pkt);
40019b8c:	00048513          	mv	a0,s1
40019b90:	de5ff0ef          	jal	ra,40019974 <mld_send>
40019b94:	00050413          	mv	s0,a0
	if (ret) {
40019b98:	fc0518e3          	bnez	a0,40019b68 <mld_send_generic+0x4c>
}
40019b9c:	00c12083          	lw	ra,12(sp)
40019ba0:	00040513          	mv	a0,s0
40019ba4:	00812403          	lw	s0,8(sp)
40019ba8:	00412483          	lw	s1,4(sp)
40019bac:	00012903          	lw	s2,0(sp)
40019bb0:	01010113          	addi	sp,sp,16
40019bb4:	00008067          	ret
		return -ENOMEM;
40019bb8:	ff400413          	li	s0,-12
40019bbc:	fe1ff06f          	j	40019b9c <mld_send_generic+0x80>

40019bc0 <handle_mld_query>:
	dbg_addr("Received", pkt_str, src, dst)

static enum net_verdict handle_mld_query(struct net_pkt *pkt,
					 struct net_ipv6_hdr *ip_hdr,
					 struct net_icmp_hdr *icmp_hdr)
{
40019bc0:	fd010113          	addi	sp,sp,-48
40019bc4:	02812423          	sw	s0,40(sp)
40019bc8:	03212023          	sw	s2,32(sp)
40019bcc:	01312e23          	sw	s3,28(sp)
40019bd0:	01412c23          	sw	s4,24(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(mld_access,
40019bd4:	01800793          	li	a5,24
{
40019bd8:	02112623          	sw	ra,44(sp)
40019bdc:	02912223          	sw	s1,36(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(mld_access,
40019be0:	00f12623          	sw	a5,12(sp)
					      struct net_icmpv6_mld_query);
	uint16_t length = net_pkt_get_len(pkt);
40019be4:	00852783          	lw	a5,8(a0)
{
40019be8:	00050413          	mv	s0,a0
40019bec:	00058a13          	mv	s4,a1
40019bf0:	00060993          	mv	s3,a2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(mld_access,
40019bf4:	00012423          	sw	zero,8(sp)
	size_t bytes = 0;
40019bf8:	00000913          	li	s2,0
	while (buf) {
40019bfc:	04079263          	bnez	a5,40019c40 <handle_mld_query+0x80>
	struct net_icmpv6_mld_query *mld_query;
	uint16_t pkt_len;

	mld_query = (struct net_icmpv6_mld_query *)
				net_pkt_get_data(pkt, &mld_access);
40019c00:	00810593          	addi	a1,sp,8
40019c04:	00040513          	mv	a0,s0
	uint16_t length = net_pkt_get_len(pkt);
40019c08:	01091913          	slli	s2,s2,0x10
				net_pkt_get_data(pkt, &mld_access);
40019c0c:	b70fa0ef          	jal	ra,40013f7c <net_pkt_get_data>
	uint16_t length = net_pkt_get_len(pkt);
40019c10:	01095913          	srli	s2,s2,0x10
				net_pkt_get_data(pkt, &mld_access);
40019c14:	00050493          	mv	s1,a0
	if (!mld_query) {
40019c18:	02051c63          	bnez	a0,40019c50 <handle_mld_query+0x90>
	return NET_OK;

drop:
	net_stats_update_ipv6_mld_drop(net_pkt_iface(pkt));

	return NET_DROP;
40019c1c:	00200513          	li	a0,2
}
40019c20:	02c12083          	lw	ra,44(sp)
40019c24:	02812403          	lw	s0,40(sp)
40019c28:	02412483          	lw	s1,36(sp)
40019c2c:	02012903          	lw	s2,32(sp)
40019c30:	01c12983          	lw	s3,28(sp)
40019c34:	01812a03          	lw	s4,24(sp)
40019c38:	03010113          	addi	sp,sp,48
40019c3c:	00008067          	ret
		bytes += buf->len;
40019c40:	0107d703          	lhu	a4,16(a5) # 16000010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x100a1f10>
		buf = buf->frags;
40019c44:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
40019c48:	00e90933          	add	s2,s2,a4
		buf = buf->frags;
40019c4c:	fb1ff06f          	j	40019bfc <handle_mld_query+0x3c>
	return net_pkt_skip(pkt, access->size);
40019c50:	00c12583          	lw	a1,12(sp)
40019c54:	00040513          	mv	a0,s0
40019c58:	b0df90ef          	jal	ra,40013764 <net_pkt_skip>
	mld_query->num_sources = ntohs(mld_query->num_sources);
40019c5c:	0174c783          	lbu	a5,23(s1)
40019c60:	0164c703          	lbu	a4,22(s1)
40019c64:	00879793          	slli	a5,a5,0x8
40019c68:	00e7e7b3          	or	a5,a5,a4
40019c6c:	00879713          	slli	a4,a5,0x8
40019c70:	0087d793          	srli	a5,a5,0x8
40019c74:	00f767b3          	or	a5,a4,a5
40019c78:	01079713          	slli	a4,a5,0x10
40019c7c:	01075713          	srli	a4,a4,0x10
40019c80:	00f48b23          	sb	a5,22(s1)
40019c84:	00875793          	srli	a5,a4,0x8
40019c88:	00f48ba3          	sb	a5,23(s1)
	pkt_len = sizeof(struct net_ipv6_hdr) +	net_pkt_ipv6_ext_len(pkt) +
40019c8c:	03a45783          	lhu	a5,58(s0)
		sizeof(struct in6_addr) * mld_query->num_sources;
40019c90:	00471713          	slli	a4,a4,0x4
	pkt_len = sizeof(struct net_ipv6_hdr) +	net_pkt_ipv6_ext_len(pkt) +
40019c94:	04478793          	addi	a5,a5,68
40019c98:	00e787b3          	add	a5,a5,a4
40019c9c:	01079793          	slli	a5,a5,0x10
40019ca0:	0107d793          	srli	a5,a5,0x10
	if (length < pkt_len || pkt_len > NET_IPV6_MTU ||
40019ca4:	f6f96ce3          	bltu	s2,a5,40019c1c <handle_mld_query+0x5c>
40019ca8:	50000713          	li	a4,1280
40019cac:	f6f768e3          	bltu	a4,a5,40019c1c <handle_mld_query+0x5c>
40019cb0:	007a4703          	lbu	a4,7(s4)
40019cb4:	00100793          	li	a5,1
40019cb8:	f6f712e3          	bne	a4,a5,40019c1c <handle_mld_query+0x5c>
	    ip_hdr->hop_limit != 1U || icmp_hdr->code != 0U) {
40019cbc:	0019c783          	lbu	a5,1(s3)
40019cc0:	f4079ee3          	bnez	a5,40019c1c <handle_mld_query+0x5c>
				   (uint8_t *)net_ipv6_unspecified_address())) {
40019cc4:	fa9f60ef          	jal	ra,40010c6c <net_ipv6_unspecified_address>
40019cc8:	00050593          	mv	a1,a0
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
40019ccc:	01000613          	li	a2,16
40019cd0:	00448513          	addi	a0,s1,4
40019cd4:	af8ef0ef          	jal	ra,40008fcc <memcmp>
40019cd8:	00050493          	mv	s1,a0
	if (!net_ipv6_addr_cmp_raw(mld_query->mcast_address,
40019cdc:	f40510e3          	bnez	a0,40019c1c <handle_mld_query+0x5c>
	return pkt->iface;
40019ce0:	01842503          	lw	a0,24(s0)
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
40019ce4:	00452983          	lw	s3,4(a0)
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
40019ce8:	0a49a783          	lw	a5,164(s3)
40019cec:	0017f713          	andi	a4,a5,1
40019cf0:	00070663          	beqz	a4,40019cfc <handle_mld_query+0x13c>
40019cf4:	0017d793          	srli	a5,a5,0x1
40019cf8:	0017f493          	andi	s1,a5,1
40019cfc:	0bc9a783          	lw	a5,188(s3)
40019d00:	0017f713          	andi	a4,a5,1
40019d04:	00070a63          	beqz	a4,40019d18 <handle_mld_query+0x158>
40019d08:	0017d793          	srli	a5,a5,0x1
40019d0c:	0017f793          	andi	a5,a5,1
40019d10:	00078463          	beqz	a5,40019d18 <handle_mld_query+0x158>
		count++;
40019d14:	00148493          	addi	s1,s1,1
					count * MLDv2_MCAST_RECORD_LEN,
40019d18:	01400593          	li	a1,20
40019d1c:	02b485b3          	mul	a1,s1,a1
	pkt = net_pkt_alloc_with_buffer(iface, IPV6_OPT_HDR_ROUTER_ALERT_LEN +
40019d20:	00500713          	li	a4,5
40019d24:	00000793          	li	a5,0
40019d28:	03a00693          	li	a3,58
40019d2c:	00200613          	li	a2,2
40019d30:	00c58593          	addi	a1,a1,12
40019d34:	9e9f90ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
40019d38:	00050913          	mv	s2,a0
	if (!pkt) {
40019d3c:	00050e63          	beqz	a0,40019d58 <handle_mld_query+0x198>
	if (mld_create_packet(pkt, count)) {
40019d40:	01049593          	slli	a1,s1,0x10
40019d44:	0105d593          	srli	a1,a1,0x10
40019d48:	cbdff0ef          	jal	ra,40019a04 <mld_create_packet>
40019d4c:	00050e63          	beqz	a0,40019d68 <handle_mld_query+0x1a8>
	net_pkt_unref(pkt);
40019d50:	00090513          	mv	a0,s2
40019d54:	9c8f90ef          	jal	ra,40012f1c <net_pkt_unref>
	net_pkt_unref(pkt);
40019d58:	00040513          	mv	a0,s0
40019d5c:	9c0f90ef          	jal	ra,40012f1c <net_pkt_unref>
	return NET_OK;
40019d60:	00000513          	li	a0,0
40019d64:	ebdff06f          	j	40019c20 <handle_mld_query+0x60>
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
40019d68:	0a49a783          	lw	a5,164(s3)
40019d6c:	0017f713          	andi	a4,a5,1
40019d70:	02070463          	beqz	a4,40019d98 <handle_mld_query+0x1d8>
40019d74:	0017d793          	srli	a5,a5,0x1
40019d78:	0017f793          	andi	a5,a5,1
40019d7c:	00078e63          	beqz	a5,40019d98 <handle_mld_query+0x1d8>
		if (!mld_create(pkt, &ipv6->mcast[i].address.in6_addr,
40019d80:	00000693          	li	a3,0
40019d84:	00200613          	li	a2,2
40019d88:	09498593          	addi	a1,s3,148
40019d8c:	00090513          	mv	a0,s2
40019d90:	b29ff0ef          	jal	ra,400198b8 <mld_create>
40019d94:	fa050ee3          	beqz	a0,40019d50 <handle_mld_query+0x190>
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
40019d98:	0bc9a783          	lw	a5,188(s3)
40019d9c:	0017f713          	andi	a4,a5,1
40019da0:	00071a63          	bnez	a4,40019db4 <handle_mld_query+0x1f4>
	if (!mld_send(pkt)) {
40019da4:	00090513          	mv	a0,s2
40019da8:	bcdff0ef          	jal	ra,40019974 <mld_send>
40019dac:	fa0512e3          	bnez	a0,40019d50 <handle_mld_query+0x190>
40019db0:	fa9ff06f          	j	40019d58 <handle_mld_query+0x198>
		if (!ipv6->mcast[i].is_used || !ipv6->mcast[i].is_joined) {
40019db4:	0017d793          	srli	a5,a5,0x1
40019db8:	0017f793          	andi	a5,a5,1
40019dbc:	fe0784e3          	beqz	a5,40019da4 <handle_mld_query+0x1e4>
		if (!mld_create(pkt, &ipv6->mcast[i].address.in6_addr,
40019dc0:	00000693          	li	a3,0
40019dc4:	00200613          	li	a2,2
40019dc8:	0ac98593          	addi	a1,s3,172
40019dcc:	00090513          	mv	a0,s2
40019dd0:	ae9ff0ef          	jal	ra,400198b8 <mld_create>
40019dd4:	fc0518e3          	bnez	a0,40019da4 <handle_mld_query+0x1e4>
40019dd8:	f79ff06f          	j	40019d50 <handle_mld_query+0x190>

40019ddc <net_ipv6_mld_join>:
{
40019ddc:	fe010113          	addi	sp,sp,-32
40019de0:	01212823          	sw	s2,16(sp)
40019de4:	00058913          	mv	s2,a1
40019de8:	00a12623          	sw	a0,12(sp)
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
40019dec:	00c10593          	addi	a1,sp,12
40019df0:	00090513          	mv	a0,s2
{
40019df4:	00112e23          	sw	ra,28(sp)
40019df8:	00812c23          	sw	s0,24(sp)
40019dfc:	00912a23          	sw	s1,20(sp)
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
40019e00:	f75f30ef          	jal	ra,4000dd74 <net_if_ipv6_maddr_lookup>
	if (maddr && net_if_ipv6_maddr_is_joined(maddr)) {
40019e04:	02050c63          	beqz	a0,40019e3c <net_ipv6_mld_join+0x60>
	return addr->is_joined;
40019e08:	01452783          	lw	a5,20(a0)
40019e0c:	00050413          	mv	s0,a0
		return -EALREADY;
40019e10:	f8800493          	li	s1,-120
40019e14:	0017d793          	srli	a5,a5,0x1
	if (maddr && net_if_ipv6_maddr_is_joined(maddr)) {
40019e18:	0017f793          	andi	a5,a5,1
40019e1c:	02078c63          	beqz	a5,40019e54 <net_ipv6_mld_join+0x78>
}
40019e20:	01c12083          	lw	ra,28(sp)
40019e24:	01812403          	lw	s0,24(sp)
40019e28:	01012903          	lw	s2,16(sp)
40019e2c:	00048513          	mv	a0,s1
40019e30:	01412483          	lw	s1,20(sp)
40019e34:	02010113          	addi	sp,sp,32
40019e38:	00008067          	ret
		maddr = net_if_ipv6_maddr_add(iface, addr);
40019e3c:	00c12503          	lw	a0,12(sp)
40019e40:	00090593          	mv	a1,s2
			return -ENOMEM;
40019e44:	ff400493          	li	s1,-12
		maddr = net_if_ipv6_maddr_add(iface, addr);
40019e48:	84cf40ef          	jal	ra,4000de94 <net_if_ipv6_maddr_add>
40019e4c:	00050413          	mv	s0,a0
		if (!maddr) {
40019e50:	fc0508e3          	beqz	a0,40019e20 <net_ipv6_mld_join+0x44>
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_MLD)) {
40019e54:	00c12503          	lw	a0,12(sp)
40019e58:	00c00593          	li	a1,12
		return 0;
40019e5c:	00000493          	li	s1,0
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_MLD)) {
40019e60:	b65ff0ef          	jal	ra,400199c4 <net_if_flag_is_set>
40019e64:	fa051ee3          	bnez	a0,40019e20 <net_ipv6_mld_join+0x44>
	if (!net_if_is_up(iface)) {
40019e68:	00c12483          	lw	s1,12(sp)
	return net_if_flag_is_set(iface, NET_IF_UP) &&
40019e6c:	00000593          	li	a1,0
40019e70:	00048513          	mv	a0,s1
40019e74:	b51ff0ef          	jal	ra,400199c4 <net_if_flag_is_set>
40019e78:	00051663          	bnez	a0,40019e84 <net_ipv6_mld_join+0xa8>
		return -ENETDOWN;
40019e7c:	f8d00493          	li	s1,-115
40019e80:	fa1ff06f          	j	40019e20 <net_ipv6_mld_join+0x44>
	       net_if_flag_is_set(iface, NET_IF_RUNNING);
40019e84:	00800593          	li	a1,8
40019e88:	00048513          	mv	a0,s1
40019e8c:	b39ff0ef          	jal	ra,400199c4 <net_if_flag_is_set>
	return net_if_flag_is_set(iface, NET_IF_UP) &&
40019e90:	fe0506e3          	beqz	a0,40019e7c <net_ipv6_mld_join+0xa0>
	ret = mld_send_generic(iface, addr, NET_IPV6_MLDv2_MODE_IS_EXCLUDE);
40019e94:	00c12503          	lw	a0,12(sp)
40019e98:	00200613          	li	a2,2
40019e9c:	00090593          	mv	a1,s2
40019ea0:	c7dff0ef          	jal	ra,40019b1c <mld_send_generic>
40019ea4:	00050493          	mv	s1,a0
	if (ret < 0) {
40019ea8:	f6054ce3          	bltz	a0,40019e20 <net_ipv6_mld_join+0x44>
	net_if_ipv6_maddr_join(maddr);
40019eac:	00040513          	mv	a0,s0
40019eb0:	8e8f40ef          	jal	ra,4000df98 <net_if_ipv6_maddr_join>
	net_if_mcast_monitor(iface, &maddr->address, true);
40019eb4:	00c12503          	lw	a0,12(sp)
40019eb8:	00040593          	mv	a1,s0
40019ebc:	00100613          	li	a2,1
40019ec0:	d29f20ef          	jal	ra,4000cbe8 <net_if_mcast_monitor>
	net_mgmt_event_notify_with_info(NET_EVENT_IPV6_MCAST_JOIN, iface,
40019ec4:	00c12583          	lw	a1,12(sp)
40019ec8:	e0600537          	lui	a0,0xe0600
40019ecc:	01000693          	li	a3,16
40019ed0:	00440613          	addi	a2,s0,4
40019ed4:	00750513          	addi	a0,a0,7 # e0600007 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600008>
40019ed8:	858f70ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
	return ret;
40019edc:	f45ff06f          	j	40019e20 <net_ipv6_mld_join+0x44>

40019ee0 <net_ipv6_mld_leave>:
{
40019ee0:	fe010113          	addi	sp,sp,-32
40019ee4:	01212823          	sw	s2,16(sp)
40019ee8:	00058913          	mv	s2,a1
40019eec:	00a12623          	sw	a0,12(sp)
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
40019ef0:	00c10593          	addi	a1,sp,12
40019ef4:	00090513          	mv	a0,s2
{
40019ef8:	00812c23          	sw	s0,24(sp)
40019efc:	00112e23          	sw	ra,28(sp)
40019f00:	00912a23          	sw	s1,20(sp)
	maddr = net_if_ipv6_maddr_lookup(addr, &iface);
40019f04:	e71f30ef          	jal	ra,4000dd74 <net_if_ipv6_maddr_lookup>
		return -ENOENT;
40019f08:	ffe00413          	li	s0,-2
	if (!maddr) {
40019f0c:	06050863          	beqz	a0,40019f7c <net_ipv6_mld_leave+0x9c>
40019f10:	00050493          	mv	s1,a0
	if (!net_if_ipv6_maddr_rm(iface, addr)) {
40019f14:	00c12503          	lw	a0,12(sp)
40019f18:	00090593          	mv	a1,s2
		return -EINVAL;
40019f1c:	fea00413          	li	s0,-22
	if (!net_if_ipv6_maddr_rm(iface, addr)) {
40019f20:	95df30ef          	jal	ra,4000d87c <net_if_ipv6_maddr_rm>
40019f24:	04050c63          	beqz	a0,40019f7c <net_ipv6_mld_leave+0x9c>
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_MLD)) {
40019f28:	00c12503          	lw	a0,12(sp)
40019f2c:	00c00593          	li	a1,12
		return 0;
40019f30:	00000413          	li	s0,0
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_MLD)) {
40019f34:	a91ff0ef          	jal	ra,400199c4 <net_if_flag_is_set>
40019f38:	04051263          	bnez	a0,40019f7c <net_ipv6_mld_leave+0x9c>
	ret = mld_send_generic(iface, addr, NET_IPV6_MLDv2_MODE_IS_INCLUDE);
40019f3c:	00c12503          	lw	a0,12(sp)
40019f40:	00100613          	li	a2,1
40019f44:	00090593          	mv	a1,s2
40019f48:	bd5ff0ef          	jal	ra,40019b1c <mld_send_generic>
40019f4c:	00050413          	mv	s0,a0
	if (ret < 0) {
40019f50:	02054663          	bltz	a0,40019f7c <net_ipv6_mld_leave+0x9c>
	net_if_mcast_monitor(iface, &maddr->address, false);
40019f54:	00c12503          	lw	a0,12(sp)
40019f58:	00000613          	li	a2,0
40019f5c:	00048593          	mv	a1,s1
40019f60:	c89f20ef          	jal	ra,4000cbe8 <net_if_mcast_monitor>
	net_mgmt_event_notify_with_info(NET_EVENT_IPV6_MCAST_LEAVE, iface,
40019f64:	00c12583          	lw	a1,12(sp)
40019f68:	e0600537          	lui	a0,0xe0600
40019f6c:	01000693          	li	a3,16
40019f70:	00448613          	addi	a2,s1,4
40019f74:	00850513          	addi	a0,a0,8 # e0600008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600009>
40019f78:	fb9f60ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
}
40019f7c:	01c12083          	lw	ra,28(sp)
40019f80:	00040513          	mv	a0,s0
40019f84:	01812403          	lw	s0,24(sp)
40019f88:	01412483          	lw	s1,20(sp)
40019f8c:	01012903          	lw	s2,16(sp)
40019f90:	02010113          	addi	sp,sp,32
40019f94:	00008067          	ret

40019f98 <net_ipv6_mld_init>:
	.handler = handle_mld_query,
};

void net_ipv6_mld_init(void)
{
	net_icmpv6_register_handler(&mld_query_input_handler);
40019f98:	4003c537          	lui	a0,0x4003c
40019f9c:	67850513          	addi	a0,a0,1656 # 4003c678 <mld_query_input_handler>
40019fa0:	c59fb06f          	j	40015bf8 <net_icmpv6_register_handler>

40019fa4 <net_route_nexthop_remove>:
static K_MUTEX_DEFINE(lock);

static void net_route_nexthop_remove(struct net_nbr *nbr)
{
	NET_DBG("Nexthop %p removed", nbr);
}
40019fa4:	00008067          	ret

40019fa8 <nbr_new>:
}

static struct net_nbr *nbr_new(struct net_if *iface,
			       struct in6_addr *addr,
			       uint8_t prefix_len)
{
40019fa8:	fd010113          	addi	sp,sp,-48
40019fac:	03212023          	sw	s2,32(sp)
40019fb0:	00050913          	mv	s2,a0
	struct net_nbr *nbr = net_nbr_get(&net_nbr_routes.table);
40019fb4:	4003c537          	lui	a0,0x4003c
40019fb8:	68450513          	addi	a0,a0,1668 # 4003c684 <net_nbr_routes>
{
40019fbc:	02812423          	sw	s0,40(sp)
40019fc0:	02912223          	sw	s1,36(sp)
40019fc4:	02112623          	sw	ra,44(sp)
40019fc8:	00b12623          	sw	a1,12(sp)
40019fcc:	00060493          	mv	s1,a2
	struct net_nbr *nbr = net_nbr_get(&net_nbr_routes.table);
40019fd0:	cf4fc0ef          	jal	ra,400164c4 <net_nbr_get>
40019fd4:	00050413          	mv	s0,a0

	if (!nbr) {
40019fd8:	02050a63          	beqz	a0,4001a00c <nbr_new+0x64>
		return NULL;
	}

	nbr->iface = iface;

	net_ipaddr_copy(&net_route_data(nbr)->addr, addr);
40019fdc:	00c12583          	lw	a1,12(sp)
	nbr->iface = iface;
40019fe0:	01252423          	sw	s2,8(a0)
	return (struct net_route_entry *)nbr->data;
40019fe4:	00c52903          	lw	s2,12(a0)
	net_ipaddr_copy(&net_route_data(nbr)->addr, addr);
40019fe8:	01000613          	li	a2,16
40019fec:	01010513          	addi	a0,sp,16
40019ff0:	85cef0ef          	jal	ra,4000904c <memcpy>
40019ff4:	01000613          	li	a2,16
40019ff8:	01010593          	addi	a1,sp,16
40019ffc:	02090513          	addi	a0,s2,32
4001a000:	84cef0ef          	jal	ra,4000904c <memcpy>
	return (struct net_route_entry *)nbr->data;
4001a004:	00c42783          	lw	a5,12(s0)
	net_route_data(nbr)->prefix_len = prefix_len;
4001a008:	02978823          	sb	s1,48(a5)
		nbr->idx, nbr, iface,
		net_sprint_ipv6_addr(&net_route_data(nbr)->addr),
		prefix_len);

	return nbr;
}
4001a00c:	02c12083          	lw	ra,44(sp)
4001a010:	00040513          	mv	a0,s0
4001a014:	02812403          	lw	s0,40(sp)
4001a018:	02412483          	lw	s1,36(sp)
4001a01c:	02012903          	lw	s2,32(sp)
4001a020:	03010113          	addi	sp,sp,48
4001a024:	00008067          	ret

4001a028 <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
4001a028:	00058613          	mv	a2,a1
4001a02c:	00050593          	mv	a1,a0
	return z_impl_k_mutex_lock(mutex, timeout);
4001a030:	4003d537          	lui	a0,0x4003d
4001a034:	ac450513          	addi	a0,a0,-1340 # 4003cac4 <lock>
4001a038:	0450e06f          	j	4002887c <z_impl_k_mutex_lock>

4001a03c <k_mutex_unlock.constprop.0.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
4001a03c:	4003d537          	lui	a0,0x4003d
4001a040:	ac450513          	addi	a0,a0,-1340 # 4003cac4 <lock>
4001a044:	1950e06f          	j	400289d8 <z_impl_k_mutex_unlock>

4001a048 <sys_slist_find_and_remove.isra.0>:
	return list->head;
4001a048:	00052783          	lw	a5,0(a0)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4001a04c:	00000713          	li	a4,0
4001a050:	00079463          	bnez	a5,4001a058 <sys_slist_find_and_remove.isra.0+0x10>
4001a054:	00008067          	ret
4001a058:	02b79c63          	bne	a5,a1,4001a090 <sys_slist_find_and_remove.isra.0+0x48>
	return node->next;
4001a05c:	0005a783          	lw	a5,0(a1)
Z_GENLIST_REMOVE(slist, snode)
4001a060:	00071e63          	bnez	a4,4001a07c <sys_slist_find_and_remove.isra.0+0x34>
4001a064:	00452703          	lw	a4,4(a0)
	list->head = node;
4001a068:	00f52023          	sw	a5,0(a0)
Z_GENLIST_REMOVE(slist, snode)
4001a06c:	00e59463          	bne	a1,a4,4001a074 <sys_slist_find_and_remove.isra.0+0x2c>
	list->tail = node;
4001a070:	00f52223          	sw	a5,4(a0)
	parent->next = child;
4001a074:	0005a023          	sw	zero,0(a1)
Z_GENLIST_REMOVE(slist, snode)
4001a078:	00008067          	ret
	parent->next = child;
4001a07c:	00f72023          	sw	a5,0(a4)
Z_GENLIST_REMOVE(slist, snode)
4001a080:	00452783          	lw	a5,4(a0)
4001a084:	fef598e3          	bne	a1,a5,4001a074 <sys_slist_find_and_remove.isra.0+0x2c>
	list->tail = node;
4001a088:	00e52223          	sw	a4,4(a0)
}
4001a08c:	fe9ff06f          	j	4001a074 <sys_slist_find_and_remove.isra.0+0x2c>
	return node->next;
4001a090:	00078713          	mv	a4,a5
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4001a094:	0007a783          	lw	a5,0(a5)
4001a098:	fb9ff06f          	j	4001a050 <sys_slist_find_and_remove.isra.0+0x8>

4001a09c <net_route_entries_table_clear>:
static void net_route_entries_table_clear(struct net_nbr_table *table)
4001a09c:	00008067          	ret

4001a0a0 <net_route_entry_remove>:
static void net_route_entry_remove(struct net_nbr *nbr)
4001a0a0:	00008067          	ret

4001a0a4 <net_route_get_nbr>:
{
4001a0a4:	fe010113          	addi	sp,sp,-32
4001a0a8:	00812c23          	sw	s0,24(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001a0ac:	fff00593          	li	a1,-1
{
4001a0b0:	00050413          	mv	s0,a0
	k_mutex_lock(&lock, K_FOREVER);
4001a0b4:	fff00513          	li	a0,-1
{
4001a0b8:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001a0bc:	f6dff0ef          	jal	ra,4001a028 <k_mutex_lock.constprop.0.isra.0>
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
4001a0c0:	4003c7b7          	lui	a5,0x4003c
4001a0c4:	69078693          	addi	a3,a5,1680 # 4003c690 <net_route_entries_pool>
4001a0c8:	00000713          	li	a4,0
4001a0cc:	69078793          	addi	a5,a5,1680
4001a0d0:	00800613          	li	a2,8
		if (!nbr->ref) {
4001a0d4:	0006c583          	lbu	a1,0(a3)
4001a0d8:	02058a63          	beqz	a1,4001a10c <net_route_get_nbr+0x68>
		if (nbr->data == (uint8_t *)route) {
4001a0dc:	00c6a583          	lw	a1,12(a3)
4001a0e0:	02859663          	bne	a1,s0,4001a10c <net_route_get_nbr+0x68>
	return &net_route_entries_pool[idx].nbr;
4001a0e4:	04800693          	li	a3,72
4001a0e8:	02d70733          	mul	a4,a4,a3
4001a0ec:	00e78533          	add	a0,a5,a4
4001a0f0:	00a12623          	sw	a0,12(sp)
			k_mutex_unlock(&lock);
4001a0f4:	f49ff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>
			return nbr;
4001a0f8:	00c12503          	lw	a0,12(sp)
}
4001a0fc:	01c12083          	lw	ra,28(sp)
4001a100:	01812403          	lw	s0,24(sp)
4001a104:	02010113          	addi	sp,sp,32
4001a108:	00008067          	ret
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
4001a10c:	00170713          	addi	a4,a4,1
4001a110:	04868693          	addi	a3,a3,72
4001a114:	fcc710e3          	bne	a4,a2,4001a0d4 <net_route_get_nbr+0x30>
	k_mutex_unlock(&lock);
4001a118:	f25ff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>
	return NULL;
4001a11c:	00000513          	li	a0,0
4001a120:	fddff06f          	j	4001a0fc <net_route_get_nbr+0x58>

4001a124 <net_route_lookup>:
	sys_slist_prepend(&routes, &route->node);
}

struct net_route_entry *net_route_lookup(struct net_if *iface,
					 struct in6_addr *dst)
{
4001a124:	fd010113          	addi	sp,sp,-48
4001a128:	02912223          	sw	s1,36(sp)
4001a12c:	4003c4b7          	lui	s1,0x4003c
4001a130:	01312e23          	sw	s3,28(sp)
4001a134:	01412c23          	sw	s4,24(sp)
4001a138:	00050993          	mv	s3,a0
4001a13c:	00058a13          	mv	s4,a1
	struct net_route_entry *route, *found = NULL;
	uint8_t longest_match = 0U;
	int i;

	k_mutex_lock(&lock, K_FOREVER);
4001a140:	fff00513          	li	a0,-1
4001a144:	fff00593          	li	a1,-1
4001a148:	69048493          	addi	s1,s1,1680 # 4003c690 <net_route_entries_pool>
{
4001a14c:	01612823          	sw	s6,16(sp)
4001a150:	01712623          	sw	s7,12(sp)
4001a154:	01912223          	sw	s9,4(sp)
4001a158:	02112623          	sw	ra,44(sp)
4001a15c:	02812423          	sw	s0,40(sp)
4001a160:	03212023          	sw	s2,32(sp)
4001a164:	01512a23          	sw	s5,20(sp)
4001a168:	01812423          	sw	s8,8(sp)
4001a16c:	1f848c93          	addi	s9,s1,504
	k_mutex_lock(&lock, K_FOREVER);
4001a170:	eb9ff0ef          	jal	ra,4001a028 <k_mutex_lock.constprop.0.isra.0>
	uint8_t longest_match = 0U;
4001a174:	00000b93          	li	s7,0
	struct net_route_entry *route, *found = NULL;
4001a178:	00000b13          	li	s6,0

	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
		struct net_nbr *nbr = get_nbr(i);

		if (!nbr->ref) {
4001a17c:	0004c783          	lbu	a5,0(s1)
4001a180:	00078863          	beqz	a5,4001a190 <net_route_lookup+0x6c>
			continue;
		}

		if (iface && nbr->iface != iface) {
4001a184:	02098063          	beqz	s3,4001a1a4 <net_route_lookup+0x80>
4001a188:	0084a783          	lw	a5,8(s1)
4001a18c:	01378c63          	beq	a5,s3,4001a1a4 <net_route_lookup+0x80>
	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
4001a190:	11948463          	beq	s1,s9,4001a298 <net_route_lookup+0x174>
4001a194:	04848493          	addi	s1,s1,72
4001a198:	000b0413          	mv	s0,s6
{
4001a19c:	00040b13          	mv	s6,s0
4001a1a0:	fddff06f          	j	4001a17c <net_route_lookup+0x58>
	return (struct net_route_entry *)nbr->data;
4001a1a4:	00c4a403          	lw	s0,12(s1)
			continue;
		}

		route = net_route_data(nbr);

		if (route->prefix_len >= longest_match &&
4001a1a8:	03044903          	lbu	s2,48(s0)
4001a1ac:	ff7962e3          	bltu	s2,s7,4001a190 <net_route_lookup+0x6c>
	if (length > 128) {
4001a1b0:	08000793          	li	a5,128
4001a1b4:	fd27eee3          	bltu	a5,s2,4001a190 <net_route_lookup+0x6c>
		    net_ipv6_is_prefix(dst->s6_addr,
				       route->addr.s6_addr,
4001a1b8:	02040a93          	addi	s5,s0,32
	if (memcmp(addr1, addr2, bytes)) {
4001a1bc:	00395c13          	srli	s8,s2,0x3
4001a1c0:	000c0613          	mv	a2,s8
4001a1c4:	000a8593          	mv	a1,s5
4001a1c8:	000a0513          	mv	a0,s4
4001a1cc:	e01ee0ef          	jal	ra,40008fcc <memcmp>
4001a1d0:	fc0510e3          	bnez	a0,4001a190 <net_route_lookup+0x6c>
4001a1d4:	41200933          	neg	s2,s2
4001a1d8:	00797913          	andi	s2,s2,7
	if (!remain) {
4001a1dc:	02090c63          	beqz	s2,4001a214 <net_route_lookup+0xf0>
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
4001a1e0:	018a07b3          	add	a5,s4,s8
4001a1e4:	018a8ab3          	add	s5,s5,s8
4001a1e8:	0007c783          	lbu	a5,0(a5)
4001a1ec:	000ac703          	lbu	a4,0(s5)
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
4001a1f0:	00800693          	li	a3,8
4001a1f4:	412686b3          	sub	a3,a3,s2
	return (addr1[bytes] & mask) == (addr2[bytes] & mask);
4001a1f8:	00e7c733          	xor	a4,a5,a4
	mask = ((0xff << (8 - remain)) ^ 0xff) << remain;
4001a1fc:	0ff00793          	li	a5,255
4001a200:	00d797b3          	sll	a5,a5,a3
4001a204:	0ff7c793          	xori	a5,a5,255
4001a208:	012797b3          	sll	a5,a5,s2
		if (route->prefix_len >= longest_match &&
4001a20c:	00f777b3          	and	a5,a4,a5
4001a210:	f80790e3          	bnez	a5,4001a190 <net_route_lookup+0x6c>
				       route->prefix_len)) {
			found = route;
			longest_match = route->prefix_len;
4001a214:	03044b83          	lbu	s7,48(s0)
	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
4001a218:	01948a63          	beq	s1,s9,4001a22c <net_route_lookup+0x108>
4001a21c:	018b9793          	slli	a5,s7,0x18
4001a220:	4187d793          	srai	a5,a5,0x18
4001a224:	04848493          	addi	s1,s1,72
4001a228:	f607dae3          	bgez	a5,4001a19c <net_route_lookup+0x78>
		}
	}

	if (found) {
4001a22c:	02040863          	beqz	s0,4001a25c <net_route_lookup+0x138>
	sys_slist_find_and_remove(&routes, &route->node);
4001a230:	400314b7          	lui	s1,0x40031
4001a234:	00040593          	mv	a1,s0
4001a238:	ab448513          	addi	a0,s1,-1356 # 40030ab4 <routes>
4001a23c:	e0dff0ef          	jal	ra,4001a048 <sys_slist_find_and_remove.isra.0>
	return list->head;
4001a240:	ab448793          	addi	a5,s1,-1356
4001a244:	0007a703          	lw	a4,0(a5)
	parent->next = child;
4001a248:	00e42023          	sw	a4,0(s0)
Z_GENLIST_PREPEND(slist, snode)
4001a24c:	0047a703          	lw	a4,4(a5)
	list->head = node;
4001a250:	0087a023          	sw	s0,0(a5)
Z_GENLIST_PREPEND(slist, snode)
4001a254:	00071463          	bnez	a4,4001a25c <net_route_lookup+0x138>
	list->tail = node;
4001a258:	0087a223          	sw	s0,4(a5)
		net_route_info("Found", found, dst);

		update_route_access(found);
	}

	k_mutex_unlock(&lock);
4001a25c:	de1ff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>
	return found;
}
4001a260:	02c12083          	lw	ra,44(sp)
4001a264:	00040513          	mv	a0,s0
4001a268:	02812403          	lw	s0,40(sp)
4001a26c:	02412483          	lw	s1,36(sp)
4001a270:	02012903          	lw	s2,32(sp)
4001a274:	01c12983          	lw	s3,28(sp)
4001a278:	01812a03          	lw	s4,24(sp)
4001a27c:	01412a83          	lw	s5,20(sp)
4001a280:	01012b03          	lw	s6,16(sp)
4001a284:	00c12b83          	lw	s7,12(sp)
4001a288:	00812c03          	lw	s8,8(sp)
4001a28c:	00412c83          	lw	s9,4(sp)
4001a290:	03010113          	addi	sp,sp,48
4001a294:	00008067          	ret
	for (i = 0; i < CONFIG_NET_MAX_ROUTES && longest_match < 128; i++) {
4001a298:	000b0413          	mv	s0,s6
4001a29c:	f91ff06f          	j	4001a22c <net_route_lookup+0x108>

4001a2a0 <net_route_update_lifetime>:
{
	NET_DBG("Updating route lifetime of %s to %u secs",
		net_sprint_ipv6_addr(&route->addr),
		lifetime);

	if (!route) {
4001a2a0:	0c050e63          	beqz	a0,4001a37c <net_route_update_lifetime+0xdc>
{
4001a2a4:	fe010113          	addi	sp,sp,-32
4001a2a8:	00912a23          	sw	s1,20(sp)
4001a2ac:	01312623          	sw	s3,12(sp)
4001a2b0:	00050493          	mv	s1,a0
4001a2b4:	00058993          	mv	s3,a1
		return;
	}

	k_mutex_lock(&lock, K_FOREVER);
4001a2b8:	fff00513          	li	a0,-1
4001a2bc:	fff00593          	li	a1,-1
{
4001a2c0:	00812c23          	sw	s0,24(sp)
4001a2c4:	01212823          	sw	s2,16(sp)
4001a2c8:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001a2cc:	d5dff0ef          	jal	ra,4001a028 <k_mutex_lock.constprop.0.isra.0>

	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
4001a2d0:	fff00713          	li	a4,-1
4001a2d4:	0314c783          	lbu	a5,49(s1)
		route->is_infinite = true;

		(void)sys_slist_find_and_remove(&active_route_lifetime_timers,
4001a2d8:	01048913          	addi	s2,s1,16
4001a2dc:	40031437          	lui	s0,0x40031
	if (lifetime == NET_IPV6_ND_INFINITE_LIFETIME) {
4001a2e0:	02e99a63          	bne	s3,a4,4001a314 <net_route_update_lifetime+0x74>
		route->is_infinite = true;
4001a2e4:	0047e793          	ori	a5,a5,4
4001a2e8:	02f488a3          	sb	a5,49(s1)
		(void)sys_slist_find_and_remove(&active_route_lifetime_timers,
4001a2ec:	00090593          	mv	a1,s2
4001a2f0:	aac40513          	addi	a0,s0,-1364 # 40030aac <active_route_lifetime_timers>
4001a2f4:	d55ff0ef          	jal	ra,4001a048 <sys_slist_find_and_remove.isra.0>
				 &route->lifetime.node);
		k_work_reschedule(&route_lifetime_timer, K_NO_WAIT);
	}

	k_mutex_unlock(&lock);
}
4001a2f8:	01812403          	lw	s0,24(sp)
4001a2fc:	01c12083          	lw	ra,28(sp)
4001a300:	01412483          	lw	s1,20(sp)
4001a304:	01012903          	lw	s2,16(sp)
4001a308:	00c12983          	lw	s3,12(sp)
4001a30c:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
4001a310:	d2dff06f          	j	4001a03c <k_mutex_unlock.constprop.0.isra.0>
		route->is_infinite = false;
4001a314:	ffb7f793          	andi	a5,a5,-5
4001a318:	02f488a3          	sb	a5,49(s1)
	return z_impl_k_uptime_ticks();
4001a31c:	099100ef          	jal	ra,4002abb4 <z_impl_k_uptime_ticks>
		net_timeout_set(&route->lifetime, lifetime, k_uptime_get_32());
4001a320:	00a00613          	li	a2,10
4001a324:	02a60633          	mul	a2,a2,a0
4001a328:	00098593          	mv	a1,s3
4001a32c:	00090513          	mv	a0,s2
4001a330:	f5cf50ef          	jal	ra,4000fa8c <net_timeout_set>
		(void)sys_slist_find_and_remove(&active_route_lifetime_timers,
4001a334:	aac40513          	addi	a0,s0,-1364
4001a338:	00090593          	mv	a1,s2
4001a33c:	d0dff0ef          	jal	ra,4001a048 <sys_slist_find_and_remove.isra.0>
	return list->tail;
4001a340:	aac40513          	addi	a0,s0,-1364
4001a344:	00452783          	lw	a5,4(a0)
	parent->next = child;
4001a348:	0004a823          	sw	zero,16(s1)
Z_GENLIST_APPEND(slist, snode)
4001a34c:	02079263          	bnez	a5,4001a370 <net_route_update_lifetime+0xd0>
	list->tail = node;
4001a350:	01252223          	sw	s2,4(a0)
	list->head = node;
4001a354:	01252023          	sw	s2,0(a0)
		k_work_reschedule(&route_lifetime_timer, K_NO_WAIT);
4001a358:	40031537          	lui	a0,0x40031
4001a35c:	00000593          	li	a1,0
4001a360:	00000613          	li	a2,0
4001a364:	0d850513          	addi	a0,a0,216 # 400310d8 <route_lifetime_timer>
4001a368:	2bc0f0ef          	jal	ra,40029624 <k_work_reschedule>
4001a36c:	f8dff06f          	j	4001a2f8 <net_route_update_lifetime+0x58>
	parent->next = child;
4001a370:	0127a023          	sw	s2,0(a5)
	list->tail = node;
4001a374:	01252223          	sw	s2,4(a0)
}
4001a378:	fe1ff06f          	j	4001a358 <net_route_update_lifetime+0xb8>
4001a37c:	00008067          	ret

4001a380 <net_route_del>:
	struct net_route_nexthop *nexthop_route;
#if defined(CONFIG_NET_MGMT_EVENT_INFO)
       struct net_event_ipv6_route info;
#endif

	if (!route) {
4001a380:	0e050063          	beqz	a0,4001a460 <net_route_del+0xe0>
{
4001a384:	ff010113          	addi	sp,sp,-16
4001a388:	00812423          	sw	s0,8(sp)
		return -EINVAL;
	}

	k_mutex_lock(&lock, K_FOREVER);
4001a38c:	fff00593          	li	a1,-1
4001a390:	00050413          	mv	s0,a0
4001a394:	fff00513          	li	a0,-1
{
4001a398:	00112623          	sw	ra,12(sp)
4001a39c:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001a3a0:	c89ff0ef          	jal	ra,4001a028 <k_mutex_lock.constprop.0.isra.0>
4001a3a4:	00c42583          	lw	a1,12(s0)
4001a3a8:	e0600537          	lui	a0,0xe0600
4001a3ac:	00000693          	li	a3,0
4001a3b0:	00000613          	li	a2,0
4001a3b4:	00c50513          	addi	a0,a0,12 # e060000c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000d>
4001a3b8:	b79f60ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
					sizeof(struct net_event_ipv6_route));
#else
	net_mgmt_event_notify(NET_EVENT_IPV6_ROUTE_DEL, route->iface);
#endif

	if (!route->is_infinite) {
4001a3bc:	03144783          	lbu	a5,49(s0)
4001a3c0:	0047f793          	andi	a5,a5,4
4001a3c4:	02079463          	bnez	a5,4001a3ec <net_route_del+0x6c>
		sys_slist_find_and_remove(&active_route_lifetime_timers,
4001a3c8:	400314b7          	lui	s1,0x40031
4001a3cc:	01040593          	addi	a1,s0,16
4001a3d0:	aac48513          	addi	a0,s1,-1364 # 40030aac <active_route_lifetime_timers>
4001a3d4:	c75ff0ef          	jal	ra,4001a048 <sys_slist_find_and_remove.isra.0>
					  &route->lifetime.node);

		if (sys_slist_is_empty(&active_route_lifetime_timers)) {
4001a3d8:	aac4a783          	lw	a5,-1364(s1)
4001a3dc:	00079863          	bnez	a5,4001a3ec <net_route_del+0x6c>
			k_work_cancel_delayable(&route_lifetime_timer);
4001a3e0:	40031537          	lui	a0,0x40031
4001a3e4:	0d850513          	addi	a0,a0,216 # 400310d8 <route_lifetime_timer>
4001a3e8:	2540f0ef          	jal	ra,4002963c <k_work_cancel_delayable>
		}
	}

	sys_slist_find_and_remove(&routes, &route->node);
4001a3ec:	40031537          	lui	a0,0x40031
4001a3f0:	00040593          	mv	a1,s0
4001a3f4:	ab450513          	addi	a0,a0,-1356 # 40030ab4 <routes>
4001a3f8:	c51ff0ef          	jal	ra,4001a048 <sys_slist_find_and_remove.isra.0>

	nbr = net_route_get_nbr(route);
4001a3fc:	00040513          	mv	a0,s0
4001a400:	ca5ff0ef          	jal	ra,4001a0a4 <net_route_get_nbr>
4001a404:	00050493          	mv	s1,a0
	if (!nbr) {
4001a408:	02051063          	bnez	a0,4001a428 <net_route_del+0xa8>
		k_mutex_unlock(&lock);
4001a40c:	c31ff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>
		return -ENOENT;
4001a410:	ffe00513          	li	a0,-2

	nbr_free(nbr);

	k_mutex_unlock(&lock);
	return 0;
}
4001a414:	00c12083          	lw	ra,12(sp)
4001a418:	00812403          	lw	s0,8(sp)
4001a41c:	00412483          	lw	s1,4(sp)
4001a420:	01010113          	addi	sp,sp,16
4001a424:	00008067          	ret
	return list->head;
4001a428:	00442403          	lw	s0,4(s0)
	SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route, node) {
4001a42c:	00041c63          	bnez	s0,4001a444 <net_route_del+0xc4>
	net_nbr_unref(nbr);
4001a430:	00048513          	mv	a0,s1
4001a434:	85cfc0ef          	jal	ra,40016490 <net_nbr_unref>
	k_mutex_unlock(&lock);
4001a438:	c05ff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>
	return 0;
4001a43c:	00000513          	li	a0,0
4001a440:	fd5ff06f          	j	4001a414 <net_route_del+0x94>
		if (!nexthop_route->nbr) {
4001a444:	00442503          	lw	a0,4(s0)
4001a448:	00050863          	beqz	a0,4001a458 <net_route_del+0xd8>
	net_nbr_unref(nbr);
4001a44c:	844fc0ef          	jal	ra,40016490 <net_nbr_unref>
	net_nbr_unref(nbr);
4001a450:	fec40513          	addi	a0,s0,-20
4001a454:	83cfc0ef          	jal	ra,40016490 <net_nbr_unref>
	return node->next;
4001a458:	00042403          	lw	s0,0(s0)
4001a45c:	fd1ff06f          	j	4001a42c <net_route_del+0xac>
		return -EINVAL;
4001a460:	fea00513          	li	a0,-22
}
4001a464:	00008067          	ret

4001a468 <route_lifetime_timeout>:
{
4001a468:	fe010113          	addi	sp,sp,-32
4001a46c:	00112e23          	sw	ra,28(sp)
4001a470:	00812c23          	sw	s0,24(sp)
4001a474:	00912a23          	sw	s1,20(sp)
4001a478:	01212823          	sw	s2,16(sp)
4001a47c:	01312623          	sw	s3,12(sp)
4001a480:	01412423          	sw	s4,8(sp)
4001a484:	01512223          	sw	s5,4(sp)
4001a488:	72c100ef          	jal	ra,4002abb4 <z_impl_k_uptime_ticks>
4001a48c:	00050913          	mv	s2,a0
	k_mutex_lock(&lock, K_FOREVER);
4001a490:	fff00593          	li	a1,-1
4001a494:	fff00513          	li	a0,-1
	return list->head;
4001a498:	40031a37          	lui	s4,0x40031
4001a49c:	b8dff0ef          	jal	ra,4001a028 <k_mutex_lock.constprop.0.isra.0>
4001a4a0:	aaca2403          	lw	s0,-1364(s4) # 40030aac <active_route_lifetime_timers>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_route_lifetime_timers,
4001a4a4:	0a040263          	beqz	s0,4001a548 <route_lifetime_timeout+0xe0>
	return node->next;
4001a4a8:	00042483          	lw	s1,0(s0)
4001a4ac:	00048463          	beqz	s1,4001a4b4 <route_lifetime_timeout+0x4c>
4001a4b0:	ff048493          	addi	s1,s1,-16
			return t * ((uint64_t)to_hz / from_hz);
4001a4b4:	00a00993          	li	s3,10
4001a4b8:	032989b3          	mul	s3,s3,s2
4001a4bc:	ff040413          	addi	s0,s0,-16
4001a4c0:	fff00913          	li	s2,-1
4001a4c4:	00c0006f          	j	4001a4d0 <route_lifetime_timeout+0x68>
4001a4c8:	00048413          	mv	s0,s1
4001a4cc:	00078493          	mv	s1,a5
		struct net_timeout *timeout = &current->lifetime;
4001a4d0:	01040a93          	addi	s5,s0,16
		uint32_t this_update = net_timeout_evaluate(timeout,
4001a4d4:	00098593          	mv	a1,s3
4001a4d8:	000a8513          	mv	a0,s5
4001a4dc:	eb0f50ef          	jal	ra,4000fb8c <net_timeout_evaluate>
		if (this_update == 0U) {
4001a4e0:	02051663          	bnez	a0,4001a50c <route_lifetime_timeout+0xa4>
	sys_slist_find_and_remove(&active_route_lifetime_timers,
4001a4e4:	aaca0513          	addi	a0,s4,-1364
4001a4e8:	000a8593          	mv	a1,s5
4001a4ec:	b5dff0ef          	jal	ra,4001a048 <sys_slist_find_and_remove.isra.0>
	net_route_del(route);
4001a4f0:	00040513          	mv	a0,s0
4001a4f4:	e8dff0ef          	jal	ra,4001a380 <net_route_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_route_lifetime_timers,
4001a4f8:	02048063          	beqz	s1,4001a518 <route_lifetime_timeout+0xb0>
4001a4fc:	0104a783          	lw	a5,16(s1)
4001a500:	fc0784e3          	beqz	a5,4001a4c8 <route_lifetime_timeout+0x60>
4001a504:	ff078793          	addi	a5,a5,-16
4001a508:	fc1ff06f          	j	4001a4c8 <route_lifetime_timeout+0x60>
		if (this_update < next_update) {
4001a50c:	ff2576e3          	bgeu	a0,s2,4001a4f8 <route_lifetime_timeout+0x90>
4001a510:	00050913          	mv	s2,a0
4001a514:	fe5ff06f          	j	4001a4f8 <route_lifetime_timeout+0x90>
	if (next_update != UINT32_MAX) {
4001a518:	fff00793          	li	a5,-1
4001a51c:	02f90663          	beq	s2,a5,4001a548 <route_lifetime_timeout+0xe0>
		t += off;
4001a520:	00990513          	addi	a0,s2,9
			return t / ((uint64_t)from_hz / to_hz);
4001a524:	00a00613          	li	a2,10
4001a528:	00000693          	li	a3,0
4001a52c:	012535b3          	sltu	a1,a0,s2
4001a530:	d89e50ef          	jal	ra,400002b8 <__udivdi3>
		k_work_reschedule(&route_lifetime_timer, K_MSEC(next_update));
4001a534:	00058613          	mv	a2,a1
4001a538:	00050593          	mv	a1,a0
4001a53c:	40031537          	lui	a0,0x40031
4001a540:	0d850513          	addi	a0,a0,216 # 400310d8 <route_lifetime_timer>
4001a544:	0e00f0ef          	jal	ra,40029624 <k_work_reschedule>
}
4001a548:	01812403          	lw	s0,24(sp)
4001a54c:	01c12083          	lw	ra,28(sp)
4001a550:	01412483          	lw	s1,20(sp)
4001a554:	01012903          	lw	s2,16(sp)
4001a558:	00c12983          	lw	s3,12(sp)
4001a55c:	00812a03          	lw	s4,8(sp)
4001a560:	00412a83          	lw	s5,4(sp)
4001a564:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&lock);
4001a568:	ad5ff06f          	j	4001a03c <k_mutex_unlock.constprop.0.isra.0>

4001a56c <net_route_del_by_nexthop>:

int net_route_del_by_nexthop(struct net_if *iface, struct in6_addr *nexthop)
{
4001a56c:	fe010113          	addi	sp,sp,-32
4001a570:	00812c23          	sw	s0,24(sp)
4001a574:	00912a23          	sw	s1,20(sp)
4001a578:	00050413          	mv	s0,a0
4001a57c:	00058493          	mv	s1,a1
	int i, ret;

	NET_ASSERT(iface);
	NET_ASSERT(nexthop);

	k_mutex_lock(&lock, K_FOREVER);
4001a580:	fff00513          	li	a0,-1
4001a584:	fff00593          	li	a1,-1
{
4001a588:	00112e23          	sw	ra,28(sp)
4001a58c:	01212823          	sw	s2,16(sp)
4001a590:	01312623          	sw	s3,12(sp)
4001a594:	01412423          	sw	s4,8(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001a598:	a91ff0ef          	jal	ra,4001a028 <k_mutex_lock.constprop.0.isra.0>

	nbr_nexthop = net_ipv6_nbr_lookup(iface, nexthop);
4001a59c:	00048593          	mv	a1,s1
4001a5a0:	00040513          	mv	a0,s0
4001a5a4:	4003c4b7          	lui	s1,0x4003c
4001a5a8:	e0cfd0ef          	jal	ra,40017bb4 <net_ipv6_nbr_lookup>
4001a5ac:	69048493          	addi	s1,s1,1680 # 4003c690 <net_route_entries_pool>
4001a5b0:	00050913          	mv	s2,a0

	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
4001a5b4:	24048a13          	addi	s4,s1,576
	int count = 0, status = 0;
4001a5b8:	00000993          	li	s3,0
4001a5bc:	00000413          	li	s0,0
	return (struct net_route_entry *)nbr->data;
4001a5c0:	00c4a503          	lw	a0,12(s1)
		struct net_nbr *nbr = get_nbr(i);
		struct net_route_entry *route = net_route_data(nbr);

		if (!route) {
4001a5c4:	02050063          	beqz	a0,4001a5e4 <net_route_del_by_nexthop+0x78>
	return list->head;
4001a5c8:	00452783          	lw	a5,4(a0)
			continue;
		}

		SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route,
4001a5cc:	00078c63          	beqz	a5,4001a5e4 <net_route_del_by_nexthop+0x78>
					     node) {
			if (nexthop_route->nbr == nbr_nexthop) {
4001a5d0:	0047a703          	lw	a4,4(a5)
4001a5d4:	05271863          	bne	a4,s2,4001a624 <net_route_del_by_nexthop+0xb8>
				/* This route contains this nexthop */
				ret = net_route_del(route);
4001a5d8:	da9ff0ef          	jal	ra,4001a380 <net_route_del>
				if (!ret) {
4001a5dc:	04051863          	bnez	a0,4001a62c <net_route_del_by_nexthop+0xc0>
					count++;
4001a5e0:	00140413          	addi	s0,s0,1
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
4001a5e4:	04848493          	addi	s1,s1,72
4001a5e8:	fd449ce3          	bne	s1,s4,4001a5c0 <net_route_del_by_nexthop+0x54>
				break;
			}
		}
	}

	k_mutex_unlock(&lock);
4001a5ec:	a51ff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>

	if (count) {
4001a5f0:	00041863          	bnez	s0,4001a600 <net_route_del_by_nexthop+0x94>
		return count;
	} else if (status < 0) {
4001a5f4:	00098413          	mv	s0,s3
4001a5f8:	01305463          	blez	s3,4001a600 <net_route_del_by_nexthop+0x94>
4001a5fc:	00000413          	li	s0,0
		return status;
	}

	return 0;
}
4001a600:	01c12083          	lw	ra,28(sp)
4001a604:	00040513          	mv	a0,s0
4001a608:	01812403          	lw	s0,24(sp)
4001a60c:	01412483          	lw	s1,20(sp)
4001a610:	01012903          	lw	s2,16(sp)
4001a614:	00c12983          	lw	s3,12(sp)
4001a618:	00812a03          	lw	s4,8(sp)
4001a61c:	02010113          	addi	sp,sp,32
4001a620:	00008067          	ret
	return node->next;
4001a624:	0007a783          	lw	a5,0(a5)
4001a628:	fa5ff06f          	j	4001a5cc <net_route_del_by_nexthop+0x60>
4001a62c:	00050993          	mv	s3,a0
4001a630:	fb5ff06f          	j	4001a5e4 <net_route_del_by_nexthop+0x78>

4001a634 <net_route_get_nexthop>:
struct in6_addr *net_route_get_nexthop(struct net_route_entry *route)
{
	struct net_route_nexthop *nexthop_route;
	struct net_ipv6_nbr_data *ipv6_nbr_data;

	if (!route) {
4001a634:	06050463          	beqz	a0,4001a69c <net_route_get_nexthop+0x68>
{
4001a638:	fe010113          	addi	sp,sp,-32
4001a63c:	00812c23          	sw	s0,24(sp)
		return NULL;
	}

	k_mutex_lock(&lock, K_FOREVER);
4001a640:	fff00593          	li	a1,-1
4001a644:	00050413          	mv	s0,a0
4001a648:	fff00513          	li	a0,-1
{
4001a64c:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001a650:	9d9ff0ef          	jal	ra,4001a028 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4001a654:	00442783          	lw	a5,4(s0)

	SYS_SLIST_FOR_EACH_CONTAINER(&route->nexthop, nexthop_route, node) {
4001a658:	02078c63          	beqz	a5,4001a690 <net_route_get_nexthop+0x5c>
4001a65c:	0047a703          	lw	a4,4(a5)
4001a660:	00c72503          	lw	a0,12(a4)
		struct in6_addr *addr;

		ipv6_nbr_data = net_ipv6_nbr_data(nexthop_route->nbr);
		if (ipv6_nbr_data) {
4001a664:	02050263          	beqz	a0,4001a688 <net_route_get_nexthop+0x54>
			addr = &ipv6_nbr_data->addr;
4001a668:	00450513          	addi	a0,a0,4
4001a66c:	00a12623          	sw	a0,12(sp)
			NET_ASSERT(addr);

			k_mutex_unlock(&lock);
4001a670:	9cdff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>
			return addr;
4001a674:	00c12503          	lw	a0,12(sp)
		}
	}

	k_mutex_unlock(&lock);
	return NULL;
}
4001a678:	01c12083          	lw	ra,28(sp)
4001a67c:	01812403          	lw	s0,24(sp)
4001a680:	02010113          	addi	sp,sp,32
4001a684:	00008067          	ret
	return node->next;
4001a688:	0007a783          	lw	a5,0(a5)
4001a68c:	fcdff06f          	j	4001a658 <net_route_get_nexthop+0x24>
	k_mutex_unlock(&lock);
4001a690:	9adff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>
		return NULL;
4001a694:	00000513          	li	a0,0
4001a698:	fe1ff06f          	j	4001a678 <net_route_get_nexthop+0x44>
4001a69c:	00000513          	li	a0,0
}
4001a6a0:	00008067          	ret

4001a6a4 <net_route_add>:
{
4001a6a4:	fe010113          	addi	sp,sp,-32
4001a6a8:	00112e23          	sw	ra,28(sp)
4001a6ac:	00812c23          	sw	s0,24(sp)
4001a6b0:	00912a23          	sw	s1,20(sp)
4001a6b4:	01212823          	sw	s2,16(sp)
4001a6b8:	01312623          	sw	s3,12(sp)
4001a6bc:	01412423          	sw	s4,8(sp)
4001a6c0:	01512223          	sw	s5,4(sp)
4001a6c4:	01612023          	sw	s6,0(sp)
4001a6c8:	00058a93          	mv	s5,a1
4001a6cc:	00060b13          	mv	s6,a2
4001a6d0:	00068993          	mv	s3,a3
4001a6d4:	00070a13          	mv	s4,a4
4001a6d8:	00078493          	mv	s1,a5
4001a6dc:	00050913          	mv	s2,a0
	if (net_ipv6_addr_cmp(addr, net_ipv6_unspecified_address())) {
4001a6e0:	d8cf60ef          	jal	ra,40010c6c <net_ipv6_unspecified_address>
4001a6e4:	00050593          	mv	a1,a0
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
4001a6e8:	01000613          	li	a2,16
4001a6ec:	000a8513          	mv	a0,s5
4001a6f0:	8ddee0ef          	jal	ra,40008fcc <memcmp>
		return NULL;
4001a6f4:	00000413          	li	s0,0
	if (net_ipv6_addr_cmp(addr, net_ipv6_unspecified_address())) {
4001a6f8:	02050463          	beqz	a0,4001a720 <net_route_add+0x7c>
	k_mutex_lock(&lock, K_FOREVER);
4001a6fc:	fff00513          	li	a0,-1
4001a700:	fff00593          	li	a1,-1
4001a704:	925ff0ef          	jal	ra,4001a028 <k_mutex_lock.constprop.0.isra.0>
	nbr_nexthop = net_ipv6_nbr_lookup(iface, nexthop);
4001a708:	00098593          	mv	a1,s3
4001a70c:	00090513          	mv	a0,s2
4001a710:	ca4fd0ef          	jal	ra,40017bb4 <net_ipv6_nbr_lookup>
	if (!nbr_nexthop) {
4001a714:	02051c63          	bnez	a0,4001a74c <net_route_add+0xa8>
	struct net_route_entry *route = NULL;
4001a718:	00000413          	li	s0,0
	k_mutex_unlock(&lock);
4001a71c:	921ff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>
}
4001a720:	01c12083          	lw	ra,28(sp)
4001a724:	00040513          	mv	a0,s0
4001a728:	01812403          	lw	s0,24(sp)
4001a72c:	01412483          	lw	s1,20(sp)
4001a730:	01012903          	lw	s2,16(sp)
4001a734:	00c12983          	lw	s3,12(sp)
4001a738:	00812a03          	lw	s4,8(sp)
4001a73c:	00412a83          	lw	s5,4(sp)
4001a740:	00012b03          	lw	s6,0(sp)
4001a744:	02010113          	addi	sp,sp,32
4001a748:	00008067          	ret
	if (nbr_nexthop && nbr_nexthop->idx != NET_NBR_LLADDR_UNKNOWN) {
4001a74c:	00154503          	lbu	a0,1(a0)
4001a750:	0ff00793          	li	a5,255
4001a754:	00f50463          	beq	a0,a5,4001a75c <net_route_add+0xb8>
		nexthop_lladdr = net_nbr_get_lladdr(nbr_nexthop->idx);
4001a758:	fb1fb0ef          	jal	ra,40016708 <net_nbr_get_lladdr>
	route = net_route_lookup(iface, addr);
4001a75c:	000a8593          	mv	a1,s5
4001a760:	00090513          	mv	a0,s2
4001a764:	9c1ff0ef          	jal	ra,4001a124 <net_route_lookup>
4001a768:	00050413          	mv	s0,a0
	if (route) {
4001a76c:	06050e63          	beqz	a0,4001a7e8 <net_route_add+0x144>
		nexthop_addr = net_route_get_nexthop(route);
4001a770:	ec5ff0ef          	jal	ra,4001a634 <net_route_get_nexthop>
4001a774:	00050593          	mv	a1,a0
		if (nexthop_addr && net_ipv6_addr_cmp(nexthop, nexthop_addr)) {
4001a778:	02050c63          	beqz	a0,4001a7b0 <net_route_add+0x10c>
4001a77c:	01000613          	li	a2,16
4001a780:	00098513          	mv	a0,s3
4001a784:	849ee0ef          	jal	ra,40008fcc <memcmp>
4001a788:	02051463          	bnez	a0,4001a7b0 <net_route_add+0x10c>
			net_route_update_lifetime(route, lifetime);
4001a78c:	000a0593          	mv	a1,s4
4001a790:	00040513          	mv	a0,s0
4001a794:	b0dff0ef          	jal	ra,4001a2a0 <net_route_update_lifetime>
			route->preference = preference;
4001a798:	03144783          	lbu	a5,49(s0)
4001a79c:	0034f493          	andi	s1,s1,3
4001a7a0:	ffc7f793          	andi	a5,a5,-4
4001a7a4:	0097e4b3          	or	s1,a5,s1
4001a7a8:	029408a3          	sb	s1,49(s0)
			goto exit;
4001a7ac:	f71ff06f          	j	4001a71c <net_route_add+0x78>
		if (route_preference_is_lower(route->preference, preference)) {
4001a7b0:	03042783          	lw	a5,48(s0)
	if (new == NET_ROUTE_PREFERENCE_RESERVED || (new & 0xfc) != 0) {
4001a7b4:	00200713          	li	a4,2
		if (route_preference_is_lower(route->preference, preference)) {
4001a7b8:	0087d793          	srli	a5,a5,0x8
4001a7bc:	0037f793          	andi	a5,a5,3
	if (new == NET_ROUTE_PREFERENCE_RESERVED || (new & 0xfc) != 0) {
4001a7c0:	f4e48ce3          	beq	s1,a4,4001a718 <net_route_add+0x74>
4001a7c4:	00300713          	li	a4,3
4001a7c8:	f49768e3          	bltu	a4,s1,4001a718 <net_route_add+0x74>
	old = (old + 1) & 0x3;
4001a7cc:	00178793          	addi	a5,a5,1
	new = (new + 1) & 0x3;
4001a7d0:	00148713          	addi	a4,s1,1
		if (route_preference_is_lower(route->preference, preference)) {
4001a7d4:	0037f793          	andi	a5,a5,3
4001a7d8:	00377713          	andi	a4,a4,3
4001a7dc:	f2f76ee3          	bltu	a4,a5,4001a718 <net_route_add+0x74>
		net_route_del(route);
4001a7e0:	00040513          	mv	a0,s0
4001a7e4:	b9dff0ef          	jal	ra,4001a380 <net_route_del>
	nbr = nbr_new(iface, addr, prefix_len);
4001a7e8:	000b0613          	mv	a2,s6
4001a7ec:	000a8593          	mv	a1,s5
4001a7f0:	00090513          	mv	a0,s2
4001a7f4:	fb4ff0ef          	jal	ra,40019fa8 <nbr_new>
4001a7f8:	00050413          	mv	s0,a0
	if (!nbr) {
4001a7fc:	02051e63          	bnez	a0,4001a838 <net_route_add+0x194>
	return list->tail;
4001a800:	40031537          	lui	a0,0x40031
4001a804:	ab450793          	addi	a5,a0,-1356 # 40030ab4 <routes>
4001a808:	0047a403          	lw	s0,4(a5)
		sys_slist_find_and_remove(&routes, last);
4001a80c:	ab450513          	addi	a0,a0,-1356
4001a810:	00040593          	mv	a1,s0
4001a814:	835ff0ef          	jal	ra,4001a048 <sys_slist_find_and_remove.isra.0>
		net_route_del(route);
4001a818:	00040513          	mv	a0,s0
4001a81c:	b65ff0ef          	jal	ra,4001a380 <net_route_del>
		nbr = nbr_new(iface, addr, prefix_len);
4001a820:	000b0613          	mv	a2,s6
4001a824:	000a8593          	mv	a1,s5
4001a828:	00090513          	mv	a0,s2
4001a82c:	f7cff0ef          	jal	ra,40019fa8 <nbr_new>
4001a830:	00050413          	mv	s0,a0
		if (!nbr) {
4001a834:	ee0502e3          	beqz	a0,4001a718 <net_route_add+0x74>
			((sizeof(struct net_nbr) + start->size) * idx));
4001a838:	4003d7b7          	lui	a5,0x4003d
4001a83c:	8d078713          	addi	a4,a5,-1840 # 4003c8d0 <net_route_nexthop_pool>
4001a840:	00275703          	lhu	a4,2(a4)
4001a844:	8d078513          	addi	a0,a5,-1840
4001a848:	00800793          	li	a5,8
4001a84c:	01470713          	addi	a4,a4,20
		if (!nbr->ref) {
4001a850:	00054683          	lbu	a3,0(a0)
4001a854:	0a069663          	bnez	a3,4001a900 <net_route_add+0x25c>
			nbr->data = nbr->__nbr;
4001a858:	01450793          	addi	a5,a0,20
4001a85c:	00f52623          	sw	a5,12(a0)
			nbr->idx = NET_NBR_LLADDR_UNKNOWN;
4001a860:	fff00793          	li	a5,-1
4001a864:	00f500a3          	sb	a5,1(a0)
			return net_nbr_ref(nbr);
4001a868:	c4dfb0ef          	jal	ra,400164b4 <net_nbr_ref>
	if (!tmp) {
4001a86c:	ea0506e3          	beqz	a0,4001a718 <net_route_add+0x74>
	return (struct net_route_entry *)nbr->data;
4001a870:	00c42403          	lw	s0,12(s0)
	route->preference = preference;
4001a874:	0034f493          	andi	s1,s1,3
	return (struct net_route_nexthop *)nbr->data;
4001a878:	00c52a83          	lw	s5,12(a0)
	route->preference = preference;
4001a87c:	03144783          	lbu	a5,49(s0)
	route->iface = iface;
4001a880:	01242623          	sw	s2,12(s0)
	net_route_update_lifetime(route, lifetime);
4001a884:	000a0593          	mv	a1,s4
	route->preference = preference;
4001a888:	ffc7f793          	andi	a5,a5,-4
4001a88c:	0097e7b3          	or	a5,a5,s1
4001a890:	02f408a3          	sb	a5,49(s0)
	net_route_update_lifetime(route, lifetime);
4001a894:	00040513          	mv	a0,s0
4001a898:	a09ff0ef          	jal	ra,4001a2a0 <net_route_update_lifetime>
	return list->head;
4001a89c:	400317b7          	lui	a5,0x40031
4001a8a0:	ab478793          	addi	a5,a5,-1356 # 40030ab4 <routes>
4001a8a4:	0007a703          	lw	a4,0(a5)
	parent->next = child;
4001a8a8:	00e42023          	sw	a4,0(s0)
Z_GENLIST_PREPEND(slist, snode)
4001a8ac:	0047a703          	lw	a4,4(a5)
	list->head = node;
4001a8b0:	0087a023          	sw	s0,0(a5)
Z_GENLIST_PREPEND(slist, snode)
4001a8b4:	00071463          	bnez	a4,4001a8bc <net_route_add+0x218>
	list->tail = node;
4001a8b8:	0087a223          	sw	s0,4(a5)
	nbr = net_ipv6_nbr_lookup(iface, addr);
4001a8bc:	00098593          	mv	a1,s3
4001a8c0:	00090513          	mv	a0,s2
4001a8c4:	af0fd0ef          	jal	ra,40017bb4 <net_ipv6_nbr_lookup>
4001a8c8:	00050493          	mv	s1,a0
	if (nbr == NULL) {
4001a8cc:	00050463          	beqz	a0,4001a8d4 <net_route_add+0x230>
	net_nbr_ref(nbr);
4001a8d0:	be5fb0ef          	jal	ra,400164b4 <net_nbr_ref>
	nexthop_route->nbr = tmp;
4001a8d4:	009aa223          	sw	s1,4(s5)
	parent->next = child;
4001a8d8:	000aa023          	sw	zero,0(s5)
4001a8dc:	e0600537          	lui	a0,0xe0600
	list->head = node;
4001a8e0:	01542223          	sw	s5,4(s0)
	list->tail = node;
4001a8e4:	01542423          	sw	s5,8(s0)
4001a8e8:	00000693          	li	a3,0
4001a8ec:	00000613          	li	a2,0
4001a8f0:	00090593          	mv	a1,s2
4001a8f4:	00b50513          	addi	a0,a0,11 # e060000b <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000c>
4001a8f8:	e38f60ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
}
4001a8fc:	e21ff06f          	j	4001a71c <net_route_add+0x78>
	for (i = 0; i < CONFIG_NET_MAX_NEXTHOPS; i++) {
4001a900:	fff78793          	addi	a5,a5,-1
4001a904:	00e50533          	add	a0,a0,a4
4001a908:	f40794e3          	bnez	a5,4001a850 <net_route_add+0x1ac>
4001a90c:	e0dff06f          	j	4001a718 <net_route_add+0x74>

4001a910 <net_route_foreach>:

int net_route_foreach(net_route_cb_t cb, void *user_data)
{
4001a910:	fe010113          	addi	sp,sp,-32
4001a914:	00812c23          	sw	s0,24(sp)
4001a918:	4003c437          	lui	s0,0x4003c
4001a91c:	01212823          	sw	s2,16(sp)
4001a920:	01312623          	sw	s3,12(sp)
4001a924:	00050913          	mv	s2,a0
4001a928:	00058993          	mv	s3,a1
	int i, ret = 0;

	k_mutex_lock(&lock, K_FOREVER);
4001a92c:	fff00513          	li	a0,-1
4001a930:	fff00593          	li	a1,-1
4001a934:	69040413          	addi	s0,s0,1680 # 4003c690 <net_route_entries_pool>
{
4001a938:	00912a23          	sw	s1,20(sp)
4001a93c:	01412423          	sw	s4,8(sp)
4001a940:	00112e23          	sw	ra,28(sp)
4001a944:	24040a13          	addi	s4,s0,576
	k_mutex_lock(&lock, K_FOREVER);
4001a948:	ee0ff0ef          	jal	ra,4001a028 <k_mutex_lock.constprop.0.isra.0>
	int i, ret = 0;
4001a94c:	00000493          	li	s1,0
		nbr = get_nbr(i);
		if (!nbr) {
			continue;
		}

		if (!nbr->ref) {
4001a950:	00044783          	lbu	a5,0(s0)
4001a954:	00078c63          	beqz	a5,4001a96c <net_route_foreach+0x5c>
	return (struct net_route_entry *)nbr->data;
4001a958:	00c42503          	lw	a0,12(s0)
			continue;
		}

		route = net_route_data(nbr);
		if (!route) {
4001a95c:	00050863          	beqz	a0,4001a96c <net_route_foreach+0x5c>
			continue;
		}

		cb(route, user_data);
4001a960:	00098593          	mv	a1,s3
4001a964:	000900e7          	jalr	s2

		ret++;
4001a968:	00148493          	addi	s1,s1,1
	for (i = 0; i < CONFIG_NET_MAX_ROUTES; i++) {
4001a96c:	04840413          	addi	s0,s0,72
4001a970:	ff4410e3          	bne	s0,s4,4001a950 <net_route_foreach+0x40>
	}

	k_mutex_unlock(&lock);
4001a974:	ec8ff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>
	return ret;
}
4001a978:	01c12083          	lw	ra,28(sp)
4001a97c:	01812403          	lw	s0,24(sp)
4001a980:	01012903          	lw	s2,16(sp)
4001a984:	00c12983          	lw	s3,12(sp)
4001a988:	00812a03          	lw	s4,8(sp)
4001a98c:	00048513          	mv	a0,s1
4001a990:	01412483          	lw	s1,20(sp)
4001a994:	02010113          	addi	sp,sp,32
4001a998:	00008067          	ret

4001a99c <net_route_get_info>:

bool net_route_get_info(struct net_if *iface,
			struct in6_addr *dst,
			struct net_route_entry **route,
			struct in6_addr **nexthop)
{
4001a99c:	fd010113          	addi	sp,sp,-48
4001a9a0:	02812423          	sw	s0,40(sp)
4001a9a4:	01312e23          	sw	s3,28(sp)
4001a9a8:	00058413          	mv	s0,a1
4001a9ac:	00050993          	mv	s3,a0
	struct net_if_router *router;
	bool ret = false;

	k_mutex_lock(&lock, K_FOREVER);
4001a9b0:	fff00593          	li	a1,-1
4001a9b4:	fff00513          	li	a0,-1
{
4001a9b8:	02912223          	sw	s1,36(sp)
4001a9bc:	03212023          	sw	s2,32(sp)
4001a9c0:	02112623          	sw	ra,44(sp)
4001a9c4:	00060913          	mv	s2,a2
4001a9c8:	00068493          	mv	s1,a3
	k_mutex_lock(&lock, K_FOREVER);
4001a9cc:	e5cff0ef          	jal	ra,4001a028 <k_mutex_lock.constprop.0.isra.0>

	/* Search in neighbor table first, if not search in routing table. */
	if (net_ipv6_nbr_lookup(iface, dst)) {
4001a9d0:	00040593          	mv	a1,s0
4001a9d4:	00098513          	mv	a0,s3
4001a9d8:	9dcfd0ef          	jal	ra,40017bb4 <net_ipv6_nbr_lookup>
4001a9dc:	00050a63          	beqz	a0,4001a9f0 <net_route_get_info+0x54>
		/* Found nexthop, no need to look into routing table. */
		*route = NULL;
4001a9e0:	00092023          	sw	zero,0(s2)
		router = net_if_ipv6_router_find_default(NULL, dst);
		if (!router) {
			goto exit;
		}

		*nexthop = &router->address.in6_addr;
4001a9e4:	0084a023          	sw	s0,0(s1)
		ret = true;
4001a9e8:	00100513          	li	a0,1
4001a9ec:	0240006f          	j	4001aa10 <net_route_get_info+0x74>
	*route = net_route_lookup(iface, dst);
4001a9f0:	00040593          	mv	a1,s0
4001a9f4:	00098513          	mv	a0,s3
4001a9f8:	f2cff0ef          	jal	ra,4001a124 <net_route_lookup>
4001a9fc:	00a92023          	sw	a0,0(s2)
	if (*route) {
4001aa00:	02050c63          	beqz	a0,4001aa38 <net_route_get_info+0x9c>
		*nexthop = net_route_get_nexthop(*route);
4001aa04:	c31ff0ef          	jal	ra,4001a634 <net_route_get_nexthop>
4001aa08:	00a4a023          	sw	a0,0(s1)
		if (!*nexthop) {
4001aa0c:	00a03533          	snez	a0,a0
4001aa10:	00a12623          	sw	a0,12(sp)
		ret = true;
		goto exit;
	}

exit:
	k_mutex_unlock(&lock);
4001aa14:	e28ff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>
	return ret;
}
4001aa18:	02c12083          	lw	ra,44(sp)
4001aa1c:	02812403          	lw	s0,40(sp)
4001aa20:	00c12503          	lw	a0,12(sp)
4001aa24:	02412483          	lw	s1,36(sp)
4001aa28:	02012903          	lw	s2,32(sp)
4001aa2c:	01c12983          	lw	s3,28(sp)
4001aa30:	03010113          	addi	sp,sp,48
4001aa34:	00008067          	ret
		router = net_if_ipv6_router_find_default(NULL, dst);
4001aa38:	00040593          	mv	a1,s0
4001aa3c:	c01f30ef          	jal	ra,4000e63c <net_if_ipv6_router_find_default>
4001aa40:	00050413          	mv	s0,a0
	bool ret = false;
4001aa44:	00000513          	li	a0,0
		if (!router) {
4001aa48:	fc0404e3          	beqz	s0,4001aa10 <net_route_get_info+0x74>
		*nexthop = &router->address.in6_addr;
4001aa4c:	00840413          	addi	s0,s0,8
		goto exit;
4001aa50:	f95ff06f          	j	4001a9e4 <net_route_get_info+0x48>

4001aa54 <net_route_packet>:

int net_route_packet(struct net_pkt *pkt, struct in6_addr *nexthop)
{
4001aa54:	fd010113          	addi	sp,sp,-48
4001aa58:	02812423          	sw	s0,40(sp)
4001aa5c:	02912223          	sw	s1,36(sp)
4001aa60:	00050413          	mv	s0,a0
4001aa64:	00058493          	mv	s1,a1
	struct net_linkaddr_storage *lladdr;
	struct net_nbr *nbr;
	int err;

	k_mutex_lock(&lock, K_FOREVER);
4001aa68:	fff00513          	li	a0,-1
4001aa6c:	fff00593          	li	a1,-1
{
4001aa70:	02112623          	sw	ra,44(sp)
4001aa74:	03212023          	sw	s2,32(sp)
4001aa78:	01312e23          	sw	s3,28(sp)
	k_mutex_lock(&lock, K_FOREVER);
4001aa7c:	dacff0ef          	jal	ra,4001a028 <k_mutex_lock.constprop.0.isra.0>

	nbr = net_ipv6_nbr_lookup(NULL, nexthop);
4001aa80:	00048593          	mv	a1,s1
4001aa84:	00000513          	li	a0,0
4001aa88:	92cfd0ef          	jal	ra,40017bb4 <net_ipv6_nbr_lookup>
	if (!nbr) {
4001aa8c:	0e050863          	beqz	a0,4001ab7c <net_route_packet+0x128>
4001aa90:	00050913          	mv	s2,a0
			net_sprint_ipv6_addr(nexthop));
		err = -ENOENT;
		goto error;
	}

	lladdr = net_nbr_get_lladdr(nbr->idx);
4001aa94:	00154503          	lbu	a0,1(a0)
4001aa98:	c71fb0ef          	jal	ra,40016708 <net_nbr_get_lladdr>
4001aa9c:	00050493          	mv	s1,a0
	if (!lladdr) {
4001aaa0:	0e050263          	beqz	a0,4001ab84 <net_route_packet+0x130>
#endif
#if defined(CONFIG_NET_L2_PPP)
		/* PPP does not populate the lladdr fields */
		if (net_if_l2(net_pkt_iface(pkt)) != &NET_L2_GET_NAME(PPP)) {
#endif
			if (!net_pkt_lladdr_src(pkt)->addr) {
4001aaa4:	02442503          	lw	a0,36(s0)
4001aaa8:	02051863          	bnez	a0,4001aad8 <net_route_packet+0x84>
				NET_DBG("Link layer source address not set");
				err = -EINVAL;
4001aaac:	fea00513          	li	a0,-22
4001aab0:	00a12623          	sw	a0,12(sp)

	k_mutex_unlock(&lock);
	return net_send_data(pkt);

error:
	k_mutex_unlock(&lock);
4001aab4:	d88ff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>
	return err;
}
4001aab8:	02c12083          	lw	ra,44(sp)
4001aabc:	02812403          	lw	s0,40(sp)
4001aac0:	00c12503          	lw	a0,12(sp)
4001aac4:	02412483          	lw	s1,36(sp)
4001aac8:	02012903          	lw	s2,32(sp)
4001aacc:	01c12983          	lw	s3,28(sp)
4001aad0:	03010113          	addi	sp,sp,48
4001aad4:	00008067          	ret
			if (!memcmp(net_pkt_lladdr_src(pkt)->addr, lladdr->addr,
4001aad8:	0014c603          	lbu	a2,1(s1)
4001aadc:	00248993          	addi	s3,s1,2
4001aae0:	00098593          	mv	a1,s3
4001aae4:	ce8ee0ef          	jal	ra,40008fcc <memcmp>
4001aae8:	fc0502e3          	beqz	a0,4001aaac <net_route_packet+0x58>
	pkt->forwarding = forward;
4001aaec:	03744783          	lbu	a5,55(s0)
4001aaf0:	0107e793          	ori	a5,a5,16
4001aaf4:	02f40ba3          	sb	a5,55(s0)
	return net_if_get_link_addr(pkt->iface);
4001aaf8:	01842783          	lw	a5,24(s0)
	net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
4001aafc:	0007a703          	lw	a4,0(a5)
4001ab00:	01072703          	lw	a4,16(a4)
4001ab04:	02e42223          	sw	a4,36(s0)
	net_pkt_lladdr_src(pkt)->type = net_pkt_lladdr_if(pkt)->type;
4001ab08:	0007a703          	lw	a4,0(a5)
4001ab0c:	01574703          	lbu	a4,21(a4)
4001ab10:	02e404a3          	sb	a4,41(s0)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
4001ab14:	0007a783          	lw	a5,0(a5)
4001ab18:	0147c783          	lbu	a5,20(a5)
	net_pkt_lladdr_dst(pkt)->addr = lladdr->addr;
4001ab1c:	03342623          	sw	s3,44(s0)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
4001ab20:	02f40423          	sb	a5,40(s0)
	net_pkt_lladdr_dst(pkt)->type = lladdr->type;
4001ab24:	0004c783          	lbu	a5,0(s1)
4001ab28:	02f408a3          	sb	a5,49(s0)
	net_pkt_lladdr_dst(pkt)->len = lladdr->len;
4001ab2c:	0014c783          	lbu	a5,1(s1)
4001ab30:	02f40823          	sb	a5,48(s0)
	net_pkt_set_iface(pkt, nbr->iface);
4001ab34:	00892783          	lw	a5,8(s2)
	pkt->iface = iface;
4001ab38:	00f42c23          	sw	a5,24(s0)
	if (iface) {
4001ab3c:	00078e63          	beqz	a5,4001ab58 <net_route_packet+0x104>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
4001ab40:	0007a703          	lw	a4,0(a5)
4001ab44:	01574703          	lbu	a4,21(a4)
4001ab48:	02e404a3          	sb	a4,41(s0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
4001ab4c:	0007a783          	lw	a5,0(a5)
4001ab50:	0157c783          	lbu	a5,21(a5)
4001ab54:	02f408a3          	sb	a5,49(s0)
	k_mutex_unlock(&lock);
4001ab58:	ce4ff0ef          	jal	ra,4001a03c <k_mutex_unlock.constprop.0.isra.0>
	return net_send_data(pkt);
4001ab5c:	00040513          	mv	a0,s0
}
4001ab60:	02812403          	lw	s0,40(sp)
4001ab64:	02c12083          	lw	ra,44(sp)
4001ab68:	02412483          	lw	s1,36(sp)
4001ab6c:	02012903          	lw	s2,32(sp)
4001ab70:	01c12983          	lw	s3,28(sp)
4001ab74:	03010113          	addi	sp,sp,48
	return net_send_data(pkt);
4001ab78:	b51f006f          	j	4000b6c8 <net_send_data>
		err = -ENOENT;
4001ab7c:	ffe00513          	li	a0,-2
4001ab80:	f31ff06f          	j	4001aab0 <net_route_packet+0x5c>
		err = -ESRCH;
4001ab84:	ffd00513          	li	a0,-3
4001ab88:	f29ff06f          	j	4001aab0 <net_route_packet+0x5c>

4001ab8c <net_route_packet_if>:
	pkt->iface = iface;
4001ab8c:	00b52c23          	sw	a1,24(a0)
	if (iface) {
4001ab90:	00058e63          	beqz	a1,4001abac <net_route_packet_if+0x20>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
4001ab94:	0005a783          	lw	a5,0(a1)
4001ab98:	0157c783          	lbu	a5,21(a5)
4001ab9c:	02f504a3          	sb	a5,41(a0)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
4001aba0:	0005a783          	lw	a5,0(a1)
4001aba4:	0157c783          	lbu	a5,21(a5)
4001aba8:	02f508a3          	sb	a5,49(a0)
	pkt->forwarding = forward;
4001abac:	03754783          	lbu	a5,55(a0)
4001abb0:	0107e793          	ori	a5,a5,16
4001abb4:	02f50ba3          	sb	a5,55(a0)
	net_pkt_set_orig_iface(pkt, net_pkt_iface(pkt));
	net_pkt_set_iface(pkt, iface);

	net_pkt_set_forwarding(pkt, true);

	net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
4001abb8:	0005a783          	lw	a5,0(a1)
4001abbc:	0107a783          	lw	a5,16(a5)
4001abc0:	02f52223          	sw	a5,36(a0)
	net_pkt_lladdr_src(pkt)->type = net_pkt_lladdr_if(pkt)->type;
4001abc4:	0005a783          	lw	a5,0(a1)
4001abc8:	0157c783          	lbu	a5,21(a5)
4001abcc:	02f504a3          	sb	a5,41(a0)
	net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
4001abd0:	0005a783          	lw	a5,0(a1)
4001abd4:	0147c783          	lbu	a5,20(a5)
4001abd8:	02f50423          	sb	a5,40(a0)

	return net_send_data(pkt);
4001abdc:	aedf006f          	j	4000b6c8 <net_send_data>

4001abe0 <net_route_init>:
		CONFIG_NET_MAX_ROUTES, sizeof(net_route_entries_pool));

	NET_DBG("Allocated %d nexthop entries (%zu bytes)",
		CONFIG_NET_MAX_NEXTHOPS, sizeof(net_route_nexthop_pool));

	k_work_init_delayable(&route_lifetime_timer, route_lifetime_timeout);
4001abe0:	4001a5b7          	lui	a1,0x4001a
4001abe4:	40031537          	lui	a0,0x40031
4001abe8:	46858593          	addi	a1,a1,1128 # 4001a468 <route_lifetime_timeout>
4001abec:	0d850513          	addi	a0,a0,216 # 400310d8 <route_lifetime_timer>
4001abf0:	0e50e06f          	j	400294d4 <k_work_init_delayable>

4001abf4 <sys_slist_get>:
Z_GENLIST_GET(slist, snode)
4001abf4:	00050793          	mv	a5,a0
	return list->head;
4001abf8:	00052503          	lw	a0,0(a0)
Z_GENLIST_GET(slist, snode)
4001abfc:	00050c63          	beqz	a0,4001ac14 <sys_slist_get+0x20>
	return node->next;
4001ac00:	00052703          	lw	a4,0(a0)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
4001ac04:	0047a683          	lw	a3,4(a5)
	list->head = node;
4001ac08:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
4001ac0c:	00d51463          	bne	a0,a3,4001ac14 <sys_slist_get+0x20>
	list->tail = node;
4001ac10:	00e7a223          	sw	a4,4(a5)
Z_GENLIST_GET(slist, snode)
4001ac14:	00008067          	ret

4001ac18 <tcp_validate_seq>:
	return conn;
}

static bool tcp_validate_seq(struct tcp *conn, struct tcphdr *hdr)
{
	return (net_tcp_seq_cmp(th_seq(hdr), conn->ack) >= 0) &&
4001ac18:	0055c783          	lbu	a5,5(a1)
4001ac1c:	0045c703          	lbu	a4,4(a1)
4001ac20:	00010637          	lui	a2,0x10
4001ac24:	00879793          	slli	a5,a5,0x8
4001ac28:	00e7e7b3          	or	a5,a5,a4
4001ac2c:	0065c703          	lbu	a4,6(a1)
4001ac30:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001ac34:	01071713          	slli	a4,a4,0x10
4001ac38:	00f76733          	or	a4,a4,a5
4001ac3c:	0075c783          	lbu	a5,7(a1)
4001ac40:	01879793          	slli	a5,a5,0x18
4001ac44:	00e7e6b3          	or	a3,a5,a4
4001ac48:	01871713          	slli	a4,a4,0x18
4001ac4c:	0187d793          	srli	a5,a5,0x18
4001ac50:	00e7e7b3          	or	a5,a5,a4
4001ac54:	0086d713          	srli	a4,a3,0x8
4001ac58:	00c77733          	and	a4,a4,a2
4001ac5c:	00e7e7b3          	or	a5,a5,a4
4001ac60:	00869693          	slli	a3,a3,0x8
4001ac64:	00ff0737          	lui	a4,0xff0
4001ac68:	00e6f6b3          	and	a3,a3,a4
4001ac6c:	00d7e7b3          	or	a5,a5,a3
4001ac70:	22c52683          	lw	a3,556(a0)
 *
 * @return < 0 if seq1 < seq2, 0 if seq1 == seq2, > 0 if seq > seq2
 */
static inline int32_t net_tcp_seq_cmp(uint32_t seq1, uint32_t seq2)
{
	return (int32_t)(seq1 - seq2);
4001ac74:	40d78733          	sub	a4,a5,a3
4001ac78:	00074c63          	bltz	a4,4001ac90 <tcp_validate_seq+0x78>
		(net_tcp_seq_cmp(th_seq(hdr), conn->ack + conn->recv_win) < 0);
4001ac7c:	23255703          	lhu	a4,562(a0)
4001ac80:	00d70733          	add	a4,a4,a3
4001ac84:	40e78533          	sub	a0,a5,a4
	return (net_tcp_seq_cmp(th_seq(hdr), conn->ack) >= 0) &&
4001ac88:	01f55513          	srli	a0,a0,0x1f
4001ac8c:	00008067          	ret
4001ac90:	00000513          	li	a0,0
}
4001ac94:	00008067          	ret

4001ac98 <tcp_send>:
{
4001ac98:	ff010113          	addi	sp,sp,-16
4001ac9c:	00812423          	sw	s0,8(sp)
4001aca0:	00112623          	sw	ra,12(sp)
4001aca4:	00050413          	mv	s0,a0
	tcp_pkt_ref(pkt);
4001aca8:	a0cf80ef          	jal	ra,40012eb4 <net_pkt_ref>
	if (tcp_send_cb) {
4001acac:	400317b7          	lui	a5,0x40031
4001acb0:	ac07a783          	lw	a5,-1344(a5) # 40030ac0 <tcp_send_cb>
		if (tcp_send_cb(pkt) < 0) {
4001acb4:	00040513          	mv	a0,s0
	if (tcp_send_cb) {
4001acb8:	02078463          	beqz	a5,4001ace0 <tcp_send+0x48>
		if (tcp_send_cb(pkt) < 0) {
4001acbc:	000780e7          	jalr	a5
4001acc0:	00055663          	bgez	a0,4001accc <tcp_send+0x34>
			tcp_pkt_unref(pkt);
4001acc4:	00040513          	mv	a0,s0
4001acc8:	a54f80ef          	jal	ra,40012f1c <net_pkt_unref>
	tcp_pkt_unref(pkt);
4001accc:	00040513          	mv	a0,s0
}
4001acd0:	00812403          	lw	s0,8(sp)
4001acd4:	00c12083          	lw	ra,12(sp)
4001acd8:	01010113          	addi	sp,sp,16
	tcp_pkt_unref(pkt);
4001acdc:	a40f806f          	j	40012f1c <net_pkt_unref>
		if (net_send_data(pkt) < 0) {
4001ace0:	9e9f00ef          	jal	ra,4000b6c8 <net_send_data>
4001ace4:	fddff06f          	j	4001acc0 <tcp_send+0x28>

4001ace8 <tcp_derive_rto>:
{
4001ace8:	fe010113          	addi	sp,sp,-32
4001acec:	00812c23          	sw	s0,24(sp)
4001acf0:	00112e23          	sw	ra,28(sp)
4001acf4:	00050413          	mv	s0,a0
		(void) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_SYS_RAND_GET);
		return;
	}
#endif
	compiler_barrier();
	z_impl_sys_rand_get(dst, len);
4001acf8:	00100593          	li	a1,1
4001acfc:	00f10513          	addi	a0,sp,15
4001ad00:	8b9ee0ef          	jal	ra,400095b8 <z_impl_sys_rand_get>
	gain = (uint32_t)gain8;
4001ad04:	00f14783          	lbu	a5,15(sp)
	rto = (gain * rto) >> 9;
4001ad08:	0c800713          	li	a4,200
	gain += 1 << 9;
4001ad0c:	20078793          	addi	a5,a5,512
	rto = (gain * rto) >> 9;
4001ad10:	02e787b3          	mul	a5,a5,a4
4001ad14:	0097d793          	srli	a5,a5,0x9
	conn->rto = (uint16_t)rto;
4001ad18:	22f41c23          	sh	a5,568(s0)
}
4001ad1c:	01c12083          	lw	ra,28(sp)
4001ad20:	01812403          	lw	s0,24(sp)
4001ad24:	02010113          	addi	sp,sp,32
4001ad28:	00008067          	ret

4001ad2c <is_destination_local>:
{
4001ad2c:	ff010113          	addi	sp,sp,-16
4001ad30:	00812423          	sw	s0,8(sp)
4001ad34:	00112623          	sw	ra,12(sp)
4001ad38:	00912223          	sw	s1,4(sp)
4001ad3c:	01212023          	sw	s2,0(sp)
	return pkt->family;
4001ad40:	03452783          	lw	a5,52(a0)
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
4001ad44:	00100713          	li	a4,1
{
4001ad48:	00050413          	mv	s0,a0
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
4001ad4c:	01d7d793          	srli	a5,a5,0x1d
4001ad50:	10e78c63          	beq	a5,a4,4001ae68 <is_destination_local+0x13c>
4001ad54:	03442783          	lw	a5,52(s0)
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
4001ad58:	00200713          	li	a4,2
	return false;
4001ad5c:	00000513          	li	a0,0
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
4001ad60:	01d7d793          	srli	a5,a5,0x1d
4001ad64:	10e79e63          	bne	a5,a4,4001ae80 <is_destination_local+0x154>
	return pkt->frags->data;
4001ad68:	00842783          	lw	a5,8(s0)
4001ad6c:	00c7a783          	lw	a5,12(a5)
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001ad70:	0197c703          	lbu	a4,25(a5)
4001ad74:	0187c683          	lbu	a3,24(a5)
				(struct in6_addr *)NET_IPV6_HDR(pkt)->dst) ||
4001ad78:	01878513          	addi	a0,a5,24
4001ad7c:	00871713          	slli	a4,a4,0x8
4001ad80:	00d76733          	or	a4,a4,a3
4001ad84:	01a7c683          	lbu	a3,26(a5)
4001ad88:	01069693          	slli	a3,a3,0x10
4001ad8c:	00e6e6b3          	or	a3,a3,a4
4001ad90:	01b7c703          	lbu	a4,27(a5)
4001ad94:	01871713          	slli	a4,a4,0x18
4001ad98:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001ad9c:	0a071e63          	bnez	a4,4001ae58 <is_destination_local+0x12c>
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001ada0:	01d7c703          	lbu	a4,29(a5)
4001ada4:	01c7c683          	lbu	a3,28(a5)
4001ada8:	00871713          	slli	a4,a4,0x8
4001adac:	00d76733          	or	a4,a4,a3
4001adb0:	01e7c683          	lbu	a3,30(a5)
4001adb4:	01069693          	slli	a3,a3,0x10
4001adb8:	00e6e6b3          	or	a3,a3,a4
4001adbc:	01f7c703          	lbu	a4,31(a5)
4001adc0:	01871713          	slli	a4,a4,0x18
4001adc4:	00d76733          	or	a4,a4,a3
	return UNALIGNED_GET(&addr->s6_addr32[0]) == 0 &&
4001adc8:	08071863          	bnez	a4,4001ae58 <is_destination_local+0x12c>
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001adcc:	0217c703          	lbu	a4,33(a5)
4001add0:	0207c683          	lbu	a3,32(a5)
4001add4:	00871713          	slli	a4,a4,0x8
4001add8:	00d76733          	or	a4,a4,a3
4001addc:	0227c683          	lbu	a3,34(a5)
4001ade0:	01069693          	slli	a3,a3,0x10
4001ade4:	00e6e6b3          	or	a3,a3,a4
4001ade8:	0237c703          	lbu	a4,35(a5)
4001adec:	01871713          	slli	a4,a4,0x18
4001adf0:	00d76733          	or	a4,a4,a3
		UNALIGNED_GET(&addr->s6_addr32[1]) == 0 &&
4001adf4:	06071263          	bnez	a4,4001ae58 <is_destination_local+0x12c>
		ntohl(UNALIGNED_GET(&addr->s6_addr32[3])) == 1;
4001adf8:	0257c683          	lbu	a3,37(a5)
4001adfc:	0247c703          	lbu	a4,36(a5)
4001ae00:	00010637          	lui	a2,0x10
4001ae04:	00869693          	slli	a3,a3,0x8
4001ae08:	00e6e6b3          	or	a3,a3,a4
4001ae0c:	0267c703          	lbu	a4,38(a5)
4001ae10:	0277c783          	lbu	a5,39(a5)
4001ae14:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001ae18:	01071713          	slli	a4,a4,0x10
4001ae1c:	00d76733          	or	a4,a4,a3
4001ae20:	01879793          	slli	a5,a5,0x18
4001ae24:	00e7e6b3          	or	a3,a5,a4
4001ae28:	01871713          	slli	a4,a4,0x18
4001ae2c:	0187d793          	srli	a5,a5,0x18
4001ae30:	00e7e7b3          	or	a5,a5,a4
4001ae34:	0086d713          	srli	a4,a3,0x8
4001ae38:	00c77733          	and	a4,a4,a2
4001ae3c:	00e7e7b3          	or	a5,a5,a4
4001ae40:	00869693          	slli	a3,a3,0x8
4001ae44:	00ff0737          	lui	a4,0xff0
4001ae48:	00e6f6b3          	and	a3,a3,a4
4001ae4c:	00d7e7b3          	or	a5,a5,a3
		UNALIGNED_GET(&addr->s6_addr32[2]) == 0 &&
4001ae50:	00100713          	li	a4,1
4001ae54:	02e78463          	beq	a5,a4,4001ae7c <is_destination_local+0x150>
	return net_if_ipv6_addr_lookup(addr, NULL) != NULL;
4001ae58:	00000593          	li	a1,0
4001ae5c:	8c0f20ef          	jal	ra,4000cf1c <net_if_ipv6_addr_lookup>
4001ae60:	00a03533          	snez	a0,a0
4001ae64:	01c0006f          	j	4001ae80 <is_destination_local+0x154>
4001ae68:	00852783          	lw	a5,8(a0)
4001ae6c:	00c7a483          	lw	s1,12(a5)
		if (net_ipv4_is_addr_loopback(
4001ae70:	07f00793          	li	a5,127
4001ae74:	0104c703          	lbu	a4,16(s1)
4001ae78:	02f71063          	bne	a4,a5,4001ae98 <is_destination_local+0x16c>
			return true;
4001ae7c:	00100513          	li	a0,1
}
4001ae80:	00c12083          	lw	ra,12(sp)
4001ae84:	00812403          	lw	s0,8(sp)
4001ae88:	00412483          	lw	s1,4(sp)
4001ae8c:	00012903          	lw	s2,0(sp)
4001ae90:	01010113          	addi	sp,sp,16
4001ae94:	00008067          	ret
				(struct in_addr *)NET_IPV4_HDR(pkt)->dst)) {
4001ae98:	01048913          	addi	s2,s1,16
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
4001ae9c:	00000593          	li	a1,0
4001aea0:	00090513          	mv	a0,s2
4001aea4:	f69f30ef          	jal	ra,4000ee0c <net_if_ipv4_addr_lookup>
	if (!ret) {
4001aea8:	fc051ae3          	bnez	a0,4001ae7c <is_destination_local+0x150>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4001aeac:	db5f50ef          	jal	ra,40010c60 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
4001aeb0:	0114c703          	lbu	a4,17(s1)
4001aeb4:	0104c783          	lbu	a5,16(s1)
4001aeb8:	00054683          	lbu	a3,0(a0)
4001aebc:	00871713          	slli	a4,a4,0x8
4001aec0:	00f76733          	or	a4,a4,a5
4001aec4:	0124c783          	lbu	a5,18(s1)
4001aec8:	01079793          	slli	a5,a5,0x10
4001aecc:	00e7e7b3          	or	a5,a5,a4
4001aed0:	0134c703          	lbu	a4,19(s1)
4001aed4:	01871713          	slli	a4,a4,0x18
4001aed8:	00f76733          	or	a4,a4,a5
4001aedc:	00154783          	lbu	a5,1(a0)
4001aee0:	00879793          	slli	a5,a5,0x8
4001aee4:	00d7e7b3          	or	a5,a5,a3
4001aee8:	00254683          	lbu	a3,2(a0)
4001aeec:	01069693          	slli	a3,a3,0x10
4001aef0:	00f6e6b3          	or	a3,a3,a5
4001aef4:	00354783          	lbu	a5,3(a0)
4001aef8:	01879793          	slli	a5,a5,0x18
4001aefc:	00d7e7b3          	or	a5,a5,a3
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
4001af00:	f6f70ee3          	beq	a4,a5,4001ae7c <is_destination_local+0x150>
	return net_if_ipv4_is_addr_bcast(iface, addr);
4001af04:	00090593          	mv	a1,s2
4001af08:	00000513          	li	a0,0
4001af0c:	cc5f30ef          	jal	ra,4000ebd0 <net_if_ipv4_is_addr_bcast>
				(struct in_addr *)NET_IPV4_HDR(pkt)->dst) ||
4001af10:	e40502e3          	beqz	a0,4001ad54 <is_destination_local+0x28>
4001af14:	f69ff06f          	j	4001ae7c <is_destination_local+0x150>

4001af18 <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
4001af18:	1650d06f          	j	4002887c <z_impl_k_mutex_lock>

4001af1c <net_pkt_get_len.isra.0>:
static inline size_t net_pkt_get_len(struct net_pkt *pkt)
4001af1c:	00050793          	mv	a5,a0
	size_t bytes = 0;
4001af20:	00000513          	li	a0,0
	while (buf) {
4001af24:	00079463          	bnez	a5,4001af2c <net_pkt_get_len.isra.0+0x10>
}
4001af28:	00008067          	ret
		bytes += buf->len;
4001af2c:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
4001af30:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4001af34:	00e50533          	add	a0,a0,a4
		buf = buf->frags;
4001af38:	fedff06f          	j	4001af24 <net_pkt_get_len.isra.0+0x8>

4001af3c <tcp_pkt_pull>:
{
4001af3c:	ff010113          	addi	sp,sp,-16
4001af40:	00812423          	sw	s0,8(sp)
4001af44:	00912223          	sw	s1,4(sp)
4001af48:	00112623          	sw	ra,12(sp)
4001af4c:	00050413          	mv	s0,a0
	int total = net_pkt_get_len(pkt);
4001af50:	00852503          	lw	a0,8(a0)
{
4001af54:	00058493          	mv	s1,a1
	int total = net_pkt_get_len(pkt);
4001af58:	fc5ff0ef          	jal	ra,4001af1c <net_pkt_get_len.isra.0>
	if (len > total) {
4001af5c:	04956263          	bltu	a0,s1,4001afa0 <tcp_pkt_pull+0x64>
	net_pkt_cursor_init(pkt);
4001af60:	00040513          	mv	a0,s0
4001af64:	a8cf80ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	pkt->overwrite = overwrite;
4001af68:	03744783          	lbu	a5,55(s0)
	net_pkt_pull(pkt, len);
4001af6c:	00048593          	mv	a1,s1
4001af70:	00040513          	mv	a0,s0
4001af74:	0017e793          	ori	a5,a5,1
4001af78:	02f40ba3          	sb	a5,55(s0)
4001af7c:	c75f80ef          	jal	ra,40013bf0 <net_pkt_pull>
	net_pkt_trim_buffer(pkt);
4001af80:	00040513          	mv	a0,s0
4001af84:	980f80ef          	jal	ra,40013104 <net_pkt_trim_buffer>
	int ret = 0;
4001af88:	00000513          	li	a0,0
}
4001af8c:	00c12083          	lw	ra,12(sp)
4001af90:	00812403          	lw	s0,8(sp)
4001af94:	00412483          	lw	s1,4(sp)
4001af98:	01010113          	addi	sp,sp,16
4001af9c:	00008067          	ret
		ret = -EINVAL;
4001afa0:	fea00513          	li	a0,-22
	return ret;
4001afa4:	fe9ff06f          	j	4001af8c <tcp_pkt_pull+0x50>

4001afa8 <net_context_get_iface.isra.0>:
4001afa8:	b25f106f          	j	4000cacc <z_impl_net_if_get_by_index>

4001afac <th_get>:
{
4001afac:	fd010113          	addi	sp,sp,-48
4001afb0:	02812423          	sw	s0,40(sp)
4001afb4:	01612823          	sw	s6,16(sp)
4001afb8:	01712623          	sw	s7,12(sp)
4001afbc:	02112623          	sw	ra,44(sp)
4001afc0:	02912223          	sw	s1,36(sp)
4001afc4:	03212023          	sw	s2,32(sp)
4001afc8:	01312e23          	sw	s3,28(sp)
4001afcc:	01412c23          	sw	s4,24(sp)
4001afd0:	01512a23          	sw	s5,20(sp)
4001afd4:	01812423          	sw	s8,8(sp)
	size_t ip_len = net_pkt_ip_hdr_len(pkt) + net_pkt_ip_opts_len(pkt);
4001afd8:	03654a03          	lbu	s4,54(a0)
4001afdc:	03a55783          	lhu	a5,58(a0)
{
4001afe0:	00050413          	mv	s0,a0
	if (!buf || buf->size < len) {
4001afe4:	01300b93          	li	s7,19
	size_t ip_len = net_pkt_ip_hdr_len(pkt) + net_pkt_ip_opts_len(pkt);
4001afe8:	00fa0a33          	add	s4,s4,a5
	if (net_pkt_get_len(pkt) < (pos + len)) {
4001afec:	014a0b13          	addi	s6,s4,20
	net_pkt_cursor_init(pkt);
4001aff0:	00040513          	mv	a0,s0
4001aff4:	9fcf80ef          	jal	ra,400131f0 <net_pkt_cursor_init>
4001aff8:	03744783          	lbu	a5,55(s0)
	if (net_pkt_skip(pkt, ip_len) != 0) {
4001affc:	000a0593          	mv	a1,s4
4001b000:	00040513          	mv	a0,s0
4001b004:	0017e793          	ori	a5,a5,1
4001b008:	02f40ba3          	sb	a5,55(s0)
4001b00c:	f58f80ef          	jal	ra,40013764 <net_pkt_skip>
4001b010:	04051863          	bnez	a0,4001b060 <th_get+0xb4>
	if (!net_pkt_is_contiguous(pkt, sizeof(*th))) {
4001b014:	01400593          	li	a1,20
4001b018:	00040513          	mv	a0,s0
4001b01c:	ed1f80ef          	jal	ra,40013eec <net_pkt_is_contiguous>
4001b020:	10051063          	bnez	a0,4001b120 <th_get+0x174>
	struct net_buf *buf, *first = pkt->cursor.buf, *second = first->frags;
4001b024:	00c42a83          	lw	s5,12(s0)
	if (net_pkt_get_len(pkt) < (pos + len)) {
4001b028:	00842503          	lw	a0,8(s0)
	struct net_buf *buf, *first = pkt->cursor.buf, *second = first->frags;
4001b02c:	004aa903          	lw	s2,4(s5)
	if (net_pkt_get_len(pkt) < (pos + len)) {
4001b030:	eedff0ef          	jal	ra,4001af1c <net_pkt_get_len.isra.0>
4001b034:	03656663          	bltu	a0,s6,4001b060 <th_get+0xb4>
	buf = net_pkt_get_frag(pkt, len, TCP_PKT_ALLOC_TIMEOUT);
4001b038:	00a00613          	li	a2,10
4001b03c:	00000693          	li	a3,0
4001b040:	01400593          	li	a1,20
4001b044:	00040513          	mv	a0,s0
4001b048:	e45f70ef          	jal	ra,40012e8c <net_pkt_get_frag>
4001b04c:	00050493          	mv	s1,a0
	if (!buf || buf->size < len) {
4001b050:	00050863          	beqz	a0,4001b060 <th_get+0xb4>
4001b054:	01255583          	lhu	a1,18(a0)
4001b058:	02bbee63          	bltu	s7,a1,4001b094 <th_get+0xe8>
			net_buf_unref(buf);
4001b05c:	8b5ee0ef          	jal	ra,40009910 <net_buf_unref>
	struct tcphdr *th = NULL;
4001b060:	00000513          	li	a0,0
}
4001b064:	02c12083          	lw	ra,44(sp)
4001b068:	02812403          	lw	s0,40(sp)
4001b06c:	02412483          	lw	s1,36(sp)
4001b070:	02012903          	lw	s2,32(sp)
4001b074:	01c12983          	lw	s3,28(sp)
4001b078:	01812a03          	lw	s4,24(sp)
4001b07c:	01412a83          	lw	s5,20(sp)
4001b080:	01012b03          	lw	s6,16(sp)
4001b084:	00c12b83          	lw	s7,12(sp)
4001b088:	00812c03          	lw	s8,8(sp)
4001b08c:	03010113          	addi	sp,sp,48
4001b090:	00008067          	ret
	net_buf_linearize(buf->data, buf->size, pkt->frags, pos, len);
4001b094:	00842603          	lw	a2,8(s0)
4001b098:	00c52503          	lw	a0,12(a0)
4001b09c:	01400713          	li	a4,20
4001b0a0:	000a0693          	mv	a3,s4
4001b0a4:	9c5ee0ef          	jal	ra,40009a68 <net_buf_linearize>
	return net_buf_simple_add(&buf->b, len);
4001b0a8:	01400593          	li	a1,20
4001b0ac:	00c48513          	addi	a0,s1,12
4001b0b0:	a6dee0ef          	jal	ra,40009b1c <net_buf_simple_add>
	len1 = first->len - (pkt->cursor.pos - pkt->cursor.buf->data);
4001b0b4:	00c42683          	lw	a3,12(s0)
4001b0b8:	01042783          	lw	a5,16(s0)
4001b0bc:	010ad703          	lhu	a4,16(s5)
4001b0c0:	00c6a683          	lw	a3,12(a3)
	len2 = len - len1;
4001b0c4:	01400993          	li	s3,20
	len1 = first->len - (pkt->cursor.pos - pkt->cursor.buf->data);
4001b0c8:	40d787b3          	sub	a5,a5,a3
4001b0cc:	40f707b3          	sub	a5,a4,a5
	first->len -= len1;
4001b0d0:	40f70733          	sub	a4,a4,a5
	len2 = len - len1;
4001b0d4:	40f989b3          	sub	s3,s3,a5
	first->len -= len1;
4001b0d8:	00ea9823          	sh	a4,16(s5)
	while (len2) {
4001b0dc:	00099863          	bnez	s3,4001b0ec <th_get+0x140>
	buf->frags = second;
4001b0e0:	0124a223          	sw	s2,4(s1)
	first->frags = buf;
4001b0e4:	009aa223          	sw	s1,4(s5)
	return ret;
4001b0e8:	f09ff06f          	j	4001aff0 <th_get+0x44>
		size_t pull_len = MIN(second->len, len2);
4001b0ec:	01095583          	lhu	a1,16(s2)
4001b0f0:	00b9f463          	bgeu	s3,a1,4001b0f8 <th_get+0x14c>
4001b0f4:	00098593          	mv	a1,s3
	return net_buf_simple_pull(&buf->b, len);
4001b0f8:	00c90513          	addi	a0,s2,12
		len2 -= pull_len;
4001b0fc:	40b989b3          	sub	s3,s3,a1
4001b100:	a59ee0ef          	jal	ra,40009b58 <net_buf_simple_pull>
		if (second->len == 0) {
4001b104:	01095783          	lhu	a5,16(s2)
		next = second->frags;
4001b108:	00492c03          	lw	s8,4(s2)
		if (second->len == 0) {
4001b10c:	00079663          	bnez	a5,4001b118 <th_get+0x16c>
			net_buf_unref(second);
4001b110:	00090513          	mv	a0,s2
4001b114:	ffcee0ef          	jal	ra,40009910 <net_buf_unref>
{
4001b118:	000c0913          	mv	s2,s8
4001b11c:	fc1ff06f          	j	4001b0dc <th_get+0x130>
	return pkt->cursor.pos;
4001b120:	01042503          	lw	a0,16(s0)
	return th;
4001b124:	f41ff06f          	j	4001b064 <th_get+0xb8>

4001b128 <tcp_endpoint_set>:
{
4001b128:	fe010113          	addi	sp,sp,-32
4001b12c:	00812c23          	sw	s0,24(sp)
4001b130:	01412423          	sw	s4,8(sp)
4001b134:	01512223          	sw	s5,4(sp)
4001b138:	00112e23          	sw	ra,28(sp)
4001b13c:	00912a23          	sw	s1,20(sp)
4001b140:	01212823          	sw	s2,16(sp)
4001b144:	01312623          	sw	s3,12(sp)
	return pkt->family;
4001b148:	0345a983          	lw	s3,52(a1)
	switch (net_pkt_family(pkt)) {
4001b14c:	00100a93          	li	s5,1
{
4001b150:	00050413          	mv	s0,a0
4001b154:	01d9d993          	srli	s3,s3,0x1d
4001b158:	00058513          	mv	a0,a1
4001b15c:	00060a13          	mv	s4,a2
	switch (net_pkt_family(pkt)) {
4001b160:	03598a63          	beq	s3,s5,4001b194 <tcp_endpoint_set+0x6c>
4001b164:	00200793          	li	a5,2
4001b168:	0ef98063          	beq	s3,a5,4001b248 <tcp_endpoint_set+0x120>
4001b16c:	fea00513          	li	a0,-22
}
4001b170:	01c12083          	lw	ra,28(sp)
4001b174:	01812403          	lw	s0,24(sp)
4001b178:	01412483          	lw	s1,20(sp)
4001b17c:	01012903          	lw	s2,16(sp)
4001b180:	00c12983          	lw	s3,12(sp)
4001b184:	00812a03          	lw	s4,8(sp)
4001b188:	00412a83          	lw	s5,4(sp)
4001b18c:	02010113          	addi	sp,sp,32
4001b190:	00008067          	ret
	return pkt->frags->data;
4001b194:	0085a783          	lw	a5,8(a1)
4001b198:	00c7a483          	lw	s1,12(a5)
			th = th_get(pkt);
4001b19c:	e11ff0ef          	jal	ra,4001afac <th_get>
4001b1a0:	00050913          	mv	s2,a0
			if (!th) {
4001b1a4:	00051663          	bnez	a0,4001b1b0 <tcp_endpoint_set+0x88>
				return -ENOBUFS;
4001b1a8:	f9700513          	li	a0,-105
4001b1ac:	fc5ff06f          	j	4001b170 <tcp_endpoint_set+0x48>
			memset(ep, 0, sizeof(*ep));
4001b1b0:	01800613          	li	a2,24
4001b1b4:	00000593          	li	a1,0
4001b1b8:	00040513          	mv	a0,s0
4001b1bc:	eb5ed0ef          	jal	ra,40009070 <memset>
			ep->sin.sin_port = src == TCP_EP_SRC ? th_sport(th) :
4001b1c0:	073a1863          	bne	s4,s3,4001b230 <tcp_endpoint_set+0x108>
4001b1c4:	00194783          	lbu	a5,1(s2)
4001b1c8:	00094703          	lbu	a4,0(s2)
4001b1cc:	00879793          	slli	a5,a5,0x8
4001b1d0:	00e7e7b3          	or	a5,a5,a4
			net_ipv4_addr_copy_raw((uint8_t *)&ep->sin.sin_addr,
4001b1d4:	00c48713          	addi	a4,s1,12
4001b1d8:	00f41123          	sh	a5,2(s0)
	net_ipaddr_copy((struct in_addr *)dest, (const struct in_addr *)src);
4001b1dc:	00174783          	lbu	a5,1(a4) # ff0001 <__rom_region_size+0xfbf625>
4001b1e0:	00074683          	lbu	a3,0(a4)
4001b1e4:	00879793          	slli	a5,a5,0x8
4001b1e8:	00d7e7b3          	or	a5,a5,a3
4001b1ec:	00274683          	lbu	a3,2(a4)
4001b1f0:	01069693          	slli	a3,a3,0x10
4001b1f4:	00f6e6b3          	or	a3,a3,a5
4001b1f8:	00374783          	lbu	a5,3(a4)
4001b1fc:	00d40223          	sb	a3,4(s0)
4001b200:	01879793          	slli	a5,a5,0x18
4001b204:	00d7e7b3          	or	a5,a5,a3
4001b208:	0087d713          	srli	a4,a5,0x8
4001b20c:	00e402a3          	sb	a4,5(s0)
4001b210:	0107d713          	srli	a4,a5,0x10
4001b214:	0187d793          	srli	a5,a5,0x18
4001b218:	00f403a3          	sb	a5,7(s0)
4001b21c:	00e40323          	sb	a4,6(s0)
		break;
4001b220:	00100793          	li	a5,1
			ep->sa.sa_family = AF_INET;
4001b224:	00f41023          	sh	a5,0(s0)
	int ret = 0;
4001b228:	00000513          	li	a0,0
4001b22c:	f45ff06f          	j	4001b170 <tcp_endpoint_set+0x48>
							       th_dport(th);
4001b230:	00394783          	lbu	a5,3(s2)
4001b234:	00294703          	lbu	a4,2(s2)
4001b238:	00879793          	slli	a5,a5,0x8
4001b23c:	00e7e7b3          	or	a5,a5,a4
			net_ipv4_addr_copy_raw((uint8_t *)&ep->sin.sin_addr,
4001b240:	01048713          	addi	a4,s1,16
4001b244:	f95ff06f          	j	4001b1d8 <tcp_endpoint_set+0xb0>
4001b248:	0085a783          	lw	a5,8(a1)
4001b24c:	00c7a903          	lw	s2,12(a5)
			th = th_get(pkt);
4001b250:	d5dff0ef          	jal	ra,4001afac <th_get>
4001b254:	00050493          	mv	s1,a0
			if (!th) {
4001b258:	f40508e3          	beqz	a0,4001b1a8 <tcp_endpoint_set+0x80>
			memset(ep, 0, sizeof(*ep));
4001b25c:	01800613          	li	a2,24
4001b260:	00000593          	li	a1,0
4001b264:	00040513          	mv	a0,s0
4001b268:	e09ed0ef          	jal	ra,40009070 <memset>
			net_ipv6_addr_copy_raw((uint8_t *)&ep->sin6.sin6_addr,
4001b26c:	00440513          	addi	a0,s0,4
			ep->sin6.sin6_port = src == TCP_EP_SRC ? th_sport(th) :
4001b270:	035a1663          	bne	s4,s5,4001b29c <tcp_endpoint_set+0x174>
4001b274:	0014c783          	lbu	a5,1(s1)
4001b278:	0004c703          	lbu	a4,0(s1)
			net_ipv6_addr_copy_raw((uint8_t *)&ep->sin6.sin6_addr,
4001b27c:	00890593          	addi	a1,s2,8
			ep->sin6.sin6_port = src == TCP_EP_SRC ? th_sport(th) :
4001b280:	00879793          	slli	a5,a5,0x8
4001b284:	00e7e7b3          	or	a5,a5,a4
			net_ipv6_addr_copy_raw((uint8_t *)&ep->sin6.sin6_addr,
4001b288:	00f41123          	sh	a5,2(s0)
	memcpy(dest, src, sizeof(struct in6_addr));
4001b28c:	01000613          	li	a2,16
4001b290:	dbded0ef          	jal	ra,4000904c <memcpy>
		break;
4001b294:	00200793          	li	a5,2
4001b298:	f8dff06f          	j	4001b224 <tcp_endpoint_set+0xfc>
								 th_dport(th);
4001b29c:	0034c783          	lbu	a5,3(s1)
4001b2a0:	0024c703          	lbu	a4,2(s1)
			net_ipv6_addr_copy_raw((uint8_t *)&ep->sin6.sin6_addr,
4001b2a4:	01890593          	addi	a1,s2,24
								 th_dport(th);
4001b2a8:	00879793          	slli	a5,a5,0x8
4001b2ac:	00e7e7b3          	or	a5,a5,a4
			net_ipv6_addr_copy_raw((uint8_t *)&ep->sin6.sin6_addr,
4001b2b0:	fd9ff06f          	j	4001b288 <tcp_endpoint_set+0x160>

4001b2b4 <tcp_endpoint_cmp>:
{
4001b2b4:	fd010113          	addi	sp,sp,-48
4001b2b8:	02812423          	sw	s0,40(sp)
4001b2bc:	00050413          	mv	s0,a0
	if (tcp_endpoint_set(&ep_tmp, pkt, which) < 0) {
4001b2c0:	00810513          	addi	a0,sp,8
{
4001b2c4:	02112623          	sw	ra,44(sp)
	if (tcp_endpoint_set(&ep_tmp, pkt, which) < 0) {
4001b2c8:	e61ff0ef          	jal	ra,4001b128 <tcp_endpoint_set>
4001b2cc:	02054c63          	bltz	a0,4001b304 <tcp_endpoint_cmp+0x50>
	return (af == AF_INET) ? sizeof(struct sockaddr_in) :
4001b2d0:	00045703          	lhu	a4,0(s0)
4001b2d4:	00100793          	li	a5,1
4001b2d8:	01800613          	li	a2,24
4001b2dc:	00f71463          	bne	a4,a5,4001b2e4 <tcp_endpoint_cmp+0x30>
4001b2e0:	00800613          	li	a2,8
	return !memcmp(ep, &ep_tmp, tcp_endpoint_len(ep->sa.sa_family));
4001b2e4:	00810593          	addi	a1,sp,8
4001b2e8:	00040513          	mv	a0,s0
4001b2ec:	ce1ed0ef          	jal	ra,40008fcc <memcmp>
4001b2f0:	00153513          	seqz	a0,a0
}
4001b2f4:	02c12083          	lw	ra,44(sp)
4001b2f8:	02812403          	lw	s0,40(sp)
4001b2fc:	03010113          	addi	sp,sp,48
4001b300:	00008067          	ret
		return false;
4001b304:	00000513          	li	a0,0
4001b308:	fedff06f          	j	4001b2f4 <tcp_endpoint_cmp+0x40>

4001b30c <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
4001b30c:	6cc0d06f          	j	400289d8 <z_impl_k_mutex_unlock>

4001b310 <tcp_send_timer_cancel>:
	if (conn->in_retransmission == false) {
4001b310:	23c52783          	lw	a5,572(a0)
4001b314:	0087d793          	srli	a5,a5,0x8
4001b318:	0017f793          	andi	a5,a5,1
4001b31c:	0e078463          	beqz	a5,4001b404 <tcp_send_timer_cancel+0xf4>
{
4001b320:	fe010113          	addi	sp,sp,-32
4001b324:	01312623          	sw	s3,12(sp)
	k_work_cancel_delayable(&conn->send_timer);
4001b328:	09050993          	addi	s3,a0,144
{
4001b32c:	00812c23          	sw	s0,24(sp)
4001b330:	00050413          	mv	s0,a0
	k_work_cancel_delayable(&conn->send_timer);
4001b334:	00098513          	mv	a0,s3
{
4001b338:	00112e23          	sw	ra,28(sp)
4001b33c:	00912a23          	sw	s1,20(sp)
4001b340:	01212823          	sw	s2,16(sp)
	k_work_cancel_delayable(&conn->send_timer);
4001b344:	2f80e0ef          	jal	ra,4002963c <k_work_cancel_delayable>
		struct net_pkt *pkt = tcp_slist(conn, &conn->send_queue, get,
4001b348:	02840913          	addi	s2,s0,40
4001b34c:	fff00593          	li	a1,-1
4001b350:	fff00613          	li	a2,-1
4001b354:	00090513          	mv	a0,s2
4001b358:	bc1ff0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
4001b35c:	01840513          	addi	a0,s0,24
4001b360:	895ff0ef          	jal	ra,4001abf4 <sys_slist_get>
4001b364:	00050493          	mv	s1,a0
4001b368:	00090513          	mv	a0,s2
4001b36c:	02049c63          	bnez	s1,4001b3a4 <tcp_send_timer_cancel+0x94>
4001b370:	f9dff0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
	if (sys_slist_is_empty(&conn->send_queue)) {
4001b374:	01842783          	lw	a5,24(s0)
4001b378:	02079e63          	bnez	a5,4001b3b4 <tcp_send_timer_cancel+0xa4>
		conn->in_retransmission = false;
4001b37c:	23d44783          	lbu	a5,573(s0)
4001b380:	ffe7f793          	andi	a5,a5,-2
4001b384:	22f40ea3          	sb	a5,573(s0)
}
4001b388:	01c12083          	lw	ra,28(sp)
4001b38c:	01812403          	lw	s0,24(sp)
4001b390:	01412483          	lw	s1,20(sp)
4001b394:	01012903          	lw	s2,16(sp)
4001b398:	00c12983          	lw	s3,12(sp)
4001b39c:	02010113          	addi	sp,sp,32
4001b3a0:	00008067          	ret
		struct net_pkt *pkt = tcp_slist(conn, &conn->send_queue, get,
4001b3a4:	f69ff0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
			tcp_pkt_unref(pkt);
4001b3a8:	fe448513          	addi	a0,s1,-28
4001b3ac:	b71f70ef          	jal	ra,40012f1c <net_pkt_unref>
4001b3b0:	fc5ff06f          	j	4001b374 <tcp_send_timer_cancel+0x64>
					    K_MSEC(TCP_RTO_MS));
4001b3b4:	23845503          	lhu	a0,568(s0)
		conn->send_retries = tcp_retries;
4001b3b8:	00900793          	li	a5,9
4001b3bc:	20f42a23          	sw	a5,532(s0)
4001b3c0:	00a00613          	li	a2,10
4001b3c4:	00000693          	li	a3,0
4001b3c8:	00950513          	addi	a0,a0,9
4001b3cc:	00000593          	li	a1,0
4001b3d0:	ee9e40ef          	jal	ra,400002b8 <__udivdi3>
}
4001b3d4:	01812403          	lw	s0,24(sp)
4001b3d8:	01c12083          	lw	ra,28(sp)
4001b3dc:	01412483          	lw	s1,20(sp)
4001b3e0:	01012903          	lw	s2,16(sp)
4001b3e4:	00058693          	mv	a3,a1
		k_work_reschedule_for_queue(&tcp_work_q, &conn->send_timer,
4001b3e8:	00098593          	mv	a1,s3
}
4001b3ec:	00c12983          	lw	s3,12(sp)
4001b3f0:	00050613          	mv	a2,a0
		k_work_reschedule_for_queue(&tcp_work_q, &conn->send_timer,
4001b3f4:	40031537          	lui	a0,0x40031
4001b3f8:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
}
4001b3fc:	02010113          	addi	sp,sp,32
		k_work_reschedule_for_queue(&tcp_work_q, &conn->send_timer,
4001b400:	1940e06f          	j	40029594 <k_work_reschedule_for_queue>
4001b404:	00008067          	ret

4001b408 <tcp_cleanup_recv_queue>:
{
4001b408:	ff010113          	addi	sp,sp,-16
4001b40c:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001b410:	f6850493          	addi	s1,a0,-152
{
4001b414:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001b418:	fff00593          	li	a1,-1
{
4001b41c:	00050413          	mv	s0,a0
	k_mutex_lock(&conn->lock, K_FOREVER);
4001b420:	fff00613          	li	a2,-1
4001b424:	00048513          	mv	a0,s1
{
4001b428:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001b42c:	aedff0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	net_buf_unref(conn->queue_recv_data->buffer);
4001b430:	f4c42783          	lw	a5,-180(s0)
4001b434:	0087a503          	lw	a0,8(a5)
4001b438:	cd8ee0ef          	jal	ra,40009910 <net_buf_unref>
	conn->queue_recv_data->buffer = NULL;
4001b43c:	f4c42783          	lw	a5,-180(s0)
	k_mutex_unlock(&conn->lock);
4001b440:	00048513          	mv	a0,s1
	conn->queue_recv_data->buffer = NULL;
4001b444:	0007a423          	sw	zero,8(a5)
}
4001b448:	00812403          	lw	s0,8(sp)
4001b44c:	00c12083          	lw	ra,12(sp)
4001b450:	00412483          	lw	s1,4(sp)
4001b454:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&conn->lock);
4001b458:	eb5ff06f          	j	4001b30c <k_mutex_unlock.isra.0>

4001b45c <tcp_send_process_no_lock>:
{
4001b45c:	ff010113          	addi	sp,sp,-16
4001b460:	01212023          	sw	s2,0(sp)
	pkt = tcp_slist(conn, &conn->send_queue, peek_head,
4001b464:	02850913          	addi	s2,a0,40
{
4001b468:	00812423          	sw	s0,8(sp)
	pkt = tcp_slist(conn, &conn->send_queue, peek_head,
4001b46c:	fff00593          	li	a1,-1
{
4001b470:	00050413          	mv	s0,a0
	pkt = tcp_slist(conn, &conn->send_queue, peek_head,
4001b474:	fff00613          	li	a2,-1
4001b478:	00090513          	mv	a0,s2
{
4001b47c:	00912223          	sw	s1,4(sp)
4001b480:	00112623          	sw	ra,12(sp)
	pkt = tcp_slist(conn, &conn->send_queue, peek_head,
4001b484:	a95ff0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4001b488:	01842483          	lw	s1,24(s0)
4001b48c:	10048263          	beqz	s1,4001b590 <tcp_send_process_no_lock+0x134>
4001b490:	00090513          	mv	a0,s2
4001b494:	e79ff0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
	if (conn->in_retransmission) {
4001b498:	23d44783          	lbu	a5,573(s0)
	pkt = tcp_slist(conn, &conn->send_queue, peek_head,
4001b49c:	fe448493          	addi	s1,s1,-28
	if (conn->in_retransmission) {
4001b4a0:	0017f793          	andi	a5,a5,1
4001b4a4:	06079063          	bnez	a5,4001b504 <tcp_send_process_no_lock+0xa8>
		uint8_t fl = th_get(pkt)->th_flags;
4001b4a8:	00048513          	mv	a0,s1
4001b4ac:	b01ff0ef          	jal	ra,4001afac <th_get>
4001b4b0:	00d54783          	lbu	a5,13(a0)
		bool forget = ACK == fl || PSH == fl || (ACK | PSH) == fl ||
4001b4b4:	01000713          	li	a4,16
4001b4b8:	0ae78e63          	beq	a5,a4,4001b574 <tcp_send_process_no_lock+0x118>
4001b4bc:	0ef7f713          	andi	a4,a5,239
4001b4c0:	00800693          	li	a3,8
4001b4c4:	0ad70863          	beq	a4,a3,4001b574 <tcp_send_process_no_lock+0x118>
4001b4c8:	0047f793          	andi	a5,a5,4
4001b4cc:	0a079463          	bnez	a5,4001b574 <tcp_send_process_no_lock+0x118>
			tcp_pkt_clone(pkt);
4001b4d0:	00048513          	mv	a0,s1
4001b4d4:	00a00593          	li	a1,10
4001b4d8:	00000613          	li	a2,0
4001b4dc:	995f80ef          	jal	ra,40013e70 <net_pkt_clone>
4001b4e0:	00050493          	mv	s1,a0
		if (!pkt) {
4001b4e4:	0e051e63          	bnez	a0,4001b5e0 <tcp_send_process_no_lock+0x184>
	bool unref = false;
4001b4e8:	00000513          	li	a0,0
}
4001b4ec:	00c12083          	lw	ra,12(sp)
4001b4f0:	00812403          	lw	s0,8(sp)
4001b4f4:	00412483          	lw	s1,4(sp)
4001b4f8:	00012903          	lw	s2,0(sp)
4001b4fc:	01010113          	addi	sp,sp,16
4001b500:	00008067          	ret
		if (conn->send_retries > 0) {
4001b504:	21442783          	lw	a5,532(s0)
			unref = true;
4001b508:	00100513          	li	a0,1
		if (conn->send_retries > 0) {
4001b50c:	fe0780e3          	beqz	a5,4001b4ec <tcp_send_process_no_lock+0x90>
			struct net_pkt *clone = tcp_pkt_clone(pkt);
4001b510:	00a00593          	li	a1,10
4001b514:	00000613          	li	a2,0
4001b518:	00048513          	mv	a0,s1
4001b51c:	955f80ef          	jal	ra,40013e70 <net_pkt_clone>
			if (clone) {
4001b520:	00050a63          	beqz	a0,4001b534 <tcp_send_process_no_lock+0xd8>
				tcp_send(clone);
4001b524:	f74ff0ef          	jal	ra,4001ac98 <tcp_send>
				conn->send_retries--;
4001b528:	21442783          	lw	a5,532(s0)
4001b52c:	fff78793          	addi	a5,a5,-1
4001b530:	20f42a23          	sw	a5,532(s0)
	if (conn->in_retransmission) {
4001b534:	23d44783          	lbu	a5,573(s0)
4001b538:	0017f793          	andi	a5,a5,1
4001b53c:	fa0786e3          	beqz	a5,4001b4e8 <tcp_send_process_no_lock+0x8c>
					    K_MSEC(TCP_RTO_MS));
4001b540:	23845503          	lhu	a0,568(s0)
4001b544:	00a00613          	li	a2,10
4001b548:	00000693          	li	a3,0
4001b54c:	00950513          	addi	a0,a0,9
4001b550:	00000593          	li	a1,0
4001b554:	d65e40ef          	jal	ra,400002b8 <__udivdi3>
4001b558:	00050613          	mv	a2,a0
4001b55c:	00058693          	mv	a3,a1
		k_work_reschedule_for_queue(&tcp_work_q, &conn->send_timer,
4001b560:	40031537          	lui	a0,0x40031
4001b564:	09040593          	addi	a1,s0,144
4001b568:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
4001b56c:	0280e0ef          	jal	ra,40029594 <k_work_reschedule_for_queue>
4001b570:	f79ff06f          	j	4001b4e8 <tcp_send_process_no_lock+0x8c>
		pkt = forget ? tcp_slist(conn, &conn->send_queue, get,
4001b574:	00090513          	mv	a0,s2
4001b578:	fff00593          	li	a1,-1
4001b57c:	fff00613          	li	a2,-1
4001b580:	999ff0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
4001b584:	01840513          	addi	a0,s0,24
4001b588:	e6cff0ef          	jal	ra,4001abf4 <sys_slist_get>
4001b58c:	00051863          	bnez	a0,4001b59c <tcp_send_process_no_lock+0x140>
4001b590:	00090513          	mv	a0,s2
4001b594:	d79ff0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
			goto out;
4001b598:	f51ff06f          	j	4001b4e8 <tcp_send_process_no_lock+0x8c>
		pkt = forget ? tcp_slist(conn, &conn->send_queue, get,
4001b59c:	fe450493          	addi	s1,a0,-28
4001b5a0:	00090513          	mv	a0,s2
4001b5a4:	d69ff0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
		if (is_destination_local(pkt)) {
4001b5a8:	00048513          	mv	a0,s1
4001b5ac:	f80ff0ef          	jal	ra,4001ad2c <is_destination_local>
4001b5b0:	00050913          	mv	s2,a0
		tcp_send(pkt);
4001b5b4:	00048513          	mv	a0,s1
4001b5b8:	ee0ff0ef          	jal	ra,4001ac98 <tcp_send>
	if (conn->in_retransmission) {
4001b5bc:	23d44783          	lbu	a5,573(s0)
4001b5c0:	0017f793          	andi	a5,a5,1
4001b5c4:	f6079ee3          	bnez	a5,4001b540 <tcp_send_process_no_lock+0xe4>
	} else if (local && !sys_slist_is_empty(&conn->send_queue)) {
4001b5c8:	f20900e3          	beqz	s2,4001b4e8 <tcp_send_process_no_lock+0x8c>
4001b5cc:	01842783          	lw	a5,24(s0)
4001b5d0:	f0078ce3          	beqz	a5,4001b4e8 <tcp_send_process_no_lock+0x8c>
		k_work_reschedule_for_queue(&tcp_work_q, &conn->send_timer,
4001b5d4:	00000613          	li	a2,0
4001b5d8:	00000693          	li	a3,0
4001b5dc:	f85ff06f          	j	4001b560 <tcp_send_process_no_lock+0x104>
		if (is_destination_local(pkt)) {
4001b5e0:	f4cff0ef          	jal	ra,4001ad2c <is_destination_local>
4001b5e4:	00050913          	mv	s2,a0
		tcp_send(pkt);
4001b5e8:	00048513          	mv	a0,s1
4001b5ec:	eacff0ef          	jal	ra,4001ac98 <tcp_send>
	return z_timeout_remaining(&dwork->timeout);
4001b5f0:	0a040513          	addi	a0,s0,160
4001b5f4:	3f40f0ef          	jal	ra,4002a9e8 <z_timeout_remaining>
		if (forget == false &&
4001b5f8:	00b56533          	or	a0,a0,a1
4001b5fc:	fc0510e3          	bnez	a0,4001b5bc <tcp_send_process_no_lock+0x160>
			conn->send_retries = tcp_retries;
4001b600:	00900793          	li	a5,9
4001b604:	20f42a23          	sw	a5,532(s0)
			conn->in_retransmission = true;
4001b608:	23d44783          	lbu	a5,573(s0)
4001b60c:	0017e793          	ori	a5,a5,1
4001b610:	22f40ea3          	sb	a5,573(s0)
4001b614:	fa9ff06f          	j	4001b5bc <tcp_send_process_no_lock+0x160>

4001b618 <atomic_inc.isra.0>:
	return z_impl_atomic_add(target, value);
4001b618:	00100593          	li	a1,1
4001b61c:	18d0f06f          	j	4002afa8 <z_impl_atomic_add>

4001b620 <tcp_conn_unref.isra.0>:
static int tcp_conn_unref(struct tcp *conn)
4001b620:	fd010113          	addi	sp,sp,-48
4001b624:	00a12623          	sw	a0,12(sp)
	int ref_count = atomic_get(&conn->ref_count);
4001b628:	21c50513          	addi	a0,a0,540
static int tcp_conn_unref(struct tcp *conn)
4001b62c:	02112623          	sw	ra,44(sp)
4001b630:	02812423          	sw	s0,40(sp)
4001b634:	02912223          	sw	s1,36(sp)
4001b638:	03212023          	sw	s2,32(sp)
4001b63c:	01312e23          	sw	s3,28(sp)
	int ref_count = atomic_get(&conn->ref_count);
4001b640:	1a90f0ef          	jal	ra,4002afe8 <atomic_get>
	k_mutex_lock(&conn->lock, K_FOREVER);
4001b644:	00c12503          	lw	a0,12(sp)
4001b648:	fff00593          	li	a1,-1
4001b64c:	fff00613          	li	a2,-1
4001b650:	02850513          	addi	a0,a0,40
4001b654:	8c5ff0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	if (conn->in_connect) {
4001b658:	00c12503          	lw	a0,12(sp)
4001b65c:	23d54783          	lbu	a5,573(a0)
4001b660:	0027f713          	andi	a4,a5,2
4001b664:	00070a63          	beqz	a4,4001b678 <tcp_conn_unref.isra.0+0x58>
		conn->in_connect = false;
4001b668:	ffd7f793          	andi	a5,a5,-3
4001b66c:	22f50ea3          	sb	a5,573(a0)
	z_impl_k_sem_reset(sem);
4001b670:	03c50513          	addi	a0,a0,60
4001b674:	7d40d0ef          	jal	ra,40028e48 <z_impl_k_sem_reset>
	k_mutex_unlock(&conn->lock);
4001b678:	00c12503          	lw	a0,12(sp)
4001b67c:	02850513          	addi	a0,a0,40
4001b680:	c8dff0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
	ref_count = atomic_dec(&conn->ref_count) - 1;
4001b684:	00c12503          	lw	a0,12(sp)
4001b688:	21c50513          	addi	a0,a0,540
	return z_impl_atomic_sub(target, value);
4001b68c:	00100593          	li	a1,1
4001b690:	1390f0ef          	jal	ra,4002afc8 <z_impl_atomic_sub>
	if (ref_count != 0) {
4001b694:	00100793          	li	a5,1
4001b698:	14f51c63          	bne	a0,a5,4001b7f0 <tcp_conn_unref.isra.0+0x1d0>
	k_mutex_lock(&tcp_lock, K_FOREVER);
4001b69c:	4003d937          	lui	s2,0x4003d
4001b6a0:	fff00593          	li	a1,-1
4001b6a4:	fff00613          	li	a2,-1
4001b6a8:	b0090513          	addi	a0,s2,-1280 # 4003cb00 <tcp_lock>
4001b6ac:	86dff0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
		if (net_context_packet_received(
4001b6b0:	00200493          	li	s1,2
	while ((pkt = k_fifo_get(&conn->recv_data, K_NO_WAIT)) != NULL) {
4001b6b4:	00c12503          	lw	a0,12(sp)
4001b6b8:	06c50513          	addi	a0,a0,108
	return z_impl_k_queue_get(queue, timeout);
4001b6bc:	00000593          	li	a1,0
4001b6c0:	00000613          	li	a2,0
4001b6c4:	5a80d0ef          	jal	ra,40028c6c <z_impl_k_queue_get>
4001b6c8:	00c12783          	lw	a5,12(sp)
4001b6cc:	00050413          	mv	s0,a0
4001b6d0:	12051e63          	bnez	a0,4001b80c <tcp_conn_unref.isra.0+0x1ec>
	if (conn->context->conn_handler) {
4001b6d4:	0047a783          	lw	a5,4(a5)
4001b6d8:	0447a503          	lw	a0,68(a5)
4001b6dc:	00050a63          	beqz	a0,4001b6f0 <tcp_conn_unref.isra.0+0xd0>
		net_conn_unregister(conn->context->conn_handler);
4001b6e0:	894f90ef          	jal	ra,40014774 <net_conn_unregister>
		conn->context->conn_handler = NULL;
4001b6e4:	00c12783          	lw	a5,12(sp)
4001b6e8:	0047a783          	lw	a5,4(a5)
4001b6ec:	0407a223          	sw	zero,68(a5)
	conn->context->tcp = NULL;
4001b6f0:	00c12783          	lw	a5,12(sp)
4001b6f4:	0047a703          	lw	a4,4(a5)
4001b6f8:	04072a23          	sw	zero,84(a4)
	net_context_unref(conn->context);
4001b6fc:	0047a503          	lw	a0,4(a5)
4001b700:	83cf60ef          	jal	ra,4001173c <net_context_unref>
	tcp_send_queue_flush(conn);
4001b704:	00c12483          	lw	s1,12(sp)
	k_work_cancel_delayable(&conn->send_timer);
4001b708:	09048513          	addi	a0,s1,144
	while ((pkt = tcp_slist(conn, &conn->send_queue, get,
4001b70c:	02848993          	addi	s3,s1,40
	k_work_cancel_delayable(&conn->send_timer);
4001b710:	72d0d0ef          	jal	ra,4002963c <k_work_cancel_delayable>
	while ((pkt = tcp_slist(conn, &conn->send_queue, get,
4001b714:	01848493          	addi	s1,s1,24
4001b718:	fff00593          	li	a1,-1
4001b71c:	fff00613          	li	a2,-1
4001b720:	00098513          	mv	a0,s3
4001b724:	ff4ff0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
4001b728:	00048513          	mv	a0,s1
4001b72c:	cc8ff0ef          	jal	ra,4001abf4 <sys_slist_get>
4001b730:	00050413          	mv	s0,a0
4001b734:	00098513          	mv	a0,s3
4001b738:	10041063          	bnez	s0,4001b838 <tcp_conn_unref.isra.0+0x218>
4001b73c:	bd1ff0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
	k_work_cancel_delayable(&conn->send_data_timer);
4001b740:	00c12503          	lw	a0,12(sp)
4001b744:	0f050513          	addi	a0,a0,240
4001b748:	6f50d0ef          	jal	ra,4002963c <k_work_cancel_delayable>
	tcp_pkt_unref(conn->send_data);
4001b74c:	00c12783          	lw	a5,12(sp)
4001b750:	0087a503          	lw	a0,8(a5)
4001b754:	fc8f70ef          	jal	ra,40012f1c <net_pkt_unref>
		tcp_pkt_unref(conn->queue_recv_data);
4001b758:	00c12783          	lw	a5,12(sp)
4001b75c:	00c7a503          	lw	a0,12(a5)
4001b760:	fbcf70ef          	jal	ra,40012f1c <net_pkt_unref>
	(void)k_work_cancel_delayable(&conn->timewait_timer);
4001b764:	00c12503          	lw	a0,12(sp)
4001b768:	12050513          	addi	a0,a0,288
4001b76c:	6d10d0ef          	jal	ra,4002963c <k_work_cancel_delayable>
	(void)k_work_cancel_delayable(&conn->fin_timer);
4001b770:	00c12503          	lw	a0,12(sp)
4001b774:	1b050513          	addi	a0,a0,432
4001b778:	6c50d0ef          	jal	ra,4002963c <k_work_cancel_delayable>
	(void)k_work_cancel_delayable(&conn->persist_timer);
4001b77c:	00c12503          	lw	a0,12(sp)
4001b780:	15050513          	addi	a0,a0,336
4001b784:	6b90d0ef          	jal	ra,4002963c <k_work_cancel_delayable>
	(void)k_work_cancel_delayable(&conn->ack_timer);
4001b788:	00c12503          	lw	a0,12(sp)
4001b78c:	18050513          	addi	a0,a0,384
4001b790:	6ad0d0ef          	jal	ra,4002963c <k_work_cancel_delayable>
	sys_slist_find_and_remove(&tcp_conns, &conn->next);
4001b794:	00c12683          	lw	a3,12(sp)
4001b798:	400317b7          	lui	a5,0x40031
4001b79c:	ac47a703          	lw	a4,-1340(a5) # 40030ac4 <tcp_conns>
4001b7a0:	ac478793          	addi	a5,a5,-1340
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4001b7a4:	02070263          	beqz	a4,4001b7c8 <tcp_conn_unref.isra.0+0x1a8>
4001b7a8:	0ae69a63          	bne	a3,a4,4001b85c <tcp_conn_unref.isra.0+0x23c>
	return node->next;
4001b7ac:	0006a703          	lw	a4,0(a3)
Z_GENLIST_REMOVE(slist, snode)
4001b7b0:	08041c63          	bnez	s0,4001b848 <tcp_conn_unref.isra.0+0x228>
4001b7b4:	0047a603          	lw	a2,4(a5)
	list->head = node;
4001b7b8:	00e7a023          	sw	a4,0(a5)
Z_GENLIST_REMOVE(slist, snode)
4001b7bc:	00c69463          	bne	a3,a2,4001b7c4 <tcp_conn_unref.isra.0+0x1a4>
	list->tail = node;
4001b7c0:	00e7a223          	sw	a4,4(a5)
	parent->next = child;
4001b7c4:	0006a023          	sw	zero,0(a3)
	memset(conn, 0, sizeof(*conn));
4001b7c8:	00c12503          	lw	a0,12(sp)
4001b7cc:	24000613          	li	a2,576
4001b7d0:	00000593          	li	a1,0
4001b7d4:	89ded0ef          	jal	ra,40009070 <memset>
	k_mem_slab_free(&tcp_conns_slab, (void **)&conn);
4001b7d8:	4003d537          	lui	a0,0x4003d
4001b7dc:	a5050513          	addi	a0,a0,-1456 # 4003ca50 <tcp_conns_slab>
4001b7e0:	00c10593          	addi	a1,sp,12
4001b7e4:	7e40c0ef          	jal	ra,40027fc8 <k_mem_slab_free>
	k_mutex_unlock(&tcp_lock);
4001b7e8:	b0090513          	addi	a0,s2,-1280
4001b7ec:	b21ff0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
}
4001b7f0:	02c12083          	lw	ra,44(sp)
4001b7f4:	02812403          	lw	s0,40(sp)
4001b7f8:	02412483          	lw	s1,36(sp)
4001b7fc:	02012903          	lw	s2,32(sp)
4001b800:	01c12983          	lw	s3,28(sp)
4001b804:	03010113          	addi	sp,sp,48
4001b808:	00008067          	ret
			    (struct net_conn *)conn->context->conn_handler,
4001b80c:	0047a503          	lw	a0,4(a5)
		if (net_context_packet_received(
4001b810:	0147a703          	lw	a4,20(a5)
4001b814:	00000693          	li	a3,0
4001b818:	04452503          	lw	a0,68(a0)
4001b81c:	00000613          	li	a2,0
4001b820:	00040593          	mv	a1,s0
4001b824:	b81f50ef          	jal	ra,400113a4 <net_context_packet_received>
4001b828:	e89516e3          	bne	a0,s1,4001b6b4 <tcp_conn_unref.isra.0+0x94>
			tcp_pkt_unref(pkt);
4001b82c:	00040513          	mv	a0,s0
4001b830:	eecf70ef          	jal	ra,40012f1c <net_pkt_unref>
4001b834:	e81ff06f          	j	4001b6b4 <tcp_conn_unref.isra.0+0x94>
	while ((pkt = tcp_slist(conn, &conn->send_queue, get,
4001b838:	ad5ff0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
		tcp_pkt_unref(pkt);
4001b83c:	fe440513          	addi	a0,s0,-28
4001b840:	edcf70ef          	jal	ra,40012f1c <net_pkt_unref>
4001b844:	ed5ff06f          	j	4001b718 <tcp_conn_unref.isra.0+0xf8>
4001b848:	00e42023          	sw	a4,0(s0)
Z_GENLIST_REMOVE(slist, snode)
4001b84c:	0047a703          	lw	a4,4(a5)
4001b850:	f6e69ae3          	bne	a3,a4,4001b7c4 <tcp_conn_unref.isra.0+0x1a4>
	list->tail = node;
4001b854:	0087a223          	sw	s0,4(a5)
}
4001b858:	f6dff06f          	j	4001b7c4 <tcp_conn_unref.isra.0+0x1a4>
	return node->next;
4001b85c:	00070413          	mv	s0,a4
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
4001b860:	00072703          	lw	a4,0(a4)
4001b864:	f41ff06f          	j	4001b7a4 <tcp_conn_unref.isra.0+0x184>

4001b868 <tcp_conn_close.isra.0>:
static int tcp_conn_close(struct tcp *conn, int status)
4001b868:	fe010113          	addi	sp,sp,-32
4001b86c:	00812c23          	sw	s0,24(sp)
4001b870:	00112e23          	sw	ra,28(sp)
	if (conn->in_connect) {
4001b874:	23d54783          	lbu	a5,573(a0)
static int tcp_conn_close(struct tcp *conn, int status)
4001b878:	00050413          	mv	s0,a0
4001b87c:	00058713          	mv	a4,a1
	if (conn->in_connect) {
4001b880:	0027f793          	andi	a5,a5,2
4001b884:	02078263          	beqz	a5,4001b8a8 <tcp_conn_close.isra.0+0x40>
		if (conn->connect_cb) {
4001b888:	02452783          	lw	a5,36(a0)
4001b88c:	00078e63          	beqz	a5,4001b8a8 <tcp_conn_close.isra.0+0x40>
			conn->connect_cb(conn->context, status, conn->context->user_data);
4001b890:	00452503          	lw	a0,4(a0)
4001b894:	00b12623          	sw	a1,12(sp)
4001b898:	00452603          	lw	a2,4(a0)
4001b89c:	000780e7          	jalr	a5
			conn->connect_cb = NULL;
4001b8a0:	00c12703          	lw	a4,12(sp)
4001b8a4:	02042223          	sw	zero,36(s0)
	if (conn->context->recv_cb) {
4001b8a8:	00442503          	lw	a0,4(s0)
4001b8ac:	04852803          	lw	a6,72(a0)
4001b8b0:	00080c63          	beqz	a6,4001b8c8 <tcp_conn_close.isra.0+0x60>
		conn->context->recv_cb(conn->context, NULL, NULL, NULL,
4001b8b4:	01442783          	lw	a5,20(s0)
4001b8b8:	00000693          	li	a3,0
4001b8bc:	00000613          	li	a2,0
4001b8c0:	00000593          	li	a1,0
4001b8c4:	000800e7          	jalr	a6
	return tcp_conn_unref(conn);
4001b8c8:	00040513          	mv	a0,s0
}
4001b8cc:	01812403          	lw	s0,24(sp)
4001b8d0:	01c12083          	lw	ra,28(sp)
4001b8d4:	02010113          	addi	sp,sp,32
	return tcp_conn_unref(conn);
4001b8d8:	d49ff06f          	j	4001b620 <tcp_conn_unref.isra.0>

4001b8dc <tcp_send_process>:
{
4001b8dc:	ff010113          	addi	sp,sp,-16
4001b8e0:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001b8e4:	f9850413          	addi	s0,a0,-104
{
4001b8e8:	01212023          	sw	s2,0(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001b8ec:	fff00593          	li	a1,-1
	struct tcp *conn = CONTAINER_OF(dwork, struct tcp, send_timer);
4001b8f0:	f7050913          	addi	s2,a0,-144
	k_mutex_lock(&conn->lock, K_FOREVER);
4001b8f4:	fff00613          	li	a2,-1
4001b8f8:	00040513          	mv	a0,s0
{
4001b8fc:	00112623          	sw	ra,12(sp)
4001b900:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001b904:	e14ff0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	unref = tcp_send_process_no_lock(conn);
4001b908:	00090513          	mv	a0,s2
4001b90c:	b51ff0ef          	jal	ra,4001b45c <tcp_send_process_no_lock>
4001b910:	00050493          	mv	s1,a0
	k_mutex_unlock(&conn->lock);
4001b914:	00040513          	mv	a0,s0
4001b918:	9f5ff0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
	if (unref) {
4001b91c:	02048263          	beqz	s1,4001b940 <tcp_send_process+0x64>
}
4001b920:	00812403          	lw	s0,8(sp)
4001b924:	00c12083          	lw	ra,12(sp)
4001b928:	00412483          	lw	s1,4(sp)
		tcp_conn_close(conn, -ETIMEDOUT);
4001b92c:	00090513          	mv	a0,s2
}
4001b930:	00012903          	lw	s2,0(sp)
		tcp_conn_close(conn, -ETIMEDOUT);
4001b934:	f8c00593          	li	a1,-116
}
4001b938:	01010113          	addi	sp,sp,16
		tcp_conn_close(conn, -ETIMEDOUT);
4001b93c:	f2dff06f          	j	4001b868 <tcp_conn_close.isra.0>
}
4001b940:	00c12083          	lw	ra,12(sp)
4001b944:	00812403          	lw	s0,8(sp)
4001b948:	00412483          	lw	s1,4(sp)
4001b94c:	00012903          	lw	s2,0(sp)
4001b950:	01010113          	addi	sp,sp,16
4001b954:	00008067          	ret

4001b958 <tcp_timewait_timeout>:
	(void)tcp_conn_close(conn, -ETIMEDOUT);
4001b958:	f8c00593          	li	a1,-116
4001b95c:	ee050513          	addi	a0,a0,-288
4001b960:	f09ff06f          	j	4001b868 <tcp_conn_close.isra.0>

4001b964 <tcp_fin_timeout>:
	(void)tcp_conn_close(conn, -ETIMEDOUT);
4001b964:	f8c00593          	li	a1,-116
4001b968:	e5050513          	addi	a0,a0,-432
4001b96c:	efdff06f          	j	4001b868 <tcp_conn_close.isra.0>

4001b970 <tcp_init_isn>:
{
4001b970:	fa010113          	addi	sp,sp,-96
4001b974:	04812c23          	sw	s0,88(sp)
4001b978:	04112e23          	sw	ra,92(sp)
4001b97c:	04912a23          	sw	s1,84(sp)
4001b980:	05212823          	sw	s2,80(sp)
		    saddr->sa_family == AF_INET6) {
4001b984:	00055483          	lhu	s1,0(a0)
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
4001b988:	00200793          	li	a5,2
{
4001b98c:	00058413          	mv	s0,a1
		if (IS_ENABLED(CONFIG_NET_IPV6) &&
4001b990:	0af49e63          	bne	s1,a5,4001ba4c <tcp_init_isn+0xdc>
			return tcpv6_init_isn(&net_sin6(saddr)->sin6_addr,
4001b994:	0025d483          	lhu	s1,2(a1)
4001b998:	00255903          	lhu	s2,2(a0)
	} buf = {
4001b99c:	00450593          	addi	a1,a0,4
4001b9a0:	01000613          	li	a2,16
4001b9a4:	02c10513          	addi	a0,sp,44
4001b9a8:	00012e23          	sw	zero,28(sp)
4001b9ac:	02012023          	sw	zero,32(sp)
4001b9b0:	02012223          	sw	zero,36(sp)
4001b9b4:	02012423          	sw	zero,40(sp)
4001b9b8:	e94ed0ef          	jal	ra,4000904c <memcpy>
4001b9bc:	00440593          	addi	a1,s0,4
4001b9c0:	01000613          	li	a2,16
4001b9c4:	03c10513          	addi	a0,sp,60
4001b9c8:	e84ed0ef          	jal	ra,4000904c <memcpy>
4001b9cc:	04911723          	sh	s1,78(sp)
	if (!once) {
4001b9d0:	400314b7          	lui	s1,0x40031
4001b9d4:	b054c783          	lbu	a5,-1275(s1) # 40030b05 <once.1>
	} buf = {
4001b9d8:	05211623          	sh	s2,76(sp)
4001b9dc:	40032437          	lui	s0,0x40032
	if (!once) {
4001b9e0:	00079c63          	bnez	a5,4001b9f8 <tcp_init_isn+0x88>
4001b9e4:	01000593          	li	a1,16
4001b9e8:	62c40513          	addi	a0,s0,1580 # 4003262c <unique_key>
4001b9ec:	bcded0ef          	jal	ra,400095b8 <z_impl_sys_rand_get>
		once = true;
4001b9f0:	00100793          	li	a5,1
4001b9f4:	b0f482a3          	sb	a5,-1275(s1)
	memcpy(buf.key, unique_key, sizeof(buf.key));
4001b9f8:	01000613          	li	a2,16
4001b9fc:	62c40593          	addi	a1,s0,1580
4001ba00:	01c10513          	addi	a0,sp,28
4001ba04:	e48ed0ef          	jal	ra,4000904c <memcpy>
	mbedtls_md5((const unsigned char *)&buf, sizeof(buf), hash);
4001ba08:	00c10613          	addi	a2,sp,12
4001ba0c:	03400593          	li	a1,52
	mbedtls_md5((const unsigned char *)&buf, sizeof(buf), hash);
4001ba10:	01c10513          	addi	a0,sp,28
4001ba14:	4f90b0ef          	jal	ra,4002770c <mbedtls_md5>
	return seq_scale(UNALIGNED_GET((uint32_t *)&hash[0]));
4001ba18:	00c12403          	lw	s0,12(sp)
	return z_impl_k_uptime_ticks();
4001ba1c:	1980f0ef          	jal	ra,4002abb4 <z_impl_k_uptime_ticks>
			return ((uint32_t)t) * (to_hz / from_hz);
4001ba20:	009897b7          	lui	a5,0x989
4001ba24:	68078793          	addi	a5,a5,1664 # 989680 <__rom_region_size+0x958ca4>
4001ba28:	02f50533          	mul	a0,a0,a5
}
4001ba2c:	05c12083          	lw	ra,92(sp)
4001ba30:	05412483          	lw	s1,84(sp)
4001ba34:	05012903          	lw	s2,80(sp)
	return seq + (k_ticks_to_ns_floor32(k_uptime_ticks()) >> 6);
4001ba38:	00655513          	srli	a0,a0,0x6
4001ba3c:	00850533          	add	a0,a0,s0
}
4001ba40:	05812403          	lw	s0,88(sp)
4001ba44:	06010113          	addi	sp,sp,96
4001ba48:	00008067          	ret
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
4001ba4c:	00100793          	li	a5,1
4001ba50:	06f49863          	bne	s1,a5,4001bac0 <tcp_init_isn+0x150>
			return tcpv4_init_isn(&net_sin(saddr)->sin_addr,
4001ba54:	0025d783          	lhu	a5,2(a1)
4001ba58:	00255703          	lhu	a4,2(a0)
4001ba5c:	00452603          	lw	a2,4(a0)
4001ba60:	0045a683          	lw	a3,4(a1)
	if (!once) {
4001ba64:	40031937          	lui	s2,0x40031
	} buf = {
4001ba68:	02f11b23          	sh	a5,54(sp)
	if (!once) {
4001ba6c:	b0494783          	lbu	a5,-1276(s2) # 40030b04 <once.0>
	} buf = {
4001ba70:	00012e23          	sw	zero,28(sp)
4001ba74:	02012023          	sw	zero,32(sp)
4001ba78:	02012223          	sw	zero,36(sp)
4001ba7c:	02012423          	sw	zero,40(sp)
4001ba80:	02c12623          	sw	a2,44(sp)
4001ba84:	02d12823          	sw	a3,48(sp)
4001ba88:	02e11a23          	sh	a4,52(sp)
4001ba8c:	40032437          	lui	s0,0x40032
	if (!once) {
4001ba90:	00079a63          	bnez	a5,4001baa4 <tcp_init_isn+0x134>
4001ba94:	01000593          	li	a1,16
4001ba98:	62c40513          	addi	a0,s0,1580 # 4003262c <unique_key>
4001ba9c:	b1ded0ef          	jal	ra,400095b8 <z_impl_sys_rand_get>
		once = true;
4001baa0:	b0990223          	sb	s1,-1276(s2)
	memcpy(buf.key, unique_key, sizeof(unique_key));
4001baa4:	01000613          	li	a2,16
4001baa8:	62c40593          	addi	a1,s0,1580
4001baac:	01c10513          	addi	a0,sp,28
4001bab0:	d9ced0ef          	jal	ra,4000904c <memcpy>
	mbedtls_md5((const unsigned char *)&buf, sizeof(buf), hash);
4001bab4:	00c10613          	addi	a2,sp,12
4001bab8:	01c00593          	li	a1,28
4001babc:	f55ff06f          	j	4001ba10 <tcp_init_isn+0xa0>
}
4001bac0:	05812403          	lw	s0,88(sp)
4001bac4:	05c12083          	lw	ra,92(sp)
4001bac8:	05412483          	lw	s1,84(sp)
4001bacc:	05012903          	lw	s2,80(sp)
4001bad0:	06010113          	addi	sp,sp,96
	return z_impl_sys_rand32_get();
4001bad4:	aa1ed06f          	j	40009574 <z_impl_sys_rand32_get>

4001bad8 <net_tcp_get>:
{
4001bad8:	fe010113          	addi	sp,sp,-32
4001badc:	00912a23          	sw	s1,20(sp)
	k_mutex_lock(&tcp_lock, K_FOREVER);
4001bae0:	4003d4b7          	lui	s1,0x4003d
{
4001bae4:	00812c23          	sw	s0,24(sp)
	k_mutex_lock(&tcp_lock, K_FOREVER);
4001bae8:	fff00593          	li	a1,-1
4001baec:	fff00613          	li	a2,-1
{
4001baf0:	00050413          	mv	s0,a0
	k_mutex_lock(&tcp_lock, K_FOREVER);
4001baf4:	b0048513          	addi	a0,s1,-1280 # 4003cb00 <tcp_lock>
{
4001baf8:	01212823          	sw	s2,16(sp)
4001bafc:	00112e23          	sw	ra,28(sp)
	ret = k_mem_slab_alloc(&tcp_conns_slab, (void **)&conn, K_NO_WAIT);
4001bb00:	4003d937          	lui	s2,0x4003d
	k_mutex_lock(&tcp_lock, K_FOREVER);
4001bb04:	c14ff0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	ret = k_mem_slab_alloc(&tcp_conns_slab, (void **)&conn, K_NO_WAIT);
4001bb08:	00000613          	li	a2,0
4001bb0c:	00000693          	li	a3,0
4001bb10:	00c10593          	addi	a1,sp,12
4001bb14:	a5090513          	addi	a0,s2,-1456 # 4003ca50 <tcp_conns_slab>
	struct tcp *conn = NULL;
4001bb18:	00012623          	sw	zero,12(sp)
	ret = k_mem_slab_alloc(&tcp_conns_slab, (void **)&conn, K_NO_WAIT);
4001bb1c:	41c0c0ef          	jal	ra,40027f38 <k_mem_slab_alloc>
	if (ret) {
4001bb20:	16051a63          	bnez	a0,4001bc94 <net_tcp_get+0x1bc>
	memset(conn, 0, sizeof(*conn));
4001bb24:	00c12503          	lw	a0,12(sp)
4001bb28:	24000613          	li	a2,576
4001bb2c:	00000593          	li	a1,0
4001bb30:	d40ed0ef          	jal	ra,40009070 <memset>
		conn->queue_recv_data = tcp_rx_pkt_alloc(conn, 0);
4001bb34:	00a00513          	li	a0,10
4001bb38:	00000593          	li	a1,0
4001bb3c:	f94f70ef          	jal	ra,400132d0 <net_pkt_rx_alloc>
4001bb40:	00c12783          	lw	a5,12(sp)
4001bb44:	00a7a623          	sw	a0,12(a5)
		if (conn->queue_recv_data == NULL) {
4001bb48:	18050463          	beqz	a0,4001bcd0 <net_tcp_get+0x1f8>
	conn->send_data = tcp_pkt_alloc(conn, 0);
4001bb4c:	00a00513          	li	a0,10
4001bb50:	00000593          	li	a1,0
4001bb54:	f68f70ef          	jal	ra,400132bc <net_pkt_alloc>
4001bb58:	00c12783          	lw	a5,12(sp)
4001bb5c:	00a7a423          	sw	a0,8(a5)
	if (conn->send_data == NULL) {
4001bb60:	16050863          	beqz	a0,4001bcd0 <net_tcp_get+0x1f8>
	return z_impl_k_mutex_init(mutex);
4001bb64:	02878513          	addi	a0,a5,40
4001bb68:	4fd0c0ef          	jal	ra,40028864 <z_impl_k_mutex_init>
	k_fifo_init(&conn->recv_data);
4001bb6c:	00c12503          	lw	a0,12(sp)
4001bb70:	06c50513          	addi	a0,a0,108
	z_impl_k_queue_init(queue);
4001bb74:	0ac0d0ef          	jal	ra,40028c20 <z_impl_k_queue_init>
	k_sem_init(&conn->connect_sem, 0, K_SEM_MAX_LIMIT);
4001bb78:	00c12503          	lw	a0,12(sp)
4001bb7c:	03c50513          	addi	a0,a0,60
	return z_impl_k_sem_init(sem, initial_count, limit);
4001bb80:	fff00613          	li	a2,-1
4001bb84:	00000593          	li	a1,0
4001bb88:	1c40d0ef          	jal	ra,40028d4c <z_impl_k_sem_init>
	k_sem_init(&conn->tx_sem, 1, 1);
4001bb8c:	00c12503          	lw	a0,12(sp)
4001bb90:	05450513          	addi	a0,a0,84
4001bb94:	00100613          	li	a2,1
4001bb98:	00100593          	li	a1,1
4001bb9c:	1b00d0ef          	jal	ra,40028d4c <z_impl_k_sem_init>
	conn->in_connect = false;
4001bba0:	00c12503          	lw	a0,12(sp)
	conn->state = TCP_LISTEN;
4001bba4:	00100713          	li	a4,1
	k_work_init_delayable(&conn->send_timer, tcp_send_process);
4001bba8:	4001c5b7          	lui	a1,0x4001c
	conn->state = TCP_LISTEN;
4001bbac:	22e52023          	sw	a4,544(a0)
	conn->recv_win_max = tcp_rx_window;
4001bbb0:	06000737          	lui	a4,0x6000
4001bbb4:	60070713          	addi	a4,a4,1536 # 6000600 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa2500>
4001bbb8:	22e52823          	sw	a4,560(a0)
	conn->send_win_max = MAX(tcp_tx_window, NET_IPV6_MTU);
4001bbbc:	08551737          	lui	a4,0x8551
4001bbc0:	85570713          	addi	a4,a4,-1963 # 8550855 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x25f2755>
4001bbc4:	22e52a23          	sw	a4,564(a0)
	conn->in_connect = false;
4001bbc8:	23d54703          	lbu	a4,573(a0)
	conn->dup_ack_cnt = 0;
4001bbcc:	22050da3          	sb	zero,571(a0)
	conn->seq = 0U;
4001bbd0:	22052423          	sw	zero,552(a0)
	conn->in_connect = false;
4001bbd4:	ff577713          	andi	a4,a4,-11
4001bbd8:	22e50ea3          	sb	a4,573(a0)
	list->head = NULL;
4001bbdc:	00052c23          	sw	zero,24(a0)
	list->tail = NULL;
4001bbe0:	00052e23          	sw	zero,28(a0)
	k_work_init_delayable(&conn->send_timer, tcp_send_process);
4001bbe4:	8dc58593          	addi	a1,a1,-1828 # 4001b8dc <tcp_send_process>
4001bbe8:	09050513          	addi	a0,a0,144
4001bbec:	0e90d0ef          	jal	ra,400294d4 <k_work_init_delayable>
	k_work_init_delayable(&conn->timewait_timer, tcp_timewait_timeout);
4001bbf0:	00c12503          	lw	a0,12(sp)
4001bbf4:	4001c5b7          	lui	a1,0x4001c
4001bbf8:	95858593          	addi	a1,a1,-1704 # 4001b958 <tcp_timewait_timeout>
4001bbfc:	12050513          	addi	a0,a0,288
4001bc00:	0d50d0ef          	jal	ra,400294d4 <k_work_init_delayable>
	k_work_init_delayable(&conn->fin_timer, tcp_fin_timeout);
4001bc04:	00c12503          	lw	a0,12(sp)
4001bc08:	4001c5b7          	lui	a1,0x4001c
4001bc0c:	96458593          	addi	a1,a1,-1692 # 4001b964 <tcp_fin_timeout>
4001bc10:	1b050513          	addi	a0,a0,432
4001bc14:	0c10d0ef          	jal	ra,400294d4 <k_work_init_delayable>
	k_work_init_delayable(&conn->send_data_timer, tcp_resend_data);
4001bc18:	00c12503          	lw	a0,12(sp)
4001bc1c:	4001d5b7          	lui	a1,0x4001d
4001bc20:	a3058593          	addi	a1,a1,-1488 # 4001ca30 <tcp_resend_data>
4001bc24:	0f050513          	addi	a0,a0,240
4001bc28:	0ad0d0ef          	jal	ra,400294d4 <k_work_init_delayable>
	k_work_init_delayable(&conn->recv_queue_timer, tcp_cleanup_recv_queue);
4001bc2c:	00c12503          	lw	a0,12(sp)
4001bc30:	4001b5b7          	lui	a1,0x4001b
4001bc34:	40858593          	addi	a1,a1,1032 # 4001b408 <tcp_cleanup_recv_queue>
4001bc38:	0c050513          	addi	a0,a0,192
4001bc3c:	0990d0ef          	jal	ra,400294d4 <k_work_init_delayable>
	k_work_init_delayable(&conn->persist_timer, tcp_send_zwp);
4001bc40:	00c12503          	lw	a0,12(sp)
4001bc44:	4001c5b7          	lui	a1,0x4001c
4001bc48:	57458593          	addi	a1,a1,1396 # 4001c574 <tcp_send_zwp>
4001bc4c:	15050513          	addi	a0,a0,336
4001bc50:	0850d0ef          	jal	ra,400294d4 <k_work_init_delayable>
	k_work_init_delayable(&conn->ack_timer, tcp_send_ack);
4001bc54:	00c12503          	lw	a0,12(sp)
4001bc58:	4001c5b7          	lui	a1,0x4001c
4001bc5c:	52858593          	addi	a1,a1,1320 # 4001c528 <tcp_send_ack>
4001bc60:	18050513          	addi	a0,a0,384
4001bc64:	0710d0ef          	jal	ra,400294d4 <k_work_init_delayable>
	int ref_count = atomic_inc(&conn->ref_count) + 1;
4001bc68:	00c12503          	lw	a0,12(sp)
4001bc6c:	21c50513          	addi	a0,a0,540
4001bc70:	9a9ff0ef          	jal	ra,4001b618 <atomic_inc.isra.0>
	sys_slist_append(&tcp_conns, &conn->next);
4001bc74:	00c12703          	lw	a4,12(sp)
	return list->tail;
4001bc78:	400317b7          	lui	a5,0x40031
4001bc7c:	ac478793          	addi	a5,a5,-1340 # 40030ac4 <tcp_conns>
	parent->next = child;
4001bc80:	00072023          	sw	zero,0(a4)
	return list->tail;
4001bc84:	0047a683          	lw	a3,4(a5)
Z_GENLIST_APPEND(slist, snode)
4001bc88:	02069e63          	bnez	a3,4001bcc4 <net_tcp_get+0x1ec>
	list->tail = node;
4001bc8c:	00e7a223          	sw	a4,4(a5)
	list->head = node;
4001bc90:	00e7a023          	sw	a4,0(a5)
	return conn;
4001bc94:	00c12783          	lw	a5,12(sp)
	if (conn == NULL) {
4001bc98:	06079063          	bnez	a5,4001bcf8 <net_tcp_get+0x220>
		ret = -ENOMEM;
4001bc9c:	ff400413          	li	s0,-12
	k_mutex_unlock(&tcp_lock);
4001bca0:	b0048513          	addi	a0,s1,-1280
4001bca4:	e68ff0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
}
4001bca8:	01c12083          	lw	ra,28(sp)
4001bcac:	00040513          	mv	a0,s0
4001bcb0:	01812403          	lw	s0,24(sp)
4001bcb4:	01412483          	lw	s1,20(sp)
4001bcb8:	01012903          	lw	s2,16(sp)
4001bcbc:	02010113          	addi	sp,sp,32
4001bcc0:	00008067          	ret
	parent->next = child;
4001bcc4:	00e6a023          	sw	a4,0(a3)
	list->tail = node;
4001bcc8:	00e7a223          	sw	a4,4(a5)
}
4001bccc:	fc9ff06f          	j	4001bc94 <net_tcp_get+0x1bc>
	if (CONFIG_NET_TCP_RECV_QUEUE_TIMEOUT && conn->queue_recv_data) {
4001bcd0:	00c12783          	lw	a5,12(sp)
4001bcd4:	00c7a503          	lw	a0,12(a5)
4001bcd8:	00050863          	beqz	a0,4001bce8 <net_tcp_get+0x210>
		tcp_pkt_unref(conn->queue_recv_data);
4001bcdc:	a40f70ef          	jal	ra,40012f1c <net_pkt_unref>
		conn->queue_recv_data = NULL;
4001bce0:	00c12783          	lw	a5,12(sp)
4001bce4:	0007a623          	sw	zero,12(a5)
	k_mem_slab_free(&tcp_conns_slab, (void **)&conn);
4001bce8:	00c10593          	addi	a1,sp,12
4001bcec:	a5090513          	addi	a0,s2,-1456
4001bcf0:	2d80c0ef          	jal	ra,40027fc8 <k_mem_slab_free>
	if (conn == NULL) {
4001bcf4:	fa9ff06f          	j	4001bc9c <net_tcp_get+0x1c4>
	conn->context = context;
4001bcf8:	0087a223          	sw	s0,4(a5)
	context->tcp = conn;
4001bcfc:	04f42a23          	sw	a5,84(s0)
	int ret = 0;
4001bd00:	00000413          	li	s0,0
4001bd04:	f9dff06f          	j	4001bca0 <net_tcp_get+0x1c8>

4001bd08 <net_tcp_listen>:
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
4001bd08:	07455783          	lhu	a5,116(a0)
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
4001bd0c:	0067e793          	ori	a5,a5,6
4001bd10:	06f51a23          	sh	a5,116(a0)
{
	/* when created, tcp connections are in state TCP_LISTEN */
	net_context_set_state(context, NET_CONTEXT_LISTENING);

	return 0;
}
4001bd14:	00000513          	li	a0,0
4001bd18:	00008067          	ret

4001bd1c <net_tcp_send_data>:

/* net context is about to send out queued data - inform caller only */
int net_tcp_send_data(struct net_context *context, net_context_send_cb_t cb,
		      void *user_data)
{
	if (cb) {
4001bd1c:	02058463          	beqz	a1,4001bd44 <net_tcp_send_data+0x28>
{
4001bd20:	ff010113          	addi	sp,sp,-16
4001bd24:	00112623          	sw	ra,12(sp)
4001bd28:	00058793          	mv	a5,a1
		cb(context, 0, user_data);
4001bd2c:	00000593          	li	a1,0
4001bd30:	000780e7          	jalr	a5
	}

	return 0;
}
4001bd34:	00c12083          	lw	ra,12(sp)
4001bd38:	00000513          	li	a0,0
4001bd3c:	01010113          	addi	sp,sp,16
4001bd40:	00008067          	ret
4001bd44:	00000513          	li	a0,0
4001bd48:	00008067          	ret

4001bd4c <net_tcp_accept>:
	return ret;
}

int net_tcp_accept(struct net_context *context, net_tcp_accept_cb_t cb,
		   void *user_data)
{
4001bd4c:	f9010113          	addi	sp,sp,-112
4001bd50:	06812423          	sw	s0,104(sp)
4001bd54:	06912223          	sw	s1,100(sp)
4001bd58:	05312e23          	sw	s3,92(sp)
4001bd5c:	06112623          	sw	ra,108(sp)
4001bd60:	07212023          	sw	s2,96(sp)
	struct tcp *conn = context->tcp;
4001bd64:	05452903          	lw	s2,84(a0)
{
4001bd68:	00050413          	mv	s0,a0
4001bd6c:	00058993          	mv	s3,a1
4001bd70:	00060493          	mv	s1,a2
	struct sockaddr local_addr = { };
4001bd74:	00000593          	li	a1,0
4001bd78:	01800613          	li	a2,24
4001bd7c:	03810513          	addi	a0,sp,56
4001bd80:	af0ed0ef          	jal	ra,40009070 <memset>
	uint16_t local_port, remote_port;

	if (!conn) {
4001bd84:	02090863          	beqz	s2,4001bdb4 <net_tcp_accept+0x68>
		return -EINVAL;
	}

	NET_DBG("context: %p, tcp: %p, cb: %p", context, conn, cb);

	if (conn->state != TCP_LISTEN) {
4001bd88:	22092703          	lw	a4,544(s2)
4001bd8c:	00100793          	li	a5,1
4001bd90:	02f71263          	bne	a4,a5,4001bdb4 <net_tcp_accept+0x68>
		return -EINVAL;
	}

	conn->accept_cb = cb;
4001bd94:	03392023          	sw	s3,32(s2)
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
4001bd98:	07445783          	lhu	a5,116(s0)
4001bd9c:	0037d793          	srli	a5,a5,0x3
4001bda0:	0077f793          	andi	a5,a5,7
	local_addr.sa_family = net_context_get_family(context);
4001bda4:	02f11c23          	sh	a5,56(sp)

	switch (local_addr.sa_family) {
4001bda8:	02e78663          	beq	a5,a4,4001bdd4 <net_tcp_accept+0x88>
4001bdac:	00200713          	li	a4,2
4001bdb0:	0ee78463          	beq	a5,a4,4001be98 <net_tcp_accept+0x14c>
	/* Remove the temporary connection handler and register
	 * a proper now as we have an established connection.
	 */
	net_conn_unregister(context->conn_handler);

	return net_conn_register(net_context_get_proto(context),
4001bdb4:	fea00513          	li	a0,-22
				 &context->remote : NULL,
				 &local_addr,
				 remote_port, local_port,
				 context, tcp_recv, context,
				 &context->conn_handler);
}
4001bdb8:	06c12083          	lw	ra,108(sp)
4001bdbc:	06812403          	lw	s0,104(sp)
4001bdc0:	06412483          	lw	s1,100(sp)
4001bdc4:	06012903          	lw	s2,96(sp)
4001bdc8:	05c12983          	lw	s3,92(sp)
4001bdcc:	07010113          	addi	sp,sp,112
4001bdd0:	00008067          	ret
		if (net_sin_ptr(&context->local)->sin_addr) {
4001bdd4:	02442783          	lw	a5,36(s0)
4001bdd8:	02078863          	beqz	a5,4001be08 <net_tcp_accept+0xbc>
			net_ipaddr_copy(&in->sin_addr,
4001bddc:	0017c683          	lbu	a3,1(a5)
4001bde0:	0007c703          	lbu	a4,0(a5)
4001bde4:	00869693          	slli	a3,a3,0x8
4001bde8:	00e6e6b3          	or	a3,a3,a4
4001bdec:	0027c703          	lbu	a4,2(a5)
4001bdf0:	0037c783          	lbu	a5,3(a5)
4001bdf4:	01071713          	slli	a4,a4,0x10
4001bdf8:	00d76733          	or	a4,a4,a3
4001bdfc:	01879793          	slli	a5,a5,0x18
4001be00:	00e7e7b3          	or	a5,a5,a4
4001be04:	02f12e23          	sw	a5,60(sp)
		in6->sin6_port =
4001be08:	02245703          	lhu	a4,34(s0)
4001be0c:	02e11d23          	sh	a4,58(sp)
		remote_port = ntohs(net_sin6(&context->remote)->sin6_port);
4001be10:	00875693          	srli	a3,a4,0x8
4001be14:	00871793          	slli	a5,a4,0x8
4001be18:	00d7e7b3          	or	a5,a5,a3
4001be1c:	02e45683          	lhu	a3,46(s0)
	net_conn_unregister(context->conn_handler);
4001be20:	04442503          	lw	a0,68(s0)
4001be24:	01079793          	slli	a5,a5,0x10
4001be28:	00869713          	slli	a4,a3,0x8
4001be2c:	0086d693          	srli	a3,a3,0x8
4001be30:	00d76733          	or	a4,a4,a3
4001be34:	01071713          	slli	a4,a4,0x10
4001be38:	0107d793          	srli	a5,a5,0x10
4001be3c:	01075713          	srli	a4,a4,0x10
	context->user_data = user_data;
4001be40:	00942223          	sw	s1,4(s0)
4001be44:	00e12e23          	sw	a4,28(sp)
4001be48:	00f12c23          	sw	a5,24(sp)
	net_conn_unregister(context->conn_handler);
4001be4c:	929f80ef          	jal	ra,40014774 <net_conn_unregister>
	return net_conn_register(net_context_get_proto(context),
4001be50:	07445683          	lhu	a3,116(s0)
	return context->proto;
4001be54:	07245503          	lhu	a0,114(s0)
4001be58:	03814583          	lbu	a1,56(sp)
4001be5c:	1006f693          	andi	a3,a3,256
4001be60:	01812783          	lw	a5,24(sp)
4001be64:	01c12703          	lw	a4,28(sp)
4001be68:	00000613          	li	a2,0
4001be6c:	00068463          	beqz	a3,4001be74 <net_tcp_accept+0x128>
4001be70:	02c40613          	addi	a2,s0,44
4001be74:	04440693          	addi	a3,s0,68
4001be78:	4001f8b7          	lui	a7,0x4001f
4001be7c:	00d12223          	sw	a3,4(sp)
4001be80:	00812023          	sw	s0,0(sp)
4001be84:	c1488893          	addi	a7,a7,-1004 # 4001ec14 <tcp_recv>
4001be88:	00040813          	mv	a6,s0
4001be8c:	03810693          	addi	a3,sp,56
4001be90:	cb8f80ef          	jal	ra,40014348 <net_conn_register>
4001be94:	f25ff06f          	j	4001bdb8 <net_tcp_accept+0x6c>
		if (net_sin6_ptr(&context->local)->sin6_addr) {
4001be98:	02442583          	lw	a1,36(s0)
4001be9c:	f60586e3          	beqz	a1,4001be08 <net_tcp_accept+0xbc>
			net_ipaddr_copy(&in6->sin6_addr,
4001bea0:	01000613          	li	a2,16
4001bea4:	02810513          	addi	a0,sp,40
4001bea8:	9a4ed0ef          	jal	ra,4000904c <memcpy>
4001beac:	01000613          	li	a2,16
4001beb0:	02810593          	addi	a1,sp,40
4001beb4:	03c10513          	addi	a0,sp,60
4001beb8:	994ed0ef          	jal	ra,4000904c <memcpy>
4001bebc:	f4dff06f          	j	4001be08 <net_tcp_accept+0xbc>

4001bec0 <net_tcp_recv>:

int net_tcp_recv(struct net_context *context, net_context_recv_cb_t cb,
		 void *user_data)
{
	struct tcp *conn = context->tcp;
4001bec0:	05452783          	lw	a5,84(a0)

	NET_DBG("context: %p, cb: %p, user_data: %p", context, cb, user_data);

	context->recv_cb = cb;
4001bec4:	04b52423          	sw	a1,72(a0)

	if (conn) {
4001bec8:	00078463          	beqz	a5,4001bed0 <net_tcp_recv+0x10>
		conn->recv_user_data = user_data;
4001becc:	00c7aa23          	sw	a2,20(a5)
	}

	return 0;
}
4001bed0:	00000513          	li	a0,0
4001bed4:	00008067          	ret

4001bed8 <net_tcp_finalize>:

int net_tcp_finalize(struct net_pkt *pkt)
{
4001bed8:	fd010113          	addi	sp,sp,-48
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
4001bedc:	00c10793          	addi	a5,sp,12
4001bee0:	00f12223          	sw	a5,4(sp)
	struct net_tcp_hdr *tcp_hdr;

	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
4001bee4:	00410593          	addi	a1,sp,4
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
4001bee8:	01400793          	li	a5,20
{
4001beec:	02912223          	sw	s1,36(sp)
4001bef0:	02112623          	sw	ra,44(sp)
4001bef4:	02812423          	sw	s0,40(sp)
4001bef8:	00050493          	mv	s1,a0
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
4001befc:	00f12423          	sw	a5,8(sp)
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
4001bf00:	87cf80ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!tcp_hdr) {
4001bf04:	04050a63          	beqz	a0,4001bf58 <net_tcp_finalize+0x80>
		return -ENOBUFS;
	}

	tcp_hdr->chksum = 0U;
4001bf08:	00050823          	sb	zero,16(a0)
4001bf0c:	000508a3          	sb	zero,17(a0)
4001bf10:	00050413          	mv	s0,a0

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
4001bf14:	0184a503          	lw	a0,24(s1)
4001bf18:	eb8f30ef          	jal	ra,4000f5d0 <net_if_need_calc_tx_checksum>
4001bf1c:	00050e63          	beqz	a0,4001bf38 <net_tcp_finalize+0x60>
	return net_calc_chksum(pkt, IPPROTO_TCP);
4001bf20:	00600593          	li	a1,6
4001bf24:	00048513          	mv	a0,s1
4001bf28:	82df40ef          	jal	ra,40010754 <net_calc_chksum>
		tcp_hdr->chksum = net_calc_chksum_tcp(pkt);
4001bf2c:	00855793          	srli	a5,a0,0x8
4001bf30:	00a40823          	sb	a0,16(s0)
4001bf34:	00f408a3          	sb	a5,17(s0)
	}

	return net_pkt_set_data(pkt, &tcp_access);
4001bf38:	00410593          	addi	a1,sp,4
4001bf3c:	00048513          	mv	a0,s1
4001bf40:	8ccf80ef          	jal	ra,4001400c <net_pkt_set_data>
}
4001bf44:	02c12083          	lw	ra,44(sp)
4001bf48:	02812403          	lw	s0,40(sp)
4001bf4c:	02412483          	lw	s1,36(sp)
4001bf50:	03010113          	addi	sp,sp,48
4001bf54:	00008067          	ret
		return -ENOBUFS;
4001bf58:	f9700513          	li	a0,-105
4001bf5c:	fe9ff06f          	j	4001bf44 <net_tcp_finalize+0x6c>

4001bf60 <net_tcp_input>:

struct net_tcp_hdr *net_tcp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *tcp_access)
{
4001bf60:	ff010113          	addi	sp,sp,-16
4001bf64:	00812423          	sw	s0,8(sp)
4001bf68:	01212023          	sw	s2,0(sp)
4001bf6c:	00112623          	sw	ra,12(sp)
4001bf70:	00912223          	sw	s1,4(sp)
4001bf74:	00050413          	mv	s0,a0
	struct net_tcp_hdr *tcp_hdr;

	if (IS_ENABLED(CONFIG_NET_TCP_CHECKSUM) &&
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
4001bf78:	01852503          	lw	a0,24(a0)
{
4001bf7c:	00058913          	mv	s2,a1
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
4001bf80:	e58f30ef          	jal	ra,4000f5d8 <net_if_need_calc_rx_checksum>
	if (IS_ENABLED(CONFIG_NET_TCP_CHECKSUM) &&
4001bf84:	02051c63          	bnez	a0,4001bfbc <net_tcp_input+0x5c>
	    net_calc_chksum_tcp(pkt) != 0U) {
		NET_DBG("DROP: checksum mismatch");
		goto drop;
	}

	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, tcp_access);
4001bf88:	00090593          	mv	a1,s2
4001bf8c:	00040513          	mv	a0,s0
4001bf90:	fedf70ef          	jal	ra,40013f7c <net_pkt_get_data>
4001bf94:	00050493          	mv	s1,a0
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
4001bf98:	02051c63          	bnez	a0,4001bfd0 <net_tcp_input+0x70>
		return tcp_hdr;
	}

drop:
	net_stats_update_tcp_seg_chkerr(net_pkt_iface(pkt));
	return NULL;
4001bf9c:	00000493          	li	s1,0
}
4001bfa0:	00c12083          	lw	ra,12(sp)
4001bfa4:	00812403          	lw	s0,8(sp)
4001bfa8:	00012903          	lw	s2,0(sp)
4001bfac:	00048513          	mv	a0,s1
4001bfb0:	00412483          	lw	s1,4(sp)
4001bfb4:	01010113          	addi	sp,sp,16
4001bfb8:	00008067          	ret
4001bfbc:	00600593          	li	a1,6
4001bfc0:	00040513          	mv	a0,s0
4001bfc4:	f90f40ef          	jal	ra,40010754 <net_calc_chksum>
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
4001bfc8:	fc0500e3          	beqz	a0,4001bf88 <net_tcp_input+0x28>
4001bfcc:	fd1ff06f          	j	4001bf9c <net_tcp_input+0x3c>
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
4001bfd0:	00090593          	mv	a1,s2
4001bfd4:	00040513          	mv	a0,s0
4001bfd8:	834f80ef          	jal	ra,4001400c <net_pkt_set_data>
4001bfdc:	fc0502e3          	beqz	a0,4001bfa0 <net_tcp_input+0x40>
drop:
4001bfe0:	fbdff06f          	j	4001bf9c <net_tcp_input+0x3c>

4001bfe4 <net_tcp_foreach>:
	}
}
#endif /* CONFIG_NET_TEST_PROTOCOL */

void net_tcp_foreach(net_tcp_cb_t cb, void *user_data)
{
4001bfe4:	fe010113          	addi	sp,sp,-32
4001bfe8:	00912a23          	sw	s1,20(sp)
	struct tcp *conn;
	struct tcp *tmp;

	k_mutex_lock(&tcp_lock, K_FOREVER);
4001bfec:	4003d4b7          	lui	s1,0x4003d
{
4001bff0:	01312623          	sw	s3,12(sp)
4001bff4:	01412423          	sw	s4,8(sp)
4001bff8:	00050993          	mv	s3,a0
4001bffc:	00058a13          	mv	s4,a1
	k_mutex_lock(&tcp_lock, K_FOREVER);
4001c000:	fff00613          	li	a2,-1
4001c004:	fff00593          	li	a1,-1
4001c008:	b0048513          	addi	a0,s1,-1280 # 4003cb00 <tcp_lock>
{
4001c00c:	00812c23          	sw	s0,24(sp)
4001c010:	00112e23          	sw	ra,28(sp)
4001c014:	01212823          	sw	s2,16(sp)
	k_mutex_lock(&tcp_lock, K_FOREVER);
4001c018:	f01fe0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	return list->head;
4001c01c:	400317b7          	lui	a5,0x40031
4001c020:	ac47a403          	lw	s0,-1340(a5) # 40030ac4 <tcp_conns>

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp_conns, conn, tmp, next) {
4001c024:	00040663          	beqz	s0,4001c030 <net_tcp_foreach+0x4c>
	return node->next;
4001c028:	00042903          	lw	s2,0(s0)
4001c02c:	02041463          	bnez	s0,4001c054 <net_tcp_foreach+0x70>
			k_mutex_lock(&tcp_lock, K_FOREVER);
		}
	}

	k_mutex_unlock(&tcp_lock);
}
4001c030:	01812403          	lw	s0,24(sp)
4001c034:	01c12083          	lw	ra,28(sp)
4001c038:	01012903          	lw	s2,16(sp)
4001c03c:	00c12983          	lw	s3,12(sp)
4001c040:	00812a03          	lw	s4,8(sp)
	k_mutex_unlock(&tcp_lock);
4001c044:	b0048513          	addi	a0,s1,-1280
}
4001c048:	01412483          	lw	s1,20(sp)
4001c04c:	02010113          	addi	sp,sp,32
	k_mutex_unlock(&tcp_lock);
4001c050:	abcff06f          	j	4001b30c <k_mutex_unlock.isra.0>
		if (atomic_get(&conn->ref_count) > 0) {
4001c054:	21c40513          	addi	a0,s0,540
4001c058:	7910e0ef          	jal	ra,4002afe8 <atomic_get>
4001c05c:	02a05463          	blez	a0,4001c084 <net_tcp_foreach+0xa0>
			k_mutex_unlock(&tcp_lock);
4001c060:	b0048513          	addi	a0,s1,-1280
4001c064:	aa8ff0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
			cb(conn, user_data);
4001c068:	000a0593          	mv	a1,s4
4001c06c:	00040513          	mv	a0,s0
4001c070:	000980e7          	jalr	s3
			k_mutex_lock(&tcp_lock, K_FOREVER);
4001c074:	fff00593          	li	a1,-1
4001c078:	fff00613          	li	a2,-1
4001c07c:	b0048513          	addi	a0,s1,-1280
4001c080:	e99fe0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp_conns, conn, tmp, next) {
4001c084:	00000793          	li	a5,0
4001c088:	00090463          	beqz	s2,4001c090 <net_tcp_foreach+0xac>
4001c08c:	00092783          	lw	a5,0(s2)
4001c090:	00090413          	mv	s0,s2
4001c094:	00078913          	mv	s2,a5
4001c098:	f95ff06f          	j	4001c02c <net_tcp_foreach+0x48>

4001c09c <net_tcp_get_supported_mss>:

uint16_t net_tcp_get_supported_mss(const struct tcp *conn)
{
4001c09c:	ff010113          	addi	sp,sp,-16
4001c0a0:	00112623          	sw	ra,12(sp)
	sa_family_t family = net_context_get_family(conn->context);
4001c0a4:	00452703          	lw	a4,4(a0)

	if (family == AF_INET) {
4001c0a8:	00100693          	li	a3,1
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
4001c0ac:	07475783          	lhu	a5,116(a4)
4001c0b0:	0037d793          	srli	a5,a5,0x3
4001c0b4:	0077f793          	andi	a5,a5,7
4001c0b8:	04d79463          	bne	a5,a3,4001c100 <net_tcp_get_supported_mss+0x64>
#if defined(CONFIG_NET_IPV4)
		struct net_if *iface = net_context_get_iface(conn->context);
4001c0bc:	07670503          	lb	a0,118(a4)
4001c0c0:	ee9fe0ef          	jal	ra,4001afa8 <net_context_get_iface.isra.0>
			 */
			mss = net_if_get_mtu(iface) - NET_IPV4TCPH_LEN;
		}

		if (mss == 0) {
			mss = NET_IPV4_MTU - NET_IPV4TCPH_LEN;
4001c0c4:	21800793          	li	a5,536
		if (iface && net_if_get_mtu(iface) >= NET_IPV4TCPH_LEN) {
4001c0c8:	02050263          	beqz	a0,4001c0ec <net_tcp_get_supported_mss+0x50>
	return iface->if_dev->mtu;
4001c0cc:	00052783          	lw	a5,0(a0)
4001c0d0:	02700693          	li	a3,39
4001c0d4:	0187d703          	lhu	a4,24(a5)
			mss = NET_IPV4_MTU - NET_IPV4TCPH_LEN;
4001c0d8:	21800793          	li	a5,536
		if (iface && net_if_get_mtu(iface) >= NET_IPV4TCPH_LEN) {
4001c0dc:	00e6f863          	bgeu	a3,a4,4001c0ec <net_tcp_get_supported_mss+0x50>
			mss = net_if_get_mtu(iface) - NET_IPV4TCPH_LEN;
4001c0e0:	fd870793          	addi	a5,a4,-40
		if (mss == 0) {
4001c0e4:	00079463          	bnez	a5,4001c0ec <net_tcp_get_supported_mss+0x50>
			mss = NET_IPV4_MTU - NET_IPV4TCPH_LEN;
4001c0e8:	21800793          	li	a5,536

		if (mss == 0) {
			mss = NET_IPV6_MTU - NET_IPV6TCPH_LEN;
		}

		return mss;
4001c0ec:	01079513          	slli	a0,a5,0x10
4001c0f0:	01055513          	srli	a0,a0,0x10
	}
#endif /* CONFIG_NET_IPV6 */

	return 0;
}
4001c0f4:	00c12083          	lw	ra,12(sp)
4001c0f8:	01010113          	addi	sp,sp,16
4001c0fc:	00008067          	ret
	else if (family == AF_INET6) {
4001c100:	00200693          	li	a3,2
	return 0;
4001c104:	00000513          	li	a0,0
	else if (family == AF_INET6) {
4001c108:	fed796e3          	bne	a5,a3,4001c0f4 <net_tcp_get_supported_mss+0x58>
		struct net_if *iface = net_context_get_iface(conn->context);
4001c10c:	07670503          	lb	a0,118(a4)
4001c110:	e99fe0ef          	jal	ra,4001afa8 <net_context_get_iface.isra.0>
			mss = NET_IPV6_MTU - NET_IPV6TCPH_LEN;
4001c114:	4c400793          	li	a5,1220
		if (iface && net_if_get_mtu(iface) >= NET_IPV6TCPH_LEN) {
4001c118:	fc050ae3          	beqz	a0,4001c0ec <net_tcp_get_supported_mss+0x50>
4001c11c:	00052783          	lw	a5,0(a0)
4001c120:	03b00693          	li	a3,59
4001c124:	0187d703          	lhu	a4,24(a5)
			mss = NET_IPV6_MTU - NET_IPV6TCPH_LEN;
4001c128:	4c400793          	li	a5,1220
		if (iface && net_if_get_mtu(iface) >= NET_IPV6TCPH_LEN) {
4001c12c:	fce6f0e3          	bgeu	a3,a4,4001c0ec <net_tcp_get_supported_mss+0x50>
			mss = net_if_get_mtu(iface) - NET_IPV6TCPH_LEN;
4001c130:	fc470793          	addi	a5,a4,-60
		if (mss == 0) {
4001c134:	fa079ce3          	bnez	a5,4001c0ec <net_tcp_get_supported_mss+0x50>
			mss = NET_IPV6_MTU - NET_IPV6TCPH_LEN;
4001c138:	4c400793          	li	a5,1220
4001c13c:	fb1ff06f          	j	4001c0ec <net_tcp_get_supported_mss+0x50>

4001c140 <tcp_out_ext>:
{
4001c140:	fc010113          	addi	sp,sp,-64
4001c144:	02812c23          	sw	s0,56(sp)
4001c148:	02912a23          	sw	s1,52(sp)
4001c14c:	03312623          	sw	s3,44(sp)
4001c150:	03612023          	sw	s6,32(sp)
4001c154:	02112e23          	sw	ra,60(sp)
4001c158:	03212823          	sw	s2,48(sp)
4001c15c:	03412423          	sw	s4,40(sp)
4001c160:	03512223          	sw	s5,36(sp)
	if (conn->send_options.mss_found) {
4001c164:	08e54783          	lbu	a5,142(a0)
{
4001c168:	00058b13          	mv	s6,a1
4001c16c:	00050493          	mv	s1,a0
	if (conn->send_options.mss_found) {
4001c170:	0017f793          	andi	a5,a5,1
{
4001c174:	00060413          	mv	s0,a2
4001c178:	00068993          	mv	s3,a3
	size_t alloc_len = sizeof(struct tcphdr);
4001c17c:	01400593          	li	a1,20
	if (conn->send_options.mss_found) {
4001c180:	00078463          	beqz	a5,4001c188 <tcp_out_ext+0x48>
4001c184:	01800593          	li	a1,24
4001c188:	0044a783          	lw	a5,4(s1)
	pkt = tcp_pkt_alloc(conn, alloc_len);
4001c18c:	0104a503          	lw	a0,16(s1)
4001c190:	00a00713          	li	a4,10
4001c194:	0747d603          	lhu	a2,116(a5)
4001c198:	00600693          	li	a3,6
4001c19c:	00000793          	li	a5,0
4001c1a0:	00365613          	srli	a2,a2,0x3
4001c1a4:	00767613          	andi	a2,a2,7
4001c1a8:	d74f70ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
4001c1ac:	00050913          	mv	s2,a0
	if (!pkt) {
4001c1b0:	36050263          	beqz	a0,4001c514 <tcp_out_ext+0x3d4>
	if (data) {
4001c1b4:	00040863          	beqz	s0,4001c1c4 <tcp_out_ext+0x84>
		net_pkt_append_buffer(pkt, data->buffer);
4001c1b8:	00842583          	lw	a1,8(s0)
4001c1bc:	978f70ef          	jal	ra,40013334 <net_pkt_append_buffer>
		data->buffer = NULL;
4001c1c0:	00042423          	sw	zero,8(s0)
	return pkt->family;
4001c1c4:	03492783          	lw	a5,52(s2)
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
4001c1c8:	00100713          	li	a4,1
4001c1cc:	01d7d793          	srli	a5,a5,0x1d
4001c1d0:	04e79a63          	bne	a5,a4,4001c224 <tcp_out_ext+0xe4>
		return net_context_create_ipv4_new(conn->context, pkt,
4001c1d4:	0044a503          	lw	a0,4(s1)
4001c1d8:	1fc48693          	addi	a3,s1,508
4001c1dc:	1e448613          	addi	a2,s1,484
4001c1e0:	00090593          	mv	a1,s2
4001c1e4:	9f1f50ef          	jal	ra,40011bd4 <net_context_create_ipv4_new>
		return net_context_create_ipv6_new(conn->context, pkt,
4001c1e8:	00050413          	mv	s0,a0
	if (ret < 0) {
4001c1ec:	04055c63          	bgez	a0,4001c244 <tcp_out_ext+0x104>
		tcp_pkt_unref(pkt);
4001c1f0:	00090513          	mv	a0,s2
4001c1f4:	d29f60ef          	jal	ra,40012f1c <net_pkt_unref>
}
4001c1f8:	03c12083          	lw	ra,60(sp)
4001c1fc:	00040513          	mv	a0,s0
4001c200:	03812403          	lw	s0,56(sp)
4001c204:	03412483          	lw	s1,52(sp)
4001c208:	03012903          	lw	s2,48(sp)
4001c20c:	02c12983          	lw	s3,44(sp)
4001c210:	02812a03          	lw	s4,40(sp)
4001c214:	02412a83          	lw	s5,36(sp)
4001c218:	02012b03          	lw	s6,32(sp)
4001c21c:	04010113          	addi	sp,sp,64
4001c220:	00008067          	ret
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
4001c224:	00200713          	li	a4,2
4001c228:	26e79e63          	bne	a5,a4,4001c4a4 <tcp_out_ext+0x364>
		return net_context_create_ipv6_new(conn->context, pkt,
4001c22c:	0044a503          	lw	a0,4(s1)
4001c230:	1fc48693          	addi	a3,s1,508
4001c234:	1e448613          	addi	a2,s1,484
4001c238:	00090593          	mv	a1,s2
4001c23c:	abdf50ef          	jal	ra,40011cf8 <net_context_create_ipv6_new>
4001c240:	fa9ff06f          	j	4001c1e8 <tcp_out_ext+0xa8>
	th = (struct tcphdr *)net_pkt_get_data(pkt, &tcp_access);
4001c244:	00410a93          	addi	s5,sp,4
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct tcphdr);
4001c248:	01400793          	li	a5,20
4001c24c:	00c10a13          	addi	s4,sp,12
	th = (struct tcphdr *)net_pkt_get_data(pkt, &tcp_access);
4001c250:	000a8593          	mv	a1,s5
4001c254:	00090513          	mv	a0,s2
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct tcphdr);
4001c258:	01412223          	sw	s4,4(sp)
4001c25c:	00f12423          	sw	a5,8(sp)
	th = (struct tcphdr *)net_pkt_get_data(pkt, &tcp_access);
4001c260:	d1df70ef          	jal	ra,40013f7c <net_pkt_get_data>
4001c264:	00050413          	mv	s0,a0
	if (!th) {
4001c268:	00051663          	bnez	a0,4001c274 <tcp_out_ext+0x134>
		return -ENOBUFS;
4001c26c:	f9700413          	li	s0,-105
4001c270:	f81ff06f          	j	4001c1f0 <tcp_out_ext+0xb0>
	memset(th, 0, sizeof(struct tcphdr));
4001c274:	00000593          	li	a1,0
4001c278:	01400613          	li	a2,20
4001c27c:	df5ec0ef          	jal	ra,40009070 <memset>
	UNALIGNED_PUT(conn->src.sin.sin_port, &th->th_sport);
4001c280:	1e24d783          	lhu	a5,482(s1)
	UNALIGNED_PUT(htonl(seq), &th->th_seq);
4001c284:	000106b7          	lui	a3,0x10
4001c288:	f0068693          	addi	a3,a3,-256 # ff00 <__kernel_ram_size+0x3c6c>
	UNALIGNED_PUT(conn->src.sin.sin_port, &th->th_sport);
4001c28c:	00f40023          	sb	a5,0(s0)
4001c290:	0087d793          	srli	a5,a5,0x8
4001c294:	00f400a3          	sb	a5,1(s0)
	UNALIGNED_PUT(conn->dst.sin.sin_port, &th->th_dport);
4001c298:	1fa4d783          	lhu	a5,506(s1)
	UNALIGNED_PUT(htonl(seq), &th->th_seq);
4001c29c:	00ff05b7          	lui	a1,0xff0
	UNALIGNED_PUT(conn->dst.sin.sin_port, &th->th_dport);
4001c2a0:	00f40123          	sb	a5,2(s0)
4001c2a4:	0087d793          	srli	a5,a5,0x8
4001c2a8:	00f401a3          	sb	a5,3(s0)
	th->th_off = 5;
4001c2ac:	00c44783          	lbu	a5,12(s0)
4001c2b0:	00f7f793          	andi	a5,a5,15
4001c2b4:	0507e793          	ori	a5,a5,80
4001c2b8:	00f40623          	sb	a5,12(s0)
	if (conn->send_options.mss_found) {
4001c2bc:	08e4c783          	lbu	a5,142(s1)
4001c2c0:	00c44703          	lbu	a4,12(s0)
	UNALIGNED_PUT(flags, &th->th_flags);
4001c2c4:	016406a3          	sb	s6,13(s0)
	if (conn->send_options.mss_found) {
4001c2c8:	0017f793          	andi	a5,a5,1
4001c2cc:	00578793          	addi	a5,a5,5
4001c2d0:	00f77713          	andi	a4,a4,15
4001c2d4:	00479793          	slli	a5,a5,0x4
4001c2d8:	00f767b3          	or	a5,a4,a5
4001c2dc:	00f40623          	sb	a5,12(s0)
	UNALIGNED_PUT(htons(conn->recv_win), &th->th_win);
4001c2e0:	2324d703          	lhu	a4,562(s1)
	if (ACK & flags) {
4001c2e4:	010b7b13          	andi	s6,s6,16
	UNALIGNED_PUT(htons(conn->recv_win), &th->th_win);
4001c2e8:	00871793          	slli	a5,a4,0x8
4001c2ec:	00875713          	srli	a4,a4,0x8
4001c2f0:	00e7e7b3          	or	a5,a5,a4
4001c2f4:	01079713          	slli	a4,a5,0x10
4001c2f8:	01075713          	srli	a4,a4,0x10
4001c2fc:	00f40723          	sb	a5,14(s0)
4001c300:	00875793          	srli	a5,a4,0x8
4001c304:	00f407a3          	sb	a5,15(s0)
	UNALIGNED_PUT(htonl(seq), &th->th_seq);
4001c308:	01899713          	slli	a4,s3,0x18
4001c30c:	0189d793          	srli	a5,s3,0x18
4001c310:	00e7e7b3          	or	a5,a5,a4
4001c314:	0089d713          	srli	a4,s3,0x8
4001c318:	00d77733          	and	a4,a4,a3
4001c31c:	00899993          	slli	s3,s3,0x8
4001c320:	00e7e7b3          	or	a5,a5,a4
4001c324:	00b9f9b3          	and	s3,s3,a1
4001c328:	0137e9b3          	or	s3,a5,s3
4001c32c:	00f40223          	sb	a5,4(s0)
4001c330:	0089d793          	srli	a5,s3,0x8
4001c334:	00f402a3          	sb	a5,5(s0)
4001c338:	0109d793          	srli	a5,s3,0x10
4001c33c:	0189d993          	srli	s3,s3,0x18
4001c340:	00f40323          	sb	a5,6(s0)
4001c344:	013403a3          	sb	s3,7(s0)
	if (ACK & flags) {
4001c348:	040b0463          	beqz	s6,4001c390 <tcp_out_ext+0x250>
		UNALIGNED_PUT(htonl(conn->ack), &th->th_ack);
4001c34c:	22c4a783          	lw	a5,556(s1)
4001c350:	01879613          	slli	a2,a5,0x18
4001c354:	0187d713          	srli	a4,a5,0x18
4001c358:	00c76733          	or	a4,a4,a2
4001c35c:	0087d613          	srli	a2,a5,0x8
4001c360:	00d676b3          	and	a3,a2,a3
4001c364:	00879793          	slli	a5,a5,0x8
4001c368:	00d76733          	or	a4,a4,a3
4001c36c:	00b7f7b3          	and	a5,a5,a1
4001c370:	00f767b3          	or	a5,a4,a5
4001c374:	00e40423          	sb	a4,8(s0)
4001c378:	0087d713          	srli	a4,a5,0x8
4001c37c:	00e404a3          	sb	a4,9(s0)
4001c380:	0107d713          	srli	a4,a5,0x10
4001c384:	0187d793          	srli	a5,a5,0x18
4001c388:	00e40523          	sb	a4,10(s0)
4001c38c:	00f405a3          	sb	a5,11(s0)
	return net_pkt_set_data(pkt, &tcp_access);
4001c390:	000a8593          	mv	a1,s5
4001c394:	00090513          	mv	a0,s2
4001c398:	c75f70ef          	jal	ra,4001400c <net_pkt_set_data>
4001c39c:	00050413          	mv	s0,a0
	if (ret < 0) {
4001c3a0:	e40548e3          	bltz	a0,4001c1f0 <tcp_out_ext+0xb0>
	if (conn->send_options.mss_found) {
4001c3a4:	08e4c783          	lbu	a5,142(s1)
4001c3a8:	0017f793          	andi	a5,a5,1
4001c3ac:	06078e63          	beqz	a5,4001c428 <tcp_out_ext+0x2e8>
	NET_PKT_DATA_ACCESS_DEFINE(mss_opt_access, struct tcp_mss_option);
4001c3b0:	00400793          	li	a5,4
	mss = net_pkt_get_data(pkt, &mss_opt_access);
4001c3b4:	000a0593          	mv	a1,s4
4001c3b8:	00090513          	mv	a0,s2
	NET_PKT_DATA_ACCESS_DEFINE(mss_opt_access, struct tcp_mss_option);
4001c3bc:	01512623          	sw	s5,12(sp)
4001c3c0:	00f12823          	sw	a5,16(sp)
	mss = net_pkt_get_data(pkt, &mss_opt_access);
4001c3c4:	bb9f70ef          	jal	ra,40013f7c <net_pkt_get_data>
4001c3c8:	00050413          	mv	s0,a0
	if (!mss) {
4001c3cc:	ea0500e3          	beqz	a0,4001c26c <tcp_out_ext+0x12c>
	recv_mss = net_tcp_get_supported_mss(conn);
4001c3d0:	00048513          	mv	a0,s1
4001c3d4:	cc9ff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
	recv_mss |= (NET_TCP_MSS_OPT << 24) | (NET_TCP_MSS_SIZE << 16);
4001c3d8:	020407b7          	lui	a5,0x2040
4001c3dc:	00f56533          	or	a0,a0,a5
	UNALIGNED_PUT(htonl(recv_mss), (uint32_t *)mss);
4001c3e0:	00851793          	slli	a5,a0,0x8
4001c3e4:	00ff0737          	lui	a4,0xff0
4001c3e8:	00e7f7b3          	and	a5,a5,a4
4001c3ec:	01851513          	slli	a0,a0,0x18
4001c3f0:	00200713          	li	a4,2
4001c3f4:	00a7e7b3          	or	a5,a5,a0
4001c3f8:	00e40023          	sb	a4,0(s0)
4001c3fc:	00400713          	li	a4,4
4001c400:	00e400a3          	sb	a4,1(s0)
4001c404:	0107d713          	srli	a4,a5,0x10
4001c408:	0187d793          	srli	a5,a5,0x18
4001c40c:	00e40123          	sb	a4,2(s0)
4001c410:	00f401a3          	sb	a5,3(s0)
	return net_pkt_set_data(pkt, &mss_opt_access);
4001c414:	000a0593          	mv	a1,s4
4001c418:	00090513          	mv	a0,s2
4001c41c:	bf1f70ef          	jal	ra,4001400c <net_pkt_set_data>
4001c420:	00050413          	mv	s0,a0
		if (ret < 0) {
4001c424:	dc0546e3          	bltz	a0,4001c1f0 <tcp_out_ext+0xb0>
	net_pkt_cursor_init(pkt);
4001c428:	00090513          	mv	a0,s2
4001c42c:	dc5f60ef          	jal	ra,400131f0 <net_pkt_cursor_init>
4001c430:	03492783          	lw	a5,52(s2)
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
4001c434:	00100713          	li	a4,1
4001c438:	01d7d793          	srli	a5,a5,0x1d
4001c43c:	04e79863          	bne	a5,a4,4001c48c <tcp_out_ext+0x34c>
		return net_ipv4_finalize(pkt, IPPROTO_TCP);
4001c440:	00600593          	li	a1,6
4001c444:	00090513          	mv	a0,s2
4001c448:	ba0f90ef          	jal	ra,400157e8 <net_ipv4_finalize>
		return net_ipv6_finalize(pkt, IPPROTO_TCP);
4001c44c:	00050413          	mv	s0,a0
	if (ret < 0) {
4001c450:	da0540e3          	bltz	a0,4001c1f0 <tcp_out_ext+0xb0>
	if (tcp_send_cb) {
4001c454:	400317b7          	lui	a5,0x40031
4001c458:	ac07a783          	lw	a5,-1344(a5) # 40030ac0 <tcp_send_cb>
4001c45c:	04078863          	beqz	a5,4001c4ac <tcp_out_ext+0x36c>
}
4001c460:	03812403          	lw	s0,56(sp)
4001c464:	03c12083          	lw	ra,60(sp)
4001c468:	03412483          	lw	s1,52(sp)
4001c46c:	02c12983          	lw	s3,44(sp)
4001c470:	02812a03          	lw	s4,40(sp)
4001c474:	02412a83          	lw	s5,36(sp)
4001c478:	02012b03          	lw	s6,32(sp)
		ret = tcp_send_cb(pkt);
4001c47c:	00090513          	mv	a0,s2
}
4001c480:	03012903          	lw	s2,48(sp)
4001c484:	04010113          	addi	sp,sp,64
		ret = tcp_send_cb(pkt);
4001c488:	00078067          	jr	a5
	if (IS_ENABLED(CONFIG_NET_IPV6) && net_pkt_family(pkt) == AF_INET6) {
4001c48c:	00200713          	li	a4,2
4001c490:	00e79a63          	bne	a5,a4,4001c4a4 <tcp_out_ext+0x364>
		return net_ipv6_finalize(pkt, IPPROTO_TCP);
4001c494:	00600593          	li	a1,6
4001c498:	00090513          	mv	a0,s2
4001c49c:	d44fa0ef          	jal	ra,400169e0 <net_ipv6_finalize>
4001c4a0:	fadff06f          	j	4001c44c <tcp_out_ext+0x30c>
	return -EINVAL;
4001c4a4:	fea00413          	li	s0,-22
4001c4a8:	d49ff06f          	j	4001c1f0 <tcp_out_ext+0xb0>
	parent->next = child;
4001c4ac:	00092e23          	sw	zero,28(s2)
	return list->tail;
4001c4b0:	01c4a703          	lw	a4,28(s1)
	sys_slist_append(&conn->send_queue, &pkt->next);
4001c4b4:	01c90793          	addi	a5,s2,28
Z_GENLIST_APPEND(slist, snode)
4001c4b8:	02071a63          	bnez	a4,4001c4ec <tcp_out_ext+0x3ac>
	list->tail = node;
4001c4bc:	00f4ae23          	sw	a5,28(s1)
	list->head = node;
4001c4c0:	00f4ac23          	sw	a5,24(s1)
	if (is_destination_local(pkt)) {
4001c4c4:	00090513          	mv	a0,s2
4001c4c8:	865fe0ef          	jal	ra,4001ad2c <is_destination_local>
4001c4cc:	02050663          	beqz	a0,4001c4f8 <tcp_out_ext+0x3b8>
		k_work_schedule_for_queue(&tcp_work_q,
4001c4d0:	40031537          	lui	a0,0x40031
4001c4d4:	00000613          	li	a2,0
4001c4d8:	00000693          	li	a3,0
4001c4dc:	09048593          	addi	a1,s1,144
4001c4e0:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
4001c4e4:	0380d0ef          	jal	ra,4002951c <k_work_schedule_for_queue>
4001c4e8:	d11ff06f          	j	4001c1f8 <tcp_out_ext+0xb8>
	parent->next = child;
4001c4ec:	00f72023          	sw	a5,0(a4) # ff0000 <__rom_region_size+0xfbf624>
	list->tail = node;
4001c4f0:	00f4ae23          	sw	a5,28(s1)
}
4001c4f4:	fd1ff06f          	j	4001c4c4 <tcp_out_ext+0x384>
	} else if (tcp_send_process_no_lock(conn)) {
4001c4f8:	00048513          	mv	a0,s1
4001c4fc:	f61fe0ef          	jal	ra,4001b45c <tcp_send_process_no_lock>
4001c500:	ce050ce3          	beqz	a0,4001c1f8 <tcp_out_ext+0xb8>
		tcp_conn_close(conn, -ETIMEDOUT);
4001c504:	f8c00593          	li	a1,-116
4001c508:	00048513          	mv	a0,s1
4001c50c:	b5cff0ef          	jal	ra,4001b868 <tcp_conn_close.isra.0>
4001c510:	ce9ff06f          	j	4001c1f8 <tcp_out_ext+0xb8>
		ret = -ENOBUFS;
4001c514:	f9700413          	li	s0,-105
	return ret;
4001c518:	ce1ff06f          	j	4001c1f8 <tcp_out_ext+0xb8>

4001c51c <tcp_out>:
	(void)tcp_out_ext(conn, flags, NULL /* no data */, conn->seq);
4001c51c:	22852683          	lw	a3,552(a0)
4001c520:	00000613          	li	a2,0
4001c524:	c1dff06f          	j	4001c140 <tcp_out_ext>

4001c528 <tcp_send_ack>:
{
4001c528:	ff010113          	addi	sp,sp,-16
4001c52c:	00812423          	sw	s0,8(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001c530:	ea850413          	addi	s0,a0,-344
{
4001c534:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001c538:	fff00593          	li	a1,-1
4001c53c:	e8050493          	addi	s1,a0,-384
4001c540:	fff00613          	li	a2,-1
4001c544:	00040513          	mv	a0,s0
{
4001c548:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001c54c:	9cdfe0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	tcp_out(conn, ACK);
4001c550:	00048513          	mv	a0,s1
4001c554:	01000593          	li	a1,16
4001c558:	fc5ff0ef          	jal	ra,4001c51c <tcp_out>
	k_mutex_unlock(&conn->lock);
4001c55c:	00040513          	mv	a0,s0
}
4001c560:	00812403          	lw	s0,8(sp)
4001c564:	00c12083          	lw	ra,12(sp)
4001c568:	00412483          	lw	s1,4(sp)
4001c56c:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&conn->lock);
4001c570:	d9dfe06f          	j	4001b30c <k_mutex_unlock.isra.0>

4001c574 <tcp_send_zwp>:
{
4001c574:	ff010113          	addi	sp,sp,-16
4001c578:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001c57c:	ed850493          	addi	s1,a0,-296
{
4001c580:	00812423          	sw	s0,8(sp)
4001c584:	01212023          	sw	s2,0(sp)
4001c588:	00050413          	mv	s0,a0
	struct tcp *conn = CONTAINER_OF(dwork, struct tcp, persist_timer);
4001c58c:	eb050913          	addi	s2,a0,-336
	k_mutex_lock(&conn->lock, K_FOREVER);
4001c590:	fff00593          	li	a1,-1
4001c594:	fff00613          	li	a2,-1
4001c598:	00048513          	mv	a0,s1
{
4001c59c:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001c5a0:	979fe0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	(void)tcp_out_ext(conn, ACK, NULL, conn->seq - 1);
4001c5a4:	0d842683          	lw	a3,216(s0)
4001c5a8:	00000613          	li	a2,0
4001c5ac:	01000593          	li	a1,16
4001c5b0:	fff68693          	addi	a3,a3,-1
4001c5b4:	00090513          	mv	a0,s2
4001c5b8:	b89ff0ef          	jal	ra,4001c140 <tcp_out_ext>
	tcp_derive_rto(conn);
4001c5bc:	00090513          	mv	a0,s2
4001c5c0:	f28fe0ef          	jal	ra,4001ace8 <tcp_derive_rto>
	if (conn->send_win == 0) {
4001c5c4:	0e645783          	lhu	a5,230(s0)
4001c5c8:	08079263          	bnez	a5,4001c64c <tcp_send_zwp+0xd8>
		if (conn->zwp_retries < UINT8_MAX) {
4001c5cc:	0ec44783          	lbu	a5,236(s0)
4001c5d0:	0ff00713          	li	a4,255
		uint64_t timeout = TCP_RTO_MS;
4001c5d4:	0e845503          	lhu	a0,232(s0)
		if (conn->zwp_retries < UINT8_MAX) {
4001c5d8:	00e78663          	beq	a5,a4,4001c5e4 <tcp_send_zwp+0x70>
			conn->zwp_retries++;
4001c5dc:	00178793          	addi	a5,a5,1
4001c5e0:	0ef40623          	sb	a5,236(s0)
		timeout <<= conn->zwp_retries;
4001c5e4:	0ec44603          	lbu	a2,236(s0)
4001c5e8:	00000593          	li	a1,0
4001c5ec:	bf9e30ef          	jal	ra,400001e4 <__ashldi3>
4001c5f0:	00050793          	mv	a5,a0
		if (timeout == 0 || timeout > ZWP_MAX_DELAY_MS) {
4001c5f4:	fff50693          	addi	a3,a0,-1
4001c5f8:	00153513          	seqz	a0,a0
		timeout <<= conn->zwp_retries;
4001c5fc:	00058813          	mv	a6,a1
		if (timeout == 0 || timeout > ZWP_MAX_DELAY_MS) {
4001c600:	00b51863          	bne	a0,a1,4001c610 <tcp_send_zwp+0x9c>
4001c604:	0001d737          	lui	a4,0x1d
4001c608:	4bf70713          	addi	a4,a4,1215 # 1d4bf <__kernel_ram_size+0x1122b>
4001c60c:	00d77863          	bgeu	a4,a3,4001c61c <tcp_send_zwp+0xa8>
			timeout = ZWP_MAX_DELAY_MS;
4001c610:	0001d7b7          	lui	a5,0x1d
4001c614:	4c078793          	addi	a5,a5,1216 # 1d4c0 <__kernel_ram_size+0x1122c>
4001c618:	00000813          	li	a6,0
		t += off;
4001c61c:	00978513          	addi	a0,a5,9
4001c620:	00f537b3          	sltu	a5,a0,a5
			return t / ((uint64_t)from_hz / to_hz);
4001c624:	00a00613          	li	a2,10
4001c628:	00000693          	li	a3,0
4001c62c:	010785b3          	add	a1,a5,a6
4001c630:	c89e30ef          	jal	ra,400002b8 <__udivdi3>
4001c634:	00050613          	mv	a2,a0
		(void)k_work_reschedule_for_queue(
4001c638:	40031537          	lui	a0,0x40031
4001c63c:	00058693          	mv	a3,a1
4001c640:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
4001c644:	00040593          	mv	a1,s0
4001c648:	74d0c0ef          	jal	ra,40029594 <k_work_reschedule_for_queue>
}
4001c64c:	00812403          	lw	s0,8(sp)
4001c650:	00c12083          	lw	ra,12(sp)
4001c654:	00012903          	lw	s2,0(sp)
	k_mutex_unlock(&conn->lock);
4001c658:	00048513          	mv	a0,s1
}
4001c65c:	00412483          	lw	s1,4(sp)
4001c660:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&conn->lock);
4001c664:	ca9fe06f          	j	4001b30c <k_mutex_unlock.isra.0>

4001c668 <net_tcp_put>:
{
4001c668:	ff010113          	addi	sp,sp,-16
4001c66c:	00112623          	sw	ra,12(sp)
4001c670:	00812423          	sw	s0,8(sp)
4001c674:	00912223          	sw	s1,4(sp)
4001c678:	01212023          	sw	s2,0(sp)
	struct tcp *conn = context->tcp;
4001c67c:	05452403          	lw	s0,84(a0)
		return -ENOENT;
4001c680:	ffe00513          	li	a0,-2
	if (!conn) {
4001c684:	06040e63          	beqz	s0,4001c700 <net_tcp_put+0x98>
	k_mutex_lock(&conn->lock, K_FOREVER);
4001c688:	02840493          	addi	s1,s0,40
4001c68c:	fff00593          	li	a1,-1
4001c690:	fff00613          	li	a2,-1
4001c694:	00048513          	mv	a0,s1
4001c698:	881fe0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	if (conn && conn->state == TCP_ESTABLISHED) {
4001c69c:	22042703          	lw	a4,544(s0)
4001c6a0:	00400793          	li	a5,4
4001c6a4:	0ef71663          	bne	a4,a5,4001c790 <net_tcp_put+0x128>
		if (conn->send_data_total > 0) {
4001c6a8:	21042783          	lw	a5,528(s0)
4001c6ac:	40031937          	lui	s2,0x40031
4001c6b0:	06078463          	beqz	a5,4001c718 <net_tcp_put+0xb0>
			conn->in_close = true;
4001c6b4:	23d44783          	lbu	a5,573(s0)
						    K_MSEC(TCP_RTO_MS));
4001c6b8:	23845503          	lhu	a0,568(s0)
4001c6bc:	00a00613          	li	a2,10
			conn->in_close = true;
4001c6c0:	0047e793          	ori	a5,a5,4
4001c6c4:	00000693          	li	a3,0
4001c6c8:	22f40ea3          	sb	a5,573(s0)
4001c6cc:	00950513          	addi	a0,a0,9
4001c6d0:	00000593          	li	a1,0
4001c6d4:	be5e30ef          	jal	ra,400002b8 <__udivdi3>
4001c6d8:	00050613          	mv	a2,a0
4001c6dc:	00058693          	mv	a3,a1
			k_work_reschedule_for_queue(&tcp_work_q,
4001c6e0:	10890513          	addi	a0,s2,264 # 40031108 <tcp_work_q>
4001c6e4:	0f040593          	addi	a1,s0,240
4001c6e8:	6ad0c0ef          	jal	ra,40029594 <k_work_reschedule_for_queue>
	k_mutex_unlock(&conn->lock);
4001c6ec:	00048513          	mv	a0,s1
4001c6f0:	c1dfe0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
	tcp_conn_unref(conn);
4001c6f4:	00040513          	mv	a0,s0
4001c6f8:	f29fe0ef          	jal	ra,4001b620 <tcp_conn_unref.isra.0>
	return 0;
4001c6fc:	00000513          	li	a0,0
}
4001c700:	00c12083          	lw	ra,12(sp)
4001c704:	00812403          	lw	s0,8(sp)
4001c708:	00412483          	lw	s1,4(sp)
4001c70c:	00012903          	lw	s2,0(sp)
4001c710:	01010113          	addi	sp,sp,16
4001c714:	00008067          	ret
						    FIN_TIMEOUT);
4001c718:	400317b7          	lui	a5,0x40031
4001c71c:	acc7a783          	lw	a5,-1332(a5) # 40030acc <tcp_fin_timeout_ms>
4001c720:	0007d463          	bgez	a5,4001c728 <net_tcp_put+0xc0>
4001c724:	00000793          	li	a5,0
		t += off;
4001c728:	00978513          	addi	a0,a5,9
4001c72c:	41f7d593          	srai	a1,a5,0x1f
4001c730:	00f537b3          	sltu	a5,a0,a5
			return t / ((uint64_t)from_hz / to_hz);
4001c734:	00b785b3          	add	a1,a5,a1
4001c738:	00a00613          	li	a2,10
4001c73c:	00000693          	li	a3,0
4001c740:	b79e30ef          	jal	ra,400002b8 <__udivdi3>
4001c744:	00050613          	mv	a2,a0
4001c748:	00058693          	mv	a3,a1
			k_work_reschedule_for_queue(&tcp_work_q,
4001c74c:	10890513          	addi	a0,s2,264
4001c750:	1b040593          	addi	a1,s0,432
4001c754:	6410c0ef          	jal	ra,40029594 <k_work_reschedule_for_queue>
			ret = tcp_out_ext(conn, FIN | ACK, NULL,
4001c758:	22842683          	lw	a3,552(s0)
4001c75c:	21842783          	lw	a5,536(s0)
4001c760:	00000613          	li	a2,0
4001c764:	01100593          	li	a1,17
4001c768:	00f686b3          	add	a3,a3,a5
4001c76c:	00040513          	mv	a0,s0
4001c770:	9d1ff0ef          	jal	ra,4001c140 <tcp_out_ext>
			if (ret == 0) {
4001c774:	00051863          	bnez	a0,4001c784 <net_tcp_put+0x11c>
				conn_seq(conn, + 1);
4001c778:	22842783          	lw	a5,552(s0)
4001c77c:	00178793          	addi	a5,a5,1
4001c780:	22f42423          	sw	a5,552(s0)
			conn_state(conn, TCP_FIN_WAIT_1);
4001c784:	00500793          	li	a5,5
4001c788:	22f42023          	sw	a5,544(s0)
4001c78c:	f61ff06f          	j	4001c6ec <net_tcp_put+0x84>
	} else if (conn && conn->in_connect) {
4001c790:	23d44783          	lbu	a5,573(s0)
4001c794:	0027f713          	andi	a4,a5,2
4001c798:	f4070ae3          	beqz	a4,4001c6ec <net_tcp_put+0x84>
		conn->in_connect = false;
4001c79c:	ffd7f793          	andi	a5,a5,-3
4001c7a0:	22f40ea3          	sb	a5,573(s0)
4001c7a4:	f49ff06f          	j	4001c6ec <net_tcp_put+0x84>

4001c7a8 <tcp_send_data>:
{
4001c7a8:	fd010113          	addi	sp,sp,-48
4001c7ac:	02812423          	sw	s0,40(sp)
4001c7b0:	01312e23          	sw	s3,28(sp)
4001c7b4:	02112623          	sw	ra,44(sp)
4001c7b8:	02912223          	sw	s1,36(sp)
4001c7bc:	03212023          	sw	s2,32(sp)
	len = MIN3(conn->send_data_total - conn->unacked_len,
4001c7c0:	21852783          	lw	a5,536(a0)
4001c7c4:	21052903          	lw	s2,528(a0)
4001c7c8:	23655483          	lhu	s1,566(a0)
{
4001c7cc:	00050413          	mv	s0,a0
	len = MIN3(conn->send_data_total - conn->unacked_len,
4001c7d0:	40f90933          	sub	s2,s2,a5
4001c7d4:	40f484b3          	sub	s1,s1,a5
4001c7d8:	08854783          	lbu	a5,136(a0)
4001c7dc:	21800993          	li	s3,536
4001c7e0:	0017f793          	andi	a5,a5,1
4001c7e4:	00078463          	beqz	a5,4001c7ec <tcp_send_data+0x44>
4001c7e8:	08455983          	lhu	s3,132(a0)
4001c7ec:	00040513          	mv	a0,s0
4001c7f0:	8adff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001c7f4:	04a9d063          	bge	s3,a0,4001c834 <tcp_send_data+0x8c>
4001c7f8:	08844783          	lbu	a5,136(s0)
4001c7fc:	0017f793          	andi	a5,a5,1
4001c800:	16078e63          	beqz	a5,4001c97c <tcp_send_data+0x1d4>
4001c804:	08445783          	lhu	a5,132(s0)
4001c808:	16f4ce63          	blt	s1,a5,4001c984 <tcp_send_data+0x1dc>
4001c80c:	08445483          	lhu	s1,132(s0)
4001c810:	00040513          	mv	a0,s0
4001c814:	889ff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001c818:	02a4de63          	bge	s1,a0,4001c854 <tcp_send_data+0xac>
4001c81c:	08844783          	lbu	a5,136(s0)
4001c820:	21800513          	li	a0,536
4001c824:	0017f793          	andi	a5,a5,1
4001c828:	16078463          	beqz	a5,4001c990 <tcp_send_data+0x1e8>
4001c82c:	08445503          	lhu	a0,132(s0)
4001c830:	1600006f          	j	4001c990 <tcp_send_data+0x1e8>
4001c834:	00040513          	mv	a0,s0
4001c838:	865ff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001c83c:	14a4c463          	blt	s1,a0,4001c984 <tcp_send_data+0x1dc>
4001c840:	08844783          	lbu	a5,136(s0)
4001c844:	0017f793          	andi	a5,a5,1
4001c848:	fc0792e3          	bnez	a5,4001c80c <tcp_send_data+0x64>
4001c84c:	21800493          	li	s1,536
4001c850:	fc1ff06f          	j	4001c810 <tcp_send_data+0x68>
4001c854:	00040513          	mv	a0,s0
4001c858:	845ff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001c85c:	1340006f          	j	4001c990 <tcp_send_data+0x1e8>
4001c860:	23645483          	lhu	s1,566(s0)
4001c864:	21800913          	li	s2,536
4001c868:	40f484b3          	sub	s1,s1,a5
4001c86c:	08844783          	lbu	a5,136(s0)
4001c870:	0017f793          	andi	a5,a5,1
4001c874:	00078463          	beqz	a5,4001c87c <tcp_send_data+0xd4>
4001c878:	08445903          	lhu	s2,132(s0)
4001c87c:	00040513          	mv	a0,s0
4001c880:	81dff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001c884:	06a95063          	bge	s2,a0,4001c8e4 <tcp_send_data+0x13c>
4001c888:	08844783          	lbu	a5,136(s0)
4001c88c:	0017f793          	andi	a5,a5,1
4001c890:	0c078c63          	beqz	a5,4001c968 <tcp_send_data+0x1c0>
4001c894:	08445783          	lhu	a5,132(s0)
4001c898:	0cf4cc63          	blt	s1,a5,4001c970 <tcp_send_data+0x1c8>
4001c89c:	08445483          	lhu	s1,132(s0)
4001c8a0:	00040513          	mv	a0,s0
4001c8a4:	ff8ff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001c8a8:	04a4de63          	bge	s1,a0,4001c904 <tcp_send_data+0x15c>
4001c8ac:	08844783          	lbu	a5,136(s0)
4001c8b0:	0017f793          	andi	a5,a5,1
4001c8b4:	06078063          	beqz	a5,4001c914 <tcp_send_data+0x16c>
4001c8b8:	08445483          	lhu	s1,132(s0)
	if (len == 0) {
4001c8bc:	0e049663          	bnez	s1,4001c9a8 <tcp_send_data+0x200>
		ret = -ENODATA;
4001c8c0:	fc300993          	li	s3,-61
}
4001c8c4:	02c12083          	lw	ra,44(sp)
4001c8c8:	02812403          	lw	s0,40(sp)
4001c8cc:	02412483          	lw	s1,36(sp)
4001c8d0:	02012903          	lw	s2,32(sp)
4001c8d4:	00098513          	mv	a0,s3
4001c8d8:	01c12983          	lw	s3,28(sp)
4001c8dc:	03010113          	addi	sp,sp,48
4001c8e0:	00008067          	ret
	len = MIN3(conn->send_data_total - conn->unacked_len,
4001c8e4:	00040513          	mv	a0,s0
4001c8e8:	fb4ff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001c8ec:	08a4c263          	blt	s1,a0,4001c970 <tcp_send_data+0x1c8>
4001c8f0:	08844783          	lbu	a5,136(s0)
4001c8f4:	0017f793          	andi	a5,a5,1
4001c8f8:	fa0792e3          	bnez	a5,4001c89c <tcp_send_data+0xf4>
4001c8fc:	21800493          	li	s1,536
4001c900:	fa1ff06f          	j	4001c8a0 <tcp_send_data+0xf8>
4001c904:	00040513          	mv	a0,s0
4001c908:	f94ff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001c90c:	00050493          	mv	s1,a0
	if (len == 0) {
4001c910:	fadff06f          	j	4001c8bc <tcp_send_data+0x114>
	len = MIN3(conn->send_data_total - conn->unacked_len,
4001c914:	21800493          	li	s1,536
4001c918:	0900006f          	j	4001c9a8 <tcp_send_data+0x200>
	pkt = tcp_pkt_alloc(conn, len);
4001c91c:	00000593          	li	a1,0
4001c920:	00a00513          	li	a0,10
4001c924:	999f60ef          	jal	ra,400132bc <net_pkt_alloc>
4001c928:	0a80006f          	j	4001c9d0 <tcp_send_data+0x228>
	ret = tcp_out_ext(conn, PSH | ACK, pkt, conn->seq + conn->unacked_len);
4001c92c:	22842683          	lw	a3,552(s0)
4001c930:	21842783          	lw	a5,536(s0)
4001c934:	00090613          	mv	a2,s2
4001c938:	01800593          	li	a1,24
4001c93c:	00f686b3          	add	a3,a3,a5
4001c940:	00040513          	mv	a0,s0
4001c944:	ffcff0ef          	jal	ra,4001c140 <tcp_out_ext>
4001c948:	00050993          	mv	s3,a0
	if (ret == 0) {
4001c94c:	00051863          	bnez	a0,4001c95c <tcp_send_data+0x1b4>
		conn->unacked_len += len;
4001c950:	21842783          	lw	a5,536(s0)
4001c954:	009787b3          	add	a5,a5,s1
4001c958:	20f42c23          	sw	a5,536(s0)
	tcp_pkt_unref(pkt);
4001c95c:	00090513          	mv	a0,s2
4001c960:	dbcf60ef          	jal	ra,40012f1c <net_pkt_unref>
	return ret;
4001c964:	f61ff06f          	j	4001c8c4 <tcp_send_data+0x11c>
	len = MIN3(conn->send_data_total - conn->unacked_len,
4001c968:	21700793          	li	a5,535
4001c96c:	f897c8e3          	blt	a5,s1,4001c8fc <tcp_send_data+0x154>
4001c970:	23645483          	lhu	s1,566(s0)
4001c974:	21842783          	lw	a5,536(s0)
4001c978:	0240006f          	j	4001c99c <tcp_send_data+0x1f4>
4001c97c:	21700793          	li	a5,535
4001c980:	ec97c6e3          	blt	a5,s1,4001c84c <tcp_send_data+0xa4>
4001c984:	23645503          	lhu	a0,566(s0)
4001c988:	21842783          	lw	a5,536(s0)
4001c98c:	40f50533          	sub	a0,a0,a5
4001c990:	21842783          	lw	a5,536(s0)
4001c994:	eca976e3          	bgeu	s2,a0,4001c860 <tcp_send_data+0xb8>
4001c998:	21042483          	lw	s1,528(s0)
4001c99c:	40f484b3          	sub	s1,s1,a5
	if (len == 0) {
4001c9a0:	f20480e3          	beqz	s1,4001c8c0 <tcp_send_data+0x118>
	pkt = tcp_pkt_alloc(conn, len);
4001c9a4:	f6905ce3          	blez	s1,4001c91c <tcp_send_data+0x174>
4001c9a8:	00442783          	lw	a5,4(s0)
4001c9ac:	01042503          	lw	a0,16(s0)
4001c9b0:	00a00713          	li	a4,10
4001c9b4:	0747d603          	lhu	a2,116(a5)
4001c9b8:	00600693          	li	a3,6
4001c9bc:	00000793          	li	a5,0
4001c9c0:	00365613          	srli	a2,a2,0x3
4001c9c4:	00767613          	andi	a2,a2,7
4001c9c8:	00048593          	mv	a1,s1
4001c9cc:	d51f60ef          	jal	ra,4001371c <net_pkt_alloc_with_buffer>
4001c9d0:	00050913          	mv	s2,a0
	if (!pkt) {
4001c9d4:	04050a63          	beqz	a0,4001ca28 <tcp_send_data+0x280>
	ret = tcp_pkt_peek(pkt, conn->send_data, conn->unacked_len, len);
4001c9d8:	21842583          	lw	a1,536(s0)
4001c9dc:	00842983          	lw	s3,8(s0)
4001c9e0:	00b12623          	sw	a1,12(sp)
	net_pkt_cursor_init(to);
4001c9e4:	80df60ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	net_pkt_cursor_init(from);
4001c9e8:	00098513          	mv	a0,s3
4001c9ec:	805f60ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	if (pos) {
4001c9f0:	00c12583          	lw	a1,12(sp)
4001c9f4:	00058c63          	beqz	a1,4001ca0c <tcp_send_data+0x264>
	pkt->overwrite = overwrite;
4001c9f8:	0379c783          	lbu	a5,55(s3)
		net_pkt_skip(from, pos);
4001c9fc:	00098513          	mv	a0,s3
4001ca00:	0017e793          	ori	a5,a5,1
4001ca04:	02f98ba3          	sb	a5,55(s3)
4001ca08:	d5df60ef          	jal	ra,40013764 <net_pkt_skip>
	return net_pkt_copy(to, from, len);
4001ca0c:	00048613          	mv	a2,s1
4001ca10:	00098593          	mv	a1,s3
4001ca14:	00090513          	mv	a0,s2
4001ca18:	818f70ef          	jal	ra,40013a30 <net_pkt_copy>
	if (ret < 0) {
4001ca1c:	f00558e3          	bgez	a0,4001c92c <tcp_send_data+0x184>
		tcp_pkt_unref(pkt);
4001ca20:	00090513          	mv	a0,s2
4001ca24:	cf8f60ef          	jal	ra,40012f1c <net_pkt_unref>
		ret = -ENOBUFS;
4001ca28:	f9700993          	li	s3,-105
4001ca2c:	e99ff06f          	j	4001c8c4 <tcp_send_data+0x11c>

4001ca30 <tcp_resend_data>:
{
4001ca30:	ff010113          	addi	sp,sp,-16
4001ca34:	00912223          	sw	s1,4(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001ca38:	f3850493          	addi	s1,a0,-200
{
4001ca3c:	00812423          	sw	s0,8(sp)
4001ca40:	01212023          	sw	s2,0(sp)
4001ca44:	00050413          	mv	s0,a0
	struct tcp *conn = CONTAINER_OF(dwork, struct tcp, send_data_timer);
4001ca48:	f1050913          	addi	s2,a0,-240
	k_mutex_lock(&conn->lock, K_FOREVER);
4001ca4c:	fff00593          	li	a1,-1
4001ca50:	fff00613          	li	a2,-1
4001ca54:	00048513          	mv	a0,s1
{
4001ca58:	00112623          	sw	ra,12(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001ca5c:	cbcfe0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	if (conn->send_data_retries >= tcp_retries) {
4001ca60:	14a44703          	lbu	a4,330(s0)
4001ca64:	00800793          	li	a5,8
4001ca68:	02e7f663          	bgeu	a5,a4,4001ca94 <tcp_resend_data+0x64>
	k_mutex_unlock(&conn->lock);
4001ca6c:	00048513          	mv	a0,s1
4001ca70:	89dfe0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
}
4001ca74:	00812403          	lw	s0,8(sp)
4001ca78:	00c12083          	lw	ra,12(sp)
4001ca7c:	00412483          	lw	s1,4(sp)
		tcp_conn_close(conn, -ETIMEDOUT);
4001ca80:	00090513          	mv	a0,s2
}
4001ca84:	00012903          	lw	s2,0(sp)
		tcp_conn_close(conn, -ETIMEDOUT);
4001ca88:	f8c00593          	li	a1,-116
}
4001ca8c:	01010113          	addi	sp,sp,16
		tcp_conn_close(conn, -ETIMEDOUT);
4001ca90:	dd9fe06f          	j	4001b868 <tcp_conn_close.isra.0>
	conn->data_mode = TCP_DATA_MODE_RESEND;
4001ca94:	00100793          	li	a5,1
4001ca98:	12f42a23          	sw	a5,308(s0)
	conn->unacked_len = 0;
4001ca9c:	12042423          	sw	zero,296(s0)
	ret = tcp_send_data(conn);
4001caa0:	00090513          	mv	a0,s2
4001caa4:	d05ff0ef          	jal	ra,4001c7a8 <tcp_send_data>
	conn->send_data_retries++;
4001caa8:	14a44703          	lbu	a4,330(s0)
4001caac:	00170713          	addi	a4,a4,1
4001cab0:	0ff77713          	zext.b	a4,a4
4001cab4:	14e40523          	sb	a4,330(s0)
	if (ret == 0) {
4001cab8:	0a051663          	bnez	a0,4001cb64 <tcp_resend_data+0x134>
		if (conn->in_close && conn->send_data_total == 0) {
4001cabc:	14d44783          	lbu	a5,333(s0)
4001cac0:	0047f793          	andi	a5,a5,4
4001cac4:	0a078863          	beqz	a5,4001cb74 <tcp_resend_data+0x144>
4001cac8:	12042783          	lw	a5,288(s0)
4001cacc:	0a079463          	bnez	a5,4001cb74 <tcp_resend_data+0x144>
						    FIN_TIMEOUT);
4001cad0:	400317b7          	lui	a5,0x40031
4001cad4:	acc7a783          	lw	a5,-1332(a5) # 40030acc <tcp_fin_timeout_ms>
4001cad8:	0007d463          	bgez	a5,4001cae0 <tcp_resend_data+0xb0>
4001cadc:	00000793          	li	a5,0
		t += off;
4001cae0:	00978513          	addi	a0,a5,9
4001cae4:	41f7d593          	srai	a1,a5,0x1f
4001cae8:	00f537b3          	sltu	a5,a0,a5
			return t / ((uint64_t)from_hz / to_hz);
4001caec:	00b785b3          	add	a1,a5,a1
4001caf0:	00a00613          	li	a2,10
4001caf4:	00000693          	li	a3,0
4001caf8:	fc0e30ef          	jal	ra,400002b8 <__udivdi3>
4001cafc:	00050613          	mv	a2,a0
			k_work_reschedule_for_queue(&tcp_work_q,
4001cb00:	40031537          	lui	a0,0x40031
4001cb04:	00058693          	mv	a3,a1
4001cb08:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
4001cb0c:	0c040593          	addi	a1,s0,192
4001cb10:	2850c0ef          	jal	ra,40029594 <k_work_reschedule_for_queue>
			conn_state(conn, TCP_FIN_WAIT_1);
4001cb14:	00500793          	li	a5,5
			ret = tcp_out_ext(conn, FIN | ACK, NULL,
4001cb18:	13842683          	lw	a3,312(s0)
			conn_state(conn, TCP_FIN_WAIT_1);
4001cb1c:	12f42823          	sw	a5,304(s0)
			ret = tcp_out_ext(conn, FIN | ACK, NULL,
4001cb20:	12842783          	lw	a5,296(s0)
4001cb24:	00000613          	li	a2,0
4001cb28:	01100593          	li	a1,17
4001cb2c:	00f686b3          	add	a3,a3,a5
4001cb30:	00090513          	mv	a0,s2
4001cb34:	e0cff0ef          	jal	ra,4001c140 <tcp_out_ext>
			if (ret == 0) {
4001cb38:	00051863          	bnez	a0,4001cb48 <tcp_resend_data+0x118>
				conn_seq(conn, + 1);
4001cb3c:	13842783          	lw	a5,312(s0)
4001cb40:	00178793          	addi	a5,a5,1
4001cb44:	12f42c23          	sw	a5,312(s0)
}
4001cb48:	00812403          	lw	s0,8(sp)
4001cb4c:	00c12083          	lw	ra,12(sp)
4001cb50:	00012903          	lw	s2,0(sp)
	k_mutex_unlock(&conn->lock);
4001cb54:	00048513          	mv	a0,s1
}
4001cb58:	00412483          	lw	s1,4(sp)
4001cb5c:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&conn->lock);
4001cb60:	facfe06f          	j	4001b30c <k_mutex_unlock.isra.0>
	} else if (ret == -ENODATA) {
4001cb64:	fc300793          	li	a5,-61
4001cb68:	00f51663          	bne	a0,a5,4001cb74 <tcp_resend_data+0x144>
		conn->data_mode = TCP_DATA_MODE_SEND;
4001cb6c:	12042a23          	sw	zero,308(s0)
	k_mutex_unlock(&conn->lock);
4001cb70:	fd9ff06f          	j	4001cb48 <tcp_resend_data+0x118>
	if (conn->send_data_retries < tcp_retries) {
4001cb74:	00800693          	li	a3,8
	exp_tcp_rto = TCP_RTO_MS;
4001cb78:	14845783          	lhu	a5,328(s0)
	if (conn->send_data_retries < tcp_retries) {
4001cb7c:	04e6d863          	bge	a3,a4,4001cbcc <tcp_resend_data+0x19c>
		t += off;
4001cb80:	00978513          	addi	a0,a5,9
				    K_MSEC(exp_tcp_rto));
4001cb84:	41f7d593          	srai	a1,a5,0x1f
4001cb88:	00f537b3          	sltu	a5,a0,a5
			return t / ((uint64_t)from_hz / to_hz);
4001cb8c:	00a00613          	li	a2,10
4001cb90:	00000693          	li	a3,0
4001cb94:	00b785b3          	add	a1,a5,a1
4001cb98:	f20e30ef          	jal	ra,400002b8 <__udivdi3>
4001cb9c:	00050613          	mv	a2,a0
	k_work_reschedule_for_queue(&tcp_work_q, &conn->send_data_timer,
4001cba0:	40031537          	lui	a0,0x40031
4001cba4:	00058693          	mv	a3,a1
4001cba8:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
4001cbac:	00040593          	mv	a1,s0
4001cbb0:	1e50c0ef          	jal	ra,40029594 <k_work_reschedule_for_queue>
4001cbb4:	f95ff06f          	j	4001cb48 <tcp_resend_data+0x118>
			exp_tcp_rto += exp_tcp_rto >> 1;
4001cbb8:	4017d613          	srai	a2,a5,0x1
4001cbbc:	00c787b3          	add	a5,a5,a2
		for (int i = 0; i < conn->send_data_retries; i++) {
4001cbc0:	00168693          	addi	a3,a3,1
4001cbc4:	fee6cae3          	blt	a3,a4,4001cbb8 <tcp_resend_data+0x188>
4001cbc8:	fb9ff06f          	j	4001cb80 <tcp_resend_data+0x150>
4001cbcc:	00000693          	li	a3,0
4001cbd0:	ff5ff06f          	j	4001cbc4 <tcp_resend_data+0x194>

4001cbd4 <tcp_short_window>:
{
4001cbd4:	ff010113          	addi	sp,sp,-16
4001cbd8:	00812423          	sw	s0,8(sp)
4001cbdc:	00912223          	sw	s1,4(sp)
4001cbe0:	00112623          	sw	ra,12(sp)
	int32_t threshold = MIN(conn_mss(conn), conn->recv_win_max / 2);
4001cbe4:	08854783          	lbu	a5,136(a0)
{
4001cbe8:	00050413          	mv	s0,a0
4001cbec:	21800493          	li	s1,536
	int32_t threshold = MIN(conn_mss(conn), conn->recv_win_max / 2);
4001cbf0:	0017f793          	andi	a5,a5,1
4001cbf4:	00078463          	beqz	a5,4001cbfc <tcp_short_window+0x28>
4001cbf8:	08455483          	lhu	s1,132(a0)
4001cbfc:	00040513          	mv	a0,s0
4001cc00:	c9cff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001cc04:	06a4dc63          	bge	s1,a0,4001cc7c <tcp_short_window+0xa8>
4001cc08:	08844783          	lbu	a5,136(s0)
4001cc0c:	21800513          	li	a0,536
4001cc10:	0017f793          	andi	a5,a5,1
4001cc14:	00078463          	beqz	a5,4001cc1c <tcp_short_window+0x48>
4001cc18:	08445503          	lhu	a0,132(s0)
4001cc1c:	23045783          	lhu	a5,560(s0)
4001cc20:	0017d793          	srli	a5,a5,0x1
4001cc24:	02f55c63          	bge	a0,a5,4001cc5c <tcp_short_window+0x88>
4001cc28:	08844783          	lbu	a5,136(s0)
4001cc2c:	21800493          	li	s1,536
4001cc30:	0017f793          	andi	a5,a5,1
4001cc34:	00078463          	beqz	a5,4001cc3c <tcp_short_window+0x68>
4001cc38:	08445483          	lhu	s1,132(s0)
4001cc3c:	00040513          	mv	a0,s0
4001cc40:	c5cff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001cc44:	04a4d263          	bge	s1,a0,4001cc88 <tcp_short_window+0xb4>
4001cc48:	08844703          	lbu	a4,136(s0)
4001cc4c:	21800793          	li	a5,536
4001cc50:	00177713          	andi	a4,a4,1
4001cc54:	00070463          	beqz	a4,4001cc5c <tcp_short_window+0x88>
4001cc58:	08445783          	lhu	a5,132(s0)
	if (conn->recv_win > threshold) {
4001cc5c:	23245503          	lhu	a0,562(s0)
}
4001cc60:	00c12083          	lw	ra,12(sp)
4001cc64:	00812403          	lw	s0,8(sp)
	if (conn->recv_win > threshold) {
4001cc68:	00a7a533          	slt	a0,a5,a0
}
4001cc6c:	00412483          	lw	s1,4(sp)
4001cc70:	00154513          	xori	a0,a0,1
4001cc74:	01010113          	addi	sp,sp,16
4001cc78:	00008067          	ret
	int32_t threshold = MIN(conn_mss(conn), conn->recv_win_max / 2);
4001cc7c:	00040513          	mv	a0,s0
4001cc80:	c1cff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001cc84:	f99ff06f          	j	4001cc1c <tcp_short_window+0x48>
4001cc88:	00040513          	mv	a0,s0
4001cc8c:	c10ff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001cc90:	00050793          	mv	a5,a0
4001cc94:	fc9ff06f          	j	4001cc5c <tcp_short_window+0x88>

4001cc98 <tcp_update_recv_wnd>:
{
4001cc98:	ff010113          	addi	sp,sp,-16
4001cc9c:	00812423          	sw	s0,8(sp)
4001cca0:	00912223          	sw	s1,4(sp)
4001cca4:	00112623          	sw	ra,12(sp)
4001cca8:	01212023          	sw	s2,0(sp)
	new_win = conn->recv_win + delta;
4001ccac:	23255783          	lhu	a5,562(a0)
{
4001ccb0:	00050413          	mv	s0,a0
		new_win = 0;
4001ccb4:	00000493          	li	s1,0
	new_win = conn->recv_win + delta;
4001ccb8:	00b785b3          	add	a1,a5,a1
	if (new_win < 0) {
4001ccbc:	0005c863          	bltz	a1,4001cccc <tcp_update_recv_wnd+0x34>
	} else if (new_win > conn->recv_win_max) {
4001ccc0:	23055483          	lhu	s1,560(a0)
4001ccc4:	0095d463          	bge	a1,s1,4001cccc <tcp_update_recv_wnd+0x34>
4001ccc8:	00058493          	mv	s1,a1
	short_win_before = tcp_short_window(conn);
4001cccc:	00040513          	mv	a0,s0
4001ccd0:	f05ff0ef          	jal	ra,4001cbd4 <tcp_short_window>
4001ccd4:	00050913          	mv	s2,a0
	conn->recv_win = new_win;
4001ccd8:	22941923          	sh	s1,562(s0)
	short_win_after = tcp_short_window(conn);
4001ccdc:	00040513          	mv	a0,s0
4001cce0:	ef5ff0ef          	jal	ra,4001cbd4 <tcp_short_window>
	if (short_win_before && !short_win_after &&
4001cce4:	02090463          	beqz	s2,4001cd0c <tcp_update_recv_wnd+0x74>
4001cce8:	02051263          	bnez	a0,4001cd0c <tcp_update_recv_wnd+0x74>
4001ccec:	22042703          	lw	a4,544(s0)
4001ccf0:	00400793          	li	a5,4
4001ccf4:	00f71c63          	bne	a4,a5,4001cd0c <tcp_update_recv_wnd+0x74>
		k_work_cancel_delayable(&conn->ack_timer);
4001ccf8:	18040513          	addi	a0,s0,384
4001ccfc:	1410c0ef          	jal	ra,4002963c <k_work_cancel_delayable>
		tcp_out(conn, ACK);
4001cd00:	01000593          	li	a1,16
4001cd04:	00040513          	mv	a0,s0
4001cd08:	815ff0ef          	jal	ra,4001c51c <tcp_out>
}
4001cd0c:	00c12083          	lw	ra,12(sp)
4001cd10:	00812403          	lw	s0,8(sp)
4001cd14:	00412483          	lw	s1,4(sp)
4001cd18:	00012903          	lw	s2,0(sp)
4001cd1c:	00000513          	li	a0,0
4001cd20:	01010113          	addi	sp,sp,16
4001cd24:	00008067          	ret

4001cd28 <net_tcp_update_recv_wnd>:
{
4001cd28:	ff010113          	addi	sp,sp,-16
4001cd2c:	00912223          	sw	s1,4(sp)
4001cd30:	00112623          	sw	ra,12(sp)
4001cd34:	00812423          	sw	s0,8(sp)
4001cd38:	01212023          	sw	s2,0(sp)
	struct tcp *conn = context->tcp;
4001cd3c:	05452403          	lw	s0,84(a0)
		return -EPROTOTYPE;
4001cd40:	f9500493          	li	s1,-107
	if (!conn) {
4001cd44:	02040c63          	beqz	s0,4001cd7c <net_tcp_update_recv_wnd+0x54>
	k_mutex_lock(&conn->lock, K_FOREVER);
4001cd48:	02840413          	addi	s0,s0,40
4001cd4c:	00050493          	mv	s1,a0
4001cd50:	00058913          	mv	s2,a1
4001cd54:	fff00613          	li	a2,-1
4001cd58:	fff00593          	li	a1,-1
4001cd5c:	00040513          	mv	a0,s0
4001cd60:	9b8fe0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	ret = tcp_update_recv_wnd((struct tcp *)context->tcp, delta);
4001cd64:	0544a503          	lw	a0,84(s1)
4001cd68:	00090593          	mv	a1,s2
4001cd6c:	f2dff0ef          	jal	ra,4001cc98 <tcp_update_recv_wnd>
4001cd70:	00050493          	mv	s1,a0
	k_mutex_unlock(&conn->lock);
4001cd74:	00040513          	mv	a0,s0
4001cd78:	d94fe0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
}
4001cd7c:	00c12083          	lw	ra,12(sp)
4001cd80:	00812403          	lw	s0,8(sp)
4001cd84:	00012903          	lw	s2,0(sp)
4001cd88:	00048513          	mv	a0,s1
4001cd8c:	00412483          	lw	s1,4(sp)
4001cd90:	01010113          	addi	sp,sp,16
4001cd94:	00008067          	ret

4001cd98 <tcp_data_get>:
	if (tcp_recv_cb) {
4001cd98:	400317b7          	lui	a5,0x40031
4001cd9c:	abc7a783          	lw	a5,-1348(a5) # 40030abc <tcp_recv_cb>
{
4001cda0:	fc010113          	addi	sp,sp,-64
4001cda4:	02112e23          	sw	ra,60(sp)
4001cda8:	02812c23          	sw	s0,56(sp)
4001cdac:	02912a23          	sw	s1,52(sp)
4001cdb0:	03212823          	sw	s2,48(sp)
4001cdb4:	03312623          	sw	s3,44(sp)
4001cdb8:	03412423          	sw	s4,40(sp)
4001cdbc:	03512223          	sw	s5,36(sp)
4001cdc0:	03612023          	sw	s6,32(sp)
4001cdc4:	01712e23          	sw	s7,28(sp)
4001cdc8:	01812c23          	sw	s8,24(sp)
	if (tcp_recv_cb) {
4001cdcc:	02078e63          	beqz	a5,4001ce08 <tcp_data_get+0x70>
		tcp_recv_cb(conn, pkt);
4001cdd0:	000780e7          	jalr	a5
	enum net_verdict ret = NET_DROP;
4001cdd4:	00200513          	li	a0,2
}
4001cdd8:	03c12083          	lw	ra,60(sp)
4001cddc:	03812403          	lw	s0,56(sp)
4001cde0:	03412483          	lw	s1,52(sp)
4001cde4:	03012903          	lw	s2,48(sp)
4001cde8:	02c12983          	lw	s3,44(sp)
4001cdec:	02812a03          	lw	s4,40(sp)
4001cdf0:	02412a83          	lw	s5,36(sp)
4001cdf4:	02012b03          	lw	s6,32(sp)
4001cdf8:	01c12b83          	lw	s7,28(sp)
4001cdfc:	01812c03          	lw	s8,24(sp)
4001ce00:	04010113          	addi	sp,sp,64
4001ce04:	00008067          	ret
	if (conn->context->recv_cb) {
4001ce08:	00452783          	lw	a5,4(a0)
4001ce0c:	00050493          	mv	s1,a0
4001ce10:	0487a783          	lw	a5,72(a5)
4001ce14:	fc0780e3          	beqz	a5,4001cdd4 <tcp_data_get+0x3c>
4001ce18:	00c52783          	lw	a5,12(a0)
		*len += tcp_check_pending_data(conn, pkt, *len);
4001ce1c:	00062a83          	lw	s5,0(a2)
4001ce20:	00058913          	mv	s2,a1
4001ce24:	0087a783          	lw	a5,8(a5)
4001ce28:	00060a13          	mv	s4,a2
	return !pkt->buffer || !net_pkt_data(pkt) || pkt->buffer->len == 0;
4001ce2c:	14078a63          	beqz	a5,4001cf80 <tcp_data_get+0x1e8>
4001ce30:	00c7a703          	lw	a4,12(a5)
4001ce34:	14070663          	beqz	a4,4001cf80 <tcp_data_get+0x1e8>
4001ce38:	0107d783          	lhu	a5,16(a5)
4001ce3c:	14078263          	beqz	a5,4001cf80 <tcp_data_get+0x1e8>
		struct tcphdr *th = th_get(pkt);
4001ce40:	00058513          	mv	a0,a1
4001ce44:	968fe0ef          	jal	ra,4001afac <th_get>
		uint32_t expected_seq = th_seq(th) + len;
4001ce48:	00554703          	lbu	a4,5(a0)
4001ce4c:	00454783          	lbu	a5,4(a0)
4001ce50:	00754403          	lbu	s0,7(a0)
4001ce54:	00871713          	slli	a4,a4,0x8
4001ce58:	00f76733          	or	a4,a4,a5
4001ce5c:	00654783          	lbu	a5,6(a0)
4001ce60:	01841413          	slli	s0,s0,0x18
4001ce64:	000106b7          	lui	a3,0x10
4001ce68:	01079793          	slli	a5,a5,0x10
4001ce6c:	00e7e7b3          	or	a5,a5,a4
4001ce70:	00f46733          	or	a4,s0,a5
4001ce74:	01879793          	slli	a5,a5,0x18
4001ce78:	01845413          	srli	s0,s0,0x18
4001ce7c:	00f46433          	or	s0,s0,a5
4001ce80:	f0068693          	addi	a3,a3,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001ce84:	00875793          	srli	a5,a4,0x8
4001ce88:	00d7f7b3          	and	a5,a5,a3
4001ce8c:	00f46433          	or	s0,s0,a5
4001ce90:	00871713          	slli	a4,a4,0x8
4001ce94:	00ff07b7          	lui	a5,0xff0
4001ce98:	00f77733          	and	a4,a4,a5
		pending_seq = tcp_get_seq(conn->queue_recv_data->buffer);
4001ce9c:	00c4a783          	lw	a5,12(s1)
		uint32_t expected_seq = th_seq(th) + len;
4001cea0:	00e46433          	or	s0,s0,a4
4001cea4:	008a8c33          	add	s8,s5,s0
		pending_seq = tcp_get_seq(conn->queue_recv_data->buffer);
4001cea8:	0087ab83          	lw	s7,8(a5) # ff0008 <__rom_region_size+0xfbf62c>
	return *(uint32_t *)net_buf_user_data(buf);
4001ceac:	018bab03          	lw	s6,24(s7)
		pending_len = net_pkt_get_len(conn->queue_recv_data);
4001ceb0:	000b8513          	mv	a0,s7
		end_offset = expected_seq - pending_seq;
4001ceb4:	416c05b3          	sub	a1,s8,s6
4001ceb8:	00b12623          	sw	a1,12(sp)
		pending_len = net_pkt_get_len(conn->queue_recv_data);
4001cebc:	860fe0ef          	jal	ra,4001af1c <net_pkt_get_len.isra.0>
		if (end_offset < pending_len) {
4001cec0:	00c12583          	lw	a1,12(sp)
		pending_len = net_pkt_get_len(conn->queue_recv_data);
4001cec4:	00050993          	mv	s3,a0
		if (end_offset < pending_len) {
4001cec8:	08a5fa63          	bgeu	a1,a0,4001cf5c <tcp_data_get+0x1c4>
			if (end_offset) {
4001cecc:	00058a63          	beqz	a1,4001cee0 <tcp_data_get+0x148>
				net_pkt_remove_tail(pkt, end_offset);
4001ced0:	00090513          	mv	a0,s2
4001ced4:	013b09b3          	add	s3,s6,s3
4001ced8:	aa8f60ef          	jal	ra,40013180 <net_pkt_remove_tail>
				pending_len -= end_offset;
4001cedc:	418989b3          	sub	s3,s3,s8
			net_buf_frag_add(pkt->buffer,
4001cee0:	00c4a783          	lw	a5,12(s1)
4001cee4:	00892503          	lw	a0,8(s2)
4001cee8:	0087a583          	lw	a1,8(a5)
4001ceec:	b2dec0ef          	jal	ra,40009a18 <net_buf_frag_add>
			conn->queue_recv_data->buffer = NULL;
4001cef0:	00c4a783          	lw	a5,12(s1)
			k_work_cancel_delayable(&conn->recv_queue_timer);
4001cef4:	0c048513          	addi	a0,s1,192
			conn->queue_recv_data->buffer = NULL;
4001cef8:	0007a423          	sw	zero,8(a5)
			k_work_cancel_delayable(&conn->recv_queue_timer);
4001cefc:	7400c0ef          	jal	ra,4002963c <k_work_cancel_delayable>
		*len += tcp_check_pending_data(conn, pkt, *len);
4001cf00:	000a2783          	lw	a5,0(s4)
		net_pkt_cursor_init(pkt);
4001cf04:	00090513          	mv	a0,s2
		*len += tcp_check_pending_data(conn, pkt, *len);
4001cf08:	013787b3          	add	a5,a5,s3
4001cf0c:	00fa2023          	sw	a5,0(s4)
		net_pkt_cursor_init(pkt);
4001cf10:	ae0f60ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	pkt->overwrite = overwrite;
4001cf14:	03794783          	lbu	a5,55(s2)
		net_pkt_skip(pkt, net_pkt_get_len(pkt) - *len);
4001cf18:	00892503          	lw	a0,8(s2)
4001cf1c:	0017e793          	ori	a5,a5,1
4001cf20:	02f90ba3          	sb	a5,55(s2)
4001cf24:	ff9fd0ef          	jal	ra,4001af1c <net_pkt_get_len.isra.0>
4001cf28:	000a2583          	lw	a1,0(s4)
4001cf2c:	40b505b3          	sub	a1,a0,a1
4001cf30:	00090513          	mv	a0,s2
4001cf34:	831f60ef          	jal	ra,40013764 <net_pkt_skip>
		tcp_update_recv_wnd(conn, -*len);
4001cf38:	000a2583          	lw	a1,0(s4)
4001cf3c:	00048513          	mv	a0,s1
4001cf40:	40b005b3          	neg	a1,a1
4001cf44:	d55ff0ef          	jal	ra,4001cc98 <tcp_update_recv_wnd>
		k_fifo_put(&conn->recv_data, pkt);
4001cf48:	06c48513          	addi	a0,s1,108
4001cf4c:	00090593          	mv	a1,s2
4001cf50:	4f50b0ef          	jal	ra,40028c44 <k_queue_append>
4001cf54:	00000513          	li	a0,0
	return ret;
4001cf58:	e81ff06f          	j	4001cdd8 <tcp_data_get+0x40>
		gap_size = (int32_t)(pending_seq - th_seq(th) - ((uint32_t)len));
4001cf5c:	415b0b33          	sub	s6,s6,s5
4001cf60:	408b0b33          	sub	s6,s6,s0
			if (gap_size <= 0) {
4001cf64:	01604e63          	bgtz	s6,4001cf80 <tcp_data_get+0x1e8>
				net_buf_unref(conn->queue_recv_data->buffer);
4001cf68:	000b8513          	mv	a0,s7
4001cf6c:	9a5ec0ef          	jal	ra,40009910 <net_buf_unref>
				conn->queue_recv_data->buffer = NULL;
4001cf70:	00c4a783          	lw	a5,12(s1)
				k_work_cancel_delayable(&conn->recv_queue_timer);
4001cf74:	0c048513          	addi	a0,s1,192
				conn->queue_recv_data->buffer = NULL;
4001cf78:	0007a423          	sw	zero,8(a5)
				k_work_cancel_delayable(&conn->recv_queue_timer);
4001cf7c:	6c00c0ef          	jal	ra,4002963c <k_work_cancel_delayable>
	size_t pending_len = 0;
4001cf80:	00000993          	li	s3,0
4001cf84:	f7dff06f          	j	4001cf00 <tcp_data_get+0x168>

4001cf88 <tcp_send_queued_data.part.0>:
static int tcp_send_queued_data(struct tcp *conn)
4001cf88:	fe010113          	addi	sp,sp,-32
4001cf8c:	00812c23          	sw	s0,24(sp)
4001cf90:	01212823          	sw	s2,16(sp)
4001cf94:	00112e23          	sw	ra,28(sp)
4001cf98:	00912a23          	sw	s1,20(sp)
4001cf9c:	01312623          	sw	s3,12(sp)
4001cfa0:	00050413          	mv	s0,a0
	int ret = 0;
4001cfa4:	00000913          	li	s2,0
	if (conn->unacked_len > conn->send_data_total) {
4001cfa8:	21842783          	lw	a5,536(s0)
4001cfac:	21042703          	lw	a4,528(s0)
4001cfb0:	04f76063          	bltu	a4,a5,4001cff0 <tcp_send_queued_data.part.0+0x68>
	if (conn->unacked_len >= conn->send_win) {
4001cfb4:	23645483          	lhu	s1,566(s0)
4001cfb8:	0297dc63          	bge	a5,s1,4001cff0 <tcp_send_queued_data.part.0+0x68>
	unsent_len = conn->send_data_total - conn->unacked_len;
4001cfbc:	40f70733          	sub	a4,a4,a5
		unsent_len = MIN(unsent_len, conn->send_win - conn->unacked_len);
4001cfc0:	40f484b3          	sub	s1,s1,a5
4001cfc4:	00975463          	bge	a4,s1,4001cfcc <tcp_send_queued_data.part.0+0x44>
4001cfc8:	00070493          	mv	s1,a4
	while (tcp_unsent_len(conn) > 0) {
4001cfcc:	02905263          	blez	s1,4001cff0 <tcp_send_queued_data.part.0+0x68>
		if ((conn->tcp_nodelay == false) && (conn->unacked_len > 0)) {
4001cfd0:	23c42703          	lw	a4,572(s0)
4001cfd4:	00b75713          	srli	a4,a4,0xb
4001cfd8:	00177713          	andi	a4,a4,1
4001cfdc:	06070463          	beqz	a4,4001d044 <tcp_send_queued_data.part.0+0xbc>
		ret = tcp_send_data(conn);
4001cfe0:	00040513          	mv	a0,s0
4001cfe4:	fc4ff0ef          	jal	ra,4001c7a8 <tcp_send_data>
4001cfe8:	00050913          	mv	s2,a0
		if (ret < 0) {
4001cfec:	fa055ee3          	bgez	a0,4001cfa8 <tcp_send_queued_data.part.0+0x20>
	if (conn->send_data_total) {
4001cff0:	21042783          	lw	a5,528(s0)
4001cff4:	0f040493          	addi	s1,s0,240
4001cff8:	10040513          	addi	a0,s0,256
4001cffc:	08078a63          	beqz	a5,4001d090 <tcp_send_queued_data.part.0+0x108>
4001d000:	1e90d0ef          	jal	ra,4002a9e8 <z_timeout_remaining>
	if (k_work_delayable_remaining_get(&conn->send_data_timer)) {
4001d004:	00b56533          	or	a0,a0,a1
4001d008:	08051663          	bnez	a0,4001d094 <tcp_send_queued_data.part.0+0x10c>
					    K_MSEC(TCP_RTO_MS));
4001d00c:	23845503          	lhu	a0,568(s0)
		conn->send_data_retries = 0;
4001d010:	22040d23          	sb	zero,570(s0)
4001d014:	00a00613          	li	a2,10
4001d018:	00000693          	li	a3,0
4001d01c:	00950513          	addi	a0,a0,9
4001d020:	00000593          	li	a1,0
4001d024:	a94e30ef          	jal	ra,400002b8 <__udivdi3>
4001d028:	00050613          	mv	a2,a0
		k_work_reschedule_for_queue(&tcp_work_q, &conn->send_data_timer,
4001d02c:	40031537          	lui	a0,0x40031
4001d030:	00058693          	mv	a3,a1
4001d034:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
4001d038:	00048593          	mv	a1,s1
4001d03c:	5580c0ef          	jal	ra,40029594 <k_work_reschedule_for_queue>
4001d040:	0540006f          	j	4001d094 <tcp_send_queued_data.part.0+0x10c>
		if ((conn->tcp_nodelay == false) && (conn->unacked_len > 0)) {
4001d044:	f8f05ee3          	blez	a5,4001cfe0 <tcp_send_queued_data.part.0+0x58>
			if (tcp_unsent_len(conn) < conn_mss(conn)) {
4001d048:	08844783          	lbu	a5,136(s0)
4001d04c:	21800993          	li	s3,536
4001d050:	0017f793          	andi	a5,a5,1
4001d054:	00078463          	beqz	a5,4001d05c <tcp_send_queued_data.part.0+0xd4>
4001d058:	08445983          	lhu	s3,132(s0)
4001d05c:	00040513          	mv	a0,s0
4001d060:	83cff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001d064:	02a9d063          	bge	s3,a0,4001d084 <tcp_send_queued_data.part.0+0xfc>
4001d068:	08844783          	lbu	a5,136(s0)
4001d06c:	21800513          	li	a0,536
4001d070:	0017f793          	andi	a5,a5,1
4001d074:	00078463          	beqz	a5,4001d07c <tcp_send_queued_data.part.0+0xf4>
4001d078:	08445503          	lhu	a0,132(s0)
4001d07c:	f6a4d2e3          	bge	s1,a0,4001cfe0 <tcp_send_queued_data.part.0+0x58>
4001d080:	f71ff06f          	j	4001cff0 <tcp_send_queued_data.part.0+0x68>
4001d084:	00040513          	mv	a0,s0
4001d088:	814ff0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
4001d08c:	ff1ff06f          	j	4001d07c <tcp_send_queued_data.part.0+0xf4>
4001d090:	1590d0ef          	jal	ra,4002a9e8 <z_timeout_remaining>
}
4001d094:	01c12083          	lw	ra,28(sp)
4001d098:	01812403          	lw	s0,24(sp)
4001d09c:	01412483          	lw	s1,20(sp)
4001d0a0:	00c12983          	lw	s3,12(sp)
4001d0a4:	00090513          	mv	a0,s2
4001d0a8:	01012903          	lw	s2,16(sp)
4001d0ac:	02010113          	addi	sp,sp,32
4001d0b0:	00008067          	ret

4001d0b4 <net_tcp_queue_data>:
{
4001d0b4:	fe010113          	addi	sp,sp,-32
4001d0b8:	00912a23          	sw	s1,20(sp)
4001d0bc:	00112e23          	sw	ra,28(sp)
4001d0c0:	00812c23          	sw	s0,24(sp)
4001d0c4:	01212823          	sw	s2,16(sp)
4001d0c8:	01312623          	sw	s3,12(sp)
4001d0cc:	01412423          	sw	s4,8(sp)
4001d0d0:	01512223          	sw	s5,4(sp)
	struct tcp *conn = context->tcp;
4001d0d4:	05452403          	lw	s0,84(a0)
		return -ENOTCONN;
4001d0d8:	f8000493          	li	s1,-128
	if (!conn || conn->state != TCP_ESTABLISHED) {
4001d0dc:	06040063          	beqz	s0,4001d13c <net_tcp_queue_data+0x88>
4001d0e0:	22042703          	lw	a4,544(s0)
4001d0e4:	00400793          	li	a5,4
		return -ENOTCONN;
4001d0e8:	f8000493          	li	s1,-128
	if (!conn || conn->state != TCP_ESTABLISHED) {
4001d0ec:	04f71863          	bne	a4,a5,4001d13c <net_tcp_queue_data+0x88>
	k_mutex_lock(&conn->lock, K_FOREVER);
4001d0f0:	02840a93          	addi	s5,s0,40
4001d0f4:	00058913          	mv	s2,a1
4001d0f8:	fff00613          	li	a2,-1
4001d0fc:	fff00593          	li	a1,-1
4001d100:	000a8513          	mv	a0,s5
4001d104:	e15fd0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	bool window_full = (conn->send_data_total >= conn->send_win);
4001d108:	23645783          	lhu	a5,566(s0)
	if (tcp_window_full(conn)) {
4001d10c:	21042703          	lw	a4,528(s0)
4001d110:	04f76a63          	bltu	a4,a5,4001d164 <net_tcp_queue_data+0xb0>
		if (conn->send_win == 0) {
4001d114:	00078e63          	beqz	a5,4001d130 <net_tcp_queue_data+0x7c>
		(void)k_work_schedule_for_queue(&tcp_work_q,
4001d118:	40031537          	lui	a0,0x40031
4001d11c:	00000613          	li	a2,0
4001d120:	00000693          	li	a3,0
4001d124:	0f040593          	addi	a1,s0,240
4001d128:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
4001d12c:	3f00c0ef          	jal	ra,4002951c <k_work_schedule_for_queue>
		goto out;
4001d130:	ff500493          	li	s1,-11
	k_mutex_unlock(&conn->lock);
4001d134:	000a8513          	mv	a0,s5
4001d138:	9d4fe0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
}
4001d13c:	01c12083          	lw	ra,28(sp)
4001d140:	01812403          	lw	s0,24(sp)
4001d144:	01012903          	lw	s2,16(sp)
4001d148:	00c12983          	lw	s3,12(sp)
4001d14c:	00812a03          	lw	s4,8(sp)
4001d150:	00412a83          	lw	s5,4(sp)
4001d154:	00048513          	mv	a0,s1
4001d158:	01412483          	lw	s1,20(sp)
4001d15c:	02010113          	addi	sp,sp,32
4001d160:	00008067          	ret
	len = net_pkt_get_len(pkt);
4001d164:	00892503          	lw	a0,8(s2)
4001d168:	db5fd0ef          	jal	ra,4001af1c <net_pkt_get_len.isra.0>
	if (conn->send_data->buffer) {
4001d16c:	00842783          	lw	a5,8(s0)
	len = net_pkt_get_len(pkt);
4001d170:	00050a13          	mv	s4,a0
	if (conn->send_data->buffer) {
4001d174:	0087a983          	lw	s3,8(a5)
4001d178:	00098863          	beqz	s3,4001d188 <net_tcp_queue_data+0xd4>
		orig_buf = net_buf_frag_last(conn->send_data->buffer);
4001d17c:	00098513          	mv	a0,s3
4001d180:	861ec0ef          	jal	ra,400099e0 <net_buf_frag_last>
4001d184:	00050993          	mv	s3,a0
	net_pkt_append_buffer(conn->send_data, pkt->buffer);
4001d188:	00892583          	lw	a1,8(s2)
4001d18c:	00842503          	lw	a0,8(s0)
4001d190:	9a4f60ef          	jal	ra,40013334 <net_pkt_append_buffer>
	conn->send_data_total += len;
4001d194:	21042783          	lw	a5,528(s0)
4001d198:	014787b3          	add	a5,a5,s4
4001d19c:	20f42823          	sw	a5,528(s0)
	pkt->buffer = NULL;
4001d1a0:	00092423          	sw	zero,8(s2)
	if (conn->data_mode == TCP_DATA_MODE_RESEND) {
4001d1a4:	22442703          	lw	a4,548(s0)
4001d1a8:	00100793          	li	a5,1
4001d1ac:	08f70063          	beq	a4,a5,4001d22c <net_tcp_queue_data+0x178>
4001d1b0:	00040513          	mv	a0,s0
4001d1b4:	dd5ff0ef          	jal	ra,4001cf88 <tcp_send_queued_data.part.0>
4001d1b8:	00050493          	mv	s1,a0
	if (ret < 0 && ret != -ENOBUFS) {
4001d1bc:	06055a63          	bgez	a0,4001d230 <net_tcp_queue_data+0x17c>
4001d1c0:	f9700793          	li	a5,-105
4001d1c4:	00f50a63          	beq	a0,a5,4001d1d8 <net_tcp_queue_data+0x124>
		tcp_conn_close(conn, ret);
4001d1c8:	00050593          	mv	a1,a0
4001d1cc:	00040513          	mv	a0,s0
4001d1d0:	e98fe0ef          	jal	ra,4001b868 <tcp_conn_close.isra.0>
		goto out;
4001d1d4:	f61ff06f          	j	4001d134 <net_tcp_queue_data+0x80>
		(conn->send_data_total < (conn->unacked_len + len))) {
4001d1d8:	21842703          	lw	a4,536(s0)
4001d1dc:	21042783          	lw	a5,528(s0)
4001d1e0:	00ea0733          	add	a4,s4,a4
	if ((ret == -ENOBUFS) &&
4001d1e4:	04e7e463          	bltu	a5,a4,4001d22c <net_tcp_queue_data+0x178>
		conn->send_data_total -= len;
4001d1e8:	414787b3          	sub	a5,a5,s4
4001d1ec:	20f42823          	sw	a5,528(s0)
		if (orig_buf) {
4001d1f0:	02098263          	beqz	s3,4001d214 <net_tcp_queue_data+0x160>
			pkt->buffer = orig_buf->frags;
4001d1f4:	0049a783          	lw	a5,4(s3)
4001d1f8:	00f92423          	sw	a5,8(s2)
			orig_buf->frags = NULL;
4001d1fc:	0009a223          	sw	zero,4(s3)
		if (conn->send_data_total == 0) {
4001d200:	21042783          	lw	a5,528(s0)
4001d204:	f20798e3          	bnez	a5,4001d134 <net_tcp_queue_data+0x80>
			k_work_cancel_delayable(&conn->send_data_timer);
4001d208:	0f040513          	addi	a0,s0,240
4001d20c:	4300c0ef          	jal	ra,4002963c <k_work_cancel_delayable>
4001d210:	f25ff06f          	j	4001d134 <net_tcp_queue_data+0x80>
			pkt->buffer = conn->send_data->buffer;
4001d214:	00842783          	lw	a5,8(s0)
4001d218:	0087a783          	lw	a5,8(a5)
4001d21c:	00f92423          	sw	a5,8(s2)
			conn->send_data->buffer = NULL;
4001d220:	00842783          	lw	a5,8(s0)
4001d224:	0007a423          	sw	zero,8(a5)
4001d228:	fd9ff06f          	j	4001d200 <net_tcp_queue_data+0x14c>
{
4001d22c:	00000493          	li	s1,0
	bool window_full = (conn->send_data_total >= conn->send_win);
4001d230:	23645703          	lhu	a4,566(s0)
		if (tcp_window_full(conn)) {
4001d234:	21042783          	lw	a5,528(s0)
4001d238:	00e7ea63          	bltu	a5,a4,4001d24c <net_tcp_queue_data+0x198>
	return z_impl_k_sem_take(sem, timeout);
4001d23c:	00000593          	li	a1,0
4001d240:	00000613          	li	a2,0
4001d244:	05440513          	addi	a0,s0,84
4001d248:	3ad0b0ef          	jal	ra,40028df4 <z_impl_k_sem_take>
		tcp_pkt_unref(pkt);
4001d24c:	00090513          	mv	a0,s2
4001d250:	ccdf50ef          	jal	ra,40012f1c <net_pkt_unref>
4001d254:	ee1ff06f          	j	4001d134 <net_tcp_queue_data+0x80>

4001d258 <tcp_in>:
{
4001d258:	f8010113          	addi	sp,sp,-128
	k_mutex_lock(&conn->lock, K_FOREVER);
4001d25c:	02850793          	addi	a5,a0,40
{
4001d260:	06812c23          	sw	s0,120(sp)
4001d264:	06912a23          	sw	s1,116(sp)
4001d268:	06112e23          	sw	ra,124(sp)
4001d26c:	07212823          	sw	s2,112(sp)
4001d270:	07312623          	sw	s3,108(sp)
4001d274:	07412423          	sw	s4,104(sp)
4001d278:	07512223          	sw	s5,100(sp)
4001d27c:	07612023          	sw	s6,96(sp)
4001d280:	05712e23          	sw	s7,92(sp)
4001d284:	05812c23          	sw	s8,88(sp)
4001d288:	05912a23          	sw	s9,84(sp)
4001d28c:	05a12823          	sw	s10,80(sp)
4001d290:	05b12623          	sw	s11,76(sp)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001d294:	00f12423          	sw	a5,8(sp)
{
4001d298:	00050413          	mv	s0,a0
4001d29c:	00058493          	mv	s1,a1
	struct tcphdr *th = pkt ? th_get(pkt) : NULL;
4001d2a0:	02059663          	bnez	a1,4001d2cc <tcp_in+0x74>
	k_mutex_lock(&conn->lock, K_FOREVER);
4001d2a4:	fff00593          	li	a1,-1
4001d2a8:	fff00613          	li	a2,-1
4001d2ac:	00078513          	mv	a0,a5
	uint8_t next = 0, fl = 0;
4001d2b0:	00000913          	li	s2,0
	k_mutex_lock(&conn->lock, K_FOREVER);
4001d2b4:	c65fd0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	struct tcphdr *th = pkt ? th_get(pkt) : NULL;
4001d2b8:	00000b93          	li	s7,0
	enum net_verdict verdict = NET_DROP;
4001d2bc:	00200993          	li	s3,2
	int close_status = 0;
4001d2c0:	00000a93          	li	s5,0
	return len > 0 ? (size_t)len : 0;
4001d2c4:	00000a13          	li	s4,0
4001d2c8:	0680006f          	j	4001d330 <tcp_in+0xd8>
	struct tcphdr *th = pkt ? th_get(pkt) : NULL;
4001d2cc:	00058513          	mv	a0,a1
4001d2d0:	cddfd0ef          	jal	ra,4001afac <th_get>
4001d2d4:	00050b93          	mv	s7,a0
	uint8_t next = 0, fl = 0;
4001d2d8:	00000913          	li	s2,0
	size_t tcp_options_len = th ? (th_off(th) - 5) * 4 : 0;
4001d2dc:	06051263          	bnez	a0,4001d340 <tcp_in+0xe8>
	k_mutex_lock(&conn->lock, K_FOREVER);
4001d2e0:	fff00593          	li	a1,-1
4001d2e4:	fff00613          	li	a2,-1
4001d2e8:	02840513          	addi	a0,s0,40
4001d2ec:	c2dfd0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	enum net_verdict verdict = NET_DROP;
4001d2f0:	00200993          	li	s3,2
	int close_status = 0;
4001d2f4:	00000a93          	li	s5,0
	struct tcphdr *th = th_get(pkt);
4001d2f8:	00048513          	mv	a0,s1
4001d2fc:	cb1fd0ef          	jal	ra,4001afac <th_get>
4001d300:	00050b13          	mv	s6,a0
	int len = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -
4001d304:	0084a503          	lw	a0,8(s1)
4001d308:	c15fd0ef          	jal	ra,4001af1c <net_pkt_get_len.isra.0>
4001d30c:	0364c703          	lbu	a4,54(s1)
		net_pkt_ip_opts_len(pkt) - sizeof(*th) - tcp_options_len;
4001d310:	03a4d683          	lhu	a3,58(s1)
4001d314:	00d70733          	add	a4,a4,a3
4001d318:	40e50a33          	sub	s4,a0,a4
	size_t tcp_options_len = (th_off(th) - 5) * 4;
4001d31c:	00cb4703          	lbu	a4,12(s6)
4001d320:	00475713          	srli	a4,a4,0x4
4001d324:	00271713          	slli	a4,a4,0x2
		net_pkt_ip_opts_len(pkt) - sizeof(*th) - tcp_options_len;
4001d328:	40ea0a33          	sub	s4,s4,a4
	return len > 0 ? (size_t)len : 0;
4001d32c:	f80a4ce3          	bltz	s4,4001d2c4 <tcp_in+0x6c>
	switch (conn->state) {
4001d330:	4002dcb7          	lui	s9,0x4002d
	len = pkt ? tcp_data_len(pkt) : 0;
4001d334:	00000c13          	li	s8,0
	switch (conn->state) {
4001d338:	4f4c8c93          	addi	s9,s9,1268 # 4002d4f4 <CSWTCH.15321+0xac>
4001d33c:	4140006f          	j	4001d750 <tcp_in+0x4f8>
	size_t tcp_options_len = th ? (th_off(th) - 5) * 4 : 0;
4001d340:	00c54983          	lbu	s3,12(a0)
		fl = th_flags(th) & ~(ECN | CWR);
4001d344:	00d54a03          	lbu	s4,13(a0)
	k_mutex_lock(&conn->lock, K_FOREVER);
4001d348:	fff00593          	li	a1,-1
4001d34c:	fff00613          	li	a2,-1
4001d350:	02840513          	addi	a0,s0,40
4001d354:	bc5fd0ef          	jal	ra,4001af18 <k_mutex_lock.constprop.0.isra.0>
	if (th && th_off(th) < 5) {
4001d358:	00cbc703          	lbu	a4,12(s7)
	size_t tcp_options_len = th ? (th_off(th) - 5) * 4 : 0;
4001d35c:	0049d993          	srli	s3,s3,0x4
4001d360:	ffb98993          	addi	s3,s3,-5
	if (th && th_off(th) < 5) {
4001d364:	00475713          	srli	a4,a4,0x4
4001d368:	00400693          	li	a3,4
	size_t tcp_options_len = th ? (th_off(th) - 5) * 4 : 0;
4001d36c:	00299993          	slli	s3,s3,0x2
		fl = th_flags(th) & ~(ECN | CWR);
4001d370:	03fa7913          	andi	s2,s4,63
	if (th && th_off(th) < 5) {
4001d374:	02e6e063          	bltu	a3,a4,4001d394 <tcp_in+0x13c>
		tcp_out(conn, RST);
4001d378:	00400593          	li	a1,4
4001d37c:	00040513          	mv	a0,s0
4001d380:	99cff0ef          	jal	ra,4001c51c <tcp_out>
		conn_state(conn, TCP_CLOSED);
4001d384:	00b00713          	li	a4,11
4001d388:	22e42023          	sw	a4,544(s0)
	enum net_verdict verdict = NET_DROP;
4001d38c:	00200993          	li	s3,2
4001d390:	1480006f          	j	4001d4d8 <tcp_in+0x280>
	if (FL(&fl, &, RST)) {
4001d394:	0c091263          	bnez	s2,4001d458 <tcp_in+0x200>
	if (tcp_options_len && !tcp_options_check(&conn->recv_options, pkt,
4001d398:	08098063          	beqz	s3,4001d418 <tcp_in+0x1c0>
	net_pkt_cursor_init(pkt);
4001d39c:	00048513          	mv	a0,s1
	backup->buf = pkt->cursor.buf;
4001d3a0:	00c4aa83          	lw	s5,12(s1)
	backup->pos = pkt->cursor.pos;
4001d3a4:	0104aa03          	lw	s4,16(s1)
4001d3a8:	e49f50ef          	jal	ra,400131f0 <net_pkt_cursor_init>
	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) + net_pkt_ip_opts_len(pkt) +
4001d3ac:	03a4d703          	lhu	a4,58(s1)
4001d3b0:	0364c583          	lbu	a1,54(s1)
4001d3b4:	00048513          	mv	a0,s1
4001d3b8:	00e585b3          	add	a1,a1,a4
4001d3bc:	01458593          	addi	a1,a1,20 # ff0014 <__rom_region_size+0xfbf638>
4001d3c0:	ba4f60ef          	jal	ra,40013764 <net_pkt_skip>
	ret = net_pkt_read(pkt, buf, MIN(tcp_options_len, buf_len));
4001d3c4:	02800713          	li	a4,40
4001d3c8:	00098613          	mv	a2,s3
4001d3cc:	01377463          	bgeu	a4,s3,4001d3d4 <tcp_in+0x17c>
4001d3d0:	02800613          	li	a2,40
4001d3d4:	01810593          	addi	a1,sp,24
4001d3d8:	00048513          	mv	a0,s1
4001d3dc:	df0f60ef          	jal	ra,400139cc <net_pkt_read>
	pkt->cursor.buf = backup->buf;
4001d3e0:	0154a623          	sw	s5,12(s1)
	pkt->cursor.pos = backup->pos;
4001d3e4:	0144a823          	sw	s4,16(s1)
	recv_options->mss_found = false;
4001d3e8:	08844703          	lbu	a4,136(s0)
4001d3ec:	ffc77713          	andi	a4,a4,-4
4001d3f0:	08e40423          	sb	a4,136(s0)
	if (ret < 0) {
4001d3f4:	02054063          	bltz	a0,4001d414 <tcp_in+0x1bc>
	if (tcp_options_len && !tcp_options_check(&conn->recv_options, pkt,
4001d3f8:	00098593          	mv	a1,s3
	recv_options->mss_found = false;
4001d3fc:	01810713          	addi	a4,sp,24
		} else if (opt == NET_TCP_NOP_OPT) {
4001d400:	00100513          	li	a0,1
		switch (opt) {
4001d404:	00200313          	li	t1,2
			if (opt_len != 4) {
4001d408:	00400e13          	li	t3,4
		switch (opt) {
4001d40c:	00300813          	li	a6,3
	for ( ; options && len >= 1; options += opt_len, len -= opt_len) {
4001d410:	0cb04863          	bgtz	a1,4001d4e0 <tcp_in+0x288>
	if (tcp_options_len && !tcp_options_check(&conn->recv_options, pkt,
4001d414:	f73052e3          	blez	s3,4001d378 <tcp_in+0x120>
	if (th && (conn->state != TCP_LISTEN) && (conn->state != TCP_SYN_SENT) &&
4001d418:	22042703          	lw	a4,544(s0)
4001d41c:	00100693          	li	a3,1
4001d420:	fff70713          	addi	a4,a4,-1
4001d424:	12e6fe63          	bgeu	a3,a4,4001d560 <tcp_in+0x308>
	    tcp_validate_seq(conn, th) && FL(&fl, &, SYN)) {
4001d428:	000b8593          	mv	a1,s7
4001d42c:	00040513          	mv	a0,s0
4001d430:	fe8fd0ef          	jal	ra,4001ac18 <tcp_validate_seq>
	if (th && (conn->state != TCP_LISTEN) && (conn->state != TCP_SYN_SENT) &&
4001d434:	12050663          	beqz	a0,4001d560 <tcp_in+0x308>
	    tcp_validate_seq(conn, th) && FL(&fl, &, SYN)) {
4001d438:	12090463          	beqz	s2,4001d560 <tcp_in+0x308>
4001d43c:	4002c537          	lui	a0,0x4002c
4001d440:	ed850513          	addi	a0,a0,-296 # 4002bed8 <__clz_tab+0x2ac>
4001d444:	ae5eb0ef          	jal	ra,40008f28 <strlen>
4001d448:	00297713          	andi	a4,s2,2
4001d44c:	10070a63          	beqz	a4,4001d560 <tcp_in+0x308>
4001d450:	0fd97913          	andi	s2,s2,253
4001d454:	f25ff06f          	j	4001d378 <tcp_in+0x120>
	if (FL(&fl, &, RST)) {
4001d458:	4002c537          	lui	a0,0x4002c
4001d45c:	ed850513          	addi	a0,a0,-296 # 4002bed8 <__clz_tab+0x2ac>
4001d460:	ac9eb0ef          	jal	ra,40008f28 <strlen>
4001d464:	004a7713          	andi	a4,s4,4
4001d468:	f20708e3          	beqz	a4,4001d398 <tcp_in+0x140>
		if (!tcp_validate_seq(conn, th)) {
4001d46c:	000b8593          	mv	a1,s7
4001d470:	00040513          	mv	a0,s0
	if (FL(&fl, &, RST)) {
4001d474:	03ba7913          	andi	s2,s4,59
		if (!tcp_validate_seq(conn, th)) {
4001d478:	fa0fd0ef          	jal	ra,4001ac18 <tcp_validate_seq>
4001d47c:	04051863          	bnez	a0,4001d4cc <tcp_in+0x274>
			k_mutex_unlock(&conn->lock);
4001d480:	00812503          	lw	a0,8(sp)
			return NET_DROP;
4001d484:	00200993          	li	s3,2
			k_mutex_unlock(&conn->lock);
4001d488:	e85fd0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
}
4001d48c:	07c12083          	lw	ra,124(sp)
4001d490:	07812403          	lw	s0,120(sp)
4001d494:	07412483          	lw	s1,116(sp)
4001d498:	07012903          	lw	s2,112(sp)
4001d49c:	06812a03          	lw	s4,104(sp)
4001d4a0:	06412a83          	lw	s5,100(sp)
4001d4a4:	06012b03          	lw	s6,96(sp)
4001d4a8:	05c12b83          	lw	s7,92(sp)
4001d4ac:	05812c03          	lw	s8,88(sp)
4001d4b0:	05412c83          	lw	s9,84(sp)
4001d4b4:	05012d03          	lw	s10,80(sp)
4001d4b8:	04c12d83          	lw	s11,76(sp)
4001d4bc:	00098513          	mv	a0,s3
4001d4c0:	06c12983          	lw	s3,108(sp)
4001d4c4:	08010113          	addi	sp,sp,128
4001d4c8:	00008067          	ret
		conn_state(conn, TCP_CLOSED);
4001d4cc:	00b00713          	li	a4,11
4001d4d0:	22e42023          	sw	a4,544(s0)
		verdict = NET_OK;
4001d4d4:	00000993          	li	s3,0
		close_status = -ECONNRESET;
4001d4d8:	f9800a93          	li	s5,-104
4001d4dc:	e1dff06f          	j	4001d2f8 <tcp_in+0xa0>
		opt = options[0];
4001d4e0:	00074683          	lbu	a3,0(a4)
		if (opt == NET_TCP_END_OPT) {
4001d4e4:	f20688e3          	beqz	a3,4001d414 <tcp_in+0x1bc>
		} else if (opt == NET_TCP_NOP_OPT) {
4001d4e8:	06a68863          	beq	a3,a0,4001d558 <tcp_in+0x300>
			if (len < 2) { /* Only END and NOP can have length 1 */
4001d4ec:	e8a586e3          	beq	a1,a0,4001d378 <tcp_in+0x120>
			opt_len = options[1];
4001d4f0:	00174603          	lbu	a2,1(a4)
		if (opt_len < 2 || opt_len > len) {
4001d4f4:	e8c572e3          	bgeu	a0,a2,4001d378 <tcp_in+0x120>
4001d4f8:	e8c5c0e3          	blt	a1,a2,4001d378 <tcp_in+0x120>
		switch (opt) {
4001d4fc:	00668a63          	beq	a3,t1,4001d510 <tcp_in+0x2b8>
4001d500:	05068263          	beq	a3,a6,4001d544 <tcp_in+0x2ec>
	for ( ; options && len >= 1; options += opt_len, len -= opt_len) {
4001d504:	00c70733          	add	a4,a4,a2
4001d508:	40c585b3          	sub	a1,a1,a2
4001d50c:	f05ff06f          	j	4001d410 <tcp_in+0x1b8>
			if (opt_len != 4) {
4001d510:	e7c614e3          	bne	a2,t3,4001d378 <tcp_in+0x120>
			recv_options->mss =
4001d514:	00374683          	lbu	a3,3(a4)
4001d518:	00274883          	lbu	a7,2(a4)
4001d51c:	00869693          	slli	a3,a3,0x8
4001d520:	0116e6b3          	or	a3,a3,a7
4001d524:	00869893          	slli	a7,a3,0x8
4001d528:	0086d693          	srli	a3,a3,0x8
4001d52c:	00d8e6b3          	or	a3,a7,a3
4001d530:	08d41223          	sh	a3,132(s0)
			recv_options->mss_found = true;
4001d534:	08844683          	lbu	a3,136(s0)
4001d538:	0016e693          	ori	a3,a3,1
			recv_options->wnd_found = true;
4001d53c:	08d40423          	sb	a3,136(s0)
			break;
4001d540:	fc5ff06f          	j	4001d504 <tcp_in+0x2ac>
			if (opt_len != 3) {
4001d544:	e3061ae3          	bne	a2,a6,4001d378 <tcp_in+0x120>
			recv_options->wnd_found = true;
4001d548:	08844683          	lbu	a3,136(s0)
			recv_options->window = opt;
4001d54c:	09041323          	sh	a6,134(s0)
			recv_options->wnd_found = true;
4001d550:	0026e693          	ori	a3,a3,2
4001d554:	fe9ff06f          	j	4001d53c <tcp_in+0x2e4>
			opt_len = 1;
4001d558:	00100613          	li	a2,1
4001d55c:	fa9ff06f          	j	4001d504 <tcp_in+0x2ac>
		if (conn->send_win > conn->send_win_max) {
4001d560:	00fbc703          	lbu	a4,15(s7)
4001d564:	00ebc683          	lbu	a3,14(s7)
4001d568:	23445603          	lhu	a2,564(s0)
4001d56c:	00871713          	slli	a4,a4,0x8
4001d570:	00d76733          	or	a4,a4,a3
4001d574:	00871693          	slli	a3,a4,0x8
4001d578:	00875713          	srli	a4,a4,0x8
4001d57c:	00e6e733          	or	a4,a3,a4
4001d580:	00070693          	mv	a3,a4
4001d584:	01071713          	slli	a4,a4,0x10
4001d588:	01075713          	srli	a4,a4,0x10
4001d58c:	00e67463          	bgeu	a2,a4,4001d594 <tcp_in+0x33c>
4001d590:	00060693          	mv	a3,a2
4001d594:	01069713          	slli	a4,a3,0x10
			if (!k_work_delayable_is_pending(&conn->persist_timer)) {
4001d598:	15040993          	addi	s3,s0,336
4001d59c:	01075713          	srli	a4,a4,0x10
4001d5a0:	22d41b23          	sh	a3,566(s0)
	return k_work_delayable_busy_get(dwork) != 0;
4001d5a4:	00098513          	mv	a0,s3
		if (conn->send_win == 0) {
4001d5a8:	06071063          	bnez	a4,4001d608 <tcp_in+0x3b0>
4001d5ac:	76d0b0ef          	jal	ra,40029518 <k_work_delayable_busy_get>
			if (!k_work_delayable_is_pending(&conn->persist_timer)) {
4001d5b0:	02051c63          	bnez	a0,4001d5e8 <tcp_in+0x390>
					K_MSEC(TCP_RTO_MS));
4001d5b4:	23845503          	lhu	a0,568(s0)
4001d5b8:	00a00613          	li	a2,10
4001d5bc:	00000693          	li	a3,0
				conn->zwp_retries = 0;
4001d5c0:	22040e23          	sb	zero,572(s0)
4001d5c4:	00950513          	addi	a0,a0,9
4001d5c8:	00000593          	li	a1,0
4001d5cc:	cede20ef          	jal	ra,400002b8 <__udivdi3>
4001d5d0:	00050613          	mv	a2,a0
				(void)k_work_reschedule_for_queue(
4001d5d4:	40031537          	lui	a0,0x40031
4001d5d8:	00058693          	mv	a3,a1
4001d5dc:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
4001d5e0:	00098593          	mv	a1,s3
4001d5e4:	7b10b0ef          	jal	ra,40029594 <k_work_reschedule_for_queue>
	bool window_full = (conn->send_data_total >= conn->send_win);
4001d5e8:	23645703          	lhu	a4,566(s0)
		if (tcp_window_full(conn)) {
4001d5ec:	21042683          	lw	a3,528(s0)
				k_sem_give(&conn->tx_sem);
4001d5f0:	05440513          	addi	a0,s0,84
		if (tcp_window_full(conn)) {
4001d5f4:	00e6ee63          	bltu	a3,a4,4001d610 <tcp_in+0x3b8>
4001d5f8:	00000593          	li	a1,0
4001d5fc:	00000613          	li	a2,0
4001d600:	7f40b0ef          	jal	ra,40028df4 <z_impl_k_sem_take>
4001d604:	cedff06f          	j	4001d2f0 <tcp_in+0x98>
			(void)k_work_cancel_delayable(&conn->persist_timer);
4001d608:	0340c0ef          	jal	ra,4002963c <k_work_cancel_delayable>
4001d60c:	fddff06f          	j	4001d5e8 <tcp_in+0x390>
	z_impl_k_sem_give(sem);
4001d610:	7740b0ef          	jal	ra,40028d84 <z_impl_k_sem_give>
}
4001d614:	cddff06f          	j	4001d2f0 <tcp_in+0x98>
		if (FL(&fl, ==, SYN)) {
4001d618:	0ff97a13          	zext.b	s4,s2
4001d61c:	0e0a0263          	beqz	s4,4001d700 <tcp_in+0x4a8>
4001d620:	4002c537          	lui	a0,0x4002c
4001d624:	ed850513          	addi	a0,a0,-296 # 4002bed8 <__clz_tab+0x2ac>
4001d628:	901eb0ef          	jal	ra,40008f28 <strlen>
4001d62c:	00200713          	li	a4,2
4001d630:	0cea1863          	bne	s4,a4,4001d700 <tcp_in+0x4a8>
			conn->send_options.mss_found = true;
4001d634:	08e44703          	lbu	a4,142(s0)
			conn_ack(conn, th_seq(th) + 1); /* capture peer's isn */
4001d638:	00010637          	lui	a2,0x10
4001d63c:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
			conn->send_options.mss_found = true;
4001d640:	00176713          	ori	a4,a4,1
4001d644:	08e40723          	sb	a4,142(s0)
			conn_ack(conn, th_seq(th) + 1); /* capture peer's isn */
4001d648:	005bc683          	lbu	a3,5(s7)
4001d64c:	004bc703          	lbu	a4,4(s7)
4001d650:	007bc783          	lbu	a5,7(s7)
4001d654:	00869693          	slli	a3,a3,0x8
4001d658:	00e6e6b3          	or	a3,a3,a4
4001d65c:	006bc703          	lbu	a4,6(s7)
4001d660:	01879793          	slli	a5,a5,0x18
			tcp_out(conn, SYN | ACK);
4001d664:	01200593          	li	a1,18
			conn_ack(conn, th_seq(th) + 1); /* capture peer's isn */
4001d668:	01071713          	slli	a4,a4,0x10
4001d66c:	00d76733          	or	a4,a4,a3
4001d670:	00e7e6b3          	or	a3,a5,a4
4001d674:	01871713          	slli	a4,a4,0x18
4001d678:	0187d793          	srli	a5,a5,0x18
4001d67c:	00e7e7b3          	or	a5,a5,a4
4001d680:	0086d713          	srli	a4,a3,0x8
4001d684:	00c77733          	and	a4,a4,a2
4001d688:	00e7e7b3          	or	a5,a5,a4
4001d68c:	00869693          	slli	a3,a3,0x8
4001d690:	00ff0737          	lui	a4,0xff0
4001d694:	00e6f6b3          	and	a3,a3,a4
4001d698:	22c42703          	lw	a4,556(s0)
4001d69c:	00d7e7b3          	or	a5,a5,a3
			tcp_out(conn, SYN | ACK);
4001d6a0:	00040513          	mv	a0,s0
			conn_ack(conn, th_seq(th) + 1); /* capture peer's isn */
4001d6a4:	00170713          	addi	a4,a4,1 # ff0001 <__rom_region_size+0xfbf625>
4001d6a8:	00e787b3          	add	a5,a5,a4
4001d6ac:	22f42623          	sw	a5,556(s0)
			tcp_out(conn, SYN | ACK);
4001d6b0:	e6dfe0ef          	jal	ra,4001c51c <tcp_out>
			conn->send_options.mss_found = false;
4001d6b4:	08e44783          	lbu	a5,142(s0)
			k_work_reschedule_for_queue(&tcp_work_q,
4001d6b8:	40031537          	lui	a0,0x40031
4001d6bc:	06400613          	li	a2,100
			conn->send_options.mss_found = false;
4001d6c0:	ffe7f793          	andi	a5,a5,-2
4001d6c4:	08f40723          	sb	a5,142(s0)
			conn_seq(conn, + 1);
4001d6c8:	22842783          	lw	a5,552(s0)
			k_work_reschedule_for_queue(&tcp_work_q,
4001d6cc:	00000693          	li	a3,0
4001d6d0:	1b040593          	addi	a1,s0,432
			conn_seq(conn, + 1);
4001d6d4:	00178793          	addi	a5,a5,1
4001d6d8:	22f42423          	sw	a5,552(s0)
			k_work_reschedule_for_queue(&tcp_work_q,
4001d6dc:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
		if (FL(&fl, ==, SYN)) {
4001d6e0:	00000913          	li	s2,0
			k_work_reschedule_for_queue(&tcp_work_q,
4001d6e4:	6b10b0ef          	jal	ra,40029594 <k_work_reschedule_for_queue>
	if (pkt) {
4001d6e8:	00048663          	beqz	s1,4001d6f4 <tcp_in+0x49c>
			net_pkt_unref(pkt);
4001d6ec:	00048513          	mv	a0,s1
4001d6f0:	82df50ef          	jal	ra,40012f1c <net_pkt_unref>
			next = TCP_SYN_RECEIVED;
4001d6f4:	00300a13          	li	s4,3
			verdict = NET_OK;
4001d6f8:	00000993          	li	s3,0
4001d6fc:	0400006f          	j	4001d73c <tcp_in+0x4e4>
			conn->send_options.mss_found = true;
4001d700:	08e44783          	lbu	a5,142(s0)
			tcp_out(conn, SYN);
4001d704:	00200593          	li	a1,2
4001d708:	00040513          	mv	a0,s0
			conn->send_options.mss_found = true;
4001d70c:	0017e793          	ori	a5,a5,1
4001d710:	08f40723          	sb	a5,142(s0)
			tcp_out(conn, SYN);
4001d714:	e09fe0ef          	jal	ra,4001c51c <tcp_out>
			conn->send_options.mss_found = false;
4001d718:	08e44783          	lbu	a5,142(s0)
			next = TCP_SYN_SENT;
4001d71c:	00200a13          	li	s4,2
			conn->send_options.mss_found = false;
4001d720:	ffe7f793          	andi	a5,a5,-2
4001d724:	08f40723          	sb	a5,142(s0)
			conn_seq(conn, + 1);
4001d728:	22842783          	lw	a5,552(s0)
4001d72c:	00178793          	addi	a5,a5,1
4001d730:	22f42423          	sw	a5,552(s0)
	if (pkt) {
4001d734:	00048463          	beqz	s1,4001d73c <tcp_in+0x4e4>
4001d738:	1e00106f          	j	4001e918 <tcp_in+0x16c0>
		conn_state(conn, next);
4001d73c:	23442023          	sw	s4,544(s0)
		if (connection_ok) {
4001d740:	300c1863          	bnez	s8,4001da50 <tcp_in+0x7f8>
	len = pkt ? tcp_data_len(pkt) : 0;
4001d744:	00000493          	li	s1,0
4001d748:	00000b93          	li	s7,0
4001d74c:	00000a13          	li	s4,0
	switch (conn->state) {
4001d750:	22042703          	lw	a4,544(s0)
	len = pkt ? tcp_data_len(pkt) : 0;
4001d754:	01412c23          	sw	s4,24(sp)
	switch (conn->state) {
4001d758:	00a00793          	li	a5,10
4001d75c:	fff70713          	addi	a4,a4,-1
4001d760:	00e7f463          	bgeu	a5,a4,4001d768 <tcp_in+0x510>
4001d764:	7550006f          	j	4001e6b8 <tcp_in+0x1460>
4001d768:	00271713          	slli	a4,a4,0x2
4001d76c:	01970733          	add	a4,a4,s9
4001d770:	00072703          	lw	a4,0(a4)
4001d774:	00070067          	jr	a4
		if (FL(&fl, &, ACK, th_ack(th) == conn->seq &&
4001d778:	0ff97913          	zext.b	s2,s2
4001d77c:	00091463          	bnez	s2,4001d784 <tcp_in+0x52c>
4001d780:	7390006f          	j	4001e6b8 <tcp_in+0x1460>
4001d784:	4002d537          	lui	a0,0x4002d
4001d788:	46c50513          	addi	a0,a0,1132 # 4002d46c <CSWTCH.15321+0x24>
4001d78c:	f9ceb0ef          	jal	ra,40008f28 <strlen>
4001d790:	0a050c63          	beqz	a0,4001d848 <tcp_in+0x5f0>
4001d794:	009bc703          	lbu	a4,9(s7)
4001d798:	008bc683          	lbu	a3,8(s7)
4001d79c:	000105b7          	lui	a1,0x10
4001d7a0:	00871713          	slli	a4,a4,0x8
4001d7a4:	00d76733          	or	a4,a4,a3
4001d7a8:	00abc683          	lbu	a3,10(s7)
4001d7ac:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001d7b0:	00ff0537          	lui	a0,0xff0
4001d7b4:	01069693          	slli	a3,a3,0x10
4001d7b8:	00e6e6b3          	or	a3,a3,a4
4001d7bc:	00bbc703          	lbu	a4,11(s7)
4001d7c0:	01871713          	slli	a4,a4,0x18
4001d7c4:	00d76633          	or	a2,a4,a3
4001d7c8:	01869693          	slli	a3,a3,0x18
4001d7cc:	01875713          	srli	a4,a4,0x18
4001d7d0:	00d76733          	or	a4,a4,a3
4001d7d4:	00865693          	srli	a3,a2,0x8
4001d7d8:	00b6f6b3          	and	a3,a3,a1
4001d7dc:	00d76733          	or	a4,a4,a3
4001d7e0:	00861613          	slli	a2,a2,0x8
4001d7e4:	22842683          	lw	a3,552(s0)
4001d7e8:	00a67633          	and	a2,a2,a0
4001d7ec:	00c76733          	or	a4,a4,a2
4001d7f0:	6cd714e3          	bne	a4,a3,4001e6b8 <tcp_in+0x1460>
4001d7f4:	005bc683          	lbu	a3,5(s7)
4001d7f8:	004bc703          	lbu	a4,4(s7)
4001d7fc:	007bc783          	lbu	a5,7(s7)
4001d800:	00869693          	slli	a3,a3,0x8
4001d804:	00e6e6b3          	or	a3,a3,a4
4001d808:	006bc703          	lbu	a4,6(s7)
4001d80c:	01879793          	slli	a5,a5,0x18
4001d810:	01071713          	slli	a4,a4,0x10
4001d814:	00d76733          	or	a4,a4,a3
4001d818:	00e7e6b3          	or	a3,a5,a4
4001d81c:	01871713          	slli	a4,a4,0x18
4001d820:	0187d793          	srli	a5,a5,0x18
4001d824:	00e7e7b3          	or	a5,a5,a4
4001d828:	0086d713          	srli	a4,a3,0x8
4001d82c:	00b77733          	and	a4,a4,a1
4001d830:	00e7e7b3          	or	a5,a5,a4
4001d834:	00869693          	slli	a3,a3,0x8
4001d838:	22c42703          	lw	a4,556(s0)
4001d83c:	00a6f6b3          	and	a3,a3,a0
4001d840:	00d7e7b3          	or	a5,a5,a3
4001d844:	66e79ae3          	bne	a5,a4,4001e6b8 <tcp_in+0x1460>
4001d848:	01097793          	andi	a5,s2,16
4001d84c:	660786e3          	beqz	a5,4001e6b8 <tcp_in+0x1460>
			k_work_cancel_delayable(&conn->establish_timer);
4001d850:	1b040513          	addi	a0,s0,432
4001d854:	5e90b0ef          	jal	ra,4002963c <k_work_cancel_delayable>
			tcp_send_timer_cancel(conn);
4001d858:	00040513          	mv	a0,s0
4001d85c:	ab5fd0ef          	jal	ra,4001b310 <tcp_send_timer_cancel>
	int ref_count = atomic_inc(&conn->ref_count) + 1;
4001d860:	21c40513          	addi	a0,s0,540
4001d864:	db5fd0ef          	jal	ra,4001b618 <atomic_inc.isra.0>
			net_context_set_state(conn->context,
4001d868:	00442703          	lw	a4,4(s0)
		if (FL(&fl, &, ACK, th_ack(th) == conn->seq &&
4001d86c:	0ef97913          	andi	s2,s2,239
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
4001d870:	07475783          	lhu	a5,116(a4)
4001d874:	ff97f793          	andi	a5,a5,-7
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
4001d878:	0047e793          	ori	a5,a5,4
4001d87c:	06f71a23          	sh	a5,116(a4)
			if (conn->accepted_conn) {
4001d880:	02042783          	lw	a5,32(s0)
4001d884:	02078463          	beqz	a5,4001d8ac <tcp_in+0x654>
				if (conn->accepted_conn->accept_cb) {
4001d888:	0207a803          	lw	a6,32(a5)
4001d88c:	00080e63          	beqz	a6,4001d8a8 <tcp_in+0x650>
						&conn->accepted_conn->context->remote,
4001d890:	0047a703          	lw	a4,4(a5)
					conn->accepted_conn->accept_cb(
4001d894:	00442503          	lw	a0,4(s0)
4001d898:	00000693          	li	a3,0
4001d89c:	01800613          	li	a2,24
4001d8a0:	02c70593          	addi	a1,a4,44
4001d8a4:	000800e7          	jalr	a6
				conn->accepted_conn = NULL;
4001d8a8:	02042023          	sw	zero,32(s0)
			if (len) {
4001d8ac:	000a1463          	bnez	s4,4001d8b4 <tcp_in+0x65c>
4001d8b0:	7f10006f          	j	4001e8a0 <tcp_in+0x1648>
				verdict = tcp_data_get(conn, pkt, &len);
4001d8b4:	00048593          	mv	a1,s1
4001d8b8:	01810613          	addi	a2,sp,24
4001d8bc:	00040513          	mv	a0,s0
4001d8c0:	cd8ff0ef          	jal	ra,4001cd98 <tcp_data_get>
4001d8c4:	22c42783          	lw	a5,556(s0)
4001d8c8:	01812703          	lw	a4,24(sp)
4001d8cc:	00050993          	mv	s3,a0
				tcp_out(conn, ACK);
4001d8d0:	01000593          	li	a1,16
				conn_ack(conn, + len);
4001d8d4:	00e787b3          	add	a5,a5,a4
4001d8d8:	22f42623          	sw	a5,556(s0)
				tcp_out(conn, ACK);
4001d8dc:	00040513          	mv	a0,s0
4001d8e0:	c3dfe0ef          	jal	ra,4001c51c <tcp_out>
			next = TCP_ESTABLISHED;
4001d8e4:	00400a13          	li	s4,4
4001d8e8:	e55ff06f          	j	4001d73c <tcp_in+0x4e4>
		if (FL(&fl, &, SYN | ACK, th && th_ack(th) == conn->seq)) {
4001d8ec:	0ff97913          	zext.b	s2,s2
4001d8f0:	5c0904e3          	beqz	s2,4001e6b8 <tcp_in+0x1460>
4001d8f4:	4002d537          	lui	a0,0x4002d
4001d8f8:	4a050513          	addi	a0,a0,1184 # 4002d4a0 <CSWTCH.15321+0x58>
4001d8fc:	e2ceb0ef          	jal	ra,40008f28 <strlen>
4001d900:	06050463          	beqz	a0,4001d968 <tcp_in+0x710>
4001d904:	5a0b8ae3          	beqz	s7,4001e6b8 <tcp_in+0x1460>
4001d908:	009bc703          	lbu	a4,9(s7)
4001d90c:	008bc683          	lbu	a3,8(s7)
4001d910:	000105b7          	lui	a1,0x10
4001d914:	00871713          	slli	a4,a4,0x8
4001d918:	00d76733          	or	a4,a4,a3
4001d91c:	00abc683          	lbu	a3,10(s7)
4001d920:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001d924:	01069693          	slli	a3,a3,0x10
4001d928:	00e6e6b3          	or	a3,a3,a4
4001d92c:	00bbc703          	lbu	a4,11(s7)
4001d930:	01871713          	slli	a4,a4,0x18
4001d934:	00d76633          	or	a2,a4,a3
4001d938:	01869693          	slli	a3,a3,0x18
4001d93c:	01875713          	srli	a4,a4,0x18
4001d940:	00d76733          	or	a4,a4,a3
4001d944:	00865693          	srli	a3,a2,0x8
4001d948:	00b6f6b3          	and	a3,a3,a1
4001d94c:	00d76733          	or	a4,a4,a3
4001d950:	00861613          	slli	a2,a2,0x8
4001d954:	00ff06b7          	lui	a3,0xff0
4001d958:	00d67633          	and	a2,a2,a3
4001d95c:	22842683          	lw	a3,552(s0)
4001d960:	00c76733          	or	a4,a4,a2
4001d964:	54d71ae3          	bne	a4,a3,4001e6b8 <tcp_in+0x1460>
4001d968:	01297713          	andi	a4,s2,18
4001d96c:	540706e3          	beqz	a4,4001e6b8 <tcp_in+0x1460>
			tcp_send_timer_cancel(conn);
4001d970:	00040513          	mv	a0,s0
4001d974:	99dfd0ef          	jal	ra,4001b310 <tcp_send_timer_cancel>
			conn_ack(conn, th_seq(th) + 1);
4001d978:	005bc683          	lbu	a3,5(s7)
4001d97c:	004bc703          	lbu	a4,4(s7)
4001d980:	007bc783          	lbu	a5,7(s7)
4001d984:	00869693          	slli	a3,a3,0x8
4001d988:	00e6e6b3          	or	a3,a3,a4
4001d98c:	006bc703          	lbu	a4,6(s7)
4001d990:	01879793          	slli	a5,a5,0x18
4001d994:	00010637          	lui	a2,0x10
4001d998:	01071713          	slli	a4,a4,0x10
4001d99c:	00d76733          	or	a4,a4,a3
4001d9a0:	00e7e6b3          	or	a3,a5,a4
4001d9a4:	01871713          	slli	a4,a4,0x18
4001d9a8:	0187d793          	srli	a5,a5,0x18
4001d9ac:	00e7e7b3          	or	a5,a5,a4
4001d9b0:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001d9b4:	0086d713          	srli	a4,a3,0x8
4001d9b8:	00c77733          	and	a4,a4,a2
4001d9bc:	00e7e7b3          	or	a5,a5,a4
4001d9c0:	00869693          	slli	a3,a3,0x8
4001d9c4:	00ff0737          	lui	a4,0xff0
4001d9c8:	00e6f6b3          	and	a3,a3,a4
4001d9cc:	22c42703          	lw	a4,556(s0)
4001d9d0:	00d7e7b3          	or	a5,a5,a3
		if (FL(&fl, &, SYN | ACK, th && th_ack(th) == conn->seq)) {
4001d9d4:	0ed97913          	andi	s2,s2,237
			conn_ack(conn, th_seq(th) + 1);
4001d9d8:	00170713          	addi	a4,a4,1 # ff0001 <__rom_region_size+0xfbf625>
4001d9dc:	00e787b3          	add	a5,a5,a4
4001d9e0:	22f42623          	sw	a5,556(s0)
				verdict = NET_OK;
4001d9e4:	00000993          	li	s3,0
			if (len) {
4001d9e8:	020a0863          	beqz	s4,4001da18 <tcp_in+0x7c0>
				verdict = tcp_data_get(conn, pkt, &len);
4001d9ec:	01810613          	addi	a2,sp,24
4001d9f0:	00048593          	mv	a1,s1
4001d9f4:	00040513          	mv	a0,s0
4001d9f8:	ba0ff0ef          	jal	ra,4001cd98 <tcp_data_get>
4001d9fc:	00050993          	mv	s3,a0
				if (verdict == NET_OK) {
4001da00:	00051463          	bnez	a0,4001da08 <tcp_in+0x7b0>
					pkt = NULL;
4001da04:	00000493          	li	s1,0
				conn_ack(conn, + len);
4001da08:	22c42783          	lw	a5,556(s0)
4001da0c:	01812703          	lw	a4,24(sp)
4001da10:	00e787b3          	add	a5,a5,a4
4001da14:	22f42623          	sw	a5,556(s0)
	int ref_count = atomic_inc(&conn->ref_count) + 1;
4001da18:	21c40513          	addi	a0,s0,540
4001da1c:	bfdfd0ef          	jal	ra,4001b618 <atomic_inc.isra.0>
			net_context_set_state(conn->context,
4001da20:	00442703          	lw	a4,4(s0)
			tcp_out(conn, ACK);
4001da24:	01000593          	li	a1,16
4001da28:	00040513          	mv	a0,s0
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
4001da2c:	07475783          	lhu	a5,116(a4)
4001da30:	ff97f793          	andi	a5,a5,-7
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
4001da34:	0047e793          	ori	a5,a5,4
4001da38:	06f71a23          	sh	a5,116(a4)
4001da3c:	ae1fe0ef          	jal	ra,4001c51c <tcp_out>
	if (pkt) {
4001da40:	00048463          	beqz	s1,4001da48 <tcp_in+0x7f0>
4001da44:	6cd0006f          	j	4001e910 <tcp_in+0x16b8>
		conn_state(conn, next);
4001da48:	00400793          	li	a5,4
4001da4c:	22f42023          	sw	a5,544(s0)
			conn->in_connect = false;
4001da50:	23d44783          	lbu	a5,573(s0)
4001da54:	ffd7f793          	andi	a5,a5,-3
4001da58:	22f40ea3          	sb	a5,573(s0)
			if (conn->connect_cb) {
4001da5c:	02442783          	lw	a5,36(s0)
4001da60:	00078c63          	beqz	a5,4001da78 <tcp_in+0x820>
				conn->connect_cb(conn->context, 0, conn->context->user_data);
4001da64:	00442503          	lw	a0,4(s0)
4001da68:	00000593          	li	a1,0
4001da6c:	00452603          	lw	a2,4(a0)
4001da70:	000780e7          	jalr	a5
				conn->connect_cb = NULL;
4001da74:	02042223          	sw	zero,36(s0)
	z_impl_k_sem_give(sem);
4001da78:	03c40513          	addi	a0,s0,60
4001da7c:	3080b0ef          	jal	ra,40028d84 <z_impl_k_sem_give>
}
4001da80:	00100c13          	li	s8,1
4001da84:	cc1ff06f          	j	4001d744 <tcp_in+0x4ec>
		if (th && FL(&fl, ==, (FIN | ACK), th_seq(th) == conn->ack)) {
4001da88:	420b88e3          	beqz	s7,4001e6b8 <tcp_in+0x1460>
4001da8c:	0ff97b13          	zext.b	s6,s2
4001da90:	260b0e63          	beqz	s6,4001dd0c <tcp_in+0xab4>
4001da94:	4002ddb7          	lui	s11,0x4002d
4001da98:	4c0d8513          	addi	a0,s11,1216 # 4002d4c0 <CSWTCH.15321+0x78>
4001da9c:	c8ceb0ef          	jal	ra,40008f28 <strlen>
4001daa0:	06050263          	beqz	a0,4001db04 <tcp_in+0x8ac>
4001daa4:	005bc703          	lbu	a4,5(s7)
4001daa8:	004bc683          	lbu	a3,4(s7)
4001daac:	000105b7          	lui	a1,0x10
4001dab0:	00871713          	slli	a4,a4,0x8
4001dab4:	00d76733          	or	a4,a4,a3
4001dab8:	006bc683          	lbu	a3,6(s7)
4001dabc:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001dac0:	01069693          	slli	a3,a3,0x10
4001dac4:	00e6e6b3          	or	a3,a3,a4
4001dac8:	007bc703          	lbu	a4,7(s7)
4001dacc:	01871713          	slli	a4,a4,0x18
4001dad0:	00d76633          	or	a2,a4,a3
4001dad4:	01869693          	slli	a3,a3,0x18
4001dad8:	01875713          	srli	a4,a4,0x18
4001dadc:	00d76733          	or	a4,a4,a3
4001dae0:	00865693          	srli	a3,a2,0x8
4001dae4:	00b6f6b3          	and	a3,a3,a1
4001dae8:	00d76733          	or	a4,a4,a3
4001daec:	00861613          	slli	a2,a2,0x8
4001daf0:	00ff06b7          	lui	a3,0xff0
4001daf4:	00d67633          	and	a2,a2,a3
4001daf8:	22c42683          	lw	a3,556(s0)
4001dafc:	00c76733          	or	a4,a4,a2
4001db00:	0ad71263          	bne	a4,a3,4001dba4 <tcp_in+0x94c>
4001db04:	01100713          	li	a4,17
4001db08:	08eb1e63          	bne	s6,a4,4001dba4 <tcp_in+0x94c>
			if (net_tcp_seq_cmp(th_ack(th), conn->seq) > 0) {
4001db0c:	009bc683          	lbu	a3,9(s7)
4001db10:	008bc703          	lbu	a4,8(s7)
4001db14:	00bbc783          	lbu	a5,11(s7)
4001db18:	00869693          	slli	a3,a3,0x8
4001db1c:	00e6e6b3          	or	a3,a3,a4
4001db20:	00abc703          	lbu	a4,10(s7)
4001db24:	01879793          	slli	a5,a5,0x18
4001db28:	00010637          	lui	a2,0x10
4001db2c:	01071713          	slli	a4,a4,0x10
4001db30:	00d76733          	or	a4,a4,a3
4001db34:	00e7e6b3          	or	a3,a5,a4
4001db38:	01871713          	slli	a4,a4,0x18
4001db3c:	0187d793          	srli	a5,a5,0x18
4001db40:	00e7e7b3          	or	a5,a5,a4
4001db44:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001db48:	0086d713          	srli	a4,a3,0x8
4001db4c:	00c77733          	and	a4,a4,a2
4001db50:	00e7e7b3          	or	a5,a5,a4
4001db54:	00869693          	slli	a3,a3,0x8
4001db58:	00ff0737          	lui	a4,0xff0
4001db5c:	00e6f6b3          	and	a3,a3,a4
	return (int32_t)(seq1 - seq2);
4001db60:	22842703          	lw	a4,552(s0)
4001db64:	00d7e7b3          	or	a5,a5,a3
		if (th && FL(&fl, ==, (FIN | ACK), th_seq(th) == conn->ack)) {
4001db68:	00000913          	li	s2,0
4001db6c:	40e78733          	sub	a4,a5,a4
			if (net_tcp_seq_cmp(th_ack(th), conn->seq) > 0) {
4001db70:	00e05463          	blez	a4,4001db78 <tcp_in+0x920>
				conn_seq(conn, + len_acked);
4001db74:	22f42423          	sw	a5,552(s0)
			conn_ack(conn, + 1);
4001db78:	22c42783          	lw	a5,556(s0)
			tcp_out(conn, FIN | ACK);
4001db7c:	01100593          	li	a1,17
4001db80:	00040513          	mv	a0,s0
			conn_ack(conn, + 1);
4001db84:	00178793          	addi	a5,a5,1
4001db88:	22f42623          	sw	a5,556(s0)
			tcp_out(conn, FIN | ACK);
4001db8c:	991fe0ef          	jal	ra,4001c51c <tcp_out>
	if (pkt) {
4001db90:	00048663          	beqz	s1,4001db9c <tcp_in+0x944>
			net_pkt_unref(pkt);
4001db94:	00048513          	mv	a0,s1
4001db98:	b84f50ef          	jal	ra,40012f1c <net_pkt_unref>
			next = TCP_LAST_ACK;
4001db9c:	00900a13          	li	s4,9
4001dba0:	b59ff06f          	j	4001d6f8 <tcp_in+0x4a0>
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
4001dba4:	4c0d8513          	addi	a0,s11,1216
4001dba8:	b80eb0ef          	jal	ra,40008f28 <strlen>
4001dbac:	06050263          	beqz	a0,4001dc10 <tcp_in+0x9b8>
4001dbb0:	005bc703          	lbu	a4,5(s7)
4001dbb4:	004bc683          	lbu	a3,4(s7)
4001dbb8:	000105b7          	lui	a1,0x10
4001dbbc:	00871713          	slli	a4,a4,0x8
4001dbc0:	00d76733          	or	a4,a4,a3
4001dbc4:	006bc683          	lbu	a3,6(s7)
4001dbc8:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001dbcc:	01069693          	slli	a3,a3,0x10
4001dbd0:	00e6e6b3          	or	a3,a3,a4
4001dbd4:	007bc703          	lbu	a4,7(s7)
4001dbd8:	01871713          	slli	a4,a4,0x18
4001dbdc:	00d76633          	or	a2,a4,a3
4001dbe0:	01869693          	slli	a3,a3,0x18
4001dbe4:	01875713          	srli	a4,a4,0x18
4001dbe8:	00d76733          	or	a4,a4,a3
4001dbec:	00865693          	srli	a3,a2,0x8
4001dbf0:	00b6f6b3          	and	a3,a3,a1
4001dbf4:	00d76733          	or	a4,a4,a3
4001dbf8:	00861613          	slli	a2,a2,0x8
4001dbfc:	00ff06b7          	lui	a3,0xff0
4001dc00:	00d67633          	and	a2,a2,a3
4001dc04:	22c42683          	lw	a3,556(s0)
4001dc08:	00c76733          	or	a4,a4,a2
4001dc0c:	02d71e63          	bne	a4,a3,4001dc48 <tcp_in+0x9f0>
4001dc10:	00100713          	li	a4,1
4001dc14:	02eb1a63          	bne	s6,a4,4001dc48 <tcp_in+0x9f0>
			conn_ack(conn, + 1);
4001dc18:	22c42783          	lw	a5,556(s0)
			tcp_out(conn, ACK);
4001dc1c:	01000593          	li	a1,16
4001dc20:	00040513          	mv	a0,s0
			conn_ack(conn, + 1);
4001dc24:	00178793          	addi	a5,a5,1
4001dc28:	22f42623          	sw	a5,556(s0)
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
4001dc2c:	00000913          	li	s2,0
			tcp_out(conn, ACK);
4001dc30:	8edfe0ef          	jal	ra,4001c51c <tcp_out>
	if (pkt) {
4001dc34:	00048663          	beqz	s1,4001dc40 <tcp_in+0x9e8>
			net_pkt_unref(pkt);
4001dc38:	00048513          	mv	a0,s1
4001dc3c:	ae0f50ef          	jal	ra,40012f1c <net_pkt_unref>
			next = TCP_CLOSE_WAIT;
4001dc40:	00700a13          	li	s4,7
4001dc44:	ab5ff06f          	j	4001d6f8 <tcp_in+0x4a0>
		} else if (th && FL(&fl, ==, (FIN | ACK | PSH),
4001dc48:	4c0d8513          	addi	a0,s11,1216
4001dc4c:	adceb0ef          	jal	ra,40008f28 <strlen>
4001dc50:	06050263          	beqz	a0,4001dcb4 <tcp_in+0xa5c>
4001dc54:	005bc703          	lbu	a4,5(s7)
4001dc58:	004bc683          	lbu	a3,4(s7)
4001dc5c:	000105b7          	lui	a1,0x10
4001dc60:	00871713          	slli	a4,a4,0x8
4001dc64:	00d76733          	or	a4,a4,a3
4001dc68:	006bc683          	lbu	a3,6(s7)
4001dc6c:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001dc70:	01069693          	slli	a3,a3,0x10
4001dc74:	00e6e6b3          	or	a3,a3,a4
4001dc78:	007bc703          	lbu	a4,7(s7)
4001dc7c:	01871713          	slli	a4,a4,0x18
4001dc80:	00d76633          	or	a2,a4,a3
4001dc84:	01869693          	slli	a3,a3,0x18
4001dc88:	01875713          	srli	a4,a4,0x18
4001dc8c:	00d76733          	or	a4,a4,a3
4001dc90:	00865693          	srli	a3,a2,0x8
4001dc94:	00b6f6b3          	and	a3,a3,a1
4001dc98:	00d76733          	or	a4,a4,a3
4001dc9c:	00861613          	slli	a2,a2,0x8
4001dca0:	00ff06b7          	lui	a3,0xff0
4001dca4:	00d67633          	and	a2,a2,a3
4001dca8:	22c42683          	lw	a3,556(s0)
4001dcac:	00c76733          	or	a4,a4,a2
4001dcb0:	04d71e63          	bne	a4,a3,4001dd0c <tcp_in+0xab4>
4001dcb4:	01900713          	li	a4,25
4001dcb8:	04eb1a63          	bne	s6,a4,4001dd0c <tcp_in+0xab4>
4001dcbc:	00000913          	li	s2,0
				verdict = NET_OK;
4001dcc0:	00000993          	li	s3,0
			if (len) {
4001dcc4:	020a0063          	beqz	s4,4001dce4 <tcp_in+0xa8c>
				verdict = tcp_data_get(conn, pkt, &len);
4001dcc8:	01810613          	addi	a2,sp,24
4001dccc:	00048593          	mv	a1,s1
4001dcd0:	00040513          	mv	a0,s0
4001dcd4:	8c4ff0ef          	jal	ra,4001cd98 <tcp_data_get>
4001dcd8:	00050993          	mv	s3,a0
				if (verdict == NET_OK) {
4001dcdc:	00051463          	bnez	a0,4001dce4 <tcp_in+0xa8c>
					pkt = NULL;
4001dce0:	00000493          	li	s1,0
			conn_ack(conn, + len + 1);
4001dce4:	01812703          	lw	a4,24(sp)
4001dce8:	22c42783          	lw	a5,556(s0)
			tcp_out(conn, FIN | ACK);
4001dcec:	01100593          	li	a1,17
			conn_ack(conn, + len + 1);
4001dcf0:	00170713          	addi	a4,a4,1 # ff0001 <__rom_region_size+0xfbf625>
4001dcf4:	00e787b3          	add	a5,a5,a4
4001dcf8:	22f42623          	sw	a5,556(s0)
			tcp_out(conn, FIN | ACK);
4001dcfc:	00040513          	mv	a0,s0
4001dd00:	81dfe0ef          	jal	ra,4001c51c <tcp_out>
			next = TCP_LAST_ACK;
4001dd04:	00900a13          	li	s4,9
4001dd08:	a2dff06f          	j	4001d734 <tcp_in+0x4dc>
		if (th && (net_tcp_seq_cmp(th_ack(th), conn->seq) == 0)) {
4001dd0c:	009bc703          	lbu	a4,9(s7)
4001dd10:	008bc683          	lbu	a3,8(s7)
4001dd14:	000105b7          	lui	a1,0x10
4001dd18:	00871713          	slli	a4,a4,0x8
4001dd1c:	00d76733          	or	a4,a4,a3
4001dd20:	00abc683          	lbu	a3,10(s7)
4001dd24:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001dd28:	01069693          	slli	a3,a3,0x10
4001dd2c:	00e6e6b3          	or	a3,a3,a4
4001dd30:	00bbc703          	lbu	a4,11(s7)
4001dd34:	01871713          	slli	a4,a4,0x18
4001dd38:	00d76633          	or	a2,a4,a3
4001dd3c:	01869693          	slli	a3,a3,0x18
4001dd40:	01875713          	srli	a4,a4,0x18
4001dd44:	00d76733          	or	a4,a4,a3
4001dd48:	00865693          	srli	a3,a2,0x8
4001dd4c:	00b6f6b3          	and	a3,a3,a1
4001dd50:	00d76733          	or	a4,a4,a3
4001dd54:	00861613          	slli	a2,a2,0x8
4001dd58:	00ff06b7          	lui	a3,0xff0
4001dd5c:	00d67633          	and	a2,a2,a3
4001dd60:	22842683          	lw	a3,552(s0)
4001dd64:	00c76733          	or	a4,a4,a2
4001dd68:	04d71a63          	bne	a4,a3,4001ddbc <tcp_in+0xb64>
			if (conn->send_data_total > 0) {
4001dd6c:	21042703          	lw	a4,528(s0)
4001dd70:	10070a63          	beqz	a4,4001de84 <tcp_in+0xc2c>
				if (len == 0) {
4001dd74:	020a1063          	bnez	s4,4001dd94 <tcp_in+0xb3c>
					conn->dup_ack_cnt = MIN(conn->dup_ack_cnt + 1,
4001dd78:	23b44683          	lbu	a3,571(s0)
4001dd7c:	00300613          	li	a2,3
4001dd80:	00068713          	mv	a4,a3
4001dd84:	00d67463          	bgeu	a2,a3,4001dd8c <tcp_in+0xb34>
4001dd88:	00300713          	li	a4,3
4001dd8c:	00170713          	addi	a4,a4,1
4001dd90:	22e40da3          	sb	a4,571(s0)
			if ((conn->data_mode == TCP_DATA_MODE_SEND) &&
4001dd94:	22442703          	lw	a4,548(s0)
4001dd98:	02071263          	bnez	a4,4001ddbc <tcp_in+0xb64>
4001dd9c:	23b44683          	lbu	a3,571(s0)
4001dda0:	00300713          	li	a4,3
4001dda4:	00e69c63          	bne	a3,a4,4001ddbc <tcp_in+0xb64>
				int temp_unacked_len = conn->unacked_len;
4001dda8:	21842d83          	lw	s11,536(s0)
				(void)tcp_send_data(conn);
4001ddac:	00040513          	mv	a0,s0
				conn->unacked_len = 0;
4001ddb0:	20042c23          	sw	zero,536(s0)
				(void)tcp_send_data(conn);
4001ddb4:	9f5fe0ef          	jal	ra,4001c7a8 <tcp_send_data>
				conn->unacked_len = temp_unacked_len;
4001ddb8:	21b42c23          	sw	s11,536(s0)
		if (th && (net_tcp_seq_cmp(th_ack(th), conn->seq) > 0)) {
4001ddbc:	009bc683          	lbu	a3,9(s7)
4001ddc0:	008bc703          	lbu	a4,8(s7)
4001ddc4:	00bbcd83          	lbu	s11,11(s7)
4001ddc8:	00869693          	slli	a3,a3,0x8
4001ddcc:	00e6e6b3          	or	a3,a3,a4
4001ddd0:	00abc703          	lbu	a4,10(s7)
4001ddd4:	018d9d93          	slli	s11,s11,0x18
4001ddd8:	00010637          	lui	a2,0x10
4001dddc:	01071713          	slli	a4,a4,0x10
4001dde0:	00d76733          	or	a4,a4,a3
4001dde4:	00ede6b3          	or	a3,s11,a4
4001dde8:	01871713          	slli	a4,a4,0x18
4001ddec:	018ddd93          	srli	s11,s11,0x18
4001ddf0:	00ededb3          	or	s11,s11,a4
4001ddf4:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001ddf8:	0086d713          	srli	a4,a3,0x8
4001ddfc:	00c77733          	and	a4,a4,a2
4001de00:	00ededb3          	or	s11,s11,a4
4001de04:	00869693          	slli	a3,a3,0x8
4001de08:	00ff0737          	lui	a4,0xff0
4001de0c:	00e6f6b3          	and	a3,a3,a4
4001de10:	22842703          	lw	a4,552(s0)
4001de14:	00ddedb3          	or	s11,s11,a3
4001de18:	40ed8d33          	sub	s10,s11,a4
4001de1c:	1ba05a63          	blez	s10,4001dfd0 <tcp_in+0xd78>
			if ((conn->send_data_total < len_acked) ||
4001de20:	21042683          	lw	a3,528(s0)
4001de24:	07a6f463          	bgeu	a3,s10,4001de8c <tcp_in+0xc34>
				tcp_out(conn, RST);
4001de28:	00400593          	li	a1,4
4001de2c:	00040513          	mv	a0,s0
4001de30:	eecfe0ef          	jal	ra,4001c51c <tcp_out>
				conn_state(conn, TCP_CLOSED);
4001de34:	00b00793          	li	a5,11
4001de38:	22f42023          	sw	a5,544(s0)
	if (pkt) {
4001de3c:	00000913          	li	s2,0
				close_status = -ECONNRESET;
4001de40:	f9800a93          	li	s5,-104
	if (pkt) {
4001de44:	240496e3          	bnez	s1,4001e890 <tcp_in+0x1638>
	if (conn->context) {
4001de48:	00442a03          	lw	s4,4(s0)
4001de4c:	000a0463          	beqz	s4,4001de54 <tcp_in+0xbfc>
		conn_handler = (struct net_conn *)conn->context->conn_handler;
4001de50:	044a2a03          	lw	s4,68(s4)
	k_mutex_unlock(&conn->lock);
4001de54:	00812503          	lw	a0,8(sp)
	recv_user_data = conn->recv_user_data;
4001de58:	01442c03          	lw	s8,20(s0)
	while (conn_handler && atomic_get(&conn->ref_count) > 0 &&
4001de5c:	21c40b93          	addi	s7,s0,540
	k_mutex_unlock(&conn->lock);
4001de60:	cacfd0ef          	jal	ra,4001b30c <k_mutex_unlock.isra.0>
	       (recv_pkt = k_fifo_get(recv_data_fifo, K_NO_WAIT)) != NULL) {
4001de64:	06c40b13          	addi	s6,s0,108
		if (net_context_packet_received(conn_handler, recv_pkt, NULL,
4001de68:	00200c93          	li	s9,2
	while (conn_handler && atomic_get(&conn->ref_count) > 0 &&
4001de6c:	240a1ce3          	bnez	s4,4001e8c4 <tcp_in+0x166c>
	if (do_close) {
4001de70:	e0090e63          	beqz	s2,4001d48c <tcp_in+0x234>
		tcp_conn_close(conn, close_status);
4001de74:	000a8593          	mv	a1,s5
4001de78:	00040513          	mv	a0,s0
4001de7c:	9edfd0ef          	jal	ra,4001b868 <tcp_conn_close.isra.0>
4001de80:	e0cff06f          	j	4001d48c <tcp_in+0x234>
				conn->dup_ack_cnt = 0;
4001de84:	22040da3          	sb	zero,571(s0)
4001de88:	f0dff06f          	j	4001dd94 <tcp_in+0xb3c>
					(tcp_pkt_pull(conn->send_data,
4001de8c:	00842503          	lw	a0,8(s0)
4001de90:	000d0593          	mv	a1,s10
4001de94:	00e12623          	sw	a4,12(sp)
4001de98:	8a4fd0ef          	jal	ra,4001af3c <tcp_pkt_pull>
			if ((conn->send_data_total < len_acked) ||
4001de9c:	f80546e3          	bltz	a0,4001de28 <tcp_in+0xbd0>
			conn->dup_ack_cnt = 0;
4001dea0:	00c12703          	lw	a4,12(sp)
			conn->send_data_total -= len_acked;
4001dea4:	21042683          	lw	a3,528(s0)
			if (conn->unacked_len < len_acked) {
4001dea8:	21842503          	lw	a0,536(s0)
4001deac:	41b70733          	sub	a4,a4,s11
			conn->send_data_total -= len_acked;
4001deb0:	00d706b3          	add	a3,a4,a3
			conn->dup_ack_cnt = 0;
4001deb4:	22040da3          	sb	zero,571(s0)
			conn->send_data_total -= len_acked;
4001deb8:	20d42823          	sw	a3,528(s0)
				conn->unacked_len = 0;
4001debc:	00000613          	li	a2,0
			if (conn->unacked_len < len_acked) {
4001dec0:	01a56463          	bltu	a0,s10,4001dec8 <tcp_in+0xc70>
				conn->unacked_len -= len_acked;
4001dec4:	00e50633          	add	a2,a0,a4
	bool window_full = (conn->send_data_total >= conn->send_win);
4001dec8:	23645703          	lhu	a4,566(s0)
4001decc:	20c42c23          	sw	a2,536(s0)
			if (!tcp_window_full(conn)) {
4001ded0:	00e6f663          	bgeu	a3,a4,4001dedc <tcp_in+0xc84>
	z_impl_k_sem_give(sem);
4001ded4:	05440513          	addi	a0,s0,84
4001ded8:	6ad0a0ef          	jal	ra,40028d84 <z_impl_k_sem_give>
			conn_seq(conn, + len_acked);
4001dedc:	22842703          	lw	a4,552(s0)
	return z_timeout_remaining(&dwork->timeout);
4001dee0:	10040513          	addi	a0,s0,256
4001dee4:	0f040d93          	addi	s11,s0,240
4001dee8:	01a70733          	add	a4,a4,s10
4001deec:	22e42423          	sw	a4,552(s0)
4001def0:	2f90c0ef          	jal	ra,4002a9e8 <z_timeout_remaining>
			if (!k_work_delayable_remaining_get(
4001def4:	00b56533          	or	a0,a0,a1
4001def8:	7c050063          	beqz	a0,4001e6b8 <tcp_in+0x1460>
			conn->send_data_retries = 0;
4001defc:	22040d23          	sb	zero,570(s0)
			k_work_cancel_delayable(&conn->send_data_timer);
4001df00:	000d8513          	mv	a0,s11
4001df04:	7380b0ef          	jal	ra,4002963c <k_work_cancel_delayable>
			if (conn->data_mode == TCP_DATA_MODE_RESEND) {
4001df08:	22442683          	lw	a3,548(s0)
4001df0c:	00100713          	li	a4,1
4001df10:	00e69863          	bne	a3,a4,4001df20 <tcp_in+0xcc8>
				conn->unacked_len = 0;
4001df14:	20042c23          	sw	zero,536(s0)
				tcp_derive_rto(conn);
4001df18:	00040513          	mv	a0,s0
4001df1c:	dcdfc0ef          	jal	ra,4001ace8 <tcp_derive_rto>
			if (conn->in_close && conn->send_data_total == 0) {
4001df20:	23d44703          	lbu	a4,573(s0)
			conn->data_mode = TCP_DATA_MODE_SEND;
4001df24:	22042223          	sw	zero,548(s0)
				tcp_send_timer_cancel(conn);
4001df28:	00040513          	mv	a0,s0
			if (conn->in_close && conn->send_data_total == 0) {
4001df2c:	00477713          	andi	a4,a4,4
4001df30:	02070e63          	beqz	a4,4001df6c <tcp_in+0xd14>
4001df34:	21042983          	lw	s3,528(s0)
4001df38:	02099a63          	bnez	s3,4001df6c <tcp_in+0xd14>
				tcp_send_timer_cancel(conn);
4001df3c:	bd4fd0ef          	jal	ra,4001b310 <tcp_send_timer_cancel>
				tcp_out(conn, FIN | ACK);
4001df40:	01100593          	li	a1,17
4001df44:	00040513          	mv	a0,s0
4001df48:	dd4fe0ef          	jal	ra,4001c51c <tcp_out>
				conn_seq(conn, + 1);
4001df4c:	22842783          	lw	a5,552(s0)
				next = TCP_FIN_WAIT_1;
4001df50:	00500a13          	li	s4,5
				conn_seq(conn, + 1);
4001df54:	00178793          	addi	a5,a5,1
4001df58:	22f42423          	sw	a5,552(s0)
	if (pkt) {
4001df5c:	fe048063          	beqz	s1,4001d73c <tcp_in+0x4e4>
			net_pkt_unref(pkt);
4001df60:	00048513          	mv	a0,s1
4001df64:	fb9f40ef          	jal	ra,40012f1c <net_pkt_unref>
	if (next) {
4001df68:	fd4ff06f          	j	4001d73c <tcp_in+0x4e4>
	if (conn->data_mode == TCP_DATA_MODE_RESEND) {
4001df6c:	81cff0ef          	jal	ra,4001cf88 <tcp_send_queued_data.part.0>
4001df70:	00050913          	mv	s2,a0
			if (ret < 0 && ret != -ENOBUFS) {
4001df74:	04055063          	bgez	a0,4001dfb4 <tcp_in+0xd5c>
4001df78:	f9700713          	li	a4,-105
4001df7c:	02e50c63          	beq	a0,a4,4001dfb4 <tcp_in+0xd5c>
				tcp_out(conn, RST);
4001df80:	00400593          	li	a1,4
4001df84:	00040513          	mv	a0,s0
4001df88:	d94fe0ef          	jal	ra,4001c51c <tcp_out>
				conn_state(conn, TCP_CLOSED);
4001df8c:	00b00793          	li	a5,11
4001df90:	22f42023          	sw	a5,544(s0)
	if (pkt) {
4001df94:	00049a63          	bnez	s1,4001dfa8 <tcp_in+0xd50>
4001df98:	00090a93          	mv	s5,s2
4001df9c:	00000913          	li	s2,0
				verdict = NET_OK;
4001dfa0:	00000993          	li	s3,0
4001dfa4:	ea5ff06f          	j	4001de48 <tcp_in+0xbf0>
			net_pkt_unref(pkt);
4001dfa8:	00048513          	mv	a0,s1
4001dfac:	f71f40ef          	jal	ra,40012f1c <net_pkt_unref>
	if (next) {
4001dfb0:	fe9ff06f          	j	4001df98 <tcp_in+0xd40>
	bool window_full = (conn->send_data_total >= conn->send_win);
4001dfb4:	23645683          	lhu	a3,566(s0)
			if (tcp_window_full(conn)) {
4001dfb8:	21042703          	lw	a4,528(s0)
4001dfbc:	00d76a63          	bltu	a4,a3,4001dfd0 <tcp_in+0xd78>
	return z_impl_k_sem_take(sem, timeout);
4001dfc0:	00000593          	li	a1,0
4001dfc4:	00000613          	li	a2,0
4001dfc8:	05440513          	addi	a0,s0,84
4001dfcc:	6290a0ef          	jal	ra,40028df4 <z_impl_k_sem_take>
			if (th_seq(th) == conn->ack) {
4001dfd0:	005bc683          	lbu	a3,5(s7)
4001dfd4:	004bc703          	lbu	a4,4(s7)
4001dfd8:	007bc903          	lbu	s2,7(s7)
4001dfdc:	00869693          	slli	a3,a3,0x8
4001dfe0:	00e6e6b3          	or	a3,a3,a4
4001dfe4:	006bc703          	lbu	a4,6(s7)
4001dfe8:	01891913          	slli	s2,s2,0x18
4001dfec:	01071713          	slli	a4,a4,0x10
4001dff0:	00d76733          	or	a4,a4,a3
4001dff4:	00e967b3          	or	a5,s2,a4
4001dff8:	000106b7          	lui	a3,0x10
4001dffc:	01871713          	slli	a4,a4,0x18
4001e000:	01895913          	srli	s2,s2,0x18
4001e004:	00e96933          	or	s2,s2,a4
4001e008:	f0068693          	addi	a3,a3,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001e00c:	0087d713          	srli	a4,a5,0x8
4001e010:	00d77733          	and	a4,a4,a3
4001e014:	00e96933          	or	s2,s2,a4
4001e018:	00879793          	slli	a5,a5,0x8
4001e01c:	00ff0737          	lui	a4,0xff0
4001e020:	00e7f7b3          	and	a5,a5,a4
4001e024:	00f96933          	or	s2,s2,a5
4001e028:	22c42783          	lw	a5,556(s0)
4001e02c:	06f91e63          	bne	s2,a5,4001e0a8 <tcp_in+0xe50>
				if (len > 0) {
4001e030:	080a0663          	beqz	s4,4001e0bc <tcp_in+0xe64>
	if (*len == 0) {
4001e034:	01812783          	lw	a5,24(sp)
4001e038:	080782e3          	beqz	a5,4001e8bc <tcp_in+0x1664>
	ret = tcp_data_get(conn, pkt, len);
4001e03c:	00048593          	mv	a1,s1
4001e040:	01810613          	addi	a2,sp,24
4001e044:	00040513          	mv	a0,s0
4001e048:	d51fe0ef          	jal	ra,4001cd98 <tcp_data_get>
	conn_ack(conn, *len);
4001e04c:	22c42783          	lw	a5,556(s0)
4001e050:	01812703          	lw	a4,24(sp)
	ret = tcp_data_get(conn, pkt, len);
4001e054:	00050993          	mv	s3,a0
	if (tcp_short_window(conn)) {
4001e058:	00040513          	mv	a0,s0
	conn_ack(conn, *len);
4001e05c:	00e787b3          	add	a5,a5,a4
4001e060:	22f42623          	sw	a5,556(s0)
	if (tcp_short_window(conn)) {
4001e064:	b71fe0ef          	jal	ra,4001cbd4 <tcp_short_window>
		k_work_schedule_for_queue(&tcp_work_q, &conn->ack_timer,
4001e068:	18040593          	addi	a1,s0,384
	if (tcp_short_window(conn)) {
4001e06c:	02050263          	beqz	a0,4001e090 <tcp_in+0xe38>
		k_work_schedule_for_queue(&tcp_work_q, &conn->ack_timer,
4001e070:	40031537          	lui	a0,0x40031
4001e074:	00a00613          	li	a2,10
4001e078:	00000693          	li	a3,0
4001e07c:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
4001e080:	49c0b0ef          	jal	ra,4002951c <k_work_schedule_for_queue>
					if (verdict == NET_OK) {
4001e084:	f0098ce3          	beqz	s3,4001df9c <tcp_in+0xd44>
		break;
4001e088:	00000913          	li	s2,0
4001e08c:	dbdff06f          	j	4001de48 <tcp_in+0xbf0>
		k_work_cancel_delayable(&conn->ack_timer);
4001e090:	00058513          	mv	a0,a1
4001e094:	5a80b0ef          	jal	ra,4002963c <k_work_cancel_delayable>
		tcp_out(conn, ACK);
4001e098:	01000593          	li	a1,16
4001e09c:	00040513          	mv	a0,s0
4001e0a0:	c7cfe0ef          	jal	ra,4001c51c <tcp_out>
4001e0a4:	fe1ff06f          	j	4001e084 <tcp_in+0xe2c>
4001e0a8:	412787b3          	sub	a5,a5,s2
			} else if (net_tcp_seq_greater(conn->ack, th_seq(th))) {
4001e0ac:	00f05c63          	blez	a5,4001e0c4 <tcp_in+0xe6c>
					tcp_out(conn, ACK);
4001e0b0:	01000593          	li	a1,16
4001e0b4:	00040513          	mv	a0,s0
4001e0b8:	c64fe0ef          	jal	ra,4001c51c <tcp_out>
	if (pkt) {
4001e0bc:	02049863          	bnez	s1,4001e0ec <tcp_in+0xe94>
4001e0c0:	eddff06f          	j	4001df9c <tcp_in+0xd44>
	if (data_len == 0) {
4001e0c4:	1a0a0263          	beqz	s4,4001e268 <tcp_in+0x1010>
	headers_len = net_pkt_get_len(pkt) - data_len;
4001e0c8:	0084a503          	lw	a0,8(s1)
4001e0cc:	e51fc0ef          	jal	ra,4001af1c <net_pkt_get_len.isra.0>
	if (tcp_pkt_pull(pkt, headers_len) < 0) {
4001e0d0:	414505b3          	sub	a1,a0,s4
4001e0d4:	00048513          	mv	a0,s1
4001e0d8:	e65fc0ef          	jal	ra,4001af3c <tcp_pkt_pull>
4001e0dc:	00055e63          	bgez	a0,4001e0f8 <tcp_in+0xea0>
					tcp_out(conn, ACK);
4001e0e0:	01000593          	li	a1,16
4001e0e4:	00040513          	mv	a0,s0
4001e0e8:	c34fe0ef          	jal	ra,4001c51c <tcp_out>
			net_pkt_unref(pkt);
4001e0ec:	00048513          	mv	a0,s1
4001e0f0:	e2df40ef          	jal	ra,40012f1c <net_pkt_unref>
	if (next) {
4001e0f4:	ea9ff06f          	j	4001df9c <tcp_in+0xd44>
	tmp = pkt->buffer;
4001e0f8:	0084a783          	lw	a5,8(s1)
	seq += tmp->len;
4001e0fc:	0107d583          	lhu	a1,16(a5)
	tmp = tmp->frags;
4001e100:	0047a983          	lw	s3,4(a5)
	*(uint32_t *)net_buf_user_data(buf) = seq;
4001e104:	0127ac23          	sw	s2,24(a5)
	seq += tmp->len;
4001e108:	012585b3          	add	a1,a1,s2
	while (tmp) {
4001e10c:	06099663          	bnez	s3,4001e178 <tcp_in+0xf20>
	if (!net_pkt_is_empty(conn->queue_recv_data)) {
4001e110:	00c42503          	lw	a0,12(s0)
4001e114:	00852b03          	lw	s6,8(a0)
	return !pkt->buffer || !net_pkt_data(pkt) || pkt->buffer->len == 0;
4001e118:	060b0a63          	beqz	s6,4001e18c <tcp_in+0xf34>
4001e11c:	00cb2783          	lw	a5,12(s6)
4001e120:	06078663          	beqz	a5,4001e18c <tcp_in+0xf34>
4001e124:	010b5783          	lhu	a5,16(s6)
4001e128:	06078263          	beqz	a5,4001e18c <tcp_in+0xf34>
		end_offset = seq - pending_seq;
4001e12c:	018b2783          	lw	a5,24(s6)
		pending_len = net_pkt_get_len(conn->queue_recv_data);
4001e130:	000b0513          	mv	a0,s6
		end_offset = seq - pending_seq;
4001e134:	40f585b3          	sub	a1,a1,a5
4001e138:	00b12623          	sw	a1,12(sp)
		pending_len = net_pkt_get_len(conn->queue_recv_data);
4001e13c:	de1fc0ef          	jal	ra,4001af1c <net_pkt_get_len.isra.0>
		if (end_offset < pending_len) {
4001e140:	00c12583          	lw	a1,12(sp)
4001e144:	08a5e263          	bltu	a1,a0,4001e1c8 <tcp_in+0xf70>
			last = net_buf_frag_last(conn->queue_recv_data->buffer);
4001e148:	000b0513          	mv	a0,s6
4001e14c:	895eb0ef          	jal	ra,400099e0 <net_buf_frag_last>
			start_offset = pending_seq - seq_start;
4001e150:	01852783          	lw	a5,24(a0)
			end_offset = (pending_seq + last->len) - seq_start;
4001e154:	01055583          	lhu	a1,16(a0)
			start_offset = pending_seq - seq_start;
4001e158:	412787b3          	sub	a5,a5,s2
			end_offset = (pending_seq + last->len) - seq_start;
4001e15c:	00f585b3          	add	a1,a1,a5
			if ((start_offset < len) && (end_offset <= len)) {
4001e160:	0d47f063          	bgeu	a5,s4,4001e220 <tcp_in+0xfc8>
4001e164:	f6ba6ee3          	bltu	s4,a1,4001e0e0 <tcp_in+0xe88>
				net_buf_unref(conn->queue_recv_data->buffer);
4001e168:	00c42783          	lw	a5,12(s0)
4001e16c:	0087a503          	lw	a0,8(a5)
4001e170:	fa0eb0ef          	jal	ra,40009910 <net_buf_unref>
4001e174:	0740006f          	j	4001e1e8 <tcp_in+0xf90>
		seq += tmp->len;
4001e178:	0109d783          	lhu	a5,16(s3)
	*(uint32_t *)net_buf_user_data(buf) = seq;
4001e17c:	00b9ac23          	sw	a1,24(s3)
		tmp = tmp->frags;
4001e180:	0049a983          	lw	s3,4(s3)
		seq += tmp->len;
4001e184:	00f585b3          	add	a1,a1,a5
		tmp = tmp->frags;
4001e188:	f85ff06f          	j	4001e10c <tcp_in+0xeb4>
		net_pkt_append_buffer(conn->queue_recv_data, pkt->buffer);
4001e18c:	0084a583          	lw	a1,8(s1)
4001e190:	9a4f50ef          	jal	ra,40013334 <net_pkt_append_buffer>
		if (!k_work_delayable_is_pending(&conn->recv_queue_timer)) {
4001e194:	0c040593          	addi	a1,s0,192
	return k_work_delayable_busy_get(dwork) != 0;
4001e198:	00058513          	mv	a0,a1
		pkt->buffer = NULL;
4001e19c:	0004a423          	sw	zero,8(s1)
4001e1a0:	00b12623          	sw	a1,12(sp)
4001e1a4:	3740b0ef          	jal	ra,40029518 <k_work_delayable_busy_get>
		if (!k_work_delayable_is_pending(&conn->recv_queue_timer)) {
4001e1a8:	00c12583          	lw	a1,12(sp)
4001e1ac:	f2051ae3          	bnez	a0,4001e0e0 <tcp_in+0xe88>
			k_work_reschedule_for_queue(
4001e1b0:	40031537          	lui	a0,0x40031
4001e1b4:	0c800613          	li	a2,200
4001e1b8:	00000693          	li	a3,0
4001e1bc:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
4001e1c0:	3d40b0ef          	jal	ra,40029594 <k_work_reschedule_for_queue>
4001e1c4:	f1dff06f          	j	4001e0e0 <tcp_in+0xe88>
			if (end_offset < len) {
4001e1c8:	f145fce3          	bgeu	a1,s4,4001e0e0 <tcp_in+0xe88>
				if (end_offset) {
4001e1cc:	00058663          	beqz	a1,4001e1d8 <tcp_in+0xf80>
					net_pkt_remove_tail(pkt, end_offset);
4001e1d0:	00048513          	mv	a0,s1
4001e1d4:	fadf40ef          	jal	ra,40013180 <net_pkt_remove_tail>
				net_buf_frag_add(pkt->buffer,
4001e1d8:	00c42783          	lw	a5,12(s0)
4001e1dc:	0084a503          	lw	a0,8(s1)
4001e1e0:	0087a583          	lw	a1,8(a5)
4001e1e4:	835eb0ef          	jal	ra,40009a18 <net_buf_frag_add>
				conn->queue_recv_data->buffer = pkt->buffer;
4001e1e8:	00c42783          	lw	a5,12(s0)
4001e1ec:	0084a703          	lw	a4,8(s1)
4001e1f0:	00e7a423          	sw	a4,8(a5)
			if (check_seq_list(conn->queue_recv_data->buffer) == false) {
4001e1f4:	00c42783          	lw	a5,12(s0)
	bool result = true;
4001e1f8:	00100693          	li	a3,1
	uint32_t next_seq = 0;
4001e1fc:	00000713          	li	a4,0
			if (check_seq_list(conn->queue_recv_data->buffer) == false) {
4001e200:	0087a503          	lw	a0,8(a5)
	struct net_buf *tmp = buf;
4001e204:	00050793          	mv	a5,a0
	while (tmp) {
4001e208:	02079e63          	bnez	a5,4001e244 <tcp_in+0xfec>
			if (check_seq_list(conn->queue_recv_data->buffer) == false) {
4001e20c:	f80694e3          	bnez	a3,4001e194 <tcp_in+0xf3c>
				net_buf_unref(conn->queue_recv_data->buffer);
4001e210:	f00eb0ef          	jal	ra,40009910 <net_buf_unref>
				conn->queue_recv_data->buffer = NULL;
4001e214:	00c42783          	lw	a5,12(s0)
4001e218:	0007a423          	sw	zero,8(a5)
4001e21c:	f79ff06f          	j	4001e194 <tcp_in+0xf3c>
				if (end_offset < len) {
4001e220:	ed45f0e3          	bgeu	a1,s4,4001e0e0 <tcp_in+0xe88>
					if (end_offset) {
4001e224:	00058663          	beqz	a1,4001e230 <tcp_in+0xfd8>
						net_pkt_remove_tail(conn->queue_recv_data,
4001e228:	00c42503          	lw	a0,12(s0)
4001e22c:	f55f40ef          	jal	ra,40013180 <net_pkt_remove_tail>
					net_buf_frag_add(conn->queue_recv_data->buffer,
4001e230:	00c42783          	lw	a5,12(s0)
4001e234:	0084a583          	lw	a1,8(s1)
4001e238:	0087a503          	lw	a0,8(a5)
4001e23c:	fdceb0ef          	jal	ra,40009a18 <net_buf_frag_add>
		if (inserted) {
4001e240:	fb5ff06f          	j	4001e1f4 <tcp_in+0xf9c>
	return *(uint32_t *)net_buf_user_data(buf);
4001e244:	0187a603          	lw	a2,24(a5)
		if (last != NULL) {
4001e248:	00098663          	beqz	s3,4001e254 <tcp_in+0xffc>
			if (next_seq != seq) {
4001e24c:	00e60463          	beq	a2,a4,4001e254 <tcp_in+0xffc>
				result = false;
4001e250:	00000693          	li	a3,0
		next_seq = seq + tmp->len;
4001e254:	0107d703          	lhu	a4,16(a5)
		tmp = tmp->frags;
4001e258:	00078993          	mv	s3,a5
4001e25c:	0047a783          	lw	a5,4(a5)
		next_seq = seq + tmp->len;
4001e260:	00c70733          	add	a4,a4,a2
		tmp = tmp->frags;
4001e264:	fa5ff06f          	j	4001e208 <tcp_in+0xfb0>
				if ((len > 0) || FL(&fl, &, FIN)) {
4001e268:	e40b0ae3          	beqz	s6,4001e0bc <tcp_in+0xe64>
4001e26c:	4002c537          	lui	a0,0x4002c
4001e270:	ed850513          	addi	a0,a0,-296 # 4002bed8 <__clz_tab+0x2ac>
4001e274:	001b7b13          	andi	s6,s6,1
4001e278:	cb1ea0ef          	jal	ra,40008f28 <strlen>
4001e27c:	e20b1ae3          	bnez	s6,4001e0b0 <tcp_in+0xe58>
4001e280:	e3dff06f          	j	4001e0bc <tcp_in+0xe64>
		tcp_out(conn, FIN);
4001e284:	00100593          	li	a1,1
4001e288:	a75ff06f          	j	4001dcfc <tcp_in+0xaa4>
		if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
4001e28c:	420b8663          	beqz	s7,4001e6b8 <tcp_in+0x1460>
4001e290:	0ff97913          	zext.b	s2,s2
4001e294:	42090263          	beqz	s2,4001e6b8 <tcp_in+0x1460>
4001e298:	4002d537          	lui	a0,0x4002d
4001e29c:	4c050513          	addi	a0,a0,1216 # 4002d4c0 <CSWTCH.15321+0x78>
4001e2a0:	c89ea0ef          	jal	ra,40008f28 <strlen>
4001e2a4:	06050263          	beqz	a0,4001e308 <tcp_in+0x10b0>
4001e2a8:	005bc683          	lbu	a3,5(s7)
4001e2ac:	004bc703          	lbu	a4,4(s7)
4001e2b0:	007bc783          	lbu	a5,7(s7)
4001e2b4:	00869693          	slli	a3,a3,0x8
4001e2b8:	00e6e6b3          	or	a3,a3,a4
4001e2bc:	006bc703          	lbu	a4,6(s7)
4001e2c0:	01879793          	slli	a5,a5,0x18
4001e2c4:	00010637          	lui	a2,0x10
4001e2c8:	01071713          	slli	a4,a4,0x10
4001e2cc:	00d76733          	or	a4,a4,a3
4001e2d0:	00e7e6b3          	or	a3,a5,a4
4001e2d4:	01871713          	slli	a4,a4,0x18
4001e2d8:	0187d793          	srli	a5,a5,0x18
4001e2dc:	00e7e7b3          	or	a5,a5,a4
4001e2e0:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001e2e4:	0086d713          	srli	a4,a3,0x8
4001e2e8:	00c77733          	and	a4,a4,a2
4001e2ec:	00e7e7b3          	or	a5,a5,a4
4001e2f0:	00869693          	slli	a3,a3,0x8
4001e2f4:	00ff0737          	lui	a4,0xff0
4001e2f8:	00e6f6b3          	and	a3,a3,a4
4001e2fc:	22c42703          	lw	a4,556(s0)
4001e300:	00d7e7b3          	or	a5,a5,a3
4001e304:	3ae79a63          	bne	a5,a4,4001e6b8 <tcp_in+0x1460>
4001e308:	01000793          	li	a5,16
4001e30c:	3af91663          	bne	s2,a5,4001e6b8 <tcp_in+0x1460>
			tcp_send_timer_cancel(conn);
4001e310:	00040513          	mv	a0,s0
		if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
4001e314:	00000913          	li	s2,0
			tcp_send_timer_cancel(conn);
4001e318:	ff9fc0ef          	jal	ra,4001b310 <tcp_send_timer_cancel>
	if (pkt) {
4001e31c:	00048663          	beqz	s1,4001e328 <tcp_in+0x10d0>
			net_pkt_unref(pkt);
4001e320:	00048513          	mv	a0,s1
4001e324:	bf9f40ef          	jal	ra,40012f1c <net_pkt_unref>
			next = TCP_CLOSED;
4001e328:	00b00a13          	li	s4,11
			close_status = 0;
4001e32c:	00000a93          	li	s5,0
4001e330:	bc8ff06f          	j	4001d6f8 <tcp_in+0x4a0>
		conn_ack(conn, + len);
4001e334:	22c42703          	lw	a4,556(s0)
4001e338:	01470733          	add	a4,a4,s4
4001e33c:	22e42623          	sw	a4,556(s0)
		if (th && FL(&fl, ==, (FIN | ACK), th_seq(th) == conn->ack)) {
4001e340:	360b8c63          	beqz	s7,4001e6b8 <tcp_in+0x1460>
4001e344:	0ff97913          	zext.b	s2,s2
4001e348:	36090863          	beqz	s2,4001e6b8 <tcp_in+0x1460>
4001e34c:	4002da37          	lui	s4,0x4002d
4001e350:	4c0a0513          	addi	a0,s4,1216 # 4002d4c0 <CSWTCH.15321+0x78>
4001e354:	bd5ea0ef          	jal	ra,40008f28 <strlen>
4001e358:	06050263          	beqz	a0,4001e3bc <tcp_in+0x1164>
4001e35c:	005bc703          	lbu	a4,5(s7)
4001e360:	004bc683          	lbu	a3,4(s7)
4001e364:	000105b7          	lui	a1,0x10
4001e368:	00871713          	slli	a4,a4,0x8
4001e36c:	00d76733          	or	a4,a4,a3
4001e370:	006bc683          	lbu	a3,6(s7)
4001e374:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001e378:	01069693          	slli	a3,a3,0x10
4001e37c:	00e6e6b3          	or	a3,a3,a4
4001e380:	007bc703          	lbu	a4,7(s7)
4001e384:	01871713          	slli	a4,a4,0x18
4001e388:	00d76633          	or	a2,a4,a3
4001e38c:	01869693          	slli	a3,a3,0x18
4001e390:	01875713          	srli	a4,a4,0x18
4001e394:	00d76733          	or	a4,a4,a3
4001e398:	00865693          	srli	a3,a2,0x8
4001e39c:	00b6f6b3          	and	a3,a3,a1
4001e3a0:	00d76733          	or	a4,a4,a3
4001e3a4:	00861613          	slli	a2,a2,0x8
4001e3a8:	00ff06b7          	lui	a3,0xff0
4001e3ac:	00d67633          	and	a2,a2,a3
4001e3b0:	22c42683          	lw	a3,556(s0)
4001e3b4:	00c76733          	or	a4,a4,a2
4001e3b8:	04d71263          	bne	a4,a3,4001e3fc <tcp_in+0x11a4>
4001e3bc:	01100713          	li	a4,17
4001e3c0:	02e91e63          	bne	s2,a4,4001e3fc <tcp_in+0x11a4>
			tcp_send_timer_cancel(conn);
4001e3c4:	00040513          	mv	a0,s0
		if (th && FL(&fl, ==, (FIN | ACK), th_seq(th) == conn->ack)) {
4001e3c8:	00000913          	li	s2,0
			tcp_send_timer_cancel(conn);
4001e3cc:	f45fc0ef          	jal	ra,4001b310 <tcp_send_timer_cancel>
			conn_ack(conn, + 1);
4001e3d0:	22c42783          	lw	a5,556(s0)
			tcp_out(conn, ACK);
4001e3d4:	01000593          	li	a1,16
4001e3d8:	00040513          	mv	a0,s0
			conn_ack(conn, + 1);
4001e3dc:	00178793          	addi	a5,a5,1
4001e3e0:	22f42623          	sw	a5,556(s0)
			tcp_out(conn, ACK);
4001e3e4:	938fe0ef          	jal	ra,4001c51c <tcp_out>
	if (pkt) {
4001e3e8:	00048663          	beqz	s1,4001e3f4 <tcp_in+0x119c>
			net_pkt_unref(pkt);
4001e3ec:	00048513          	mv	a0,s1
4001e3f0:	b2df40ef          	jal	ra,40012f1c <net_pkt_unref>
			next = TCP_TIME_WAIT;
4001e3f4:	00a00a13          	li	s4,10
4001e3f8:	b00ff06f          	j	4001d6f8 <tcp_in+0x4a0>
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
4001e3fc:	4c0a0513          	addi	a0,s4,1216
4001e400:	b29ea0ef          	jal	ra,40008f28 <strlen>
4001e404:	06050263          	beqz	a0,4001e468 <tcp_in+0x1210>
4001e408:	005bc703          	lbu	a4,5(s7)
4001e40c:	004bc683          	lbu	a3,4(s7)
4001e410:	000105b7          	lui	a1,0x10
4001e414:	00871713          	slli	a4,a4,0x8
4001e418:	00d76733          	or	a4,a4,a3
4001e41c:	006bc683          	lbu	a3,6(s7)
4001e420:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001e424:	01069693          	slli	a3,a3,0x10
4001e428:	00e6e6b3          	or	a3,a3,a4
4001e42c:	007bc703          	lbu	a4,7(s7)
4001e430:	01871713          	slli	a4,a4,0x18
4001e434:	00d76633          	or	a2,a4,a3
4001e438:	01869693          	slli	a3,a3,0x18
4001e43c:	01875713          	srli	a4,a4,0x18
4001e440:	00d76733          	or	a4,a4,a3
4001e444:	00865693          	srli	a3,a2,0x8
4001e448:	00b6f6b3          	and	a3,a3,a1
4001e44c:	00d76733          	or	a4,a4,a3
4001e450:	00861613          	slli	a2,a2,0x8
4001e454:	00ff06b7          	lui	a3,0xff0
4001e458:	00d67633          	and	a2,a2,a3
4001e45c:	22c42683          	lw	a3,556(s0)
4001e460:	00c76733          	or	a4,a4,a2
4001e464:	04d71263          	bne	a4,a3,4001e4a8 <tcp_in+0x1250>
4001e468:	00100713          	li	a4,1
4001e46c:	02e91e63          	bne	s2,a4,4001e4a8 <tcp_in+0x1250>
			tcp_send_timer_cancel(conn);
4001e470:	00040513          	mv	a0,s0
4001e474:	e9dfc0ef          	jal	ra,4001b310 <tcp_send_timer_cancel>
			conn_ack(conn, + 1);
4001e478:	22c42783          	lw	a5,556(s0)
			tcp_out(conn, ACK);
4001e47c:	01000593          	li	a1,16
4001e480:	00040513          	mv	a0,s0
			conn_ack(conn, + 1);
4001e484:	00178793          	addi	a5,a5,1
4001e488:	22f42623          	sw	a5,556(s0)
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
4001e48c:	00000913          	li	s2,0
			tcp_out(conn, ACK);
4001e490:	88cfe0ef          	jal	ra,4001c51c <tcp_out>
	if (pkt) {
4001e494:	00048663          	beqz	s1,4001e4a0 <tcp_in+0x1248>
			net_pkt_unref(pkt);
4001e498:	00048513          	mv	a0,s1
4001e49c:	a81f40ef          	jal	ra,40012f1c <net_pkt_unref>
			next = TCP_CLOSING;
4001e4a0:	00800a13          	li	s4,8
4001e4a4:	a54ff06f          	j	4001d6f8 <tcp_in+0x4a0>
		} else if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
4001e4a8:	4c0a0513          	addi	a0,s4,1216
4001e4ac:	a7dea0ef          	jal	ra,40008f28 <strlen>
4001e4b0:	06050263          	beqz	a0,4001e514 <tcp_in+0x12bc>
4001e4b4:	005bc683          	lbu	a3,5(s7)
4001e4b8:	004bc703          	lbu	a4,4(s7)
4001e4bc:	007bc783          	lbu	a5,7(s7)
4001e4c0:	00869693          	slli	a3,a3,0x8
4001e4c4:	00e6e6b3          	or	a3,a3,a4
4001e4c8:	006bc703          	lbu	a4,6(s7)
4001e4cc:	01879793          	slli	a5,a5,0x18
4001e4d0:	00010637          	lui	a2,0x10
4001e4d4:	01071713          	slli	a4,a4,0x10
4001e4d8:	00d76733          	or	a4,a4,a3
4001e4dc:	00e7e6b3          	or	a3,a5,a4
4001e4e0:	01871713          	slli	a4,a4,0x18
4001e4e4:	0187d793          	srli	a5,a5,0x18
4001e4e8:	00e7e7b3          	or	a5,a5,a4
4001e4ec:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001e4f0:	0086d713          	srli	a4,a3,0x8
4001e4f4:	00c77733          	and	a4,a4,a2
4001e4f8:	00e7e7b3          	or	a5,a5,a4
4001e4fc:	00869693          	slli	a3,a3,0x8
4001e500:	00ff0737          	lui	a4,0xff0
4001e504:	00e6f6b3          	and	a3,a3,a4
4001e508:	22c42703          	lw	a4,556(s0)
4001e50c:	00d7e7b3          	or	a5,a5,a3
4001e510:	1ae79463          	bne	a5,a4,4001e6b8 <tcp_in+0x1460>
4001e514:	01000793          	li	a5,16
4001e518:	1af91063          	bne	s2,a5,4001e6b8 <tcp_in+0x1460>
			tcp_send_timer_cancel(conn);
4001e51c:	00040513          	mv	a0,s0
		} else if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
4001e520:	00000913          	li	s2,0
			tcp_send_timer_cancel(conn);
4001e524:	dedfc0ef          	jal	ra,4001b310 <tcp_send_timer_cancel>
	if (pkt) {
4001e528:	00048663          	beqz	s1,4001e534 <tcp_in+0x12dc>
			net_pkt_unref(pkt);
4001e52c:	00048513          	mv	a0,s1
4001e530:	9edf40ef          	jal	ra,40012f1c <net_pkt_unref>
			next = TCP_FIN_WAIT_2;
4001e534:	00600a13          	li	s4,6
4001e538:	9c0ff06f          	j	4001d6f8 <tcp_in+0x4a0>
		if (th && (FL(&fl, ==, FIN, th_seq(th) == conn->ack) ||
4001e53c:	160b8e63          	beqz	s7,4001e6b8 <tcp_in+0x1460>
4001e540:	0ff97913          	zext.b	s2,s2
4001e544:	16090a63          	beqz	s2,4001e6b8 <tcp_in+0x1460>
4001e548:	4002da37          	lui	s4,0x4002d
4001e54c:	4c0a0513          	addi	a0,s4,1216 # 4002d4c0 <CSWTCH.15321+0x78>
4001e550:	9d9ea0ef          	jal	ra,40008f28 <strlen>
4001e554:	06050263          	beqz	a0,4001e5b8 <tcp_in+0x1360>
4001e558:	005bc703          	lbu	a4,5(s7)
4001e55c:	004bc683          	lbu	a3,4(s7)
4001e560:	000105b7          	lui	a1,0x10
4001e564:	00871713          	slli	a4,a4,0x8
4001e568:	00d76733          	or	a4,a4,a3
4001e56c:	006bc683          	lbu	a3,6(s7)
4001e570:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001e574:	01069693          	slli	a3,a3,0x10
4001e578:	00e6e6b3          	or	a3,a3,a4
4001e57c:	007bc703          	lbu	a4,7(s7)
4001e580:	01871713          	slli	a4,a4,0x18
4001e584:	00d76633          	or	a2,a4,a3
4001e588:	01869693          	slli	a3,a3,0x18
4001e58c:	01875713          	srli	a4,a4,0x18
4001e590:	00d76733          	or	a4,a4,a3
4001e594:	00865693          	srli	a3,a2,0x8
4001e598:	00b6f6b3          	and	a3,a3,a1
4001e59c:	00d76733          	or	a4,a4,a3
4001e5a0:	00861613          	slli	a2,a2,0x8
4001e5a4:	00ff06b7          	lui	a3,0xff0
4001e5a8:	00d67633          	and	a2,a2,a3
4001e5ac:	22c42683          	lw	a3,556(s0)
4001e5b0:	00c76733          	or	a4,a4,a2
4001e5b4:	00d71e63          	bne	a4,a3,4001e5d0 <tcp_in+0x1378>
4001e5b8:	00100713          	li	a4,1
4001e5bc:	00e91a63          	bne	s2,a4,4001e5d0 <tcp_in+0x1378>
			k_work_cancel_delayable(&conn->fin_timer);
4001e5c0:	1b040513          	addi	a0,s0,432
			   FL(&fl, ==, FIN | PSH | ACK,
4001e5c4:	00000913          	li	s2,0
			k_work_cancel_delayable(&conn->fin_timer);
4001e5c8:	0740b0ef          	jal	ra,4002963c <k_work_cancel_delayable>
4001e5cc:	e05ff06f          	j	4001e3d0 <tcp_in+0x1178>
			   FL(&fl, ==, FIN | ACK, th_seq(th) == conn->ack) ||
4001e5d0:	4c0a0513          	addi	a0,s4,1216
4001e5d4:	955ea0ef          	jal	ra,40008f28 <strlen>
4001e5d8:	06050263          	beqz	a0,4001e63c <tcp_in+0x13e4>
4001e5dc:	005bc703          	lbu	a4,5(s7)
4001e5e0:	004bc683          	lbu	a3,4(s7)
4001e5e4:	000105b7          	lui	a1,0x10
4001e5e8:	00871713          	slli	a4,a4,0x8
4001e5ec:	00d76733          	or	a4,a4,a3
4001e5f0:	006bc683          	lbu	a3,6(s7)
4001e5f4:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001e5f8:	01069693          	slli	a3,a3,0x10
4001e5fc:	00e6e6b3          	or	a3,a3,a4
4001e600:	007bc703          	lbu	a4,7(s7)
4001e604:	01871713          	slli	a4,a4,0x18
4001e608:	00d76633          	or	a2,a4,a3
4001e60c:	01869693          	slli	a3,a3,0x18
4001e610:	01875713          	srli	a4,a4,0x18
4001e614:	00d76733          	or	a4,a4,a3
4001e618:	00865693          	srli	a3,a2,0x8
4001e61c:	00b6f6b3          	and	a3,a3,a1
4001e620:	00d76733          	or	a4,a4,a3
4001e624:	00861613          	slli	a2,a2,0x8
4001e628:	00ff06b7          	lui	a3,0xff0
4001e62c:	00d67633          	and	a2,a2,a3
4001e630:	22c42683          	lw	a3,556(s0)
4001e634:	00c76733          	or	a4,a4,a2
4001e638:	00d71663          	bne	a4,a3,4001e644 <tcp_in+0x13ec>
4001e63c:	01100713          	li	a4,17
4001e640:	f8e900e3          	beq	s2,a4,4001e5c0 <tcp_in+0x1368>
			   FL(&fl, ==, FIN | PSH | ACK,
4001e644:	4c0a0513          	addi	a0,s4,1216
4001e648:	8e1ea0ef          	jal	ra,40008f28 <strlen>
4001e64c:	06050263          	beqz	a0,4001e6b0 <tcp_in+0x1458>
4001e650:	005bc683          	lbu	a3,5(s7)
4001e654:	004bc703          	lbu	a4,4(s7)
4001e658:	007bc783          	lbu	a5,7(s7)
4001e65c:	00869693          	slli	a3,a3,0x8
4001e660:	00e6e6b3          	or	a3,a3,a4
4001e664:	006bc703          	lbu	a4,6(s7)
4001e668:	01879793          	slli	a5,a5,0x18
4001e66c:	00010637          	lui	a2,0x10
4001e670:	01071713          	slli	a4,a4,0x10
4001e674:	00d76733          	or	a4,a4,a3
4001e678:	00e7e6b3          	or	a3,a5,a4
4001e67c:	01871713          	slli	a4,a4,0x18
4001e680:	0187d793          	srli	a5,a5,0x18
4001e684:	00e7e7b3          	or	a5,a5,a4
4001e688:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001e68c:	0086d713          	srli	a4,a3,0x8
4001e690:	00c77733          	and	a4,a4,a2
4001e694:	00e7e7b3          	or	a5,a5,a4
4001e698:	00869693          	slli	a3,a3,0x8
4001e69c:	00ff0737          	lui	a4,0xff0
4001e6a0:	00e6f6b3          	and	a3,a3,a4
4001e6a4:	22c42703          	lw	a4,556(s0)
4001e6a8:	00d7e7b3          	or	a5,a5,a3
4001e6ac:	00e79663          	bne	a5,a4,4001e6b8 <tcp_in+0x1460>
4001e6b0:	01900793          	li	a5,25
4001e6b4:	f0f906e3          	beq	s2,a5,4001e5c0 <tcp_in+0x1368>
	if (pkt) {
4001e6b8:	1c049a63          	bnez	s1,4001e88c <tcp_in+0x1634>
4001e6bc:	9cdff06f          	j	4001e088 <tcp_in+0xe30>
		if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
4001e6c0:	1c0b8263          	beqz	s7,4001e884 <tcp_in+0x162c>
4001e6c4:	0ff97913          	zext.b	s2,s2
4001e6c8:	fe0908e3          	beqz	s2,4001e6b8 <tcp_in+0x1460>
4001e6cc:	4002d537          	lui	a0,0x4002d
4001e6d0:	4c050513          	addi	a0,a0,1216 # 4002d4c0 <CSWTCH.15321+0x78>
4001e6d4:	855ea0ef          	jal	ra,40008f28 <strlen>
4001e6d8:	06050263          	beqz	a0,4001e73c <tcp_in+0x14e4>
4001e6dc:	005bc683          	lbu	a3,5(s7)
4001e6e0:	004bc703          	lbu	a4,4(s7)
4001e6e4:	007bc783          	lbu	a5,7(s7)
4001e6e8:	00869693          	slli	a3,a3,0x8
4001e6ec:	00e6e6b3          	or	a3,a3,a4
4001e6f0:	006bc703          	lbu	a4,6(s7)
4001e6f4:	01879793          	slli	a5,a5,0x18
4001e6f8:	00010637          	lui	a2,0x10
4001e6fc:	01071713          	slli	a4,a4,0x10
4001e700:	00d76733          	or	a4,a4,a3
4001e704:	00e7e6b3          	or	a3,a5,a4
4001e708:	01871713          	slli	a4,a4,0x18
4001e70c:	0187d793          	srli	a5,a5,0x18
4001e710:	00e7e7b3          	or	a5,a5,a4
4001e714:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001e718:	0086d713          	srli	a4,a3,0x8
4001e71c:	00c77733          	and	a4,a4,a2
4001e720:	00e7e7b3          	or	a5,a5,a4
4001e724:	00869693          	slli	a3,a3,0x8
4001e728:	00ff0737          	lui	a4,0xff0
4001e72c:	00e6f6b3          	and	a3,a3,a4
4001e730:	22c42703          	lw	a4,556(s0)
4001e734:	00d7e7b3          	or	a5,a5,a3
4001e738:	14e79663          	bne	a5,a4,4001e884 <tcp_in+0x162c>
4001e73c:	01000793          	li	a5,16
4001e740:	f6f91ce3          	bne	s2,a5,4001e6b8 <tcp_in+0x1460>
			tcp_send_timer_cancel(conn);
4001e744:	00040513          	mv	a0,s0
		if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
4001e748:	00000913          	li	s2,0
			tcp_send_timer_cancel(conn);
4001e74c:	bc5fc0ef          	jal	ra,4001b310 <tcp_send_timer_cancel>
4001e750:	c99ff06f          	j	4001e3e8 <tcp_in+0x1190>
		if (th && (FL(&fl, ==, (FIN | ACK), th_seq(th) + 1 == conn->ack) ||
4001e754:	100b8863          	beqz	s7,4001e864 <tcp_in+0x160c>
4001e758:	0ff97913          	zext.b	s2,s2
4001e75c:	10090463          	beqz	s2,4001e864 <tcp_in+0x160c>
4001e760:	4002da37          	lui	s4,0x4002d
4001e764:	4d8a0513          	addi	a0,s4,1240 # 4002d4d8 <CSWTCH.15321+0x90>
4001e768:	fc0ea0ef          	jal	ra,40008f28 <strlen>
4001e76c:	06050463          	beqz	a0,4001e7d4 <tcp_in+0x157c>
4001e770:	005bc703          	lbu	a4,5(s7)
4001e774:	004bc683          	lbu	a3,4(s7)
4001e778:	000105b7          	lui	a1,0x10
4001e77c:	00871713          	slli	a4,a4,0x8
4001e780:	00d76733          	or	a4,a4,a3
4001e784:	006bc683          	lbu	a3,6(s7)
4001e788:	f0058593          	addi	a1,a1,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001e78c:	01069693          	slli	a3,a3,0x10
4001e790:	00e6e6b3          	or	a3,a3,a4
4001e794:	007bc703          	lbu	a4,7(s7)
4001e798:	01871713          	slli	a4,a4,0x18
4001e79c:	00d76633          	or	a2,a4,a3
4001e7a0:	01869693          	slli	a3,a3,0x18
4001e7a4:	01875713          	srli	a4,a4,0x18
4001e7a8:	00d76733          	or	a4,a4,a3
4001e7ac:	00865693          	srli	a3,a2,0x8
4001e7b0:	00b6f6b3          	and	a3,a3,a1
4001e7b4:	00d76733          	or	a4,a4,a3
4001e7b8:	00861613          	slli	a2,a2,0x8
4001e7bc:	00ff06b7          	lui	a3,0xff0
4001e7c0:	00d67633          	and	a2,a2,a3
4001e7c4:	22c42683          	lw	a3,556(s0)
4001e7c8:	00c76733          	or	a4,a4,a2
4001e7cc:	00170713          	addi	a4,a4,1 # ff0001 <__rom_region_size+0xfbf625>
4001e7d0:	00d71663          	bne	a4,a3,4001e7dc <tcp_in+0x1584>
4001e7d4:	01100713          	li	a4,17
4001e7d8:	06e90e63          	beq	s2,a4,4001e854 <tcp_in+0x15fc>
			   FL(&fl, ==, FIN, th_seq(th) + 1 == conn->ack))) {
4001e7dc:	4d8a0513          	addi	a0,s4,1240
4001e7e0:	f48ea0ef          	jal	ra,40008f28 <strlen>
4001e7e4:	06050463          	beqz	a0,4001e84c <tcp_in+0x15f4>
4001e7e8:	005bc683          	lbu	a3,5(s7)
4001e7ec:	004bc703          	lbu	a4,4(s7)
4001e7f0:	007bc783          	lbu	a5,7(s7)
4001e7f4:	00869693          	slli	a3,a3,0x8
4001e7f8:	00e6e6b3          	or	a3,a3,a4
4001e7fc:	006bc703          	lbu	a4,6(s7)
4001e800:	01879793          	slli	a5,a5,0x18
4001e804:	00010637          	lui	a2,0x10
4001e808:	01071713          	slli	a4,a4,0x10
4001e80c:	00d76733          	or	a4,a4,a3
4001e810:	00e7e6b3          	or	a3,a5,a4
4001e814:	01871713          	slli	a4,a4,0x18
4001e818:	0187d793          	srli	a5,a5,0x18
4001e81c:	00e7e7b3          	or	a5,a5,a4
4001e820:	f0060613          	addi	a2,a2,-256 # ff00 <__kernel_ram_size+0x3c6c>
4001e824:	0086d713          	srli	a4,a3,0x8
4001e828:	00c77733          	and	a4,a4,a2
4001e82c:	00e7e7b3          	or	a5,a5,a4
4001e830:	00869693          	slli	a3,a3,0x8
4001e834:	00ff0737          	lui	a4,0xff0
4001e838:	00e6f6b3          	and	a3,a3,a4
4001e83c:	22c42703          	lw	a4,556(s0)
4001e840:	00d7e7b3          	or	a5,a5,a3
4001e844:	00178793          	addi	a5,a5,1
4001e848:	00e79e63          	bne	a5,a4,4001e864 <tcp_in+0x160c>
4001e84c:	00100793          	li	a5,1
4001e850:	00f91a63          	bne	s2,a5,4001e864 <tcp_in+0x160c>
			tcp_out(conn, ACK);
4001e854:	01000593          	li	a1,16
4001e858:	00040513          	mv	a0,s0
4001e85c:	cc1fd0ef          	jal	ra,4001c51c <tcp_out>
			verdict = NET_OK;
4001e860:	00000993          	li	s3,0
		k_work_reschedule_for_queue(
4001e864:	40031537          	lui	a0,0x40031
4001e868:	09600613          	li	a2,150
4001e86c:	00000693          	li	a3,0
4001e870:	12040593          	addi	a1,s0,288
4001e874:	10850513          	addi	a0,a0,264 # 40031108 <tcp_work_q>
4001e878:	51d0a0ef          	jal	ra,40029594 <k_work_reschedule_for_queue>
	if (pkt) {
4001e87c:	00000913          	li	s2,0
4001e880:	dc4ff06f          	j	4001de44 <tcp_in+0xbec>
4001e884:	00000913          	li	s2,0
4001e888:	dc048063          	beqz	s1,4001de48 <tcp_in+0xbf0>
			return NET_DROP;
4001e88c:	00000913          	li	s2,0
		if (verdict == NET_OK) {
4001e890:	da099c63          	bnez	s3,4001de48 <tcp_in+0xbf0>
			net_pkt_unref(pkt);
4001e894:	00048513          	mv	a0,s1
4001e898:	e84f40ef          	jal	ra,40012f1c <net_pkt_unref>
	if (next) {
4001e89c:	dacff06f          	j	4001de48 <tcp_in+0xbf0>
	if (pkt) {
4001e8a0:	00048663          	beqz	s1,4001e8ac <tcp_in+0x1654>
			net_pkt_unref(pkt);
4001e8a4:	00048513          	mv	a0,s1
4001e8a8:	e74f40ef          	jal	ra,40012f1c <net_pkt_unref>
				verdict = NET_OK;
4001e8ac:	00000993          	li	s3,0
4001e8b0:	834ff06f          	j	4001d8e4 <tcp_in+0x68c>
		do_close = true;
4001e8b4:	00100913          	li	s2,1
4001e8b8:	d8cff06f          	j	4001de44 <tcp_in+0xbec>
		return NET_DROP;
4001e8bc:	00200993          	li	s3,2
4001e8c0:	fc8ff06f          	j	4001e088 <tcp_in+0xe30>
	while (conn_handler && atomic_get(&conn->ref_count) > 0 &&
4001e8c4:	000b8513          	mv	a0,s7
4001e8c8:	7200c0ef          	jal	ra,4002afe8 <atomic_get>
4001e8cc:	daa05263          	blez	a0,4001de70 <tcp_in+0xc18>
	return z_impl_k_queue_get(queue, timeout);
4001e8d0:	00000593          	li	a1,0
4001e8d4:	00000613          	li	a2,0
4001e8d8:	000b0513          	mv	a0,s6
4001e8dc:	3900a0ef          	jal	ra,40028c6c <z_impl_k_queue_get>
4001e8e0:	00050493          	mv	s1,a0
4001e8e4:	d8050663          	beqz	a0,4001de70 <tcp_in+0xc18>
		if (net_context_packet_received(conn_handler, recv_pkt, NULL,
4001e8e8:	000c0713          	mv	a4,s8
4001e8ec:	00000693          	li	a3,0
4001e8f0:	00000613          	li	a2,0
4001e8f4:	00048593          	mv	a1,s1
4001e8f8:	000a0513          	mv	a0,s4
4001e8fc:	aa9f20ef          	jal	ra,400113a4 <net_context_packet_received>
4001e900:	fd9512e3          	bne	a0,s9,4001e8c4 <tcp_in+0x166c>
			tcp_pkt_unref(recv_pkt);
4001e904:	00048513          	mv	a0,s1
4001e908:	e14f40ef          	jal	ra,40012f1c <net_pkt_unref>
4001e90c:	d60ff06f          	j	4001de6c <tcp_in+0xc14>
			next = TCP_ESTABLISHED;
4001e910:	00400a13          	li	s4,4
			connection_ok = true;
4001e914:	00100c13          	li	s8,1
		if (verdict == NET_OK) {
4001e918:	00098463          	beqz	s3,4001e920 <tcp_in+0x16c8>
4001e91c:	e21fe06f          	j	4001d73c <tcp_in+0x4e4>
4001e920:	e40ff06f          	j	4001df60 <tcp_in+0xd08>

4001e924 <net_tcp_connect>:
{
4001e924:	fa010113          	addi	sp,sp,-96
4001e928:	04112e23          	sw	ra,92(sp)
4001e92c:	04912a23          	sw	s1,84(sp)
4001e930:	05212823          	sw	s2,80(sp)
4001e934:	05312623          	sw	s3,76(sp)
4001e938:	05412423          	sw	s4,72(sp)
4001e93c:	05512223          	sw	s5,68(sp)
4001e940:	05612023          	sw	s6,64(sp)
4001e944:	03712e23          	sw	s7,60(sp)
4001e948:	03812c23          	sw	s8,56(sp)
4001e94c:	03912a23          	sw	s9,52(sp)
4001e950:	03a12823          	sw	s10,48(sp)
4001e954:	03b12623          	sw	s11,44(sp)
4001e958:	04812c23          	sw	s0,88(sp)
	conn = context->tcp;
4001e95c:	05452403          	lw	s0,84(a0)
{
4001e960:	00050493          	mv	s1,a0
	conn->iface = net_context_get_iface(context);
4001e964:	07650503          	lb	a0,118(a0)
{
4001e968:	00078b93          	mv	s7,a5
4001e96c:	00058993          	mv	s3,a1
4001e970:	00060c93          	mv	s9,a2
4001e974:	00068a13          	mv	s4,a3
4001e978:	00070a93          	mv	s5,a4
4001e97c:	00080b13          	mv	s6,a6
4001e980:	00088c13          	mv	s8,a7
	conn->iface = net_context_get_iface(context);
4001e984:	e24fc0ef          	jal	ra,4001afa8 <net_context_get_iface.isra.0>
4001e988:	00a42823          	sw	a0,16(s0)
	tcp_derive_rto(conn);
4001e98c:	00040513          	mv	a0,s0
4001e990:	b58fc0ef          	jal	ra,4001ace8 <tcp_derive_rto>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
4001e994:	0744d903          	lhu	s2,116(s1)
	switch (net_context_get_family(context)) {
4001e998:	00100793          	li	a5,1
		memset(&conn->src, 0, sizeof(struct sockaddr_in));
4001e99c:	1e040d13          	addi	s10,s0,480
4001e9a0:	00395913          	srli	s2,s2,0x3
4001e9a4:	00797913          	andi	s2,s2,7
		memset(&conn->dst, 0, sizeof(struct sockaddr_in));
4001e9a8:	1f840d93          	addi	s11,s0,504
	switch (net_context_get_family(context)) {
4001e9ac:	14f90463          	beq	s2,a5,4001eaf4 <net_tcp_connect+0x1d0>
4001e9b0:	00200793          	li	a5,2
4001e9b4:	1cf90863          	beq	s2,a5,4001eb84 <net_tcp_connect+0x260>
		conn->seq = tcp_init_isn(&conn->src.sa, &conn->dst.sa);
4001e9b8:	000d8593          	mv	a1,s11
4001e9bc:	000d0513          	mv	a0,s10
4001e9c0:	fb1fc0ef          	jal	ra,4001b970 <tcp_init_isn>
4001e9c4:	22a42423          	sw	a0,552(s0)
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
4001e9c8:	0744d583          	lhu	a1,116(s1)
	ret = net_conn_register(net_context_get_proto(context),
4001e9cc:	04448693          	addi	a3,s1,68
4001e9d0:	008a9793          	slli	a5,s5,0x8
4001e9d4:	ff95f593          	andi	a1,a1,-7
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
4001e9d8:	0025e593          	ori	a1,a1,2
4001e9dc:	06b49a23          	sh	a1,116(s1)
4001e9e0:	00d12223          	sw	a3,4(sp)
4001e9e4:	008a1713          	slli	a4,s4,0x8
4001e9e8:	00912023          	sw	s1,0(sp)
4001e9ec:	008ada93          	srli	s5,s5,0x8
4001e9f0:	008a5a13          	srli	s4,s4,0x8
4001e9f4:	0724d503          	lhu	a0,114(s1)
4001e9f8:	0157e7b3          	or	a5,a5,s5
4001e9fc:	01476733          	or	a4,a4,s4
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
4001ea00:	0035d593          	srli	a1,a1,0x3
4001ea04:	4001f8b7          	lui	a7,0x4001f
4001ea08:	01079793          	slli	a5,a5,0x10
4001ea0c:	01071713          	slli	a4,a4,0x10
4001ea10:	c1488893          	addi	a7,a7,-1004 # 4001ec14 <tcp_recv>
4001ea14:	00048813          	mv	a6,s1
4001ea18:	0107d793          	srli	a5,a5,0x10
4001ea1c:	01075713          	srli	a4,a4,0x10
4001ea20:	000c8693          	mv	a3,s9
4001ea24:	00098613          	mv	a2,s3
4001ea28:	0075f593          	andi	a1,a1,7
4001ea2c:	91df50ef          	jal	ra,40014348 <net_conn_register>
4001ea30:	00050913          	mv	s2,a0
	if (ret < 0) {
4001ea34:	08054063          	bltz	a0,4001eab4 <net_tcp_connect+0x190>
	context->user_data = user_data;
4001ea38:	06012783          	lw	a5,96(sp)
	conn->connect_cb = cb;
4001ea3c:	03842223          	sw	s8,36(s0)
	(void)tcp_in(conn, NULL);
4001ea40:	00000593          	li	a1,0
	context->user_data = user_data;
4001ea44:	00f4a223          	sw	a5,4(s1)
	conn->in_connect = !IS_ENABLED(CONFIG_NET_TEST_PROTOCOL);
4001ea48:	23d44783          	lbu	a5,573(s0)
	(void)tcp_in(conn, NULL);
4001ea4c:	00040513          	mv	a0,s0
	conn->in_connect = !IS_ENABLED(CONFIG_NET_TEST_PROTOCOL);
4001ea50:	0027e793          	ori	a5,a5,2
4001ea54:	22f40ea3          	sb	a5,573(s0)
	(void)tcp_in(conn, NULL);
4001ea58:	801fe0ef          	jal	ra,4001d258 <tcp_in>
		if ((K_TIMEOUT_EQ(timeout, K_NO_WAIT)) &&
4001ea5c:	016be7b3          	or	a5,s7,s6
4001ea60:	00079863          	bnez	a5,4001ea70 <net_tcp_connect+0x14c>
4001ea64:	22042703          	lw	a4,544(s0)
4001ea68:	00400793          	li	a5,4
4001ea6c:	1af71063          	bne	a4,a5,4001ec0c <net_tcp_connect+0x2e8>
	return z_impl_k_sem_take(sem, timeout);
4001ea70:	000b8593          	mv	a1,s7
4001ea74:	000b0613          	mv	a2,s6
4001ea78:	03c40513          	addi	a0,s0,60
4001ea7c:	3780a0ef          	jal	ra,40028df4 <z_impl_k_sem_take>
		} else if (k_sem_take(&conn->connect_sem, timeout) != 0 &&
4001ea80:	16050e63          	beqz	a0,4001ebfc <net_tcp_connect+0x2d8>
4001ea84:	22042703          	lw	a4,544(s0)
4001ea88:	00400793          	li	a5,4
4001ea8c:	16f70863          	beq	a4,a5,4001ebfc <net_tcp_connect+0x2d8>
			if (conn->in_connect) {
4001ea90:	23d44783          	lbu	a5,573(s0)
4001ea94:	0027f713          	andi	a4,a5,2
4001ea98:	00070c63          	beqz	a4,4001eab0 <net_tcp_connect+0x18c>
				conn->in_connect = false;
4001ea9c:	ffd7f793          	andi	a5,a5,-3
4001eaa0:	22f40ea3          	sb	a5,573(s0)
				tcp_conn_close(conn, -ETIMEDOUT);
4001eaa4:	f8c00593          	li	a1,-116
4001eaa8:	00040513          	mv	a0,s0
4001eaac:	dbdfc0ef          	jal	ra,4001b868 <tcp_conn_close.isra.0>
			ret = -ETIMEDOUT;
4001eab0:	f8c00913          	li	s2,-116
}
4001eab4:	05c12083          	lw	ra,92(sp)
4001eab8:	05812403          	lw	s0,88(sp)
4001eabc:	05412483          	lw	s1,84(sp)
4001eac0:	04c12983          	lw	s3,76(sp)
4001eac4:	04812a03          	lw	s4,72(sp)
4001eac8:	04412a83          	lw	s5,68(sp)
4001eacc:	04012b03          	lw	s6,64(sp)
4001ead0:	03c12b83          	lw	s7,60(sp)
4001ead4:	03812c03          	lw	s8,56(sp)
4001ead8:	03412c83          	lw	s9,52(sp)
4001eadc:	03012d03          	lw	s10,48(sp)
4001eae0:	02c12d83          	lw	s11,44(sp)
4001eae4:	00090513          	mv	a0,s2
4001eae8:	05012903          	lw	s2,80(sp)
4001eaec:	06010113          	addi	sp,sp,96
4001eaf0:	00008067          	ret
		memset(&conn->src, 0, sizeof(struct sockaddr_in));
4001eaf4:	00800613          	li	a2,8
4001eaf8:	00000593          	li	a1,0
4001eafc:	000d0513          	mv	a0,s10
4001eb00:	d70ea0ef          	jal	ra,40009070 <memset>
		memset(&conn->dst, 0, sizeof(struct sockaddr_in));
4001eb04:	00800613          	li	a2,8
4001eb08:	00000593          	li	a1,0
4001eb0c:	000d8513          	mv	a0,s11
4001eb10:	d60ea0ef          	jal	ra,40009070 <memset>
		conn->src.sa.sa_family = AF_INET;
4001eb14:	1f241023          	sh	s2,480(s0)
		conn->dst.sa.sa_family = AF_INET;
4001eb18:	1f241c23          	sh	s2,504(s0)
		conn->dst.sin.sin_port = remote_port;
4001eb1c:	1f441d23          	sh	s4,506(s0)
		conn->src.sin.sin_port = local_port;
4001eb20:	1f541123          	sh	s5,482(s0)
		ip4 = net_if_ipv4_select_src_addr(
4001eb24:	07648503          	lb	a0,118(s1)
4001eb28:	c80fc0ef          	jal	ra,4001afa8 <net_context_get_iface.isra.0>
4001eb2c:	00498593          	addi	a1,s3,4
4001eb30:	9b8f00ef          	jal	ra,4000ece8 <net_if_ipv4_select_src_addr>
		conn->src.sin.sin_addr = *ip4;
4001eb34:	00052783          	lw	a5,0(a0)
4001eb38:	1ef42223          	sw	a5,484(s0)
		net_ipaddr_copy(&conn->dst.sin.sin_addr,
4001eb3c:	0059c783          	lbu	a5,5(s3)
4001eb40:	0049c703          	lbu	a4,4(s3)
4001eb44:	00879793          	slli	a5,a5,0x8
4001eb48:	00e7e7b3          	or	a5,a5,a4
4001eb4c:	0069c703          	lbu	a4,6(s3)
4001eb50:	01071713          	slli	a4,a4,0x10
4001eb54:	00f76733          	or	a4,a4,a5
4001eb58:	0079c783          	lbu	a5,7(s3)
4001eb5c:	1ee40e23          	sb	a4,508(s0)
4001eb60:	01879793          	slli	a5,a5,0x18
4001eb64:	00e7e7b3          	or	a5,a5,a4
4001eb68:	0087d713          	srli	a4,a5,0x8
4001eb6c:	1ee40ea3          	sb	a4,509(s0)
4001eb70:	0107d713          	srli	a4,a5,0x10
4001eb74:	0187d793          	srli	a5,a5,0x18
4001eb78:	1ee40f23          	sb	a4,510(s0)
4001eb7c:	1ef40fa3          	sb	a5,511(s0)
		break;
4001eb80:	e39ff06f          	j	4001e9b8 <net_tcp_connect+0x94>
		memset(&conn->src, 0, sizeof(struct sockaddr_in6));
4001eb84:	01800613          	li	a2,24
4001eb88:	00000593          	li	a1,0
4001eb8c:	000d0513          	mv	a0,s10
4001eb90:	ce0ea0ef          	jal	ra,40009070 <memset>
		memset(&conn->dst, 0, sizeof(struct sockaddr_in6));
4001eb94:	01800613          	li	a2,24
4001eb98:	00000593          	li	a1,0
4001eb9c:	000d8513          	mv	a0,s11
4001eba0:	cd0ea0ef          	jal	ra,40009070 <memset>
		conn->src.sin6.sin6_family = AF_INET6;
4001eba4:	1f241023          	sh	s2,480(s0)
		conn->dst.sin6.sin6_family = AF_INET6;
4001eba8:	1f241c23          	sh	s2,504(s0)
		conn->dst.sin6.sin6_port = remote_port;
4001ebac:	1f441d23          	sh	s4,506(s0)
		conn->src.sin6.sin6_port = local_port;
4001ebb0:	1f541123          	sh	s5,482(s0)
		ip6 = net_if_ipv6_select_src_addr(
4001ebb4:	07648503          	lb	a0,118(s1)
					&net_sin6(remote_addr)->sin6_addr);
4001ebb8:	00498913          	addi	s2,s3,4
		ip6 = net_if_ipv6_select_src_addr(
4001ebbc:	becfc0ef          	jal	ra,4001afa8 <net_context_get_iface.isra.0>
4001ebc0:	00090593          	mv	a1,s2
4001ebc4:	c21ef0ef          	jal	ra,4000e7e4 <net_if_ipv6_select_src_addr>
4001ebc8:	00050593          	mv	a1,a0
		conn->src.sin6.sin6_addr = *ip6;
4001ebcc:	01000613          	li	a2,16
4001ebd0:	1e440513          	addi	a0,s0,484
4001ebd4:	c78ea0ef          	jal	ra,4000904c <memcpy>
		net_ipaddr_copy(&conn->dst.sin6.sin6_addr,
4001ebd8:	00090593          	mv	a1,s2
4001ebdc:	01000613          	li	a2,16
4001ebe0:	01010513          	addi	a0,sp,16
4001ebe4:	c68ea0ef          	jal	ra,4000904c <memcpy>
4001ebe8:	01000613          	li	a2,16
4001ebec:	01010593          	addi	a1,sp,16
4001ebf0:	1fc40513          	addi	a0,s0,508
4001ebf4:	c58ea0ef          	jal	ra,4000904c <memcpy>
		break;
4001ebf8:	dc1ff06f          	j	4001e9b8 <net_tcp_connect+0x94>
		conn->in_connect = false;
4001ebfc:	23d44783          	lbu	a5,573(s0)
4001ec00:	ffd7f793          	andi	a5,a5,-3
4001ec04:	22f40ea3          	sb	a5,573(s0)
4001ec08:	eadff06f          	j	4001eab4 <net_tcp_connect+0x190>
			ret = -EINPROGRESS;
4001ec0c:	f8900913          	li	s2,-119
	return ret;
4001ec10:	ea5ff06f          	j	4001eab4 <net_tcp_connect+0x190>

4001ec14 <tcp_recv>:
{
4001ec14:	fa010113          	addi	sp,sp,-96
	return list->head;
4001ec18:	400317b7          	lui	a5,0x40031
4001ec1c:	04812c23          	sw	s0,88(sp)
4001ec20:	ac47a403          	lw	s0,-1340(a5) # 40030ac4 <tcp_conns>
4001ec24:	04912a23          	sw	s1,84(sp)
4001ec28:	05312623          	sw	s3,76(sp)
4001ec2c:	04112e23          	sw	ra,92(sp)
4001ec30:	05212823          	sw	s2,80(sp)
4001ec34:	05412423          	sw	s4,72(sp)
4001ec38:	05512223          	sw	s5,68(sp)
4001ec3c:	00058493          	mv	s1,a1
4001ec40:	00070993          	mv	s3,a4
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp_conns, conn, tmp, next) {
4001ec44:	00040663          	beqz	s0,4001ec50 <tcp_recv+0x3c>
	return node->next;
4001ec48:	00042903          	lw	s2,0(s0)
4001ec4c:	0a041a63          	bnez	s0,4001ed00 <tcp_recv+0xec>
	th = th_get(pkt);
4001ec50:	00048513          	mv	a0,s1
4001ec54:	b58fc0ef          	jal	ra,4001afac <th_get>
	if (th_flags(th) & SYN && !(th_flags(th) & ACK)) {
4001ec58:	00d54903          	lbu	s2,13(a0)
4001ec5c:	00297793          	andi	a5,s2,2
4001ec60:	12078663          	beqz	a5,4001ed8c <tcp_recv+0x178>
4001ec64:	01097913          	andi	s2,s2,16
4001ec68:	12091263          	bnez	s2,4001ed8c <tcp_recv+0x178>
		struct tcp *conn_old = ((struct net_context *)user_data)->tcp;
4001ec6c:	0549aa03          	lw	s4,84(s3)
	return pkt->family;
4001ec70:	0344a983          	lw	s3,52(s1)
	struct sockaddr local_addr = { 0 };
4001ec74:	01800613          	li	a2,24
4001ec78:	00000593          	li	a1,0
4001ec7c:	02810513          	addi	a0,sp,40
	struct net_context *context = NULL;
4001ec80:	00012a23          	sw	zero,20(sp)
4001ec84:	01d9d993          	srli	s3,s3,0x1d
	struct sockaddr local_addr = { 0 };
4001ec88:	be8ea0ef          	jal	ra,40009070 <memset>
	ret = net_context_get(af, SOCK_STREAM, IPPROTO_TCP, &context);
4001ec8c:	01410693          	addi	a3,sp,20
4001ec90:	00600613          	li	a2,6
4001ec94:	00100593          	li	a1,1
4001ec98:	00098513          	mv	a0,s3
4001ec9c:	845f20ef          	jal	ra,400114e0 <net_context_get>
	if (ret < 0) {
4001eca0:	0e054663          	bltz	a0,4001ed8c <tcp_recv+0x178>
	conn = context->tcp;
4001eca4:	01412783          	lw	a5,20(sp)
4001eca8:	0547a403          	lw	s0,84(a5)
	conn->iface = pkt->iface;
4001ecac:	0184a783          	lw	a5,24(s1)
	tcp_derive_rto(conn);
4001ecb0:	00040513          	mv	a0,s0
	conn->iface = pkt->iface;
4001ecb4:	00f42823          	sw	a5,16(s0)
	tcp_derive_rto(conn);
4001ecb8:	830fc0ef          	jal	ra,4001ace8 <tcp_derive_rto>
4001ecbc:	0344a783          	lw	a5,52(s1)
	if (family == AF_UNSPEC || family == AF_INET || family == AF_INET6 ||
4001ecc0:	00400693          	li	a3,4
	net_context_set_family(conn->context, net_pkt_family(pkt));
4001ecc4:	00442703          	lw	a4,4(s0)
4001ecc8:	01d7d793          	srli	a5,a5,0x1d
4001eccc:	00f6e463          	bltu	a3,a5,4001ecd4 <tcp_recv+0xc0>
		flag = family << 3;
4001ecd0:	00379913          	slli	s2,a5,0x3
	context->flags |= flag;
4001ecd4:	07475783          	lhu	a5,116(a4) # ff0074 <__rom_region_size+0xfbf698>
	if (tcp_endpoint_set(&conn->dst, pkt, TCP_EP_SRC) < 0) {
4001ecd8:	1f840a93          	addi	s5,s0,504
4001ecdc:	00100613          	li	a2,1
4001ece0:	00f96933          	or	s2,s2,a5
4001ece4:	07271a23          	sh	s2,116(a4)
4001ece8:	00048593          	mv	a1,s1
4001ecec:	000a8513          	mv	a0,s5
4001ecf0:	c38fc0ef          	jal	ra,4001b128 <tcp_endpoint_set>
4001ecf4:	06055c63          	bgez	a0,4001ed6c <tcp_recv+0x158>
		net_context_put(context);
4001ecf8:	01412503          	lw	a0,20(sp)
4001ecfc:	08c0006f          	j	4001ed88 <tcp_recv+0x174>
	return tcp_endpoint_cmp(&conn->src, pkt, TCP_EP_DST) &&
4001ed00:	00000613          	li	a2,0
4001ed04:	00048593          	mv	a1,s1
4001ed08:	1e040513          	addi	a0,s0,480
4001ed0c:	da8fc0ef          	jal	ra,4001b2b4 <tcp_endpoint_cmp>
4001ed10:	00051e63          	bnez	a0,4001ed2c <tcp_recv+0x118>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp_conns, conn, tmp, next) {
4001ed14:	00000793          	li	a5,0
4001ed18:	00090463          	beqz	s2,4001ed20 <tcp_recv+0x10c>
4001ed1c:	00092783          	lw	a5,0(s2)
4001ed20:	00090413          	mv	s0,s2
4001ed24:	00078913          	mv	s2,a5
4001ed28:	f25ff06f          	j	4001ec4c <tcp_recv+0x38>
		tcp_endpoint_cmp(&conn->dst, pkt, TCP_EP_SRC);
4001ed2c:	00100613          	li	a2,1
4001ed30:	00048593          	mv	a1,s1
4001ed34:	1f840513          	addi	a0,s0,504
4001ed38:	d7cfc0ef          	jal	ra,4001b2b4 <tcp_endpoint_cmp>
	return tcp_endpoint_cmp(&conn->src, pkt, TCP_EP_DST) &&
4001ed3c:	fc050ce3          	beqz	a0,4001ed14 <tcp_recv+0x100>
		verdict = tcp_in(conn, pkt);
4001ed40:	00040513          	mv	a0,s0
}
4001ed44:	05812403          	lw	s0,88(sp)
4001ed48:	05c12083          	lw	ra,92(sp)
4001ed4c:	05012903          	lw	s2,80(sp)
4001ed50:	04c12983          	lw	s3,76(sp)
4001ed54:	04812a03          	lw	s4,72(sp)
4001ed58:	04412a83          	lw	s5,68(sp)
		verdict = tcp_in(conn, pkt);
4001ed5c:	00048593          	mv	a1,s1
}
4001ed60:	05412483          	lw	s1,84(sp)
4001ed64:	06010113          	addi	sp,sp,96
		verdict = tcp_in(conn, pkt);
4001ed68:	cf0fe06f          	j	4001d258 <tcp_in>
	if (tcp_endpoint_set(&conn->src, pkt, TCP_EP_DST) < 0) {
4001ed6c:	00000613          	li	a2,0
4001ed70:	00048593          	mv	a1,s1
4001ed74:	1e040513          	addi	a0,s0,480
4001ed78:	bb0fc0ef          	jal	ra,4001b128 <tcp_endpoint_set>
4001ed7c:	00050793          	mv	a5,a0
4001ed80:	01412503          	lw	a0,20(sp)
4001ed84:	0207d863          	bgez	a5,4001edb4 <tcp_recv+0x1a0>
		net_context_put(context);
4001ed88:	a35f20ef          	jal	ra,400117bc <net_context_put>
}
4001ed8c:	05c12083          	lw	ra,92(sp)
4001ed90:	05812403          	lw	s0,88(sp)
4001ed94:	05412483          	lw	s1,84(sp)
4001ed98:	05012903          	lw	s2,80(sp)
4001ed9c:	04c12983          	lw	s3,76(sp)
4001eda0:	04812a03          	lw	s4,72(sp)
4001eda4:	04412a83          	lw	s5,68(sp)
4001eda8:	00200513          	li	a0,2
4001edac:	06010113          	addi	sp,sp,96
4001edb0:	00008067          	ret
	memcpy(&context->remote, &conn->dst, sizeof(context->remote));
4001edb4:	01800613          	li	a2,24
4001edb8:	000a8593          	mv	a1,s5
4001edbc:	02c50513          	addi	a0,a0,44
4001edc0:	a8cea0ef          	jal	ra,4000904c <memcpy>
	context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
4001edc4:	01412903          	lw	s2,20(sp)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
4001edc8:	00200713          	li	a4,2
	context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
4001edcc:	07495783          	lhu	a5,116(s2)
	net_sin_ptr(&context->local)->sin_family = af;
4001edd0:	03391023          	sh	s3,32(s2)
	context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
4001edd4:	1007e793          	ori	a5,a5,256
4001edd8:	06f91a23          	sh	a5,116(s2)
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
4001eddc:	0037d793          	srli	a5,a5,0x3
4001ede0:	0077f793          	andi	a5,a5,7
	local_addr.sa_family = net_context_get_family(context);
4001ede4:	02f11423          	sh	a5,40(sp)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
4001ede8:	04e79463          	bne	a5,a4,4001ee30 <tcp_recv+0x21c>
		if (net_sin6_ptr(&context->local)->sin6_addr) {
4001edec:	02492583          	lw	a1,36(s2)
4001edf0:	02058063          	beqz	a1,4001ee10 <tcp_recv+0x1fc>
			net_ipaddr_copy(&net_sin6(&local_addr)->sin6_addr,
4001edf4:	01000613          	li	a2,16
4001edf8:	01810513          	addi	a0,sp,24
4001edfc:	a50ea0ef          	jal	ra,4000904c <memcpy>
4001ee00:	01000613          	li	a2,16
4001ee04:	01810593          	addi	a1,sp,24
4001ee08:	02c10513          	addi	a0,sp,44
4001ee0c:	a40ea0ef          	jal	ra,4000904c <memcpy>
	ret = net_context_bind(context, &local_addr, sizeof(local_addr));
4001ee10:	02810593          	addi	a1,sp,40
4001ee14:	01800613          	li	a2,24
4001ee18:	00090513          	mv	a0,s2
4001ee1c:	a2df20ef          	jal	ra,40011848 <net_context_bind>
	if (ret < 0) {
4001ee20:	01412583          	lw	a1,20(sp)
4001ee24:	04055663          	bgez	a0,4001ee70 <tcp_recv+0x25c>
		net_context_put(context);
4001ee28:	00058513          	mv	a0,a1
4001ee2c:	f5dff06f          	j	4001ed88 <tcp_recv+0x174>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
4001ee30:	00100713          	li	a4,1
4001ee34:	fce79ee3          	bne	a5,a4,4001ee10 <tcp_recv+0x1fc>
		if (net_sin_ptr(&context->local)->sin_addr) {
4001ee38:	02492783          	lw	a5,36(s2)
4001ee3c:	fc078ae3          	beqz	a5,4001ee10 <tcp_recv+0x1fc>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
4001ee40:	0017c683          	lbu	a3,1(a5)
4001ee44:	0007c703          	lbu	a4,0(a5)
4001ee48:	00869693          	slli	a3,a3,0x8
4001ee4c:	00e6e6b3          	or	a3,a3,a4
4001ee50:	0027c703          	lbu	a4,2(a5)
4001ee54:	0037c783          	lbu	a5,3(a5)
4001ee58:	01071713          	slli	a4,a4,0x10
4001ee5c:	00d76733          	or	a4,a4,a3
4001ee60:	01879793          	slli	a5,a5,0x18
4001ee64:	00e7e7b3          	or	a5,a5,a4
4001ee68:	02f12623          	sw	a5,44(sp)
4001ee6c:	fa5ff06f          	j	4001ee10 <tcp_recv+0x1fc>
		conn->seq = tcp_init_isn(&local_addr, &context->remote);
4001ee70:	02c58593          	addi	a1,a1,44
4001ee74:	02810513          	addi	a0,sp,40
4001ee78:	af9fc0ef          	jal	ra,4001b970 <tcp_init_isn>
	ret = net_conn_register(IPPROTO_TCP, af,
4001ee7c:	1e245703          	lhu	a4,482(s0)
4001ee80:	1fa45683          	lhu	a3,506(s0)
				&context->remote, &local_addr,
4001ee84:	01412803          	lw	a6,20(sp)
	ret = net_conn_register(IPPROTO_TCP, af,
4001ee88:	00871793          	slli	a5,a4,0x8
4001ee8c:	00875713          	srli	a4,a4,0x8
4001ee90:	00e7e7b3          	or	a5,a5,a4
4001ee94:	00869713          	slli	a4,a3,0x8
4001ee98:	0086d693          	srli	a3,a3,0x8
4001ee9c:	00d76733          	or	a4,a4,a3
		conn->seq = tcp_init_isn(&local_addr, &context->remote);
4001eea0:	22a42423          	sw	a0,552(s0)
	ret = net_conn_register(IPPROTO_TCP, af,
4001eea4:	04480693          	addi	a3,a6,68
4001eea8:	4001f8b7          	lui	a7,0x4001f
4001eeac:	01079793          	slli	a5,a5,0x10
4001eeb0:	01071713          	slli	a4,a4,0x10
4001eeb4:	00d12223          	sw	a3,4(sp)
4001eeb8:	01012023          	sw	a6,0(sp)
4001eebc:	c1488893          	addi	a7,a7,-1004 # 4001ec14 <tcp_recv>
4001eec0:	0107d793          	srli	a5,a5,0x10
4001eec4:	01075713          	srli	a4,a4,0x10
4001eec8:	02810693          	addi	a3,sp,40
4001eecc:	02c80613          	addi	a2,a6,44
4001eed0:	00098593          	mv	a1,s3
4001eed4:	00600513          	li	a0,6
4001eed8:	c70f50ef          	jal	ra,40014348 <net_conn_register>
	if (ret < 0) {
4001eedc:	e0054ee3          	bltz	a0,4001ecf8 <tcp_recv+0xe4>
		net_ipaddr_copy(&conn_old->context->remote, &conn->dst.sa);
4001eee0:	004a2903          	lw	s2,4(s4)
4001eee4:	01800613          	li	a2,24
4001eee8:	000a8593          	mv	a1,s5
4001eeec:	02810513          	addi	a0,sp,40
4001eef0:	95cea0ef          	jal	ra,4000904c <memcpy>
4001eef4:	01800613          	li	a2,24
4001eef8:	02810593          	addi	a1,sp,40
4001eefc:	02c90513          	addi	a0,s2,44
4001ef00:	94cea0ef          	jal	ra,4000904c <memcpy>
		conn->accepted_conn = conn_old;
4001ef04:	03442023          	sw	s4,32(s0)
	if (conn) {
4001ef08:	e39ff06f          	j	4001ed40 <tcp_recv+0x12c>

4001ef0c <net_tcp_state_str>:
	switch (state) {
4001ef0c:	fff50513          	addi	a0,a0,-1
4001ef10:	00a00793          	li	a5,10
4001ef14:	02a7e063          	bltu	a5,a0,4001ef34 <net_tcp_state_str+0x28>
4001ef18:	4002d7b7          	lui	a5,0x4002d
4001ef1c:	00251513          	slli	a0,a0,0x2
4001ef20:	5dc78793          	addi	a5,a5,1500 # 4002d5dc <CSWTCH.14405>
4001ef24:	00a787b3          	add	a5,a5,a0
4001ef28:	0007a503          	lw	a0,0(a5)
}

const char *net_tcp_state_str(enum tcp_state state)
{
	return tcp_state_to_str(state, false);
}
4001ef2c:	00450513          	addi	a0,a0,4
4001ef30:	00008067          	ret
{
4001ef34:	00000513          	li	a0,0
4001ef38:	ff5ff06f          	j	4001ef2c <net_tcp_state_str+0x20>

4001ef3c <net_tcp_init>:

	return &conn->connect_sem;
}

void net_tcp_init(void)
{
4001ef3c:	ff010113          	addi	sp,sp,-16
4001ef40:	00812423          	sw	s0,8(sp)
#define THREAD_PRIORITY K_PRIO_PREEMPT(0)
#endif

	/* Use private workqueue in order not to block the system work queue.
	 */
	k_work_queue_start(&tcp_work_q, work_q_stack,
4001ef44:	400345b7          	lui	a1,0x40034
4001ef48:	40031437          	lui	s0,0x40031
4001ef4c:	00000713          	li	a4,0
4001ef50:	ff000693          	li	a3,-16
4001ef54:	40000613          	li	a2,1024
4001ef58:	17058593          	addi	a1,a1,368 # 40034170 <work_q_stack>
4001ef5c:	10840513          	addi	a0,s0,264 # 40031108 <tcp_work_q>
{
4001ef60:	00112623          	sw	ra,12(sp)
	k_work_queue_start(&tcp_work_q, work_q_stack,
4001ef64:	4c00a0ef          	jal	ra,40029424 <k_work_queue_start>
4001ef68:	00900693          	li	a3,9
4001ef6c:	00000793          	li	a5,0
			   K_KERNEL_STACK_SIZEOF(work_q_stack), THREAD_PRIORITY,
			   NULL);

	/* Compute the largest possible retransmission timeout */
	tcp_fin_timeout_ms = 0;
	rto = tcp_rto;
4001ef70:	0c800713          	li	a4,200
	for (i = 0; i < tcp_retries; i++) {
		tcp_fin_timeout_ms += rto;
		rto += rto >> 1;
4001ef74:	40175613          	srai	a2,a4,0x1
	for (i = 0; i < tcp_retries; i++) {
4001ef78:	fff68693          	addi	a3,a3,-1 # feffff <__rom_region_size+0xfbf623>
		tcp_fin_timeout_ms += rto;
4001ef7c:	00e787b3          	add	a5,a5,a4
		rto += rto >> 1;
4001ef80:	00c70733          	add	a4,a4,a2
	for (i = 0; i < tcp_retries; i++) {
4001ef84:	fe0698e3          	bnez	a3,4001ef74 <net_tcp_init+0x38>
	}
	/* At the last timeout cicle */
	tcp_fin_timeout_ms += tcp_rto;
4001ef88:	0c878793          	addi	a5,a5,200

	/* When CONFIG_NET_TCP_RANDOMIZED_RTO is active in can be worse case 1.5 times larger */
	if (IS_ENABLED(CONFIG_NET_TCP_RANDOMIZED_RTO)) {
		tcp_fin_timeout_ms += tcp_fin_timeout_ms >> 1;
4001ef8c:	4017d713          	srai	a4,a5,0x1
4001ef90:	00f707b3          	add	a5,a4,a5
4001ef94:	40031737          	lui	a4,0x40031
4001ef98:	acf72623          	sw	a5,-1332(a4) # 40030acc <tcp_fin_timeout_ms>
	return z_impl_k_thread_name_set(thread, str);
4001ef9c:	10840513          	addi	a0,s0,264
	}

	k_thread_name_set(&tcp_work_q.thread, "tcp_work");
	NET_DBG("Workq started. Thread ID: %p", &tcp_work_q.thread);
}
4001efa0:	00812403          	lw	s0,8(sp)
4001efa4:	00c12083          	lw	ra,12(sp)
4001efa8:	4002d5b7          	lui	a1,0x4002d
4001efac:	52058593          	addi	a1,a1,1312 # 4002d520 <CSWTCH.15321+0xd8>
4001efb0:	01010113          	addi	sp,sp,16
4001efb4:	1700906f          	j	40028124 <z_impl_k_thread_name_set>

4001efb8 <net_udp_create>:
#include "net_stats.h"

#define PKT_WAIT_TIME K_SECONDS(1)

int net_udp_create(struct net_pkt *pkt, uint16_t src_port, uint16_t dst_port)
{
4001efb8:	fe010113          	addi	sp,sp,-32
4001efbc:	00912a23          	sw	s1,20(sp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
4001efc0:	00800793          	li	a5,8
{
4001efc4:	00058493          	mv	s1,a1
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
4001efc8:	00810593          	addi	a1,sp,8
{
4001efcc:	00812c23          	sw	s0,24(sp)
4001efd0:	01212823          	sw	s2,16(sp)
4001efd4:	00112e23          	sw	ra,28(sp)
4001efd8:	00050913          	mv	s2,a0
4001efdc:	00060413          	mv	s0,a2
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
4001efe0:	00212423          	sw	sp,8(sp)
4001efe4:	00f12623          	sw	a5,12(sp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
4001efe8:	f95f40ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!udp_hdr) {
4001efec:	04050863          	beqz	a0,4001f03c <net_udp_create+0x84>
		return -ENOBUFS;
	}

	udp_hdr->src_port = src_port;
4001eff0:	00950023          	sb	s1,0(a0)
	udp_hdr->dst_port = dst_port;
4001eff4:	00850123          	sb	s0,2(a0)
	udp_hdr->src_port = src_port;
4001eff8:	0084d493          	srli	s1,s1,0x8
	udp_hdr->dst_port = dst_port;
4001effc:	00845413          	srli	s0,s0,0x8
	udp_hdr->src_port = src_port;
4001f000:	009500a3          	sb	s1,1(a0)
	udp_hdr->dst_port = dst_port;
4001f004:	008501a3          	sb	s0,3(a0)
	udp_hdr->len      = 0U;
4001f008:	00050223          	sb	zero,4(a0)
4001f00c:	000502a3          	sb	zero,5(a0)
	udp_hdr->chksum   = 0U;
4001f010:	00050323          	sb	zero,6(a0)
4001f014:	000503a3          	sb	zero,7(a0)

	return net_pkt_set_data(pkt, &udp_access);
4001f018:	00810593          	addi	a1,sp,8
4001f01c:	00090513          	mv	a0,s2
4001f020:	fedf40ef          	jal	ra,4001400c <net_pkt_set_data>
}
4001f024:	01c12083          	lw	ra,28(sp)
4001f028:	01812403          	lw	s0,24(sp)
4001f02c:	01412483          	lw	s1,20(sp)
4001f030:	01012903          	lw	s2,16(sp)
4001f034:	02010113          	addi	sp,sp,32
4001f038:	00008067          	ret
		return -ENOBUFS;
4001f03c:	f9700513          	li	a0,-105
4001f040:	fe5ff06f          	j	4001f024 <net_udp_create+0x6c>

4001f044 <net_udp_finalize>:

int net_udp_finalize(struct net_pkt *pkt)
{
4001f044:	fe010113          	addi	sp,sp,-32
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
4001f048:	00800793          	li	a5,8
	struct net_udp_hdr *udp_hdr;
	uint16_t length = 0;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
4001f04c:	00810593          	addi	a1,sp,8
{
4001f050:	00812c23          	sw	s0,24(sp)
4001f054:	00112e23          	sw	ra,28(sp)
4001f058:	00912a23          	sw	s1,20(sp)
4001f05c:	00050413          	mv	s0,a0
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
4001f060:	00212423          	sw	sp,8(sp)
4001f064:	00f12623          	sw	a5,12(sp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
4001f068:	f15f40ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!udp_hdr) {
4001f06c:	0a050663          	beqz	a0,4001f118 <net_udp_finalize+0xd4>
4001f070:	00842703          	lw	a4,8(s0)
4001f074:	00050493          	mv	s1,a0
	size_t bytes = 0;
4001f078:	00000793          	li	a5,0
	while (buf) {
4001f07c:	08071663          	bnez	a4,4001f108 <net_udp_finalize+0xc4>
		return -ENOBUFS;
	}

	length = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -
4001f080:	03644683          	lbu	a3,54(s0)
4001f084:	03a45703          	lhu	a4,58(s0)
4001f088:	00d70733          	add	a4,a4,a3
4001f08c:	40e787b3          	sub	a5,a5,a4
		 net_pkt_ip_opts_len(pkt);

	udp_hdr->len = htons(length);
4001f090:	00879713          	slli	a4,a5,0x8
4001f094:	01079793          	slli	a5,a5,0x10
4001f098:	0107d793          	srli	a5,a5,0x10
4001f09c:	0087d793          	srli	a5,a5,0x8
4001f0a0:	00f767b3          	or	a5,a4,a5
4001f0a4:	01079713          	slli	a4,a5,0x10
4001f0a8:	01075713          	srli	a4,a4,0x10
4001f0ac:	00f48223          	sb	a5,4(s1)
4001f0b0:	00875793          	srli	a5,a4,0x8
4001f0b4:	00f482a3          	sb	a5,5(s1)

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
4001f0b8:	01842503          	lw	a0,24(s0)
4001f0bc:	d14f00ef          	jal	ra,4000f5d0 <net_if_need_calc_tx_checksum>
4001f0c0:	02050463          	beqz	a0,4001f0e8 <net_udp_finalize+0xa4>
	uint16_t chksum = net_calc_chksum(pkt, IPPROTO_UDP);
4001f0c4:	01100593          	li	a1,17
4001f0c8:	00040513          	mv	a0,s0
4001f0cc:	e88f10ef          	jal	ra,40010754 <net_calc_chksum>
	return chksum == 0U ? 0xffff : chksum;
4001f0d0:	00051663          	bnez	a0,4001f0dc <net_udp_finalize+0x98>
4001f0d4:	000107b7          	lui	a5,0x10
4001f0d8:	fff78513          	addi	a0,a5,-1 # ffff <__kernel_ram_size+0x3d6b>
		udp_hdr->chksum = net_calc_chksum_udp(pkt);
4001f0dc:	00855793          	srli	a5,a0,0x8
4001f0e0:	00a48323          	sb	a0,6(s1)
4001f0e4:	00f483a3          	sb	a5,7(s1)
	}

	return net_pkt_set_data(pkt, &udp_access);
4001f0e8:	00810593          	addi	a1,sp,8
4001f0ec:	00040513          	mv	a0,s0
4001f0f0:	f1df40ef          	jal	ra,4001400c <net_pkt_set_data>
}
4001f0f4:	01c12083          	lw	ra,28(sp)
4001f0f8:	01812403          	lw	s0,24(sp)
4001f0fc:	01412483          	lw	s1,20(sp)
4001f100:	02010113          	addi	sp,sp,32
4001f104:	00008067          	ret
		bytes += buf->len;
4001f108:	01075683          	lhu	a3,16(a4)
		buf = buf->frags;
4001f10c:	00472703          	lw	a4,4(a4)
		bytes += buf->len;
4001f110:	00d787b3          	add	a5,a5,a3
		buf = buf->frags;
4001f114:	f69ff06f          	j	4001f07c <net_udp_finalize+0x38>
		return -ENOBUFS;
4001f118:	f9700513          	li	a0,-105
4001f11c:	fd9ff06f          	j	4001f0f4 <net_udp_finalize+0xb0>

4001f120 <net_udp_input>:
	return net_conn_unregister(handle);
}

struct net_udp_hdr *net_udp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *udp_access)
{
4001f120:	ff010113          	addi	sp,sp,-16
4001f124:	00912223          	sw	s1,4(sp)
4001f128:	01212023          	sw	s2,0(sp)
4001f12c:	00112623          	sw	ra,12(sp)
4001f130:	00812423          	sw	s0,8(sp)
4001f134:	00050493          	mv	s1,a0
4001f138:	00058913          	mv	s2,a1
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);
4001f13c:	e41f40ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
4001f140:	02051263          	bnez	a0,4001f164 <net_udp_input+0x44>
	}
out:
	return udp_hdr;
drop:
	net_stats_update_udp_chkerr(net_pkt_iface(pkt));
	return NULL;
4001f144:	00000413          	li	s0,0
}
4001f148:	00c12083          	lw	ra,12(sp)
4001f14c:	00040513          	mv	a0,s0
4001f150:	00812403          	lw	s0,8(sp)
4001f154:	00412483          	lw	s1,4(sp)
4001f158:	00012903          	lw	s2,0(sp)
4001f15c:	01010113          	addi	sp,sp,16
4001f160:	00008067          	ret
4001f164:	00050413          	mv	s0,a0
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
4001f168:	00090593          	mv	a1,s2
4001f16c:	00048513          	mv	a0,s1
4001f170:	e9df40ef          	jal	ra,4001400c <net_pkt_set_data>
4001f174:	fc0518e3          	bnez	a0,4001f144 <net_udp_input+0x24>
	if (ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -
4001f178:	00544783          	lbu	a5,5(s0)
4001f17c:	00444703          	lbu	a4,4(s0)
4001f180:	0084a683          	lw	a3,8(s1)
4001f184:	00879793          	slli	a5,a5,0x8
4001f188:	00e7e7b3          	or	a5,a5,a4
4001f18c:	00879713          	slli	a4,a5,0x8
4001f190:	0087d793          	srli	a5,a5,0x8
4001f194:	00f76733          	or	a4,a4,a5
4001f198:	01071713          	slli	a4,a4,0x10
4001f19c:	01075713          	srli	a4,a4,0x10
	size_t bytes = 0;
4001f1a0:	00000793          	li	a5,0
	while (buf) {
4001f1a4:	04069663          	bnez	a3,4001f1f0 <net_udp_input+0xd0>
				    net_pkt_ip_hdr_len(pkt) -
4001f1a8:	0364c683          	lbu	a3,54(s1)
				    net_pkt_ip_opts_len(pkt))) {
4001f1ac:	03a4d603          	lhu	a2,58(s1)
				    net_pkt_ip_hdr_len(pkt) -
4001f1b0:	00c686b3          	add	a3,a3,a2
4001f1b4:	40d787b3          	sub	a5,a5,a3
	if (ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -
4001f1b8:	f8f716e3          	bne	a4,a5,4001f144 <net_udp_input+0x24>
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
4001f1bc:	0184a503          	lw	a0,24(s1)
4001f1c0:	c18f00ef          	jal	ra,4000f5d8 <net_if_need_calc_rx_checksum>
	if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
4001f1c4:	f80502e3          	beqz	a0,4001f148 <net_udp_input+0x28>
		if (!udp_hdr->chksum) {
4001f1c8:	00744783          	lbu	a5,7(s0)
4001f1cc:	00644703          	lbu	a4,6(s0)
4001f1d0:	00879793          	slli	a5,a5,0x8
4001f1d4:	00e7e7b3          	or	a5,a5,a4
4001f1d8:	f60786e3          	beqz	a5,4001f144 <net_udp_input+0x24>
	return net_calc_chksum(pkt, IPPROTO_UDP);
4001f1dc:	01100593          	li	a1,17
4001f1e0:	00048513          	mv	a0,s1
4001f1e4:	d70f10ef          	jal	ra,40010754 <net_calc_chksum>
		if (net_calc_verify_chksum_udp(pkt) != 0U) {
4001f1e8:	f60500e3          	beqz	a0,4001f148 <net_udp_input+0x28>
4001f1ec:	f59ff06f          	j	4001f144 <net_udp_input+0x24>
		bytes += buf->len;
4001f1f0:	0106d603          	lhu	a2,16(a3)
		buf = buf->frags;
4001f1f4:	0046a683          	lw	a3,4(a3)
		bytes += buf->len;
4001f1f8:	00c787b3          	add	a5,a5,a2
		buf = buf->frags;
4001f1fc:	fa9ff06f          	j	4001f1a4 <net_udp_input+0x84>

4001f200 <is_pkt_part_of_slab>:
{
	size_t last_offset = (slab->num_blocks - 1) * slab->block_size;
	size_t ptr_offset;

	/* Check if pointer fits into slab buffer area. */
	if ((ptr < slab->buffer) || (ptr > slab->buffer + last_offset)) {
4001f200:	01052703          	lw	a4,16(a0)
4001f204:	02e5e863          	bltu	a1,a4,4001f234 <is_pkt_part_of_slab+0x34>
	size_t last_offset = (slab->num_blocks - 1) * slab->block_size;
4001f208:	00852783          	lw	a5,8(a0)
4001f20c:	00c52683          	lw	a3,12(a0)
		return false;
4001f210:	00000513          	li	a0,0
	size_t last_offset = (slab->num_blocks - 1) * slab->block_size;
4001f214:	fff78793          	addi	a5,a5,-1
4001f218:	02d787b3          	mul	a5,a5,a3
	if ((ptr < slab->buffer) || (ptr > slab->buffer + last_offset)) {
4001f21c:	00f707b3          	add	a5,a4,a5
4001f220:	00b7ec63          	bltu	a5,a1,4001f238 <is_pkt_part_of_slab+0x38>
	}

	/* Check if pointer offset is correct. */
	ptr_offset = ptr - slab->buffer;
4001f224:	40e585b3          	sub	a1,a1,a4
	if (ptr_offset % slab->block_size != 0) {
4001f228:	02d5f5b3          	remu	a1,a1,a3
4001f22c:	0015b513          	seqz	a0,a1
4001f230:	00008067          	ret
		return false;
4001f234:	00000513          	li	a0,0
		return false;
	}

	return true;
}
4001f238:	00008067          	ret

4001f23c <cmd_net_tcp>:
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	return 0;
}
4001f23c:	00000513          	li	a0,0
4001f240:	00008067          	ret

4001f244 <net_if_get_by_index>:
4001f244:	889ed06f          	j	4000cacc <z_impl_net_if_get_by_index>

4001f248 <nbr_address_get>:
SHELL_DYNAMIC_CMD_CREATE(nbr_address, nbr_address_get);

#define NBR_ADDRESS_CMD &nbr_address

static void nbr_address_get(size_t idx, struct shell_static_entry *entry)
{
4001f248:	fe010113          	addi	sp,sp,-32
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &nbr_address;
4001f24c:	4002c7b7          	lui	a5,0x4002c
{
4001f250:	00812c23          	sw	s0,24(sp)
4001f254:	00912a23          	sw	s1,20(sp)
4001f258:	00112e23          	sw	ra,28(sp)
	entry->subcmd = &nbr_address;
4001f25c:	ae478793          	addi	a5,a5,-1308 # 4002bae4 <nbr_address>
	entry->handler = NULL;
4001f260:	0005a623          	sw	zero,12(a1)
	entry->help  = NULL;
4001f264:	0005a223          	sw	zero,4(a1)
	entry->subcmd = &nbr_address;
4001f268:	00f5a423          	sw	a5,8(a1)
{
4001f26c:	00050413          	mv	s0,a0
4001f270:	00058493          	mv	s1,a1
	if (idx == 0) {
4001f274:	04051663          	bnez	a0,4001f2c0 <nbr_address_get+0x78>
		memset(nbr_address_buffer, 0, sizeof(nbr_address_buffer));
4001f278:	40032537          	lui	a0,0x40032
4001f27c:	00000593          	li	a1,0
4001f280:	14000613          	li	a2,320
4001f284:	6a850513          	addi	a0,a0,1704 # 400326a8 <nbr_address_buffer>
4001f288:	de9e90ef          	jal	ra,40009070 <memset>
	net_ipv6_nbr_foreach(nbr_address_cb, &count);
4001f28c:	4001f537          	lui	a0,0x4001f
4001f290:	00c10593          	addi	a1,sp,12
4001f294:	2e450513          	addi	a0,a0,740 # 4001f2e4 <nbr_address_cb>
	int count = 0;
4001f298:	00012623          	sw	zero,12(sp)
	net_ipv6_nbr_foreach(nbr_address_cb, &count);
4001f29c:	f30f80ef          	jal	ra,400179cc <net_ipv6_nbr_foreach>
	if (!nbr_address_buffer[idx][0]) {
4001f2a0:	02800713          	li	a4,40
4001f2a4:	02e40433          	mul	s0,s0,a4
4001f2a8:	400327b7          	lui	a5,0x40032
4001f2ac:	6a878793          	addi	a5,a5,1704 # 400326a8 <nbr_address_buffer>
4001f2b0:	008787b3          	add	a5,a5,s0
4001f2b4:	0007c703          	lbu	a4,0(a5)
4001f2b8:	00071a63          	bnez	a4,4001f2cc <nbr_address_get+0x84>
4001f2bc:	00c0006f          	j	4001f2c8 <nbr_address_get+0x80>
	if (idx >= CONFIG_NET_IPV6_MAX_NEIGHBORS) {
4001f2c0:	00700793          	li	a5,7
4001f2c4:	fca7fee3          	bgeu	a5,a0,4001f2a0 <nbr_address_get+0x58>
		return NULL;
4001f2c8:	00000793          	li	a5,0
	entry->syntax = set_nbr_address(idx);
4001f2cc:	00f4a023          	sw	a5,0(s1)
}
4001f2d0:	01c12083          	lw	ra,28(sp)
4001f2d4:	01812403          	lw	s0,24(sp)
4001f2d8:	01412483          	lw	s1,20(sp)
4001f2dc:	02010113          	addi	sp,sp,32
4001f2e0:	00008067          	ret

4001f2e4 <nbr_address_cb>:
{
4001f2e4:	ff010113          	addi	sp,sp,-16
4001f2e8:	00112623          	sw	ra,12(sp)
4001f2ec:	00812423          	sw	s0,8(sp)
4001f2f0:	00912223          	sw	s1,4(sp)
	if (*count >= CONFIG_NET_IPV6_MAX_NEIGHBORS) {
4001f2f4:	0005a483          	lw	s1,0(a1)
4001f2f8:	00700793          	li	a5,7
4001f2fc:	0497c663          	blt	a5,s1,4001f348 <nbr_address_cb+0x64>
4001f300:	00058413          	mv	s0,a1
		 "%s", net_sprint_ipv6_addr(&net_ipv6_nbr_data(nbr)->addr));
4001f304:	00c52583          	lw	a1,12(a0)
	snprintk(nbr_address_buffer[*count], NET_IPV6_ADDR_LEN,
4001f308:	00200513          	li	a0,2
4001f30c:	00458593          	addi	a1,a1,4
4001f310:	e09f00ef          	jal	ra,40010118 <net_sprint_addr>
4001f314:	02800793          	li	a5,40
4001f318:	02f484b3          	mul	s1,s1,a5
4001f31c:	00050693          	mv	a3,a0
4001f320:	40032537          	lui	a0,0x40032
4001f324:	4002c637          	lui	a2,0x4002c
4001f328:	6a850513          	addi	a0,a0,1704 # 400326a8 <nbr_address_buffer>
4001f32c:	78460613          	addi	a2,a2,1924 # 4002c784 <shell_telnet_fprintf+0x128>
4001f330:	02800593          	li	a1,40
4001f334:	00950533          	add	a0,a0,s1
4001f338:	c91e10ef          	jal	ra,40000fc8 <snprintk>
	(*count)++;
4001f33c:	00042783          	lw	a5,0(s0)
4001f340:	00178793          	addi	a5,a5,1
4001f344:	00f42023          	sw	a5,0(s0)
}
4001f348:	00c12083          	lw	ra,12(sp)
4001f34c:	00812403          	lw	s0,8(sp)
4001f350:	00412483          	lw	s1,4(sp)
4001f354:	01010113          	addi	sp,sp,16
4001f358:	00008067          	ret

4001f35c <cmd_net_websocket>:
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_WEBSOCKET_CLIENT",
4001f35c:	4002d737          	lui	a4,0x4002d
4001f360:	4002d6b7          	lui	a3,0x4002d
4001f364:	4002d637          	lui	a2,0x4002d
{
4001f368:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_WEBSOCKET_CLIENT",
4001f36c:	61070713          	addi	a4,a4,1552 # 4002d610 <CSWTCH.14405+0x34>
4001f370:	61c68693          	addi	a3,a3,1564 # 4002d61c <CSWTCH.14405+0x40>
4001f374:	63460613          	addi	a2,a2,1588 # 4002d634 <CSWTCH.14405+0x58>
4001f378:	00200593          	li	a1,2
{
4001f37c:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_WEBSOCKET_CLIENT",
4001f380:	931e60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f384:	00c12083          	lw	ra,12(sp)
4001f388:	00000513          	li	a0,0
4001f38c:	01010113          	addi	sp,sp,16
4001f390:	00008067          	ret

4001f394 <cmd_net_vlan>:
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_VLAN", "VLAN");
4001f394:	4002d737          	lui	a4,0x4002d
4001f398:	4002d6b7          	lui	a3,0x4002d
4001f39c:	4002d637          	lui	a2,0x4002d
{
4001f3a0:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_VLAN", "VLAN");
4001f3a4:	65470713          	addi	a4,a4,1620 # 4002d654 <CSWTCH.14405+0x78>
4001f3a8:	65c68693          	addi	a3,a3,1628 # 4002d65c <CSWTCH.14405+0x80>
4001f3ac:	63460613          	addi	a2,a2,1588 # 4002d634 <CSWTCH.14405+0x58>
4001f3b0:	00200593          	li	a1,2
{
4001f3b4:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_VLAN", "VLAN");
4001f3b8:	8f9e60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f3bc:	00c12083          	lw	ra,12(sp)
4001f3c0:	00000513          	li	a0,0
4001f3c4:	01010113          	addi	sp,sp,16
4001f3c8:	00008067          	ret

4001f3cc <cmd_net_vlan_add>:
static int cmd_net_vlan_add(const struct shell *sh, size_t argc,
4001f3cc:	fc9ff06f          	j	4001f394 <cmd_net_vlan>

4001f3d0 <cmd_net_vlan_del>:
static int cmd_net_vlan_del(const struct shell *sh, size_t argc,
4001f3d0:	fc5ff06f          	j	4001f394 <cmd_net_vlan>

4001f3d4 <cmd_net_virtual>:
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_VIRTUAL",
4001f3d4:	4002d737          	lui	a4,0x4002d
4001f3d8:	4002d6b7          	lui	a3,0x4002d
4001f3dc:	4002d637          	lui	a2,0x4002d
{
4001f3e0:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_VIRTUAL",
4001f3e4:	66c70713          	addi	a4,a4,1644 # 4002d66c <CSWTCH.14405+0x90>
4001f3e8:	68868693          	addi	a3,a3,1672 # 4002d688 <CSWTCH.14405+0xac>
4001f3ec:	63460613          	addi	a2,a2,1588 # 4002d634 <CSWTCH.14405+0x58>
4001f3f0:	00200593          	li	a1,2
{
4001f3f4:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_VIRTUAL",
4001f3f8:	8b9e60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f3fc:	00c12083          	lw	ra,12(sp)
4001f400:	00000513          	li	a0,0
4001f404:	01010113          	addi	sp,sp,16
4001f408:	00008067          	ret

4001f40c <tcp_sent_cb>:
	PR_SHELL(tcp_shell, "Message sent\n");
4001f40c:	400317b7          	lui	a5,0x40031
4001f410:	adc7a503          	lw	a0,-1316(a5) # 40030adc <tcp_shell>
4001f414:	4002d637          	lui	a2,0x4002d
4001f418:	6a060613          	addi	a2,a2,1696 # 4002d6a0 <CSWTCH.14405+0xc4>
4001f41c:	00800593          	li	a1,8
4001f420:	891e606f          	j	40005cb0 <shell_fprintf>

4001f424 <cmd_net_suspend>:
	PR_INFO("You need a network driver supporting Power Management.\n");
4001f424:	4002d637          	lui	a2,0x4002d
{
4001f428:	ff010113          	addi	sp,sp,-16
	PR_INFO("You need a network driver supporting Power Management.\n");
4001f42c:	6b060613          	addi	a2,a2,1712 # 4002d6b0 <CSWTCH.14405+0xd4>
4001f430:	00200593          	li	a1,2
{
4001f434:	00112623          	sw	ra,12(sp)
	PR_INFO("You need a network driver supporting Power Management.\n");
4001f438:	879e60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f43c:	00c12083          	lw	ra,12(sp)
4001f440:	00000513          	li	a0,0
4001f444:	01010113          	addi	sp,sp,16
4001f448:	00008067          	ret

4001f44c <cmd_net_stats_all>:
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_STATISTICS",
4001f44c:	4002d737          	lui	a4,0x4002d
4001f450:	4002d6b7          	lui	a3,0x4002d
4001f454:	4002d637          	lui	a2,0x4002d
{
4001f458:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_STATISTICS",
4001f45c:	6e870713          	addi	a4,a4,1768 # 4002d6e8 <CSWTCH.14405+0x10c>
4001f460:	6f468693          	addi	a3,a3,1780 # 4002d6f4 <CSWTCH.14405+0x118>
4001f464:	63460613          	addi	a2,a2,1588 # 4002d634 <CSWTCH.14405+0x58>
4001f468:	00200593          	li	a1,2
{
4001f46c:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_STATISTICS",
4001f470:	841e60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f474:	00c12083          	lw	ra,12(sp)
4001f478:	00000513          	li	a0,0
4001f47c:	01010113          	addi	sp,sp,16
4001f480:	00008067          	ret

4001f484 <cmd_net_stats_iface>:
static int cmd_net_stats_iface(const struct shell *sh, size_t argc,
4001f484:	fc9ff06f          	j	4001f44c <cmd_net_stats_all>

4001f488 <cmd_net_stats>:
static int cmd_net_stats(const struct shell *sh, size_t argc, char *argv[])
4001f488:	fc5ff06f          	j	4001f44c <cmd_net_stats_all>

4001f48c <cmd_net_stacks>:
	PR("Type \"kernel stacks\" to see stack information.\n");
4001f48c:	4002d637          	lui	a2,0x4002d
{
4001f490:	ff010113          	addi	sp,sp,-16
	PR("Type \"kernel stacks\" to see stack information.\n");
4001f494:	70c60613          	addi	a2,a2,1804 # 4002d70c <CSWTCH.14405+0x130>
4001f498:	00800593          	li	a1,8
{
4001f49c:	00112623          	sw	ra,12(sp)
	PR("Type \"kernel stacks\" to see stack information.\n");
4001f4a0:	811e60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f4a4:	00c12083          	lw	ra,12(sp)
4001f4a8:	00000513          	li	a0,0
4001f4ac:	01010113          	addi	sp,sp,16
4001f4b0:	00008067          	ret

4001f4b4 <cmd_net_ppp_status>:
	PR_INFO("Set %s to enable %s support.\n",
4001f4b4:	4002d737          	lui	a4,0x4002d
4001f4b8:	4002d6b7          	lui	a3,0x4002d
4001f4bc:	4002d637          	lui	a2,0x4002d
{
4001f4c0:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n",
4001f4c4:	73c70713          	addi	a4,a4,1852 # 4002d73c <CSWTCH.14405+0x160>
4001f4c8:	74068693          	addi	a3,a3,1856 # 4002d740 <CSWTCH.14405+0x164>
4001f4cc:	63460613          	addi	a2,a2,1588 # 4002d634 <CSWTCH.14405+0x58>
4001f4d0:	00200593          	li	a1,2
{
4001f4d4:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n",
4001f4d8:	fd8e60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f4dc:	00c12083          	lw	ra,12(sp)
4001f4e0:	00000513          	li	a0,0
4001f4e4:	01010113          	addi	sp,sp,16
4001f4e8:	00008067          	ret

4001f4ec <cmd_net_ppp_ping>:
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_PPP", "PPP");
4001f4ec:	4002d737          	lui	a4,0x4002d
4001f4f0:	4002d6b7          	lui	a3,0x4002d
4001f4f4:	4002d637          	lui	a2,0x4002d
{
4001f4f8:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_PPP", "PPP");
4001f4fc:	73c70713          	addi	a4,a4,1852 # 4002d73c <CSWTCH.14405+0x160>
4001f500:	76868693          	addi	a3,a3,1896 # 4002d768 <CSWTCH.14405+0x18c>
4001f504:	63460613          	addi	a2,a2,1588 # 4002d634 <CSWTCH.14405+0x58>
4001f508:	00200593          	li	a1,2
{
4001f50c:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_PPP", "PPP");
4001f510:	fa0e60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f514:	00c12083          	lw	ra,12(sp)
4001f518:	00000513          	li	a0,0
4001f51c:	01010113          	addi	sp,sp,16
4001f520:	00008067          	ret

4001f524 <cmd_net_set_mac>:
	PR_WARNING("Unsupported command, please enable CONFIG_NET_L2_ETHERNET "
4001f524:	4002d637          	lui	a2,0x4002d
{
4001f528:	ff010113          	addi	sp,sp,-16
	PR_WARNING("Unsupported command, please enable CONFIG_NET_L2_ETHERNET "
4001f52c:	77c60613          	addi	a2,a2,1916 # 4002d77c <CSWTCH.14405+0x1a0>
4001f530:	00300593          	li	a1,3
{
4001f534:	00112623          	sw	ra,12(sp)
	PR_WARNING("Unsupported command, please enable CONFIG_NET_L2_ETHERNET "
4001f538:	f78e60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f53c:	00c12083          	lw	ra,12(sp)
4001f540:	ff800513          	li	a0,-8
4001f544:	01010113          	addi	sp,sp,16
4001f548:	00008067          	ret

4001f54c <cmd_net_gptp_port>:
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_GPTP", "gPTP");
4001f54c:	4002d737          	lui	a4,0x4002d
4001f550:	4002d6b7          	lui	a3,0x4002d
4001f554:	4002d637          	lui	a2,0x4002d
{
4001f558:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_GPTP", "gPTP");
4001f55c:	7d870713          	addi	a4,a4,2008 # 4002d7d8 <CSWTCH.14405+0x1fc>
4001f560:	7e068693          	addi	a3,a3,2016 # 4002d7e0 <CSWTCH.14405+0x204>
4001f564:	63460613          	addi	a2,a2,1588 # 4002d634 <CSWTCH.14405+0x58>
4001f568:	00200593          	li	a1,2
{
4001f56c:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_GPTP", "gPTP");
4001f570:	f40e60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f574:	00c12083          	lw	ra,12(sp)
4001f578:	00000513          	li	a0,0
4001f57c:	01010113          	addi	sp,sp,16
4001f580:	00008067          	ret

4001f584 <cmd_net_gptp>:
static int cmd_net_gptp(const struct shell *sh, size_t argc, char *argv[])
4001f584:	fc9ff06f          	j	4001f54c <cmd_net_gptp_port>

4001f588 <cmd_net_events_on>:
	PR_INFO("Network management events are not supported. "
4001f588:	4002d637          	lui	a2,0x4002d
{
4001f58c:	ff010113          	addi	sp,sp,-16
	PR_INFO("Network management events are not supported. "
4001f590:	7f060613          	addi	a2,a2,2032 # 4002d7f0 <CSWTCH.14405+0x214>
4001f594:	00200593          	li	a1,2
{
4001f598:	00112623          	sw	ra,12(sp)
	PR_INFO("Network management events are not supported. "
4001f59c:	f14e60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f5a0:	00c12083          	lw	ra,12(sp)
4001f5a4:	00000513          	li	a0,0
4001f5a8:	01010113          	addi	sp,sp,16
4001f5ac:	00008067          	ret

4001f5b0 <cmd_net_capture>:
	PR_INFO("Set %s to enable %s support.\n",
4001f5b0:	4002e737          	lui	a4,0x4002e
4001f5b4:	4002e6b7          	lui	a3,0x4002e
4001f5b8:	4002d637          	lui	a2,0x4002d
{
4001f5bc:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n",
4001f5c0:	85070713          	addi	a4,a4,-1968 # 4002d850 <CSWTCH.14405+0x274>
4001f5c4:	86868693          	addi	a3,a3,-1944 # 4002d868 <CSWTCH.14405+0x28c>
4001f5c8:	63460613          	addi	a2,a2,1588 # 4002d634 <CSWTCH.14405+0x58>
4001f5cc:	00200593          	li	a1,2
{
4001f5d0:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n",
4001f5d4:	edce60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f5d8:	00c12083          	lw	ra,12(sp)
4001f5dc:	00000513          	li	a0,0
4001f5e0:	01010113          	addi	sp,sp,16
4001f5e4:	00008067          	ret

4001f5e8 <cmd_net_capture_setup>:
static int cmd_net_capture_setup(const struct shell *sh, size_t argc,
4001f5e8:	fc9ff06f          	j	4001f5b0 <cmd_net_capture>

4001f5ec <cmd_net_capture_cleanup>:
static int cmd_net_capture_cleanup(const struct shell *sh, size_t argc,
4001f5ec:	fc5ff06f          	j	4001f5b0 <cmd_net_capture>

4001f5f0 <cmd_net_capture_enable>:
static int cmd_net_capture_enable(const struct shell *sh, size_t argc,
4001f5f0:	fc1ff06f          	j	4001f5b0 <cmd_net_capture>

4001f5f4 <cmd_net_capture_disable>:
static int cmd_net_capture_disable(const struct shell *sh, size_t argc,
4001f5f4:	fbdff06f          	j	4001f5b0 <cmd_net_capture>

4001f5f8 <cmd_net_allocs>:
	PR_INFO("Set %s to enable %s support.\n",
4001f5f8:	4002e737          	lui	a4,0x4002e
4001f5fc:	4002e6b7          	lui	a3,0x4002e
4001f600:	4002d637          	lui	a2,0x4002d
{
4001f604:	ff010113          	addi	sp,sp,-16
	PR_INFO("Set %s to enable %s support.\n",
4001f608:	87c70713          	addi	a4,a4,-1924 # 4002d87c <CSWTCH.14405+0x2a0>
4001f60c:	89068693          	addi	a3,a3,-1904 # 4002d890 <CSWTCH.14405+0x2b4>
4001f610:	63460613          	addi	a2,a2,1588 # 4002d634 <CSWTCH.14405+0x58>
4001f614:	00200593          	li	a1,2
{
4001f618:	00112623          	sw	ra,12(sp)
	PR_INFO("Set %s to enable %s support.\n",
4001f61c:	e94e60ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001f620:	00c12083          	lw	ra,12(sp)
4001f624:	00000513          	li	a0,0
4001f628:	01010113          	addi	sp,sp,16
4001f62c:	00008067          	ret

4001f630 <get_iface_idx>:
{
4001f630:	fd010113          	addi	sp,sp,-48
4001f634:	02112623          	sw	ra,44(sp)
4001f638:	02812423          	sw	s0,40(sp)
	if (!index_str) {
4001f63c:	02059463          	bnez	a1,4001f664 <get_iface_idx+0x34>
		PR_WARNING("Interface index is missing.\n");
4001f640:	4002e637          	lui	a2,0x4002e
4001f644:	8b060613          	addi	a2,a2,-1872 # 4002d8b0 <CSWTCH.14405+0x2d4>
4001f648:	00300593          	li	a1,3
4001f64c:	e64e60ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
4001f650:	fea00513          	li	a0,-22
}
4001f654:	02c12083          	lw	ra,44(sp)
4001f658:	02812403          	lw	s0,40(sp)
4001f65c:	03010113          	addi	sp,sp,48
4001f660:	00008067          	ret
4001f664:	00058693          	mv	a3,a1
	idx = strtol(index_str, &endptr, 10);
4001f668:	00050413          	mv	s0,a0
4001f66c:	00a00613          	li	a2,10
4001f670:	00068513          	mv	a0,a3
4001f674:	01c10593          	addi	a1,sp,28
4001f678:	00d12623          	sw	a3,12(sp)
4001f67c:	c5ce90ef          	jal	ra,40008ad8 <strtol>
	if (*endptr != '\0') {
4001f680:	01c12783          	lw	a5,28(sp)
4001f684:	00c12683          	lw	a3,12(sp)
4001f688:	0007c783          	lbu	a5,0(a5)
4001f68c:	02078063          	beqz	a5,4001f6ac <get_iface_idx+0x7c>
		PR_WARNING("Invalid index %s\n", index_str);
4001f690:	4002e637          	lui	a2,0x4002e
4001f694:	00040513          	mv	a0,s0
4001f698:	8d060613          	addi	a2,a2,-1840 # 4002d8d0 <CSWTCH.14405+0x2f4>
4001f69c:	00300593          	li	a1,3
4001f6a0:	e10e60ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOENT;
4001f6a4:	ffe00513          	li	a0,-2
4001f6a8:	fadff06f          	j	4001f654 <get_iface_idx+0x24>
	if (idx < 0 || idx > 255) {
4001f6ac:	0ff00793          	li	a5,255
4001f6b0:	faa7f2e3          	bgeu	a5,a0,4001f654 <get_iface_idx+0x24>
		PR_WARNING("Invalid index %d\n", idx);
4001f6b4:	4002e637          	lui	a2,0x4002e
4001f6b8:	00050693          	mv	a3,a0
4001f6bc:	8e460613          	addi	a2,a2,-1820 # 4002d8e4 <CSWTCH.14405+0x308>
4001f6c0:	00040513          	mv	a0,s0
4001f6c4:	00300593          	li	a1,3
4001f6c8:	de8e60ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ERANGE;
4001f6cc:	fde00513          	li	a0,-34
4001f6d0:	f85ff06f          	j	4001f654 <get_iface_idx+0x24>

4001f6d4 <cmd_net_tcp_recv>:
{
4001f6d4:	fe010113          	addi	sp,sp,-32
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
4001f6d8:	400317b7          	lui	a5,0x40031
{
4001f6dc:	00812c23          	sw	s0,24(sp)
4001f6e0:	00050413          	mv	s0,a0
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
4001f6e4:	ae07a503          	lw	a0,-1312(a5) # 40030ae0 <tcp_ctx>
{
4001f6e8:	00112e23          	sw	ra,28(sp)
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
4001f6ec:	00050863          	beqz	a0,4001f6fc <cmd_net_tcp_recv+0x28>
	return context->flags & NET_CONTEXT_IN_USE;
4001f6f0:	07455783          	lhu	a5,116(a0)
4001f6f4:	0017f793          	andi	a5,a5,1
4001f6f8:	02079663          	bnez	a5,4001f724 <cmd_net_tcp_recv+0x50>
		PR_WARNING("Not connected\n");
4001f6fc:	4002e637          	lui	a2,0x4002e
4001f700:	8f860613          	addi	a2,a2,-1800 # 4002d8f8 <CSWTCH.14405+0x31c>
4001f704:	00300593          	li	a1,3
4001f708:	00040513          	mv	a0,s0
4001f70c:	da4e60ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
4001f710:	ff800513          	li	a0,-8
}
4001f714:	01c12083          	lw	ra,28(sp)
4001f718:	01812403          	lw	s0,24(sp)
4001f71c:	02010113          	addi	sp,sp,32
4001f720:	00008067          	ret
	ret = net_context_recv(tcp_ctx, tcp_recv_cb, K_NO_WAIT, &user_data);
4001f724:	400215b7          	lui	a1,0x40021
4001f728:	00000693          	li	a3,0
4001f72c:	00810713          	addi	a4,sp,8
4001f730:	00000613          	li	a2,0
4001f734:	72058593          	addi	a1,a1,1824 # 40021720 <tcp_recv_cb>
	user_data.sh = sh;
4001f738:	00812423          	sw	s0,8(sp)
	ret = net_context_recv(tcp_ctx, tcp_recv_cb, K_NO_WAIT, &user_data);
4001f73c:	f61f20ef          	jal	ra,4001269c <net_context_recv>
4001f740:	00050693          	mv	a3,a0
	return 0;
4001f744:	00000513          	li	a0,0
	if (ret < 0) {
4001f748:	fc06d6e3          	bgez	a3,4001f714 <cmd_net_tcp_recv+0x40>
		PR_WARNING("Cannot recv data (%d)\n", ret);
4001f74c:	4002e637          	lui	a2,0x4002e
4001f750:	90860613          	addi	a2,a2,-1784 # 4002d908 <CSWTCH.14405+0x32c>
4001f754:	00300593          	li	a1,3
4001f758:	00040513          	mv	a0,s0
4001f75c:	d54e60ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
4001f760:	fb1ff06f          	j	4001f710 <cmd_net_tcp_recv+0x3c>

4001f764 <cmd_net_tcp_close>:
{
4001f764:	ff010113          	addi	sp,sp,-16
4001f768:	00912223          	sw	s1,4(sp)
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
4001f76c:	400314b7          	lui	s1,0x40031
{
4001f770:	00812423          	sw	s0,8(sp)
4001f774:	00050413          	mv	s0,a0
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
4001f778:	ae04a503          	lw	a0,-1312(s1) # 40030ae0 <tcp_ctx>
{
4001f77c:	00112623          	sw	ra,12(sp)
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
4001f780:	00050863          	beqz	a0,4001f790 <cmd_net_tcp_close+0x2c>
4001f784:	07455783          	lhu	a5,116(a0)
4001f788:	0017f793          	andi	a5,a5,1
4001f78c:	02079863          	bnez	a5,4001f7bc <cmd_net_tcp_close+0x58>
		PR_WARNING("Not connected\n");
4001f790:	4002e637          	lui	a2,0x4002e
4001f794:	8f860613          	addi	a2,a2,-1800 # 4002d8f8 <CSWTCH.14405+0x31c>
4001f798:	00300593          	li	a1,3
4001f79c:	00040513          	mv	a0,s0
4001f7a0:	d10e60ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
4001f7a4:	ff800513          	li	a0,-8
}
4001f7a8:	00c12083          	lw	ra,12(sp)
4001f7ac:	00812403          	lw	s0,8(sp)
4001f7b0:	00412483          	lw	s1,4(sp)
4001f7b4:	01010113          	addi	sp,sp,16
4001f7b8:	00008067          	ret
	ret = net_context_put(tcp_ctx);
4001f7bc:	800f20ef          	jal	ra,400117bc <net_context_put>
4001f7c0:	00050693          	mv	a3,a0
	if (ret < 0) {
4001f7c4:	00055e63          	bgez	a0,4001f7e0 <cmd_net_tcp_close+0x7c>
		PR_WARNING("Cannot close the connection (%d)\n", ret);
4001f7c8:	4002e637          	lui	a2,0x4002e
4001f7cc:	92060613          	addi	a2,a2,-1760 # 4002d920 <CSWTCH.14405+0x344>
4001f7d0:	00300593          	li	a1,3
4001f7d4:	00040513          	mv	a0,s0
4001f7d8:	cd8e60ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
4001f7dc:	fc9ff06f          	j	4001f7a4 <cmd_net_tcp_close+0x40>
	PR("Connection closed.\n");
4001f7e0:	4002e637          	lui	a2,0x4002e
4001f7e4:	00040513          	mv	a0,s0
4001f7e8:	94460613          	addi	a2,a2,-1724 # 4002d944 <CSWTCH.14405+0x368>
4001f7ec:	00800593          	li	a1,8
4001f7f0:	cc0e60ef          	jal	ra,40005cb0 <shell_fprintf>
	return 0;
4001f7f4:	00000513          	li	a0,0
	tcp_ctx = NULL;
4001f7f8:	ae04a023          	sw	zero,-1312(s1)
	return 0;
4001f7fc:	fadff06f          	j	4001f7a8 <cmd_net_tcp_close+0x44>

4001f800 <cmd_net_tcp_send>:
{
4001f800:	fd010113          	addi	sp,sp,-48
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
4001f804:	400317b7          	lui	a5,0x40031
{
4001f808:	02912223          	sw	s1,36(sp)
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
4001f80c:	ae07a483          	lw	s1,-1312(a5) # 40030ae0 <tcp_ctx>
{
4001f810:	02812423          	sw	s0,40(sp)
4001f814:	02112623          	sw	ra,44(sp)
4001f818:	00050413          	mv	s0,a0
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
4001f81c:	00048863          	beqz	s1,4001f82c <cmd_net_tcp_send+0x2c>
4001f820:	0744d783          	lhu	a5,116(s1)
4001f824:	0017f793          	andi	a5,a5,1
4001f828:	02079863          	bnez	a5,4001f858 <cmd_net_tcp_send+0x58>
		PR_WARNING("Not connected\n");
4001f82c:	4002e637          	lui	a2,0x4002e
4001f830:	8f860613          	addi	a2,a2,-1800 # 4002d8f8 <CSWTCH.14405+0x31c>
4001f834:	00300593          	li	a1,3
4001f838:	00040513          	mv	a0,s0
		PR_WARNING("No data to send.\n");
4001f83c:	c74e60ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
4001f840:	ff800513          	li	a0,-8
}
4001f844:	02c12083          	lw	ra,44(sp)
4001f848:	02812403          	lw	s0,40(sp)
4001f84c:	02412483          	lw	s1,36(sp)
4001f850:	03010113          	addi	sp,sp,48
4001f854:	00008067          	ret
	if (!argv[++arg]) {
4001f858:	00462583          	lw	a1,4(a2)
4001f85c:	00059a63          	bnez	a1,4001f870 <cmd_net_tcp_send+0x70>
		PR_WARNING("No data to send.\n");
4001f860:	4002e637          	lui	a2,0x4002e
4001f864:	95860613          	addi	a2,a2,-1704 # 4002d958 <CSWTCH.14405+0x37c>
4001f868:	00300593          	li	a1,3
4001f86c:	fd1ff06f          	j	4001f83c <cmd_net_tcp_send+0x3c>
	user_data.sh = sh;
4001f870:	00a12c23          	sw	a0,24(sp)
	ret = net_context_send(tcp_ctx, (uint8_t *)argv[arg],
4001f874:	00058513          	mv	a0,a1
4001f878:	00b12623          	sw	a1,12(sp)
4001f87c:	eace90ef          	jal	ra,40008f28 <strlen>
4001f880:	00c12583          	lw	a1,12(sp)
4001f884:	4001f6b7          	lui	a3,0x4001f
4001f888:	00050613          	mv	a2,a0
4001f88c:	40c68693          	addi	a3,a3,1036 # 4001f40c <tcp_sent_cb>
4001f890:	01810813          	addi	a6,sp,24
4001f894:	0c800713          	li	a4,200
4001f898:	00000793          	li	a5,0
4001f89c:	00048513          	mv	a0,s1
4001f8a0:	c99f20ef          	jal	ra,40012538 <net_context_send>
4001f8a4:	00050693          	mv	a3,a0
	return 0;
4001f8a8:	00000513          	li	a0,0
	if (ret < 0) {
4001f8ac:	f806dce3          	bgez	a3,4001f844 <cmd_net_tcp_send+0x44>
		PR_WARNING("Cannot send msg (%d)\n", ret);
4001f8b0:	4002e637          	lui	a2,0x4002e
4001f8b4:	96c60613          	addi	a2,a2,-1684 # 4002d96c <CSWTCH.14405+0x390>
4001f8b8:	00300593          	li	a1,3
4001f8bc:	00040513          	mv	a0,s0
4001f8c0:	bf0e60ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
4001f8c4:	f7dff06f          	j	4001f840 <cmd_net_tcp_send+0x40>

4001f8c8 <net_addr_pton>:
4001f8c8:	885f006f          	j	4001014c <z_impl_net_addr_pton>

4001f8cc <cmd_net_route>:
{
4001f8cc:	fe010113          	addi	sp,sp,-32
	user_data.sh = sh;
4001f8d0:	00a12423          	sw	a0,8(sp)
	net_if_foreach(iface_per_route_cb, &user_data);
4001f8d4:	40022537          	lui	a0,0x40022
4001f8d8:	00810593          	addi	a1,sp,8
4001f8dc:	dc050513          	addi	a0,a0,-576 # 40021dc0 <iface_per_route_cb>
{
4001f8e0:	00112e23          	sw	ra,28(sp)
	net_if_foreach(iface_per_route_cb, &user_data);
4001f8e4:	d41ef0ef          	jal	ra,4000f624 <net_if_foreach>
}
4001f8e8:	01c12083          	lw	ra,28(sp)
4001f8ec:	00000513          	li	a0,0
4001f8f0:	02010113          	addi	sp,sp,32
4001f8f4:	00008067          	ret

4001f8f8 <cmd_net_ipv4>:
	PR("IPv4 support                              : %s\n",
4001f8f8:	4002e6b7          	lui	a3,0x4002e
4001f8fc:	4002e637          	lui	a2,0x4002e
{
4001f900:	fe010113          	addi	sp,sp,-32
	PR("IPv4 support                              : %s\n",
4001f904:	98468693          	addi	a3,a3,-1660 # 4002d984 <CSWTCH.14405+0x3a8>
4001f908:	98c60613          	addi	a2,a2,-1652 # 4002d98c <CSWTCH.14405+0x3b0>
4001f90c:	00800593          	li	a1,8
{
4001f910:	00112e23          	sw	ra,28(sp)
4001f914:	00812c23          	sw	s0,24(sp)
4001f918:	00050413          	mv	s0,a0
	PR("IPv4 support                              : %s\n",
4001f91c:	b94e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("IPv4 fragmentation support                : %s\n",
4001f920:	4002e6b7          	lui	a3,0x4002e
4001f924:	4002e637          	lui	a2,0x4002e
4001f928:	00040513          	mv	a0,s0
4001f92c:	9bc68693          	addi	a3,a3,-1604 # 4002d9bc <CSWTCH.14405+0x3e0>
4001f930:	9c860613          	addi	a2,a2,-1592 # 4002d9c8 <CSWTCH.14405+0x3ec>
4001f934:	00800593          	li	a1,8
4001f938:	b78e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Max number of IPv4 network interfaces "
4001f93c:	4002e637          	lui	a2,0x4002e
4001f940:	00040513          	mv	a0,s0
4001f944:	00100693          	li	a3,1
4001f948:	9f860613          	addi	a2,a2,-1544 # 4002d9f8 <CSWTCH.14405+0x41c>
4001f94c:	00800593          	li	a1,8
4001f950:	b60e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Max number of unicast IPv4 addresses "
4001f954:	4002e637          	lui	a2,0x4002e
4001f958:	00040513          	mv	a0,s0
4001f95c:	00100693          	li	a3,1
4001f960:	a3c60613          	addi	a2,a2,-1476 # 4002da3c <CSWTCH.14405+0x460>
4001f964:	00800593          	li	a1,8
4001f968:	b48e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Max number of multicast IPv4 addresses "
4001f96c:	4002e637          	lui	a2,0x4002e
4001f970:	00040513          	mv	a0,s0
4001f974:	00100693          	li	a3,1
4001f978:	a8060613          	addi	a2,a2,-1408 # 4002da80 <CSWTCH.14405+0x4a4>
4001f97c:	00800593          	li	a1,8
4001f980:	b30e60ef          	jal	ra,40005cb0 <shell_fprintf>
	net_if_foreach(ip_address_lifetime_cb, &user_data);
4001f984:	40022537          	lui	a0,0x40022
4001f988:	00810593          	addi	a1,sp,8
4001f98c:	c3850513          	addi	a0,a0,-968 # 40021c38 <ip_address_lifetime_cb>
	user_data.sh = sh;
4001f990:	00812423          	sw	s0,8(sp)
	user_data.user_data = NULL;
4001f994:	00012623          	sw	zero,12(sp)
	net_if_foreach(ip_address_lifetime_cb, &user_data);
4001f998:	c8def0ef          	jal	ra,4000f624 <net_if_foreach>
}
4001f99c:	01c12083          	lw	ra,28(sp)
4001f9a0:	01812403          	lw	s0,24(sp)
4001f9a4:	00000513          	li	a0,0
4001f9a8:	02010113          	addi	sp,sp,32
4001f9ac:	00008067          	ret

4001f9b0 <cmd_net_ipv6>:
{
4001f9b0:	fe010113          	addi	sp,sp,-32
4001f9b4:	00912a23          	sw	s1,20(sp)
	PR("IPv6 support                              : %s\n",
4001f9b8:	4002e637          	lui	a2,0x4002e
4001f9bc:	4002e4b7          	lui	s1,0x4002e
4001f9c0:	98448693          	addi	a3,s1,-1660 # 4002d984 <CSWTCH.14405+0x3a8>
4001f9c4:	ac460613          	addi	a2,a2,-1340 # 4002dac4 <CSWTCH.14405+0x4e8>
4001f9c8:	00800593          	li	a1,8
{
4001f9cc:	00112e23          	sw	ra,28(sp)
4001f9d0:	00812c23          	sw	s0,24(sp)
4001f9d4:	01212823          	sw	s2,16(sp)
4001f9d8:	00050413          	mv	s0,a0
	PR("IPv6 support                              : %s\n",
4001f9dc:	ad4e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("IPv6 fragmentation support                : %s\n",
4001f9e0:	4002e937          	lui	s2,0x4002e
4001f9e4:	4002e637          	lui	a2,0x4002e
4001f9e8:	9bc90693          	addi	a3,s2,-1604 # 4002d9bc <CSWTCH.14405+0x3e0>
4001f9ec:	00040513          	mv	a0,s0
4001f9f0:	af460613          	addi	a2,a2,-1292 # 4002daf4 <CSWTCH.14405+0x518>
4001f9f4:	00800593          	li	a1,8
4001f9f8:	ab8e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Multicast Listener Discovery support      : %s\n",
4001f9fc:	4002e637          	lui	a2,0x4002e
4001fa00:	98448693          	addi	a3,s1,-1660
4001fa04:	00040513          	mv	a0,s0
4001fa08:	b2460613          	addi	a2,a2,-1244 # 4002db24 <CSWTCH.14405+0x548>
4001fa0c:	00800593          	li	a1,8
4001fa10:	aa0e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Neighbor cache support                    : %s\n",
4001fa14:	4002e637          	lui	a2,0x4002e
4001fa18:	98448693          	addi	a3,s1,-1660
4001fa1c:	00040513          	mv	a0,s0
4001fa20:	b5460613          	addi	a2,a2,-1196 # 4002db54 <CSWTCH.14405+0x578>
4001fa24:	00800593          	li	a1,8
4001fa28:	a88e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Neighbor discovery support                : %s\n",
4001fa2c:	4002e637          	lui	a2,0x4002e
4001fa30:	98448693          	addi	a3,s1,-1660
4001fa34:	00040513          	mv	a0,s0
4001fa38:	b8460613          	addi	a2,a2,-1148 # 4002db84 <CSWTCH.14405+0x5a8>
4001fa3c:	00800593          	li	a1,8
4001fa40:	a70e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Duplicate address detection (DAD) support : %s\n",
4001fa44:	4002e637          	lui	a2,0x4002e
4001fa48:	98448693          	addi	a3,s1,-1660
4001fa4c:	00040513          	mv	a0,s0
4001fa50:	bb460613          	addi	a2,a2,-1100 # 4002dbb4 <CSWTCH.14405+0x5d8>
4001fa54:	00800593          	li	a1,8
4001fa58:	a58e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Router advertisement RDNSS option support : %s\n",
4001fa5c:	4002e637          	lui	a2,0x4002e
4001fa60:	98448693          	addi	a3,s1,-1660
4001fa64:	00040513          	mv	a0,s0
4001fa68:	be460613          	addi	a2,a2,-1052 # 4002dbe4 <CSWTCH.14405+0x608>
4001fa6c:	00800593          	li	a1,8
4001fa70:	a40e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("6lo header compression support            : %s\n",
4001fa74:	4002e637          	lui	a2,0x4002e
4001fa78:	9bc90693          	addi	a3,s2,-1604
4001fa7c:	00040513          	mv	a0,s0
4001fa80:	c1460613          	addi	a2,a2,-1004 # 4002dc14 <CSWTCH.14405+0x638>
4001fa84:	00800593          	li	a1,8
4001fa88:	a28e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Max number of IPv6 network interfaces "
4001fa8c:	4002e637          	lui	a2,0x4002e
4001fa90:	00040513          	mv	a0,s0
4001fa94:	00100693          	li	a3,1
4001fa98:	c4460613          	addi	a2,a2,-956 # 4002dc44 <CSWTCH.14405+0x668>
4001fa9c:	00800593          	li	a1,8
4001faa0:	a10e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Max number of unicast IPv6 addresses "
4001faa4:	4002e637          	lui	a2,0x4002e
4001faa8:	00040513          	mv	a0,s0
4001faac:	00300693          	li	a3,3
4001fab0:	c8860613          	addi	a2,a2,-888 # 4002dc88 <CSWTCH.14405+0x6ac>
4001fab4:	00800593          	li	a1,8
4001fab8:	9f8e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Max number of multicast IPv6 addresses "
4001fabc:	4002e637          	lui	a2,0x4002e
4001fac0:	00040513          	mv	a0,s0
4001fac4:	00200693          	li	a3,2
4001fac8:	ccc60613          	addi	a2,a2,-820 # 4002dccc <CSWTCH.14405+0x6f0>
4001facc:	00800593          	li	a1,8
4001fad0:	9e0e60ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Max number of IPv6 prefixes per network "
4001fad4:	4002e637          	lui	a2,0x4002e
4001fad8:	00040513          	mv	a0,s0
4001fadc:	00200693          	li	a3,2
4001fae0:	d1060613          	addi	a2,a2,-752 # 4002dd10 <CSWTCH.14405+0x734>
4001fae4:	00800593          	li	a1,8
4001fae8:	9c8e60ef          	jal	ra,40005cb0 <shell_fprintf>
	net_if_foreach(address_lifetime_cb, &user_data);
4001faec:	40023537          	lui	a0,0x40023
4001faf0:	00810593          	addi	a1,sp,8
4001faf4:	c2850513          	addi	a0,a0,-984 # 40022c28 <address_lifetime_cb>
	user_data.sh = sh;
4001faf8:	00812423          	sw	s0,8(sp)
	user_data.user_data = NULL;
4001fafc:	00012623          	sw	zero,12(sp)
	net_if_foreach(address_lifetime_cb, &user_data);
4001fb00:	b25ef0ef          	jal	ra,4000f624 <net_if_foreach>
}
4001fb04:	01c12083          	lw	ra,28(sp)
4001fb08:	01812403          	lw	s0,24(sp)
4001fb0c:	01412483          	lw	s1,20(sp)
4001fb10:	01012903          	lw	s2,16(sp)
4001fb14:	00000513          	li	a0,0
4001fb18:	02010113          	addi	sp,sp,32
4001fb1c:	00008067          	ret

4001fb20 <cmd_net_iface>:
{
4001fb20:	fd010113          	addi	sp,sp,-48
4001fb24:	02812423          	sw	s0,40(sp)
4001fb28:	02112623          	sw	ra,44(sp)
	if (argv[1]) {
4001fb2c:	00462583          	lw	a1,4(a2)
{
4001fb30:	00050413          	mv	s0,a0
	if (argv[1]) {
4001fb34:	04058463          	beqz	a1,4001fb7c <cmd_net_iface+0x5c>
		idx = get_iface_idx(sh, argv[1]);
4001fb38:	af9ff0ef          	jal	ra,4001f630 <get_iface_idx>
		if (idx < 0) {
4001fb3c:	00a12623          	sw	a0,12(sp)
4001fb40:	02054463          	bltz	a0,4001fb68 <cmd_net_iface+0x48>
		iface = net_if_get_by_index(idx);
4001fb44:	f00ff0ef          	jal	ra,4001f244 <net_if_get_by_index>
		if (!iface) {
4001fb48:	00c12683          	lw	a3,12(sp)
		iface = net_if_get_by_index(idx);
4001fb4c:	00050593          	mv	a1,a0
		if (!iface) {
4001fb50:	02051663          	bnez	a0,4001fb7c <cmd_net_iface+0x5c>
			PR_WARNING("No such interface in index %d\n", idx);
4001fb54:	4002e637          	lui	a2,0x4002e
4001fb58:	d5460613          	addi	a2,a2,-684 # 4002dd54 <CSWTCH.14405+0x778>
4001fb5c:	00300593          	li	a1,3
4001fb60:	00040513          	mv	a0,s0
4001fb64:	94ce60ef          	jal	ra,40005cb0 <shell_fprintf>
			return -ENOEXEC;
4001fb68:	ff800513          	li	a0,-8
}
4001fb6c:	02c12083          	lw	ra,44(sp)
4001fb70:	02812403          	lw	s0,40(sp)
4001fb74:	03010113          	addi	sp,sp,48
4001fb78:	00008067          	ret
	net_if_foreach(iface_cb, &user_data);
4001fb7c:	40023537          	lui	a0,0x40023
	user_data.user_data = iface;
4001fb80:	00b12e23          	sw	a1,28(sp)
	net_if_foreach(iface_cb, &user_data);
4001fb84:	ea850513          	addi	a0,a0,-344 # 40022ea8 <iface_cb>
4001fb88:	01810593          	addi	a1,sp,24
	user_data.sh = sh;
4001fb8c:	00812c23          	sw	s0,24(sp)
	net_if_foreach(iface_cb, &user_data);
4001fb90:	a95ef0ef          	jal	ra,4000f624 <net_if_foreach>
	return 0;
4001fb94:	00000513          	li	a0,0
4001fb98:	fd5ff06f          	j	4001fb6c <cmd_net_iface+0x4c>

4001fb9c <cmd_net_ip6_route_del>:
{
4001fb9c:	fc010113          	addi	sp,sp,-64
4001fba0:	02112e23          	sw	ra,60(sp)
4001fba4:	02812c23          	sw	s0,56(sp)
4001fba8:	02912a23          	sw	s1,52(sp)
4001fbac:	03212823          	sw	s2,48(sp)
4001fbb0:	03312623          	sw	s3,44(sp)
	struct in6_addr prefix = { 0 };
4001fbb4:	00012823          	sw	zero,16(sp)
4001fbb8:	00012a23          	sw	zero,20(sp)
4001fbbc:	00012c23          	sw	zero,24(sp)
4001fbc0:	00012e23          	sw	zero,28(sp)
	if (argc != 3) {
4001fbc4:	00300793          	li	a5,3
4001fbc8:	02f58c63          	beq	a1,a5,4001fc00 <cmd_net_ip6_route_del+0x64>
		PR_ERROR("Correct usage: net route del <index> <destination>\n");
4001fbcc:	4002e637          	lui	a2,0x4002e
4001fbd0:	d7460613          	addi	a2,a2,-652 # 4002dd74 <CSWTCH.14405+0x798>
4001fbd4:	00100593          	li	a1,1
4001fbd8:	8d8e60ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
4001fbdc:	fea00413          	li	s0,-22
}
4001fbe0:	03c12083          	lw	ra,60(sp)
4001fbe4:	00040513          	mv	a0,s0
4001fbe8:	03812403          	lw	s0,56(sp)
4001fbec:	03412483          	lw	s1,52(sp)
4001fbf0:	03012903          	lw	s2,48(sp)
4001fbf4:	02c12983          	lw	s3,44(sp)
4001fbf8:	04010113          	addi	sp,sp,64
4001fbfc:	00008067          	ret
	idx = get_iface_idx(sh, argv[1]);
4001fc00:	00462583          	lw	a1,4(a2)
4001fc04:	00050993          	mv	s3,a0
4001fc08:	00060493          	mv	s1,a2
4001fc0c:	a25ff0ef          	jal	ra,4001f630 <get_iface_idx>
	if (idx < 0) {
4001fc10:	00a12623          	sw	a0,12(sp)
4001fc14:	02054463          	bltz	a0,4001fc3c <cmd_net_ip6_route_del+0xa0>
	iface = net_if_get_by_index(idx);
4001fc18:	e2cff0ef          	jal	ra,4001f244 <net_if_get_by_index>
	if (!iface) {
4001fc1c:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
4001fc20:	00050913          	mv	s2,a0
	if (!iface) {
4001fc24:	02051063          	bnez	a0,4001fc44 <cmd_net_ip6_route_del+0xa8>
		PR_WARNING("No such interface in index %d\n", idx);
4001fc28:	4002e637          	lui	a2,0x4002e
4001fc2c:	d5460613          	addi	a2,a2,-684 # 4002dd54 <CSWTCH.14405+0x778>
4001fc30:	00300593          	li	a1,3
4001fc34:	00098513          	mv	a0,s3
4001fc38:	878e60ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
4001fc3c:	ff800413          	li	s0,-8
4001fc40:	fa1ff06f          	j	4001fbe0 <cmd_net_ip6_route_del+0x44>
	if (net_addr_pton(AF_INET6, argv[2], &prefix)) {
4001fc44:	0084a583          	lw	a1,8(s1)
4001fc48:	01010613          	addi	a2,sp,16
4001fc4c:	00200513          	li	a0,2
4001fc50:	c79ff0ef          	jal	ra,4001f8c8 <net_addr_pton>
4001fc54:	00050413          	mv	s0,a0
4001fc58:	02050063          	beqz	a0,4001fc78 <cmd_net_ip6_route_del+0xdc>
		PR_ERROR("Invalid address: %s\n", argv[2]);
4001fc5c:	0084a683          	lw	a3,8(s1)
4001fc60:	4002e637          	lui	a2,0x4002e
4001fc64:	da860613          	addi	a2,a2,-600 # 4002dda8 <CSWTCH.14405+0x7cc>
4001fc68:	00100593          	li	a1,1
4001fc6c:	00098513          	mv	a0,s3
4001fc70:	840e60ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
4001fc74:	f69ff06f          	j	4001fbdc <cmd_net_ip6_route_del+0x40>
	route = net_route_lookup(iface, &prefix);
4001fc78:	01010593          	addi	a1,sp,16
4001fc7c:	00090513          	mv	a0,s2
4001fc80:	ca4fa0ef          	jal	ra,4001a124 <net_route_lookup>
	if (route) {
4001fc84:	f4050ee3          	beqz	a0,4001fbe0 <cmd_net_ip6_route_del+0x44>
		net_route_del(route);
4001fc88:	ef8fa0ef          	jal	ra,4001a380 <net_route_del>
4001fc8c:	f55ff06f          	j	4001fbe0 <cmd_net_ip6_route_del+0x44>

4001fc90 <cmd_net_ip6_route_add>:
{
4001fc90:	fb010113          	addi	sp,sp,-80
4001fc94:	04112623          	sw	ra,76(sp)
4001fc98:	04812423          	sw	s0,72(sp)
4001fc9c:	04912223          	sw	s1,68(sp)
4001fca0:	05212023          	sw	s2,64(sp)
4001fca4:	03312e23          	sw	s3,60(sp)
	struct in6_addr gw = {0};
4001fca8:	00012823          	sw	zero,16(sp)
4001fcac:	00012a23          	sw	zero,20(sp)
4001fcb0:	00012c23          	sw	zero,24(sp)
4001fcb4:	00012e23          	sw	zero,28(sp)
	struct in6_addr prefix = {0};
4001fcb8:	02012023          	sw	zero,32(sp)
4001fcbc:	02012223          	sw	zero,36(sp)
4001fcc0:	02012423          	sw	zero,40(sp)
4001fcc4:	02012623          	sw	zero,44(sp)
	if (argc != 4) {
4001fcc8:	00400793          	li	a5,4
4001fccc:	00f58e63          	beq	a1,a5,4001fce8 <cmd_net_ip6_route_add+0x58>
		PR_ERROR("Correct usage: net route add <index> "
4001fcd0:	4002e637          	lui	a2,0x4002e
4001fcd4:	dc060613          	addi	a2,a2,-576 # 4002ddc0 <CSWTCH.14405+0x7e4>
4001fcd8:	00100593          	li	a1,1
4001fcdc:	fd5e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
4001fce0:	fea00493          	li	s1,-22
4001fce4:	0440006f          	j	4001fd28 <cmd_net_ip6_route_add+0x98>
	idx = get_iface_idx(sh, argv[1]);
4001fce8:	00462583          	lw	a1,4(a2)
4001fcec:	00050913          	mv	s2,a0
4001fcf0:	00060413          	mv	s0,a2
4001fcf4:	93dff0ef          	jal	ra,4001f630 <get_iface_idx>
	if (idx < 0) {
4001fcf8:	00a12623          	sw	a0,12(sp)
4001fcfc:	02054463          	bltz	a0,4001fd24 <cmd_net_ip6_route_add+0x94>
	iface = net_if_get_by_index(idx);
4001fd00:	d44ff0ef          	jal	ra,4001f244 <net_if_get_by_index>
	if (!iface) {
4001fd04:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
4001fd08:	00050993          	mv	s3,a0
	if (!iface) {
4001fd0c:	02051e63          	bnez	a0,4001fd48 <cmd_net_ip6_route_add+0xb8>
		PR_WARNING("No such interface in index %d\n", idx);
4001fd10:	4002e637          	lui	a2,0x4002e
4001fd14:	d5460613          	addi	a2,a2,-684 # 4002dd54 <CSWTCH.14405+0x778>
4001fd18:	00300593          	li	a1,3
4001fd1c:	00090513          	mv	a0,s2
4001fd20:	f91e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
4001fd24:	ff800493          	li	s1,-8
}
4001fd28:	04c12083          	lw	ra,76(sp)
4001fd2c:	04812403          	lw	s0,72(sp)
4001fd30:	04012903          	lw	s2,64(sp)
4001fd34:	03c12983          	lw	s3,60(sp)
4001fd38:	00048513          	mv	a0,s1
4001fd3c:	04412483          	lw	s1,68(sp)
4001fd40:	05010113          	addi	sp,sp,80
4001fd44:	00008067          	ret
	if (net_addr_pton(AF_INET6, argv[2], &prefix)) {
4001fd48:	00842583          	lw	a1,8(s0)
4001fd4c:	02010613          	addi	a2,sp,32
4001fd50:	00200513          	li	a0,2
4001fd54:	b75ff0ef          	jal	ra,4001f8c8 <net_addr_pton>
4001fd58:	02050063          	beqz	a0,4001fd78 <cmd_net_ip6_route_add+0xe8>
		PR_ERROR("Invalid address: %s\n", argv[2]);
4001fd5c:	00842683          	lw	a3,8(s0)
4001fd60:	4002e637          	lui	a2,0x4002e
4001fd64:	da860613          	addi	a2,a2,-600 # 4002dda8 <CSWTCH.14405+0x7cc>
		PR_ERROR("Invalid gateway: %s\n", argv[3]);
4001fd68:	00100593          	li	a1,1
4001fd6c:	00090513          	mv	a0,s2
4001fd70:	f41e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
4001fd74:	f6dff06f          	j	4001fce0 <cmd_net_ip6_route_add+0x50>
	if (net_addr_pton(AF_INET6, argv[3], &gw)) {
4001fd78:	00c42583          	lw	a1,12(s0)
4001fd7c:	01010613          	addi	a2,sp,16
4001fd80:	00200513          	li	a0,2
4001fd84:	b45ff0ef          	jal	ra,4001f8c8 <net_addr_pton>
4001fd88:	00050493          	mv	s1,a0
4001fd8c:	00050a63          	beqz	a0,4001fda0 <cmd_net_ip6_route_add+0x110>
		PR_ERROR("Invalid gateway: %s\n", argv[3]);
4001fd90:	4002e637          	lui	a2,0x4002e
4001fd94:	00c42683          	lw	a3,12(s0)
4001fd98:	e0060613          	addi	a2,a2,-512 # 4002de00 <CSWTCH.14405+0x824>
4001fd9c:	fcdff06f          	j	4001fd68 <cmd_net_ip6_route_add+0xd8>
	route = net_route_add(iface, &prefix, NET_IPV6_DEFAULT_PREFIX_LEN,
4001fda0:	00000793          	li	a5,0
4001fda4:	fff00713          	li	a4,-1
4001fda8:	01010693          	addi	a3,sp,16
4001fdac:	04000613          	li	a2,64
4001fdb0:	02010593          	addi	a1,sp,32
4001fdb4:	00098513          	mv	a0,s3
4001fdb8:	8edfa0ef          	jal	ra,4001a6a4 <net_route_add>
	if (route == NULL) {
4001fdbc:	f60516e3          	bnez	a0,4001fd28 <cmd_net_ip6_route_add+0x98>
		PR_ERROR("Failed to add route\n");
4001fdc0:	4002e637          	lui	a2,0x4002e
4001fdc4:	e1860613          	addi	a2,a2,-488 # 4002de18 <CSWTCH.14405+0x83c>
4001fdc8:	00100593          	li	a1,1
4001fdcc:	00090513          	mv	a0,s2
4001fdd0:	ee1e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
4001fdd4:	f51ff06f          	j	4001fd24 <cmd_net_ip6_route_add+0x94>

4001fdd8 <cmd_net_mem>:
{
4001fdd8:	fe010113          	addi	sp,sp,-32
4001fddc:	00812c23          	sw	s0,24(sp)
	net_pkt_get_info(&rx, &tx, &rx_data, &tx_data);
4001fde0:	00c10693          	addi	a3,sp,12
{
4001fde4:	00050413          	mv	s0,a0
	net_pkt_get_info(&rx, &tx, &rx_data, &tx_data);
4001fde8:	00810613          	addi	a2,sp,8
4001fdec:	00410593          	addi	a1,sp,4
4001fdf0:	00010513          	mv	a0,sp
{
4001fdf4:	00112e23          	sw	ra,28(sp)
	net_pkt_get_info(&rx, &tx, &rx_data, &tx_data);
4001fdf8:	9dcf30ef          	jal	ra,40012fd4 <net_pkt_get_info>
	PR("Fragment length %d bytes\n", CONFIG_NET_BUF_DATA_SIZE);
4001fdfc:	4002e637          	lui	a2,0x4002e
4001fe00:	08000693          	li	a3,128
4001fe04:	00040513          	mv	a0,s0
4001fe08:	e3060613          	addi	a2,a2,-464 # 4002de30 <CSWTCH.14405+0x854>
4001fe0c:	00800593          	li	a1,8
4001fe10:	ea1e50ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Network buffer pools:\n");
4001fe14:	4002e637          	lui	a2,0x4002e
4001fe18:	00040513          	mv	a0,s0
4001fe1c:	e4c60613          	addi	a2,a2,-436 # 4002de4c <CSWTCH.14405+0x870>
4001fe20:	00800593          	li	a1,8
4001fe24:	e8de50ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Address\t\tTotal\tName\n");
4001fe28:	4002e637          	lui	a2,0x4002e
4001fe2c:	00040513          	mv	a0,s0
4001fe30:	e6460613          	addi	a2,a2,-412 # 4002de64 <CSWTCH.14405+0x888>
4001fe34:	00800593          	li	a1,8
4001fe38:	e79e50ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("%p\t%d\tRX\n", rx, rx->num_blocks);
4001fe3c:	00012683          	lw	a3,0(sp)
4001fe40:	4002e637          	lui	a2,0x4002e
4001fe44:	00040513          	mv	a0,s0
4001fe48:	0086a703          	lw	a4,8(a3)
4001fe4c:	e7c60613          	addi	a2,a2,-388 # 4002de7c <CSWTCH.14405+0x8a0>
4001fe50:	00800593          	li	a1,8
4001fe54:	e5de50ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("%p\t%d\tTX\n", tx, tx->num_blocks);
4001fe58:	00412683          	lw	a3,4(sp)
4001fe5c:	4002e637          	lui	a2,0x4002e
4001fe60:	00040513          	mv	a0,s0
4001fe64:	0086a703          	lw	a4,8(a3)
4001fe68:	e8860613          	addi	a2,a2,-376 # 4002de88 <CSWTCH.14405+0x8ac>
4001fe6c:	00800593          	li	a1,8
4001fe70:	e41e50ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("%p\t%d\tRX DATA\n", rx_data, rx_data->buf_count);
4001fe74:	00812683          	lw	a3,8(sp)
4001fe78:	4002e637          	lui	a2,0x4002e
4001fe7c:	00040513          	mv	a0,s0
4001fe80:	0186d703          	lhu	a4,24(a3)
4001fe84:	e9460613          	addi	a2,a2,-364 # 4002de94 <CSWTCH.14405+0x8b8>
4001fe88:	00800593          	li	a1,8
4001fe8c:	e25e50ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("%p\t%d\tTX DATA\n", tx_data, tx_data->buf_count);
4001fe90:	00c12683          	lw	a3,12(sp)
4001fe94:	4002e637          	lui	a2,0x4002e
4001fe98:	00040513          	mv	a0,s0
4001fe9c:	0186d703          	lhu	a4,24(a3)
4001fea0:	ea460613          	addi	a2,a2,-348 # 4002dea4 <CSWTCH.14405+0x8c8>
4001fea4:	00800593          	li	a1,8
4001fea8:	e09e50ef          	jal	ra,40005cb0 <shell_fprintf>
	PR_INFO("Set %s to enable %s support.\n",
4001feac:	4002e737          	lui	a4,0x4002e
4001feb0:	4002e6b7          	lui	a3,0x4002e
4001feb4:	4002d637          	lui	a2,0x4002d
4001feb8:	00040513          	mv	a0,s0
4001febc:	eb470713          	addi	a4,a4,-332 # 4002deb4 <CSWTCH.14405+0x8d8>
4001fec0:	ec868693          	addi	a3,a3,-312 # 4002dec8 <CSWTCH.14405+0x8ec>
4001fec4:	63460613          	addi	a2,a2,1588 # 4002d634 <CSWTCH.14405+0x58>
4001fec8:	00200593          	li	a1,2
4001fecc:	de5e50ef          	jal	ra,40005cb0 <shell_fprintf>
}
4001fed0:	01c12083          	lw	ra,28(sp)
4001fed4:	01812403          	lw	s0,24(sp)
4001fed8:	00000513          	li	a0,0
4001fedc:	02010113          	addi	sp,sp,32
4001fee0:	00008067          	ret

4001fee4 <cmd_net_pkt>:
{
4001fee4:	fc010113          	addi	sp,sp,-64
4001fee8:	02112e23          	sw	ra,60(sp)
4001feec:	02812c23          	sw	s0,56(sp)
4001fef0:	02912a23          	sw	s1,52(sp)
4001fef4:	03212823          	sw	s2,48(sp)
4001fef8:	03312623          	sw	s3,44(sp)
4001fefc:	03412423          	sw	s4,40(sp)
4001ff00:	03512223          	sw	s5,36(sp)
	if (argv[1]) {
4001ff04:	00462483          	lw	s1,4(a2)
4001ff08:	24048863          	beqz	s1,40020158 <cmd_net_pkt+0x274>
	if (ptr_str[0] == '0' && ptr_str[1] == 'x') {
4001ff0c:	0004c703          	lbu	a4,0(s1)
4001ff10:	03000793          	li	a5,48
4001ff14:	00050413          	mv	s0,a0
4001ff18:	00060913          	mv	s2,a2
4001ff1c:	00f71a63          	bne	a4,a5,4001ff30 <cmd_net_pkt+0x4c>
4001ff20:	0014c703          	lbu	a4,1(s1)
4001ff24:	07800793          	li	a5,120
4001ff28:	00f71463          	bne	a4,a5,4001ff30 <cmd_net_pkt+0x4c>
		ptr_str += 2;
4001ff2c:	00248493          	addi	s1,s1,2
	len = hex2bin(ptr_str, strlen(ptr_str), buf, sizeof(buf));
4001ff30:	00048513          	mv	a0,s1
4001ff34:	ff5e80ef          	jal	ra,40008f28 <strlen>
4001ff38:	00050593          	mv	a1,a0
4001ff3c:	00400693          	li	a3,4
4001ff40:	01c10613          	addi	a2,sp,28
4001ff44:	00048513          	mv	a0,s1
4001ff48:	ea5e00ef          	jal	ra,40000dec <hex2bin>
	if (!len) {
4001ff4c:	00050c63          	beqz	a0,4001ff64 <cmd_net_pkt+0x80>
	for (i = len - 1; i >= 0; i--) {
4001ff50:	fff50513          	addi	a0,a0,-1
4001ff54:	00000793          	li	a5,0
	intptr_t ptr = 0;
4001ff58:	00000493          	li	s1,0
	for (i = len - 1; i >= 0; i--) {
4001ff5c:	04055463          	bgez	a0,4001ffa4 <cmd_net_pkt+0xc0>
		if (!pkt) {
4001ff60:	06049263          	bnez	s1,4001ffc4 <cmd_net_pkt+0xe0>
			PR_ERROR("Invalid ptr value (%s). "
4001ff64:	00492683          	lw	a3,4(s2)
4001ff68:	4002e637          	lui	a2,0x4002e
4001ff6c:	ee460613          	addi	a2,a2,-284 # 4002dee4 <CSWTCH.14405+0x908>
			PR_ERROR("Pointer is not recognized as net_pkt (%s).\n",
4001ff70:	00100593          	li	a1,1
4001ff74:	00040513          	mv	a0,s0
4001ff78:	d39e50ef          	jal	ra,40005cb0 <shell_fprintf>
			return -ENOEXEC;
4001ff7c:	ff800513          	li	a0,-8
}
4001ff80:	03c12083          	lw	ra,60(sp)
4001ff84:	03812403          	lw	s0,56(sp)
4001ff88:	03412483          	lw	s1,52(sp)
4001ff8c:	03012903          	lw	s2,48(sp)
4001ff90:	02c12983          	lw	s3,44(sp)
4001ff94:	02812a03          	lw	s4,40(sp)
4001ff98:	02412a83          	lw	s5,36(sp)
4001ff9c:	04010113          	addi	sp,sp,64
4001ffa0:	00008067          	ret
		ptr |= buf[i] << 8 * (len - 1 - i);
4001ffa4:	01c10713          	addi	a4,sp,28
4001ffa8:	00a70733          	add	a4,a4,a0
4001ffac:	00074703          	lbu	a4,0(a4)
	for (i = len - 1; i >= 0; i--) {
4001ffb0:	fff50513          	addi	a0,a0,-1
		ptr |= buf[i] << 8 * (len - 1 - i);
4001ffb4:	00f71733          	sll	a4,a4,a5
4001ffb8:	00e4e4b3          	or	s1,s1,a4
	for (i = len - 1; i >= 0; i--) {
4001ffbc:	00878793          	addi	a5,a5,8
4001ffc0:	f9dff06f          	j	4001ff5c <cmd_net_pkt+0x78>
	net_pkt_get_info(&rx, &tx, NULL, NULL);
4001ffc4:	01c10593          	addi	a1,sp,28
4001ffc8:	01810513          	addi	a0,sp,24
4001ffcc:	00000693          	li	a3,0
4001ffd0:	00000613          	li	a2,0
4001ffd4:	800f30ef          	jal	ra,40012fd4 <net_pkt_get_info>
	if (is_pkt_part_of_slab(rx, ptr) || is_pkt_part_of_slab(tx, ptr)) {
4001ffd8:	01812503          	lw	a0,24(sp)
4001ffdc:	00048593          	mv	a1,s1
4001ffe0:	a20ff0ef          	jal	ra,4001f200 <is_pkt_part_of_slab>
4001ffe4:	02051263          	bnez	a0,40020008 <cmd_net_pkt+0x124>
4001ffe8:	01c12503          	lw	a0,28(sp)
4001ffec:	00048593          	mv	a1,s1
4001fff0:	a10ff0ef          	jal	ra,4001f200 <is_pkt_part_of_slab>
		if (!is_pkt_ptr_valid(pkt)) {
4001fff4:	00051a63          	bnez	a0,40020008 <cmd_net_pkt+0x124>
			PR_ERROR("Pointer is not recognized as net_pkt (%s).\n",
4001fff8:	4002e637          	lui	a2,0x4002e
4001fffc:	00492683          	lw	a3,4(s2)
40020000:	f1460613          	addi	a2,a2,-236 # 4002df14 <CSWTCH.14405+0x938>
40020004:	f6dff06f          	j	4001ff70 <cmd_net_pkt+0x8c>
	PR("net_pkt %p buffer chain:\n", pkt);
40020008:	4002e637          	lui	a2,0x4002e
4002000c:	00048693          	mv	a3,s1
40020010:	f4060613          	addi	a2,a2,-192 # 4002df40 <CSWTCH.14405+0x964>
40020014:	00800593          	li	a1,8
40020018:	00040513          	mv	a0,s0
	struct net_buf *buf = pkt->buffer;
4002001c:	0084a903          	lw	s2,8(s1)
	PR("%p[%ld]", pkt, atomic_get(&pkt->atomic_ref));
40020020:	02048a13          	addi	s4,s1,32
	PR("net_pkt %p buffer chain:\n", pkt);
40020024:	c8de50ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("%p[%ld]", pkt, atomic_get(&pkt->atomic_ref));
40020028:	000a0513          	mv	a0,s4
4002002c:	7bd0a0ef          	jal	ra,4002afe8 <atomic_get>
40020030:	4002e637          	lui	a2,0x4002e
40020034:	00050713          	mv	a4,a0
40020038:	00048693          	mv	a3,s1
4002003c:	f5c60613          	addi	a2,a2,-164 # 4002df5c <CSWTCH.14405+0x980>
40020040:	00800593          	li	a1,8
40020044:	00040513          	mv	a0,s0
40020048:	c69e50ef          	jal	ra,40005cb0 <shell_fprintf>
	if (buf) {
4002004c:	06090263          	beqz	s2,400200b0 <cmd_net_pkt+0x1cc>
		PR("->");
40020050:	4002e9b7          	lui	s3,0x4002e
40020054:	f6498613          	addi	a2,s3,-156 # 4002df64 <CSWTCH.14405+0x988>
40020058:	00800593          	li	a1,8
4002005c:	00040513          	mv	a0,s0
40020060:	c51e50ef          	jal	ra,40005cb0 <shell_fprintf>
		PR("%p[%ld/%u (%u/%u)]", buf, atomic_get(&pkt->atomic_ref),
40020064:	4002eab7          	lui	s5,0x4002e
40020068:	000a0513          	mv	a0,s4
4002006c:	77d0a0ef          	jal	ra,4002afe8 <atomic_get>
40020070:	01095783          	lhu	a5,16(s2)
40020074:	00a12623          	sw	a0,12(sp)
	return net_buf_simple_max_len(&buf->b);
40020078:	00c90513          	addi	a0,s2,12
4002007c:	00f12423          	sw	a5,8(sp)
40020080:	b19e90ef          	jal	ra,40009b98 <net_buf_simple_max_len>
40020084:	01295883          	lhu	a7,18(s2)
40020088:	00812783          	lw	a5,8(sp)
4002008c:	00c12703          	lw	a4,12(sp)
40020090:	00050813          	mv	a6,a0
40020094:	00090693          	mv	a3,s2
40020098:	f68a8613          	addi	a2,s5,-152 # 4002df68 <CSWTCH.14405+0x98c>
4002009c:	00800593          	li	a1,8
400200a0:	00040513          	mv	a0,s0
400200a4:	c0de50ef          	jal	ra,40005cb0 <shell_fprintf>
		buf = buf->frags;
400200a8:	00492903          	lw	s2,4(s2)
		if (buf) {
400200ac:	02091c63          	bnez	s2,400200e4 <cmd_net_pkt+0x200>
	PR("\n");
400200b0:	4002e937          	lui	s2,0x4002e
400200b4:	48c90613          	addi	a2,s2,1164 # 4002e48c <CSWTCH.14405+0xeb0>
400200b8:	00800593          	li	a1,8
400200bc:	00040513          	mv	a0,s0
400200c0:	bf1e50ef          	jal	ra,40005cb0 <shell_fprintf>
		PR("\n");
400200c4:	48c90613          	addi	a2,s2,1164
400200c8:	00800593          	li	a1,8
400200cc:	00040513          	mv	a0,s0
400200d0:	be1e50ef          	jal	ra,40005cb0 <shell_fprintf>
	struct net_buf *buf = pkt->buffer;
400200d4:	0084a903          	lw	s2,8(s1)
	if (!buf || buf->ref == 0) {
400200d8:	02091063          	bnez	s2,400200f8 <cmd_net_pkt+0x214>
	return 0;
400200dc:	00000513          	li	a0,0
400200e0:	ea1ff06f          	j	4001ff80 <cmd_net_pkt+0x9c>
			PR("->");
400200e4:	f6498613          	addi	a2,s3,-156
400200e8:	00800593          	li	a1,8
400200ec:	00040513          	mv	a0,s0
400200f0:	bc1e50ef          	jal	ra,40005cb0 <shell_fprintf>
	while (buf) {
400200f4:	f75ff06f          	j	40020068 <cmd_net_pkt+0x184>
	if (!buf || buf->ref == 0) {
400200f8:	00894783          	lbu	a5,8(s2)
400200fc:	fe0780e3          	beqz	a5,400200dc <cmd_net_pkt+0x1f8>
	PR("net_pkt %p buffer chain hexdump:\n", pkt);
40020100:	4002e637          	lui	a2,0x4002e
40020104:	00048693          	mv	a3,s1
40020108:	f7c60613          	addi	a2,a2,-132 # 4002df7c <CSWTCH.14405+0x9a0>
4002010c:	00800593          	li	a1,8
40020110:	00040513          	mv	a0,s0
40020114:	b9de50ef          	jal	ra,40005cb0 <shell_fprintf>
	int i = 0;
40020118:	00000493          	li	s1,0
		PR("net_buf[%d] %p\n", i++, buf);
4002011c:	4002e9b7          	lui	s3,0x4002e
40020120:	00048693          	mv	a3,s1
40020124:	00090713          	mv	a4,s2
40020128:	fa098613          	addi	a2,s3,-96 # 4002dfa0 <CSWTCH.14405+0x9c4>
4002012c:	00800593          	li	a1,8
40020130:	00040513          	mv	a0,s0
40020134:	b7de50ef          	jal	ra,40005cb0 <shell_fprintf>
		shell_hexdump(sh, buf->data, buf->len);
40020138:	01095603          	lhu	a2,16(s2)
4002013c:	00c92583          	lw	a1,12(s2)
40020140:	00040513          	mv	a0,s0
		PR("net_buf[%d] %p\n", i++, buf);
40020144:	00148493          	addi	s1,s1,1
		shell_hexdump(sh, buf->data, buf->len);
40020148:	dc5e50ef          	jal	ra,40005f0c <shell_hexdump>
		buf = buf->frags;
4002014c:	00492903          	lw	s2,4(s2)
	while (buf) {
40020150:	fc0918e3          	bnez	s2,40020120 <cmd_net_pkt+0x23c>
40020154:	f89ff06f          	j	400200dc <cmd_net_pkt+0x1f8>
		PR_INFO("Pointer value must be given.\n");
40020158:	4002e637          	lui	a2,0x4002e
4002015c:	fb060613          	addi	a2,a2,-80 # 4002dfb0 <CSWTCH.14405+0x9d4>
40020160:	00200593          	li	a1,2
40020164:	b4de50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
40020168:	e15ff06f          	j	4001ff7c <cmd_net_pkt+0x98>

4002016c <ping_cleanup>:
{
4002016c:	ff010113          	addi	sp,sp,-16
40020170:	00812423          	sw	s0,8(sp)
40020174:	00050413          	mv	s0,a0
	net_icmpv6_unregister_handler(&ping6_handler);
40020178:	4003d537          	lui	a0,0x4003d
4002017c:	9bc50513          	addi	a0,a0,-1604 # 4003c9bc <ping6_handler>
{
40020180:	00112623          	sw	ra,12(sp)
	net_icmpv6_unregister_handler(&ping6_handler);
40020184:	a99f50ef          	jal	ra,40015c1c <net_icmpv6_unregister_handler>
	net_icmpv4_unregister_handler(&ping4_handler);
40020188:	4003d537          	lui	a0,0x4003d
4002018c:	9b050513          	addi	a0,a0,-1616 # 4003c9b0 <ping4_handler>
40020190:	aa4f50ef          	jal	ra,40015434 <net_icmpv4_unregister_handler>
	shell_set_bypass(ctx->sh, NULL);
40020194:	04842503          	lw	a0,72(s0)
}
40020198:	00812403          	lw	s0,8(sp)
4002019c:	00c12083          	lw	ra,12(sp)
	shell_set_bypass(ctx->sh, NULL);
400201a0:	00000593          	li	a1,0
}
400201a4:	01010113          	addi	sp,sp,16
	shell_set_bypass(ctx->sh, NULL);
400201a8:	e4de506f          	j	40005ff4 <shell_set_bypass>

400201ac <ping_done>:
{
400201ac:	ff010113          	addi	sp,sp,-16
400201b0:	00112623          	sw	ra,12(sp)
400201b4:	00812423          	sw	s0,8(sp)
400201b8:	00050413          	mv	s0,a0
	k_work_cancel_delayable(&ctx->work);
400201bc:	480090ef          	jal	ra,4002963c <k_work_cancel_delayable>
	ping_cleanup(ctx);
400201c0:	00040513          	mv	a0,s0
400201c4:	fa9ff0ef          	jal	ra,4002016c <ping_cleanup>
	shell_fprintf(ctx->sh, SHELL_NORMAL, "");
400201c8:	04842503          	lw	a0,72(s0)
}
400201cc:	00812403          	lw	s0,8(sp)
400201d0:	00c12083          	lw	ra,12(sp)
	shell_fprintf(ctx->sh, SHELL_NORMAL, "");
400201d4:	4002c637          	lui	a2,0x4002c
400201d8:	ed860613          	addi	a2,a2,-296 # 4002bed8 <__clz_tab+0x2ac>
400201dc:	00800593          	li	a1,8
}
400201e0:	01010113          	addi	sp,sp,16
	shell_fprintf(ctx->sh, SHELL_NORMAL, "");
400201e4:	acde506f          	j	40005cb0 <shell_fprintf>

400201e8 <handle_ipv4_echo_reply>:
{
400201e8:	fa010113          	addi	sp,sp,-96
400201ec:	05212823          	sw	s2,80(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
400201f0:	00400793          	li	a5,4
{
400201f4:	00058913          	mv	s2,a1
	icmp_echo = (struct net_icmpv4_echo_req *)net_pkt_get_data(pkt,
400201f8:	02810593          	addi	a1,sp,40
{
400201fc:	04812c23          	sw	s0,88(sp)
40020200:	04112e23          	sw	ra,92(sp)
40020204:	04912a23          	sw	s1,84(sp)
40020208:	05312623          	sw	s3,76(sp)
4002020c:	05412423          	sw	s4,72(sp)
40020210:	05512223          	sw	s5,68(sp)
40020214:	00050413          	mv	s0,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
40020218:	02012423          	sw	zero,40(sp)
4002021c:	02f12623          	sw	a5,44(sp)
	char time_buf[16] = { 0 };
40020220:	02012823          	sw	zero,48(sp)
40020224:	02012a23          	sw	zero,52(sp)
40020228:	02012c23          	sw	zero,56(sp)
4002022c:	02012e23          	sw	zero,60(sp)
	icmp_echo = (struct net_icmpv4_echo_req *)net_pkt_get_data(pkt,
40020230:	d4df30ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (icmp_echo == NULL) {
40020234:	02051663          	bnez	a0,40020260 <handle_ipv4_echo_reply+0x78>
		return -NET_DROP;
40020238:	ffe00513          	li	a0,-2
}
4002023c:	05c12083          	lw	ra,92(sp)
40020240:	05812403          	lw	s0,88(sp)
40020244:	05412483          	lw	s1,84(sp)
40020248:	05012903          	lw	s2,80(sp)
4002024c:	04c12983          	lw	s3,76(sp)
40020250:	04812a03          	lw	s4,72(sp)
40020254:	04412a83          	lw	s5,68(sp)
40020258:	06010113          	addi	sp,sp,96
4002025c:	00008067          	ret
	net_pkt_skip(pkt, sizeof(*icmp_echo));
40020260:	00400593          	li	a1,4
40020264:	00050493          	mv	s1,a0
40020268:	00040513          	mv	a0,s0
4002026c:	cf8f30ef          	jal	ra,40013764 <net_pkt_skip>
	if (net_pkt_remaining_data(pkt) >= sizeof(uint32_t)) {
40020270:	00040513          	mv	a0,s0
40020274:	8f5f30ef          	jal	ra,40013b68 <net_pkt_remaining_data>
40020278:	00300793          	li	a5,3
4002027c:	04a7f663          	bgeu	a5,a0,400202c8 <handle_ipv4_echo_reply+0xe0>
		if (net_pkt_read_be32(pkt, &cycles)) {
40020280:	02410593          	addi	a1,sp,36
40020284:	00040513          	mv	a0,s0
40020288:	f50f30ef          	jal	ra,400139d8 <net_pkt_read_be32>
4002028c:	fa0516e3          	bnez	a0,40020238 <handle_ipv4_echo_reply+0x50>
40020290:	2a0060ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
		cycles = k_cycle_get_32() - cycles;
40020294:	02412783          	lw	a5,36(sp)
		snprintf(time_buf, sizeof(time_buf),
40020298:	000f46b7          	lui	a3,0xf4
4002029c:	24068693          	addi	a3,a3,576 # f4240 <__rom_region_size+0xc3864>
		cycles = k_cycle_get_32() - cycles;
400202a0:	40f50533          	sub	a0,a0,a5
			return t * ((uint64_t)to_hz / from_hz);
400202a4:	00a00793          	li	a5,10
400202a8:	02a12223          	sw	a0,36(sp)
400202ac:	02f50533          	mul	a0,a0,a5
		snprintf(time_buf, sizeof(time_buf),
400202b0:	4002e637          	lui	a2,0x4002e
400202b4:	fd060613          	addi	a2,a2,-48 # 4002dfd0 <CSWTCH.14405+0x9f4>
400202b8:	01000593          	li	a1,16
400202bc:	02d556b3          	divu	a3,a0,a3
400202c0:	03010513          	addi	a0,sp,48
400202c4:	e41e80ef          	jal	ra,40009104 <snprintf>
	PR_SHELL(ping_ctx.sh, "%d bytes from %s to %s: icmp_seq=%d ttl=%d "
400202c8:	00394783          	lbu	a5,3(s2)
400202cc:	00294703          	lbu	a4,2(s2)
400202d0:	40031a37          	lui	s4,0x40031
400202d4:	00879793          	slli	a5,a5,0x8
400202d8:	00e7e7b3          	or	a5,a5,a4
400202dc:	00879693          	slli	a3,a5,0x8
400202e0:	0087d793          	srli	a5,a5,0x8
400202e4:	00f6e6b3          	or	a3,a3,a5
400202e8:	03a45783          	lhu	a5,58(s0)
400202ec:	01069693          	slli	a3,a3,0x10
400202f0:	0106d693          	srli	a3,a3,0x10
400202f4:	40f686b3          	sub	a3,a3,a5
400202f8:	ffc68693          	addi	a3,a3,-4
400202fc:	1f0a0a93          	addi	s5,s4,496 # 400311f0 <ping_ctx>
40020300:	00c90593          	addi	a1,s2,12
40020304:	00100513          	li	a0,1
40020308:	00d12e23          	sw	a3,28(sp)
4002030c:	048aa983          	lw	s3,72(s5)
40020310:	e09ef0ef          	jal	ra,40010118 <net_sprint_addr>
40020314:	00a12c23          	sw	a0,24(sp)
40020318:	01090593          	addi	a1,s2,16
4002031c:	00100513          	li	a0,1
40020320:	df9ef0ef          	jal	ra,40010118 <net_sprint_addr>
40020324:	0034c603          	lbu	a2,3(s1)
40020328:	0024c583          	lbu	a1,2(s1)
4002032c:	01812703          	lw	a4,24(sp)
40020330:	00861613          	slli	a2,a2,0x8
40020334:	00b66633          	or	a2,a2,a1
40020338:	00861813          	slli	a6,a2,0x8
4002033c:	00865613          	srli	a2,a2,0x8
40020340:	00c86833          	or	a6,a6,a2
40020344:	03010613          	addi	a2,sp,48
40020348:	00c12023          	sw	a2,0(sp)
4002034c:	00894883          	lbu	a7,8(s2)
40020350:	01c12683          	lw	a3,28(sp)
40020354:	01081813          	slli	a6,a6,0x10
40020358:	4002e637          	lui	a2,0x4002e
4002035c:	00050793          	mv	a5,a0
40020360:	01085813          	srli	a6,a6,0x10
40020364:	fdc60613          	addi	a2,a2,-36 # 4002dfdc <CSWTCH.14405+0xa00>
40020368:	00800593          	li	a1,8
4002036c:	00098513          	mv	a0,s3
40020370:	941e50ef          	jal	ra,40005cb0 <shell_fprintf>
	if (ntohs(icmp_echo->sequence) == ping_ctx.count) {
40020374:	0034c783          	lbu	a5,3(s1)
40020378:	0024c703          	lbu	a4,2(s1)
4002037c:	00879793          	slli	a5,a5,0x8
40020380:	00e7e7b3          	or	a5,a5,a4
40020384:	00879713          	slli	a4,a5,0x8
40020388:	0087d793          	srli	a5,a5,0x8
4002038c:	00f767b3          	or	a5,a4,a5
40020390:	04caa703          	lw	a4,76(s5)
40020394:	01079793          	slli	a5,a5,0x10
40020398:	0107d793          	srli	a5,a5,0x10
4002039c:	00e79663          	bne	a5,a4,400203a8 <handle_ipv4_echo_reply+0x1c0>
		ping_done(&ping_ctx);
400203a0:	1f0a0513          	addi	a0,s4,496
400203a4:	e09ff0ef          	jal	ra,400201ac <ping_done>
	net_pkt_unref(pkt);
400203a8:	00040513          	mv	a0,s0
400203ac:	b71f20ef          	jal	ra,40012f1c <net_pkt_unref>
	return NET_OK;
400203b0:	00000513          	li	a0,0
400203b4:	e89ff06f          	j	4002023c <handle_ipv4_echo_reply+0x54>

400203b8 <handle_ipv6_echo_reply>:
{
400203b8:	fa010113          	addi	sp,sp,-96
400203bc:	05212823          	sw	s2,80(sp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
400203c0:	00400793          	li	a5,4
{
400203c4:	00058913          	mv	s2,a1
	icmp_echo = (struct net_icmpv6_echo_req *)net_pkt_get_data(pkt,
400203c8:	02810593          	addi	a1,sp,40
{
400203cc:	04812c23          	sw	s0,88(sp)
400203d0:	04112e23          	sw	ra,92(sp)
400203d4:	04912a23          	sw	s1,84(sp)
400203d8:	05312623          	sw	s3,76(sp)
400203dc:	05412423          	sw	s4,72(sp)
400203e0:	05512223          	sw	s5,68(sp)
400203e4:	00050413          	mv	s0,a0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
400203e8:	02012423          	sw	zero,40(sp)
400203ec:	02f12623          	sw	a5,44(sp)
	char time_buf[16] = { 0 };
400203f0:	02012823          	sw	zero,48(sp)
400203f4:	02012a23          	sw	zero,52(sp)
400203f8:	02012c23          	sw	zero,56(sp)
400203fc:	02012e23          	sw	zero,60(sp)
	icmp_echo = (struct net_icmpv6_echo_req *)net_pkt_get_data(pkt,
40020400:	b7df30ef          	jal	ra,40013f7c <net_pkt_get_data>
	if (icmp_echo == NULL) {
40020404:	02051663          	bnez	a0,40020430 <handle_ipv6_echo_reply+0x78>
		return -NET_DROP;
40020408:	ffe00513          	li	a0,-2
}
4002040c:	05c12083          	lw	ra,92(sp)
40020410:	05812403          	lw	s0,88(sp)
40020414:	05412483          	lw	s1,84(sp)
40020418:	05012903          	lw	s2,80(sp)
4002041c:	04c12983          	lw	s3,76(sp)
40020420:	04812a03          	lw	s4,72(sp)
40020424:	04412a83          	lw	s5,68(sp)
40020428:	06010113          	addi	sp,sp,96
4002042c:	00008067          	ret
	net_pkt_skip(pkt, sizeof(*icmp_echo));
40020430:	00400593          	li	a1,4
40020434:	00050493          	mv	s1,a0
40020438:	00040513          	mv	a0,s0
4002043c:	b28f30ef          	jal	ra,40013764 <net_pkt_skip>
	if (net_pkt_remaining_data(pkt) >= sizeof(uint32_t)) {
40020440:	00040513          	mv	a0,s0
40020444:	f24f30ef          	jal	ra,40013b68 <net_pkt_remaining_data>
40020448:	00300793          	li	a5,3
4002044c:	04a7f663          	bgeu	a5,a0,40020498 <handle_ipv6_echo_reply+0xe0>
		if (net_pkt_read_be32(pkt, &cycles)) {
40020450:	02410593          	addi	a1,sp,36
40020454:	00040513          	mv	a0,s0
40020458:	d80f30ef          	jal	ra,400139d8 <net_pkt_read_be32>
4002045c:	fa0516e3          	bnez	a0,40020408 <handle_ipv6_echo_reply+0x50>
40020460:	0d0060ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
		cycles = k_cycle_get_32() - cycles;
40020464:	02412783          	lw	a5,36(sp)
		snprintf(time_buf, sizeof(time_buf),
40020468:	000f46b7          	lui	a3,0xf4
4002046c:	24068693          	addi	a3,a3,576 # f4240 <__rom_region_size+0xc3864>
		cycles = k_cycle_get_32() - cycles;
40020470:	40f50533          	sub	a0,a0,a5
40020474:	00a00793          	li	a5,10
40020478:	02a12223          	sw	a0,36(sp)
4002047c:	02f50533          	mul	a0,a0,a5
		snprintf(time_buf, sizeof(time_buf),
40020480:	4002e637          	lui	a2,0x4002e
40020484:	fd060613          	addi	a2,a2,-48 # 4002dfd0 <CSWTCH.14405+0x9f4>
40020488:	01000593          	li	a1,16
4002048c:	02d556b3          	divu	a3,a0,a3
40020490:	03010513          	addi	a0,sp,48
40020494:	c71e80ef          	jal	ra,40009104 <snprintf>
	PR_SHELL(ping_ctx.sh, "%d bytes from %s to %s: icmp_seq=%d ttl=%d "
40020498:	00594783          	lbu	a5,5(s2)
4002049c:	00494703          	lbu	a4,4(s2)
400204a0:	40031a37          	lui	s4,0x40031
400204a4:	00879793          	slli	a5,a5,0x8
400204a8:	00e7e7b3          	or	a5,a5,a4
400204ac:	00879693          	slli	a3,a5,0x8
400204b0:	0087d793          	srli	a5,a5,0x8
400204b4:	00f6e6b3          	or	a3,a3,a5
400204b8:	03a45783          	lhu	a5,58(s0)
400204bc:	01069693          	slli	a3,a3,0x10
400204c0:	0106d693          	srli	a3,a3,0x10
400204c4:	40f686b3          	sub	a3,a3,a5
400204c8:	ffc68693          	addi	a3,a3,-4
400204cc:	1f0a0a93          	addi	s5,s4,496 # 400311f0 <ping_ctx>
400204d0:	00890593          	addi	a1,s2,8
400204d4:	00200513          	li	a0,2
400204d8:	00d12e23          	sw	a3,28(sp)
400204dc:	048aa983          	lw	s3,72(s5)
400204e0:	c39ef0ef          	jal	ra,40010118 <net_sprint_addr>
400204e4:	00a12c23          	sw	a0,24(sp)
400204e8:	01890593          	addi	a1,s2,24
400204ec:	00200513          	li	a0,2
400204f0:	c29ef0ef          	jal	ra,40010118 <net_sprint_addr>
400204f4:	0034c603          	lbu	a2,3(s1)
400204f8:	0024c583          	lbu	a1,2(s1)
400204fc:	01812703          	lw	a4,24(sp)
40020500:	00861613          	slli	a2,a2,0x8
40020504:	00b66633          	or	a2,a2,a1
40020508:	00861813          	slli	a6,a2,0x8
4002050c:	00865613          	srli	a2,a2,0x8
40020510:	00c86833          	or	a6,a6,a2
40020514:	03010613          	addi	a2,sp,48
40020518:	00c12023          	sw	a2,0(sp)
4002051c:	00794883          	lbu	a7,7(s2)
40020520:	01c12683          	lw	a3,28(sp)
40020524:	01081813          	slli	a6,a6,0x10
40020528:	4002e637          	lui	a2,0x4002e
4002052c:	00050793          	mv	a5,a0
40020530:	01085813          	srli	a6,a6,0x10
40020534:	fdc60613          	addi	a2,a2,-36 # 4002dfdc <CSWTCH.14405+0xa00>
40020538:	00800593          	li	a1,8
4002053c:	00098513          	mv	a0,s3
40020540:	f70e50ef          	jal	ra,40005cb0 <shell_fprintf>
	if (ntohs(icmp_echo->sequence) == ping_ctx.count) {
40020544:	0034c783          	lbu	a5,3(s1)
40020548:	0024c703          	lbu	a4,2(s1)
4002054c:	00879793          	slli	a5,a5,0x8
40020550:	00e7e7b3          	or	a5,a5,a4
40020554:	00879713          	slli	a4,a5,0x8
40020558:	0087d793          	srli	a5,a5,0x8
4002055c:	00f767b3          	or	a5,a4,a5
40020560:	04caa703          	lw	a4,76(s5)
40020564:	01079793          	slli	a5,a5,0x10
40020568:	0107d793          	srli	a5,a5,0x10
4002056c:	00e79663          	bne	a5,a4,40020578 <handle_ipv6_echo_reply+0x1c0>
		ping_done(&ping_ctx);
40020570:	1f0a0513          	addi	a0,s4,496
40020574:	c39ff0ef          	jal	ra,400201ac <ping_done>
	net_pkt_unref(pkt);
40020578:	00040513          	mv	a0,s0
4002057c:	9a1f20ef          	jal	ra,40012f1c <net_pkt_unref>
	return NET_OK;
40020580:	00000513          	li	a0,0
40020584:	e89ff06f          	j	4002040c <handle_ipv6_echo_reply+0x54>

40020588 <cmd_net_nbr_rm>:
{
40020588:	fe010113          	addi	sp,sp,-32
4002058c:	00112e23          	sw	ra,28(sp)
40020590:	00812c23          	sw	s0,24(sp)
40020594:	00912a23          	sw	s1,20(sp)
	if (!argv[1]) {
40020598:	00462583          	lw	a1,4(a2)
4002059c:	02059663          	bnez	a1,400205c8 <cmd_net_nbr_rm+0x40>
		PR_WARNING("Neighbor IPv6 address missing.\n");
400205a0:	4002e637          	lui	a2,0x4002e
400205a4:	00c60613          	addi	a2,a2,12 # 4002e00c <CSWTCH.14405+0xa30>
400205a8:	00300593          	li	a1,3
400205ac:	f04e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
400205b0:	ff800513          	li	a0,-8
}
400205b4:	01c12083          	lw	ra,28(sp)
400205b8:	01812403          	lw	s0,24(sp)
400205bc:	01412483          	lw	s1,20(sp)
400205c0:	02010113          	addi	sp,sp,32
400205c4:	00008067          	ret
400205c8:	00050413          	mv	s0,a0
400205cc:	00060493          	mv	s1,a2
	ret = net_addr_pton(AF_INET6, argv[1], &addr);
400205d0:	00200513          	li	a0,2
400205d4:	00010613          	mv	a2,sp
400205d8:	af0ff0ef          	jal	ra,4001f8c8 <net_addr_pton>
	if (ret < 0) {
400205dc:	02055063          	bgez	a0,400205fc <cmd_net_nbr_rm+0x74>
		PR_WARNING("Cannot parse '%s'\n", argv[1]);
400205e0:	0044a683          	lw	a3,4(s1)
400205e4:	4002e637          	lui	a2,0x4002e
400205e8:	02c60613          	addi	a2,a2,44 # 4002e02c <CSWTCH.14405+0xa50>
400205ec:	00300593          	li	a1,3
400205f0:	00040513          	mv	a0,s0
400205f4:	ebce50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
400205f8:	fb9ff06f          	j	400205b0 <cmd_net_nbr_rm+0x28>
	if (!net_ipv6_nbr_rm(NULL, &addr)) {
400205fc:	00010593          	mv	a1,sp
40020600:	00000513          	li	a0,0
40020604:	bf4f70ef          	jal	ra,400179f8 <net_ipv6_nbr_rm>
		PR_WARNING("Cannot remove neighbor %s\n",
40020608:	00010593          	mv	a1,sp
	if (!net_ipv6_nbr_rm(NULL, &addr)) {
4002060c:	00051e63          	bnez	a0,40020628 <cmd_net_nbr_rm+0xa0>
		PR_WARNING("Cannot remove neighbor %s\n",
40020610:	00200513          	li	a0,2
40020614:	b05ef0ef          	jal	ra,40010118 <net_sprint_addr>
40020618:	4002e637          	lui	a2,0x4002e
4002061c:	00050693          	mv	a3,a0
40020620:	04060613          	addi	a2,a2,64 # 4002e040 <CSWTCH.14405+0xa64>
40020624:	fc9ff06f          	j	400205ec <cmd_net_nbr_rm+0x64>
		PR("Neighbor %s removed.\n", net_sprint_ipv6_addr(&addr));
40020628:	00200513          	li	a0,2
4002062c:	aedef0ef          	jal	ra,40010118 <net_sprint_addr>
40020630:	4002e637          	lui	a2,0x4002e
40020634:	00050693          	mv	a3,a0
40020638:	05c60613          	addi	a2,a2,92 # 4002e05c <CSWTCH.14405+0xa80>
4002063c:	00040513          	mv	a0,s0
40020640:	00800593          	li	a1,8
40020644:	e6ce50ef          	jal	ra,40005cb0 <shell_fprintf>
	return 0;
40020648:	00000513          	li	a0,0
4002064c:	f69ff06f          	j	400205b4 <cmd_net_nbr_rm+0x2c>

40020650 <cmd_net_ip_del>:
{
40020650:	fc010113          	addi	sp,sp,-64
40020654:	02112e23          	sw	ra,60(sp)
40020658:	02812c23          	sw	s0,56(sp)
4002065c:	02912a23          	sw	s1,52(sp)
40020660:	03212823          	sw	s2,48(sp)
40020664:	03312623          	sw	s3,44(sp)
	if (argc != 3) {
40020668:	00300793          	li	a5,3
4002066c:	00f58e63          	beq	a1,a5,40020688 <cmd_net_ip_del+0x38>
		PR_ERROR("Correct usage: net ipv4 del <index> <address>");
40020670:	4002e637          	lui	a2,0x4002e
40020674:	07460613          	addi	a2,a2,116 # 4002e074 <CSWTCH.14405+0xa98>
40020678:	00100593          	li	a1,1
4002067c:	e34e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
40020680:	fea00413          	li	s0,-22
40020684:	0440006f          	j	400206c8 <cmd_net_ip_del+0x78>
	idx = get_iface_idx(sh, argv[1]);
40020688:	00462583          	lw	a1,4(a2)
4002068c:	00050913          	mv	s2,a0
40020690:	00060493          	mv	s1,a2
40020694:	f9dfe0ef          	jal	ra,4001f630 <get_iface_idx>
	if (idx < 0) {
40020698:	00a12623          	sw	a0,12(sp)
4002069c:	02054463          	bltz	a0,400206c4 <cmd_net_ip_del+0x74>
	iface = net_if_get_by_index(idx);
400206a0:	ba5fe0ef          	jal	ra,4001f244 <net_if_get_by_index>
	if (!iface) {
400206a4:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
400206a8:	00050993          	mv	s3,a0
	if (!iface) {
400206ac:	02051e63          	bnez	a0,400206e8 <cmd_net_ip_del+0x98>
		PR_WARNING("No such interface in index %d\n", idx);
400206b0:	4002e637          	lui	a2,0x4002e
400206b4:	d5460613          	addi	a2,a2,-684 # 4002dd54 <CSWTCH.14405+0x778>
400206b8:	00300593          	li	a1,3
400206bc:	00090513          	mv	a0,s2
400206c0:	df0e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
400206c4:	ff800413          	li	s0,-8
}
400206c8:	03c12083          	lw	ra,60(sp)
400206cc:	00040513          	mv	a0,s0
400206d0:	03812403          	lw	s0,56(sp)
400206d4:	03412483          	lw	s1,52(sp)
400206d8:	03012903          	lw	s2,48(sp)
400206dc:	02c12983          	lw	s3,44(sp)
400206e0:	04010113          	addi	sp,sp,64
400206e4:	00008067          	ret
	if (net_addr_pton(AF_INET, argv[2], &addr)) {
400206e8:	0084a583          	lw	a1,8(s1)
400206ec:	01c10613          	addi	a2,sp,28
400206f0:	00100513          	li	a0,1
400206f4:	9d4ff0ef          	jal	ra,4001f8c8 <net_addr_pton>
400206f8:	00050413          	mv	s0,a0
400206fc:	02050063          	beqz	a0,4002071c <cmd_net_ip_del+0xcc>
		PR_ERROR("Invalid address: %s\n", argv[2]);
40020700:	0084a683          	lw	a3,8(s1)
40020704:	4002e637          	lui	a2,0x4002e
40020708:	da860613          	addi	a2,a2,-600 # 4002dda8 <CSWTCH.14405+0x7cc>
4002070c:	00100593          	li	a1,1
40020710:	00090513          	mv	a0,s2
40020714:	d9ce50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
40020718:	f69ff06f          	j	40020680 <cmd_net_ip_del+0x30>
	if (!net_if_ipv4_addr_rm(iface, &addr)) {
4002071c:	01c10593          	addi	a1,sp,28
40020720:	00098513          	mv	a0,s3
40020724:	9a1ee0ef          	jal	ra,4000f0c4 <net_if_ipv4_addr_rm>
40020728:	fa0510e3          	bnez	a0,400206c8 <cmd_net_ip_del+0x78>
		PR_ERROR("Failed to delete %s\n", argv[2]);
4002072c:	4002e637          	lui	a2,0x4002e
40020730:	0084a683          	lw	a3,8(s1)
40020734:	0a460613          	addi	a2,a2,164 # 4002e0a4 <CSWTCH.14405+0xac8>
40020738:	00100593          	li	a1,1
4002073c:	f81ff06f          	j	400206bc <cmd_net_ip_del+0x6c>

40020740 <cmd_net_ip_add>:
{
40020740:	fc010113          	addi	sp,sp,-64
40020744:	02112e23          	sw	ra,60(sp)
40020748:	02812c23          	sw	s0,56(sp)
4002074c:	02912a23          	sw	s1,52(sp)
40020750:	03212823          	sw	s2,48(sp)
40020754:	03312623          	sw	s3,44(sp)
	if (argc != 4) {
40020758:	00400793          	li	a5,4
4002075c:	00f58e63          	beq	a1,a5,40020778 <cmd_net_ip_add+0x38>
		PR_ERROR("Correct usage: net ipv4 add <index> <address> <netmask>\n");
40020760:	4002e637          	lui	a2,0x4002e
40020764:	0bc60613          	addi	a2,a2,188 # 4002e0bc <CSWTCH.14405+0xae0>
40020768:	00100593          	li	a1,1
4002076c:	d44e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
40020770:	fea00493          	li	s1,-22
40020774:	0440006f          	j	400207b8 <cmd_net_ip_add+0x78>
	idx = get_iface_idx(sh, argv[1]);
40020778:	00462583          	lw	a1,4(a2)
4002077c:	00050993          	mv	s3,a0
40020780:	00060413          	mv	s0,a2
40020784:	eadfe0ef          	jal	ra,4001f630 <get_iface_idx>
	if (idx < 0) {
40020788:	00a12623          	sw	a0,12(sp)
4002078c:	02054463          	bltz	a0,400207b4 <cmd_net_ip_add+0x74>
	iface = net_if_get_by_index(idx);
40020790:	ab5fe0ef          	jal	ra,4001f244 <net_if_get_by_index>
	if (!iface) {
40020794:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
40020798:	00050913          	mv	s2,a0
	if (!iface) {
4002079c:	02051e63          	bnez	a0,400207d8 <cmd_net_ip_add+0x98>
		PR_WARNING("No such interface in index %d\n", idx);
400207a0:	4002e637          	lui	a2,0x4002e
400207a4:	d5460613          	addi	a2,a2,-684 # 4002dd54 <CSWTCH.14405+0x778>
400207a8:	00300593          	li	a1,3
400207ac:	00098513          	mv	a0,s3
400207b0:	d00e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
400207b4:	ff800493          	li	s1,-8
}
400207b8:	03c12083          	lw	ra,60(sp)
400207bc:	03812403          	lw	s0,56(sp)
400207c0:	03012903          	lw	s2,48(sp)
400207c4:	02c12983          	lw	s3,44(sp)
400207c8:	00048513          	mv	a0,s1
400207cc:	03412483          	lw	s1,52(sp)
400207d0:	04010113          	addi	sp,sp,64
400207d4:	00008067          	ret
	if (net_addr_pton(AF_INET, argv[2], &addr)) {
400207d8:	00842583          	lw	a1,8(s0)
400207dc:	01c10613          	addi	a2,sp,28
400207e0:	00100513          	li	a0,1
400207e4:	8e4ff0ef          	jal	ra,4001f8c8 <net_addr_pton>
400207e8:	02050063          	beqz	a0,40020808 <cmd_net_ip_add+0xc8>
		PR_ERROR("Invalid address: %s\n", argv[2]);
400207ec:	00842683          	lw	a3,8(s0)
400207f0:	4002e637          	lui	a2,0x4002e
400207f4:	da860613          	addi	a2,a2,-600 # 4002dda8 <CSWTCH.14405+0x7cc>
400207f8:	00100593          	li	a1,1
400207fc:	00098513          	mv	a0,s3
40020800:	cb0e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
40020804:	f6dff06f          	j	40020770 <cmd_net_ip_add+0x30>
	net_if_ipv4_addr_add(iface, &addr, NET_ADDR_MANUAL, 0);
40020808:	00000693          	li	a3,0
4002080c:	00300613          	li	a2,3
40020810:	01c10593          	addi	a1,sp,28
40020814:	00090513          	mv	a0,s2
40020818:	f4cee0ef          	jal	ra,4000ef64 <net_if_ipv4_addr_add>
	if (net_addr_pton(AF_INET, argv[3], &addr)) {
4002081c:	00c42583          	lw	a1,12(s0)
40020820:	01c10613          	addi	a2,sp,28
40020824:	00100513          	li	a0,1
40020828:	8a0ff0ef          	jal	ra,4001f8c8 <net_addr_pton>
4002082c:	00050493          	mv	s1,a0
40020830:	00050a63          	beqz	a0,40020844 <cmd_net_ip_add+0x104>
		PR_ERROR("Invalid netmask: %s", argv[3]);
40020834:	4002e637          	lui	a2,0x4002e
40020838:	00c42683          	lw	a3,12(s0)
4002083c:	0f860613          	addi	a2,a2,248 # 4002e0f8 <CSWTCH.14405+0xb1c>
40020840:	fb9ff06f          	j	400207f8 <cmd_net_ip_add+0xb8>
	net_if_ipv4_set_netmask(iface, &addr);
40020844:	01c10593          	addi	a1,sp,28
40020848:	00090513          	mv	a0,s2
4002084c:	e84ee0ef          	jal	ra,4000eed0 <net_if_ipv4_set_netmask>
	return 0;
40020850:	f69ff06f          	j	400207b8 <cmd_net_ip_add+0x78>

40020854 <cmd_net_ip6_del>:
{
40020854:	fc010113          	addi	sp,sp,-64
40020858:	02112e23          	sw	ra,60(sp)
4002085c:	02812c23          	sw	s0,56(sp)
40020860:	02912a23          	sw	s1,52(sp)
40020864:	03212823          	sw	s2,48(sp)
40020868:	03312623          	sw	s3,44(sp)
	if (argc != 3) {
4002086c:	00300793          	li	a5,3
40020870:	00f58e63          	beq	a1,a5,4002088c <cmd_net_ip6_del+0x38>
		PR_ERROR("Correct usage: net ipv6 del <index> <address>\n");
40020874:	4002e637          	lui	a2,0x4002e
40020878:	10c60613          	addi	a2,a2,268 # 4002e10c <CSWTCH.14405+0xb30>
4002087c:	00100593          	li	a1,1
40020880:	c30e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
40020884:	fea00413          	li	s0,-22
40020888:	0440006f          	j	400208cc <cmd_net_ip6_del+0x78>
	idx = get_iface_idx(sh, argv[1]);
4002088c:	00462583          	lw	a1,4(a2)
40020890:	00050913          	mv	s2,a0
40020894:	00060493          	mv	s1,a2
40020898:	d99fe0ef          	jal	ra,4001f630 <get_iface_idx>
	if (idx < 0) {
4002089c:	00a12623          	sw	a0,12(sp)
400208a0:	02054463          	bltz	a0,400208c8 <cmd_net_ip6_del+0x74>
	iface = net_if_get_by_index(idx);
400208a4:	9a1fe0ef          	jal	ra,4001f244 <net_if_get_by_index>
	if (!iface) {
400208a8:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
400208ac:	00050993          	mv	s3,a0
	if (!iface) {
400208b0:	02051e63          	bnez	a0,400208ec <cmd_net_ip6_del+0x98>
		PR_WARNING("No such interface in index %d\n", idx);
400208b4:	4002e637          	lui	a2,0x4002e
400208b8:	d5460613          	addi	a2,a2,-684 # 4002dd54 <CSWTCH.14405+0x778>
400208bc:	00300593          	li	a1,3
400208c0:	00090513          	mv	a0,s2
400208c4:	bece50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
400208c8:	ff800413          	li	s0,-8
}
400208cc:	03c12083          	lw	ra,60(sp)
400208d0:	00040513          	mv	a0,s0
400208d4:	03812403          	lw	s0,56(sp)
400208d8:	03412483          	lw	s1,52(sp)
400208dc:	03012903          	lw	s2,48(sp)
400208e0:	02c12983          	lw	s3,44(sp)
400208e4:	04010113          	addi	sp,sp,64
400208e8:	00008067          	ret
	if (net_addr_pton(AF_INET6, argv[2], &addr)) {
400208ec:	0084a583          	lw	a1,8(s1)
400208f0:	01010613          	addi	a2,sp,16
400208f4:	00200513          	li	a0,2
400208f8:	fd1fe0ef          	jal	ra,4001f8c8 <net_addr_pton>
400208fc:	00050413          	mv	s0,a0
40020900:	02050063          	beqz	a0,40020920 <cmd_net_ip6_del+0xcc>
		PR_ERROR("Invalid address: %s\n", argv[2]);
40020904:	0084a683          	lw	a3,8(s1)
40020908:	4002e637          	lui	a2,0x4002e
4002090c:	da860613          	addi	a2,a2,-600 # 4002dda8 <CSWTCH.14405+0x7cc>
40020910:	00100593          	li	a1,1
40020914:	00090513          	mv	a0,s2
40020918:	b98e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
4002091c:	f69ff06f          	j	40020884 <cmd_net_ip6_del+0x30>
	if (!net_if_ipv6_addr_rm(iface, &addr)) {
40020920:	01010593          	addi	a1,sp,16
40020924:	00098513          	mv	a0,s3
40020928:	838ed0ef          	jal	ra,4000d960 <net_if_ipv6_addr_rm>
4002092c:	fa0510e3          	bnez	a0,400208cc <cmd_net_ip6_del+0x78>
		PR_ERROR("Failed to delete %s\n", argv[2]);
40020930:	0084a683          	lw	a3,8(s1)
40020934:	4002e637          	lui	a2,0x4002e
40020938:	0a460613          	addi	a2,a2,164 # 4002e0a4 <CSWTCH.14405+0xac8>
4002093c:	00100593          	li	a1,1
40020940:	00090513          	mv	a0,s2
40020944:	b6ce50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -1;
40020948:	fff00413          	li	s0,-1
4002094c:	f81ff06f          	j	400208cc <cmd_net_ip6_del+0x78>

40020950 <cmd_net_ip6_add>:
{
40020950:	fc010113          	addi	sp,sp,-64
40020954:	02112e23          	sw	ra,60(sp)
40020958:	02812c23          	sw	s0,56(sp)
4002095c:	02912a23          	sw	s1,52(sp)
40020960:	03212823          	sw	s2,48(sp)
40020964:	03312623          	sw	s3,44(sp)
	if (argc != 3) {
40020968:	00300793          	li	a5,3
4002096c:	00f58e63          	beq	a1,a5,40020988 <cmd_net_ip6_add+0x38>
		PR_ERROR("Correct usage: net ipv6 add <index> <address>\n");
40020970:	4002e637          	lui	a2,0x4002e
40020974:	13c60613          	addi	a2,a2,316 # 4002e13c <CSWTCH.14405+0xb60>
40020978:	00100593          	li	a1,1
4002097c:	b34e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
40020980:	fea00413          	li	s0,-22
40020984:	0480006f          	j	400209cc <cmd_net_ip6_add+0x7c>
	idx = get_iface_idx(sh, argv[1]);
40020988:	00462583          	lw	a1,4(a2)
4002098c:	00050913          	mv	s2,a0
40020990:	00060493          	mv	s1,a2
40020994:	c9dfe0ef          	jal	ra,4001f630 <get_iface_idx>
	if (idx < 0) {
40020998:	00a12623          	sw	a0,12(sp)
		return -ENOEXEC;
4002099c:	ff800413          	li	s0,-8
	if (idx < 0) {
400209a0:	02054663          	bltz	a0,400209cc <cmd_net_ip6_add+0x7c>
	iface = net_if_get_by_index(idx);
400209a4:	8a1fe0ef          	jal	ra,4001f244 <net_if_get_by_index>
	if (!iface) {
400209a8:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
400209ac:	00050993          	mv	s3,a0
	if (!iface) {
400209b0:	02051e63          	bnez	a0,400209ec <cmd_net_ip6_add+0x9c>
		PR_WARNING("No such interface in index %d\n", idx);
400209b4:	4002e637          	lui	a2,0x4002e
400209b8:	d5460613          	addi	a2,a2,-684 # 4002dd54 <CSWTCH.14405+0x778>
400209bc:	00300593          	li	a1,3
400209c0:	00090513          	mv	a0,s2
400209c4:	aece50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOENT;
400209c8:	ffe00413          	li	s0,-2
}
400209cc:	03c12083          	lw	ra,60(sp)
400209d0:	00040513          	mv	a0,s0
400209d4:	03812403          	lw	s0,56(sp)
400209d8:	03412483          	lw	s1,52(sp)
400209dc:	03012903          	lw	s2,48(sp)
400209e0:	02c12983          	lw	s3,44(sp)
400209e4:	04010113          	addi	sp,sp,64
400209e8:	00008067          	ret
	if (net_addr_pton(AF_INET6, argv[2], &addr)) {
400209ec:	0084a583          	lw	a1,8(s1)
400209f0:	01010613          	addi	a2,sp,16
400209f4:	00200513          	li	a0,2
400209f8:	ed1fe0ef          	jal	ra,4001f8c8 <net_addr_pton>
400209fc:	00050413          	mv	s0,a0
40020a00:	02050063          	beqz	a0,40020a20 <cmd_net_ip6_add+0xd0>
		PR_ERROR("Invalid address: %s\n", argv[2]);
40020a04:	0084a683          	lw	a3,8(s1)
40020a08:	4002e637          	lui	a2,0x4002e
40020a0c:	da860613          	addi	a2,a2,-600 # 4002dda8 <CSWTCH.14405+0x7cc>
40020a10:	00100593          	li	a1,1
40020a14:	00090513          	mv	a0,s2
40020a18:	a98e50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
40020a1c:	f65ff06f          	j	40020980 <cmd_net_ip6_add+0x30>
	if (!net_if_ipv6_addr_add(iface, &addr, NET_ADDR_MANUAL, 0)) {
40020a20:	00000693          	li	a3,0
40020a24:	00300613          	li	a2,3
40020a28:	01010593          	addi	a1,sp,16
40020a2c:	00098513          	mv	a0,s3
40020a30:	89dec0ef          	jal	ra,4000d2cc <net_if_ipv6_addr_add>
40020a34:	f8051ce3          	bnez	a0,400209cc <cmd_net_ip6_add+0x7c>
		PR_ERROR("Failed to add %s address to interface %p\n", argv[2], iface);
40020a38:	0084a683          	lw	a3,8(s1)
40020a3c:	4002e637          	lui	a2,0x4002e
40020a40:	00098713          	mv	a4,s3
40020a44:	16c60613          	addi	a2,a2,364 # 4002e16c <CSWTCH.14405+0xb90>
40020a48:	00100593          	li	a1,1
40020a4c:	00090513          	mv	a0,s2
40020a50:	a60e50ef          	jal	ra,40005cb0 <shell_fprintf>
40020a54:	f79ff06f          	j	400209cc <cmd_net_ip6_add+0x7c>

40020a58 <cmd_net_iface_down>:
{
40020a58:	fe010113          	addi	sp,sp,-32
40020a5c:	00812c23          	sw	s0,24(sp)
40020a60:	00112e23          	sw	ra,28(sp)
	idx = get_iface_idx(sh, argv[1]);
40020a64:	00462583          	lw	a1,4(a2)
{
40020a68:	00050413          	mv	s0,a0
	idx = get_iface_idx(sh, argv[1]);
40020a6c:	bc5fe0ef          	jal	ra,4001f630 <get_iface_idx>
	if (idx < 0) {
40020a70:	00a12623          	sw	a0,12(sp)
40020a74:	02054263          	bltz	a0,40020a98 <cmd_net_iface_down+0x40>
	iface = net_if_get_by_index(idx);
40020a78:	fccfe0ef          	jal	ra,4001f244 <net_if_get_by_index>
	if (!iface) {
40020a7c:	00c12683          	lw	a3,12(sp)
40020a80:	02051863          	bnez	a0,40020ab0 <cmd_net_iface_down+0x58>
		PR_WARNING("No such interface in index %d\n", idx);
40020a84:	4002e637          	lui	a2,0x4002e
40020a88:	d5460613          	addi	a2,a2,-684 # 4002dd54 <CSWTCH.14405+0x778>
40020a8c:	00300593          	li	a1,3
40020a90:	00040513          	mv	a0,s0
40020a94:	a1ce50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
40020a98:	ff800713          	li	a4,-8
}
40020a9c:	01c12083          	lw	ra,28(sp)
40020aa0:	01812403          	lw	s0,24(sp)
40020aa4:	00070513          	mv	a0,a4
40020aa8:	02010113          	addi	sp,sp,32
40020aac:	00008067          	ret
40020ab0:	00d12623          	sw	a3,12(sp)
	ret = net_if_down(iface);
40020ab4:	c81ee0ef          	jal	ra,4000f734 <net_if_down>
	if (ret) {
40020ab8:	00c12683          	lw	a3,12(sp)
	ret = net_if_down(iface);
40020abc:	00050713          	mv	a4,a0
	if (ret) {
40020ac0:	00050e63          	beqz	a0,40020adc <cmd_net_iface_down+0x84>
		PR_WARNING("Cannot take interface %d down (%d)\n", idx, ret);
40020ac4:	4002e637          	lui	a2,0x4002e
40020ac8:	19860613          	addi	a2,a2,408 # 4002e198 <CSWTCH.14405+0xbbc>
40020acc:	00300593          	li	a1,3
40020ad0:	00040513          	mv	a0,s0
40020ad4:	9dce50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
40020ad8:	fc1ff06f          	j	40020a98 <cmd_net_iface_down+0x40>
		PR("Interface %d is down\n", idx);
40020adc:	4002e637          	lui	a2,0x4002e
40020ae0:	00a12623          	sw	a0,12(sp)
40020ae4:	1bc60613          	addi	a2,a2,444 # 4002e1bc <CSWTCH.14405+0xbe0>
40020ae8:	00800593          	li	a1,8
40020aec:	00040513          	mv	a0,s0
40020af0:	9c0e50ef          	jal	ra,40005cb0 <shell_fprintf>
40020af4:	00c12703          	lw	a4,12(sp)
	return 0;
40020af8:	fa5ff06f          	j	40020a9c <cmd_net_iface_down+0x44>

40020afc <cmd_net_dns_cancel>:
{
40020afc:	ff010113          	addi	sp,sp,-16
40020b00:	00812423          	sw	s0,8(sp)
40020b04:	00112623          	sw	ra,12(sp)
40020b08:	00050413          	mv	s0,a0
	ctx = dns_resolve_get_default();
40020b0c:	5e5040ef          	jal	ra,400258f0 <dns_resolve_get_default>
	if (!ctx) {
40020b10:	04051c63          	bnez	a0,40020b68 <cmd_net_dns_cancel+0x6c>
		PR_WARNING("No default DNS context found.\n");
40020b14:	4002e637          	lui	a2,0x4002e
40020b18:	00040513          	mv	a0,s0
40020b1c:	1d460613          	addi	a2,a2,468 # 4002e1d4 <CSWTCH.14405+0xbf8>
40020b20:	00300593          	li	a1,3
40020b24:	98ce50ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
40020b28:	ff800513          	li	a0,-8
}
40020b2c:	00c12083          	lw	ra,12(sp)
40020b30:	00812403          	lw	s0,8(sp)
40020b34:	01010113          	addi	sp,sp,16
40020b38:	00008067          	ret
		if (!dns_resolve_cancel(ctx, ctx->queries[i].id)) {
40020b3c:	0907d583          	lhu	a1,144(a5)
40020b40:	13d040ef          	jal	ra,4002547c <dns_resolve_cancel>
40020b44:	02051863          	bnez	a0,40020b74 <cmd_net_dns_cancel+0x78>
		PR("Cancelled %d pending requests.\n", ret);
40020b48:	4002e637          	lui	a2,0x4002e
40020b4c:	00100693          	li	a3,1
40020b50:	1f460613          	addi	a2,a2,500 # 4002e1f4 <CSWTCH.14405+0xc18>
40020b54:	00800593          	li	a1,8
40020b58:	00040513          	mv	a0,s0
40020b5c:	954e50ef          	jal	ra,40005cb0 <shell_fprintf>
	return 0;
40020b60:	00000513          	li	a0,0
40020b64:	fc9ff06f          	j	40020b2c <cmd_net_dns_cancel+0x30>
		if (!ctx->queries[i].cb) {
40020b68:	07452703          	lw	a4,116(a0)
40020b6c:	00050793          	mv	a5,a0
40020b70:	fc0716e3          	bnez	a4,40020b3c <cmd_net_dns_cancel+0x40>
		PR("No pending DNS requests.\n");
40020b74:	4002e637          	lui	a2,0x4002e
40020b78:	21460613          	addi	a2,a2,532 # 4002e214 <CSWTCH.14405+0xc38>
40020b7c:	00800593          	li	a1,8
40020b80:	00040513          	mv	a0,s0
40020b84:	92ce50ef          	jal	ra,40005cb0 <shell_fprintf>
40020b88:	fd9ff06f          	j	40020b60 <cmd_net_dns_cancel+0x64>

40020b8c <cmd_net_conn>:
	PR("     Context   \tIface  Flags            Local             Remote\n");
40020b8c:	4002e637          	lui	a2,0x4002e
{
40020b90:	fe010113          	addi	sp,sp,-32
	PR("     Context   \tIface  Flags            Local             Remote\n");
40020b94:	23060613          	addi	a2,a2,560 # 4002e230 <CSWTCH.14405+0xc54>
40020b98:	00800593          	li	a1,8
{
40020b9c:	00112e23          	sw	ra,28(sp)
40020ba0:	00812c23          	sw	s0,24(sp)
	int count = 0;
40020ba4:	00012223          	sw	zero,4(sp)
{
40020ba8:	00050413          	mv	s0,a0
	PR("     Context   \tIface  Flags            Local             Remote\n");
40020bac:	904e50ef          	jal	ra,40005cb0 <shell_fprintf>
	net_context_foreach(context_cb, &user_data);
40020bb0:	40022537          	lui	a0,0x40022
	user_data.user_data = &count;
40020bb4:	00410793          	addi	a5,sp,4
	net_context_foreach(context_cb, &user_data);
40020bb8:	00810593          	addi	a1,sp,8
40020bbc:	81450513          	addi	a0,a0,-2028 # 40021814 <context_cb>
	user_data.user_data = &count;
40020bc0:	00f12623          	sw	a5,12(sp)
	user_data.sh = sh;
40020bc4:	00812423          	sw	s0,8(sp)
	net_context_foreach(context_cb, &user_data);
40020bc8:	d81f10ef          	jal	ra,40012948 <net_context_foreach>
	if (count == 0) {
40020bcc:	00412783          	lw	a5,4(sp)
40020bd0:	00079c63          	bnez	a5,40020be8 <cmd_net_conn+0x5c>
		PR("No connections\n");
40020bd4:	4002e637          	lui	a2,0x4002e
40020bd8:	27460613          	addi	a2,a2,628 # 4002e274 <CSWTCH.14405+0xc98>
40020bdc:	00800593          	li	a1,8
40020be0:	00040513          	mv	a0,s0
40020be4:	8cce50ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("\nTCP        Context   Src port Dst port   "
40020be8:	4002e637          	lui	a2,0x4002e
40020bec:	28460613          	addi	a2,a2,644 # 4002e284 <CSWTCH.14405+0xca8>
40020bf0:	00800593          	li	a1,8
40020bf4:	00040513          	mv	a0,s0
40020bf8:	8b8e50ef          	jal	ra,40005cb0 <shell_fprintf>
	net_tcp_foreach(tcp_cb, &user_data);
40020bfc:	40021537          	lui	a0,0x40021
40020c00:	00810593          	addi	a1,sp,8
40020c04:	c6450513          	addi	a0,a0,-924 # 40020c64 <tcp_cb>
	count = 0;
40020c08:	00012223          	sw	zero,4(sp)
	net_tcp_foreach(tcp_cb, &user_data);
40020c0c:	bd8fb0ef          	jal	ra,4001bfe4 <net_tcp_foreach>
	if (count == 0) {
40020c10:	00412783          	lw	a5,4(sp)
40020c14:	00079c63          	bnez	a5,40020c2c <cmd_net_conn+0xa0>
		PR("No TCP connections\n");
40020c18:	4002e637          	lui	a2,0x4002e
40020c1c:	2d460613          	addi	a2,a2,724 # 4002e2d4 <CSWTCH.14405+0xcf8>
40020c20:	00800593          	li	a1,8
40020c24:	00040513          	mv	a0,s0
40020c28:	888e50ef          	jal	ra,40005cb0 <shell_fprintf>
	PR_INFO("Set %s to enable %s support.\n",
40020c2c:	4002e737          	lui	a4,0x4002e
40020c30:	4002e6b7          	lui	a3,0x4002e
40020c34:	4002d637          	lui	a2,0x4002d
40020c38:	00040513          	mv	a0,s0
40020c3c:	2e870713          	addi	a4,a4,744 # 4002e2e8 <CSWTCH.14405+0xd0c>
40020c40:	2f868693          	addi	a3,a3,760 # 4002e2f8 <CSWTCH.14405+0xd1c>
40020c44:	63460613          	addi	a2,a2,1588 # 4002d634 <CSWTCH.14405+0x58>
40020c48:	00200593          	li	a1,2
40020c4c:	864e50ef          	jal	ra,40005cb0 <shell_fprintf>
}
40020c50:	01c12083          	lw	ra,28(sp)
40020c54:	01812403          	lw	s0,24(sp)
40020c58:	00000513          	li	a0,0
40020c5c:	02010113          	addi	sp,sp,32
40020c60:	00008067          	ret

40020c64 <tcp_cb>:
{
40020c64:	fc010113          	addi	sp,sp,-64
40020c68:	02112e23          	sw	ra,60(sp)
40020c6c:	02812c23          	sw	s0,56(sp)
40020c70:	03212823          	sw	s2,48(sp)
40020c74:	03412423          	sw	s4,40(sp)
40020c78:	02912a23          	sw	s1,52(sp)
40020c7c:	03312623          	sw	s3,44(sp)
40020c80:	00050413          	mv	s0,a0
	int *count = data->user_data;
40020c84:	0045a983          	lw	s3,4(a1)
	const struct shell *sh = data->sh;
40020c88:	0005a483          	lw	s1,0(a1)
	uint16_t recv_mss = net_tcp_get_supported_mss(conn);
40020c8c:	c10fb0ef          	jal	ra,4001c09c <net_tcp_get_supported_mss>
	PR("%p %p   %5u    %5u %10u %10u %5u   %s\n",
40020c90:	00442703          	lw	a4,4(s0)
40020c94:	22842883          	lw	a7,552(s0)
	uint16_t recv_mss = net_tcp_get_supported_mss(conn);
40020c98:	00050913          	mv	s2,a0
	PR("%p %p   %5u    %5u %10u %10u %5u   %s\n",
40020c9c:	02275683          	lhu	a3,34(a4)
40020ca0:	22042503          	lw	a0,544(s0)
40020ca4:	22c42a03          	lw	s4,556(s0)
40020ca8:	00869793          	slli	a5,a3,0x8
40020cac:	0086d693          	srli	a3,a3,0x8
40020cb0:	00d7e7b3          	or	a5,a5,a3
40020cb4:	02e75683          	lhu	a3,46(a4)
40020cb8:	01079793          	slli	a5,a5,0x10
40020cbc:	0107d793          	srli	a5,a5,0x10
40020cc0:	00869813          	slli	a6,a3,0x8
40020cc4:	0086d693          	srli	a3,a3,0x8
40020cc8:	00d86833          	or	a6,a6,a3
40020ccc:	01081813          	slli	a6,a6,0x10
40020cd0:	01085813          	srli	a6,a6,0x10
40020cd4:	00f12e23          	sw	a5,28(sp)
40020cd8:	00e12c23          	sw	a4,24(sp)
40020cdc:	01012a23          	sw	a6,20(sp)
40020ce0:	01112823          	sw	a7,16(sp)
40020ce4:	a28fe0ef          	jal	ra,4001ef0c <net_tcp_state_str>
40020ce8:	01c12783          	lw	a5,28(sp)
40020cec:	01012883          	lw	a7,16(sp)
40020cf0:	01412803          	lw	a6,20(sp)
40020cf4:	01812703          	lw	a4,24(sp)
40020cf8:	4002e637          	lui	a2,0x4002e
40020cfc:	00a12423          	sw	a0,8(sp)
40020d00:	01212223          	sw	s2,4(sp)
40020d04:	01412023          	sw	s4,0(sp)
40020d08:	00040693          	mv	a3,s0
40020d0c:	00048513          	mv	a0,s1
40020d10:	31860613          	addi	a2,a2,792 # 4002e318 <CSWTCH.14405+0xd3c>
40020d14:	00800593          	li	a1,8
40020d18:	f99e40ef          	jal	ra,40005cb0 <shell_fprintf>
	(*count)++;
40020d1c:	0009a783          	lw	a5,0(s3)
40020d20:	00178793          	addi	a5,a5,1
40020d24:	00f9a023          	sw	a5,0(s3)
}
40020d28:	03c12083          	lw	ra,60(sp)
40020d2c:	03812403          	lw	s0,56(sp)
40020d30:	03412483          	lw	s1,52(sp)
40020d34:	03012903          	lw	s2,48(sp)
40020d38:	02c12983          	lw	s3,44(sp)
40020d3c:	02812a03          	lw	s4,40(sp)
40020d40:	04010113          	addi	sp,sp,64
40020d44:	00008067          	ret

40020d48 <cmd_net_arp_flush>:
	PR("Flushing ARP cache.\n");
40020d48:	4002e637          	lui	a2,0x4002e
{
40020d4c:	ff010113          	addi	sp,sp,-16
	PR("Flushing ARP cache.\n");
40020d50:	34060613          	addi	a2,a2,832 # 4002e340 <CSWTCH.14405+0xd64>
40020d54:	00800593          	li	a1,8
{
40020d58:	00112623          	sw	ra,12(sp)
	PR("Flushing ARP cache.\n");
40020d5c:	f55e40ef          	jal	ra,40005cb0 <shell_fprintf>
	net_arp_clear_cache(NULL);
40020d60:	00000513          	li	a0,0
40020d64:	c74ea0ef          	jal	ra,4000b1d8 <net_arp_clear_cache>
}
40020d68:	00c12083          	lw	ra,12(sp)
40020d6c:	00000513          	li	a0,0
40020d70:	01010113          	addi	sp,sp,16
40020d74:	00008067          	ret

40020d78 <cmd_net_nbr>:
{
40020d78:	fe010113          	addi	sp,sp,-32
40020d7c:	00812c23          	sw	s0,24(sp)
	user_data.sh = sh;
40020d80:	00a12423          	sw	a0,8(sp)
{
40020d84:	00050413          	mv	s0,a0
	net_ipv6_nbr_foreach(nbr_cb, &user_data);
40020d88:	40024537          	lui	a0,0x40024
	user_data.user_data = &count;
40020d8c:	00410793          	addi	a5,sp,4
	net_ipv6_nbr_foreach(nbr_cb, &user_data);
40020d90:	00810593          	addi	a1,sp,8
40020d94:	86450513          	addi	a0,a0,-1948 # 40023864 <nbr_cb>
	user_data.user_data = &count;
40020d98:	00f12623          	sw	a5,12(sp)
{
40020d9c:	00112e23          	sw	ra,28(sp)
	int count = 0;
40020da0:	00012223          	sw	zero,4(sp)
	net_ipv6_nbr_foreach(nbr_cb, &user_data);
40020da4:	c29f60ef          	jal	ra,400179cc <net_ipv6_nbr_foreach>
	if (count == 0) {
40020da8:	00412783          	lw	a5,4(sp)
40020dac:	00079c63          	bnez	a5,40020dc4 <cmd_net_nbr+0x4c>
		PR("No neighbors.\n");
40020db0:	4002e637          	lui	a2,0x4002e
40020db4:	35860613          	addi	a2,a2,856 # 4002e358 <CSWTCH.14405+0xd7c>
40020db8:	00800593          	li	a1,8
40020dbc:	00040513          	mv	a0,s0
40020dc0:	ef1e40ef          	jal	ra,40005cb0 <shell_fprintf>
}
40020dc4:	01c12083          	lw	ra,28(sp)
40020dc8:	01812403          	lw	s0,24(sp)
40020dcc:	00000513          	li	a0,0
40020dd0:	02010113          	addi	sp,sp,32
40020dd4:	00008067          	ret

40020dd8 <cmd_net_udp_close>:
{
40020dd8:	ff010113          	addi	sp,sp,-16
	if (!udp_ctx || !net_context_is_used(udp_ctx)) {
40020ddc:	400317b7          	lui	a5,0x40031
{
40020de0:	00812423          	sw	s0,8(sp)
40020de4:	00050413          	mv	s0,a0
	if (!udp_ctx || !net_context_is_used(udp_ctx)) {
40020de8:	ad87a503          	lw	a0,-1320(a5) # 40030ad8 <udp_ctx>
{
40020dec:	00112623          	sw	ra,12(sp)
	if (!udp_ctx || !net_context_is_used(udp_ctx)) {
40020df0:	00050863          	beqz	a0,40020e00 <cmd_net_udp_close+0x28>
40020df4:	07455783          	lhu	a5,116(a0)
40020df8:	0017f793          	andi	a5,a5,1
40020dfc:	02079663          	bnez	a5,40020e28 <cmd_net_udp_close+0x50>
		PR_WARNING("Network context is not used. Cannot close.\n");
40020e00:	4002e637          	lui	a2,0x4002e
40020e04:	00040513          	mv	a0,s0
40020e08:	36860613          	addi	a2,a2,872 # 4002e368 <CSWTCH.14405+0xd8c>
40020e0c:	00300593          	li	a1,3
40020e10:	ea1e40ef          	jal	ra,40005cb0 <shell_fprintf>
40020e14:	fea00513          	li	a0,-22
}
40020e18:	00c12083          	lw	ra,12(sp)
40020e1c:	00812403          	lw	s0,8(sp)
40020e20:	01010113          	addi	sp,sp,16
40020e24:	00008067          	ret
	ret = net_context_put(udp_ctx);
40020e28:	995f00ef          	jal	ra,400117bc <net_context_put>
40020e2c:	00050693          	mv	a3,a0
	if (ret < 0) {
40020e30:	00054663          	bltz	a0,40020e3c <cmd_net_udp_close+0x64>
	return 0;
40020e34:	00000513          	li	a0,0
40020e38:	fe1ff06f          	j	40020e18 <cmd_net_udp_close+0x40>
		PR_WARNING("Cannot close UDP port (%d)\n", ret);
40020e3c:	4002e637          	lui	a2,0x4002e
40020e40:	39460613          	addi	a2,a2,916 # 4002e394 <CSWTCH.14405+0xdb8>
40020e44:	00300593          	li	a1,3
40020e48:	00040513          	mv	a0,s0
40020e4c:	e65e40ef          	jal	ra,40005cb0 <shell_fprintf>
40020e50:	fe5ff06f          	j	40020e34 <cmd_net_udp_close+0x5c>

40020e54 <tcp_connected>:
{
40020e54:	ff010113          	addi	sp,sp,-16
40020e58:	00812423          	sw	s0,8(sp)
		PR_SHELL(tcp_shell, "TCP connection failed (%d)\n", status);
40020e5c:	400317b7          	lui	a5,0x40031
{
40020e60:	00112623          	sw	ra,12(sp)
40020e64:	00050413          	mv	s0,a0
		PR_SHELL(tcp_shell, "TCP connection failed (%d)\n", status);
40020e68:	adc7a503          	lw	a0,-1316(a5) # 40030adc <tcp_shell>
	if (status < 0) {
40020e6c:	0205dc63          	bgez	a1,40020ea4 <tcp_connected+0x50>
		PR_SHELL(tcp_shell, "TCP connection failed (%d)\n", status);
40020e70:	4002e637          	lui	a2,0x4002e
40020e74:	00058693          	mv	a3,a1
40020e78:	3b060613          	addi	a2,a2,944 # 4002e3b0 <CSWTCH.14405+0xdd4>
40020e7c:	00800593          	li	a1,8
40020e80:	e31e40ef          	jal	ra,40005cb0 <shell_fprintf>
		net_context_put(context);
40020e84:	00040513          	mv	a0,s0
40020e88:	935f00ef          	jal	ra,400117bc <net_context_put>
}
40020e8c:	00c12083          	lw	ra,12(sp)
40020e90:	00812403          	lw	s0,8(sp)
		tcp_ctx = NULL;
40020e94:	400317b7          	lui	a5,0x40031
40020e98:	ae07a023          	sw	zero,-1312(a5) # 40030ae0 <tcp_ctx>
}
40020e9c:	01010113          	addi	sp,sp,16
40020ea0:	00008067          	ret
40020ea4:	00812403          	lw	s0,8(sp)
40020ea8:	00c12083          	lw	ra,12(sp)
		PR_SHELL(tcp_shell, "TCP connected\n");
40020eac:	4002e637          	lui	a2,0x4002e
40020eb0:	3cc60613          	addi	a2,a2,972 # 4002e3cc <CSWTCH.14405+0xdf0>
40020eb4:	00800593          	li	a1,8
}
40020eb8:	01010113          	addi	sp,sp,16
		PR_SHELL(tcp_shell, "TCP connected\n");
40020ebc:	df5e406f          	j	40005cb0 <shell_fprintf>

40020ec0 <ping_bypass>:
	for (size_t i = 0; i < len; i++) {
40020ec0:	00000793          	li	a5,0
		if (data[i] == ASCII_CTRL_C) {
40020ec4:	00300713          	li	a4,3
	for (size_t i = 0; i < len; i++) {
40020ec8:	00c79463          	bne	a5,a2,40020ed0 <ping_bypass+0x10>
40020ecc:	00008067          	ret
		if (data[i] == ASCII_CTRL_C) {
40020ed0:	00f586b3          	add	a3,a1,a5
40020ed4:	0006c683          	lbu	a3,0(a3)
40020ed8:	02e69863          	bne	a3,a4,40020f08 <ping_bypass+0x48>
{
40020edc:	ff010113          	addi	sp,sp,-16
40020ee0:	00812423          	sw	s0,8(sp)
			k_work_cancel_delayable(&ping_ctx.work);
40020ee4:	40031437          	lui	s0,0x40031
40020ee8:	1f040513          	addi	a0,s0,496 # 400311f0 <ping_ctx>
{
40020eec:	00112623          	sw	ra,12(sp)
			k_work_cancel_delayable(&ping_ctx.work);
40020ef0:	74c080ef          	jal	ra,4002963c <k_work_cancel_delayable>
			ping_cleanup(&ping_ctx);
40020ef4:	1f040513          	addi	a0,s0,496
}
40020ef8:	00812403          	lw	s0,8(sp)
40020efc:	00c12083          	lw	ra,12(sp)
40020f00:	01010113          	addi	sp,sp,16
			ping_cleanup(&ping_ctx);
40020f04:	a68ff06f          	j	4002016c <ping_cleanup>
	for (size_t i = 0; i < len; i++) {
40020f08:	00178793          	addi	a5,a5,1
40020f0c:	fbdff06f          	j	40020ec8 <ping_bypass+0x8>

40020f10 <cmd_net_arp>:
	if (!argv[arg]) {
40020f10:	00462783          	lw	a5,4(a2)
40020f14:	06079063          	bnez	a5,40020f74 <cmd_net_arp+0x64>
{
40020f18:	fe010113          	addi	sp,sp,-32
40020f1c:	00812c23          	sw	s0,24(sp)
		user_data.sh = sh;
40020f20:	00a12423          	sw	a0,8(sp)
40020f24:	00050413          	mv	s0,a0
		if (net_arp_foreach(arp_cb, &user_data) == 0) {
40020f28:	40024537          	lui	a0,0x40024
		user_data.user_data = &count;
40020f2c:	00410793          	addi	a5,sp,4
		if (net_arp_foreach(arp_cb, &user_data) == 0) {
40020f30:	00810593          	addi	a1,sp,8
40020f34:	a6c50513          	addi	a0,a0,-1428 # 40023a6c <arp_cb>
{
40020f38:	00112e23          	sw	ra,28(sp)
		int count = 0;
40020f3c:	00012223          	sw	zero,4(sp)
		user_data.user_data = &count;
40020f40:	00f12623          	sw	a5,12(sp)
		if (net_arp_foreach(arp_cb, &user_data) == 0) {
40020f44:	c34ea0ef          	jal	ra,4000b378 <net_arp_foreach>
40020f48:	00051c63          	bnez	a0,40020f60 <cmd_net_arp+0x50>
			PR("ARP cache is empty.\n");
40020f4c:	4002e637          	lui	a2,0x4002e
40020f50:	3dc60613          	addi	a2,a2,988 # 4002e3dc <CSWTCH.14405+0xe00>
40020f54:	00800593          	li	a1,8
40020f58:	00040513          	mv	a0,s0
40020f5c:	d55e40ef          	jal	ra,40005cb0 <shell_fprintf>
}
40020f60:	01c12083          	lw	ra,28(sp)
40020f64:	01812403          	lw	s0,24(sp)
40020f68:	00000513          	li	a0,0
40020f6c:	02010113          	addi	sp,sp,32
40020f70:	00008067          	ret
40020f74:	00000513          	li	a0,0
40020f78:	00008067          	ret

40020f7c <cmd_net_udp>:
static int cmd_net_udp(const struct shell *sh, size_t argc, char *argv[])
40020f7c:	00000513          	li	a0,0
40020f80:	00008067          	ret

40020f84 <cmd_net_dns_query>:
{
40020f84:	fe010113          	addi	sp,sp,-32
40020f88:	00112e23          	sw	ra,28(sp)
40020f8c:	00812c23          	sw	s0,24(sp)
40020f90:	00912a23          	sw	s1,20(sp)
40020f94:	01212823          	sw	s2,16(sp)
	host = argv[arg++];
40020f98:	00462483          	lw	s1,4(a2)
	if (!host) {
40020f9c:	02049863          	bnez	s1,40020fcc <cmd_net_dns_query+0x48>
		PR_WARNING("Hostname not specified.\n");
40020fa0:	4002e637          	lui	a2,0x4002e
40020fa4:	3f460613          	addi	a2,a2,1012 # 4002e3f4 <CSWTCH.14405+0xe18>
40020fa8:	00300593          	li	a1,3
			PR_WARNING("Unknown query type, specify either "
40020fac:	d05e40ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
40020fb0:	ff800513          	li	a0,-8
}
40020fb4:	01c12083          	lw	ra,28(sp)
40020fb8:	01812403          	lw	s0,24(sp)
40020fbc:	01412483          	lw	s1,20(sp)
40020fc0:	01012903          	lw	s2,16(sp)
40020fc4:	02010113          	addi	sp,sp,32
40020fc8:	00008067          	ret
	if (argv[arg]) {
40020fcc:	00862903          	lw	s2,8(a2)
40020fd0:	00050413          	mv	s0,a0
40020fd4:	02090663          	beqz	s2,40021000 <cmd_net_dns_query+0x7c>
		if (strcmp(type, "A") == 0) {
40020fd8:	4002e5b7          	lui	a1,0x4002e
40020fdc:	41058593          	addi	a1,a1,1040 # 4002e410 <CSWTCH.14405+0xe34>
40020fe0:	00090513          	mv	a0,s2
40020fe4:	f89e70ef          	jal	ra,40008f6c <strcmp>
40020fe8:	02051063          	bnez	a0,40021008 <cmd_net_dns_query+0x84>
			PR("IPv4 address type\n");
40020fec:	4002e637          	lui	a2,0x4002e
40020ff0:	41460613          	addi	a2,a2,1044 # 4002e414 <CSWTCH.14405+0xe38>
40020ff4:	00800593          	li	a1,8
40020ff8:	00040513          	mv	a0,s0
40020ffc:	cb5e40ef          	jal	ra,40005cb0 <shell_fprintf>
	enum dns_query_type qtype = DNS_QUERY_TYPE_A;
40021000:	00100613          	li	a2,1
40021004:	0300006f          	j	40021034 <cmd_net_dns_query+0xb0>
		} else if (strcmp(type, "AAAA") == 0) {
40021008:	4002e5b7          	lui	a1,0x4002e
4002100c:	42858593          	addi	a1,a1,1064 # 4002e428 <CSWTCH.14405+0xe4c>
40021010:	00090513          	mv	a0,s2
40021014:	f59e70ef          	jal	ra,40008f6c <strcmp>
40021018:	06051663          	bnez	a0,40021084 <cmd_net_dns_query+0x100>
			PR("IPv6 address type\n");
4002101c:	4002e637          	lui	a2,0x4002e
40021020:	43060613          	addi	a2,a2,1072 # 4002e430 <CSWTCH.14405+0xe54>
40021024:	00800593          	li	a1,8
40021028:	00040513          	mv	a0,s0
4002102c:	c85e40ef          	jal	ra,40005cb0 <shell_fprintf>
			qtype = DNS_QUERY_TYPE_AAAA;
40021030:	01c00613          	li	a2,28
40021034:	00c12623          	sw	a2,12(sp)
				    uint16_t *dns_id,
				    dns_resolve_cb_t cb,
				    void *user_data,
				    int32_t timeout)
{
	return dns_resolve_name(dns_resolve_get_default(),
40021038:	0b9040ef          	jal	ra,400258f0 <dns_resolve_get_default>
4002103c:	00c12603          	lw	a2,12(sp)
40021040:	40022737          	lui	a4,0x40022
40021044:	7e870713          	addi	a4,a4,2024 # 400227e8 <dns_result_cb>
40021048:	00000693          	li	a3,0
4002104c:	7d000813          	li	a6,2000
40021050:	00040793          	mv	a5,s0
40021054:	00048593          	mv	a1,s1
40021058:	42c040ef          	jal	ra,40025484 <dns_resolve_name>
4002105c:	00050713          	mv	a4,a0
		PR_WARNING("Cannot resolve '%s' (%d)\n", host, ret);
40021060:	00048693          	mv	a3,s1
	if (ret < 0) {
40021064:	02055a63          	bgez	a0,40021098 <cmd_net_dns_query+0x114>
		PR_WARNING("Cannot resolve '%s' (%d)\n", host, ret);
40021068:	4002e637          	lui	a2,0x4002e
4002106c:	47460613          	addi	a2,a2,1140 # 4002e474 <CSWTCH.14405+0xe98>
40021070:	00300593          	li	a1,3
40021074:	00040513          	mv	a0,s0
40021078:	c39e40ef          	jal	ra,40005cb0 <shell_fprintf>
	return 0;
4002107c:	00000513          	li	a0,0
40021080:	f35ff06f          	j	40020fb4 <cmd_net_dns_query+0x30>
			PR_WARNING("Unknown query type, specify either "
40021084:	4002e637          	lui	a2,0x4002e
40021088:	44460613          	addi	a2,a2,1092 # 4002e444 <CSWTCH.14405+0xe68>
4002108c:	00300593          	li	a1,3
40021090:	00040513          	mv	a0,s0
40021094:	f19ff06f          	j	40020fac <cmd_net_dns_query+0x28>
		PR("Query for '%s' sent.\n", host);
40021098:	4002e637          	lui	a2,0x4002e
4002109c:	49060613          	addi	a2,a2,1168 # 4002e490 <CSWTCH.14405+0xeb4>
400210a0:	00800593          	li	a1,8
400210a4:	00040513          	mv	a0,s0
400210a8:	c09e40ef          	jal	ra,40005cb0 <shell_fprintf>
400210ac:	fd1ff06f          	j	4002107c <cmd_net_dns_query+0xf8>

400210b0 <cmd_net_dns>:
{
400210b0:	ff010113          	addi	sp,sp,-16
400210b4:	00112623          	sw	ra,12(sp)
400210b8:	00812423          	sw	s0,8(sp)
400210bc:	00912223          	sw	s1,4(sp)
	if (argv[1]) {
400210c0:	00462783          	lw	a5,4(a2)
400210c4:	00078863          	beqz	a5,400210d4 <cmd_net_dns+0x24>
		cmd_net_dns_query(sh, argc, argv);
400210c8:	ebdff0ef          	jal	ra,40020f84 <cmd_net_dns_query>
		return 0;
400210cc:	00000513          	li	a0,0
400210d0:	02c0006f          	j	400210fc <cmd_net_dns+0x4c>
400210d4:	00050493          	mv	s1,a0
	ctx = dns_resolve_get_default();
400210d8:	019040ef          	jal	ra,400258f0 <dns_resolve_get_default>
400210dc:	00050413          	mv	s0,a0
	if (!ctx) {
400210e0:	02051863          	bnez	a0,40021110 <cmd_net_dns+0x60>
		PR_WARNING("No default DNS context found.\n");
400210e4:	4002e637          	lui	a2,0x4002e
400210e8:	00048513          	mv	a0,s1
400210ec:	1d460613          	addi	a2,a2,468 # 4002e1d4 <CSWTCH.14405+0xbf8>
400210f0:	00300593          	li	a1,3
400210f4:	bbde40ef          	jal	ra,40005cb0 <shell_fprintf>
400210f8:	ff800513          	li	a0,-8
}
400210fc:	00c12083          	lw	ra,12(sp)
40021100:	00812403          	lw	s0,8(sp)
40021104:	00412483          	lw	s1,4(sp)
40021108:	01010113          	addi	sp,sp,16
4002110c:	00008067          	ret
	PR("DNS servers:\n");
40021110:	4002e637          	lui	a2,0x4002e
40021114:	4a860613          	addi	a2,a2,1192 # 4002e4a8 <CSWTCH.14405+0xecc>
40021118:	00800593          	li	a1,8
4002111c:	00048513          	mv	a0,s1
40021120:	b91e40ef          	jal	ra,40005cb0 <shell_fprintf>
		if (ctx->servers[i].dns_server.sa_family == AF_INET) {
40021124:	00045783          	lhu	a5,0(s0)
40021128:	00100713          	li	a4,1
4002112c:	0ae79063          	bne	a5,a4,400211cc <cmd_net_dns+0x11c>
			PR("\t%s:%u\n",
40021130:	00440593          	addi	a1,s0,4
40021134:	00100513          	li	a0,1
40021138:	fe1ee0ef          	jal	ra,40010118 <net_sprint_addr>
4002113c:	00245783          	lhu	a5,2(s0)
40021140:	4002e637          	lui	a2,0x4002e
40021144:	00050693          	mv	a3,a0
40021148:	00879713          	slli	a4,a5,0x8
4002114c:	0087d793          	srli	a5,a5,0x8
40021150:	00f76733          	or	a4,a4,a5
40021154:	01071713          	slli	a4,a4,0x10
40021158:	01075713          	srli	a4,a4,0x10
4002115c:	4b860613          	addi	a2,a2,1208 # 4002e4b8 <CSWTCH.14405+0xedc>
			PR("\t[%s]:%u\n",
40021160:	00800593          	li	a1,8
40021164:	00048513          	mv	a0,s1
40021168:	b49e40ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("Pending queries:\n");
4002116c:	4002e637          	lui	a2,0x4002e
40021170:	4cc60613          	addi	a2,a2,1228 # 4002e4cc <CSWTCH.14405+0xef0>
40021174:	00800593          	li	a1,8
40021178:	00048513          	mv	a0,s1
4002117c:	b35e40ef          	jal	ra,40005cb0 <shell_fprintf>
		if (!ctx->queries[i].cb || !ctx->queries[i].query) {
40021180:	07442783          	lw	a5,116(s0)
40021184:	f40784e3          	beqz	a5,400210cc <cmd_net_dns+0x1c>
40021188:	08842783          	lw	a5,136(s0)
4002118c:	f40780e3          	beqz	a5,400210cc <cmd_net_dns+0x1c>
	return z_timeout_remaining(&dwork->timeout);
40021190:	05040513          	addi	a0,s0,80
40021194:	055090ef          	jal	ra,4002a9e8 <z_timeout_remaining>
		if (ctx->queries[i].query_type == DNS_QUERY_TYPE_A) {
40021198:	08c42703          	lw	a4,140(s0)
			return ((uint32_t)t) * (to_hz / from_hz);
4002119c:	00a00793          	li	a5,10
400211a0:	00100693          	li	a3,1
400211a4:	02a787b3          	mul	a5,a5,a0
400211a8:	06d71063          	bne	a4,a3,40021208 <cmd_net_dns+0x158>
			PR("\tIPv4[%u]: %s remaining %d\n",
400211ac:	08842703          	lw	a4,136(s0)
400211b0:	09045683          	lhu	a3,144(s0)
400211b4:	4002e637          	lui	a2,0x4002e
400211b8:	4e060613          	addi	a2,a2,1248 # 4002e4e0 <CSWTCH.14405+0xf04>
			PR("\tIPv6[%u]: %s remaining %d\n",
400211bc:	00800593          	li	a1,8
400211c0:	00048513          	mv	a0,s1
400211c4:	aede40ef          	jal	ra,40005cb0 <shell_fprintf>
400211c8:	f05ff06f          	j	400210cc <cmd_net_dns+0x1c>
		} else if (ctx->servers[i].dns_server.sa_family == AF_INET6) {
400211cc:	00200713          	li	a4,2
400211d0:	f8e79ee3          	bne	a5,a4,4002116c <cmd_net_dns+0xbc>
			PR("\t[%s]:%u\n",
400211d4:	00440593          	addi	a1,s0,4
400211d8:	00200513          	li	a0,2
400211dc:	f3dee0ef          	jal	ra,40010118 <net_sprint_addr>
400211e0:	00245783          	lhu	a5,2(s0)
400211e4:	4002e637          	lui	a2,0x4002e
400211e8:	00050693          	mv	a3,a0
400211ec:	00879713          	slli	a4,a5,0x8
400211f0:	0087d793          	srli	a5,a5,0x8
400211f4:	00f76733          	or	a4,a4,a5
400211f8:	01071713          	slli	a4,a4,0x10
400211fc:	01075713          	srli	a4,a4,0x10
40021200:	4c060613          	addi	a2,a2,1216 # 4002e4c0 <CSWTCH.14405+0xee4>
40021204:	f5dff06f          	j	40021160 <cmd_net_dns+0xb0>
		} else if (ctx->queries[i].query_type == DNS_QUERY_TYPE_AAAA) {
40021208:	01c00693          	li	a3,28
4002120c:	ecd710e3          	bne	a4,a3,400210cc <cmd_net_dns+0x1c>
			PR("\tIPv6[%u]: %s remaining %d\n",
40021210:	4002e637          	lui	a2,0x4002e
40021214:	08842703          	lw	a4,136(s0)
40021218:	09045683          	lhu	a3,144(s0)
4002121c:	4fc60613          	addi	a2,a2,1276 # 4002e4fc <CSWTCH.14405+0xf20>
40021220:	f9dff06f          	j	400211bc <cmd_net_dns+0x10c>

40021224 <udp_sent>:
	PR_SHELL(udp_shell, "Message sent\n");
40021224:	400317b7          	lui	a5,0x40031
40021228:	ad47a503          	lw	a0,-1324(a5) # 40030ad4 <udp_shell>
4002122c:	4002d637          	lui	a2,0x4002d
{
40021230:	ff010113          	addi	sp,sp,-16
	PR_SHELL(udp_shell, "Message sent\n");
40021234:	6a060613          	addi	a2,a2,1696 # 4002d6a0 <CSWTCH.14405+0xc4>
40021238:	00800593          	li	a1,8
{
4002123c:	00112623          	sw	ra,12(sp)
	PR_SHELL(udp_shell, "Message sent\n");
40021240:	a71e40ef          	jal	ra,40005cb0 <shell_fprintf>
}
40021244:	00c12083          	lw	ra,12(sp)
	z_impl_k_sem_give(sem);
40021248:	4003d537          	lui	a0,0x4003d
4002124c:	b5c50513          	addi	a0,a0,-1188 # 4003cb5c <udp_send_wait>
40021250:	01010113          	addi	sp,sp,16
40021254:	3310706f          	j	40028d84 <z_impl_k_sem_give>

40021258 <cmd_net_udp_send>:
{
40021258:	fb010113          	addi	sp,sp,-80
4002125c:	04112623          	sw	ra,76(sp)
40021260:	04812423          	sw	s0,72(sp)
40021264:	04912223          	sw	s1,68(sp)
40021268:	05212023          	sw	s2,64(sp)
4002126c:	03312e23          	sw	s3,60(sp)
40021270:	03412c23          	sw	s4,56(sp)
40021274:	03512a23          	sw	s5,52(sp)
	char *endptr = NULL;
40021278:	00012a23          	sw	zero,20(sp)
	if (argc < 4) {
4002127c:	00300793          	li	a5,3
40021280:	04b7e063          	bltu	a5,a1,400212c0 <cmd_net_udp_send+0x68>
		PR_WARNING("Not enough arguments given for udp send command\n");
40021284:	4002e637          	lui	a2,0x4002e
40021288:	51860613          	addi	a2,a2,1304 # 4002e518 <CSWTCH.14405+0xf3c>
4002128c:	00300593          	li	a1,3
		PR_WARNING("Invalid port number\n");
40021290:	a21e40ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
40021294:	fea00913          	li	s2,-22
}
40021298:	04c12083          	lw	ra,76(sp)
4002129c:	04812403          	lw	s0,72(sp)
400212a0:	04412483          	lw	s1,68(sp)
400212a4:	03c12983          	lw	s3,60(sp)
400212a8:	03812a03          	lw	s4,56(sp)
400212ac:	03412a83          	lw	s5,52(sp)
400212b0:	00090513          	mv	a0,s2
400212b4:	04012903          	lw	s2,64(sp)
400212b8:	05010113          	addi	sp,sp,80
400212bc:	00008067          	ret
400212c0:	00060913          	mv	s2,a2
	host = argv[1];
400212c4:	00050413          	mv	s0,a0
	port = strtol(argv[2], &endptr, 0);
400212c8:	00892503          	lw	a0,8(s2)
	host = argv[1];
400212cc:	00462a83          	lw	s5,4(a2)
	port = strtol(argv[2], &endptr, 0);
400212d0:	01410593          	addi	a1,sp,20
400212d4:	00000613          	li	a2,0
400212d8:	801e70ef          	jal	ra,40008ad8 <strtol>
	if (endptr == argv[2]) {
400212dc:	00892703          	lw	a4,8(s2)
400212e0:	01412783          	lw	a5,20(sp)
	port = strtol(argv[2], &endptr, 0);
400212e4:	01051493          	slli	s1,a0,0x10
	payload = argv[3];
400212e8:	00c92a03          	lw	s4,12(s2)
	port = strtol(argv[2], &endptr, 0);
400212ec:	0104d493          	srli	s1,s1,0x10
	if (endptr == argv[2]) {
400212f0:	00f71c63          	bne	a4,a5,40021308 <cmd_net_udp_send+0xb0>
		PR_WARNING("Invalid port number\n");
400212f4:	4002e637          	lui	a2,0x4002e
400212f8:	54c60613          	addi	a2,a2,1356 # 4002e54c <CSWTCH.14405+0xf70>
400212fc:	00300593          	li	a1,3
40021300:	00040513          	mv	a0,s0
40021304:	f8dff06f          	j	40021290 <cmd_net_udp_send+0x38>
	if (udp_ctx && net_context_is_used(udp_ctx)) {
40021308:	400319b7          	lui	s3,0x40031
4002130c:	ad89a783          	lw	a5,-1320(s3) # 40030ad8 <udp_ctx>
40021310:	02078663          	beqz	a5,4002133c <cmd_net_udp_send+0xe4>
40021314:	0747d783          	lhu	a5,116(a5)
40021318:	0017f793          	andi	a5,a5,1
4002131c:	02078063          	beqz	a5,4002133c <cmd_net_udp_send+0xe4>
		PR_WARNING("Network context already in use\n");
40021320:	4002e637          	lui	a2,0x4002e
40021324:	56460613          	addi	a2,a2,1380 # 4002e564 <CSWTCH.14405+0xf88>
40021328:	00300593          	li	a1,3
4002132c:	00040513          	mv	a0,s0
40021330:	981e40ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EALREADY;
40021334:	f8800913          	li	s2,-120
40021338:	f61ff06f          	j	40021298 <cmd_net_udp_send+0x40>
	memset(&addr, 0, sizeof(addr));
4002133c:	01800613          	li	a2,24
40021340:	00000593          	li	a1,0
40021344:	01810513          	addi	a0,sp,24
40021348:	d29e70ef          	jal	ra,40009070 <memset>
	ret = net_ipaddr_parse(host, strlen(host), &addr);
4002134c:	000a8513          	mv	a0,s5
40021350:	bd9e70ef          	jal	ra,40008f28 <strlen>
40021354:	00050593          	mv	a1,a0
40021358:	01810613          	addi	a2,sp,24
4002135c:	000a8513          	mv	a0,s5
40021360:	e88ef0ef          	jal	ra,400109e8 <net_ipaddr_parse>
	ret = net_context_get(addr.sa_family, SOCK_DGRAM, IPPROTO_UDP,
40021364:	01815503          	lhu	a0,24(sp)
40021368:	ad898693          	addi	a3,s3,-1320
4002136c:	01100613          	li	a2,17
40021370:	00200593          	li	a1,2
40021374:	96cf00ef          	jal	ra,400114e0 <net_context_get>
40021378:	00050913          	mv	s2,a0
	if (ret < 0) {
4002137c:	02055063          	bgez	a0,4002139c <cmd_net_udp_send+0x144>
		PR_WARNING("Cannot get UDP context (%d)\n", ret);
40021380:	4002e637          	lui	a2,0x4002e
40021384:	00050693          	mv	a3,a0
40021388:	58460613          	addi	a2,a2,1412 # 4002e584 <CSWTCH.14405+0xfa8>
4002138c:	00300593          	li	a1,3
40021390:	00040513          	mv	a0,s0
40021394:	91de40ef          	jal	ra,40005cb0 <shell_fprintf>
		return ret;
40021398:	f01ff06f          	j	40021298 <cmd_net_udp_send+0x40>
	udp_shell = sh;
4002139c:	400317b7          	lui	a5,0x40031
400213a0:	ac87aa23          	sw	s0,-1324(a5) # 40030ad4 <udp_shell>
	if (IS_ENABLED(CONFIG_NET_IPV6) && addr.sa_family == AF_INET6) {
400213a4:	01815783          	lhu	a5,24(sp)
400213a8:	00200713          	li	a4,2
400213ac:	02e79e63          	bne	a5,a4,400213e8 <cmd_net_udp_send+0x190>
		net_sin6(&addr)->sin6_port = htons(port);
400213b0:	00849793          	slli	a5,s1,0x8
400213b4:	0084d493          	srli	s1,s1,0x8
400213b8:	0097e7b3          	or	a5,a5,s1
		iface = net_if_ipv6_select_src_iface(
400213bc:	01c10513          	addi	a0,sp,28
		net_sin6(&addr)->sin6_port = htons(port);
400213c0:	00f11d23          	sh	a5,26(sp)
		addrlen = sizeof(struct sockaddr_in6);
400213c4:	01800493          	li	s1,24
		iface = net_if_ipv6_select_src_iface(
400213c8:	d40ed0ef          	jal	ra,4000e908 <net_if_ipv6_select_src_iface>
	if (!iface) {
400213cc:	06051c63          	bnez	a0,40021444 <cmd_net_udp_send+0x1ec>
		PR_WARNING("No interface to send to given host\n");
400213d0:	4002e637          	lui	a2,0x4002e
400213d4:	5d460613          	addi	a2,a2,1492 # 4002e5d4 <CSWTCH.14405+0xff8>
		PR_WARNING("UDP packet sending failed\n");
400213d8:	00300593          	li	a1,3
400213dc:	00040513          	mv	a0,s0
400213e0:	8d1e40ef          	jal	ra,40005cb0 <shell_fprintf>
400213e4:	0480006f          	j	4002142c <cmd_net_udp_send+0x1d4>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && addr.sa_family == AF_INET) {
400213e8:	00100713          	li	a4,1
400213ec:	02e79263          	bne	a5,a4,40021410 <cmd_net_udp_send+0x1b8>
		net_sin(&addr)->sin_port = htons(port);
400213f0:	00849793          	slli	a5,s1,0x8
400213f4:	0084d493          	srli	s1,s1,0x8
400213f8:	0097e7b3          	or	a5,a5,s1
		iface = net_if_ipv4_select_src_iface(
400213fc:	01c10513          	addi	a0,sp,28
		net_sin(&addr)->sin_port = htons(port);
40021400:	00f11d23          	sh	a5,26(sp)
		addrlen = sizeof(struct sockaddr_in);
40021404:	00800493          	li	s1,8
		iface = net_if_ipv4_select_src_iface(
40021408:	859ed0ef          	jal	ra,4000ec60 <net_if_ipv4_select_src_iface>
4002140c:	fc1ff06f          	j	400213cc <cmd_net_udp_send+0x174>
		PR_WARNING("IPv6 and IPv4 are disabled, cannot %s.\n", "send");
40021410:	4002e6b7          	lui	a3,0x4002e
40021414:	4002e637          	lui	a2,0x4002e
40021418:	5a468693          	addi	a3,a3,1444 # 4002e5a4 <CSWTCH.14405+0xfc8>
4002141c:	5ac60613          	addi	a2,a2,1452 # 4002e5ac <CSWTCH.14405+0xfd0>
		PR_WARNING("Setting rcv callback failed (%d)\n", ret);
40021420:	00300593          	li	a1,3
40021424:	00040513          	mv	a0,s0
40021428:	889e40ef          	jal	ra,40005cb0 <shell_fprintf>
	ret = net_context_put(udp_ctx);
4002142c:	ad89a503          	lw	a0,-1320(s3)
40021430:	b8cf00ef          	jal	ra,400117bc <net_context_put>
40021434:	00050693          	mv	a3,a0
	if (ret < 0) {
40021438:	0a054e63          	bltz	a0,400214f4 <cmd_net_udp_send+0x29c>
	return 0;
4002143c:	00000913          	li	s2,0
40021440:	e59ff06f          	j	40021298 <cmd_net_udp_send+0x40>
	net_context_set_iface(udp_ctx, iface);
40021444:	ad89a903          	lw	s2,-1320(s3)
	context->iface = net_if_get_by_iface(iface);
40021448:	998ee0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
	ret = net_context_recv(udp_ctx, udp_rcvd, K_NO_WAIT, NULL);
4002144c:	400215b7          	lui	a1,0x40021
40021450:	06a90b23          	sb	a0,118(s2)
40021454:	ad89a503          	lw	a0,-1320(s3)
40021458:	00000693          	li	a3,0
4002145c:	00000713          	li	a4,0
40021460:	00000613          	li	a2,0
40021464:	66058593          	addi	a1,a1,1632 # 40021660 <udp_rcvd>
40021468:	a34f10ef          	jal	ra,4001269c <net_context_recv>
4002146c:	00050693          	mv	a3,a0
	if (ret < 0) {
40021470:	00055863          	bgez	a0,40021480 <cmd_net_udp_send+0x228>
		PR_WARNING("Setting rcv callback failed (%d)\n", ret);
40021474:	4002e637          	lui	a2,0x4002e
40021478:	5f860613          	addi	a2,a2,1528 # 4002e5f8 <CSWTCH.14405+0x101c>
4002147c:	fa5ff06f          	j	40021420 <cmd_net_udp_send+0x1c8>
	ret = net_context_sendto(udp_ctx, payload, strlen(payload), &addr,
40021480:	ad89a903          	lw	s2,-1320(s3)
40021484:	000a0513          	mv	a0,s4
40021488:	aa1e70ef          	jal	ra,40008f28 <strlen>
4002148c:	400217b7          	lui	a5,0x40021
40021490:	00050613          	mv	a2,a0
40021494:	01810693          	addi	a3,sp,24
40021498:	00012023          	sw	zero,0(sp)
4002149c:	fff00813          	li	a6,-1
400214a0:	fff00893          	li	a7,-1
400214a4:	22478793          	addi	a5,a5,548 # 40021224 <udp_sent>
400214a8:	00048713          	mv	a4,s1
400214ac:	000a0593          	mv	a1,s4
400214b0:	00090513          	mv	a0,s2
400214b4:	954f10ef          	jal	ra,40012608 <net_context_sendto>
400214b8:	00050693          	mv	a3,a0
	if (ret < 0) {
400214bc:	00055863          	bgez	a0,400214cc <cmd_net_udp_send+0x274>
		PR_WARNING("Sending packet failed (%d)\n", ret);
400214c0:	4002e637          	lui	a2,0x4002e
400214c4:	61c60613          	addi	a2,a2,1564 # 4002e61c <CSWTCH.14405+0x1040>
400214c8:	f59ff06f          	j	40021420 <cmd_net_udp_send+0x1c8>
	return z_impl_k_sem_take(sem, timeout);
400214cc:	4003d537          	lui	a0,0x4003d
400214d0:	0c800593          	li	a1,200
400214d4:	00000613          	li	a2,0
400214d8:	b5c50513          	addi	a0,a0,-1188 # 4003cb5c <udp_send_wait>
400214dc:	119070ef          	jal	ra,40028df4 <z_impl_k_sem_take>
	if (ret == -EAGAIN) {
400214e0:	ff500793          	li	a5,-11
400214e4:	f4f514e3          	bne	a0,a5,4002142c <cmd_net_udp_send+0x1d4>
		PR_WARNING("UDP packet sending failed\n");
400214e8:	4002e637          	lui	a2,0x4002e
400214ec:	63860613          	addi	a2,a2,1592 # 4002e638 <CSWTCH.14405+0x105c>
400214f0:	ee9ff06f          	j	400213d8 <cmd_net_udp_send+0x180>
		PR_WARNING("Cannot put UDP context (%d)\n", ret);
400214f4:	4002e637          	lui	a2,0x4002e
400214f8:	65460613          	addi	a2,a2,1620 # 4002e654 <CSWTCH.14405+0x1078>
400214fc:	00300593          	li	a1,3
40021500:	00040513          	mv	a0,s0
40021504:	face40ef          	jal	ra,40005cb0 <shell_fprintf>
40021508:	f35ff06f          	j	4002143c <cmd_net_udp_send+0x1e4>

4002150c <net_if_flag_is_set>:
	if (iface == NULL) {
4002150c:	02050c63          	beqz	a0,40021544 <net_if_flag_is_set+0x38>
{
40021510:	ff010113          	addi	sp,sp,-16
40021514:	00812423          	sw	s0,8(sp)
40021518:	00112623          	sw	ra,12(sp)
	return atomic_test_bit(iface->if_dev->flags, value);
4002151c:	00052503          	lw	a0,0(a0)
40021520:	00058413          	mv	s0,a1
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
40021524:	00c50513          	addi	a0,a0,12
40021528:	2c1090ef          	jal	ra,4002afe8 <atomic_get>
}
4002152c:	00c12083          	lw	ra,12(sp)
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
40021530:	40855533          	sra	a0,a0,s0
40021534:	00812403          	lw	s0,8(sp)
40021538:	00157513          	andi	a0,a0,1
4002153c:	01010113          	addi	sp,sp,16
40021540:	00008067          	ret
		return false;
40021544:	00000513          	li	a0,0
}
40021548:	00008067          	ret

4002154c <net_if_is_up>:
{
4002154c:	ff010113          	addi	sp,sp,-16
	return net_if_flag_is_set(iface, NET_IF_UP) &&
40021550:	00000593          	li	a1,0
{
40021554:	00812423          	sw	s0,8(sp)
40021558:	00112623          	sw	ra,12(sp)
4002155c:	00050413          	mv	s0,a0
	return net_if_flag_is_set(iface, NET_IF_UP) &&
40021560:	fadff0ef          	jal	ra,4002150c <net_if_flag_is_set>
40021564:	02050263          	beqz	a0,40021588 <net_if_is_up+0x3c>
	       net_if_flag_is_set(iface, NET_IF_RUNNING);
40021568:	00800593          	li	a1,8
4002156c:	00040513          	mv	a0,s0
40021570:	f9dff0ef          	jal	ra,4002150c <net_if_flag_is_set>
}
40021574:	00c12083          	lw	ra,12(sp)
40021578:	00812403          	lw	s0,8(sp)
4002157c:	00157513          	andi	a0,a0,1
40021580:	01010113          	addi	sp,sp,16
40021584:	00008067          	ret
	return net_if_flag_is_set(iface, NET_IF_UP) &&
40021588:	00000513          	li	a0,0
4002158c:	fe9ff06f          	j	40021574 <net_if_is_up+0x28>

40021590 <cmd_net_iface_up>:
{
40021590:	fe010113          	addi	sp,sp,-32
40021594:	00812c23          	sw	s0,24(sp)
40021598:	00112e23          	sw	ra,28(sp)
4002159c:	00912a23          	sw	s1,20(sp)
	idx = get_iface_idx(sh, argv[1]);
400215a0:	00462583          	lw	a1,4(a2)
{
400215a4:	00050413          	mv	s0,a0
	idx = get_iface_idx(sh, argv[1]);
400215a8:	888fe0ef          	jal	ra,4001f630 <get_iface_idx>
	if (idx < 0) {
400215ac:	00a12623          	sw	a0,12(sp)
400215b0:	02054463          	bltz	a0,400215d8 <cmd_net_iface_up+0x48>
	iface = net_if_get_by_index(idx);
400215b4:	c91fd0ef          	jal	ra,4001f244 <net_if_get_by_index>
	if (!iface) {
400215b8:	00c12683          	lw	a3,12(sp)
	iface = net_if_get_by_index(idx);
400215bc:	00050493          	mv	s1,a0
	if (!iface) {
400215c0:	02051a63          	bnez	a0,400215f4 <cmd_net_iface_up+0x64>
		PR_WARNING("No such interface in index %d\n", idx);
400215c4:	4002e637          	lui	a2,0x4002e
400215c8:	d5460613          	addi	a2,a2,-684 # 4002dd54 <CSWTCH.14405+0x778>
400215cc:	00300593          	li	a1,3
400215d0:	00040513          	mv	a0,s0
400215d4:	edce40ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
400215d8:	ff800713          	li	a4,-8
}
400215dc:	01c12083          	lw	ra,28(sp)
400215e0:	01812403          	lw	s0,24(sp)
400215e4:	01412483          	lw	s1,20(sp)
400215e8:	00070513          	mv	a0,a4
400215ec:	02010113          	addi	sp,sp,32
400215f0:	00008067          	ret
400215f4:	00d12623          	sw	a3,12(sp)
	if (net_if_is_up(iface)) {
400215f8:	f55ff0ef          	jal	ra,4002154c <net_if_is_up>
400215fc:	00c12683          	lw	a3,12(sp)
40021600:	00050863          	beqz	a0,40021610 <cmd_net_iface_up+0x80>
		PR_WARNING("Interface %d is already up.\n", idx);
40021604:	4002e637          	lui	a2,0x4002e
40021608:	67460613          	addi	a2,a2,1652 # 4002e674 <CSWTCH.14405+0x1098>
4002160c:	fc1ff06f          	j	400215cc <cmd_net_iface_up+0x3c>
	ret = net_if_up(iface);
40021610:	00048513          	mv	a0,s1
40021614:	00d12623          	sw	a3,12(sp)
40021618:	870ee0ef          	jal	ra,4000f688 <net_if_up>
	if (ret) {
4002161c:	00c12683          	lw	a3,12(sp)
	ret = net_if_up(iface);
40021620:	00050713          	mv	a4,a0
	if (ret) {
40021624:	00050e63          	beqz	a0,40021640 <cmd_net_iface_up+0xb0>
		PR_WARNING("Cannot take interface %d up (%d)\n", idx, ret);
40021628:	4002e637          	lui	a2,0x4002e
4002162c:	69460613          	addi	a2,a2,1684 # 4002e694 <CSWTCH.14405+0x10b8>
40021630:	00300593          	li	a1,3
40021634:	00040513          	mv	a0,s0
40021638:	e78e40ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
4002163c:	f9dff06f          	j	400215d8 <cmd_net_iface_up+0x48>
		PR("Interface %d is up\n", idx);
40021640:	4002e637          	lui	a2,0x4002e
40021644:	00a12623          	sw	a0,12(sp)
40021648:	6b860613          	addi	a2,a2,1720 # 4002e6b8 <CSWTCH.14405+0x10dc>
4002164c:	00800593          	li	a1,8
40021650:	00040513          	mv	a0,s0
40021654:	e5ce40ef          	jal	ra,40005cb0 <shell_fprintf>
40021658:	00c12703          	lw	a4,12(sp)
	return 0;
4002165c:	f81ff06f          	j	400215dc <cmd_net_iface_up+0x4c>

40021660 <udp_rcvd>:
	if (pkt) {
40021660:	0a058e63          	beqz	a1,4002171c <udp_rcvd+0xbc>
{
40021664:	fd010113          	addi	sp,sp,-48
		size_t len = net_pkt_remaining_data(pkt);
40021668:	00058513          	mv	a0,a1
{
4002166c:	02112623          	sw	ra,44(sp)
40021670:	02812423          	sw	s0,40(sp)
40021674:	02912223          	sw	s1,36(sp)
40021678:	03212023          	sw	s2,32(sp)
4002167c:	01312e23          	sw	s3,28(sp)
40021680:	01412c23          	sw	s4,24(sp)
40021684:	00058413          	mv	s0,a1
		PR_SHELL(udp_shell, "Received UDP packet: ");
40021688:	400314b7          	lui	s1,0x40031
		size_t len = net_pkt_remaining_data(pkt);
4002168c:	cdcf20ef          	jal	ra,40013b68 <net_pkt_remaining_data>
40021690:	00050993          	mv	s3,a0
		PR_SHELL(udp_shell, "Received UDP packet: ");
40021694:	ad44a503          	lw	a0,-1324(s1) # 40030ad4 <udp_shell>
40021698:	4002e637          	lui	a2,0x4002e
4002169c:	6cc60613          	addi	a2,a2,1740 # 4002e6cc <CSWTCH.14405+0x10f0>
400216a0:	00800593          	li	a1,8
400216a4:	e0ce40ef          	jal	ra,40005cb0 <shell_fprintf>
		for (size_t i = 0; i < len; ++i) {
400216a8:	00000913          	li	s2,0
			PR_SHELL(udp_shell, "%02x ", byte);
400216ac:	4002da37          	lui	s4,0x4002d
		for (size_t i = 0; i < len; ++i) {
400216b0:	05299063          	bne	s3,s2,400216f0 <udp_rcvd+0x90>
		PR_SHELL(udp_shell, "\n");
400216b4:	ad44a503          	lw	a0,-1324(s1)
400216b8:	4002e637          	lui	a2,0x4002e
400216bc:	48c60613          	addi	a2,a2,1164 # 4002e48c <CSWTCH.14405+0xeb0>
400216c0:	00800593          	li	a1,8
400216c4:	dece40ef          	jal	ra,40005cb0 <shell_fprintf>
		net_pkt_unref(pkt);
400216c8:	00040513          	mv	a0,s0
400216cc:	851f10ef          	jal	ra,40012f1c <net_pkt_unref>
}
400216d0:	02c12083          	lw	ra,44(sp)
400216d4:	02812403          	lw	s0,40(sp)
400216d8:	02412483          	lw	s1,36(sp)
400216dc:	02012903          	lw	s2,32(sp)
400216e0:	01c12983          	lw	s3,28(sp)
400216e4:	01812a03          	lw	s4,24(sp)
400216e8:	03010113          	addi	sp,sp,48
400216ec:	00008067          	ret
	return net_pkt_read(pkt, data, 1);
400216f0:	00100613          	li	a2,1
400216f4:	00f10593          	addi	a1,sp,15
400216f8:	00040513          	mv	a0,s0
400216fc:	ad0f20ef          	jal	ra,400139cc <net_pkt_read>
			PR_SHELL(udp_shell, "%02x ", byte);
40021700:	00f14683          	lbu	a3,15(sp)
40021704:	ad44a503          	lw	a0,-1324(s1)
40021708:	a2ca0613          	addi	a2,s4,-1492 # 4002ca2c <shell_telnet_fprintf+0x3d0>
4002170c:	00800593          	li	a1,8
40021710:	da0e40ef          	jal	ra,40005cb0 <shell_fprintf>
		for (size_t i = 0; i < len; ++i) {
40021714:	00190913          	addi	s2,s2,1
40021718:	f99ff06f          	j	400216b0 <udp_rcvd+0x50>
4002171c:	00008067          	ret

40021720 <tcp_recv_cb>:
{
40021720:	ff010113          	addi	sp,sp,-16
40021724:	00112623          	sw	ra,12(sp)
40021728:	00812423          	sw	s0,8(sp)
4002172c:	00912223          	sw	s1,4(sp)
	if (pkt == NULL) {
40021730:	06059e63          	bnez	a1,400217ac <tcp_recv_cb+0x8c>
		if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
40021734:	40031437          	lui	s0,0x40031
40021738:	ae042503          	lw	a0,-1312(s0) # 40030ae0 <tcp_ctx>
4002173c:	04050e63          	beqz	a0,40021798 <tcp_recv_cb+0x78>
	return context->flags & NET_CONTEXT_IN_USE;
40021740:	07455783          	lhu	a5,116(a0)
40021744:	0017f793          	andi	a5,a5,1
40021748:	04078863          	beqz	a5,40021798 <tcp_recv_cb+0x78>
		ret = net_context_put(tcp_ctx);
4002174c:	870f00ef          	jal	ra,400117bc <net_context_put>
40021750:	00050693          	mv	a3,a0
		if (ret < 0) {
40021754:	400317b7          	lui	a5,0x40031
40021758:	02055463          	bgez	a0,40021780 <tcp_recv_cb+0x60>
}
4002175c:	00812403          	lw	s0,8(sp)
40021760:	00c12083          	lw	ra,12(sp)
40021764:	00412483          	lw	s1,4(sp)
			PR_SHELL(tcp_shell,
40021768:	adc7a503          	lw	a0,-1316(a5) # 40030adc <tcp_shell>
4002176c:	4002e637          	lui	a2,0x4002e
40021770:	92060613          	addi	a2,a2,-1760 # 4002d920 <CSWTCH.14405+0x344>
40021774:	00800593          	li	a1,8
}
40021778:	01010113          	addi	sp,sp,16
			PR_SHELL(tcp_shell,
4002177c:	d34e406f          	j	40005cb0 <shell_fprintf>
		PR_SHELL(tcp_shell, "Connection closed by remote peer.\n");
40021780:	adc7a503          	lw	a0,-1316(a5)
40021784:	4002e637          	lui	a2,0x4002e
40021788:	6e460613          	addi	a2,a2,1764 # 4002e6e4 <CSWTCH.14405+0x1108>
4002178c:	00800593          	li	a1,8
40021790:	d20e40ef          	jal	ra,40005cb0 <shell_fprintf>
		tcp_ctx = NULL;
40021794:	ae042023          	sw	zero,-1312(s0)
}
40021798:	00c12083          	lw	ra,12(sp)
4002179c:	00812403          	lw	s0,8(sp)
400217a0:	00412483          	lw	s1,4(sp)
400217a4:	01010113          	addi	sp,sp,16
400217a8:	00008067          	ret
400217ac:	00050493          	mv	s1,a0
	len = net_pkt_remaining_data(pkt);
400217b0:	00058513          	mv	a0,a1
400217b4:	00058413          	mv	s0,a1
400217b8:	bb0f20ef          	jal	ra,40013b68 <net_pkt_remaining_data>
400217bc:	00050593          	mv	a1,a0
	(void)net_context_update_recv_wnd(context, len);
400217c0:	00048513          	mv	a0,s1
400217c4:	920f10ef          	jal	ra,400128e4 <net_context_update_recv_wnd>
	PR_SHELL(tcp_shell, "%zu bytes received\n", net_pkt_get_len(pkt));
400217c8:	400317b7          	lui	a5,0x40031
400217cc:	adc7a503          	lw	a0,-1316(a5) # 40030adc <tcp_shell>
400217d0:	00842783          	lw	a5,8(s0)
	size_t bytes = 0;
400217d4:	00000693          	li	a3,0
	while (buf) {
400217d8:	02079663          	bnez	a5,40021804 <tcp_recv_cb+0xe4>
400217dc:	4002e637          	lui	a2,0x4002e
400217e0:	70860613          	addi	a2,a2,1800 # 4002e708 <CSWTCH.14405+0x112c>
400217e4:	00800593          	li	a1,8
400217e8:	cc8e40ef          	jal	ra,40005cb0 <shell_fprintf>
	net_pkt_unref(pkt);
400217ec:	00040513          	mv	a0,s0
}
400217f0:	00812403          	lw	s0,8(sp)
400217f4:	00c12083          	lw	ra,12(sp)
400217f8:	00412483          	lw	s1,4(sp)
400217fc:	01010113          	addi	sp,sp,16
	net_pkt_unref(pkt);
40021800:	f1cf106f          	j	40012f1c <net_pkt_unref>
		bytes += buf->len;
40021804:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
40021808:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
4002180c:	00e686b3          	add	a3,a3,a4
		buf = buf->frags;
40021810:	fc9ff06f          	j	400217d8 <tcp_recv_cb+0xb8>

40021814 <context_cb>:
{
40021814:	f6010113          	addi	sp,sp,-160
40021818:	08812c23          	sw	s0,152(sp)
4002181c:	08912a23          	sw	s1,148(sp)
40021820:	09312623          	sw	s3,140(sp)
40021824:	08112e23          	sw	ra,156(sp)
40021828:	09212823          	sw	s2,144(sp)
4002182c:	09412423          	sw	s4,136(sp)
40021830:	09512223          	sw	s5,132(sp)
	const struct shell *sh = data->sh;
40021834:	0005aa03          	lw	s4,0(a1)
	int *count = data->user_data;
40021838:	0045a903          	lw	s2,4(a1)
{
4002183c:	00050413          	mv	s0,a0
	char addr_remote[ADDR_LEN + 7] = "";
40021840:	02b00613          	li	a2,43
40021844:	00000593          	li	a1,0
40021848:	05410513          	addi	a0,sp,84
4002184c:	04012823          	sw	zero,80(sp)
40021850:	821e70ef          	jal	ra,40009070 <memset>
	if (context->local.family == AF_INET6) {
40021854:	02045683          	lhu	a3,32(s0)
40021858:	00200793          	li	a5,2
4002185c:	02010493          	addi	s1,sp,32
40021860:	05010993          	addi	s3,sp,80
40021864:	16f69263          	bne	a3,a5,400219c8 <context_cb+0x1b4>
		snprintk(addr_local, local_len, "[%s]:%u",
40021868:	02442583          	lw	a1,36(s0)
4002186c:	00200513          	li	a0,2
40021870:	4002eab7          	lui	s5,0x4002e
40021874:	8a5ee0ef          	jal	ra,40010118 <net_sprint_addr>
40021878:	02245783          	lhu	a5,34(s0)
4002187c:	00050693          	mv	a3,a0
40021880:	71ca8613          	addi	a2,s5,1820 # 4002e71c <CSWTCH.14405+0x1140>
40021884:	00879713          	slli	a4,a5,0x8
40021888:	0087d793          	srli	a5,a5,0x8
4002188c:	00f76733          	or	a4,a4,a5
40021890:	01071713          	slli	a4,a4,0x10
40021894:	01075713          	srli	a4,a4,0x10
40021898:	02f00593          	li	a1,47
4002189c:	00048513          	mv	a0,s1
400218a0:	f28df0ef          	jal	ra,40000fc8 <snprintk>
		snprintk(addr_remote, remote_len, "[%s]:%u",
400218a4:	03040593          	addi	a1,s0,48
400218a8:	00200513          	li	a0,2
400218ac:	86dee0ef          	jal	ra,40010118 <net_sprint_addr>
400218b0:	02e45783          	lhu	a5,46(s0)
400218b4:	00050693          	mv	a3,a0
400218b8:	71ca8613          	addi	a2,s5,1820
400218bc:	00879713          	slli	a4,a5,0x8
400218c0:	0087d793          	srli	a5,a5,0x8
400218c4:	00f76733          	or	a4,a4,a5
400218c8:	01071713          	slli	a4,a4,0x10
400218cc:	01075713          	srli	a4,a4,0x10
		snprintk(addr_remote, remote_len, "%s:%d",
400218d0:	02f00593          	li	a1,47
400218d4:	00098513          	mv	a0,s3
400218d8:	ef0df0ef          	jal	ra,40000fc8 <snprintk>
	PR("[%2d] %p\t%d      %c%c%c   %16s\t%16s\n",
400218dc:	00092683          	lw	a3,0(s2)
	return net_if_get_by_index(context->iface);
400218e0:	07640503          	lb	a0,118(s0)
400218e4:	00168693          	addi	a3,a3,1
400218e8:	00d12e23          	sw	a3,28(sp)
400218ec:	959fd0ef          	jal	ra,4001f244 <net_if_get_by_index>
400218f0:	cf1ed0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
400218f4:	07445703          	lhu	a4,116(s0)
400218f8:	00200593          	li	a1,2
400218fc:	01c12683          	lw	a3,28(sp)
40021900:	00375613          	srli	a2,a4,0x3
40021904:	00767613          	andi	a2,a2,7
40021908:	00050793          	mv	a5,a0
4002190c:	03600813          	li	a6,54
40021910:	00b60a63          	beq	a2,a1,40021924 <context_cb+0x110>
40021914:	00100593          	li	a1,1
40021918:	02000813          	li	a6,32
4002191c:	00b61463          	bne	a2,a1,40021924 <context_cb+0x110>
40021920:	03400813          	li	a6,52
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
40021924:	00675713          	srli	a4,a4,0x6
40021928:	00377713          	andi	a4,a4,3
4002192c:	00200613          	li	a2,2
40021930:	04400893          	li	a7,68
40021934:	02c70063          	beq	a4,a2,40021954 <context_cb+0x140>
40021938:	00100613          	li	a2,1
4002193c:	05300893          	li	a7,83
40021940:	00c70a63          	beq	a4,a2,40021954 <context_cb+0x140>
40021944:	00300613          	li	a2,3
40021948:	02000893          	li	a7,32
4002194c:	00c71463          	bne	a4,a2,40021954 <context_cb+0x140>
40021950:	05200893          	li	a7,82
	return context->proto;
40021954:	07245603          	lhu	a2,114(s0)
40021958:	01100593          	li	a1,17
4002195c:	05500713          	li	a4,85
40021960:	00b60a63          	beq	a2,a1,40021974 <context_cb+0x160>
40021964:	00600593          	li	a1,6
40021968:	02000713          	li	a4,32
4002196c:	00b61463          	bne	a2,a1,40021974 <context_cb+0x160>
40021970:	05400713          	li	a4,84
40021974:	4002e637          	lui	a2,0x4002e
40021978:	01312423          	sw	s3,8(sp)
4002197c:	00912223          	sw	s1,4(sp)
40021980:	00e12023          	sw	a4,0(sp)
40021984:	000a0513          	mv	a0,s4
40021988:	00040713          	mv	a4,s0
4002198c:	73860613          	addi	a2,a2,1848 # 4002e738 <CSWTCH.14405+0x115c>
40021990:	00800593          	li	a1,8
40021994:	b1ce40ef          	jal	ra,40005cb0 <shell_fprintf>
	(*count)++;
40021998:	00092783          	lw	a5,0(s2)
4002199c:	00178793          	addi	a5,a5,1
400219a0:	00f92023          	sw	a5,0(s2)
}
400219a4:	09c12083          	lw	ra,156(sp)
400219a8:	09812403          	lw	s0,152(sp)
400219ac:	09412483          	lw	s1,148(sp)
400219b0:	09012903          	lw	s2,144(sp)
400219b4:	08c12983          	lw	s3,140(sp)
400219b8:	08812a03          	lw	s4,136(sp)
400219bc:	08412a83          	lw	s5,132(sp)
400219c0:	0a010113          	addi	sp,sp,160
400219c4:	00008067          	ret
	if (context->local.family == AF_INET) {
400219c8:	00100793          	li	a5,1
400219cc:	06f69863          	bne	a3,a5,40021a3c <context_cb+0x228>
		snprintk(addr_local, local_len, "%s:%d",
400219d0:	02442583          	lw	a1,36(s0)
400219d4:	00100513          	li	a0,1
400219d8:	4002eab7          	lui	s5,0x4002e
400219dc:	f3cee0ef          	jal	ra,40010118 <net_sprint_addr>
400219e0:	02245783          	lhu	a5,34(s0)
400219e4:	00050693          	mv	a3,a0
400219e8:	724a8613          	addi	a2,s5,1828 # 4002e724 <CSWTCH.14405+0x1148>
400219ec:	00879713          	slli	a4,a5,0x8
400219f0:	0087d793          	srli	a5,a5,0x8
400219f4:	00f76733          	or	a4,a4,a5
400219f8:	01071713          	slli	a4,a4,0x10
400219fc:	01075713          	srli	a4,a4,0x10
40021a00:	02f00593          	li	a1,47
40021a04:	00048513          	mv	a0,s1
40021a08:	dc0df0ef          	jal	ra,40000fc8 <snprintk>
		snprintk(addr_remote, remote_len, "%s:%d",
40021a0c:	03040593          	addi	a1,s0,48
40021a10:	00100513          	li	a0,1
40021a14:	f04ee0ef          	jal	ra,40010118 <net_sprint_addr>
40021a18:	02e45783          	lhu	a5,46(s0)
40021a1c:	00050693          	mv	a3,a0
40021a20:	724a8613          	addi	a2,s5,1828
40021a24:	00879713          	slli	a4,a5,0x8
40021a28:	0087d793          	srli	a5,a5,0x8
40021a2c:	00f76733          	or	a4,a4,a5
40021a30:	01071713          	slli	a4,a4,0x10
40021a34:	01075713          	srli	a4,a4,0x10
40021a38:	e99ff06f          	j	400218d0 <context_cb+0xbc>
	if (context->local.family == AF_UNSPEC) {
40021a3c:	00069e63          	bnez	a3,40021a58 <context_cb+0x244>
		snprintk(addr_local, local_len, "AF_UNSPEC");
40021a40:	4002d637          	lui	a2,0x4002d
40021a44:	2f460613          	addi	a2,a2,756 # 4002d2f4 <net_buf_fixed_cb+0x5c>
		snprintk(addr_local, local_len, "AF_CAN");
40021a48:	02f00593          	li	a1,47
40021a4c:	00048513          	mv	a0,s1
40021a50:	d78df0ef          	jal	ra,40000fc8 <snprintk>
40021a54:	e89ff06f          	j	400218dc <context_cb+0xc8>
	} else if (context->local.family == AF_PACKET) {
40021a58:	00300793          	li	a5,3
40021a5c:	00f69863          	bne	a3,a5,40021a6c <context_cb+0x258>
		snprintk(addr_local, local_len, "AF_PACKET");
40021a60:	4002d637          	lui	a2,0x4002d
40021a64:	31460613          	addi	a2,a2,788 # 4002d314 <net_buf_fixed_cb+0x7c>
40021a68:	fe1ff06f          	j	40021a48 <context_cb+0x234>
	} else if (context->local.family == AF_CAN) {
40021a6c:	00400793          	li	a5,4
40021a70:	00f69863          	bne	a3,a5,40021a80 <context_cb+0x26c>
		snprintk(addr_local, local_len, "AF_CAN");
40021a74:	4002d637          	lui	a2,0x4002d
40021a78:	32060613          	addi	a2,a2,800 # 4002d320 <net_buf_fixed_cb+0x88>
40021a7c:	fcdff06f          	j	40021a48 <context_cb+0x234>
		snprintk(addr_local, local_len, "AF_UNK(%d)",
40021a80:	4002e637          	lui	a2,0x4002e
40021a84:	72c60613          	addi	a2,a2,1836 # 4002e72c <CSWTCH.14405+0x1150>
40021a88:	02f00593          	li	a1,47
40021a8c:	00048513          	mv	a0,s1
40021a90:	d38df0ef          	jal	ra,40000fc8 <snprintk>
40021a94:	e49ff06f          	j	400218dc <context_cb+0xc8>

40021a98 <cmd_net_resume>:
static int cmd_net_resume(const struct shell *sh, size_t argc,
40021a98:	4002d637          	lui	a2,0x4002d
40021a9c:	ff010113          	addi	sp,sp,-16
40021aa0:	6b060613          	addi	a2,a2,1712 # 4002d6b0 <CSWTCH.14405+0xd4>
40021aa4:	00200593          	li	a1,2
40021aa8:	00112623          	sw	ra,12(sp)
40021aac:	a04e40ef          	jal	ra,40005cb0 <shell_fprintf>
40021ab0:	00c12083          	lw	ra,12(sp)
40021ab4:	00000513          	li	a0,0
40021ab8:	01010113          	addi	sp,sp,16
40021abc:	00008067          	ret

40021ac0 <cmd_net_events_off>:
static int cmd_net_events_off(const struct shell *sh, size_t argc,
40021ac0:	4002d637          	lui	a2,0x4002d
40021ac4:	ff010113          	addi	sp,sp,-16
40021ac8:	7f060613          	addi	a2,a2,2032 # 4002d7f0 <CSWTCH.14405+0x214>
40021acc:	00200593          	li	a1,2
40021ad0:	00112623          	sw	ra,12(sp)
40021ad4:	9dce40ef          	jal	ra,40005cb0 <shell_fprintf>
40021ad8:	00c12083          	lw	ra,12(sp)
40021adc:	00000513          	li	a0,0
40021ae0:	01010113          	addi	sp,sp,16
40021ae4:	00008067          	ret

40021ae8 <cmd_net_events>:
static int cmd_net_events(const struct shell *sh, size_t argc, char *argv[])
40021ae8:	4002d637          	lui	a2,0x4002d
40021aec:	ff010113          	addi	sp,sp,-16
40021af0:	7f060613          	addi	a2,a2,2032 # 4002d7f0 <CSWTCH.14405+0x214>
40021af4:	00200593          	li	a1,2
40021af8:	00112623          	sw	ra,12(sp)
40021afc:	9b4e40ef          	jal	ra,40005cb0 <shell_fprintf>
40021b00:	00c12083          	lw	ra,12(sp)
40021b04:	00000513          	li	a0,0
40021b08:	01010113          	addi	sp,sp,16
40021b0c:	00008067          	ret

40021b10 <iface2str>:
	if (!iface || !iface->if_dev) {
40021b10:	02050c63          	beqz	a0,40021b48 <iface2str+0x38>
40021b14:	00052783          	lw	a5,0(a0)
40021b18:	02078863          	beqz	a5,40021b48 <iface2str+0x38>
	if (net_if_l2(iface) == &NET_L2_GET_NAME(ETHERNET)) {
40021b1c:	0047a703          	lw	a4,4(a5)
40021b20:	4003d7b7          	lui	a5,0x4003d
40021b24:	c6478793          	addi	a5,a5,-924 # 4003cc64 <_net_l2_ETHERNET>
40021b28:	02f71063          	bne	a4,a5,40021b48 <iface2str+0x38>
		if (extra) {
40021b2c:	00058863          	beqz	a1,40021b3c <iface2str+0x2c>
			*extra = "========";
40021b30:	4002e7b7          	lui	a5,0x4002e
40021b34:	77c78793          	addi	a5,a5,1916 # 4002e77c <CSWTCH.14405+0x11a0>
40021b38:	00f5a023          	sw	a5,0(a1)
		return "Ethernet";
40021b3c:	4002e537          	lui	a0,0x4002e
40021b40:	76050513          	addi	a0,a0,1888 # 4002e760 <CSWTCH.14405+0x1184>
40021b44:	00008067          	ret
	if (extra) {
40021b48:	00059863          	bnez	a1,40021b58 <iface2str+0x48>
	return "<unknown type>";
40021b4c:	4002e537          	lui	a0,0x4002e
40021b50:	76c50513          	addi	a0,a0,1900 # 4002e76c <CSWTCH.14405+0x1190>
}
40021b54:	00008067          	ret
		*extra = "==============";
40021b58:	4002e7b7          	lui	a5,0x4002e
40021b5c:	78878793          	addi	a5,a5,1928 # 4002e788 <CSWTCH.14405+0x11ac>
40021b60:	00f5a023          	sw	a5,0(a1)
40021b64:	fe9ff06f          	j	40021b4c <iface2str+0x3c>

40021b68 <iface_index_get>:
{
40021b68:	fe010113          	addi	sp,sp,-32
40021b6c:	00912a23          	sw	s1,20(sp)
40021b70:	01212823          	sw	s2,16(sp)
40021b74:	00112e23          	sw	ra,28(sp)
40021b78:	00812c23          	sw	s0,24(sp)
	entry->handler = NULL;
40021b7c:	0005a623          	sw	zero,12(a1)
{
40021b80:	00050913          	mv	s2,a0
40021b84:	00058493          	mv	s1,a1
	struct net_if *iface = net_if_get_by_index(idx);
40021b88:	ebcfd0ef          	jal	ra,4001f244 <net_if_get_by_index>
40021b8c:	00050713          	mv	a4,a0
	if (!iface) {
40021b90:	04050263          	beqz	a0,40021bd4 <iface_index_get+0x6c>
	snprintk(iface_help_buffer[idx], MAX_IFACE_HELP_STR_LEN,
40021b94:	01c00413          	li	s0,28
40021b98:	02890433          	mul	s0,s2,s0
40021b9c:	400327b7          	lui	a5,0x40032
40021ba0:	7e878793          	addi	a5,a5,2024 # 400327e8 <iface_help_buffer>
40021ba4:	00000593          	li	a1,0
40021ba8:	00a12623          	sw	a0,12(sp)
40021bac:	00f40433          	add	s0,s0,a5
40021bb0:	f61ff0ef          	jal	ra,40021b10 <iface2str>
40021bb4:	00c12703          	lw	a4,12(sp)
40021bb8:	4002e637          	lui	a2,0x4002e
40021bbc:	00050693          	mv	a3,a0
40021bc0:	79860613          	addi	a2,a2,1944 # 4002e798 <CSWTCH.14405+0x11bc>
40021bc4:	01c00593          	li	a1,28
40021bc8:	00040513          	mv	a0,s0
40021bcc:	bfcdf0ef          	jal	ra,40000fc8 <snprintk>
	return iface_help_buffer[idx];
40021bd0:	00040713          	mv	a4,s0
	entry->subcmd = &iface_index;
40021bd4:	4002c7b7          	lui	a5,0x4002c
40021bd8:	ae078793          	addi	a5,a5,-1312 # 4002bae0 <iface_index>
	entry->help  = set_iface_index_help(idx);
40021bdc:	00e4a223          	sw	a4,4(s1)
	entry->subcmd = &iface_index;
40021be0:	00f4a423          	sw	a5,8(s1)
	struct net_if *iface = net_if_get_by_index(idx);
40021be4:	00090513          	mv	a0,s2
40021be8:	e5cfd0ef          	jal	ra,4001f244 <net_if_get_by_index>
40021bec:	00050413          	mv	s0,a0
	if (!iface) {
40021bf0:	02050663          	beqz	a0,40021c1c <iface_index_get+0xb4>
	snprintk(iface_index_buffer[idx], MAX_IFACE_STR_LEN, "%zu", idx);
40021bf4:	400317b7          	lui	a5,0x40031
40021bf8:	00291413          	slli	s0,s2,0x2
40021bfc:	ad078793          	addi	a5,a5,-1328 # 40030ad0 <iface_index_buffer>
40021c00:	00f40433          	add	s0,s0,a5
40021c04:	4002e637          	lui	a2,0x4002e
40021c08:	00090693          	mv	a3,s2
40021c0c:	7a060613          	addi	a2,a2,1952 # 4002e7a0 <CSWTCH.14405+0x11c4>
40021c10:	00400593          	li	a1,4
40021c14:	00040513          	mv	a0,s0
40021c18:	bb0df0ef          	jal	ra,40000fc8 <snprintk>
	entry->syntax = set_iface_index_buffer(idx);
40021c1c:	0084a023          	sw	s0,0(s1)
}
40021c20:	01c12083          	lw	ra,28(sp)
40021c24:	01812403          	lw	s0,24(sp)
40021c28:	01412483          	lw	s1,20(sp)
40021c2c:	01012903          	lw	s2,16(sp)
40021c30:	02010113          	addi	sp,sp,32
40021c34:	00008067          	ret

40021c38 <ip_address_lifetime_cb>:
{
40021c38:	fd010113          	addi	sp,sp,-48
40021c3c:	02112623          	sw	ra,44(sp)
40021c40:	03212023          	sw	s2,32(sp)
40021c44:	02812423          	sw	s0,40(sp)
40021c48:	02912223          	sw	s1,36(sp)
	const struct shell *sh = data->sh;
40021c4c:	0005a483          	lw	s1,0(a1)
{
40021c50:	00050913          	mv	s2,a0
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
40021c54:	00852403          	lw	s0,8(a0)
	PR("\nIPv4 addresses for interface %d (%p) (%s)\n",
40021c58:	989ed0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
40021c5c:	00a12223          	sw	a0,4(sp)
40021c60:	01c10593          	addi	a1,sp,28
40021c64:	00090513          	mv	a0,s2
40021c68:	ea9ff0ef          	jal	ra,40021b10 <iface2str>
40021c6c:	00412683          	lw	a3,4(sp)
40021c70:	4002e637          	lui	a2,0x4002e
40021c74:	00050793          	mv	a5,a0
40021c78:	7b460613          	addi	a2,a2,1972 # 4002e7b4 <CSWTCH.14405+0x11d8>
40021c7c:	00800593          	li	a1,8
40021c80:	00048513          	mv	a0,s1
40021c84:	00090713          	mv	a4,s2
40021c88:	828e40ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("============================================%s\n", extra);
40021c8c:	01c12683          	lw	a3,28(sp)
40021c90:	4002e637          	lui	a2,0x4002e
40021c94:	7e060613          	addi	a2,a2,2016 # 4002e7e0 <CSWTCH.14405+0x1204>
40021c98:	00800593          	li	a1,8
40021c9c:	00048513          	mv	a0,s1
40021ca0:	810e40ef          	jal	ra,40005cb0 <shell_fprintf>
	if (!ipv4) {
40021ca4:	02041663          	bnez	s0,40021cd0 <ip_address_lifetime_cb+0x98>
}
40021ca8:	02812403          	lw	s0,40(sp)
40021cac:	02c12083          	lw	ra,44(sp)
40021cb0:	02012903          	lw	s2,32(sp)
		PR("No IPv4 config found for this interface.\n");
40021cb4:	00048513          	mv	a0,s1
}
40021cb8:	02412483          	lw	s1,36(sp)
		PR("No IPv4 config found for this interface.\n");
40021cbc:	4002f637          	lui	a2,0x4002f
40021cc0:	81060613          	addi	a2,a2,-2032 # 4002e810 <CSWTCH.14405+0x1234>
40021cc4:	00800593          	li	a1,8
}
40021cc8:	03010113          	addi	sp,sp,48
		PR("No IPv4 config found for this interface.\n");
40021ccc:	fe5e306f          	j	40005cb0 <shell_fprintf>
	PR("Type      \tState    \tLifetime (sec)\tAddress\n");
40021cd0:	4002f637          	lui	a2,0x4002f
40021cd4:	83c60613          	addi	a2,a2,-1988 # 4002e83c <CSWTCH.14405+0x1260>
40021cd8:	00800593          	li	a1,8
40021cdc:	00048513          	mv	a0,s1
40021ce0:	fd1e30ef          	jal	ra,40005cb0 <shell_fprintf>
		if (!ipv4->unicast[i].is_used ||
40021ce4:	02c42783          	lw	a5,44(s0)
40021ce8:	0197d793          	srli	a5,a5,0x19
40021cec:	0017f793          	andi	a5,a5,1
40021cf0:	0a078063          	beqz	a5,40021d90 <ip_address_lifetime_cb+0x158>
40021cf4:	00045703          	lhu	a4,0(s0)
40021cf8:	00100793          	li	a5,1
40021cfc:	08f71a63          	bne	a4,a5,40021d90 <ip_address_lifetime_cb+0x158>
		PR("%s  \t%s    \t%12s/%12s\n",
40021d00:	02c44703          	lbu	a4,44(s0)
	switch (addr_type) {
40021d04:	00400793          	li	a5,4
40021d08:	0ae7e063          	bltu	a5,a4,40021da8 <ip_address_lifetime_cb+0x170>
40021d0c:	400307b7          	lui	a5,0x40030
40021d10:	00271713          	slli	a4,a4,0x2
40021d14:	09c78793          	addi	a5,a5,156 # 4003009c <CSWTCH.188>
40021d18:	00e787b3          	add	a5,a5,a4
40021d1c:	0007a683          	lw	a3,0(a5)
	switch (addr_state) {
40021d20:	02d44783          	lbu	a5,45(s0)
40021d24:	00300713          	li	a4,3
40021d28:	00178793          	addi	a5,a5,1
40021d2c:	0ff7f793          	zext.b	a5,a5
40021d30:	08f76263          	bltu	a4,a5,40021db4 <ip_address_lifetime_cb+0x17c>
40021d34:	40030737          	lui	a4,0x40030
40021d38:	08c70713          	addi	a4,a4,140 # 4003008c <CSWTCH.190>
40021d3c:	00279793          	slli	a5,a5,0x2
40021d40:	00f707b3          	add	a5,a4,a5
40021d44:	0007a703          	lw	a4,0(a5)
		PR("%s  \t%s    \t%12s/%12s\n",
40021d48:	00440593          	addi	a1,s0,4
40021d4c:	00100513          	li	a0,1
40021d50:	00d12623          	sw	a3,12(sp)
40021d54:	00e12423          	sw	a4,8(sp)
40021d58:	bc0ee0ef          	jal	ra,40010118 <net_sprint_addr>
40021d5c:	00a12223          	sw	a0,4(sp)
40021d60:	04c40593          	addi	a1,s0,76
40021d64:	00100513          	li	a0,1
40021d68:	bb0ee0ef          	jal	ra,40010118 <net_sprint_addr>
40021d6c:	00412783          	lw	a5,4(sp)
40021d70:	00812703          	lw	a4,8(sp)
40021d74:	00c12683          	lw	a3,12(sp)
40021d78:	4002f637          	lui	a2,0x4002f
40021d7c:	00050813          	mv	a6,a0
40021d80:	86c60613          	addi	a2,a2,-1940 # 4002e86c <CSWTCH.14405+0x1290>
40021d84:	00800593          	li	a1,8
40021d88:	00048513          	mv	a0,s1
40021d8c:	f25e30ef          	jal	ra,40005cb0 <shell_fprintf>
}
40021d90:	02c12083          	lw	ra,44(sp)
40021d94:	02812403          	lw	s0,40(sp)
40021d98:	02412483          	lw	s1,36(sp)
40021d9c:	02012903          	lw	s2,32(sp)
40021da0:	03010113          	addi	sp,sp,48
40021da4:	00008067          	ret
		PR("%s  \t%s    \t%12s/%12s\n",
40021da8:	4002e6b7          	lui	a3,0x4002e
40021dac:	7a468693          	addi	a3,a3,1956 # 4002e7a4 <CSWTCH.14405+0x11c8>
40021db0:	f71ff06f          	j	40021d20 <ip_address_lifetime_cb+0xe8>
	switch (addr_state) {
40021db4:	4002d737          	lui	a4,0x4002d
40021db8:	3ec70713          	addi	a4,a4,1004 # 4002d3ec <all_nodes_mcast_group.0+0x1c>
40021dbc:	f8dff06f          	j	40021d48 <ip_address_lifetime_cb+0x110>

40021dc0 <iface_per_route_cb>:
{
40021dc0:	fd010113          	addi	sp,sp,-48
40021dc4:	02112623          	sw	ra,44(sp)
40021dc8:	02812423          	sw	s0,40(sp)
40021dcc:	02912223          	sw	s1,36(sp)
40021dd0:	03212023          	sw	s2,32(sp)
	const struct shell *sh = data->sh;
40021dd4:	0005a903          	lw	s2,0(a1)
{
40021dd8:	00050493          	mv	s1,a0
40021ddc:	00058413          	mv	s0,a1
	PR("\nIPv6 routes for interface %d (%p) (%s)\n",
40021de0:	801ed0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
40021de4:	00a12623          	sw	a0,12(sp)
40021de8:	01c10593          	addi	a1,sp,28
40021dec:	00048513          	mv	a0,s1
40021df0:	d21ff0ef          	jal	ra,40021b10 <iface2str>
40021df4:	00c12683          	lw	a3,12(sp)
40021df8:	4002f637          	lui	a2,0x4002f
40021dfc:	00050793          	mv	a5,a0
40021e00:	00048713          	mv	a4,s1
40021e04:	00090513          	mv	a0,s2
40021e08:	88460613          	addi	a2,a2,-1916 # 4002e884 <CSWTCH.14405+0x12a8>
40021e0c:	00800593          	li	a1,8
40021e10:	ea1e30ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("=========================================%s\n", extra);
40021e14:	01c12683          	lw	a3,28(sp)
40021e18:	4002f637          	lui	a2,0x4002f
40021e1c:	00090513          	mv	a0,s2
40021e20:	00800593          	li	a1,8
40021e24:	8b060613          	addi	a2,a2,-1872 # 4002e8b0 <CSWTCH.14405+0x12d4>
40021e28:	e89e30ef          	jal	ra,40005cb0 <shell_fprintf>
	data->user_data = iface;
40021e2c:	00942223          	sw	s1,4(s0)
	net_route_foreach(route_cb, data);
40021e30:	00040593          	mv	a1,s0
}
40021e34:	02812403          	lw	s0,40(sp)
40021e38:	02c12083          	lw	ra,44(sp)
40021e3c:	02412483          	lw	s1,36(sp)
40021e40:	02012903          	lw	s2,32(sp)
	net_route_foreach(route_cb, data);
40021e44:	40022537          	lui	a0,0x40022
40021e48:	39050513          	addi	a0,a0,912 # 40022390 <route_cb>
}
40021e4c:	03010113          	addi	sp,sp,48
	net_route_foreach(route_cb, data);
40021e50:	ac1f806f          	j	4001a910 <net_route_foreach>

40021e54 <parse_arg>:
{
40021e54:	fe010113          	addi	sp,sp,-32
40021e58:	00112e23          	sw	ra,28(sp)
40021e5c:	00812c23          	sw	s0,24(sp)
40021e60:	00912a23          	sw	s1,20(sp)
	const char *str = argv[*i] + 2;
40021e64:	00052783          	lw	a5,0(a0)
40021e68:	00279713          	slli	a4,a5,0x2
40021e6c:	00e60633          	add	a2,a2,a4
40021e70:	00062403          	lw	s0,0(a2)
	if (*str == 0) {
40021e74:	00244703          	lbu	a4,2(s0)
	const char *str = argv[*i] + 2;
40021e78:	00240413          	addi	s0,s0,2
	if (*str == 0) {
40021e7c:	02071863          	bnez	a4,40021eac <parse_arg+0x58>
		if (*i + 1 >= argc) {
40021e80:	00178793          	addi	a5,a5,1
40021e84:	02b7e063          	bltu	a5,a1,40021ea4 <parse_arg+0x50>
			return -1;
40021e88:	fff00493          	li	s1,-1
}
40021e8c:	01c12083          	lw	ra,28(sp)
40021e90:	01812403          	lw	s0,24(sp)
40021e94:	00048513          	mv	a0,s1
40021e98:	01412483          	lw	s1,20(sp)
40021e9c:	02010113          	addi	sp,sp,32
40021ea0:	00008067          	ret
		*i += 1;
40021ea4:	00f52023          	sw	a5,0(a0)
		str = argv[*i];
40021ea8:	00462403          	lw	s0,4(a2)
40021eac:	2b1050ef          	jal	ra,4002795c <z_impl_z_errno>
	if (strncmp(str, "0x", 2) == 0) {
40021eb0:	4002f5b7          	lui	a1,0x4002f
	errno = 0;
40021eb4:	00052023          	sw	zero,0(a0)
	if (strncmp(str, "0x", 2) == 0) {
40021eb8:	00200613          	li	a2,2
40021ebc:	8e058593          	addi	a1,a1,-1824 # 4002e8e0 <CSWTCH.14405+0x1304>
40021ec0:	00040513          	mv	a0,s0
40021ec4:	8cce70ef          	jal	ra,40008f90 <strncmp>
		res = strtol(str, &endptr, 16);
40021ec8:	01000613          	li	a2,16
	if (strncmp(str, "0x", 2) == 0) {
40021ecc:	00050463          	beqz	a0,40021ed4 <parse_arg+0x80>
		res = strtol(str, &endptr, 10);
40021ed0:	00a00613          	li	a2,10
40021ed4:	00c10593          	addi	a1,sp,12
40021ed8:	00040513          	mv	a0,s0
40021edc:	bfde60ef          	jal	ra,40008ad8 <strtol>
40021ee0:	00050493          	mv	s1,a0
40021ee4:	279050ef          	jal	ra,4002795c <z_impl_z_errno>
	if (errno || (endptr == str)) {
40021ee8:	00052783          	lw	a5,0(a0)
40021eec:	f8079ee3          	bnez	a5,40021e88 <parse_arg+0x34>
40021ef0:	00c12783          	lw	a5,12(sp)
40021ef4:	f8879ce3          	bne	a5,s0,40021e8c <parse_arg+0x38>
40021ef8:	f91ff06f          	j	40021e88 <parse_arg+0x34>

40021efc <cmd_net_ping>:
{
40021efc:	fa010113          	addi	sp,sp,-96
40021f00:	04812c23          	sw	s0,88(sp)
40021f04:	04912a23          	sw	s1,84(sp)
40021f08:	05212823          	sw	s2,80(sp)
40021f0c:	05312623          	sw	s3,76(sp)
40021f10:	05412423          	sw	s4,72(sp)
40021f14:	05512223          	sw	s5,68(sp)
40021f18:	05612023          	sw	s6,64(sp)
40021f1c:	03712e23          	sw	s7,60(sp)
40021f20:	03812c23          	sw	s8,56(sp)
40021f24:	03912a23          	sw	s9,52(sp)
40021f28:	03a12823          	sw	s10,48(sp)
40021f2c:	03b12623          	sw	s11,44(sp)
40021f30:	04112e23          	sw	ra,92(sp)
40021f34:	00a12423          	sw	a0,8(sp)
40021f38:	00b12623          	sw	a1,12(sp)
40021f3c:	00060413          	mv	s0,a2
	for (size_t i = 1; i < argc; ++i) {
40021f40:	00100793          	li	a5,1
	int payload_size = 4;
40021f44:	00400993          	li	s3,4
	int tos = 0;
40021f48:	00000a13          	li	s4,0
	int iface_idx = -1;
40021f4c:	fff00913          	li	s2,-1
	int interval = 1000;
40021f50:	3e800a93          	li	s5,1000
	int count = 3;
40021f54:	00300b13          	li	s6,3
	char *host = NULL;
40021f58:	00000493          	li	s1,0
		switch (argv[i][1]) {
40021f5c:	06300b93          	li	s7,99
40021f60:	06900c13          	li	s8,105
40021f64:	07300c93          	li	s9,115
40021f68:	04900d13          	li	s10,73
40021f6c:	05100d93          	li	s11,81
	for (size_t i = 1; i < argc; ++i) {
40021f70:	00c12703          	lw	a4,12(sp)
40021f74:	00f12e23          	sw	a5,28(sp)
40021f78:	02e7e063          	bltu	a5,a4,40021f98 <cmd_net_ping+0x9c>
	if (!host) {
40021f7c:	16049463          	bnez	s1,400220e4 <cmd_net_ping+0x1e8>
		PR_WARNING("Target host missing\n");
40021f80:	00812503          	lw	a0,8(sp)
40021f84:	4002f637          	lui	a2,0x4002f
40021f88:	91460613          	addi	a2,a2,-1772 # 4002e914 <CSWTCH.14405+0x1338>
40021f8c:	00300593          	li	a1,3
40021f90:	d21e30ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
40021f94:	0a00006f          	j	40022034 <cmd_net_ping+0x138>
		if (*argv[i] != '-') {
40021f98:	00279793          	slli	a5,a5,0x2
40021f9c:	00f407b3          	add	a5,s0,a5
40021fa0:	0007a683          	lw	a3,0(a5)
40021fa4:	02d00713          	li	a4,45
40021fa8:	0006c783          	lbu	a5,0(a3)
40021fac:	12e79863          	bne	a5,a4,400220dc <cmd_net_ping+0x1e0>
		switch (argv[i][1]) {
40021fb0:	0016c783          	lbu	a5,1(a3)
40021fb4:	05778263          	beq	a5,s7,40021ff8 <cmd_net_ping+0xfc>
40021fb8:	00fbec63          	bltu	s7,a5,40021fd0 <cmd_net_ping+0xd4>
40021fbc:	0da78e63          	beq	a5,s10,40022098 <cmd_net_ping+0x19c>
40021fc0:	0fb78e63          	beq	a5,s11,400220bc <cmd_net_ping+0x1c0>
			PR_WARNING("Unrecognized argument: %s\n", argv[i]);
40021fc4:	4002f637          	lui	a2,0x4002f
40021fc8:	8f860613          	addi	a2,a2,-1800 # 4002e8f8 <CSWTCH.14405+0x131c>
40021fcc:	05c0006f          	j	40022028 <cmd_net_ping+0x12c>
		switch (argv[i][1]) {
40021fd0:	0b878263          	beq	a5,s8,40022074 <cmd_net_ping+0x178>
40021fd4:	ff9798e3          	bne	a5,s9,40021fc4 <cmd_net_ping+0xc8>
			payload_size = parse_arg(&i, argc, argv);
40021fd8:	00c12583          	lw	a1,12(sp)
40021fdc:	00040613          	mv	a2,s0
40021fe0:	01c10513          	addi	a0,sp,28
40021fe4:	e71ff0ef          	jal	ra,40021e54 <parse_arg>
			if (payload_size < 0 || payload_size > UINT16_MAX) {
40021fe8:	000107b7          	lui	a5,0x10
			payload_size = parse_arg(&i, argc, argv);
40021fec:	00050993          	mv	s3,a0
			if (payload_size < 0 || payload_size > UINT16_MAX) {
40021ff0:	08f56e63          	bltu	a0,a5,4002208c <cmd_net_ping+0x190>
40021ff4:	01c0006f          	j	40022010 <cmd_net_ping+0x114>
			count = parse_arg(&i, argc, argv);
40021ff8:	00c12583          	lw	a1,12(sp)
40021ffc:	00040613          	mv	a2,s0
40022000:	01c10513          	addi	a0,sp,28
40022004:	e51ff0ef          	jal	ra,40021e54 <parse_arg>
40022008:	00050b13          	mv	s6,a0
			if (count < 0) {
4002200c:	08055063          	bgez	a0,4002208c <cmd_net_ping+0x190>
				PR_WARNING("Parse error: %s\n", argv[i]);
40022010:	01c12783          	lw	a5,28(sp)
40022014:	4002f637          	lui	a2,0x4002f
40022018:	8e460613          	addi	a2,a2,-1820 # 4002e8e4 <CSWTCH.14405+0x1308>
4002201c:	00279793          	slli	a5,a5,0x2
40022020:	00f407b3          	add	a5,s0,a5
40022024:	0007a683          	lw	a3,0(a5) # 10000 <__kernel_ram_size+0x3d6c>
			PR_WARNING("Unrecognized argument: %s\n", argv[i]);
40022028:	00812503          	lw	a0,8(sp)
4002202c:	00300593          	li	a1,3
40022030:	c81e30ef          	jal	ra,40005cb0 <shell_fprintf>
	char *host = NULL;
40022034:	ff800513          	li	a0,-8
}
40022038:	05c12083          	lw	ra,92(sp)
4002203c:	05812403          	lw	s0,88(sp)
40022040:	05412483          	lw	s1,84(sp)
40022044:	05012903          	lw	s2,80(sp)
40022048:	04c12983          	lw	s3,76(sp)
4002204c:	04812a03          	lw	s4,72(sp)
40022050:	04412a83          	lw	s5,68(sp)
40022054:	04012b03          	lw	s6,64(sp)
40022058:	03c12b83          	lw	s7,60(sp)
4002205c:	03812c03          	lw	s8,56(sp)
40022060:	03412c83          	lw	s9,52(sp)
40022064:	03012d03          	lw	s10,48(sp)
40022068:	02c12d83          	lw	s11,44(sp)
4002206c:	06010113          	addi	sp,sp,96
40022070:	00008067          	ret
			interval = parse_arg(&i, argc, argv);
40022074:	00c12583          	lw	a1,12(sp)
40022078:	00040613          	mv	a2,s0
4002207c:	01c10513          	addi	a0,sp,28
40022080:	dd5ff0ef          	jal	ra,40021e54 <parse_arg>
40022084:	00050a93          	mv	s5,a0
			if (interval < 0) {
40022088:	f80544e3          	bltz	a0,40022010 <cmd_net_ping+0x114>
	for (size_t i = 1; i < argc; ++i) {
4002208c:	01c12783          	lw	a5,28(sp)
40022090:	00178793          	addi	a5,a5,1
40022094:	eddff06f          	j	40021f70 <cmd_net_ping+0x74>
			iface_idx = parse_arg(&i, argc, argv);
40022098:	00c12583          	lw	a1,12(sp)
4002209c:	00040613          	mv	a2,s0
400220a0:	01c10513          	addi	a0,sp,28
400220a4:	db1ff0ef          	jal	ra,40021e54 <parse_arg>
400220a8:	00050913          	mv	s2,a0
			if (iface_idx < 0 || !net_if_get_by_index(iface_idx)) {
400220ac:	f60542e3          	bltz	a0,40022010 <cmd_net_ping+0x114>
400220b0:	994fd0ef          	jal	ra,4001f244 <net_if_get_by_index>
400220b4:	fc051ce3          	bnez	a0,4002208c <cmd_net_ping+0x190>
400220b8:	f59ff06f          	j	40022010 <cmd_net_ping+0x114>
			tos = parse_arg(&i, argc, argv);
400220bc:	00c12583          	lw	a1,12(sp)
400220c0:	00040613          	mv	a2,s0
400220c4:	01c10513          	addi	a0,sp,28
400220c8:	d8dff0ef          	jal	ra,40021e54 <parse_arg>
			if (tos < 0 || tos > UINT8_MAX) {
400220cc:	0ff00793          	li	a5,255
			tos = parse_arg(&i, argc, argv);
400220d0:	00050a13          	mv	s4,a0
			if (tos < 0 || tos > UINT8_MAX) {
400220d4:	faa7fce3          	bgeu	a5,a0,4002208c <cmd_net_ping+0x190>
400220d8:	f39ff06f          	j	40022010 <cmd_net_ping+0x114>
		if (*argv[i] != '-') {
400220dc:	00068493          	mv	s1,a3
400220e0:	fadff06f          	j	4002208c <cmd_net_ping+0x190>
	memset(&ping_ctx, 0, sizeof(ping_ctx));
400220e4:	40031bb7          	lui	s7,0x40031
400220e8:	06000613          	li	a2,96
400220ec:	00000593          	li	a1,0
400220f0:	1f0b8513          	addi	a0,s7,496 # 400311f0 <ping_ctx>
400220f4:	f7de60ef          	jal	ra,40009070 <memset>
	k_work_init_delayable(&ping_ctx.work, ping_work);
400220f8:	400225b7          	lui	a1,0x40022
400220fc:	25058593          	addi	a1,a1,592 # 40022250 <ping_work>
40022100:	1f0b8513          	addi	a0,s7,496
40022104:	3d0070ef          	jal	ra,400294d4 <k_work_init_delayable>
	ping_ctx.sh = sh;
40022108:	1f0b8793          	addi	a5,s7,496
4002210c:	00812703          	lw	a4,8(sp)
	ping_ctx.payload_size = payload_size;
40022110:	05379c23          	sh	s3,88(a5)
	    net_addr_pton(AF_INET6, host, &ping_ctx.addr.in6_addr) == 0) {
40022114:	400319b7          	lui	s3,0x40031
40022118:	22498613          	addi	a2,s3,548 # 40031224 <ping_ctx+0x34>
4002211c:	00048593          	mv	a1,s1
40022120:	00200513          	li	a0,2
	ping_ctx.tos = tos;
40022124:	05478d23          	sb	s4,90(a5)
	ping_ctx.sh = sh;
40022128:	04e7a423          	sw	a4,72(a5)
	ping_ctx.count = count;
4002212c:	0567a623          	sw	s6,76(a5)
	ping_ctx.interval = interval;
40022130:	0557a823          	sw	s5,80(a5)
	    net_addr_pton(AF_INET6, host, &ping_ctx.addr.in6_addr) == 0) {
40022134:	f94fd0ef          	jal	ra,4001f8c8 <net_addr_pton>
40022138:	1f0b8a13          	addi	s4,s7,496
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
4002213c:	04051863          	bnez	a0,4002218c <cmd_net_ping+0x290>
		net_icmpv6_register_handler(&ping6_handler);
40022140:	4003d537          	lui	a0,0x4003d
		ping_ctx.addr.family = AF_INET6;
40022144:	00200793          	li	a5,2
		net_icmpv6_register_handler(&ping6_handler);
40022148:	9bc50513          	addi	a0,a0,-1604 # 4003c9bc <ping6_handler>
		ping_ctx.addr.family = AF_INET6;
4002214c:	02fa1823          	sh	a5,48(s4)
		net_icmpv6_register_handler(&ping6_handler);
40022150:	aa9f30ef          	jal	ra,40015bf8 <net_icmpv6_register_handler>
	struct net_if *iface = net_if_get_by_index(id);
40022154:	00090513          	mv	a0,s2
40022158:	8ecfd0ef          	jal	ra,4001f244 <net_if_get_by_index>
4002215c:	00050793          	mv	a5,a0
	if (iface != NULL) {
40022160:	08051e63          	bnez	a0,400221fc <cmd_net_ping+0x300>
	if (IS_ENABLED(CONFIG_NET_IPV4) && target->family == AF_INET) {
40022164:	030a5703          	lhu	a4,48(s4)
40022168:	00100693          	li	a3,1
4002216c:	06d71463          	bne	a4,a3,400221d4 <cmd_net_ping+0x2d8>
		iface = net_if_ipv4_select_src_iface(&target->in_addr);
40022170:	22498513          	addi	a0,s3,548
40022174:	aedec0ef          	jal	ra,4000ec60 <net_if_ipv4_select_src_iface>
40022178:	00050793          	mv	a5,a0
		if (iface != NULL) {
4002217c:	08051063          	bnez	a0,400221fc <cmd_net_ping+0x300>
		iface = net_if_get_default();
40022180:	a3dea0ef          	jal	ra,4000cbbc <net_if_get_default>
40022184:	00050793          	mv	a5,a0
40022188:	0740006f          	j	400221fc <cmd_net_ping+0x300>
		   net_addr_pton(AF_INET, host, &ping_ctx.addr.in_addr) == 0) {
4002218c:	22498613          	addi	a2,s3,548
40022190:	00048593          	mv	a1,s1
40022194:	00100513          	li	a0,1
40022198:	f30fd0ef          	jal	ra,4001f8c8 <net_addr_pton>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
4002219c:	00051e63          	bnez	a0,400221b8 <cmd_net_ping+0x2bc>
		net_icmpv4_register_handler(&ping4_handler);
400221a0:	4003d537          	lui	a0,0x4003d
		ping_ctx.addr.family = AF_INET;
400221a4:	00100793          	li	a5,1
		net_icmpv4_register_handler(&ping4_handler);
400221a8:	9b050513          	addi	a0,a0,-1616 # 4003c9b0 <ping4_handler>
		ping_ctx.addr.family = AF_INET;
400221ac:	02fa1823          	sh	a5,48(s4)
		net_icmpv4_register_handler(&ping4_handler);
400221b0:	a60f30ef          	jal	ra,40015410 <net_icmpv4_register_handler>
400221b4:	fa1ff06f          	j	40022154 <cmd_net_ping+0x258>
		PR_WARNING("Invalid IP address\n");
400221b8:	00812503          	lw	a0,8(sp)
400221bc:	4002f637          	lui	a2,0x4002f
400221c0:	92c60613          	addi	a2,a2,-1748 # 4002e92c <CSWTCH.14405+0x1350>
400221c4:	00300593          	li	a1,3
400221c8:	ae9e30ef          	jal	ra,40005cb0 <shell_fprintf>
		return 0;
400221cc:	00000513          	li	a0,0
400221d0:	e69ff06f          	j	40022038 <cmd_net_ping+0x13c>
	if (IS_ENABLED(CONFIG_NET_IPV6) && target->family == AF_INET6) {
400221d4:	00200693          	li	a3,2
400221d8:	02d71263          	bne	a4,a3,400221fc <cmd_net_ping+0x300>
		iface = net_if_ipv6_select_src_iface(&target->in6_addr);
400221dc:	22498513          	addi	a0,s3,548
400221e0:	f28ec0ef          	jal	ra,4000e908 <net_if_ipv6_select_src_iface>
400221e4:	00050793          	mv	a5,a0
		if (iface != NULL) {
400221e8:	00051a63          	bnez	a0,400221fc <cmd_net_ping+0x300>
		nbr = net_ipv6_nbr_lookup(NULL, &target->in6_addr);
400221ec:	22498593          	addi	a1,s3,548
400221f0:	9c5f50ef          	jal	ra,40017bb4 <net_ipv6_nbr_lookup>
		if (nbr) {
400221f4:	04050463          	beqz	a0,4002223c <cmd_net_ping+0x340>
			iface = nbr->iface;
400221f8:	00852783          	lw	a5,8(a0)
	PR("PING %s\n", host);
400221fc:	00812503          	lw	a0,8(sp)
40022200:	4002f637          	lui	a2,0x4002f
40022204:	00048693          	mv	a3,s1
40022208:	94060613          	addi	a2,a2,-1728 # 4002e940 <CSWTCH.14405+0x1364>
4002220c:	00800593          	li	a1,8
	ping_ctx.iface = ping_select_iface(iface_idx, &ping_ctx.addr);
40022210:	04fa2223          	sw	a5,68(s4)
	PR("PING %s\n", host);
40022214:	a9de30ef          	jal	ra,40005cb0 <shell_fprintf>
	shell_set_bypass(sh, ping_bypass);
40022218:	00812503          	lw	a0,8(sp)
4002221c:	400215b7          	lui	a1,0x40021
40022220:	ec058593          	addi	a1,a1,-320 # 40020ec0 <ping_bypass>
40022224:	dd1e30ef          	jal	ra,40005ff4 <shell_set_bypass>
	k_work_reschedule(&ping_ctx.work, K_NO_WAIT);
40022228:	00000593          	li	a1,0
4002222c:	00000613          	li	a2,0
40022230:	1f0b8513          	addi	a0,s7,496
40022234:	3f0070ef          	jal	ra,40029624 <k_work_reschedule>
	return 0;
40022238:	f95ff06f          	j	400221cc <cmd_net_ping+0x2d0>
		route = net_route_lookup(NULL, &target->in6_addr);
4002223c:	22498593          	addi	a1,s3,548
40022240:	ee5f70ef          	jal	ra,4001a124 <net_route_lookup>
		if (route) {
40022244:	f2050ee3          	beqz	a0,40022180 <cmd_net_ping+0x284>
			iface = route->iface;
40022248:	00c52783          	lw	a5,12(a0)
			goto out;
4002224c:	fb1ff06f          	j	400221fc <cmd_net_ping+0x300>

40022250 <ping_work>:
{
40022250:	fe010113          	addi	sp,sp,-32
40022254:	00812c23          	sw	s0,24(sp)
40022258:	00112e23          	sw	ra,28(sp)
4002225c:	00912a23          	sw	s1,20(sp)
40022260:	01212823          	sw	s2,16(sp)
	ctx->sequence++;
40022264:	05452783          	lw	a5,84(a0)
	if (ctx->sequence > ctx->count) {
40022268:	04c52703          	lw	a4,76(a0)
	const struct shell *sh = ctx->sh;
4002226c:	04852483          	lw	s1,72(a0)
	ctx->sequence++;
40022270:	00178793          	addi	a5,a5,1
40022274:	04f52a23          	sw	a5,84(a0)
{
40022278:	00050413          	mv	s0,a0
	if (ctx->sequence > ctx->count) {
4002227c:	02f77a63          	bgeu	a4,a5,400222b0 <ping_work+0x60>
		PR_INFO("Ping timeout\n");
40022280:	4002f637          	lui	a2,0x4002f
40022284:	94c60613          	addi	a2,a2,-1716 # 4002e94c <CSWTCH.14405+0x1370>
40022288:	00200593          	li	a1,2
4002228c:	00048513          	mv	a0,s1
40022290:	a21e30ef          	jal	ra,40005cb0 <shell_fprintf>
		ping_done(ctx);
40022294:	00040513          	mv	a0,s0
}
40022298:	01812403          	lw	s0,24(sp)
4002229c:	01c12083          	lw	ra,28(sp)
400222a0:	01412483          	lw	s1,20(sp)
400222a4:	01012903          	lw	s2,16(sp)
400222a8:	02010113          	addi	sp,sp,32
		ping_done(ctx);
400222ac:	f01fd06f          	j	400201ac <ping_done>
	if (ctx->addr.family == AF_INET6) {
400222b0:	03055703          	lhu	a4,48(a0)
		ret = net_icmpv6_send_echo_request(ctx->iface,
400222b4:	03450593          	addi	a1,a0,52
	if (ctx->addr.family == AF_INET6) {
400222b8:	00200793          	li	a5,2
400222bc:	00b12623          	sw	a1,12(sp)
		ret = net_icmpv6_send_echo_request(ctx->iface,
400222c0:	04452903          	lw	s2,68(a0)
	if (ctx->addr.family == AF_INET6) {
400222c4:	04f71663          	bne	a4,a5,40022310 <ping_work+0xc0>
400222c8:	aace70ef          	jal	ra,40009574 <z_impl_sys_rand32_get>
		ret = net_icmpv6_send_echo_request(ctx->iface,
400222cc:	05845803          	lhu	a6,88(s0)
400222d0:	05a44703          	lbu	a4,90(s0)
400222d4:	05445683          	lhu	a3,84(s0)
400222d8:	00c12583          	lw	a1,12(sp)
400222dc:	01051613          	slli	a2,a0,0x10
400222e0:	00000793          	li	a5,0
400222e4:	01065613          	srli	a2,a2,0x10
400222e8:	00090513          	mv	a0,s2
400222ec:	ea9f30ef          	jal	ra,40016194 <net_icmpv6_send_echo_request>
		ret = net_icmpv4_send_echo_request(ctx->iface,
400222f0:	00050693          	mv	a3,a0
	if (ret != 0) {
400222f4:	04050463          	beqz	a0,4002233c <ping_work+0xec>
		PR_WARNING("Failed to send ping, err: %d", ret);
400222f8:	4002f637          	lui	a2,0x4002f
400222fc:	95c60613          	addi	a2,a2,-1700 # 4002e95c <CSWTCH.14405+0x1380>
40022300:	00300593          	li	a1,3
40022304:	00048513          	mv	a0,s1
40022308:	9a9e30ef          	jal	ra,40005cb0 <shell_fprintf>
4002230c:	f89ff06f          	j	40022294 <ping_work+0x44>
40022310:	a64e70ef          	jal	ra,40009574 <z_impl_sys_rand32_get>
		ret = net_icmpv4_send_echo_request(ctx->iface,
40022314:	05845803          	lhu	a6,88(s0)
40022318:	05a44703          	lbu	a4,90(s0)
4002231c:	05445683          	lhu	a3,84(s0)
40022320:	00c12583          	lw	a1,12(sp)
40022324:	01051613          	slli	a2,a0,0x10
40022328:	00000793          	li	a5,0
4002232c:	01065613          	srli	a2,a2,0x10
40022330:	00090513          	mv	a0,s2
40022334:	d01f20ef          	jal	ra,40015034 <net_icmpv4_send_echo_request>
40022338:	fb9ff06f          	j	400222f0 <ping_work+0xa0>
	if (ctx->sequence < ctx->count) {
4002233c:	05442703          	lw	a4,84(s0)
40022340:	04c42783          	lw	a5,76(s0)
40022344:	04f77063          	bgeu	a4,a5,40022384 <ping_work+0x134>
		k_work_reschedule(&ctx->work, K_MSEC(ctx->interval));
40022348:	05042583          	lw	a1,80(s0)
			return t / ((uint64_t)from_hz / to_hz);
4002234c:	00a00613          	li	a2,10
40022350:	00000693          	li	a3,0
		t += off;
40022354:	00958513          	addi	a0,a1,9
			return t / ((uint64_t)from_hz / to_hz);
40022358:	00b535b3          	sltu	a1,a0,a1
4002235c:	f5ddd0ef          	jal	ra,400002b8 <__udivdi3>
40022360:	00058613          	mv	a2,a1
40022364:	00050593          	mv	a1,a0
		k_work_reschedule(&ctx->work, K_SECONDS(2));
40022368:	00040513          	mv	a0,s0
}
4002236c:	01812403          	lw	s0,24(sp)
40022370:	01c12083          	lw	ra,28(sp)
40022374:	01412483          	lw	s1,20(sp)
40022378:	01012903          	lw	s2,16(sp)
4002237c:	02010113          	addi	sp,sp,32
		k_work_reschedule(&ctx->work, K_SECONDS(2));
40022380:	2a40706f          	j	40029624 <k_work_reschedule>
40022384:	0c800593          	li	a1,200
40022388:	00000613          	li	a2,0
4002238c:	fddff06f          	j	40022368 <ping_work+0x118>

40022390 <route_cb>:
{
40022390:	fb010113          	addi	sp,sp,-80
40022394:	04812423          	sw	s0,72(sp)
40022398:	04112623          	sw	ra,76(sp)
4002239c:	04912223          	sw	s1,68(sp)
400223a0:	05212023          	sw	s2,64(sp)
400223a4:	03312e23          	sw	s3,60(sp)
400223a8:	03412c23          	sw	s4,56(sp)
400223ac:	03512a23          	sw	s5,52(sp)
400223b0:	03612823          	sw	s6,48(sp)
400223b4:	03712623          	sw	s7,44(sp)
400223b8:	03812423          	sw	s8,40(sp)
400223bc:	03912223          	sw	s9,36(sp)
400223c0:	03a12023          	sw	s10,32(sp)
400223c4:	01b12e23          	sw	s11,28(sp)
	const struct shell *sh = data->sh;
400223c8:	0005a483          	lw	s1,0(a1)
	struct net_if *iface = data->user_data;
400223cc:	0045a903          	lw	s2,4(a1)
{
400223d0:	00050413          	mv	s0,a0
	return z_impl_k_uptime_ticks();
400223d4:	7e0080ef          	jal	ra,4002abb4 <z_impl_k_uptime_ticks>
	if (entry->iface != iface) {
400223d8:	00c42783          	lw	a5,12(s0)
400223dc:	17279a63          	bne	a5,s2,40022550 <route_cb+0x1c0>
			return t * ((uint64_t)to_hz / from_hz);
400223e0:	00a00a13          	li	s4,10
	PR("IPv6 prefix : %s/%d\n", net_sprint_ipv6_addr(&entry->addr),
400223e4:	02040593          	addi	a1,s0,32
400223e8:	02aa0a33          	mul	s4,s4,a0
400223ec:	00200513          	li	a0,2
400223f0:	d29ed0ef          	jal	ra,40010118 <net_sprint_addr>
400223f4:	03044703          	lbu	a4,48(s0)
400223f8:	4002f637          	lui	a2,0x4002f
400223fc:	00050693          	mv	a3,a0
40022400:	97c60613          	addi	a2,a2,-1668 # 4002e97c <CSWTCH.14405+0x13a0>
40022404:	00800593          	li	a1,8
40022408:	00048513          	mv	a0,s1
4002240c:	8a5e30ef          	jal	ra,40005cb0 <shell_fprintf>
	return list->head;
40022410:	00442903          	lw	s2,4(s0)
40022414:	00000993          	li	s3,0
		PR("\tneighbor : %p\t", nexthop_route->nbr);
40022418:	4002fab7          	lui	s5,0x4002f
		PR("lifetime : %s\n", remaining_str);
4002241c:	4002fb37          	lui	s6,0x4002f
			snprintk(remaining_str, sizeof(remaining_str) - 1,
40022420:	4002fbb7          	lui	s7,0x4002f
			snprintk(remaining_str, sizeof(remaining_str) - 1,
40022424:	4002fc37          	lui	s8,0x4002f
	return net_sprint_ll_addr_buf(ll, ll_len, (char *)buf, sizeof(buf));
40022428:	40032cb7          	lui	s9,0x40032
			PR("addr : %s\t", net_sprint_ll_addr(lladdr->addr,
4002242c:	4002fd37          	lui	s10,0x4002f
			PR("addr : <unknown>\t");
40022430:	4002fdb7          	lui	s11,0x4002f
	SYS_SLIST_FOR_EACH_CONTAINER(&entry->nexthop, nexthop_route, node) {
40022434:	04091a63          	bnez	s2,40022488 <route_cb+0xf8>
	if (count == 0) {
40022438:	10099c63          	bnez	s3,40022550 <route_cb+0x1c0>
}
4002243c:	04812403          	lw	s0,72(sp)
40022440:	04c12083          	lw	ra,76(sp)
40022444:	04012903          	lw	s2,64(sp)
40022448:	03c12983          	lw	s3,60(sp)
4002244c:	03812a03          	lw	s4,56(sp)
40022450:	03412a83          	lw	s5,52(sp)
40022454:	03012b03          	lw	s6,48(sp)
40022458:	02c12b83          	lw	s7,44(sp)
4002245c:	02812c03          	lw	s8,40(sp)
40022460:	02412c83          	lw	s9,36(sp)
40022464:	02012d03          	lw	s10,32(sp)
40022468:	01c12d83          	lw	s11,28(sp)
		PR("\t<none>\n");
4002246c:	00048513          	mv	a0,s1
}
40022470:	04412483          	lw	s1,68(sp)
		PR("\t<none>\n");
40022474:	4002f637          	lui	a2,0x4002f
40022478:	9e860613          	addi	a2,a2,-1560 # 4002e9e8 <CSWTCH.14405+0x140c>
4002247c:	00800593          	li	a1,8
}
40022480:	05010113          	addi	sp,sp,80
		PR("\t<none>\n");
40022484:	82de306f          	j	40005cb0 <shell_fprintf>
		if (!nexthop_route->nbr) {
40022488:	00492683          	lw	a3,4(s2)
4002248c:	06068463          	beqz	a3,400224f4 <route_cb+0x164>
		PR("\tneighbor : %p\t", nexthop_route->nbr);
40022490:	00048513          	mv	a0,s1
40022494:	994a8613          	addi	a2,s5,-1644 # 4002e994 <CSWTCH.14405+0x13b8>
40022498:	00800593          	li	a1,8
4002249c:	815e30ef          	jal	ra,40005cb0 <shell_fprintf>
		if (nexthop_route->nbr->idx == NET_NBR_LLADDR_UNKNOWN) {
400224a0:	00492783          	lw	a5,4(s2)
400224a4:	0017c503          	lbu	a0,1(a5)
400224a8:	0ff00793          	li	a5,255
400224ac:	04f51863          	bne	a0,a5,400224fc <route_cb+0x16c>
			PR("addr : <unknown>\t");
400224b0:	9a4d8613          	addi	a2,s11,-1628 # 4002e9a4 <CSWTCH.14405+0x13c8>
400224b4:	00800593          	li	a1,8
400224b8:	00048513          	mv	a0,s1
400224bc:	ff4e30ef          	jal	ra,40005cb0 <shell_fprintf>
		if (entry->is_infinite) {
400224c0:	03144783          	lbu	a5,49(s0)
400224c4:	0047f793          	andi	a5,a5,4
400224c8:	06078263          	beqz	a5,4002252c <route_cb+0x19c>
			snprintk(remaining_str, sizeof(remaining_str) - 1,
400224cc:	9c4c0613          	addi	a2,s8,-1596 # 4002e9c4 <CSWTCH.14405+0x13e8>
400224d0:	00f00593          	li	a1,15
400224d4:	00010513          	mv	a0,sp
400224d8:	af1de0ef          	jal	ra,40000fc8 <snprintk>
		PR("lifetime : %s\n", remaining_str);
400224dc:	00010693          	mv	a3,sp
400224e0:	9d8b0613          	addi	a2,s6,-1576 # 4002e9d8 <CSWTCH.14405+0x13fc>
400224e4:	00800593          	li	a1,8
400224e8:	00048513          	mv	a0,s1
400224ec:	fc4e30ef          	jal	ra,40005cb0 <shell_fprintf>
		count++;
400224f0:	00198993          	addi	s3,s3,1
	return node->next;
400224f4:	00092903          	lw	s2,0(s2)
400224f8:	f3dff06f          	j	40022434 <route_cb+0xa4>
			lladdr = net_nbr_get_lladdr(nexthop_route->nbr->idx);
400224fc:	a0cf40ef          	jal	ra,40016708 <net_nbr_get_lladdr>
40022500:	00154583          	lbu	a1,1(a0)
40022504:	690c8613          	addi	a2,s9,1680 # 40032690 <buf.1>
40022508:	01800693          	li	a3,24
4002250c:	00250513          	addi	a0,a0,2
40022510:	fe8ed0ef          	jal	ra,4000fcf8 <net_sprint_ll_addr_buf>
40022514:	00050693          	mv	a3,a0
			PR("addr : %s\t", net_sprint_ll_addr(lladdr->addr,
40022518:	9b8d0613          	addi	a2,s10,-1608 # 4002e9b8 <CSWTCH.14405+0x13dc>
4002251c:	00800593          	li	a1,8
40022520:	00048513          	mv	a0,s1
40022524:	f8ce30ef          	jal	ra,40005cb0 <shell_fprintf>
40022528:	f99ff06f          	j	400224c0 <route_cb+0x130>
			remaining = net_timeout_remaining(&entry->lifetime, now);
4002252c:	000a0593          	mv	a1,s4
40022530:	01040513          	addi	a0,s0,16
40022534:	de0ed0ef          	jal	ra,4000fb14 <net_timeout_remaining>
40022538:	00050693          	mv	a3,a0
			snprintk(remaining_str, sizeof(remaining_str) - 1,
4002253c:	9d0b8613          	addi	a2,s7,-1584 # 4002e9d0 <CSWTCH.14405+0x13f4>
40022540:	00f00593          	li	a1,15
40022544:	00010513          	mv	a0,sp
40022548:	a81de0ef          	jal	ra,40000fc8 <snprintk>
4002254c:	f91ff06f          	j	400224dc <route_cb+0x14c>
}
40022550:	04c12083          	lw	ra,76(sp)
40022554:	04812403          	lw	s0,72(sp)
40022558:	04412483          	lw	s1,68(sp)
4002255c:	04012903          	lw	s2,64(sp)
40022560:	03c12983          	lw	s3,60(sp)
40022564:	03812a03          	lw	s4,56(sp)
40022568:	03412a83          	lw	s5,52(sp)
4002256c:	03012b03          	lw	s6,48(sp)
40022570:	02c12b83          	lw	s7,44(sp)
40022574:	02812c03          	lw	s8,40(sp)
40022578:	02412c83          	lw	s9,36(sp)
4002257c:	02012d03          	lw	s10,32(sp)
40022580:	01c12d83          	lw	s11,28(sp)
40022584:	05010113          	addi	sp,sp,80
40022588:	00008067          	ret

4002258c <cmd_net_udp_bind>:
{
4002258c:	fb010113          	addi	sp,sp,-80
40022590:	04112623          	sw	ra,76(sp)
40022594:	04812423          	sw	s0,72(sp)
40022598:	04912223          	sw	s1,68(sp)
4002259c:	05212023          	sw	s2,64(sp)
400225a0:	03312e23          	sw	s3,60(sp)
400225a4:	03412c23          	sw	s4,56(sp)
	char *endptr = NULL;
400225a8:	00012a23          	sw	zero,20(sp)
	if (argc < 3) {
400225ac:	00200793          	li	a5,2
400225b0:	02b7ee63          	bltu	a5,a1,400225ec <cmd_net_udp_bind+0x60>
		PR_WARNING("Not enough arguments given for udp bind command\n");
400225b4:	4002f637          	lui	a2,0x4002f
400225b8:	9f460613          	addi	a2,a2,-1548 # 4002e9f4 <CSWTCH.14405+0x1418>
400225bc:	00300593          	li	a1,3
		PR_WARNING("Invalid port number\n");
400225c0:	ef0e30ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EINVAL;
400225c4:	fea00913          	li	s2,-22
}
400225c8:	04c12083          	lw	ra,76(sp)
400225cc:	04812403          	lw	s0,72(sp)
400225d0:	04412483          	lw	s1,68(sp)
400225d4:	03c12983          	lw	s3,60(sp)
400225d8:	03812a03          	lw	s4,56(sp)
400225dc:	00090513          	mv	a0,s2
400225e0:	04012903          	lw	s2,64(sp)
400225e4:	05010113          	addi	sp,sp,80
400225e8:	00008067          	ret
400225ec:	00060913          	mv	s2,a2
	addr_str = argv[1];
400225f0:	00050413          	mv	s0,a0
	port = strtol(argv[2], &endptr, 0);
400225f4:	00892503          	lw	a0,8(s2)
	addr_str = argv[1];
400225f8:	00462a03          	lw	s4,4(a2)
	port = strtol(argv[2], &endptr, 0);
400225fc:	01410593          	addi	a1,sp,20
40022600:	00000613          	li	a2,0
40022604:	cd4e60ef          	jal	ra,40008ad8 <strtol>
	if (endptr == argv[2]) {
40022608:	00892703          	lw	a4,8(s2)
4002260c:	01412783          	lw	a5,20(sp)
	port = strtol(argv[2], &endptr, 0);
40022610:	01051493          	slli	s1,a0,0x10
40022614:	0104d493          	srli	s1,s1,0x10
	if (endptr == argv[2]) {
40022618:	00f71c63          	bne	a4,a5,40022630 <cmd_net_udp_bind+0xa4>
		PR_WARNING("Invalid port number\n");
4002261c:	4002e637          	lui	a2,0x4002e
40022620:	54c60613          	addi	a2,a2,1356 # 4002e54c <CSWTCH.14405+0xf70>
40022624:	00300593          	li	a1,3
40022628:	00040513          	mv	a0,s0
4002262c:	f95ff06f          	j	400225c0 <cmd_net_udp_bind+0x34>
	if (udp_ctx && net_context_is_used(udp_ctx)) {
40022630:	400319b7          	lui	s3,0x40031
40022634:	ad89a783          	lw	a5,-1320(s3) # 40030ad8 <udp_ctx>
40022638:	02078663          	beqz	a5,40022664 <cmd_net_udp_bind+0xd8>
	return context->flags & NET_CONTEXT_IN_USE;
4002263c:	0747d783          	lhu	a5,116(a5)
40022640:	0017f793          	andi	a5,a5,1
40022644:	02078063          	beqz	a5,40022664 <cmd_net_udp_bind+0xd8>
		PR_WARNING("Network context already in use\n");
40022648:	4002e637          	lui	a2,0x4002e
4002264c:	56460613          	addi	a2,a2,1380 # 4002e564 <CSWTCH.14405+0xf88>
40022650:	00300593          	li	a1,3
40022654:	00040513          	mv	a0,s0
40022658:	e58e30ef          	jal	ra,40005cb0 <shell_fprintf>
		return -EALREADY;
4002265c:	f8800913          	li	s2,-120
40022660:	f69ff06f          	j	400225c8 <cmd_net_udp_bind+0x3c>
	memset(&addr, 0, sizeof(addr));
40022664:	01800613          	li	a2,24
40022668:	00000593          	li	a1,0
4002266c:	01810513          	addi	a0,sp,24
40022670:	a01e60ef          	jal	ra,40009070 <memset>
	ret = net_ipaddr_parse(addr_str, strlen(addr_str), &addr);
40022674:	000a0513          	mv	a0,s4
40022678:	8b1e60ef          	jal	ra,40008f28 <strlen>
4002267c:	00050593          	mv	a1,a0
40022680:	01810613          	addi	a2,sp,24
40022684:	000a0513          	mv	a0,s4
40022688:	b60ee0ef          	jal	ra,400109e8 <net_ipaddr_parse>
	ret = net_context_get(addr.sa_family, SOCK_DGRAM, IPPROTO_UDP,
4002268c:	01815503          	lhu	a0,24(sp)
40022690:	ad898693          	addi	a3,s3,-1320
40022694:	01100613          	li	a2,17
40022698:	00200593          	li	a1,2
4002269c:	e45ee0ef          	jal	ra,400114e0 <net_context_get>
400226a0:	00050913          	mv	s2,a0
	if (ret < 0) {
400226a4:	02055063          	bgez	a0,400226c4 <cmd_net_udp_bind+0x138>
		PR_WARNING("Cannot get UDP context (%d)\n", ret);
400226a8:	4002e637          	lui	a2,0x4002e
400226ac:	00050693          	mv	a3,a0
400226b0:	58460613          	addi	a2,a2,1412 # 4002e584 <CSWTCH.14405+0xfa8>
400226b4:	00300593          	li	a1,3
400226b8:	00040513          	mv	a0,s0
400226bc:	df4e30ef          	jal	ra,40005cb0 <shell_fprintf>
		return ret;
400226c0:	f09ff06f          	j	400225c8 <cmd_net_udp_bind+0x3c>
	udp_shell = sh;
400226c4:	400317b7          	lui	a5,0x40031
400226c8:	ac87aa23          	sw	s0,-1324(a5) # 40030ad4 <udp_shell>
	if (IS_ENABLED(CONFIG_NET_IPV6) && addr.sa_family == AF_INET6) {
400226cc:	01815783          	lhu	a5,24(sp)
400226d0:	00200713          	li	a4,2
400226d4:	06e79063          	bne	a5,a4,40022734 <cmd_net_udp_bind+0x1a8>
		net_sin6(&addr)->sin6_port = htons(port);
400226d8:	00849793          	slli	a5,s1,0x8
400226dc:	0084d493          	srli	s1,s1,0x8
400226e0:	0097e7b3          	or	a5,a5,s1
		iface = net_if_ipv6_select_src_iface(
400226e4:	01c10513          	addi	a0,sp,28
		net_sin6(&addr)->sin6_port = htons(port);
400226e8:	00f11d23          	sh	a5,26(sp)
		iface = net_if_ipv6_select_src_iface(
400226ec:	a1cec0ef          	jal	ra,4000e908 <net_if_ipv6_select_src_iface>
		addrlen = sizeof(struct sockaddr_in6);
400226f0:	01800613          	li	a2,24
	if (!iface) {
400226f4:	08051463          	bnez	a0,4002277c <cmd_net_udp_bind+0x1f0>
		PR_WARNING("No interface to send to given host\n");
400226f8:	4002e637          	lui	a2,0x4002e
400226fc:	5d460613          	addi	a2,a2,1492 # 4002e5d4 <CSWTCH.14405+0xff8>
40022700:	00300593          	li	a1,3
40022704:	00040513          	mv	a0,s0
40022708:	da8e30ef          	jal	ra,40005cb0 <shell_fprintf>
	ret = net_context_put(udp_ctx);
4002270c:	ad89a503          	lw	a0,-1320(s3)
40022710:	8acef0ef          	jal	ra,400117bc <net_context_put>
40022714:	00050693          	mv	a3,a0
	if (ret < 0) {
40022718:	0a055e63          	bgez	a0,400227d4 <cmd_net_udp_bind+0x248>
		PR_WARNING("Cannot put UDP context (%d)\n", ret);
4002271c:	4002e637          	lui	a2,0x4002e
40022720:	65460613          	addi	a2,a2,1620 # 4002e654 <CSWTCH.14405+0x1078>
40022724:	00300593          	li	a1,3
40022728:	00040513          	mv	a0,s0
4002272c:	d84e30ef          	jal	ra,40005cb0 <shell_fprintf>
40022730:	0a40006f          	j	400227d4 <cmd_net_udp_bind+0x248>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && addr.sa_family == AF_INET) {
40022734:	00100713          	li	a4,1
40022738:	02e79263          	bne	a5,a4,4002275c <cmd_net_udp_bind+0x1d0>
		net_sin(&addr)->sin_port = htons(port);
4002273c:	00849793          	slli	a5,s1,0x8
40022740:	0084d493          	srli	s1,s1,0x8
40022744:	0097e7b3          	or	a5,a5,s1
		iface = net_if_ipv4_select_src_iface(
40022748:	01c10513          	addi	a0,sp,28
		net_sin(&addr)->sin_port = htons(port);
4002274c:	00f11d23          	sh	a5,26(sp)
		iface = net_if_ipv4_select_src_iface(
40022750:	d10ec0ef          	jal	ra,4000ec60 <net_if_ipv4_select_src_iface>
		addrlen = sizeof(struct sockaddr_in);
40022754:	00800613          	li	a2,8
40022758:	f9dff06f          	j	400226f4 <cmd_net_udp_bind+0x168>
		PR_WARNING("IPv6 and IPv4 are disabled, cannot %s.\n", "bind");
4002275c:	4002f6b7          	lui	a3,0x4002f
40022760:	4002e637          	lui	a2,0x4002e
40022764:	a2868693          	addi	a3,a3,-1496 # 4002ea28 <CSWTCH.14405+0x144c>
40022768:	5ac60613          	addi	a2,a2,1452 # 4002e5ac <CSWTCH.14405+0xfd0>
		PR_WARNING("Receiving from UDP port failed (%d)\n", ret);
4002276c:	00300593          	li	a1,3
40022770:	00040513          	mv	a0,s0
40022774:	d3ce30ef          	jal	ra,40005cb0 <shell_fprintf>
		goto release_ctx;
40022778:	f95ff06f          	j	4002270c <cmd_net_udp_bind+0x180>
	net_context_set_iface(udp_ctx, iface);
4002277c:	ad89a483          	lw	s1,-1320(s3)
40022780:	00c12623          	sw	a2,12(sp)
	context->iface = net_if_get_by_iface(iface);
40022784:	e5dec0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
40022788:	06a48b23          	sb	a0,118(s1)
	ret = net_context_bind(udp_ctx, &addr, addrlen);
4002278c:	00c12603          	lw	a2,12(sp)
40022790:	ad89a503          	lw	a0,-1320(s3)
40022794:	01810593          	addi	a1,sp,24
40022798:	8b0ef0ef          	jal	ra,40011848 <net_context_bind>
4002279c:	00050693          	mv	a3,a0
	if (ret < 0) {
400227a0:	00055863          	bgez	a0,400227b0 <cmd_net_udp_bind+0x224>
		PR_WARNING("Binding to UDP port failed (%d)\n", ret);
400227a4:	4002f637          	lui	a2,0x4002f
400227a8:	a3060613          	addi	a2,a2,-1488 # 4002ea30 <CSWTCH.14405+0x1454>
400227ac:	fc1ff06f          	j	4002276c <cmd_net_udp_bind+0x1e0>
	ret = net_context_recv(udp_ctx, udp_rcvd, K_NO_WAIT, NULL);
400227b0:	ad89a503          	lw	a0,-1320(s3)
400227b4:	400215b7          	lui	a1,0x40021
400227b8:	00000693          	li	a3,0
400227bc:	00000713          	li	a4,0
400227c0:	00000613          	li	a2,0
400227c4:	66058593          	addi	a1,a1,1632 # 40021660 <udp_rcvd>
400227c8:	ed5ef0ef          	jal	ra,4001269c <net_context_recv>
400227cc:	00050693          	mv	a3,a0
	if (ret < 0) {
400227d0:	00054663          	bltz	a0,400227dc <cmd_net_udp_bind+0x250>
	return 0;
400227d4:	00000913          	li	s2,0
400227d8:	df1ff06f          	j	400225c8 <cmd_net_udp_bind+0x3c>
		PR_WARNING("Receiving from UDP port failed (%d)\n", ret);
400227dc:	4002f637          	lui	a2,0x4002f
400227e0:	a5460613          	addi	a2,a2,-1452 # 4002ea54 <CSWTCH.14405+0x1478>
400227e4:	f89ff06f          	j	4002276c <cmd_net_udp_bind+0x1e0>

400227e8 <dns_result_cb>:
{
400227e8:	fc010113          	addi	sp,sp,-64
400227ec:	02812c23          	sw	s0,56(sp)
400227f0:	02112e23          	sw	ra,60(sp)
	if (status == DNS_EAI_CANCELED) {
400227f4:	f9b00793          	li	a5,-101
{
400227f8:	00060413          	mv	s0,a2
	if (status == DNS_EAI_CANCELED) {
400227fc:	00f51a63          	bne	a0,a5,40022810 <dns_result_cb+0x28>
		PR_WARNING("dns: Timeout while resolving name.\n");
40022800:	4002f637          	lui	a2,0x4002f
40022804:	a7c60613          	addi	a2,a2,-1412 # 4002ea7c <CSWTCH.14405+0x14a0>
		PR_WARNING("dns: No such name found.\n");
40022808:	00300593          	li	a1,3
4002280c:	0a80006f          	j	400228b4 <dns_result_cb+0xcc>
	if (status == DNS_EAI_INPROGRESS && info) {
40022810:	f9c00793          	li	a5,-100
40022814:	00050693          	mv	a3,a0
40022818:	08f51463          	bne	a0,a5,400228a0 <dns_result_cb+0xb8>
4002281c:	0c058063          	beqz	a1,400228dc <dns_result_cb+0xf4>
		if (info->ai_family == AF_INET) {
40022820:	01c5c783          	lbu	a5,28(a1)
40022824:	00100713          	li	a4,1
40022828:	04e79063          	bne	a5,a4,40022868 <dns_result_cb+0x80>
	return z_impl_net_addr_ntop(family, src, dst, size);
4002282c:	01000693          	li	a3,16
40022830:	00810613          	addi	a2,sp,8
40022834:	00458593          	addi	a1,a1,4
40022838:	00100513          	li	a0,1
4002283c:	d9ced0ef          	jal	ra,4000fdd8 <z_impl_net_addr_ntop>
		PR("dns: %s\n", addr);
40022840:	4002f637          	lui	a2,0x4002f
40022844:	00810693          	addi	a3,sp,8
40022848:	00040513          	mv	a0,s0
4002284c:	ab860613          	addi	a2,a2,-1352 # 4002eab8 <CSWTCH.14405+0x14dc>
40022850:	00800593          	li	a1,8
40022854:	c5ce30ef          	jal	ra,40005cb0 <shell_fprintf>
}
40022858:	03c12083          	lw	ra,60(sp)
4002285c:	03812403          	lw	s0,56(sp)
40022860:	04010113          	addi	sp,sp,64
40022864:	00008067          	ret
		} else if (info->ai_family == AF_INET6) {
40022868:	00200713          	li	a4,2
4002286c:	00e79c63          	bne	a5,a4,40022884 <dns_result_cb+0x9c>
40022870:	02800693          	li	a3,40
40022874:	00810613          	addi	a2,sp,8
40022878:	00458593          	addi	a1,a1,4
4002287c:	00200513          	li	a0,2
40022880:	fbdff06f          	j	4002283c <dns_result_cb+0x54>
			strncpy(addr, "Invalid protocol family",
40022884:	4002f5b7          	lui	a1,0x4002f
40022888:	02800613          	li	a2,40
4002288c:	aa058593          	addi	a1,a1,-1376 # 4002eaa0 <CSWTCH.14405+0x14c4>
40022890:	00810513          	addi	a0,sp,8
40022894:	e10e60ef          	jal	ra,40008ea4 <strncpy>
			addr[sizeof(addr) - 1] = 0;
40022898:	020107a3          	sb	zero,47(sp)
4002289c:	fa5ff06f          	j	40022840 <dns_result_cb+0x58>
	if (status == DNS_EAI_ALLDONE) {
400228a0:	f9900793          	li	a5,-103
400228a4:	02f51263          	bne	a0,a5,400228c8 <dns_result_cb+0xe0>
		PR("dns: All results received\n");
400228a8:	4002f637          	lui	a2,0x4002f
400228ac:	ac460613          	addi	a2,a2,-1340 # 4002eac4 <CSWTCH.14405+0x14e8>
400228b0:	00800593          	li	a1,8
400228b4:	00040513          	mv	a0,s0
}
400228b8:	03812403          	lw	s0,56(sp)
400228bc:	03c12083          	lw	ra,60(sp)
400228c0:	04010113          	addi	sp,sp,64
		PR("dns: All results received\n");
400228c4:	bece306f          	j	40005cb0 <shell_fprintf>
	if (status == DNS_EAI_FAIL) {
400228c8:	ffc00793          	li	a5,-4
400228cc:	00f51863          	bne	a0,a5,400228dc <dns_result_cb+0xf4>
		PR_WARNING("dns: No such name found.\n");
400228d0:	4002f637          	lui	a2,0x4002f
400228d4:	ae060613          	addi	a2,a2,-1312 # 4002eae0 <CSWTCH.14405+0x1504>
400228d8:	f31ff06f          	j	40022808 <dns_result_cb+0x20>
	PR_WARNING("dns: Unhandled status %d received\n", status);
400228dc:	00040513          	mv	a0,s0
}
400228e0:	03812403          	lw	s0,56(sp)
400228e4:	03c12083          	lw	ra,60(sp)
	PR_WARNING("dns: Unhandled status %d received\n", status);
400228e8:	4002f637          	lui	a2,0x4002f
400228ec:	afc60613          	addi	a2,a2,-1284 # 4002eafc <CSWTCH.14405+0x1520>
400228f0:	00300593          	li	a1,3
}
400228f4:	04010113          	addi	sp,sp,64
	PR_WARNING("dns: Unhandled status %d received\n", status);
400228f8:	bb8e306f          	j	40005cb0 <shell_fprintf>

400228fc <cmd_net_tcp_connect>:
{
400228fc:	fa010113          	addi	sp,sp,-96
40022900:	05312623          	sw	s3,76(sp)
	if (tcp_ctx && net_context_is_used(tcp_ctx)) {
40022904:	400319b7          	lui	s3,0x40031
40022908:	ae09a783          	lw	a5,-1312(s3) # 40030ae0 <tcp_ctx>
{
4002290c:	04812c23          	sw	s0,88(sp)
40022910:	05212823          	sw	s2,80(sp)
40022914:	04112e23          	sw	ra,92(sp)
40022918:	04912a23          	sw	s1,84(sp)
4002291c:	05412423          	sw	s4,72(sp)
40022920:	00050413          	mv	s0,a0
40022924:	00060913          	mv	s2,a2
	if (tcp_ctx && net_context_is_used(tcp_ctx)) {
40022928:	04078263          	beqz	a5,4002296c <cmd_net_tcp_connect+0x70>
	return context->flags & NET_CONTEXT_IN_USE;
4002292c:	0747d783          	lhu	a5,116(a5)
40022930:	0017f793          	andi	a5,a5,1
40022934:	02078c63          	beqz	a5,4002296c <cmd_net_tcp_connect+0x70>
		PR("Already connected\n");
40022938:	4002f637          	lui	a2,0x4002f
4002293c:	b2060613          	addi	a2,a2,-1248 # 4002eb20 <CSWTCH.14405+0x1544>
40022940:	00800593          	li	a1,8
		PR_WARNING("Peer IP address missing.\n");
40022944:	b6ce30ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
40022948:	ff800513          	li	a0,-8
}
4002294c:	05c12083          	lw	ra,92(sp)
40022950:	05812403          	lw	s0,88(sp)
40022954:	05412483          	lw	s1,84(sp)
40022958:	05012903          	lw	s2,80(sp)
4002295c:	04c12983          	lw	s3,76(sp)
40022960:	04812a03          	lw	s4,72(sp)
40022964:	06010113          	addi	sp,sp,96
40022968:	00008067          	ret
	if (!argv[++arg]) {
4002296c:	00492a03          	lw	s4,4(s2)
40022970:	000a1c63          	bnez	s4,40022988 <cmd_net_tcp_connect+0x8c>
		PR_WARNING("Peer IP address missing.\n");
40022974:	4002f637          	lui	a2,0x4002f
40022978:	b3460613          	addi	a2,a2,-1228 # 4002eb34 <CSWTCH.14405+0x1558>
4002297c:	00300593          	li	a1,3
40022980:	00040513          	mv	a0,s0
40022984:	fc1ff06f          	j	40022944 <cmd_net_tcp_connect+0x48>
	if (!argv[++arg]) {
40022988:	00892503          	lw	a0,8(s2)
4002298c:	00051863          	bnez	a0,4002299c <cmd_net_tcp_connect+0xa0>
		PR_WARNING("Peer port missing.\n");
40022990:	4002f637          	lui	a2,0x4002f
40022994:	b5060613          	addi	a2,a2,-1200 # 4002eb50 <CSWTCH.14405+0x1574>
40022998:	fe5ff06f          	j	4002297c <cmd_net_tcp_connect+0x80>
	port = strtol(argv[arg], &endptr, 10);
4002299c:	00a00613          	li	a2,10
400229a0:	00c10593          	addi	a1,sp,12
400229a4:	934e60ef          	jal	ra,40008ad8 <strtol>
	if (*endptr != '\0') {
400229a8:	00c12783          	lw	a5,12(sp)
	port = strtol(argv[arg], &endptr, 10);
400229ac:	01051493          	slli	s1,a0,0x10
400229b0:	0104d493          	srli	s1,s1,0x10
	if (*endptr != '\0') {
400229b4:	0007c783          	lbu	a5,0(a5)
400229b8:	02078063          	beqz	a5,400229d8 <cmd_net_tcp_connect+0xdc>
		PR_WARNING("Invalid port %s\n", argv[arg]);
400229bc:	00892683          	lw	a3,8(s2)
400229c0:	4002f637          	lui	a2,0x4002f
400229c4:	b6460613          	addi	a2,a2,-1180 # 4002eb64 <CSWTCH.14405+0x1588>
400229c8:	00300593          	li	a1,3
400229cc:	00040513          	mv	a0,s0
400229d0:	ae0e30ef          	jal	ra,40005cb0 <shell_fprintf>
		return -ENOEXEC;
400229d4:	f75ff06f          	j	40022948 <cmd_net_tcp_connect+0x4c>
	struct net_if *iface = net_if_get_default();
400229d8:	9e4ea0ef          	jal	ra,4000cbbc <net_if_get_default>
400229dc:	00050913          	mv	s2,a0
		ret = net_addr_pton(AF_INET6, host,
400229e0:	02c10613          	addi	a2,sp,44
400229e4:	000a0593          	mv	a1,s4
400229e8:	00200513          	li	a0,2
400229ec:	eddfc0ef          	jal	ra,4001f8c8 <net_addr_pton>
		if (ret < 0) {
400229f0:	10055a63          	bgez	a0,40022b04 <cmd_net_tcp_connect+0x208>
			ret = net_addr_pton(AF_INET, host,
400229f4:	02c10613          	addi	a2,sp,44
400229f8:	000a0593          	mv	a1,s4
400229fc:	00100513          	li	a0,1
40022a00:	ec9fc0ef          	jal	ra,4001f8c8 <net_addr_pton>
			if (ret < 0) {
40022a04:	02055063          	bgez	a0,40022a24 <cmd_net_tcp_connect+0x128>
				PR_WARNING("Invalid IP address\n");
40022a08:	4002f637          	lui	a2,0x4002f
40022a0c:	92c60613          	addi	a2,a2,-1748 # 4002e92c <CSWTCH.14405+0x1350>
40022a10:	00300593          	li	a1,3
40022a14:	00040513          	mv	a0,s0
40022a18:	a98e30ef          	jal	ra,40005cb0 <shell_fprintf>
	return 0;
40022a1c:	00000513          	li	a0,0
40022a20:	f2dff06f          	j	4002294c <cmd_net_tcp_connect+0x50>
	       &iface->config.ip.ipv4->unicast[0].address.in_addr,
40022a24:	00892583          	lw	a1,8(s2)
			net_sin(&addr)->sin_port = htons(port);
40022a28:	00849793          	slli	a5,s1,0x8
40022a2c:	0084d493          	srli	s1,s1,0x8
40022a30:	0097e7b3          	or	a5,a5,s1
	memcpy(&net_sin(myaddr)->sin_addr,
40022a34:	00400613          	li	a2,4
40022a38:	00458593          	addi	a1,a1,4
40022a3c:	01410513          	addi	a0,sp,20
			net_sin(&addr)->sin_port = htons(port);
40022a40:	02f11523          	sh	a5,42(sp)
	memcpy(&net_sin(myaddr)->sin_addr,
40022a44:	e08e60ef          	jal	ra,4000904c <memcpy>
			family = addr.sa_family = myaddr.sa_family = AF_INET;
40022a48:	00100793          	li	a5,1
			PR("Connecting from %s:%u ",
40022a4c:	01410593          	addi	a1,sp,20
40022a50:	00100513          	li	a0,1
			family = addr.sa_family = myaddr.sa_family = AF_INET;
40022a54:	00f12823          	sw	a5,16(sp)
40022a58:	02f11423          	sh	a5,40(sp)
			PR("Connecting from %s:%u ",
40022a5c:	ebced0ef          	jal	ra,40010118 <net_sprint_addr>
40022a60:	01215783          	lhu	a5,18(sp)
40022a64:	4002f637          	lui	a2,0x4002f
40022a68:	00050693          	mv	a3,a0
40022a6c:	00879713          	slli	a4,a5,0x8
40022a70:	0087d793          	srli	a5,a5,0x8
40022a74:	00f76733          	or	a4,a4,a5
40022a78:	01071713          	slli	a4,a4,0x10
40022a7c:	01075713          	srli	a4,a4,0x10
40022a80:	b7860613          	addi	a2,a2,-1160 # 4002eb78 <CSWTCH.14405+0x159c>
40022a84:	00800593          	li	a1,8
40022a88:	00040513          	mv	a0,s0
40022a8c:	a24e30ef          	jal	ra,40005cb0 <shell_fprintf>
			PR("to %s:%u\n",
40022a90:	02c10593          	addi	a1,sp,44
40022a94:	00100513          	li	a0,1
40022a98:	e80ed0ef          	jal	ra,40010118 <net_sprint_addr>
40022a9c:	02a15783          	lhu	a5,42(sp)
40022aa0:	4002f637          	lui	a2,0x4002f
40022aa4:	00050693          	mv	a3,a0
40022aa8:	00879713          	slli	a4,a5,0x8
40022aac:	0087d793          	srli	a5,a5,0x8
40022ab0:	00f76733          	or	a4,a4,a5
40022ab4:	01071713          	slli	a4,a4,0x10
40022ab8:	00040513          	mv	a0,s0
40022abc:	01075713          	srli	a4,a4,0x10
40022ac0:	b9060613          	addi	a2,a2,-1136 # 4002eb90 <CSWTCH.14405+0x15b4>
40022ac4:	00800593          	li	a1,8
40022ac8:	9e8e30ef          	jal	ra,40005cb0 <shell_fprintf>
			addrlen = sizeof(struct sockaddr_in);
40022acc:	00800493          	li	s1,8
			family = addr.sa_family = myaddr.sa_family = AF_INET;
40022ad0:	00100513          	li	a0,1
	ret = net_context_get(family, SOCK_STREAM, IPPROTO_TCP, ctx);
40022ad4:	ae098693          	addi	a3,s3,-1312
40022ad8:	00600613          	li	a2,6
40022adc:	00100593          	li	a1,1
40022ae0:	a01ee0ef          	jal	ra,400114e0 <net_context_get>
40022ae4:	00050693          	mv	a3,a0
	if (ret < 0) {
40022ae8:	0e055663          	bgez	a0,40022bd4 <cmd_net_tcp_connect+0x2d8>
		PR_WARNING("Cannot get TCP context (%d)\n", ret);
40022aec:	4002f637          	lui	a2,0x4002f
40022af0:	bc460613          	addi	a2,a2,-1084 # 4002ebc4 <CSWTCH.14405+0x15e8>
		PR_WARNING("Cannot bind TCP (%d)\n", ret);
40022af4:	00300593          	li	a1,3
40022af8:	00040513          	mv	a0,s0
40022afc:	9b4e30ef          	jal	ra,40005cb0 <shell_fprintf>
		return;
40022b00:	f1dff06f          	j	40022a1c <cmd_net_tcp_connect+0x120>
			net_sin6(&addr)->sin6_port = htons(port);
40022b04:	00849793          	slli	a5,s1,0x8
40022b08:	0084d493          	srli	s1,s1,0x8
40022b0c:	0097e7b3          	or	a5,a5,s1
			nbr = net_ipv6_nbr_lookup(NULL,
40022b10:	02c10593          	addi	a1,sp,44
40022b14:	00000513          	li	a0,0
			net_sin6(&addr)->sin6_port = htons(port);
40022b18:	02f11523          	sh	a5,42(sp)
			nbr = net_ipv6_nbr_lookup(NULL,
40022b1c:	898f50ef          	jal	ra,40017bb4 <net_ipv6_nbr_lookup>
			if (nbr) {
40022b20:	00050463          	beqz	a0,40022b28 <cmd_net_tcp_connect+0x22c>
				iface = nbr->iface;
40022b24:	00852903          	lw	s2,8(a0)
	my6addr = net_if_ipv6_select_src_addr(iface,
40022b28:	01410593          	addi	a1,sp,20
40022b2c:	00090513          	mv	a0,s2
40022b30:	cb5eb0ef          	jal	ra,4000e7e4 <net_if_ipv6_select_src_addr>
40022b34:	00050593          	mv	a1,a0
	memcpy(&net_sin6(myaddr)->sin6_addr, my6addr, sizeof(struct in6_addr));
40022b38:	01000613          	li	a2,16
40022b3c:	01410513          	addi	a0,sp,20
40022b40:	d0ce60ef          	jal	ra,4000904c <memcpy>
			family = addr.sa_family = myaddr.sa_family = AF_INET6;
40022b44:	00200793          	li	a5,2
			PR("Connecting from [%s]:%u ",
40022b48:	01410593          	addi	a1,sp,20
40022b4c:	00200513          	li	a0,2
			family = addr.sa_family = myaddr.sa_family = AF_INET6;
40022b50:	00f12823          	sw	a5,16(sp)
40022b54:	02f11423          	sh	a5,40(sp)
			PR("Connecting from [%s]:%u ",
40022b58:	dc0ed0ef          	jal	ra,40010118 <net_sprint_addr>
40022b5c:	01215783          	lhu	a5,18(sp)
40022b60:	4002f637          	lui	a2,0x4002f
40022b64:	00050693          	mv	a3,a0
40022b68:	00879713          	slli	a4,a5,0x8
40022b6c:	0087d793          	srli	a5,a5,0x8
40022b70:	00f76733          	or	a4,a4,a5
40022b74:	01071713          	slli	a4,a4,0x10
40022b78:	01075713          	srli	a4,a4,0x10
40022b7c:	b9c60613          	addi	a2,a2,-1124 # 4002eb9c <CSWTCH.14405+0x15c0>
40022b80:	00800593          	li	a1,8
40022b84:	00040513          	mv	a0,s0
40022b88:	928e30ef          	jal	ra,40005cb0 <shell_fprintf>
			PR("to [%s]:%u\n",
40022b8c:	02c10593          	addi	a1,sp,44
40022b90:	00200513          	li	a0,2
40022b94:	d84ed0ef          	jal	ra,40010118 <net_sprint_addr>
40022b98:	02a15783          	lhu	a5,42(sp)
40022b9c:	4002f637          	lui	a2,0x4002f
40022ba0:	00050693          	mv	a3,a0
40022ba4:	00879713          	slli	a4,a5,0x8
40022ba8:	0087d793          	srli	a5,a5,0x8
40022bac:	00f76733          	or	a4,a4,a5
40022bb0:	01071713          	slli	a4,a4,0x10
40022bb4:	00040513          	mv	a0,s0
40022bb8:	01075713          	srli	a4,a4,0x10
40022bbc:	bb860613          	addi	a2,a2,-1096 # 4002ebb8 <CSWTCH.14405+0x15dc>
40022bc0:	00800593          	li	a1,8
40022bc4:	8ece30ef          	jal	ra,40005cb0 <shell_fprintf>
			addrlen = sizeof(struct sockaddr_in6);
40022bc8:	01800493          	li	s1,24
			family = addr.sa_family = myaddr.sa_family = AF_INET6;
40022bcc:	00200513          	li	a0,2
		break;
40022bd0:	f05ff06f          	j	40022ad4 <cmd_net_tcp_connect+0x1d8>
	ret = net_context_bind(*ctx, &myaddr, addrlen);
40022bd4:	ae09a503          	lw	a0,-1312(s3)
40022bd8:	00048613          	mv	a2,s1
40022bdc:	01010593          	addi	a1,sp,16
40022be0:	c69ee0ef          	jal	ra,40011848 <net_context_bind>
40022be4:	00050693          	mv	a3,a0
	if (ret < 0) {
40022be8:	00055863          	bgez	a0,40022bf8 <cmd_net_tcp_connect+0x2fc>
		PR_WARNING("Cannot bind TCP (%d)\n", ret);
40022bec:	4002f637          	lui	a2,0x4002f
40022bf0:	be460613          	addi	a2,a2,-1052 # 4002ebe4 <CSWTCH.14405+0x1608>
40022bf4:	f01ff06f          	j	40022af4 <cmd_net_tcp_connect+0x1f8>
	net_context_connect(*ctx, &addr, addrlen, tcp_connected,
40022bf8:	ae09a503          	lw	a0,-1312(s3)
	tcp_shell = sh;
40022bfc:	400317b7          	lui	a5,0x40031
	net_context_connect(*ctx, &addr, addrlen, tcp_connected,
40022c00:	400216b7          	lui	a3,0x40021
	tcp_shell = sh;
40022c04:	ac87ae23          	sw	s0,-1316(a5) # 40030adc <tcp_shell>
	net_context_connect(*ctx, &addr, addrlen, tcp_connected,
40022c08:	00000813          	li	a6,0
40022c0c:	12c00713          	li	a4,300
40022c10:	00000793          	li	a5,0
40022c14:	e5468693          	addi	a3,a3,-428 # 40020e54 <tcp_connected>
40022c18:	00048613          	mv	a2,s1
40022c1c:	02810593          	addi	a1,sp,40
40022c20:	d8cef0ef          	jal	ra,400121ac <net_context_connect>
40022c24:	df9ff06f          	j	40022a1c <cmd_net_tcp_connect+0x120>

40022c28 <address_lifetime_cb>:
{
40022c28:	fb010113          	addi	sp,sp,-80
40022c2c:	04112623          	sw	ra,76(sp)
40022c30:	04912223          	sw	s1,68(sp)
40022c34:	04812423          	sw	s0,72(sp)
40022c38:	05212023          	sw	s2,64(sp)
40022c3c:	03312e23          	sw	s3,60(sp)
40022c40:	03412c23          	sw	s4,56(sp)
40022c44:	03512a23          	sw	s5,52(sp)
40022c48:	03612823          	sw	s6,48(sp)
40022c4c:	03712623          	sw	s7,44(sp)
40022c50:	03812423          	sw	s8,40(sp)
40022c54:	03912223          	sw	s9,36(sp)
	const struct shell *sh = data->sh;
40022c58:	0005a983          	lw	s3,0(a1)
{
40022c5c:	00050493          	mv	s1,a0
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
40022c60:	00452a03          	lw	s4,4(a0)
	PR("\nIPv6 addresses for interface %d (%p) (%s)\n",
40022c64:	97dec0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
40022c68:	00a12423          	sw	a0,8(sp)
40022c6c:	01010593          	addi	a1,sp,16
40022c70:	00048513          	mv	a0,s1
40022c74:	e9dfe0ef          	jal	ra,40021b10 <iface2str>
40022c78:	00812683          	lw	a3,8(sp)
40022c7c:	4002f637          	lui	a2,0x4002f
40022c80:	00050793          	mv	a5,a0
40022c84:	bfc60613          	addi	a2,a2,-1028 # 4002ebfc <CSWTCH.14405+0x1620>
40022c88:	00800593          	li	a1,8
40022c8c:	00098513          	mv	a0,s3
40022c90:	00048713          	mv	a4,s1
40022c94:	81ce30ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("============================================%s\n", extra);
40022c98:	01012683          	lw	a3,16(sp)
40022c9c:	4002e637          	lui	a2,0x4002e
40022ca0:	7e060613          	addi	a2,a2,2016 # 4002e7e0 <CSWTCH.14405+0x1204>
40022ca4:	00800593          	li	a1,8
40022ca8:	00098513          	mv	a0,s3
40022cac:	804e30ef          	jal	ra,40005cb0 <shell_fprintf>
	if (!ipv6) {
40022cb0:	040a1463          	bnez	s4,40022cf8 <address_lifetime_cb+0xd0>
}
40022cb4:	04812403          	lw	s0,72(sp)
40022cb8:	04c12083          	lw	ra,76(sp)
40022cbc:	04412483          	lw	s1,68(sp)
40022cc0:	04012903          	lw	s2,64(sp)
40022cc4:	03812a03          	lw	s4,56(sp)
40022cc8:	03412a83          	lw	s5,52(sp)
40022ccc:	03012b03          	lw	s6,48(sp)
40022cd0:	02c12b83          	lw	s7,44(sp)
40022cd4:	02812c03          	lw	s8,40(sp)
40022cd8:	02412c83          	lw	s9,36(sp)
		PR("No IPv6 config found for this interface.\n");
40022cdc:	00098513          	mv	a0,s3
}
40022ce0:	03c12983          	lw	s3,60(sp)
		PR("No IPv6 config found for this interface.\n");
40022ce4:	4002f637          	lui	a2,0x4002f
40022ce8:	c2860613          	addi	a2,a2,-984 # 4002ec28 <CSWTCH.14405+0x164c>
40022cec:	00800593          	li	a1,8
}
40022cf0:	05010113          	addi	sp,sp,80
		PR("No IPv6 config found for this interface.\n");
40022cf4:	fbde206f          	j	40005cb0 <shell_fprintf>
	PR("Type      \tState    \tLifetime (sec)\tAddress\n");
40022cf8:	4002f637          	lui	a2,0x4002f
40022cfc:	83c60613          	addi	a2,a2,-1988 # 4002e83c <CSWTCH.14405+0x1260>
40022d00:	00800593          	li	a1,8
40022d04:	00098513          	mv	a0,s3
40022d08:	fa9e20ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40022d0c:	004a0413          	addi	s0,s4,4
40022d10:	00000913          	li	s2,0
		if (!ipv6->unicast[i].is_used ||
40022d14:	03000b93          	li	s7,48
40022d18:	00200c13          	li	s8,2
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40022d1c:	00300b13          	li	s6,3
		if (!ipv6->unicast[i].is_used ||
40022d20:	037907b3          	mul	a5,s2,s7
40022d24:	00fa07b3          	add	a5,s4,a5
40022d28:	02c7a783          	lw	a5,44(a5)
40022d2c:	0197d793          	srli	a5,a5,0x19
40022d30:	0017f793          	andi	a5,a5,1
40022d34:	0e078663          	beqz	a5,40022e20 <address_lifetime_cb+0x1f8>
40022d38:	ffc45783          	lhu	a5,-4(s0)
40022d3c:	0f879263          	bne	a5,s8,40022e20 <address_lifetime_cb+0x1f8>
40022d40:	675070ef          	jal	ra,4002abb4 <z_impl_k_uptime_ticks>
		remaining = net_timeout_remaining(&ipv6->unicast[i].lifetime,
40022d44:	00a00593          	li	a1,10
40022d48:	02a585b3          	mul	a1,a1,a0
40022d4c:	01040513          	addi	a0,s0,16
			prefix_len = 128U;
40022d50:	08000a93          	li	s5,128
		remaining = net_timeout_remaining(&ipv6->unicast[i].lifetime,
40022d54:	dc1ec0ef          	jal	ra,4000fb14 <net_timeout_remaining>
40022d58:	00050c93          	mv	s9,a0
		prefix = net_if_ipv6_prefix_get(iface,
40022d5c:	00040593          	mv	a1,s0
40022d60:	00048513          	mv	a0,s1
40022d64:	c1ceb0ef          	jal	ra,4000e180 <net_if_ipv6_prefix_get>
		if (prefix) {
40022d68:	00050463          	beqz	a0,40022d70 <address_lifetime_cb+0x148>
			prefix_len = prefix->len;
40022d6c:	02454a83          	lbu	s5,36(a0)
		if (ipv6->unicast[i].is_infinite) {
40022d70:	03000793          	li	a5,48
40022d74:	02f907b3          	mul	a5,s2,a5
40022d78:	00fa07b3          	add	a5,s4,a5
40022d7c:	02f7c783          	lbu	a5,47(a5)
40022d80:	0017f793          	andi	a5,a5,1
40022d84:	0c078e63          	beqz	a5,40022e60 <address_lifetime_cb+0x238>
			snprintk(remaining_str, sizeof(remaining_str) - 1,
40022d88:	4002f637          	lui	a2,0x4002f
40022d8c:	9c460613          	addi	a2,a2,-1596 # 4002e9c4 <CSWTCH.14405+0x13e8>
40022d90:	00b00593          	li	a1,11
40022d94:	01410513          	addi	a0,sp,20
40022d98:	a30de0ef          	jal	ra,40000fc8 <snprintk>
		PR("%s  \t%s\t%s    \t%s/%d\n",
40022d9c:	02844703          	lbu	a4,40(s0)
	switch (addr_type) {
40022da0:	00400793          	li	a5,4
40022da4:	0ee7e663          	bltu	a5,a4,40022e90 <address_lifetime_cb+0x268>
40022da8:	400307b7          	lui	a5,0x40030
40022dac:	00271713          	slli	a4,a4,0x2
40022db0:	09c78793          	addi	a5,a5,156 # 4003009c <CSWTCH.188>
40022db4:	00e787b3          	add	a5,a5,a4
40022db8:	0007a683          	lw	a3,0(a5)
	switch (addr_state) {
40022dbc:	02944783          	lbu	a5,41(s0)
40022dc0:	00300713          	li	a4,3
40022dc4:	00178793          	addi	a5,a5,1
40022dc8:	0ff7f793          	zext.b	a5,a5
40022dcc:	0cf76863          	bltu	a4,a5,40022e9c <address_lifetime_cb+0x274>
40022dd0:	40030737          	lui	a4,0x40030
40022dd4:	08c70713          	addi	a4,a4,140 # 4003008c <CSWTCH.190>
40022dd8:	00279793          	slli	a5,a5,0x2
40022ddc:	00f707b3          	add	a5,a4,a5
40022de0:	0007a703          	lw	a4,0(a5)
		PR("%s  \t%s\t%s    \t%s/%d\n",
40022de4:	00040593          	mv	a1,s0
40022de8:	00200513          	li	a0,2
40022dec:	00d12623          	sw	a3,12(sp)
40022df0:	00e12423          	sw	a4,8(sp)
40022df4:	b24ed0ef          	jal	ra,40010118 <net_sprint_addr>
40022df8:	00812703          	lw	a4,8(sp)
40022dfc:	00c12683          	lw	a3,12(sp)
40022e00:	4002f637          	lui	a2,0x4002f
40022e04:	00050813          	mv	a6,a0
40022e08:	000a8893          	mv	a7,s5
40022e0c:	01410793          	addi	a5,sp,20
40022e10:	c5860613          	addi	a2,a2,-936 # 4002ec58 <CSWTCH.14405+0x167c>
40022e14:	00800593          	li	a1,8
40022e18:	00098513          	mv	a0,s3
40022e1c:	e95e20ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; i < NET_IF_MAX_IPV6_ADDR; i++) {
40022e20:	00190913          	addi	s2,s2,1
40022e24:	03040413          	addi	s0,s0,48
40022e28:	ef691ce3          	bne	s2,s6,40022d20 <address_lifetime_cb+0xf8>
}
40022e2c:	04c12083          	lw	ra,76(sp)
40022e30:	04812403          	lw	s0,72(sp)
40022e34:	04412483          	lw	s1,68(sp)
40022e38:	04012903          	lw	s2,64(sp)
40022e3c:	03c12983          	lw	s3,60(sp)
40022e40:	03812a03          	lw	s4,56(sp)
40022e44:	03412a83          	lw	s5,52(sp)
40022e48:	03012b03          	lw	s6,48(sp)
40022e4c:	02c12b83          	lw	s7,44(sp)
40022e50:	02812c03          	lw	s8,40(sp)
40022e54:	02412c83          	lw	s9,36(sp)
40022e58:	05010113          	addi	sp,sp,80
40022e5c:	00008067          	ret
				 "%u", (uint32_t)(remaining / 1000U));
40022e60:	3e800613          	li	a2,1000
40022e64:	00000693          	li	a3,0
40022e68:	000c8513          	mv	a0,s9
40022e6c:	00000593          	li	a1,0
40022e70:	c48dd0ef          	jal	ra,400002b8 <__udivdi3>
			snprintk(remaining_str, sizeof(remaining_str) - 1,
40022e74:	4002f637          	lui	a2,0x4002f
				 "%u", (uint32_t)(remaining / 1000U));
40022e78:	00050693          	mv	a3,a0
			snprintk(remaining_str, sizeof(remaining_str) - 1,
40022e7c:	c5460613          	addi	a2,a2,-940 # 4002ec54 <CSWTCH.14405+0x1678>
40022e80:	00b00593          	li	a1,11
40022e84:	01410513          	addi	a0,sp,20
40022e88:	940de0ef          	jal	ra,40000fc8 <snprintk>
40022e8c:	f11ff06f          	j	40022d9c <address_lifetime_cb+0x174>
		PR("%s  \t%s\t%s    \t%s/%d\n",
40022e90:	4002e6b7          	lui	a3,0x4002e
40022e94:	7a468693          	addi	a3,a3,1956 # 4002e7a4 <CSWTCH.14405+0x11c8>
40022e98:	f25ff06f          	j	40022dbc <address_lifetime_cb+0x194>
	switch (addr_state) {
40022e9c:	4002d737          	lui	a4,0x4002d
40022ea0:	3ec70713          	addi	a4,a4,1004 # 4002d3ec <all_nodes_mcast_group.0+0x1c>
40022ea4:	f41ff06f          	j	40022de4 <address_lifetime_cb+0x1bc>

40022ea8 <iface_cb>:
{
40022ea8:	fa010113          	addi	sp,sp,-96
40022eac:	04912a23          	sw	s1,84(sp)
40022eb0:	05212823          	sw	s2,80(sp)
40022eb4:	04112e23          	sw	ra,92(sp)
40022eb8:	04812c23          	sw	s0,88(sp)
40022ebc:	05312623          	sw	s3,76(sp)
40022ec0:	05412423          	sw	s4,72(sp)
40022ec4:	05512223          	sw	s5,68(sp)
40022ec8:	05612023          	sw	s6,64(sp)
40022ecc:	03712e23          	sw	s7,60(sp)
40022ed0:	03812c23          	sw	s8,56(sp)
40022ed4:	03912a23          	sw	s9,52(sp)
40022ed8:	03a12823          	sw	s10,48(sp)
40022edc:	03b12623          	sw	s11,44(sp)
	const struct shell *sh = data->sh;
40022ee0:	0005a783          	lw	a5,0(a1)
{
40022ee4:	00050913          	mv	s2,a0
40022ee8:	00058493          	mv	s1,a1
	const struct shell *sh = data->sh;
40022eec:	00f12423          	sw	a5,8(sp)
	if (data->user_data && data->user_data != iface) {
40022ef0:	0045a783          	lw	a5,4(a1)
40022ef4:	00078463          	beqz	a5,40022efc <iface_cb+0x54>
40022ef8:	2ca79e63          	bne	a5,a0,400231d4 <iface_cb+0x32c>
	PR("\nInterface %p (%s) [%d]\n", iface, iface2str(iface, &extra),
40022efc:	01c10593          	addi	a1,sp,28
40022f00:	00090513          	mv	a0,s2
40022f04:	c0dfe0ef          	jal	ra,40021b10 <iface2str>
40022f08:	00a12623          	sw	a0,12(sp)
40022f0c:	00090513          	mv	a0,s2
40022f10:	ed0ec0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
40022f14:	00050793          	mv	a5,a0
40022f18:	00c12703          	lw	a4,12(sp)
40022f1c:	00812503          	lw	a0,8(sp)
40022f20:	4002f637          	lui	a2,0x4002f
40022f24:	00090693          	mv	a3,s2
40022f28:	c8860613          	addi	a2,a2,-888 # 4002ec88 <CSWTCH.14405+0x16ac>
40022f2c:	00800593          	li	a1,8
40022f30:	d81e20ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("===========================%s\n", extra);
40022f34:	00812503          	lw	a0,8(sp)
40022f38:	01c12683          	lw	a3,28(sp)
40022f3c:	4002f637          	lui	a2,0x4002f
40022f40:	ca460613          	addi	a2,a2,-860 # 4002eca4 <CSWTCH.14405+0x16c8>
40022f44:	00800593          	li	a1,8
40022f48:	d69e20ef          	jal	ra,40005cb0 <shell_fprintf>
	if (!net_if_is_up(iface)) {
40022f4c:	00090513          	mv	a0,s2
40022f50:	dfcfe0ef          	jal	ra,4002154c <net_if_is_up>
40022f54:	26050263          	beqz	a0,400231b8 <iface_cb+0x310>
	return &iface->if_dev->link_addr;
40022f58:	00092783          	lw	a5,0(s2)
	    net_if_get_link_addr(iface)->addr) {
40022f5c:	0107a503          	lw	a0,16(a5)
	if (net_if_get_link_addr(iface) &&
40022f60:	2a051863          	bnez	a0,40023210 <iface_cb+0x368>
	return iface->if_dev->mtu;
40022f64:	00092783          	lw	a5,0(s2)
	PR("MTU       : %d\n", net_if_get_mtu(iface));
40022f68:	00812503          	lw	a0,8(sp)
40022f6c:	4002f637          	lui	a2,0x4002f
40022f70:	0187d683          	lhu	a3,24(a5)
40022f74:	ce860613          	addi	a2,a2,-792 # 4002ece8 <CSWTCH.14405+0x170c>
40022f78:	00800593          	li	a1,8
40022f7c:	d35e20ef          	jal	ra,40005cb0 <shell_fprintf>
	if (net_if_flag_is_set(iface, NET_IF_POINTOPOINT)) {
40022f80:	00100593          	li	a1,1
40022f84:	00090513          	mv	a0,s2
40022f88:	d84fe0ef          	jal	ra,4002150c <net_if_flag_is_set>
40022f8c:	40032a37          	lui	s4,0x40032
	int pos = 0;
40022f90:	00000493          	li	s1,0
	if (net_if_flag_is_set(iface, NET_IF_POINTOPOINT)) {
40022f94:	00050e63          	beqz	a0,40022fb0 <iface_cb+0x108>
		pos += snprintk(str + pos, sizeof(str) - pos,
40022f98:	4002f637          	lui	a2,0x4002f
40022f9c:	cf860613          	addi	a2,a2,-776 # 4002ecf8 <CSWTCH.14405+0x171c>
40022fa0:	05100593          	li	a1,81
40022fa4:	63ca0513          	addi	a0,s4,1596 # 4003263c <str.0>
40022fa8:	820de0ef          	jal	ra,40000fc8 <snprintk>
40022fac:	00050493          	mv	s1,a0
	if (net_if_flag_is_set(iface, NET_IF_PROMISC)) {
40022fb0:	00200593          	li	a1,2
40022fb4:	00090513          	mv	a0,s2
40022fb8:	400329b7          	lui	s3,0x40032
40022fbc:	d50fe0ef          	jal	ra,4002150c <net_if_flag_is_set>
40022fc0:	63c98993          	addi	s3,s3,1596 # 4003263c <str.0>
40022fc4:	02050063          	beqz	a0,40022fe4 <iface_cb+0x13c>
		pos += snprintk(str + pos, sizeof(str) - pos,
40022fc8:	4002f637          	lui	a2,0x4002f
40022fcc:	05100593          	li	a1,81
40022fd0:	409585b3          	sub	a1,a1,s1
40022fd4:	00998533          	add	a0,s3,s1
40022fd8:	d0860613          	addi	a2,a2,-760 # 4002ed08 <CSWTCH.14405+0x172c>
40022fdc:	feddd0ef          	jal	ra,40000fc8 <snprintk>
40022fe0:	00a484b3          	add	s1,s1,a0
	if (net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
40022fe4:	00300593          	li	a1,3
40022fe8:	00090513          	mv	a0,s2
40022fec:	d20fe0ef          	jal	ra,4002150c <net_if_flag_is_set>
40022ff0:	00050793          	mv	a5,a0
		pos += snprintk(str + pos, sizeof(str) - pos,
40022ff4:	05100593          	li	a1,81
40022ff8:	00998533          	add	a0,s3,s1
40022ffc:	409585b3          	sub	a1,a1,s1
	if (net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
40023000:	24078063          	beqz	a5,40023240 <iface_cb+0x398>
		pos += snprintk(str + pos, sizeof(str) - pos,
40023004:	4002f637          	lui	a2,0x4002f
40023008:	d1460613          	addi	a2,a2,-748 # 4002ed14 <CSWTCH.14405+0x1738>
		pos += snprintk(str + pos, sizeof(str) - pos,
4002300c:	fbddd0ef          	jal	ra,40000fc8 <snprintk>
40023010:	00a484b3          	add	s1,s1,a0
	if (net_if_flag_is_set(iface, NET_IF_FORWARD_MULTICASTS)) {
40023014:	00500593          	li	a1,5
40023018:	00090513          	mv	a0,s2
4002301c:	cf0fe0ef          	jal	ra,4002150c <net_if_flag_is_set>
40023020:	02050063          	beqz	a0,40023040 <iface_cb+0x198>
		pos += snprintk(str + pos, sizeof(str) - pos,
40023024:	4002f637          	lui	a2,0x4002f
40023028:	05100593          	li	a1,81
4002302c:	409585b3          	sub	a1,a1,s1
40023030:	00998533          	add	a0,s3,s1
40023034:	d3060613          	addi	a2,a2,-720 # 4002ed30 <CSWTCH.14405+0x1754>
40023038:	f91dd0ef          	jal	ra,40000fc8 <snprintk>
4002303c:	00a484b3          	add	s1,s1,a0
	if (net_if_flag_is_set(iface, NET_IF_IPV4)) {
40023040:	00600593          	li	a1,6
40023044:	00090513          	mv	a0,s2
40023048:	cc4fe0ef          	jal	ra,4002150c <net_if_flag_is_set>
4002304c:	02050063          	beqz	a0,4002306c <iface_cb+0x1c4>
		pos += snprintk(str + pos, sizeof(str) - pos,
40023050:	4002f637          	lui	a2,0x4002f
40023054:	05100593          	li	a1,81
40023058:	409585b3          	sub	a1,a1,s1
4002305c:	00998533          	add	a0,s3,s1
40023060:	d4060613          	addi	a2,a2,-704 # 4002ed40 <CSWTCH.14405+0x1764>
40023064:	f65dd0ef          	jal	ra,40000fc8 <snprintk>
40023068:	00a484b3          	add	s1,s1,a0
	if (net_if_flag_is_set(iface, NET_IF_IPV6)) {
4002306c:	00700593          	li	a1,7
40023070:	00090513          	mv	a0,s2
40023074:	c98fe0ef          	jal	ra,4002150c <net_if_flag_is_set>
40023078:	02050063          	beqz	a0,40023098 <iface_cb+0x1f0>
		pos += snprintk(str + pos, sizeof(str) - pos,
4002307c:	4002f637          	lui	a2,0x4002f
40023080:	05100593          	li	a1,81
40023084:	409585b3          	sub	a1,a1,s1
40023088:	00998533          	add	a0,s3,s1
4002308c:	d4860613          	addi	a2,a2,-696 # 4002ed48 <CSWTCH.14405+0x176c>
40023090:	f39dd0ef          	jal	ra,40000fc8 <snprintk>
40023094:	00a484b3          	add	s1,s1,a0
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {
40023098:	00b00593          	li	a1,11
4002309c:	00090513          	mv	a0,s2
400230a0:	c6cfe0ef          	jal	ra,4002150c <net_if_flag_is_set>
400230a4:	02050063          	beqz	a0,400230c4 <iface_cb+0x21c>
		pos += snprintk(str + pos, sizeof(str) - pos,
400230a8:	4002f637          	lui	a2,0x4002f
400230ac:	05100593          	li	a1,81
400230b0:	409585b3          	sub	a1,a1,s1
400230b4:	00998533          	add	a0,s3,s1
400230b8:	d5060613          	addi	a2,a2,-688 # 4002ed50 <CSWTCH.14405+0x1774>
400230bc:	f0ddd0ef          	jal	ra,40000fc8 <snprintk>
400230c0:	00a484b3          	add	s1,s1,a0
	if (net_if_flag_is_set(iface, NET_IF_IPV6_NO_MLD)) {
400230c4:	00c00593          	li	a1,12
400230c8:	00090513          	mv	a0,s2
400230cc:	c40fe0ef          	jal	ra,4002150c <net_if_flag_is_set>
400230d0:	02050063          	beqz	a0,400230f0 <iface_cb+0x248>
		pos += snprintk(str + pos, sizeof(str) - pos,
400230d4:	4002f637          	lui	a2,0x4002f
400230d8:	05100593          	li	a1,81
400230dc:	409585b3          	sub	a1,a1,s1
400230e0:	00998533          	add	a0,s3,s1
400230e4:	d5860613          	addi	a2,a2,-680 # 4002ed58 <CSWTCH.14405+0x177c>
400230e8:	ee1dd0ef          	jal	ra,40000fc8 <snprintk>
400230ec:	00a484b3          	add	s1,s1,a0
	PR("Flags     : %s\n", iface_flags2str(iface));
400230f0:	00812503          	lw	a0,8(sp)
400230f4:	4002f637          	lui	a2,0x4002f
	str[pos - 1] = '\0';
400230f8:	009989b3          	add	s3,s3,s1
	PR("Flags     : %s\n", iface_flags2str(iface));
400230fc:	63ca0693          	addi	a3,s4,1596
40023100:	d6060613          	addi	a2,a2,-672 # 4002ed60 <CSWTCH.14405+0x1784>
40023104:	00800593          	li	a1,8
	str[pos - 1] = '\0';
40023108:	fe098fa3          	sb	zero,-1(s3)
	PR("Flags     : %s\n", iface_flags2str(iface));
4002310c:	ba5e20ef          	jal	ra,40005cb0 <shell_fprintf>
	if (!iface || !iface->if_dev) {
40023110:	00092783          	lw	a5,0(s2)
40023114:	12079c63          	bnez	a5,4002324c <iface_cb+0x3a4>
	if (!net_if_flag_is_set(iface, NET_IF_IPV6)) {
40023118:	00700593          	li	a1,7
4002311c:	00090513          	mv	a0,s2
40023120:	becfe0ef          	jal	ra,4002150c <net_if_flag_is_set>
40023124:	1a051463          	bnez	a0,400232cc <iface_cb+0x424>
		PR("%s not %s for this interface.\n", "IPv6", "enabled");
40023128:	00812503          	lw	a0,8(sp)
4002312c:	4002e737          	lui	a4,0x4002e
40023130:	4002f6b7          	lui	a3,0x4002f
40023134:	4002f637          	lui	a2,0x4002f
40023138:	98470713          	addi	a4,a4,-1660 # 4002d984 <CSWTCH.14405+0x3a8>
4002313c:	d9c68693          	addi	a3,a3,-612 # 4002ed9c <CSWTCH.14405+0x17c0>
40023140:	da460613          	addi	a2,a2,-604 # 4002eda4 <CSWTCH.14405+0x17c8>
40023144:	00800593          	li	a1,8
40023148:	b69e20ef          	jal	ra,40005cb0 <shell_fprintf>
	if (!net_if_flag_is_set(iface, NET_IF_IPV4)) {
4002314c:	00600593          	li	a1,6
40023150:	00090513          	mv	a0,s2
40023154:	bb8fe0ef          	jal	ra,4002150c <net_if_flag_is_set>
40023158:	4e051a63          	bnez	a0,4002364c <iface_cb+0x7a4>
}
4002315c:	05812403          	lw	s0,88(sp)
		PR("%s not %s for this interface.\n", "IPv4", "enabled");
40023160:	00812503          	lw	a0,8(sp)
}
40023164:	05c12083          	lw	ra,92(sp)
40023168:	05412483          	lw	s1,84(sp)
4002316c:	05012903          	lw	s2,80(sp)
40023170:	04c12983          	lw	s3,76(sp)
40023174:	04812a03          	lw	s4,72(sp)
40023178:	04412a83          	lw	s5,68(sp)
4002317c:	04012b03          	lw	s6,64(sp)
40023180:	03c12b83          	lw	s7,60(sp)
40023184:	03812c03          	lw	s8,56(sp)
40023188:	03412c83          	lw	s9,52(sp)
4002318c:	03012d03          	lw	s10,48(sp)
40023190:	02c12d83          	lw	s11,44(sp)
		PR("%s not %s for this interface.\n", "IPv4", "enabled");
40023194:	4002e737          	lui	a4,0x4002e
40023198:	4002f6b7          	lui	a3,0x4002f
4002319c:	4002f637          	lui	a2,0x4002f
400231a0:	98470713          	addi	a4,a4,-1660 # 4002d984 <CSWTCH.14405+0x3a8>
400231a4:	ee468693          	addi	a3,a3,-284 # 4002eee4 <CSWTCH.14405+0x1908>
400231a8:	da460613          	addi	a2,a2,-604 # 4002eda4 <CSWTCH.14405+0x17c8>
400231ac:	00800593          	li	a1,8
}
400231b0:	06010113          	addi	sp,sp,96
		PR("%s not %s for this interface.\n", "IPv4", "enabled");
400231b4:	afde206f          	j	40005cb0 <shell_fprintf>
		PR_INFO("Interface is down.\n");
400231b8:	00812503          	lw	a0,8(sp)
400231bc:	4002f637          	lui	a2,0x4002f
400231c0:	cc460613          	addi	a2,a2,-828 # 4002ecc4 <CSWTCH.14405+0x16e8>
400231c4:	00200593          	li	a1,2
400231c8:	ae9e20ef          	jal	ra,40005cb0 <shell_fprintf>
		if (data->user_data == NULL) {
400231cc:	0044a783          	lw	a5,4(s1)
400231d0:	d80794e3          	bnez	a5,40022f58 <iface_cb+0xb0>
}
400231d4:	05c12083          	lw	ra,92(sp)
400231d8:	05812403          	lw	s0,88(sp)
400231dc:	05412483          	lw	s1,84(sp)
400231e0:	05012903          	lw	s2,80(sp)
400231e4:	04c12983          	lw	s3,76(sp)
400231e8:	04812a03          	lw	s4,72(sp)
400231ec:	04412a83          	lw	s5,68(sp)
400231f0:	04012b03          	lw	s6,64(sp)
400231f4:	03c12b83          	lw	s7,60(sp)
400231f8:	03812c03          	lw	s8,56(sp)
400231fc:	03412c83          	lw	s9,52(sp)
40023200:	03012d03          	lw	s10,48(sp)
40023204:	02c12d83          	lw	s11,44(sp)
40023208:	06010113          	addi	sp,sp,96
4002320c:	00008067          	ret
40023210:	0147c583          	lbu	a1,20(a5)
40023214:	40032637          	lui	a2,0x40032
40023218:	01800693          	li	a3,24
4002321c:	69060613          	addi	a2,a2,1680 # 40032690 <buf.1>
40023220:	ad9ec0ef          	jal	ra,4000fcf8 <net_sprint_ll_addr_buf>
40023224:	00050693          	mv	a3,a0
		PR("Link addr : %s\n",
40023228:	00812503          	lw	a0,8(sp)
4002322c:	4002f637          	lui	a2,0x4002f
40023230:	cd860613          	addi	a2,a2,-808 # 4002ecd8 <CSWTCH.14405+0x16fc>
40023234:	00800593          	li	a1,8
40023238:	a79e20ef          	jal	ra,40005cb0 <shell_fprintf>
	if (iface == NULL) {
4002323c:	d29ff06f          	j	40022f64 <iface_cb+0xbc>
		pos += snprintk(str + pos, sizeof(str) - pos,
40023240:	4002f637          	lui	a2,0x4002f
40023244:	d2460613          	addi	a2,a2,-732 # 4002ed24 <CSWTCH.14405+0x1748>
40023248:	dc5ff06f          	j	4002300c <iface_cb+0x164>
	if (net_if_l2(iface) == &NET_L2_GET_NAME(ETHERNET)) {
4002324c:	0047a703          	lw	a4,4(a5)
40023250:	4003d7b7          	lui	a5,0x4003d
40023254:	c6478793          	addi	a5,a5,-924 # 4003cc64 <_net_l2_ETHERNET>
40023258:	ecf710e3          	bne	a4,a5,40023118 <iface_cb+0x270>
		PR("Ethernet capabilities supported:\n");
4002325c:	00812503          	lw	a0,8(sp)
40023260:	4002f637          	lui	a2,0x4002f
40023264:	d7060613          	addi	a2,a2,-656 # 4002ed70 <CSWTCH.14405+0x1794>
40023268:	00800593          	li	a1,8
4002326c:	a45e20ef          	jal	ra,40005cb0 <shell_fprintf>
	return iface->if_dev->dev;
40023270:	00092783          	lw	a5,0(s2)
		return (enum ethernet_hw_caps)0;
40023274:	00000993          	li	s3,0
40023278:	0007a503          	lw	a0,0(a5)
	if (!eth->get_capabilities) {
4002327c:	00852783          	lw	a5,8(a0)
40023280:	00c7a783          	lw	a5,12(a5)
40023284:	00078663          	beqz	a5,40023290 <iface_cb+0x3e8>
	return eth->get_capabilities(net_if_get_device(iface));
40023288:	000780e7          	jalr	a5
4002328c:	00050993          	mv	s3,a0
	for (i = 0; i < ARRAY_SIZE(eth_hw_caps); i++) {
40023290:	400304b7          	lui	s1,0x40030
40023294:	6f048493          	addi	s1,s1,1776 # 400306f0 <eth_hw_caps>
40023298:	09848a13          	addi	s4,s1,152
			PR("\t%s\n", eth_hw_caps[i].description);
4002329c:	4002fab7          	lui	s5,0x4002f
		if (caps & eth_hw_caps[i].capability) {
400232a0:	0004a783          	lw	a5,0(s1)
400232a4:	00f9f7b3          	and	a5,s3,a5
400232a8:	00078c63          	beqz	a5,400232c0 <iface_cb+0x418>
			PR("\t%s\n", eth_hw_caps[i].description);
400232ac:	0044a683          	lw	a3,4(s1)
400232b0:	00812503          	lw	a0,8(sp)
400232b4:	d94a8613          	addi	a2,s5,-620 # 4002ed94 <CSWTCH.14405+0x17b8>
400232b8:	00800593          	li	a1,8
400232bc:	9f5e20ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; i < ARRAY_SIZE(eth_hw_caps); i++) {
400232c0:	00848493          	addi	s1,s1,8
400232c4:	fc9a1ee3          	bne	s4,s1,400232a0 <iface_cb+0x3f8>
400232c8:	e51ff06f          	j	40023118 <iface_cb+0x270>
	ipv6 = iface->config.ip.ipv6;
400232cc:	00492483          	lw	s1,4(s2)
	PR("IPv6 unicast addresses (max %d):\n", NET_IF_MAX_IPV6_ADDR);
400232d0:	00812503          	lw	a0,8(sp)
400232d4:	4002f637          	lui	a2,0x4002f
400232d8:	00300693          	li	a3,3
400232dc:	dc460613          	addi	a2,a2,-572 # 4002edc4 <CSWTCH.14405+0x17e8>
400232e0:	00800593          	li	a1,8
400232e4:	9cde20ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_ADDR; i++) {
400232e8:	02048463          	beqz	s1,40023310 <iface_cb+0x468>
400232ec:	00448d13          	addi	s10,s1,4
	count = 0;
400232f0:	00000d93          	li	s11,0
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_ADDR; i++) {
400232f4:	00000993          	li	s3,0
400232f8:	00300a13          	li	s4,3
		if (!unicast->is_used) {
400232fc:	03000a93          	li	s5,48
40023300:	00400c13          	li	s8,4
		PR("\t%s %s %s%s%s\n",
40023304:	4002fcb7          	lui	s9,0x4002f
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_ADDR; i++) {
40023308:	19499a63          	bne	s3,s4,4002349c <iface_cb+0x5f4>
	if (count == 0) {
4002330c:	000d9c63          	bnez	s11,40023324 <iface_cb+0x47c>
		PR("\t<none>\n");
40023310:	00812503          	lw	a0,8(sp)
40023314:	4002f637          	lui	a2,0x4002f
40023318:	9e860613          	addi	a2,a2,-1560 # 4002e9e8 <CSWTCH.14405+0x140c>
4002331c:	00800593          	li	a1,8
40023320:	991e20ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("IPv6 multicast addresses (max %d):\n", NET_IF_MAX_IPV6_MADDR);
40023324:	00812503          	lw	a0,8(sp)
40023328:	4002f637          	lui	a2,0x4002f
4002332c:	00200693          	li	a3,2
40023330:	df860613          	addi	a2,a2,-520 # 4002edf8 <CSWTCH.14405+0x181c>
40023334:	00800593          	li	a1,8
40023338:	979e20ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
4002333c:	02048263          	beqz	s1,40023360 <iface_cb+0x4b8>
40023340:	09448593          	addi	a1,s1,148
	count = 0;
40023344:	00000993          	li	s3,0
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
40023348:	00000793          	li	a5,0
4002334c:	00200b13          	li	s6,2
		if (!mcast->is_used) {
40023350:	01800b93          	li	s7,24
		PR("\t%s\n", net_sprint_ipv6_addr(&mcast->address.in6_addr));
40023354:	4002fa37          	lui	s4,0x4002f
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
40023358:	23679863          	bne	a5,s6,40023588 <iface_cb+0x6e0>
	if (count == 0) {
4002335c:	00099c63          	bnez	s3,40023374 <iface_cb+0x4cc>
		PR("\t<none>\n");
40023360:	00812503          	lw	a0,8(sp)
40023364:	4002f637          	lui	a2,0x4002f
40023368:	9e860613          	addi	a2,a2,-1560 # 4002e9e8 <CSWTCH.14405+0x140c>
4002336c:	00800593          	li	a1,8
40023370:	941e20ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("IPv6 prefixes (max %d):\n", NET_IF_MAX_IPV6_PREFIX);
40023374:	00812503          	lw	a0,8(sp)
40023378:	4002f637          	lui	a2,0x4002f
4002337c:	00200693          	li	a3,2
40023380:	e1c60613          	addi	a2,a2,-484 # 4002ee1c <CSWTCH.14405+0x1840>
40023384:	00800593          	li	a1,8
40023388:	929e20ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_PREFIX; i++) {
4002338c:	02048a63          	beqz	s1,400233c0 <iface_cb+0x518>
		PR("\t%s/%d%s\n",
40023390:	4002cab7          	lui	s5,0x4002c
40023394:	4002fb37          	lui	s6,0x4002f
40023398:	0d048a13          	addi	s4,s1,208
	count = 0;
4002339c:	00000413          	li	s0,0
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_PREFIX; i++) {
400233a0:	00000793          	li	a5,0
400233a4:	00200c13          	li	s8,2
		if (!prefix->is_used) {
400233a8:	02800c93          	li	s9,40
		PR("\t%s/%d%s\n",
400233ac:	ed8a8a93          	addi	s5,s5,-296 # 4002bed8 <__clz_tab+0x2ac>
400233b0:	c70b0b13          	addi	s6,s6,-912 # 4002ec70 <CSWTCH.14405+0x1694>
400233b4:	4002fd37          	lui	s10,0x4002f
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_PREFIX; i++) {
400233b8:	23879063          	bne	a5,s8,400235d8 <iface_cb+0x730>
	if (count == 0) {
400233bc:	00041c63          	bnez	s0,400233d4 <iface_cb+0x52c>
		PR("\t<none>\n");
400233c0:	00812503          	lw	a0,8(sp)
400233c4:	4002f637          	lui	a2,0x4002f
400233c8:	9e860613          	addi	a2,a2,-1560 # 4002e9e8 <CSWTCH.14405+0x140c>
400233cc:	00800593          	li	a1,8
400233d0:	8e1e20ef          	jal	ra,40005cb0 <shell_fprintf>
	router = net_if_ipv6_router_find_default(iface, NULL);
400233d4:	00000593          	li	a1,0
400233d8:	00090513          	mv	a0,s2
400233dc:	a60eb0ef          	jal	ra,4000e63c <net_if_ipv6_router_find_default>
400233e0:	00050993          	mv	s3,a0
	if (router) {
400233e4:	04050863          	beqz	a0,40023434 <iface_cb+0x58c>
		PR("IPv6 default router :\n");
400233e8:	00812503          	lw	a0,8(sp)
400233ec:	4002f637          	lui	a2,0x4002f
400233f0:	e4460613          	addi	a2,a2,-444 # 4002ee44 <CSWTCH.14405+0x1868>
400233f4:	00800593          	li	a1,8
400233f8:	8b9e20ef          	jal	ra,40005cb0 <shell_fprintf>
		PR("\t%s%s\n",
400233fc:	00898593          	addi	a1,s3,8
40023400:	00200513          	li	a0,2
40023404:	d15ec0ef          	jal	ra,40010118 <net_sprint_addr>
40023408:	0229c783          	lbu	a5,34(s3)
4002340c:	00050693          	mv	a3,a0
40023410:	0047f793          	andi	a5,a5,4
40023414:	22078663          	beqz	a5,40023640 <iface_cb+0x798>
40023418:	4002f737          	lui	a4,0x4002f
4002341c:	c7070713          	addi	a4,a4,-912 # 4002ec70 <CSWTCH.14405+0x1694>
40023420:	00812503          	lw	a0,8(sp)
40023424:	4002f637          	lui	a2,0x4002f
40023428:	e5c60613          	addi	a2,a2,-420 # 4002ee5c <CSWTCH.14405+0x1880>
4002342c:	00800593          	li	a1,8
40023430:	881e20ef          	jal	ra,40005cb0 <shell_fprintf>
	if (ipv6) {
40023434:	d0048ce3          	beqz	s1,4002314c <iface_cb+0x2a4>
		PR("IPv6 hop limit           : %d\n",
40023438:	1254c683          	lbu	a3,293(s1)
4002343c:	00812503          	lw	a0,8(sp)
40023440:	4002f637          	lui	a2,0x4002f
40023444:	e6460613          	addi	a2,a2,-412 # 4002ee64 <CSWTCH.14405+0x1888>
40023448:	00800593          	li	a1,8
4002344c:	865e20ef          	jal	ra,40005cb0 <shell_fprintf>
		PR("IPv6 base reachable time : %d\n",
40023450:	1104a683          	lw	a3,272(s1)
40023454:	00812503          	lw	a0,8(sp)
40023458:	4002f637          	lui	a2,0x4002f
4002345c:	e8460613          	addi	a2,a2,-380 # 4002ee84 <CSWTCH.14405+0x18a8>
40023460:	00800593          	li	a1,8
40023464:	84de20ef          	jal	ra,40005cb0 <shell_fprintf>
		PR("IPv6 reachable time      : %d\n",
40023468:	1144a683          	lw	a3,276(s1)
4002346c:	00812503          	lw	a0,8(sp)
40023470:	4002f637          	lui	a2,0x4002f
40023474:	ea460613          	addi	a2,a2,-348 # 4002eea4 <CSWTCH.14405+0x18c8>
40023478:	00800593          	li	a1,8
4002347c:	835e20ef          	jal	ra,40005cb0 <shell_fprintf>
		PR("IPv6 retransmit timer    : %d\n",
40023480:	1184a683          	lw	a3,280(s1)
40023484:	00812503          	lw	a0,8(sp)
40023488:	4002f637          	lui	a2,0x4002f
4002348c:	ec460613          	addi	a2,a2,-316 # 4002eec4 <CSWTCH.14405+0x18e8>
40023490:	00800593          	li	a1,8
40023494:	81de20ef          	jal	ra,40005cb0 <shell_fprintf>
40023498:	cb5ff06f          	j	4002314c <iface_cb+0x2a4>
		if (!unicast->is_used) {
4002349c:	035987b3          	mul	a5,s3,s5
400234a0:	00198b93          	addi	s7,s3,1
400234a4:	030d0b13          	addi	s6,s10,48 # 4002f030 <CSWTCH.14405+0x1a54>
400234a8:	00f487b3          	add	a5,s1,a5
400234ac:	02f7c783          	lbu	a5,47(a5)
400234b0:	0027f793          	andi	a5,a5,2
400234b4:	00079863          	bnez	a5,400234c4 <iface_cb+0x61c>
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_ADDR; i++) {
400234b8:	000b8993          	mv	s3,s7
400234bc:	000b0d13          	mv	s10,s6
400234c0:	e49ff06f          	j	40023308 <iface_cb+0x460>
		PR("\t%s %s %s%s%s\n",
400234c4:	000d0593          	mv	a1,s10
400234c8:	00200513          	li	a0,2
400234cc:	c4dec0ef          	jal	ra,40010118 <net_sprint_addr>
400234d0:	028d4703          	lbu	a4,40(s10)
400234d4:	00050693          	mv	a3,a0
400234d8:	08ec6063          	bltu	s8,a4,40023558 <iface_cb+0x6b0>
400234dc:	400307b7          	lui	a5,0x40030
400234e0:	00271713          	slli	a4,a4,0x2
400234e4:	09c78793          	addi	a5,a5,156 # 4003009c <CSWTCH.188>
400234e8:	00e787b3          	add	a5,a5,a4
400234ec:	0007a703          	lw	a4,0(a5)
	switch (addr_state) {
400234f0:	029d4783          	lbu	a5,41(s10)
400234f4:	00178793          	addi	a5,a5,1
400234f8:	0ff7f793          	zext.b	a5,a5
400234fc:	06fa6463          	bltu	s4,a5,40023564 <iface_cb+0x6bc>
40023500:	40030637          	lui	a2,0x40030
40023504:	00279793          	slli	a5,a5,0x2
40023508:	08c60613          	addi	a2,a2,140 # 4003008c <CSWTCH.190>
4002350c:	00f607b3          	add	a5,a2,a5
40023510:	0007a783          	lw	a5,0(a5)
		PR("\t%s %s %s%s%s\n",
40023514:	035989b3          	mul	s3,s3,s5
40023518:	013489b3          	add	s3,s1,s3
4002351c:	02f9c603          	lbu	a2,47(s3)
40023520:	00167593          	andi	a1,a2,1
40023524:	04059663          	bnez	a1,40023570 <iface_cb+0x6c8>
40023528:	4002c837          	lui	a6,0x4002c
4002352c:	ed880813          	addi	a6,a6,-296 # 4002bed8 <__clz_tab+0x2ac>
40023530:	00467613          	andi	a2,a2,4
40023534:	04060463          	beqz	a2,4002357c <iface_cb+0x6d4>
40023538:	4002f8b7          	lui	a7,0x4002f
4002353c:	c7c88893          	addi	a7,a7,-900 # 4002ec7c <CSWTCH.14405+0x16a0>
40023540:	00812503          	lw	a0,8(sp)
40023544:	de8c8613          	addi	a2,s9,-536 # 4002ede8 <CSWTCH.14405+0x180c>
40023548:	00800593          	li	a1,8
4002354c:	f64e20ef          	jal	ra,40005cb0 <shell_fprintf>
		count++;
40023550:	001d8d93          	addi	s11,s11,1
40023554:	f65ff06f          	j	400234b8 <iface_cb+0x610>
		PR("\t%s %s %s%s%s\n",
40023558:	4002e737          	lui	a4,0x4002e
4002355c:	7a470713          	addi	a4,a4,1956 # 4002e7a4 <CSWTCH.14405+0x11c8>
40023560:	f91ff06f          	j	400234f0 <iface_cb+0x648>
	switch (addr_state) {
40023564:	4002d7b7          	lui	a5,0x4002d
40023568:	3ec78793          	addi	a5,a5,1004 # 4002d3ec <all_nodes_mcast_group.0+0x1c>
4002356c:	fa9ff06f          	j	40023514 <iface_cb+0x66c>
		PR("\t%s %s %s%s%s\n",
40023570:	4002f837          	lui	a6,0x4002f
40023574:	c7080813          	addi	a6,a6,-912 # 4002ec70 <CSWTCH.14405+0x1694>
40023578:	fb9ff06f          	j	40023530 <iface_cb+0x688>
4002357c:	4002c8b7          	lui	a7,0x4002c
40023580:	ed888893          	addi	a7,a7,-296 # 4002bed8 <__clz_tab+0x2ac>
40023584:	fbdff06f          	j	40023540 <iface_cb+0x698>
		if (!mcast->is_used) {
40023588:	03778733          	mul	a4,a5,s7
4002358c:	01858a93          	addi	s5,a1,24
40023590:	00178793          	addi	a5,a5,1
40023594:	00e48733          	add	a4,s1,a4
40023598:	0a474703          	lbu	a4,164(a4)
4002359c:	00177713          	andi	a4,a4,1
400235a0:	00071663          	bnez	a4,400235ac <iface_cb+0x704>
400235a4:	000a8593          	mv	a1,s5
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
400235a8:	db1ff06f          	j	40023358 <iface_cb+0x4b0>
		PR("\t%s\n", net_sprint_ipv6_addr(&mcast->address.in6_addr));
400235ac:	00200513          	li	a0,2
400235b0:	00f12623          	sw	a5,12(sp)
400235b4:	b65ec0ef          	jal	ra,40010118 <net_sprint_addr>
400235b8:	00050693          	mv	a3,a0
400235bc:	00812503          	lw	a0,8(sp)
400235c0:	d94a0613          	addi	a2,s4,-620 # 4002ed94 <CSWTCH.14405+0x17b8>
400235c4:	00800593          	li	a1,8
400235c8:	ee8e20ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
400235cc:	00c12783          	lw	a5,12(sp)
		count++;
400235d0:	00198993          	addi	s3,s3,1
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_MADDR; i++) {
400235d4:	fd1ff06f          	j	400235a4 <iface_cb+0x6fc>
		if (!prefix->is_used) {
400235d8:	03978db3          	mul	s11,a5,s9
400235dc:	00178993          	addi	s3,a5,1
400235e0:	028a0b93          	addi	s7,s4,40
400235e4:	01b48db3          	add	s11,s1,s11
400235e8:	0e5dc703          	lbu	a4,229(s11)
400235ec:	00277713          	andi	a4,a4,2
400235f0:	00071863          	bnez	a4,40023600 <iface_cb+0x758>
	for (i = 0; ipv6 && i < NET_IF_MAX_IPV6_PREFIX; i++) {
400235f4:	00098793          	mv	a5,s3
400235f8:	000b8a13          	mv	s4,s7
400235fc:	dbdff06f          	j	400233b8 <iface_cb+0x510>
		PR("\t%s/%d%s\n",
40023600:	000a0593          	mv	a1,s4
40023604:	00200513          	li	a0,2
40023608:	b11ec0ef          	jal	ra,40010118 <net_sprint_addr>
4002360c:	0e5dc603          	lbu	a2,229(s11)
40023610:	014a4703          	lbu	a4,20(s4)
40023614:	00050693          	mv	a3,a0
40023618:	00167613          	andi	a2,a2,1
4002361c:	000a8793          	mv	a5,s5
40023620:	00060463          	beqz	a2,40023628 <iface_cb+0x780>
40023624:	000b0793          	mv	a5,s6
40023628:	00812503          	lw	a0,8(sp)
4002362c:	e38d0613          	addi	a2,s10,-456
40023630:	00800593          	li	a1,8
40023634:	e7ce20ef          	jal	ra,40005cb0 <shell_fprintf>
		count++;
40023638:	00140413          	addi	s0,s0,1
4002363c:	fb9ff06f          	j	400235f4 <iface_cb+0x74c>
		PR("\t%s%s\n",
40023640:	4002c737          	lui	a4,0x4002c
40023644:	ed870713          	addi	a4,a4,-296 # 4002bed8 <__clz_tab+0x2ac>
40023648:	dd9ff06f          	j	40023420 <iface_cb+0x578>
	ipv4 = iface->config.ip.ipv4;
4002364c:	00892483          	lw	s1,8(s2)
	PR("IPv4 unicast addresses (max %d):\n", NET_IF_MAX_IPV4_ADDR);
40023650:	00812503          	lw	a0,8(sp)
40023654:	4002f637          	lui	a2,0x4002f
40023658:	00100693          	li	a3,1
4002365c:	eec60613          	addi	a2,a2,-276 # 4002eeec <CSWTCH.14405+0x1910>
40023660:	00800593          	li	a1,8
40023664:	e4ce20ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; ipv4 && i < NET_IF_MAX_IPV4_ADDR; i++) {
40023668:	18048063          	beqz	s1,400237e8 <iface_cb+0x940>
		if (!unicast->is_used) {
4002366c:	02f4c783          	lbu	a5,47(s1)
40023670:	0027f793          	andi	a5,a5,2
40023674:	16078a63          	beqz	a5,400237e8 <iface_cb+0x940>
		PR("\t%s %s %s%s\n",
40023678:	00448593          	addi	a1,s1,4
4002367c:	00100513          	li	a0,1
40023680:	a99ec0ef          	jal	ra,40010118 <net_sprint_addr>
40023684:	02c4c703          	lbu	a4,44(s1)
	switch (addr_type) {
40023688:	00400793          	li	a5,4
		PR("\t%s %s %s%s\n",
4002368c:	00050693          	mv	a3,a0
40023690:	12e7ea63          	bltu	a5,a4,400237c4 <iface_cb+0x91c>
40023694:	400307b7          	lui	a5,0x40030
40023698:	00271713          	slli	a4,a4,0x2
4002369c:	09c78793          	addi	a5,a5,156 # 4003009c <CSWTCH.188>
400236a0:	00e787b3          	add	a5,a5,a4
400236a4:	0007a703          	lw	a4,0(a5)
	switch (addr_state) {
400236a8:	02d4c783          	lbu	a5,45(s1)
400236ac:	00300613          	li	a2,3
400236b0:	00178793          	addi	a5,a5,1
400236b4:	0ff7f793          	zext.b	a5,a5
400236b8:	10f66c63          	bltu	a2,a5,400237d0 <iface_cb+0x928>
400236bc:	40030637          	lui	a2,0x40030
400236c0:	00279793          	slli	a5,a5,0x2
400236c4:	08c60613          	addi	a2,a2,140 # 4003008c <CSWTCH.190>
400236c8:	00f607b3          	add	a5,a2,a5
400236cc:	0007a783          	lw	a5,0(a5)
		PR("\t%s %s %s%s\n",
400236d0:	02f4c603          	lbu	a2,47(s1)
400236d4:	00167613          	andi	a2,a2,1
400236d8:	10060263          	beqz	a2,400237dc <iface_cb+0x934>
400236dc:	4002f837          	lui	a6,0x4002f
400236e0:	c7080813          	addi	a6,a6,-912 # 4002ec70 <CSWTCH.14405+0x1694>
400236e4:	00812503          	lw	a0,8(sp)
400236e8:	4002f637          	lui	a2,0x4002f
400236ec:	f1060613          	addi	a2,a2,-240 # 4002ef10 <CSWTCH.14405+0x1934>
400236f0:	00800593          	li	a1,8
400236f4:	dbce20ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("IPv4 multicast addresses (max %d):\n", NET_IF_MAX_IPV4_MADDR);
400236f8:	00812503          	lw	a0,8(sp)
400236fc:	4002f637          	lui	a2,0x4002f
40023700:	00100693          	li	a3,1
40023704:	f2060613          	addi	a2,a2,-224 # 4002ef20 <CSWTCH.14405+0x1944>
40023708:	00800593          	li	a1,8
4002370c:	da4e20ef          	jal	ra,40005cb0 <shell_fprintf>
	for (i = 0; ipv4 && i < NET_IF_MAX_IPV4_MADDR; i++) {
40023710:	0e048863          	beqz	s1,40023800 <iface_cb+0x958>
		if (!mcast->is_used) {
40023714:	0444c783          	lbu	a5,68(s1)
40023718:	0017f793          	andi	a5,a5,1
4002371c:	12078863          	beqz	a5,4002384c <iface_cb+0x9a4>
		PR("\t%s\n", net_sprint_ipv4_addr(&mcast->address.in_addr));
40023720:	03448593          	addi	a1,s1,52
40023724:	00100513          	li	a0,1
40023728:	9f1ec0ef          	jal	ra,40010118 <net_sprint_addr>
4002372c:	00050693          	mv	a3,a0
40023730:	00812503          	lw	a0,8(sp)
40023734:	4002f637          	lui	a2,0x4002f
40023738:	d9460613          	addi	a2,a2,-620 # 4002ed94 <CSWTCH.14405+0x17b8>
4002373c:	00800593          	li	a1,8
40023740:	d70e20ef          	jal	ra,40005cb0 <shell_fprintf>
		PR("IPv4 gateway : %s\n",
40023744:	04848593          	addi	a1,s1,72
40023748:	00100513          	li	a0,1
4002374c:	9cdec0ef          	jal	ra,40010118 <net_sprint_addr>
40023750:	00050693          	mv	a3,a0
40023754:	00812503          	lw	a0,8(sp)
40023758:	4002f637          	lui	a2,0x4002f
4002375c:	f4460613          	addi	a2,a2,-188 # 4002ef44 <CSWTCH.14405+0x1968>
40023760:	00800593          	li	a1,8
40023764:	d4ce20ef          	jal	ra,40005cb0 <shell_fprintf>
		PR("IPv4 netmask : %s\n",
40023768:	04c48593          	addi	a1,s1,76
4002376c:	00100513          	li	a0,1
40023770:	9a9ec0ef          	jal	ra,40010118 <net_sprint_addr>
}
40023774:	05812403          	lw	s0,88(sp)
40023778:	05c12083          	lw	ra,92(sp)
4002377c:	05412483          	lw	s1,84(sp)
40023780:	05012903          	lw	s2,80(sp)
40023784:	04c12983          	lw	s3,76(sp)
40023788:	04812a03          	lw	s4,72(sp)
4002378c:	04412a83          	lw	s5,68(sp)
40023790:	04012b03          	lw	s6,64(sp)
40023794:	03c12b83          	lw	s7,60(sp)
40023798:	03812c03          	lw	s8,56(sp)
4002379c:	03412c83          	lw	s9,52(sp)
400237a0:	03012d03          	lw	s10,48(sp)
400237a4:	02c12d83          	lw	s11,44(sp)
		PR("IPv4 netmask : %s\n",
400237a8:	00050693          	mv	a3,a0
400237ac:	00812503          	lw	a0,8(sp)
400237b0:	4002f637          	lui	a2,0x4002f
400237b4:	f5860613          	addi	a2,a2,-168 # 4002ef58 <CSWTCH.14405+0x197c>
400237b8:	00800593          	li	a1,8
}
400237bc:	06010113          	addi	sp,sp,96
		PR("IPv4 netmask : %s\n",
400237c0:	cf0e206f          	j	40005cb0 <shell_fprintf>
		PR("\t%s %s %s%s\n",
400237c4:	4002e737          	lui	a4,0x4002e
400237c8:	7a470713          	addi	a4,a4,1956 # 4002e7a4 <CSWTCH.14405+0x11c8>
400237cc:	eddff06f          	j	400236a8 <iface_cb+0x800>
	switch (addr_state) {
400237d0:	4002d7b7          	lui	a5,0x4002d
400237d4:	3ec78793          	addi	a5,a5,1004 # 4002d3ec <all_nodes_mcast_group.0+0x1c>
400237d8:	ef9ff06f          	j	400236d0 <iface_cb+0x828>
		PR("\t%s %s %s%s\n",
400237dc:	4002c837          	lui	a6,0x4002c
400237e0:	ed880813          	addi	a6,a6,-296 # 4002bed8 <__clz_tab+0x2ac>
400237e4:	f01ff06f          	j	400236e4 <iface_cb+0x83c>
		PR("\t<none>\n");
400237e8:	00812503          	lw	a0,8(sp)
400237ec:	4002f637          	lui	a2,0x4002f
400237f0:	9e860613          	addi	a2,a2,-1560 # 4002e9e8 <CSWTCH.14405+0x140c>
400237f4:	00800593          	li	a1,8
400237f8:	cb8e20ef          	jal	ra,40005cb0 <shell_fprintf>
400237fc:	efdff06f          	j	400236f8 <iface_cb+0x850>
}
40023800:	05812403          	lw	s0,88(sp)
		PR("\t<none>\n");
40023804:	00812503          	lw	a0,8(sp)
}
40023808:	05c12083          	lw	ra,92(sp)
4002380c:	05412483          	lw	s1,84(sp)
40023810:	05012903          	lw	s2,80(sp)
40023814:	04c12983          	lw	s3,76(sp)
40023818:	04812a03          	lw	s4,72(sp)
4002381c:	04412a83          	lw	s5,68(sp)
40023820:	04012b03          	lw	s6,64(sp)
40023824:	03c12b83          	lw	s7,60(sp)
40023828:	03812c03          	lw	s8,56(sp)
4002382c:	03412c83          	lw	s9,52(sp)
40023830:	03012d03          	lw	s10,48(sp)
40023834:	02c12d83          	lw	s11,44(sp)
		PR("\t<none>\n");
40023838:	4002f637          	lui	a2,0x4002f
4002383c:	9e860613          	addi	a2,a2,-1560 # 4002e9e8 <CSWTCH.14405+0x140c>
40023840:	00800593          	li	a1,8
}
40023844:	06010113          	addi	sp,sp,96
		PR("\t<none>\n");
40023848:	c68e206f          	j	40005cb0 <shell_fprintf>
4002384c:	00812503          	lw	a0,8(sp)
40023850:	4002f637          	lui	a2,0x4002f
40023854:	9e860613          	addi	a2,a2,-1560 # 4002e9e8 <CSWTCH.14405+0x140c>
40023858:	00800593          	li	a1,8
4002385c:	c54e20ef          	jal	ra,40005cb0 <shell_fprintf>
40023860:	ee5ff06f          	j	40023744 <iface_cb+0x89c>

40023864 <nbr_cb>:
{
40023864:	f9010113          	addi	sp,sp,-112
40023868:	05512a23          	sw	s5,84(sp)
4002386c:	06112623          	sw	ra,108(sp)
40023870:	06812423          	sw	s0,104(sp)
40023874:	06912223          	sw	s1,100(sp)
40023878:	07212023          	sw	s2,96(sp)
4002387c:	05312e23          	sw	s3,92(sp)
40023880:	05412c23          	sw	s4,88(sp)
40023884:	05612823          	sw	s6,80(sp)
40023888:	05712623          	sw	s7,76(sp)
4002388c:	05812423          	sw	s8,72(sp)
40023890:	05912223          	sw	s9,68(sp)
40023894:	05a12023          	sw	s10,64(sp)
40023898:	03b12e23          	sw	s11,60(sp)
	const struct shell *sh = data->sh;
4002389c:	0005a783          	lw	a5,0(a1)
	int *count = data->user_data;
400238a0:	0045ab03          	lw	s6,4(a1)
{
400238a4:	00050a93          	mv	s5,a0
	const struct shell *sh = data->sh;
400238a8:	02f12623          	sw	a5,44(sp)
	if (*count == 0) {
400238ac:	000b2783          	lw	a5,0(s6)
400238b0:	02079063          	bnez	a5,400238d0 <nbr_cb+0x6c>
		PR("     Neighbor  Interface  Flags    State     "
400238b4:	02c12503          	lw	a0,44(sp)
400238b8:	4002c6b7          	lui	a3,0x4002c
400238bc:	4002f637          	lui	a2,0x4002f
400238c0:	ed868693          	addi	a3,a3,-296 # 4002bed8 <__clz_tab+0x2ac>
400238c4:	f7860613          	addi	a2,a2,-136 # 4002ef78 <CSWTCH.14405+0x199c>
400238c8:	00800593          	li	a1,8
400238cc:	be4e20ef          	jal	ra,40005cb0 <shell_fprintf>
	(*count)++;
400238d0:	000b2783          	lw	a5,0(s6)
400238d4:	4002c437          	lui	s0,0x4002c
400238d8:	ed840d93          	addi	s11,s0,-296 # 4002bed8 <__clz_tab+0x2ac>
400238dc:	00178793          	addi	a5,a5,1
400238e0:	00fb2023          	sw	a5,0(s6)
	state_str = net_ipv6_nbr_state2str(net_ipv6_nbr_data(nbr)->state);
400238e4:	00caa783          	lw	a5,12(s5)
	char *state_pad = "";
400238e8:	ed840413          	addi	s0,s0,-296
	state_str = net_ipv6_nbr_state2str(net_ipv6_nbr_data(nbr)->state);
400238ec:	0307a503          	lw	a0,48(a5)
400238f0:	8b0f40ef          	jal	ra,400179a0 <net_ipv6_nbr_state2str>
400238f4:	00050a13          	mv	s4,a0
	if (strlen(state_str) == 5) {
400238f8:	e30e50ef          	jal	ra,40008f28 <strlen>
400238fc:	00500793          	li	a5,5
40023900:	00f51663          	bne	a0,a5,4002390c <nbr_cb+0xa8>
		state_pad = "    ";
40023904:	4002f437          	lui	s0,0x4002f
40023908:	f6c40413          	addi	s0,s0,-148 # 4002ef6c <CSWTCH.14405+0x1990>
4002390c:	00caa603          	lw	a2,12(s5)
		    net_ipv6_nbr_data(nbr)->reachable_timeout -
40023910:	02062783          	lw	a5,32(a2)
	remaining = net_ipv6_nbr_data(nbr)->reachable +
40023914:	01862983          	lw	s3,24(a2)
40023918:	01c62603          	lw	a2,28(a2)
		    net_ipv6_nbr_data(nbr)->reachable_timeout -
4002391c:	41f7d693          	srai	a3,a5,0x1f
	remaining = net_ipv6_nbr_data(nbr)->reachable +
40023920:	013789b3          	add	s3,a5,s3
40023924:	00f9b7b3          	sltu	a5,s3,a5
40023928:	00c686b3          	add	a3,a3,a2
4002392c:	00d78933          	add	s2,a5,a3
40023930:	284070ef          	jal	ra,4002abb4 <z_impl_k_uptime_ticks>
40023934:	00a00793          	li	a5,10
40023938:	02b785b3          	mul	a1,a5,a1
	PR("[%2d] %p  %d      %5d/%d/%d/%d  %s%s %6d  %17s%s %s\n",
4002393c:	000b2b03          	lw	s6,0(s6)
40023940:	02a784b3          	mul	s1,a5,a0
40023944:	02a7b7b3          	mulhu	a5,a5,a0
	remaining = net_ipv6_nbr_data(nbr)->reachable +
40023948:	409984b3          	sub	s1,s3,s1
4002394c:	0099b9b3          	sltu	s3,s3,s1
40023950:	00f58533          	add	a0,a1,a5
40023954:	40a90933          	sub	s2,s2,a0
	PR("[%2d] %p  %d      %5d/%d/%d/%d  %s%s %6d  %17s%s %s\n",
40023958:	008aa503          	lw	a0,8(s5)
	remaining = net_ipv6_nbr_data(nbr)->reachable +
4002395c:	41390933          	sub	s2,s2,s3
	PR("[%2d] %p  %d      %5d/%d/%d/%d  %s%s %6d  %17s%s %s\n",
40023960:	c81eb0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
40023964:	00caa783          	lw	a5,12(s5)
40023968:	000acc03          	lbu	s8,0(s5)
4002396c:	00050993          	mv	s3,a0
40023970:	0347db83          	lhu	s7,52(a5)
40023974:	0367cc83          	lbu	s9,54(a5)
40023978:	0377cd03          	lbu	s10,55(a5)
4002397c:	00095463          	bgez	s2,40023984 <nbr_cb+0x120>
40023980:	00000493          	li	s1,0
40023984:	001ac503          	lbu	a0,1(s5)
40023988:	0ff00793          	li	a5,255
4002398c:	0cf50a63          	beq	a0,a5,40023a60 <nbr_cb+0x1fc>
40023990:	d79f20ef          	jal	ra,40016708 <net_nbr_get_lladdr>
40023994:	00050913          	mv	s2,a0
40023998:	001ac503          	lbu	a0,1(s5)
4002399c:	d6df20ef          	jal	ra,40016708 <net_nbr_get_lladdr>
400239a0:	00154583          	lbu	a1,1(a0)
400239a4:	40032637          	lui	a2,0x40032
400239a8:	00290513          	addi	a0,s2,2
400239ac:	01800693          	li	a3,24
400239b0:	69060613          	addi	a2,a2,1680 # 40032690 <buf.1>
400239b4:	b44ec0ef          	jal	ra,4000fcf8 <net_sprint_ll_addr_buf>
400239b8:	00050913          	mv	s2,a0
400239bc:	001ac503          	lbu	a0,1(s5)
400239c0:	0ff00793          	li	a5,255
400239c4:	00f50463          	beq	a0,a5,400239cc <nbr_cb+0x168>
400239c8:	d41f20ef          	jal	ra,40016708 <net_nbr_get_lladdr>
400239cc:	00caa583          	lw	a1,12(s5)
400239d0:	00200513          	li	a0,2
400239d4:	00458593          	addi	a1,a1,4
400239d8:	f40ec0ef          	jal	ra,40010118 <net_sprint_addr>
400239dc:	00a12e23          	sw	a0,28(sp)
400239e0:	02c12503          	lw	a0,44(sp)
400239e4:	4002f637          	lui	a2,0x4002f
400239e8:	01b12c23          	sw	s11,24(sp)
400239ec:	01212a23          	sw	s2,20(sp)
400239f0:	00912823          	sw	s1,16(sp)
400239f4:	00812623          	sw	s0,12(sp)
400239f8:	01412423          	sw	s4,8(sp)
400239fc:	01a12223          	sw	s10,4(sp)
40023a00:	01912023          	sw	s9,0(sp)
40023a04:	000c0893          	mv	a7,s8
40023a08:	000b8813          	mv	a6,s7
40023a0c:	00098793          	mv	a5,s3
40023a10:	000a8713          	mv	a4,s5
40023a14:	000b0693          	mv	a3,s6
40023a18:	fcc60613          	addi	a2,a2,-52 # 4002efcc <CSWTCH.14405+0x19f0>
40023a1c:	00800593          	li	a1,8
40023a20:	a90e20ef          	jal	ra,40005cb0 <shell_fprintf>
}
40023a24:	06c12083          	lw	ra,108(sp)
40023a28:	06812403          	lw	s0,104(sp)
40023a2c:	06412483          	lw	s1,100(sp)
40023a30:	06012903          	lw	s2,96(sp)
40023a34:	05c12983          	lw	s3,92(sp)
40023a38:	05812a03          	lw	s4,88(sp)
40023a3c:	05412a83          	lw	s5,84(sp)
40023a40:	05012b03          	lw	s6,80(sp)
40023a44:	04c12b83          	lw	s7,76(sp)
40023a48:	04812c03          	lw	s8,72(sp)
40023a4c:	04412c83          	lw	s9,68(sp)
40023a50:	04012d03          	lw	s10,64(sp)
40023a54:	03c12d83          	lw	s11,60(sp)
40023a58:	07010113          	addi	sp,sp,112
40023a5c:	00008067          	ret
	PR("[%2d] %p  %d      %5d/%d/%d/%d  %s%s %6d  %17s%s %s\n",
40023a60:	4002f937          	lui	s2,0x4002f
40023a64:	f7490913          	addi	s2,s2,-140 # 4002ef74 <CSWTCH.14405+0x1998>
40023a68:	f55ff06f          	j	400239bc <nbr_cb+0x158>

40023a6c <arp_cb>:
{
40023a6c:	fd010113          	addi	sp,sp,-48
40023a70:	02812423          	sw	s0,40(sp)
40023a74:	02112623          	sw	ra,44(sp)
40023a78:	02912223          	sw	s1,36(sp)
40023a7c:	03212023          	sw	s2,32(sp)
40023a80:	01312e23          	sw	s3,28(sp)
	int *count = data->user_data;
40023a84:	0045a483          	lw	s1,4(a1)
	const struct shell *sh = data->sh;
40023a88:	0005a903          	lw	s2,0(a1)
{
40023a8c:	00050413          	mv	s0,a0
	if (*count == 0) {
40023a90:	0004a783          	lw	a5,0(s1)
40023a94:	00079c63          	bnez	a5,40023aac <arp_cb+0x40>
		PR("     Interface  Link              Address\n");
40023a98:	4002f637          	lui	a2,0x4002f
40023a9c:	00460613          	addi	a2,a2,4 # 4002f004 <CSWTCH.14405+0x1a28>
40023aa0:	00800593          	li	a1,8
40023aa4:	00090513          	mv	a0,s2
40023aa8:	a08e20ef          	jal	ra,40005cb0 <shell_fprintf>
	PR("[%2d] %d          %s %s\n", *count,
40023aac:	00842503          	lw	a0,8(s0)
40023ab0:	0004a983          	lw	s3,0(s1)
40023ab4:	b2deb0ef          	jal	ra,4000f5e0 <net_if_get_by_iface>
40023ab8:	40032637          	lui	a2,0x40032
40023abc:	00a12623          	sw	a0,12(sp)
40023ac0:	01800693          	li	a3,24
40023ac4:	69060613          	addi	a2,a2,1680 # 40032690 <buf.1>
40023ac8:	00600593          	li	a1,6
40023acc:	01040513          	addi	a0,s0,16
40023ad0:	a28ec0ef          	jal	ra,4000fcf8 <net_sprint_ll_addr_buf>
40023ad4:	00a12423          	sw	a0,8(sp)
40023ad8:	00c40593          	addi	a1,s0,12
40023adc:	00100513          	li	a0,1
40023ae0:	e38ec0ef          	jal	ra,40010118 <net_sprint_addr>
40023ae4:	00812783          	lw	a5,8(sp)
40023ae8:	00c12703          	lw	a4,12(sp)
40023aec:	4002f637          	lui	a2,0x4002f
40023af0:	00050813          	mv	a6,a0
40023af4:	00098693          	mv	a3,s3
40023af8:	00090513          	mv	a0,s2
40023afc:	03060613          	addi	a2,a2,48 # 4002f030 <CSWTCH.14405+0x1a54>
40023b00:	00800593          	li	a1,8
40023b04:	9ace20ef          	jal	ra,40005cb0 <shell_fprintf>
	(*count)++;
40023b08:	0004a783          	lw	a5,0(s1)
40023b0c:	00178793          	addi	a5,a5,1
40023b10:	00f4a023          	sw	a5,0(s1)
}
40023b14:	02c12083          	lw	ra,44(sp)
40023b18:	02812403          	lw	s0,40(sp)
40023b1c:	02412483          	lw	s1,36(sp)
40023b20:	02012903          	lw	s2,32(sp)
40023b24:	01c12983          	lw	s3,28(sp)
40023b28:	03010113          	addi	sp,sp,48
40023b2c:	00008067          	ret

40023b30 <net_shell_init>:

	(void)cmd_net_events_on(shell_backend_uart_get_ptr(), 1, argv);
#endif

	return 0;
}
40023b30:	00000513          	li	a0,0
40023b34:	00008067          	ret

40023b38 <services_notify_ready>:
#if defined(CONFIG_NET_NATIVE)
static struct net_mgmt_event_callback mgmt_iface_cb;
#endif

static inline void services_notify_ready(int flags)
{
40023b38:	ff010113          	addi	sp,sp,-16
40023b3c:	00112623          	sw	ra,12(sp)
40023b40:	00050593          	mv	a1,a0
	return z_impl_atomic_or(target, value);
40023b44:	40031537          	lui	a0,0x40031
40023b48:	ae450513          	addi	a0,a0,-1308 # 40030ae4 <services_flags>
40023b4c:	4c0070ef          	jal	ra,4002b00c <z_impl_atomic_or>
	atomic_or(&services_flags, flags);
	k_sem_give(&waiter);
}
40023b50:	00c12083          	lw	ra,12(sp)
	z_impl_k_sem_give(sem);
40023b54:	4003d537          	lui	a0,0x4003d
40023b58:	b7450513          	addi	a0,a0,-1164 # 4003cb74 <waiter>
40023b5c:	01010113          	addi	sp,sp,16
40023b60:	2240506f          	j	40028d84 <z_impl_k_sem_give>

40023b64 <ipv6_event_handler>:
static struct net_mgmt_event_callback mgmt6_cb;
static struct in6_addr laddr;

static void ipv6_event_handler(struct net_mgmt_event_callback *cb,
			       uint32_t mgmt_event, struct net_if *iface)
{
40023b64:	fe010113          	addi	sp,sp,-32
40023b68:	00112e23          	sw	ra,28(sp)
40023b6c:	00812c23          	sw	s0,24(sp)
40023b70:	00912a23          	sw	s1,20(sp)
	struct net_if_ipv6 *ipv6 = iface->config.ip.ipv6;
40023b74:	00462703          	lw	a4,4(a2)
{
40023b78:	00c12623          	sw	a2,12(sp)
	int i;

	if (!ipv6) {
40023b7c:	02070a63          	beqz	a4,40023bb0 <ipv6_event_handler+0x4c>
		return;
	}

	if (mgmt_event == NET_EVENT_IPV6_ADDR_ADD) {
40023b80:	e06007b7          	lui	a5,0xe0600
40023b84:	00178693          	addi	a3,a5,1 # e0600001 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0600002>
40023b88:	08d59063          	bne	a1,a3,40023c08 <ipv6_event_handler+0xa4>
		/* save the last added IP address for this interface */
		for (i = NET_IF_MAX_IPV6_ADDR - 1; i >= 0; i--) {
			if (ipv6->unicast[i].is_used) {
40023b8c:	08c72783          	lw	a5,140(a4)
40023b90:	0197d793          	srli	a5,a5,0x19
40023b94:	0017f793          	andi	a5,a5,1
40023b98:	02078663          	beqz	a5,40023bc4 <ipv6_event_handler+0x60>
				memcpy(&laddr,
40023b9c:	01000613          	li	a2,16
40023ba0:	06470593          	addi	a1,a4,100
40023ba4:	40033537          	lui	a0,0x40033
40023ba8:	80450513          	addi	a0,a0,-2044 # 40032804 <laddr>
40023bac:	ca0e50ef          	jal	ra,4000904c <memcpy>
	}

	if (mgmt_event == NET_EVENT_IPV6_ROUTER_ADD) {
		services_notify_ready(NET_CONFIG_NEED_ROUTER);
	}
}
40023bb0:	01c12083          	lw	ra,28(sp)
40023bb4:	01812403          	lw	s0,24(sp)
40023bb8:	01412483          	lw	s1,20(sp)
40023bbc:	02010113          	addi	sp,sp,32
40023bc0:	00008067          	ret
			if (ipv6->unicast[i].is_used) {
40023bc4:	05c72783          	lw	a5,92(a4)
40023bc8:	0197d793          	srli	a5,a5,0x19
40023bcc:	0017f793          	andi	a5,a5,1
40023bd0:	02079863          	bnez	a5,40023c00 <ipv6_event_handler+0x9c>
40023bd4:	02c72783          	lw	a5,44(a4)
40023bd8:	0197d793          	srli	a5,a5,0x19
40023bdc:	0017f793          	andi	a5,a5,1
40023be0:	fc0788e3          	beqz	a5,40023bb0 <ipv6_event_handler+0x4c>
		for (i = NET_IF_MAX_IPV6_ADDR - 1; i >= 0; i--) {
40023be4:	00000793          	li	a5,0
				       &ipv6->unicast[i].address.in6_addr,
40023be8:	03000693          	li	a3,48
40023bec:	02d787b3          	mul	a5,a5,a3
				memcpy(&laddr,
40023bf0:	01000613          	li	a2,16
				       &ipv6->unicast[i].address.in6_addr,
40023bf4:	00478793          	addi	a5,a5,4
				memcpy(&laddr,
40023bf8:	00f705b3          	add	a1,a4,a5
40023bfc:	fa9ff06f          	j	40023ba4 <ipv6_event_handler+0x40>
		for (i = NET_IF_MAX_IPV6_ADDR - 1; i >= 0; i--) {
40023c00:	00100793          	li	a5,1
40023c04:	fe5ff06f          	j	40023be8 <ipv6_event_handler+0x84>
	if (mgmt_event == NET_EVENT_IPV6_DAD_SUCCEED) {
40023c08:	00d78713          	addi	a4,a5,13
40023c0c:	04e59463          	bne	a1,a4,40023c54 <ipv6_event_handler+0xf0>
		ifaddr = net_if_ipv6_addr_lookup(&laddr, &iface);
40023c10:	400334b7          	lui	s1,0x40033
40023c14:	00c10593          	addi	a1,sp,12
40023c18:	80448513          	addi	a0,s1,-2044 # 40032804 <laddr>
40023c1c:	b00e90ef          	jal	ra,4000cf1c <net_if_ipv6_addr_lookup>
40023c20:	00050413          	mv	s0,a0
		if (!ifaddr ||
40023c24:	f80506e3          	beqz	a0,40023bb0 <ipv6_event_handler+0x4c>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
40023c28:	01000613          	li	a2,16
40023c2c:	80448593          	addi	a1,s1,-2044
40023c30:	00450513          	addi	a0,a0,4
40023c34:	b98e50ef          	jal	ra,40008fcc <memcmp>
40023c38:	f6051ce3          	bnez	a0,40023bb0 <ipv6_event_handler+0x4c>
		    !(net_ipv6_addr_cmp(&ifaddr->address.in6_addr, &laddr) &&
40023c3c:	02d40703          	lb	a4,45(s0)
40023c40:	00100793          	li	a5,1
		services_notify_ready(NET_CONFIG_NEED_IPV6);
40023c44:	00200513          	li	a0,2
		    !(net_ipv6_addr_cmp(&ifaddr->address.in6_addr, &laddr) &&
40023c48:	f6f714e3          	bne	a4,a5,40023bb0 <ipv6_event_handler+0x4c>
		services_notify_ready(NET_CONFIG_NEED_ROUTER);
40023c4c:	eedff0ef          	jal	ra,40023b38 <services_notify_ready>
40023c50:	f61ff06f          	j	40023bb0 <ipv6_event_handler+0x4c>
	if (mgmt_event == NET_EVENT_IPV6_ROUTER_ADD) {
40023c54:	00978793          	addi	a5,a5,9
40023c58:	f4f59ce3          	bne	a1,a5,40023bb0 <ipv6_event_handler+0x4c>
		services_notify_ready(NET_CONFIG_NEED_ROUTER);
40023c5c:	00100513          	li	a0,1
40023c60:	fedff06f          	j	40023c4c <ipv6_event_handler+0xe8>

40023c64 <net_if_flag_is_set>:
	if (iface == NULL) {
40023c64:	02050c63          	beqz	a0,40023c9c <net_if_flag_is_set+0x38>
{
40023c68:	ff010113          	addi	sp,sp,-16
40023c6c:	00812423          	sw	s0,8(sp)
40023c70:	00112623          	sw	ra,12(sp)
	return atomic_test_bit(iface->if_dev->flags, value);
40023c74:	00052503          	lw	a0,0(a0)
40023c78:	00058413          	mv	s0,a1
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
40023c7c:	00c50513          	addi	a0,a0,12
40023c80:	368070ef          	jal	ra,4002afe8 <atomic_get>
}
40023c84:	00c12083          	lw	ra,12(sp)
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
40023c88:	40855533          	sra	a0,a0,s0
40023c8c:	00812403          	lw	s0,8(sp)
40023c90:	00157513          	andi	a0,a0,1
40023c94:	01010113          	addi	sp,sp,16
40023c98:	00008067          	ret
		return false;
40023c9c:	00000513          	li	a0,0
}
40023ca0:	00008067          	ret

40023ca4 <iface_find_cb>:

static void iface_find_cb(struct net_if *iface, void *user_data)
{
	struct net_if **iface_to_use = user_data;

	if (*iface_to_use == NULL &&
40023ca4:	0005a783          	lw	a5,0(a1)
40023ca8:	04079063          	bnez	a5,40023ce8 <iface_find_cb+0x44>
{
40023cac:	ff010113          	addi	sp,sp,-16
40023cb0:	00812423          	sw	s0,8(sp)
40023cb4:	00058413          	mv	s0,a1
	    !net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
40023cb8:	00300593          	li	a1,3
{
40023cbc:	00912223          	sw	s1,4(sp)
40023cc0:	00112623          	sw	ra,12(sp)
40023cc4:	00050493          	mv	s1,a0
	    !net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
40023cc8:	f9dff0ef          	jal	ra,40023c64 <net_if_flag_is_set>
	if (*iface_to_use == NULL &&
40023ccc:	00051463          	bnez	a0,40023cd4 <iface_find_cb+0x30>
		*iface_to_use = iface;
40023cd0:	00942023          	sw	s1,0(s0)
		return;
	}
}
40023cd4:	00c12083          	lw	ra,12(sp)
40023cd8:	00812403          	lw	s0,8(sp)
40023cdc:	00412483          	lw	s1,4(sp)
40023ce0:	01010113          	addi	sp,sp,16
40023ce4:	00008067          	ret
40023ce8:	00008067          	ret

40023cec <iface_up_handler>:
	if (mgmt_event == NET_EVENT_IF_UP) {
40023cec:	d00107b7          	lui	a5,0xd0010
40023cf0:	00278793          	addi	a5,a5,2 # d0010002 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd0010003>
40023cf4:	02f59663          	bne	a1,a5,40023d20 <iface_up_handler+0x34>
{
40023cf8:	ff010113          	addi	sp,sp,-16
40023cfc:	00112623          	sw	ra,12(sp)
	z_impl_k_sem_reset(sem);
40023d00:	4003d537          	lui	a0,0x4003d
40023d04:	b4450513          	addi	a0,a0,-1212 # 4003cb44 <counter>
40023d08:	140050ef          	jal	ra,40028e48 <z_impl_k_sem_reset>
}
40023d0c:	00c12083          	lw	ra,12(sp)
	z_impl_k_sem_give(sem);
40023d10:	4003d537          	lui	a0,0x4003d
40023d14:	b7450513          	addi	a0,a0,-1164 # 4003cb74 <waiter>
40023d18:	01010113          	addi	sp,sp,16
40023d1c:	0680506f          	j	40028d84 <z_impl_k_sem_give>
40023d20:	00008067          	ret

40023d24 <net_config_init_by_iface>:
{
40023d24:	fc010113          	addi	sp,sp,-64
40023d28:	03212823          	sw	s2,48(sp)
40023d2c:	03312623          	sw	s3,44(sp)
40023d30:	03512223          	sw	s5,36(sp)
	int loop = timeout / LOOP_DIVIDER;
40023d34:	00a00913          	li	s2,10
{
40023d38:	02112e23          	sw	ra,60(sp)
40023d3c:	02812c23          	sw	s0,56(sp)
40023d40:	02912a23          	sw	s1,52(sp)
40023d44:	03412423          	sw	s4,40(sp)
40023d48:	03612023          	sw	s6,32(sp)
40023d4c:	01712e23          	sw	s7,28(sp)
40023d50:	01812c23          	sw	s8,24(sp)
40023d54:	01912a23          	sw	s9,20(sp)
40023d58:	01a12823          	sw	s10,16(sp)
	int loop = timeout / LOOP_DIVIDER;
40023d5c:	0326c933          	div	s2,a3,s2
{
40023d60:	00060a93          	mv	s5,a2
40023d64:	00068993          	mv	s3,a3
	if (!iface) {
40023d68:	00051463          	bnez	a0,40023d70 <net_config_init_by_iface+0x4c>
		iface = net_if_get_default();
40023d6c:	e51e80ef          	jal	ra,4000cbbc <net_if_get_default>
40023d70:	00050493          	mv	s1,a0
		count = -1;
40023d74:	fff00413          	li	s0,-1
	if (timeout < 0) {
40023d78:	0009c863          	bltz	s3,40023d88 <net_config_init_by_iface+0x64>
		count = 0;
40023d7c:	00000413          	li	s0,0
	} else if (timeout == 0) {
40023d80:	00098463          	beqz	s3,40023d88 <net_config_init_by_iface+0x64>
		count = LOOP_DIVIDER;
40023d84:	00a00413          	li	s0,10
	return net_if_flag_is_set(iface, NET_IF_UP) &&
40023d88:	00000593          	li	a1,0
40023d8c:	00048513          	mv	a0,s1
40023d90:	ed5ff0ef          	jal	ra,40023c64 <net_if_flag_is_set>
40023d94:	4003da37          	lui	s4,0x4003d
40023d98:	18050663          	beqz	a0,40023f24 <net_config_init_by_iface+0x200>
	       net_if_flag_is_set(iface, NET_IF_RUNNING);
40023d9c:	00800593          	li	a1,8
40023da0:	00048513          	mv	a0,s1
40023da4:	ec1ff0ef          	jal	ra,40023c64 <net_if_flag_is_set>
	return net_if_flag_is_set(iface, NET_IF_UP) &&
40023da8:	16050e63          	beqz	a0,40023f24 <net_config_init_by_iface+0x200>
	z_impl_k_sem_reset(sem);
40023dac:	b44a0513          	addi	a0,s4,-1212 # 4003cb44 <counter>
40023db0:	098050ef          	jal	ra,40028e48 <z_impl_k_sem_reset>
	z_impl_k_sem_give(sem);
40023db4:	4003d537          	lui	a0,0x4003d
40023db8:	b7450513          	addi	a0,a0,-1164 # 4003cb74 <waiter>
40023dbc:	7c9040ef          	jal	ra,40028d84 <z_impl_k_sem_give>
	return z_impl_net_addr_pton(family, src, dst);
40023dc0:	4002c5b7          	lui	a1,0x4002c
40023dc4:	00c10613          	addi	a2,sp,12
40023dc8:	d2c58593          	addi	a1,a1,-724 # 4002bd2c <__clz_tab+0x100>
40023dcc:	00100513          	li	a0,1
40023dd0:	b7cec0ef          	jal	ra,4001014c <z_impl_net_addr_pton>
	if (net_addr_pton(AF_INET, CONFIG_NET_CONFIG_MY_IPV4_ADDR, &addr)) {
40023dd4:	04051263          	bnez	a0,40023e18 <net_config_init_by_iface+0xf4>
	net_if_ipv4_addr_add(iface, &addr, NET_ADDR_MANUAL, 0);
40023dd8:	00000693          	li	a3,0
40023ddc:	00300613          	li	a2,3
40023de0:	00c10593          	addi	a1,sp,12
40023de4:	00048513          	mv	a0,s1
40023de8:	97ceb0ef          	jal	ra,4000ef64 <net_if_ipv4_addr_add>
40023dec:	400305b7          	lui	a1,0x40030
40023df0:	00c10613          	addi	a2,sp,12
40023df4:	78858593          	addi	a1,a1,1928 # 40030788 <eth_hw_caps+0x98>
40023df8:	00100513          	li	a0,1
40023dfc:	b50ec0ef          	jal	ra,4001014c <z_impl_net_addr_pton>
		if (net_addr_pton(AF_INET, CONFIG_NET_CONFIG_MY_IPV4_NETMASK,
40023e00:	00051863          	bnez	a0,40023e10 <net_config_init_by_iface+0xec>
			net_if_ipv4_set_netmask(iface, &addr);
40023e04:	00c10593          	addi	a1,sp,12
40023e08:	00048513          	mv	a0,s1
40023e0c:	8c4eb0ef          	jal	ra,4000eed0 <net_if_ipv4_set_netmask>
	services_notify_ready(NET_CONFIG_NEED_IPV4);
40023e10:	00400513          	li	a0,4
40023e14:	d25ff0ef          	jal	ra,40023b38 <services_notify_ready>
40023e18:	40033a37          	lui	s4,0x40033
40023e1c:	4002c5b7          	lui	a1,0x4002c
40023e20:	804a0613          	addi	a2,s4,-2044 # 40032804 <laddr>
40023e24:	d3858593          	addi	a1,a1,-712 # 4002bd38 <__clz_tab+0x10c>
40023e28:	00200513          	li	a0,2
40023e2c:	b20ec0ef          	jal	ra,4001014c <z_impl_net_addr_pton>
	cb->handler = handler;
40023e30:	40033537          	lui	a0,0x40033
40023e34:	400247b7          	lui	a5,0x40024
40023e38:	81450713          	addi	a4,a0,-2028 # 40032814 <mgmt6_cb>
40023e3c:	b6478793          	addi	a5,a5,-1180 # 40023b64 <ipv6_event_handler>
40023e40:	00f72223          	sw	a5,4(a4)
	cb->event_mask = mgmt_event_mask;
40023e44:	e06007b7          	lui	a5,0xe0600
40023e48:	00d78793          	addi	a5,a5,13 # e060000d <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe060000e>
	net_mgmt_add_event_callback(&mgmt6_cb);
40023e4c:	81450513          	addi	a0,a0,-2028
40023e50:	00f72423          	sw	a5,8(a4)
40023e54:	f85ec0ef          	jal	ra,40010dd8 <net_mgmt_add_event_callback>
		ifaddr = net_if_ipv6_addr_add(iface, &laddr,
40023e58:	804a0593          	addi	a1,s4,-2044
40023e5c:	00000693          	li	a3,0
40023e60:	00300613          	li	a2,3
40023e64:	00048513          	mv	a0,s1
40023e68:	c64e90ef          	jal	ra,4000d2cc <net_if_ipv6_addr_add>
	    net_if_flag_is_set(iface, NET_IF_IPV6_NO_ND)) {
40023e6c:	00b00593          	li	a1,11
40023e70:	00048513          	mv	a0,s1
40023e74:	df1ff0ef          	jal	ra,40023c64 <net_if_flag_is_set>
	if (!IS_ENABLED(CONFIG_NET_IPV6_DAD) ||
40023e78:	00050663          	beqz	a0,40023e84 <net_config_init_by_iface+0x160>
		services_notify_ready(NET_CONFIG_NEED_IPV6);
40023e7c:	00200513          	li	a0,2
40023e80:	cb9ff0ef          	jal	ra,40023b38 <services_notify_ready>
	if (timeout > 0 && count < 0) {
40023e84:	01305663          	blez	s3,40023e90 <net_config_init_by_iface+0x16c>
		return -ENETDOWN;
40023e88:	f8d00513          	li	a0,-115
	if (timeout > 0 && count < 0) {
40023e8c:	06044063          	bltz	s0,40023eec <net_config_init_by_iface+0x1c8>
		k_sem_take(&waiter, K_MSEC(loop));
40023e90:	00095463          	bgez	s2,40023e98 <net_config_init_by_iface+0x174>
40023e94:	00000913          	li	s2,0
			return t / ((uint64_t)from_hz / to_hz);
40023e98:	00990513          	addi	a0,s2,9
40023e9c:	00a00613          	li	a2,10
40023ea0:	00000693          	li	a3,0
40023ea4:	00000593          	li	a1,0
40023ea8:	c10dc0ef          	jal	ra,400002b8 <__udivdi3>
40023eac:	00050493          	mv	s1,a0
40023eb0:	00058913          	mv	s2,a1
	return (atomic_get(&services_flags) & flags) == flags;
40023eb4:	40031b37          	lui	s6,0x40031
	return z_impl_k_sem_take(sem, timeout);
40023eb8:	4003dbb7          	lui	s7,0x4003d
40023ebc:	ae4b0513          	addi	a0,s6,-1308 # 40030ae4 <services_flags>
40023ec0:	128070ef          	jal	ra,4002afe8 <atomic_get>
40023ec4:	00aaf533          	and	a0,s5,a0
	while (!services_are_ready(flags) && count-- > 0) {
40023ec8:	00aa8863          	beq	s5,a0,40023ed8 <net_config_init_by_iface+0x1b4>
40023ecc:	fff40a13          	addi	s4,s0,-1
40023ed0:	10804263          	bgtz	s0,40023fd4 <net_config_init_by_iface+0x2b0>
40023ed4:	000a0413          	mv	s0,s4
	if (count == -1 && timeout > 0) {
40023ed8:	fff00793          	li	a5,-1
	return 0;
40023edc:	00000513          	li	a0,0
	if (count == -1 && timeout > 0) {
40023ee0:	00f41663          	bne	s0,a5,40023eec <net_config_init_by_iface+0x1c8>
40023ee4:	01305463          	blez	s3,40023eec <net_config_init_by_iface+0x1c8>
		return -ETIMEDOUT;
40023ee8:	f8c00513          	li	a0,-116
}
40023eec:	03c12083          	lw	ra,60(sp)
40023ef0:	03812403          	lw	s0,56(sp)
40023ef4:	03412483          	lw	s1,52(sp)
40023ef8:	03012903          	lw	s2,48(sp)
40023efc:	02c12983          	lw	s3,44(sp)
40023f00:	02812a03          	lw	s4,40(sp)
40023f04:	02412a83          	lw	s5,36(sp)
40023f08:	02012b03          	lw	s6,32(sp)
40023f0c:	01c12b83          	lw	s7,28(sp)
40023f10:	01812c03          	lw	s8,24(sp)
40023f14:	01412c83          	lw	s9,20(sp)
40023f18:	01012d03          	lw	s10,16(sp)
40023f1c:	04010113          	addi	sp,sp,64
40023f20:	00008067          	ret
	cb->handler = handler;
40023f24:	40033b37          	lui	s6,0x40033
40023f28:	400247b7          	lui	a5,0x40024
40023f2c:	820b0713          	addi	a4,s6,-2016 # 40032820 <mgmt_iface_cb>
40023f30:	cec78793          	addi	a5,a5,-788 # 40023cec <iface_up_handler>
40023f34:	00f72223          	sw	a5,4(a4)
	cb->event_mask = mgmt_event_mask;
40023f38:	d00107b7          	lui	a5,0xd0010
40023f3c:	00278793          	addi	a5,a5,2 # d0010002 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd0010003>
	net_mgmt_add_event_callback(&mgmt_iface_cb);
40023f40:	820b0513          	addi	a0,s6,-2016
40023f44:	00f72423          	sw	a5,8(a4)
40023f48:	e91ec0ef          	jal	ra,40010dd8 <net_mgmt_add_event_callback>
	return z_impl_k_sem_init(sem, initial_count, limit);
40023f4c:	fff00613          	li	a2,-1
40023f50:	00100593          	li	a1,1
40023f54:	b44a0513          	addi	a0,s4,-1212
40023f58:	5f5040ef          	jal	ra,40028d4c <z_impl_k_sem_init>
			if (k_sem_take(&waiter, K_MSEC(loop))) {
40023f5c:	00090513          	mv	a0,s2
40023f60:	00095463          	bgez	s2,40023f68 <net_config_init_by_iface+0x244>
40023f64:	00000513          	li	a0,0
40023f68:	00a00613          	li	a2,10
40023f6c:	00000693          	li	a3,0
40023f70:	00950513          	addi	a0,a0,9
40023f74:	00000593          	li	a1,0
40023f78:	b40dc0ef          	jal	ra,400002b8 <__udivdi3>
40023f7c:	00050b93          	mv	s7,a0
40023f80:	00058c13          	mv	s8,a1
	return sem->count;
40023f84:	b44a0a13          	addi	s4,s4,-1212
	return z_impl_k_sem_take(sem, timeout);
40023f88:	4003dd37          	lui	s10,0x4003d
		while (count-- > 0) {
40023f8c:	fff40c93          	addi	s9,s0,-1
40023f90:	00805663          	blez	s0,40023f9c <net_config_init_by_iface+0x278>
			if (!k_sem_count_get(&counter)) {
40023f94:	008a2783          	lw	a5,8(s4)
40023f98:	00079a63          	bnez	a5,40023fac <net_config_init_by_iface+0x288>
		net_mgmt_del_event_callback(&mgmt_iface_cb);
40023f9c:	820b0513          	addi	a0,s6,-2016
40023fa0:	eadec0ef          	jal	ra,40010e4c <net_mgmt_del_event_callback>
40023fa4:	000c8413          	mv	s0,s9
40023fa8:	e19ff06f          	j	40023dc0 <net_config_init_by_iface+0x9c>
40023fac:	000b8593          	mv	a1,s7
40023fb0:	000c0613          	mv	a2,s8
40023fb4:	b74d0513          	addi	a0,s10,-1164 # 4003cb74 <waiter>
40023fb8:	63d040ef          	jal	ra,40028df4 <z_impl_k_sem_take>
			if (k_sem_take(&waiter, K_MSEC(loop))) {
40023fbc:	00051663          	bnez	a0,40023fc8 <net_config_init_by_iface+0x2a4>
		while (count-- > 0) {
40023fc0:	000c8413          	mv	s0,s9
40023fc4:	fc9ff06f          	j	40023f8c <net_config_init_by_iface+0x268>
				if (!k_sem_count_get(&counter)) {
40023fc8:	008a2783          	lw	a5,8(s4)
40023fcc:	fe079ae3          	bnez	a5,40023fc0 <net_config_init_by_iface+0x29c>
40023fd0:	fcdff06f          	j	40023f9c <net_config_init_by_iface+0x278>
40023fd4:	00048593          	mv	a1,s1
40023fd8:	00090613          	mv	a2,s2
40023fdc:	b74b8513          	addi	a0,s7,-1164 # 4003cb74 <waiter>
40023fe0:	615040ef          	jal	ra,40028df4 <z_impl_k_sem_take>
	while (!services_are_ready(flags) && count-- > 0) {
40023fe4:	000a0413          	mv	s0,s4
40023fe8:	ed5ff06f          	j	40023ebc <net_config_init_by_iface+0x198>

40023fec <net_config_init_app>:

int net_config_init_app(const struct device *dev, const char *app_info)
{
40023fec:	fe010113          	addi	sp,sp,-32
40023ff0:	00812c23          	sw	s0,24(sp)
40023ff4:	00112e23          	sw	ra,28(sp)
	struct net_if *iface = NULL;
40023ff8:	00012623          	sw	zero,12(sp)
{
40023ffc:	00058413          	mv	s0,a1
	uint32_t flags = 0U;
	int ret;

	if (dev) {
40024000:	02051e63          	bnez	a0,4002403c <net_config_init_app+0x50>
		flags |= NET_CONFIG_NEED_IPV4;
	}

	/* Only try to use a network interface that is auto started */
	if (iface == NULL) {
		net_if_foreach(iface_find_cb, &iface);
40024004:	40024537          	lui	a0,0x40024
40024008:	00c10593          	addi	a1,sp,12
4002400c:	ca450513          	addi	a0,a0,-860 # 40023ca4 <iface_find_cb>
40024010:	e14eb0ef          	jal	ra,4000f624 <net_if_foreach>
	}

	/* Initialize the application automatically if needed */
	ret = net_config_init_by_iface(iface, app_info, flags,
40024014:	00c12503          	lw	a0,12(sp)
40024018:	000076b7          	lui	a3,0x7
4002401c:	00040593          	mv	a1,s0
40024020:	53068693          	addi	a3,a3,1328 # 7530 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3530>
40024024:	00000613          	li	a2,0
40024028:	cfdff0ef          	jal	ra,40023d24 <net_config_init_by_iface>
			log_backend_activate(backend, NULL);
		}
	}

	return ret;
}
4002402c:	01c12083          	lw	ra,28(sp)
40024030:	01812403          	lw	s0,24(sp)
40024034:	02010113          	addi	sp,sp,32
40024038:	00008067          	ret
		iface = net_if_lookup_by_dev(dev);
4002403c:	b4de80ef          	jal	ra,4000cb88 <net_if_lookup_by_dev>
40024040:	00a12623          	sw	a0,12(sp)
	if (iface == NULL) {
40024044:	fc0518e3          	bnez	a0,40024014 <net_config_init_app+0x28>
40024048:	fbdff06f          	j	40024004 <net_config_init_app+0x18>

4002404c <init_app>:

#if defined(CONFIG_NET_CONFIG_AUTO_INIT)
static int init_app(void)
{

	(void)net_config_init_app(NULL, "Initializing network");
4002404c:	400305b7          	lui	a1,0x40030
{
40024050:	ff010113          	addi	sp,sp,-16
	(void)net_config_init_app(NULL, "Initializing network");
40024054:	79858593          	addi	a1,a1,1944 # 40030798 <eth_hw_caps+0xa8>
40024058:	00000513          	li	a0,0
{
4002405c:	00112623          	sw	ra,12(sp)
	(void)net_config_init_app(NULL, "Initializing network");
40024060:	f8dff0ef          	jal	ra,40023fec <net_config_init_app>

	return 0;
}
40024064:	00c12083          	lw	ra,12(sp)
40024068:	00000513          	li	a0,0
4002406c:	01010113          	addi	sp,sp,16
40024070:	00008067          	ret

40024074 <dns_msg_pack_qname>:

#include "dns_internal.h"

static inline uint16_t dns_strlen(const char *str)
{
	if (str == NULL) {
40024074:	00069663          	bnez	a3,40024080 <dns_msg_pack_qname+0xc>
	lb_index = 1U;
	lb_size = 0U;

	dn_size = dns_strlen(domain_name);
	if (dn_size == 0U) {
		return -EINVAL;
40024078:	fea00513          	li	a0,-22
	}

	*len = lb_index;

	return 0;
}
4002407c:	00008067          	ret
{
40024080:	fe010113          	addi	sp,sp,-32
40024084:	01312623          	sw	s3,12(sp)
40024088:	00050993          	mv	s3,a0
	return (uint16_t)strlen(str);
4002408c:	00068513          	mv	a0,a3
{
40024090:	00812c23          	sw	s0,24(sp)
40024094:	00912a23          	sw	s1,20(sp)
40024098:	01212823          	sw	s2,16(sp)
4002409c:	00068493          	mv	s1,a3
400240a0:	00112e23          	sw	ra,28(sp)
400240a4:	00058413          	mv	s0,a1
400240a8:	00060913          	mv	s2,a2
	return (uint16_t)strlen(str);
400240ac:	e7de40ef          	jal	ra,40008f28 <strlen>
400240b0:	01051693          	slli	a3,a0,0x10
400240b4:	0106d693          	srli	a3,a3,0x10
		return -EINVAL;
400240b8:	fea00513          	li	a0,-22
	if (dn_size == 0U) {
400240bc:	00068863          	beqz	a3,400240cc <dns_msg_pack_qname+0x58>
		if (lb_index >= size) {
400240c0:	00100793          	li	a5,1
400240c4:	0727ea63          	bltu	a5,s2,40024138 <dns_msg_pack_qname+0xc4>
			return -ENOMEM;
400240c8:	ff400513          	li	a0,-12
}
400240cc:	01c12083          	lw	ra,28(sp)
400240d0:	01812403          	lw	s0,24(sp)
400240d4:	01412483          	lw	s1,20(sp)
400240d8:	01012903          	lw	s2,16(sp)
400240dc:	00c12983          	lw	s3,12(sp)
400240e0:	02010113          	addi	sp,sp,32
400240e4:	00008067          	ret
		if (lb_index >= size) {
400240e8:	00170713          	addi	a4,a4,1
400240ec:	01071613          	slli	a2,a4,0x10
400240f0:	01065613          	srli	a2,a2,0x10
400240f4:	fd267ae3          	bgeu	a2,s2,400240c8 <dns_msg_pack_qname+0x54>
		switch (domain_name[i]) {
400240f8:	00e48633          	add	a2,s1,a4
400240fc:	fff64603          	lbu	a2,-1(a2)
40024100:	01071593          	slli	a1,a4,0x10
40024104:	0105d593          	srli	a1,a1,0x10
40024108:	04060c63          	beqz	a2,40024160 <dns_msg_pack_qname+0xec>
4002410c:	04a60063          	beq	a2,a0,4002414c <dns_msg_pack_qname+0xd8>
			lb_size += 1U;
40024110:	00178793          	addi	a5,a5,1
			buf[lb_index] = domain_name[i];
40024114:	00e408b3          	add	a7,s0,a4
			lb_size += 1U;
40024118:	01079793          	slli	a5,a5,0x10
			buf[lb_index] = domain_name[i];
4002411c:	00c88023          	sb	a2,0(a7)
			lb_size += 1U;
40024120:	0107d793          	srli	a5,a5,0x10
	for (i = 0U; i < dn_size + 1; i++) {
40024124:	fcb6f2e3          	bgeu	a3,a1,400240e8 <dns_msg_pack_qname+0x74>
		lb_index += 1U;
40024128:	00158593          	addi	a1,a1,1
	*len = lb_index;
4002412c:	00b99023          	sh	a1,0(s3)
	return 0;
40024130:	00000513          	li	a0,0
40024134:	f99ff06f          	j	400240cc <dns_msg_pack_qname+0x58>
		if (lb_index >= size) {
40024138:	00100713          	li	a4,1
	lb_size = 0U;
4002413c:	00000793          	li	a5,0
	lb_start = 0U;
40024140:	00000813          	li	a6,0
		switch (domain_name[i]) {
40024144:	02e00513          	li	a0,46
40024148:	fb1ff06f          	j	400240f8 <dns_msg_pack_qname+0x84>
			buf[lb_start] = lb_size;
4002414c:	01040833          	add	a6,s0,a6
40024150:	00f80023          	sb	a5,0(a6)
			break;
40024154:	00058813          	mv	a6,a1
			lb_size = 0U;
40024158:	00000793          	li	a5,0
			break;
4002415c:	fc9ff06f          	j	40024124 <dns_msg_pack_qname+0xb0>
			buf[lb_start] = lb_size;
40024160:	01040633          	add	a2,s0,a6
40024164:	00f60023          	sb	a5,0(a2)
			buf[lb_index] = 0U;
40024168:	00e40633          	add	a2,s0,a4
4002416c:	00060023          	sb	zero,0(a2)
			break;
40024170:	fb5ff06f          	j	40024124 <dns_msg_pack_qname+0xb0>

40024174 <dns_unpack_answer>:
	uint16_t rem_size;
	uint16_t pos;
	uint16_t len;
	uint8_t *answer;

	answer = dns_msg->msg + dns_msg->answer_offset;
40024174:	00e55883          	lhu	a7,14(a0)
40024178:	00052783          	lw	a5,0(a0)

	dname_len = skip_fqdn(answer,
			      dns_msg->msg_size - dns_msg->answer_offset);
4002417c:	01055803          	lhu	a6,16(a0)
	int i = 0;
40024180:	00000713          	li	a4,0
	answer = dns_msg->msg + dns_msg->answer_offset;
40024184:	011787b3          	add	a5,a5,a7
		} else if (answer[i] >= 0xc0) {
40024188:	0bf00313          	li	t1,191
	dname_len = skip_fqdn(answer,
4002418c:	411808b3          	sub	a7,a6,a7
		} else if (answer[i] < DNS_LABEL_MAX_SIZE) {
40024190:	03e00e13          	li	t3,62
		if (i >= buf_sz) {
40024194:	11175863          	bge	a4,a7,400242a4 <dns_unpack_answer+0x130>
		if (answer[i] == 0) {
40024198:	00e785b3          	add	a1,a5,a4
4002419c:	0005c583          	lbu	a1,0(a1)
400241a0:	0e059c63          	bnez	a1,40024298 <dns_unpack_answer+0x124>
			i += 1;
400241a4:	00170713          	addi	a4,a4,1
	 *
	 * So, answer size >= 12
	 *
	 * See RFC-1035 4.1.3. Resource record format
	 */
	rem_size = dns_msg->msg_size - dname_len;
400241a8:	01071313          	slli	t1,a4,0x10
400241ac:	01035313          	srli	t1,t1,0x10
400241b0:	40680833          	sub	a6,a6,t1
	if (rem_size < 2 + 2 + 4 + 2) {
400241b4:	01081813          	slli	a6,a6,0x10
400241b8:	01085813          	srli	a6,a6,0x10
400241bc:	00900593          	li	a1,9
400241c0:	0f05f263          	bgeu	a1,a6,400242a4 <dns_unpack_answer+0x130>
	}

	/* Only DNS_CLASS_IN answers. If mDNS is enabled, strip away the
	 * Cache-Flush bit (highest one).
	 */
	if ((dns_answer_class(dname_len, answer) &
400241c4:	00e787b3          	add	a5,a5,a4
400241c8:	0037c803          	lbu	a6,3(a5)
400241cc:	0027c703          	lbu	a4,2(a5)
400241d0:	00881813          	slli	a6,a6,0x8
400241d4:	00e86833          	or	a6,a6,a4
400241d8:	10000713          	li	a4,256
400241dc:	0ce81463          	bne	a6,a4,400242a4 <dns_unpack_answer+0x130>
	return ntohs(UNALIGNED_GET((uint16_t *)(answer + dname_size + 2)));
}

static inline int dns_answer_ttl(uint16_t dname_size, uint8_t *answer)
{
	return ntohl(UNALIGNED_GET((uint32_t *)(answer + dname_size + 4)));
400241e0:	0057c703          	lbu	a4,5(a5)
400241e4:	0047c583          	lbu	a1,4(a5)
400241e8:	00010e37          	lui	t3,0x10
400241ec:	00871713          	slli	a4,a4,0x8
400241f0:	00b76733          	or	a4,a4,a1
400241f4:	0067c583          	lbu	a1,6(a5)
400241f8:	f00e0e13          	addi	t3,t3,-256 # ff00 <__kernel_ram_size+0x3c6c>
400241fc:	01059593          	slli	a1,a1,0x10
40024200:	00e5e5b3          	or	a1,a1,a4
40024204:	0077c703          	lbu	a4,7(a5)
40024208:	01871713          	slli	a4,a4,0x18
4002420c:	00b768b3          	or	a7,a4,a1
40024210:	01859593          	slli	a1,a1,0x18
40024214:	01875713          	srli	a4,a4,0x18
40024218:	00b76733          	or	a4,a4,a1
4002421c:	0088d593          	srli	a1,a7,0x8
40024220:	01c5f5b3          	and	a1,a1,t3
40024224:	00b76733          	or	a4,a4,a1
40024228:	00889893          	slli	a7,a7,0x8
4002422c:	00ff05b7          	lui	a1,0xff0
40024230:	00b8f8b3          	and	a7,a7,a1
40024234:	01176733          	or	a4,a4,a7
							!= DNS_CLASS_IN) {
		return -EINVAL;
	}

	/* TTL value */
	*ttl = dns_answer_ttl(dname_len, answer);
40024238:	00e62023          	sw	a4,0(a2)
}

static inline int dns_answer_rdlength(uint16_t dname_size,
					     uint8_t *answer)
{
	return ntohs(UNALIGNED_GET((uint16_t *)(answer + dname_size + 8)));
4002423c:	0097c703          	lbu	a4,9(a5)
40024240:	0087c603          	lbu	a2,8(a5)
	len = dns_answer_rdlength(dname_len, answer);
	pos = dns_msg->answer_offset + dname_len +
40024244:	00e55583          	lhu	a1,14(a0)
40024248:	00871713          	slli	a4,a4,0x8
4002424c:	00c76733          	or	a4,a4,a2
	return ntohs(UNALIGNED_GET((uint16_t *)(answer + dname_size + 0)));
40024250:	0007c603          	lbu	a2,0(a5)
40024254:	0017c783          	lbu	a5,1(a5)
40024258:	00879793          	slli	a5,a5,0x8
4002425c:	00c7e7b3          	or	a5,a5,a2
		DNS_COMMON_UINT_SIZE + /* class length */
		DNS_COMMON_UINT_SIZE + /* type length */
		DNS_TTL_LEN +
		DNS_RDLENGTH_LEN;
	*type = dns_answer_type(dname_len, answer);
40024260:	00879613          	slli	a2,a5,0x8
40024264:	0087d893          	srli	a7,a5,0x8
40024268:	01166633          	or	a2,a2,a7
4002426c:	01061613          	slli	a2,a2,0x10
40024270:	01065613          	srli	a2,a2,0x10
40024274:	00c6a023          	sw	a2,0(a3)

	switch (*type) {
40024278:	50000693          	li	a3,1280
4002427c:	04d78263          	beq	a5,a3,400242c0 <dns_unpack_answer+0x14c>
40024280:	000026b7          	lui	a3,0x2
40024284:	c0068693          	addi	a3,a3,-1024 # 1c00 <CONFIG_HEAP_MEM_POOL_SIZE+0xc00>
40024288:	00d78463          	beq	a5,a3,40024290 <dns_unpack_answer+0x11c>
4002428c:	01079c63          	bne	a5,a6,400242a4 <dns_unpack_answer+0x130>
40024290:	feb00793          	li	a5,-21
40024294:	0300006f          	j	400242c4 <dns_unpack_answer+0x150>
		} else if (answer[i] >= 0xc0) {
40024298:	00b37a63          	bgeu	t1,a1,400242ac <dns_unpack_answer+0x138>
			i += 2;
4002429c:	00270713          	addi	a4,a4,2
			if (i > buf_sz) {
400242a0:	f0e8d4e3          	bge	a7,a4,400241a8 <dns_unpack_answer+0x34>
	switch (*type) {
400242a4:	fea00513          	li	a0,-22
400242a8:	00008067          	ret
		} else if (answer[i] < DNS_LABEL_MAX_SIZE) {
400242ac:	febe6ce3          	bltu	t3,a1,400242a4 <dns_unpack_answer+0x130>
			i += answer[i] + 1;
400242b0:	00158593          	addi	a1,a1,1 # ff0001 <__rom_region_size+0xfbf625>
400242b4:	0ff5f593          	zext.b	a1,a1
400242b8:	00b70733          	add	a4,a4,a1
		if (i >= buf_sz) {
400242bc:	ed9ff06f          	j	40024194 <dns_unpack_answer+0x20>
	switch (*type) {
400242c0:	fed00793          	li	a5,-19
	dns_msg->response_type = type;
400242c4:	00f52223          	sw	a5,4(a0)
	pos = dns_msg->answer_offset + dname_len +
400242c8:	00a58793          	addi	a5,a1,10
400242cc:	00f30333          	add	t1,t1,a5
	dns_msg->response_length = len;
400242d0:	00871793          	slli	a5,a4,0x8
400242d4:	00875713          	srli	a4,a4,0x8
400242d8:	00e7e7b3          	or	a5,a5,a4
	dns_msg->response_position = pos;
400242dc:	00651423          	sh	t1,8(a0)
	dns_msg->response_length = len;
400242e0:	00f51523          	sh	a5,10(a0)
	case DNS_RR_TYPE_A:
	case DNS_RR_TYPE_AAAA:
		set_dns_msg_response(dns_msg, DNS_RESPONSE_IP, pos, len);
		return 0;
400242e4:	00000513          	li	a0,0
		/* malformed dns answer */
		return -EINVAL;
	}

	return 0;
}
400242e8:	00008067          	ret

400242ec <dns_unpack_response_header>:
	int rc;

	dns_header = msg->msg;
	size = msg->msg_size;

	if (size < DNS_MSG_HEADER_SIZE) {
400242ec:	01055683          	lhu	a3,16(a0)
400242f0:	00b00713          	li	a4,11
	dns_header = msg->msg;
400242f4:	00052783          	lw	a5,0(a0)
	if (size < DNS_MSG_HEADER_SIZE) {
400242f8:	08d77e63          	bgeu	a4,a3,40024394 <dns_unpack_response_header+0xa8>
	return ntohs(UNALIGNED_GET((uint16_t *)(header)));
400242fc:	0017c703          	lbu	a4,1(a5)
40024300:	0007c683          	lbu	a3,0(a5)
		return -ENOMEM;
	}

	if (dns_unpack_header_id(dns_header) != src_id) {
		return -EINVAL;
40024304:	fea00513          	li	a0,-22
40024308:	00871713          	slli	a4,a4,0x8
4002430c:	00d76733          	or	a4,a4,a3
40024310:	00871693          	slli	a3,a4,0x8
40024314:	00875713          	srli	a4,a4,0x8
40024318:	00e6e733          	or	a4,a3,a4
4002431c:	01071713          	slli	a4,a4,0x10
40024320:	01075713          	srli	a4,a4,0x10
	if (dns_unpack_header_id(dns_header) != src_id) {
40024324:	06e59663          	bne	a1,a4,40024390 <dns_unpack_response_header+0xa4>
	return ((*(header + 2)) & 0x80) ? 1 : 0;
40024328:	0027c703          	lbu	a4,2(a5)
	}

	if (dns_header_qr(dns_header) != DNS_RESPONSE) {
4002432c:	00775693          	srli	a3,a4,0x7
40024330:	06068063          	beqz	a3,40024390 <dns_unpack_response_header+0xa4>
	return ((*(header + 2)) & 0x70) >> 1;
40024334:	40175713          	srai	a4,a4,0x1
40024338:	03877713          	andi	a4,a4,56
		return -EINVAL;
	}

	if (dns_header_opcode(dns_header) != DNS_QUERY) {
4002433c:	04071a63          	bnez	a4,40024390 <dns_unpack_response_header+0xa4>
	return ((*(header + 3)) & 0x70) >> 4;
40024340:	0037c703          	lbu	a4,3(a5)
40024344:	40475513          	srai	a0,a4,0x4
40024348:	00757513          	andi	a0,a0,7
		return -EINVAL;
	}

	if (dns_header_z(dns_header) != 0) {
4002434c:	04051063          	bnez	a0,4002438c <dns_unpack_response_header+0xa0>
	return ((*(header + 3)) & 0x0F);
40024350:	00f77713          	andi	a4,a4,15
		return -EINVAL;
	}

	rc = dns_header_rcode(dns_header);
	switch (rc) {
40024354:	00070663          	beqz	a4,40024360 <dns_unpack_response_header+0x74>
40024358:	00070513          	mv	a0,a4
4002435c:	00008067          	ret
	return ntohs(UNALIGNED_GET((uint16_t *)(header + 6)));
40024360:	0077c703          	lbu	a4,7(a5)
40024364:	0067c683          	lbu	a3,6(a5)
40024368:	00871713          	slli	a4,a4,0x8
4002436c:	00d76733          	or	a4,a4,a3
	ancount = dns_unpack_header_ancount(dns_header);

	/* For mDNS (when src_id == 0) the query count is 0 so accept
	 * the packet in that case.
	 */
	if ((qdcount < 1 && src_id > 0) || ancount < 1) {
40024370:	0047c683          	lbu	a3,4(a5)
40024374:	0057c783          	lbu	a5,5(a5)
40024378:	00879793          	slli	a5,a5,0x8
4002437c:	00d7e7b3          	or	a5,a5,a3
40024380:	00079463          	bnez	a5,40024388 <dns_unpack_response_header+0x9c>
40024384:	00059463          	bnez	a1,4002438c <dns_unpack_response_header+0xa0>
40024388:	00071463          	bnez	a4,40024390 <dns_unpack_response_header+0xa4>
		return -EINVAL;
4002438c:	fea00513          	li	a0,-22
		return -EINVAL;
	}

	return 0;
}
40024390:	00008067          	ret
		return -ENOMEM;
40024394:	ff400513          	li	a0,-12
40024398:	00008067          	ret

4002439c <dns_msg_pack_query>:
}

int dns_msg_pack_query(uint8_t *buf, uint16_t *len, uint16_t size,
		       uint8_t *qname, uint16_t qname_len, uint16_t id,
		       enum dns_rr_type qtype)
{
4002439c:	fe010113          	addi	sp,sp,-32
400243a0:	01512223          	sw	s5,4(sp)
400243a4:	00112e23          	sw	ra,28(sp)
400243a8:	00812c23          	sw	s0,24(sp)
400243ac:	00912a23          	sw	s1,20(sp)
400243b0:	01212823          	sw	s2,16(sp)
400243b4:	01312623          	sw	s3,12(sp)
400243b8:	01412423          	sw	s4,8(sp)
	uint16_t msg_size;
	uint16_t offset;
	int rc;

	msg_size = DNS_MSG_HEADER_SIZE + DNS_QTYPE_LEN + DNS_QCLASS_LEN;
	if (msg_size + qname_len > size) {
400243bc:	01070a93          	addi	s5,a4,16
400243c0:	0f564663          	blt	a2,s5,400244ac <dns_msg_pack_query+0x110>
400243c4:	00070493          	mv	s1,a4
	UNALIGNED_PUT(htons(id), (uint16_t *)(buf));
400243c8:	00879713          	slli	a4,a5,0x8
400243cc:	0087d793          	srli	a5,a5,0x8
400243d0:	00f767b3          	or	a5,a4,a5
400243d4:	01079713          	slli	a4,a5,0x10
400243d8:	01075713          	srli	a4,a4,0x10
400243dc:	00f50023          	sb	a5,0(a0)
	*(buf + offset) = DNS_FLAGS1;		/* QR, Opcode, AA, TC and RD */
400243e0:	00100a13          	li	s4,1
	UNALIGNED_PUT(htons(id), (uint16_t *)(buf));
400243e4:	00875793          	srli	a5,a4,0x8
400243e8:	00050413          	mv	s0,a0
400243ec:	00f500a3          	sb	a5,1(a0)
400243f0:	00058993          	mv	s3,a1
	*(buf + offset) = DNS_FLAGS1;		/* QR, Opcode, AA, TC and RD */
400243f4:	01450123          	sb	s4,2(a0)
400243f8:	00068593          	mv	a1,a3
	*(buf + offset + 1) = DNS_FLAGS2;	/* RA, Z and RCODE */
400243fc:	000501a3          	sb	zero,3(a0)
	UNALIGNED_PUT(htons(1), (uint16_t *)(buf + offset));
40024400:	00050223          	sb	zero,4(a0)
40024404:	014502a3          	sb	s4,5(a0)
	UNALIGNED_PUT(0, (uint32_t *)(buf + offset));
40024408:	00050323          	sb	zero,6(a0)
4002440c:	000503a3          	sb	zero,7(a0)
40024410:	00050423          	sb	zero,8(a0)
40024414:	000504a3          	sb	zero,9(a0)
	UNALIGNED_PUT(0, (uint16_t *)(buf + offset));
40024418:	00050523          	sb	zero,10(a0)
4002441c:	000505a3          	sb	zero,11(a0)
	if (rc != 0) {
		return rc;
	}

	offset = DNS_MSG_HEADER_SIZE;
	memcpy(buf + offset, qname, qname_len);
40024420:	00048613          	mv	a2,s1
40024424:	00c50513          	addi	a0,a0,12
40024428:	00080913          	mv	s2,a6
4002442c:	c21e40ef          	jal	ra,4000904c <memcpy>

	offset += qname_len;

	/* QType */
	UNALIGNED_PUT(htons(qtype), (uint16_t *)(buf + offset + 0));
40024430:	00891713          	slli	a4,s2,0x8
40024434:	01091913          	slli	s2,s2,0x10
40024438:	01095913          	srli	s2,s2,0x10
	offset += qname_len;
4002443c:	00c48793          	addi	a5,s1,12
	UNALIGNED_PUT(htons(qtype), (uint16_t *)(buf + offset + 0));
40024440:	00895913          	srli	s2,s2,0x8
40024444:	01276733          	or	a4,a4,s2
40024448:	01079793          	slli	a5,a5,0x10
4002444c:	01071693          	slli	a3,a4,0x10
40024450:	0107d793          	srli	a5,a5,0x10
	offset += DNS_QTYPE_LEN;
40024454:	00e48493          	addi	s1,s1,14
	UNALIGNED_PUT(htons(qtype), (uint16_t *)(buf + offset + 0));
40024458:	00f407b3          	add	a5,s0,a5
4002445c:	0106d693          	srli	a3,a3,0x10

	/* QClass */
	UNALIGNED_PUT(htons(DNS_CLASS_IN), (uint16_t *)(buf + offset));
40024460:	01049493          	slli	s1,s1,0x10
	UNALIGNED_PUT(htons(qtype), (uint16_t *)(buf + offset + 0));
40024464:	00e78023          	sb	a4,0(a5)
	UNALIGNED_PUT(htons(DNS_CLASS_IN), (uint16_t *)(buf + offset));
40024468:	0104d493          	srli	s1,s1,0x10
	UNALIGNED_PUT(htons(qtype), (uint16_t *)(buf + offset + 0));
4002446c:	0086d713          	srli	a4,a3,0x8
40024470:	00e780a3          	sb	a4,1(a5)
	UNALIGNED_PUT(htons(DNS_CLASS_IN), (uint16_t *)(buf + offset));
40024474:	00940433          	add	s0,s0,s1
40024478:	00040023          	sb	zero,0(s0)
4002447c:	014400a3          	sb	s4,1(s0)

	*len = offset + DNS_QCLASS_LEN;
40024480:	01599023          	sh	s5,0(s3)

	return 0;
40024484:	00000513          	li	a0,0
}
40024488:	01c12083          	lw	ra,28(sp)
4002448c:	01812403          	lw	s0,24(sp)
40024490:	01412483          	lw	s1,20(sp)
40024494:	01012903          	lw	s2,16(sp)
40024498:	00c12983          	lw	s3,12(sp)
4002449c:	00812a03          	lw	s4,8(sp)
400244a0:	00412a83          	lw	s5,4(sp)
400244a4:	02010113          	addi	sp,sp,32
400244a8:	00008067          	ret
		return -ENOMEM;
400244ac:	ff400513          	li	a0,-12
400244b0:	fd9ff06f          	j	40024488 <dns_msg_pack_query+0xec>

400244b4 <dns_unpack_response_query>:
	int offset;
	int rc;

	dns_msg->query_offset = DNS_MSG_HEADER_SIZE;
	dns_query = dns_msg->msg + dns_msg->query_offset;
	remaining_size = dns_msg->msg_size - dns_msg->query_offset;
400244b4:	01055803          	lhu	a6,16(a0)
	dns_query = dns_msg->msg + dns_msg->query_offset;
400244b8:	00052703          	lw	a4,0(a0)
	dns_msg->query_offset = DNS_MSG_HEADER_SIZE;
400244bc:	00c00793          	li	a5,12

	rc = dns_find_null(&qname_size, dns_query, remaining_size);
400244c0:	ff480613          	addi	a2,a6,-12
400244c4:	01061613          	slli	a2,a2,0x10
	dns_msg->query_offset = DNS_MSG_HEADER_SIZE;
400244c8:	00f51623          	sh	a5,12(a0)
{
400244cc:	00050693          	mv	a3,a0
	rc = dns_find_null(&qname_size, dns_query, remaining_size);
400244d0:	01065613          	srli	a2,a2,0x10
	*qname_size = 0;
400244d4:	00000793          	li	a5,0
	while (*qname_size < size) {
400244d8:	00c7c663          	blt	a5,a2,400244e4 <dns_unpack_response_query+0x30>
	return -ENOMEM;
400244dc:	ff400513          	li	a0,-12
400244e0:	00008067          	ret
		if (buf[(*qname_size)++] == 0x00) {
400244e4:	00178593          	addi	a1,a5,1
400244e8:	00b70533          	add	a0,a4,a1
400244ec:	00b54503          	lbu	a0,11(a0)
400244f0:	06050c63          	beqz	a0,40024568 <dns_unpack_response_query+0xb4>
400244f4:	00058793          	mv	a5,a1
400244f8:	fe1ff06f          	j	400244d8 <dns_unpack_response_query+0x24>
	offset += DNS_QTYPE_LEN + DNS_QCLASS_LEN;
	if (offset >= dns_msg->msg_size) {
		return -ENOMEM;
	}

	buf = dns_query + qname_size;
400244fc:	00d78793          	addi	a5,a5,13
40024500:	00f70733          	add	a4,a4,a5
	return ntohs(UNALIGNED_GET((uint16_t *)(question + 0)));
40024504:	00174783          	lbu	a5,1(a4)
40024508:	00074603          	lbu	a2,0(a4)
4002450c:	00879793          	slli	a5,a5,0x8
40024510:	00c7e7b3          	or	a5,a5,a2
40024514:	00879613          	slli	a2,a5,0x8
40024518:	0087d793          	srli	a5,a5,0x8
4002451c:	00f667b3          	or	a5,a2,a5
40024520:	01079793          	slli	a5,a5,0x10
40024524:	0107d793          	srli	a5,a5,0x10
	if (dns_unpack_query_qtype(buf) != DNS_RR_TYPE_A &&
40024528:	00100613          	li	a2,1
4002452c:	00c78863          	beq	a5,a2,4002453c <dns_unpack_response_query+0x88>
40024530:	01c00613          	li	a2,28
	    dns_unpack_query_qtype(buf) != DNS_RR_TYPE_AAAA) {
		return -EINVAL;
40024534:	fea00513          	li	a0,-22
	if (dns_unpack_query_qtype(buf) != DNS_RR_TYPE_A &&
40024538:	02c79e63          	bne	a5,a2,40024574 <dns_unpack_response_query+0xc0>
	}

	if (dns_unpack_query_qclass(buf) != DNS_CLASS_IN) {
4002453c:	00374783          	lbu	a5,3(a4)
40024540:	00274603          	lbu	a2,2(a4)
40024544:	10000713          	li	a4,256
40024548:	00879793          	slli	a5,a5,0x8
4002454c:	00c7e7b3          	or	a5,a5,a2
		return -EINVAL;
40024550:	fea00513          	li	a0,-22
	if (dns_unpack_query_qclass(buf) != DNS_CLASS_IN) {
40024554:	02e79063          	bne	a5,a4,40024574 <dns_unpack_response_query+0xc0>
		return -EINVAL;
	}

	dns_msg->answer_offset = dns_msg->query_offset + qname_size +
				 DNS_QTYPE_LEN + DNS_QCLASS_LEN;
40024558:	01058593          	addi	a1,a1,16
	dns_msg->answer_offset = dns_msg->query_offset + qname_size +
4002455c:	00b69723          	sh	a1,14(a3)

	return 0;
40024560:	00000513          	li	a0,0
40024564:	00008067          	ret
	offset += DNS_QTYPE_LEN + DNS_QCLASS_LEN;
40024568:	01178613          	addi	a2,a5,17
	return -ENOMEM;
4002456c:	ff400513          	li	a0,-12
	if (offset >= dns_msg->msg_size) {
40024570:	f90646e3          	blt	a2,a6,400244fc <dns_unpack_response_query+0x48>
}
40024574:	00008067          	ret

40024578 <dns_copy_qname>:

int dns_copy_qname(uint8_t *buf, uint16_t *len, uint16_t size,
		   struct dns_msg_t *dns_msg, uint16_t pos)
{
40024578:	fd010113          	addi	sp,sp,-48
4002457c:	02812423          	sw	s0,40(sp)
40024580:	03212023          	sw	s2,32(sp)
40024584:	01312e23          	sw	s3,28(sp)
40024588:	01412c23          	sw	s4,24(sp)
4002458c:	01512a23          	sw	s5,20(sp)
40024590:	01612823          	sw	s6,16(sp)
40024594:	01712623          	sw	s7,12(sp)
40024598:	02112623          	sw	ra,44(sp)
4002459c:	02912223          	sw	s1,36(sp)
	uint16_t msg_size = dns_msg->msg_size;
400245a0:	0106da83          	lhu	s5,16(a3)
	uint8_t *msg = dns_msg->msg;
400245a4:	0006ab03          	lw	s6,0(a3)
{
400245a8:	00050993          	mv	s3,a0
400245ac:	00058913          	mv	s2,a1
400245b0:	00060a13          	mv	s4,a2
400245b4:	00070413          	mv	s0,a4
	uint16_t lb_size;
	int rc = -EINVAL;

	*len = 0U;
400245b8:	00059023          	sh	zero,0(a1)
		}

		lb_size = msg[pos];

		/* pointer */
		if (lb_size > DNS_LABEL_MAX_SIZE) {
400245bc:	03f00b93          	li	s7,63
		if (pos >= msg_size) {
400245c0:	09547c63          	bgeu	s0,s5,40024658 <dns_copy_qname+0xe0>
		lb_size = msg[pos];
400245c4:	008b05b3          	add	a1,s6,s0
400245c8:	0005c483          	lbu	s1,0(a1)
		if (lb_size > DNS_LABEL_MAX_SIZE) {
400245cc:	029bf063          	bgeu	s7,s1,400245ec <dns_copy_qname+0x74>
			uint8_t mask = DNS_LABEL_MAX_SIZE;

			if (pos + 1 >= msg_size) {
400245d0:	00140413          	addi	s0,s0,1
400245d4:	09545263          	bge	s0,s5,40024658 <dns_copy_qname+0xe0>
				rc = -ENOMEM;
				break;
			}

			/* See: RFC 1035, 4.1.4. Message compression */
			pos = ((msg[pos] & mask) << 8) + msg[pos + 1];
400245d8:	0015c403          	lbu	s0,1(a1)
400245dc:	03f4f493          	andi	s1,s1,63
400245e0:	00849493          	slli	s1,s1,0x8
400245e4:	00848433          	add	s0,s1,s0

			continue;
400245e8:	fd9ff06f          	j	400245c0 <dns_copy_qname+0x48>
		}

		/* validate that the label (i.e. size + elements),
		 * fits the current msg buffer
		 */
		if (DNS_LABEL_LEN_SIZE + lb_size > size - *len) {
400245ec:	00095503          	lhu	a0,0(s2)
400245f0:	40aa07b3          	sub	a5,s4,a0
400245f4:	06f4d263          	bge	s1,a5,40024658 <dns_copy_qname+0xe0>
			rc = -ENOMEM;
			break;
		}

		/* copy the lb_size value and label elements */
		memcpy(buf + *len, msg + pos, DNS_LABEL_LEN_SIZE + lb_size);
400245f8:	00148613          	addi	a2,s1,1
400245fc:	00a98533          	add	a0,s3,a0
40024600:	a4de40ef          	jal	ra,4000904c <memcpy>
		/* update destination buffer len */
		*len += DNS_LABEL_LEN_SIZE + lb_size;
40024604:	00095783          	lhu	a5,0(s2)
40024608:	00140413          	addi	s0,s0,1
		/* update msg ptr position */
		pos += DNS_LABEL_LEN_SIZE + lb_size;
4002460c:	00940433          	add	s0,s0,s1
		*len += DNS_LABEL_LEN_SIZE + lb_size;
40024610:	00178793          	addi	a5,a5,1
40024614:	00f487b3          	add	a5,s1,a5
		pos += DNS_LABEL_LEN_SIZE + lb_size;
40024618:	01041413          	slli	s0,s0,0x10
		*len += DNS_LABEL_LEN_SIZE + lb_size;
4002461c:	00f91023          	sh	a5,0(s2)
		pos += DNS_LABEL_LEN_SIZE + lb_size;
40024620:	01045413          	srli	s0,s0,0x10

		/* The domain name terminates with the zero length octet
		 * for the null label of the root
		 */
		if (lb_size == 0U) {
40024624:	f8049ee3          	bnez	s1,400245c0 <dns_copy_qname+0x48>
			rc = 0;
40024628:	00000513          	li	a0,0
			break;
		}
	}

	return rc;
}
4002462c:	02c12083          	lw	ra,44(sp)
40024630:	02812403          	lw	s0,40(sp)
40024634:	02412483          	lw	s1,36(sp)
40024638:	02012903          	lw	s2,32(sp)
4002463c:	01c12983          	lw	s3,28(sp)
40024640:	01812a03          	lw	s4,24(sp)
40024644:	01412a83          	lw	s5,20(sp)
40024648:	01012b03          	lw	s6,16(sp)
4002464c:	00c12b83          	lw	s7,12(sp)
40024650:	03010113          	addi	sp,sp,48
40024654:	00008067          	ret
			rc = -ENOMEM;
40024658:	ff400513          	li	a0,-12
	return rc;
4002465c:	fd1ff06f          	j	4002462c <dns_copy_qname+0xb4>

40024660 <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
40024660:	00054503          	lbu	a0,0(a0)
40024664:	f00007b7          	lui	a5,0xf0000
40024668:	01851513          	slli	a0,a0,0x18
4002466c:	00f57533          	and	a0,a0,a5
40024670:	200007b7          	lui	a5,0x20000
40024674:	00f50533          	add	a0,a0,a5
}
40024678:	00153513          	seqz	a0,a0
4002467c:	00008067          	ret

40024680 <invoke_query_callback>:
					 struct dns_pending_query *pending_query)
{
	/* Only notify if the slot is neither released nor in the process of
	 * being released.
	 */
	if (pending_query->query != NULL && pending_query->cb != NULL)  {
40024680:	04862783          	lw	a5,72(a2)
40024684:	00078a63          	beqz	a5,40024698 <invoke_query_callback+0x18>
40024688:	03462783          	lw	a5,52(a2)
4002468c:	00078663          	beqz	a5,40024698 <invoke_query_callback+0x18>
		pending_query->cb(status, info, pending_query->user_data);
40024690:	03862603          	lw	a2,56(a2)
40024694:	00078067          	jr	a5 # 20000000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1a0a1f00>
	}
}
40024698:	00008067          	ret

4002469c <get_slot_by_id>:

/* Must be invoked with context lock held */
static inline int get_slot_by_id(struct dns_resolve_context *ctx,
				 uint16_t dns_id,
				 uint16_t query_hash)
{
4002469c:	00050793          	mv	a5,a0
	if (pending_query->cb != NULL) {
400246a0:	0747a703          	lw	a4,116(a5)
	int i;

	for (i = 0; i < CONFIG_DNS_NUM_CONCUR_QUERIES; i++) {
400246a4:	00000513          	li	a0,0
	if (pending_query->cb != NULL) {
400246a8:	00070c63          	beqz	a4,400246c0 <get_slot_by_id+0x24>
		if (check_query_active(&ctx->queries[i], false) &&
400246ac:	0907d703          	lhu	a4,144(a5)
400246b0:	00b71863          	bne	a4,a1,400246c0 <get_slot_by_id+0x24>
		    ctx->queries[i].id == dns_id &&
400246b4:	00060863          	beqz	a2,400246c4 <get_slot_by_id+0x28>
		    (query_hash == 0 ||
400246b8:	0927d783          	lhu	a5,146(a5)
400246bc:	00c78463          	beq	a5,a2,400246c4 <get_slot_by_id+0x28>
		     ctx->queries[i].query_hash == query_hash)) {
			return i;
		}
	}

	return -ENOENT;
400246c0:	ffe00513          	li	a0,-2
}
400246c4:	00008067          	ret

400246c8 <k_mutex_lock>:
	return z_impl_k_mutex_lock(mutex, timeout);
400246c8:	1b40406f          	j	4002887c <z_impl_k_mutex_lock>

400246cc <release_query>:
{
400246cc:	ff010113          	addi	sp,sp,-16
400246d0:	00812423          	sw	s0,8(sp)
400246d4:	00112623          	sw	ra,12(sp)
400246d8:	00050413          	mv	s0,a0
	int busy = k_work_cancel_delayable(&pending_query->timer);
400246dc:	761040ef          	jal	ra,4002963c <k_work_cancel_delayable>
	if (busy == 0) {
400246e0:	00051c63          	bnez	a0,400246f8 <release_query+0x2c>
		pending_query->cb = NULL;
400246e4:	02042a23          	sw	zero,52(s0)
}
400246e8:	00c12083          	lw	ra,12(sp)
400246ec:	00812403          	lw	s0,8(sp)
400246f0:	01010113          	addi	sp,sp,16
400246f4:	00008067          	ret
		pending_query->query = NULL;
400246f8:	04042423          	sw	zero,72(s0)
}
400246fc:	fedff06f          	j	400246e8 <release_query+0x1c>

40024700 <dns_server_exists>:

static bool dns_server_exists(struct dns_resolve_context *ctx,
			      const struct sockaddr *addr)
{
	for (int i = 0; i < SERVER_COUNT; i++) {
		if (IS_ENABLED(CONFIG_NET_IPV4) && (addr->sa_family == AF_INET) &&
40024700:	0005d683          	lhu	a3,0(a1)
40024704:	00100813          	li	a6,1
{
40024708:	00050793          	mv	a5,a0
4002470c:	00058713          	mv	a4,a1
		if (IS_ENABLED(CONFIG_NET_IPV4) && (addr->sa_family == AF_INET) &&
40024710:	07069e63          	bne	a3,a6,4002478c <dns_server_exists+0x8c>
40024714:	00055603          	lhu	a2,0(a0)
				return true;
			}
		}
	}

	return false;
40024718:	00000513          	li	a0,0
		if (IS_ENABLED(CONFIG_NET_IPV4) && (addr->sa_family == AF_INET) &&
4002471c:	04d61e63          	bne	a2,a3,40024778 <dns_server_exists+0x78>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
40024720:	0055c603          	lbu	a2,5(a1)
40024724:	0045c683          	lbu	a3,4(a1)
40024728:	0075c703          	lbu	a4,7(a1)
4002472c:	00861613          	slli	a2,a2,0x8
40024730:	00d66633          	or	a2,a2,a3
40024734:	0065c683          	lbu	a3,6(a1)
40024738:	01871713          	slli	a4,a4,0x18
4002473c:	01069693          	slli	a3,a3,0x10
40024740:	00c6e6b3          	or	a3,a3,a2
40024744:	0057c603          	lbu	a2,5(a5)
40024748:	00d76733          	or	a4,a4,a3
4002474c:	0047c683          	lbu	a3,4(a5)
40024750:	00861613          	slli	a2,a2,0x8
40024754:	00d66633          	or	a2,a2,a3
40024758:	0067c683          	lbu	a3,6(a5)
4002475c:	0077c783          	lbu	a5,7(a5)
40024760:	01069693          	slli	a3,a3,0x10
40024764:	00c6e6b3          	or	a3,a3,a2
40024768:	01879793          	slli	a5,a5,0x18
4002476c:	00d7e7b3          	or	a5,a5,a3
			if (net_ipv4_addr_cmp(&net_sin(addr)->sin_addr,
40024770:	00f71463          	bne	a4,a5,40024778 <dns_server_exists+0x78>
				return true;
40024774:	00100513          	li	a0,1
}
40024778:	00008067          	ret
				return true;
4002477c:	00100513          	li	a0,1
}
40024780:	00c12083          	lw	ra,12(sp)
40024784:	01010113          	addi	sp,sp,16
40024788:	00008067          	ret
4002478c:	00200613          	li	a2,2
		if (IS_ENABLED(CONFIG_NET_IPV6) && (addr->sa_family == AF_INET6) &&
40024790:	02c69863          	bne	a3,a2,400247c0 <dns_server_exists+0xc0>
40024794:	00055783          	lhu	a5,0(a0)
40024798:	02d79463          	bne	a5,a3,400247c0 <dns_server_exists+0xc0>
{
4002479c:	ff010113          	addi	sp,sp,-16
400247a0:	00450593          	addi	a1,a0,4
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
400247a4:	01000613          	li	a2,16
400247a8:	00470513          	addi	a0,a4,4
400247ac:	00112623          	sw	ra,12(sp)
400247b0:	81de40ef          	jal	ra,40008fcc <memcmp>
			if (net_ipv6_addr_cmp(&net_sin6(addr)->sin6_addr,
400247b4:	fc0504e3          	beqz	a0,4002477c <dns_server_exists+0x7c>
	return false;
400247b8:	00000513          	li	a0,0
400247bc:	fc5ff06f          	j	40024780 <dns_server_exists+0x80>
400247c0:	00000513          	li	a0,0
400247c4:	00008067          	ret

400247c8 <dns_postprocess_server>:
{
400247c8:	fe010113          	addi	sp,sp,-32
400247cc:	01212823          	sw	s2,16(sp)
	struct sockaddr *addr = &ctx->servers[idx].dns_server;
400247d0:	00559913          	slli	s2,a1,0x5
{
400247d4:	00812c23          	sw	s0,24(sp)
400247d8:	00912a23          	sw	s1,20(sp)
400247dc:	00112e23          	sw	ra,28(sp)
400247e0:	01312623          	sw	s3,12(sp)
	struct sockaddr *addr = &ctx->servers[idx].dns_server;
400247e4:	01250433          	add	s0,a0,s2
	if (addr->sa_family == AF_INET) {
400247e8:	00045703          	lhu	a4,0(s0)
400247ec:	00100793          	li	a5,1
{
400247f0:	00050493          	mv	s1,a0
	if (addr->sa_family == AF_INET) {
400247f4:	0af71263          	bne	a4,a5,40024898 <dns_postprocess_server+0xd0>
		if (net_ipv4_is_addr_mcast(&net_sin(addr)->sin_addr) &&
400247f8:	00440993          	addi	s3,s0,4
400247fc:	00098513          	mv	a0,s3
40024800:	e61ff0ef          	jal	ra,40024660 <net_ipv4_is_addr_mcast>
40024804:	02050063          	beqz	a0,40024824 <dns_postprocess_server+0x5c>
40024808:	00744703          	lbu	a4,7(s0)
4002480c:	0fb00793          	li	a5,251
40024810:	00f71a63          	bne	a4,a5,40024824 <dns_postprocess_server+0x5c>
		ctx->servers[idx].is_mdns = server_is_mdns(AF_INET6, addr);
40024814:	01c44783          	lbu	a5,28(s0)
40024818:	0017e793          	ori	a5,a5,1
4002481c:	00f40e23          	sb	a5,28(s0)
		if (!ctx->servers[idx].is_mdns) {
40024820:	0480006f          	j	40024868 <dns_postprocess_server+0xa0>
		ctx->servers[idx].is_mdns = server_is_mdns(AF_INET, addr);
40024824:	01248733          	add	a4,s1,s2
40024828:	01c74783          	lbu	a5,28(a4)
		if (net_ipv4_is_addr_mcast(&net_sin(addr)->sin_addr) &&
4002482c:	00098513          	mv	a0,s3
		ctx->servers[idx].is_mdns = server_is_mdns(AF_INET, addr);
40024830:	ffe7f793          	andi	a5,a5,-2
40024834:	00f70e23          	sb	a5,28(a4)
		if (net_ipv4_is_addr_mcast(&net_sin(addr)->sin_addr) &&
40024838:	e29ff0ef          	jal	ra,40024660 <net_ipv4_is_addr_mcast>
4002483c:	00050863          	beqz	a0,4002484c <dns_postprocess_server+0x84>
40024840:	00744783          	lbu	a5,7(s0)
40024844:	f0478793          	addi	a5,a5,-252
40024848:	0017b513          	seqz	a0,a5
			ctx->servers[idx].is_llmnr =
4002484c:	01248933          	add	s2,s1,s2
40024850:	01c94703          	lbu	a4,28(s2)
40024854:	00157513          	andi	a0,a0,1
40024858:	00151793          	slli	a5,a0,0x1
4002485c:	ffd77713          	andi	a4,a4,-3
40024860:	00f767b3          	or	a5,a4,a5
40024864:	00f90e23          	sb	a5,28(s2)
		if (net_sin6(addr)->sin6_port == 0U) {
40024868:	00245783          	lhu	a5,2(s0)
4002486c:	00079863          	bnez	a5,4002487c <dns_postprocess_server+0xb4>
				net_sin6(addr)->sin6_port = htons(53);
40024870:	000037b7          	lui	a5,0x3
40024874:	50078793          	addi	a5,a5,1280 # 3500 <CONFIG_SRAM_SIZE+0x1500>
40024878:	00f41123          	sh	a5,2(s0)
}
4002487c:	01c12083          	lw	ra,28(sp)
40024880:	01812403          	lw	s0,24(sp)
40024884:	01412483          	lw	s1,20(sp)
40024888:	01012903          	lw	s2,16(sp)
4002488c:	00c12983          	lw	s3,12(sp)
40024890:	02010113          	addi	sp,sp,32
40024894:	00008067          	ret
		if (net_ipv6_is_addr_mcast(&net_sin6(addr)->sin6_addr) &&
40024898:	00444703          	lbu	a4,4(s0)
4002489c:	0ff00793          	li	a5,255
400248a0:	00f71863          	bne	a4,a5,400248b0 <dns_postprocess_server+0xe8>
400248a4:	01344703          	lbu	a4,19(s0)
400248a8:	0fb00793          	li	a5,251
400248ac:	f6f704e3          	beq	a4,a5,40024814 <dns_postprocess_server+0x4c>
		ctx->servers[idx].is_mdns = server_is_mdns(AF_INET6, addr);
400248b0:	01248733          	add	a4,s1,s2
400248b4:	01c74783          	lbu	a5,28(a4)
400248b8:	ffe7f793          	andi	a5,a5,-2
400248bc:	00f70e23          	sb	a5,28(a4)
		if (net_ipv6_is_addr_mcast(&net_sin6(addr)->sin6_addr) &&
400248c0:	00444703          	lbu	a4,4(s0)
400248c4:	0ff00793          	li	a5,255
400248c8:	02f70263          	beq	a4,a5,400248ec <dns_postprocess_server+0x124>
		return false;
400248cc:	00000793          	li	a5,0
			ctx->servers[idx].is_llmnr =
400248d0:	012484b3          	add	s1,s1,s2
400248d4:	01c4c703          	lbu	a4,28(s1)
400248d8:	00179793          	slli	a5,a5,0x1
400248dc:	ffd77713          	andi	a4,a4,-3
400248e0:	00f767b3          	or	a5,a4,a5
400248e4:	00f48e23          	sb	a5,28(s1)
400248e8:	f81ff06f          	j	40024868 <dns_postprocess_server+0xa0>
		if (net_ipv6_is_addr_mcast(&net_sin6(addr)->sin6_addr) &&
400248ec:	01344783          	lbu	a5,19(s0)
400248f0:	ffd78793          	addi	a5,a5,-3
400248f4:	0017b793          	seqz	a5,a5
400248f8:	fd9ff06f          	j	400248d0 <dns_postprocess_server+0x108>

400248fc <dns_resolve_init_locked>:
{
400248fc:	fc010113          	addi	sp,sp,-64
40024900:	02812c23          	sw	s0,56(sp)
40024904:	02912a23          	sw	s1,52(sp)
40024908:	03212823          	sw	s2,48(sp)
4002490c:	00050413          	mv	s0,a0
40024910:	00058493          	mv	s1,a1
40024914:	00060913          	mv	s2,a2
	struct sockaddr_in6 local_addr6 = {
40024918:	00000593          	li	a1,0
4002491c:	01600613          	li	a2,22
40024920:	00a10513          	addi	a0,sp,10
{
40024924:	02112e23          	sw	ra,60(sp)
40024928:	03312623          	sw	s3,44(sp)
	struct sockaddr_in6 local_addr6 = {
4002492c:	f44e40ef          	jal	ra,40009070 <memset>
40024930:	00200793          	li	a5,2
	struct sockaddr_in local_addr4 = {
40024934:	00100713          	li	a4,1
	struct sockaddr_in6 local_addr6 = {
40024938:	00f11423          	sh	a5,8(sp)
	struct sockaddr_in local_addr4 = {
4002493c:	00011123          	sh	zero,2(sp)
40024940:	00011223          	sh	zero,4(sp)
40024944:	00011323          	sh	zero,6(sp)
40024948:	00e11023          	sh	a4,0(sp)
		return -ENOENT;
4002494c:	ffe00513          	li	a0,-2
	if (!ctx) {
40024950:	0a040863          	beqz	s0,40024a00 <dns_resolve_init_locked+0x104>
	if (ctx->state != DNS_RESOLVE_CONTEXT_INACTIVE) {
40024954:	09842703          	lw	a4,152(s0)
		ret = -ENOTEMPTY;
40024958:	fa600513          	li	a0,-90
	if (ctx->state != DNS_RESOLVE_CONTEXT_INACTIVE) {
4002495c:	0af71263          	bne	a4,a5,40024a00 <dns_resolve_init_locked+0x104>
	if (servers) {
40024960:	00048663          	beqz	s1,4002496c <dns_resolve_init_locked+0x70>
		for (i = 0; idx < SERVER_COUNT && servers[i]; i++) {
40024964:	0004a783          	lw	a5,0(s1)
40024968:	0a079a63          	bnez	a5,40024a1c <dns_resolve_init_locked+0x120>
	if (servers_sa) {
4002496c:	0e091a63          	bnez	s2,40024a60 <dns_resolve_init_locked+0x164>
	     i < SERVER_COUNT && ctx->servers[i].dns_server.sa_family; i++) {
40024970:	00045783          	lhu	a5,0(s0)
		ret = -EINVAL;
40024974:	fea00513          	li	a0,-22
	     i < SERVER_COUNT && ctx->servers[i].dns_server.sa_family; i++) {
40024978:	08078463          	beqz	a5,40024a00 <dns_resolve_init_locked+0x104>
		if (ctx->servers[i].dns_server.sa_family == AF_INET6) {
4002497c:	00200713          	li	a4,2
40024980:	0ee78c63          	beq	a5,a4,40024a78 <dns_resolve_init_locked+0x17c>
		if (ctx->servers[i].dns_server.sa_family == AF_INET) {
40024984:	00100713          	li	a4,1
			ret = -EAFNOSUPPORT;
40024988:	f9600513          	li	a0,-106
		if (ctx->servers[i].dns_server.sa_family == AF_INET) {
4002498c:	06e79a63          	bne	a5,a4,40024a00 <dns_resolve_init_locked+0x104>
			local_addr = (struct sockaddr *)&local_addr4;
40024990:	00010493          	mv	s1,sp
			addr_len = sizeof(struct sockaddr_in);
40024994:	00800913          	li	s2,8
		ret = net_context_get(ctx->servers[i].dns_server.sa_family,
40024998:	01840693          	addi	a3,s0,24
4002499c:	01100613          	li	a2,17
400249a0:	00200593          	li	a1,2
400249a4:	00078513          	mv	a0,a5
400249a8:	b39ec0ef          	jal	ra,400114e0 <net_context_get>
		if (ret < 0) {
400249ac:	04054a63          	bltz	a0,40024a00 <dns_resolve_init_locked+0x104>
		ret = net_context_bind(ctx->servers[i].net_ctx,
400249b0:	01842503          	lw	a0,24(s0)
400249b4:	00090613          	mv	a2,s2
400249b8:	00048593          	mv	a1,s1
400249bc:	e8dec0ef          	jal	ra,40011848 <net_context_bind>
		if (ret < 0) {
400249c0:	04054063          	bltz	a0,40024a00 <dns_resolve_init_locked+0x104>
	return net_if_get_by_index(context->iface);
400249c4:	01842783          	lw	a5,24(s0)
400249c8:	07678503          	lb	a0,118(a5)
400249cc:	900e80ef          	jal	ra,4000cacc <z_impl_net_if_get_by_index>
400249d0:	00050593          	mv	a1,a0
	net_mgmt_event_notify_with_info(mgmt_event, iface, NULL, 0);
400249d4:	f1140537          	lui	a0,0xf1140
400249d8:	00350513          	addi	a0,a0,3 # f1140003 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf1140004>
400249dc:	00000693          	li	a3,0
400249e0:	00000613          	li	a2,0
400249e4:	d4cec0ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
	ctx->buf_timeout = DNS_BUF_TIMEOUT;
400249e8:	03200713          	li	a4,50
400249ec:	00000793          	li	a5,0
	ctx->state = DNS_RESOLVE_CONTEXT_ACTIVE;
400249f0:	08042c23          	sw	zero,152(s0)
	ctx->buf_timeout = DNS_BUF_TIMEOUT;
400249f4:	02e42c23          	sw	a4,56(s0)
400249f8:	02f42e23          	sw	a5,60(s0)
	ret = 0;
400249fc:	00000513          	li	a0,0
}
40024a00:	03c12083          	lw	ra,60(sp)
40024a04:	03812403          	lw	s0,56(sp)
40024a08:	03412483          	lw	s1,52(sp)
40024a0c:	03012903          	lw	s2,48(sp)
40024a10:	02c12983          	lw	s3,44(sp)
40024a14:	04010113          	addi	sp,sp,64
40024a18:	00008067          	ret
			(void)memset(addr, 0, sizeof(*addr));
40024a1c:	01800613          	li	a2,24
40024a20:	00000593          	li	a1,0
40024a24:	00040513          	mv	a0,s0
40024a28:	e48e40ef          	jal	ra,40009070 <memset>
			ret = net_ipaddr_parse(servers[i], strlen(servers[i]),
40024a2c:	0004a983          	lw	s3,0(s1)
			if (!ret) {
40024a30:	00448493          	addi	s1,s1,4
			ret = net_ipaddr_parse(servers[i], strlen(servers[i]),
40024a34:	00098513          	mv	a0,s3
40024a38:	cf0e40ef          	jal	ra,40008f28 <strlen>
40024a3c:	00050593          	mv	a1,a0
40024a40:	00040613          	mv	a2,s0
40024a44:	00098513          	mv	a0,s3
40024a48:	fa1eb0ef          	jal	ra,400109e8 <net_ipaddr_parse>
			if (!ret) {
40024a4c:	f0050ce3          	beqz	a0,40024964 <dns_resolve_init_locked+0x68>
			dns_postprocess_server(ctx, idx);
40024a50:	00000593          	li	a1,0
40024a54:	00040513          	mv	a0,s0
40024a58:	d71ff0ef          	jal	ra,400247c8 <dns_postprocess_server>
		for (i = 0; idx < SERVER_COUNT && servers_sa[i]; i++) {
40024a5c:	f15ff06f          	j	40024970 <dns_resolve_init_locked+0x74>
40024a60:	00092583          	lw	a1,0(s2)
40024a64:	f00586e3          	beqz	a1,40024970 <dns_resolve_init_locked+0x74>
			memcpy(&ctx->servers[idx].dns_server, servers_sa[i],
40024a68:	01800613          	li	a2,24
40024a6c:	00040513          	mv	a0,s0
40024a70:	ddce40ef          	jal	ra,4000904c <memcpy>
40024a74:	fddff06f          	j	40024a50 <dns_resolve_init_locked+0x154>
			local_addr = (struct sockaddr *)&local_addr6;
40024a78:	00810493          	addi	s1,sp,8
			addr_len = sizeof(struct sockaddr_in6);
40024a7c:	01800913          	li	s2,24
40024a80:	f19ff06f          	j	40024998 <dns_resolve_init_locked+0x9c>

40024a84 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
40024a84:	7550306f          	j	400289d8 <z_impl_k_mutex_unlock>

40024a88 <dns_resolve_cancel_with_hash.constprop.0>:
static int dns_resolve_cancel_with_hash(struct dns_resolve_context *ctx,
40024a88:	fe010113          	addi	sp,sp,-32
40024a8c:	01312623          	sw	s3,12(sp)
	k_mutex_lock(&ctx->lock, K_FOREVER);
40024a90:	02050993          	addi	s3,a0,32
static int dns_resolve_cancel_with_hash(struct dns_resolve_context *ctx,
40024a94:	00812c23          	sw	s0,24(sp)
40024a98:	00912a23          	sw	s1,20(sp)
40024a9c:	01212823          	sw	s2,16(sp)
40024aa0:	00050413          	mv	s0,a0
40024aa4:	00058493          	mv	s1,a1
40024aa8:	00060913          	mv	s2,a2
	k_mutex_lock(&ctx->lock, K_FOREVER);
40024aac:	fff00593          	li	a1,-1
40024ab0:	fff00613          	li	a2,-1
40024ab4:	00098513          	mv	a0,s3
static int dns_resolve_cancel_with_hash(struct dns_resolve_context *ctx,
40024ab8:	00112e23          	sw	ra,28(sp)
	k_mutex_lock(&ctx->lock, K_FOREVER);
40024abc:	c0dff0ef          	jal	ra,400246c8 <k_mutex_lock>
	if (ctx->state == DNS_RESOLVE_CONTEXT_DEACTIVATING) {
40024ac0:	09842703          	lw	a4,152(s0)
40024ac4:	00100793          	li	a5,1
40024ac8:	04f70263          	beq	a4,a5,40024b0c <dns_resolve_cancel_with_hash.constprop.0+0x84>
	i = get_slot_by_id(ctx, dns_id, query_hash);
40024acc:	00048593          	mv	a1,s1
40024ad0:	00090613          	mv	a2,s2
40024ad4:	00040513          	mv	a0,s0
40024ad8:	bc5ff0ef          	jal	ra,4002469c <get_slot_by_id>
		ret = -ENOENT;
40024adc:	ffe00493          	li	s1,-2
	if (i < 0) {
40024ae0:	02054863          	bltz	a0,40024b10 <dns_resolve_cancel_with_hash.constprop.0+0x88>
	invoke_query_callback(DNS_EAI_CANCELED, NULL, &ctx->queries[slot]);
40024ae4:	05800793          	li	a5,88
40024ae8:	02f50533          	mul	a0,a0,a5
40024aec:	00000593          	li	a1,0
40024af0:	04050513          	addi	a0,a0,64
40024af4:	00a40433          	add	s0,s0,a0
40024af8:	00040613          	mv	a2,s0
40024afc:	f9b00513          	li	a0,-101
40024b00:	b81ff0ef          	jal	ra,40024680 <invoke_query_callback>
	release_query(&ctx->queries[slot]);
40024b04:	00040513          	mv	a0,s0
40024b08:	bc5ff0ef          	jal	ra,400246cc <release_query>
	int ret = 0;
40024b0c:	00000493          	li	s1,0
	k_mutex_unlock(&ctx->lock);
40024b10:	00098513          	mv	a0,s3
40024b14:	f71ff0ef          	jal	ra,40024a84 <k_mutex_unlock.isra.0>
}
40024b18:	01c12083          	lw	ra,28(sp)
40024b1c:	01812403          	lw	s0,24(sp)
40024b20:	01012903          	lw	s2,16(sp)
40024b24:	00c12983          	lw	s3,12(sp)
40024b28:	00048513          	mv	a0,s1
40024b2c:	01412483          	lw	s1,20(sp)
40024b30:	02010113          	addi	sp,sp,32
40024b34:	00008067          	ret

40024b38 <query_timeout>:
{
40024b38:	ff010113          	addi	sp,sp,-16
40024b3c:	00812423          	sw	s0,8(sp)
40024b40:	00112623          	sw	ra,12(sp)
40024b44:	00050413          	mv	s0,a0
	ret = k_mutex_lock(&pending_query->ctx->lock, K_NO_WAIT);
40024b48:	03052503          	lw	a0,48(a0)
40024b4c:	00000593          	li	a1,0
40024b50:	00000613          	li	a2,0
40024b54:	02050513          	addi	a0,a0,32
40024b58:	b71ff0ef          	jal	ra,400246c8 <k_mutex_lock>
	if (ret != 0) {
40024b5c:	02050063          	beqz	a0,40024b7c <query_timeout+0x44>
		k_work_reschedule(dwork, K_MSEC(10));
40024b60:	00040513          	mv	a0,s0
}
40024b64:	00812403          	lw	s0,8(sp)
40024b68:	00c12083          	lw	ra,12(sp)
		k_work_reschedule(dwork, K_MSEC(10));
40024b6c:	00100593          	li	a1,1
40024b70:	00000613          	li	a2,0
}
40024b74:	01010113          	addi	sp,sp,16
		k_work_reschedule(dwork, K_MSEC(10));
40024b78:	2ad0406f          	j	40029624 <k_work_reschedule>
	(void)dns_resolve_cancel_with_hash(pending_query->ctx,
40024b7c:	05245603          	lhu	a2,82(s0)
40024b80:	05045583          	lhu	a1,80(s0)
40024b84:	03042503          	lw	a0,48(s0)
40024b88:	f01ff0ef          	jal	ra,40024a88 <dns_resolve_cancel_with_hash.constprop.0>
	k_mutex_unlock(&pending_query->ctx->lock);
40024b8c:	03042503          	lw	a0,48(s0)
}
40024b90:	00812403          	lw	s0,8(sp)
40024b94:	00c12083          	lw	ra,12(sp)
	k_mutex_unlock(&pending_query->ctx->lock);
40024b98:	02050513          	addi	a0,a0,32
}
40024b9c:	01010113          	addi	sp,sp,16
	k_mutex_unlock(&pending_query->ctx->lock);
40024ba0:	ee5ff06f          	j	40024a84 <k_mutex_unlock.isra.0>

40024ba4 <dns_resolve_close_locked>:
	if (ctx->state != DNS_RESOLVE_CONTEXT_ACTIVE) {
40024ba4:	09852783          	lw	a5,152(a0)
40024ba8:	08079863          	bnez	a5,40024c38 <dns_resolve_close_locked+0x94>
{
40024bac:	ff010113          	addi	sp,sp,-16
40024bb0:	00812423          	sw	s0,8(sp)
40024bb4:	00912223          	sw	s1,4(sp)
	ctx->state = DNS_RESOLVE_CONTEXT_DEACTIVATING;
40024bb8:	00100793          	li	a5,1
{
40024bbc:	00112623          	sw	ra,12(sp)
	k_mutex_unlock(&ctx->lock);
40024bc0:	02050493          	addi	s1,a0,32
	ctx->state = DNS_RESOLVE_CONTEXT_DEACTIVATING;
40024bc4:	08f52c23          	sw	a5,152(a0)
40024bc8:	00050413          	mv	s0,a0
	k_mutex_unlock(&ctx->lock);
40024bcc:	00048513          	mv	a0,s1
40024bd0:	eb5ff0ef          	jal	ra,40024a84 <k_mutex_unlock.isra.0>
		if (ctx->servers[i].net_ctx) {
40024bd4:	01842783          	lw	a5,24(s0)
40024bd8:	02078863          	beqz	a5,40024c08 <dns_resolve_close_locked+0x64>
40024bdc:	07678503          	lb	a0,118(a5)
40024be0:	eede70ef          	jal	ra,4000cacc <z_impl_net_if_get_by_index>
40024be4:	00050593          	mv	a1,a0
40024be8:	f1140537          	lui	a0,0xf1140
40024bec:	00000693          	li	a3,0
40024bf0:	00000613          	li	a2,0
40024bf4:	00450513          	addi	a0,a0,4 # f1140004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf1140005>
40024bf8:	b38ec0ef          	jal	ra,40010f30 <net_mgmt_event_notify_with_info>
			net_context_put(ctx->servers[i].net_ctx);
40024bfc:	01842503          	lw	a0,24(s0)
40024c00:	bbdec0ef          	jal	ra,400117bc <net_context_put>
			ctx->servers[i].net_ctx = NULL;
40024c04:	00042c23          	sw	zero,24(s0)
	k_mutex_lock(&ctx->lock, K_FOREVER);
40024c08:	00048513          	mv	a0,s1
40024c0c:	fff00593          	li	a1,-1
40024c10:	fff00613          	li	a2,-1
40024c14:	ab5ff0ef          	jal	ra,400246c8 <k_mutex_lock>
	ctx->state = DNS_RESOLVE_CONTEXT_INACTIVE;
40024c18:	00200793          	li	a5,2
40024c1c:	08f42c23          	sw	a5,152(s0)
}
40024c20:	00c12083          	lw	ra,12(sp)
40024c24:	00812403          	lw	s0,8(sp)
40024c28:	00412483          	lw	s1,4(sp)
	return 0;
40024c2c:	00000513          	li	a0,0
}
40024c30:	01010113          	addi	sp,sp,16
40024c34:	00008067          	ret
		return -ENOENT;
40024c38:	ffe00513          	li	a0,-2
}
40024c3c:	00008067          	ret

40024c40 <dns_write.constprop.0>:
static int dns_write(struct dns_resolve_context *ctx,
40024c40:	fc010113          	addi	sp,sp,-64
40024c44:	03312623          	sw	s3,44(sp)
	query_type = ctx->queries[query_idx].query_type;
40024c48:	05800993          	li	s3,88
40024c4c:	033589b3          	mul	s3,a1,s3
static int dns_write(struct dns_resolve_context *ctx,
40024c50:	02812c23          	sw	s0,56(sp)
40024c54:	02912a23          	sw	s1,52(sp)
40024c58:	03212823          	sw	s2,48(sp)
40024c5c:	03512223          	sw	s5,36(sp)
40024c60:	02112e23          	sw	ra,60(sp)
40024c64:	03412423          	sw	s4,40(sp)
40024c68:	00060913          	mv	s2,a2
	net_ctx = ctx->servers[server_idx].net_ctx;
40024c6c:	01852a03          	lw	s4,24(a0)
	ret = dns_msg_pack_query(dns_data->data, &dns_data->len, dns_data->size,
40024c70:	0106d703          	lhu	a4,16(a3)
	query_type = ctx->queries[query_idx].query_type;
40024c74:	013509b3          	add	s3,a0,s3
static int dns_write(struct dns_resolve_context *ctx,
40024c78:	00050413          	mv	s0,a0
40024c7c:	00068a93          	mv	s5,a3
	ret = dns_msg_pack_query(dns_data->data, &dns_data->len, dns_data->size,
40024c80:	08c9a803          	lw	a6,140(s3)
40024c84:	0909d783          	lhu	a5,144(s3)
40024c88:	00c6a683          	lw	a3,12(a3)
40024c8c:	01265603          	lhu	a2,18(a2)
40024c90:	00c92503          	lw	a0,12(s2)
static int dns_write(struct dns_resolve_context *ctx,
40024c94:	00058493          	mv	s1,a1
	ret = dns_msg_pack_query(dns_data->data, &dns_data->len, dns_data->size,
40024c98:	01090593          	addi	a1,s2,16
40024c9c:	f00ff0ef          	jal	ra,4002439c <dns_msg_pack_query>
	if (ret < 0) {
40024ca0:	10054463          	bltz	a0,40024da8 <dns_write.constprop.0+0x168>
			   dns_qname->len + 2);
40024ca4:	010ad683          	lhu	a3,16(s5)
		crc16_ansi(dns_data->data + DNS_MSG_HEADER_SIZE,
40024ca8:	00c92603          	lw	a2,12(s2)
 *
 * @return The computed CRC16 value
 */
static inline uint16_t crc16_ansi(const uint8_t *src, size_t len)
{
	return crc16_reflect(0xA001, 0xffff, src, len);
40024cac:	000105b7          	lui	a1,0x10
40024cb0:	0000a537          	lui	a0,0xa
40024cb4:	00268693          	addi	a3,a3,2
40024cb8:	00c60613          	addi	a2,a2,12
40024cbc:	fff58593          	addi	a1,a1,-1 # ffff <__kernel_ram_size+0x3d6b>
40024cc0:	00150513          	addi	a0,a0,1 # a001 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x6001>
40024cc4:	e61dc0ef          	jal	ra,40001b24 <crc16_reflect>
	ctx->queries[query_idx].query_hash =
40024cc8:	08a99923          	sh	a0,146(s3)
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
40024ccc:	074a5783          	lhu	a5,116(s4)
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
40024cd0:	00200713          	li	a4,2
40024cd4:	0037d793          	srli	a5,a5,0x3
40024cd8:	0077f793          	andi	a5,a5,7
40024cdc:	00e79663          	bne	a5,a4,40024ce8 <dns_write.constprop.0+0xa8>
	context->ipv4_ttl = ttl;
40024ce0:	060a0ba3          	sb	zero,119(s4)
}
40024ce4:	00c0006f          	j	40024cf0 <dns_write.constprop.0+0xb0>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
40024ce8:	00100713          	li	a4,1
40024cec:	fee78ae3          	beq	a5,a4,40024ce0 <dns_write.constprop.0+0xa0>
	ret = net_context_recv(net_ctx, cb_recv, K_NO_WAIT, ctx);
40024cf0:	400255b7          	lui	a1,0x40025
40024cf4:	00040713          	mv	a4,s0
40024cf8:	00000613          	li	a2,0
40024cfc:	00000693          	li	a3,0
40024d00:	f4c58593          	addi	a1,a1,-180 # 40024f4c <cb_recv>
40024d04:	000a0513          	mv	a0,s4
40024d08:	995ed0ef          	jal	ra,4001269c <net_context_recv>
	if (ret < 0 && ret != -EALREADY) {
40024d0c:	00055663          	bgez	a0,40024d18 <dns_write.constprop.0+0xd8>
40024d10:	f8800793          	li	a5,-120
40024d14:	06f51863          	bne	a0,a5,40024d84 <dns_write.constprop.0+0x144>
	if (server->sa_family == AF_INET) {
40024d18:	00045683          	lhu	a3,0(s0)
40024d1c:	00100793          	li	a5,1
		server_addr_len = sizeof(struct sockaddr_in6);
40024d20:	01800713          	li	a4,24
	if (server->sa_family == AF_INET) {
40024d24:	00f69463          	bne	a3,a5,40024d2c <dns_write.constprop.0+0xec>
		server_addr_len = sizeof(struct sockaddr_in);
40024d28:	00800713          	li	a4,8
	ret = k_work_reschedule(&ctx->queries[query_idx].timer,
40024d2c:	05800793          	li	a5,88
40024d30:	02f484b3          	mul	s1,s1,a5
40024d34:	00e12e23          	sw	a4,28(sp)
40024d38:	009407b3          	add	a5,s0,s1
40024d3c:	0807a583          	lw	a1,128(a5)
40024d40:	0847a603          	lw	a2,132(a5)
40024d44:	04048493          	addi	s1,s1,64
40024d48:	00940533          	add	a0,s0,s1
40024d4c:	0d9040ef          	jal	ra,40029624 <k_work_reschedule>
	if (ret < 0) {
40024d50:	02054a63          	bltz	a0,40024d84 <dns_write.constprop.0+0x144>
	ret = net_context_sendto(net_ctx, dns_data->data, dns_data->len,
40024d54:	00012023          	sw	zero,0(sp)
40024d58:	01c12703          	lw	a4,28(sp)
40024d5c:	01095603          	lhu	a2,16(s2)
40024d60:	00c92583          	lw	a1,12(s2)
40024d64:	00000813          	li	a6,0
40024d68:	00000893          	li	a7,0
40024d6c:	00000793          	li	a5,0
40024d70:	00040693          	mv	a3,s0
40024d74:	000a0513          	mv	a0,s4
40024d78:	891ed0ef          	jal	ra,40012608 <net_context_sendto>
	if (ret < 0) {
40024d7c:	00a05463          	blez	a0,40024d84 <dns_write.constprop.0+0x144>
40024d80:	00000513          	li	a0,0
}
40024d84:	03c12083          	lw	ra,60(sp)
40024d88:	03812403          	lw	s0,56(sp)
40024d8c:	03412483          	lw	s1,52(sp)
40024d90:	03012903          	lw	s2,48(sp)
40024d94:	02c12983          	lw	s3,44(sp)
40024d98:	02812a03          	lw	s4,40(sp)
40024d9c:	02412a83          	lw	s5,36(sp)
40024da0:	04010113          	addi	sp,sp,64
40024da4:	00008067          	ret
		return -EINVAL;
40024da8:	fea00513          	li	a0,-22
40024dac:	fd9ff06f          	j	40024d84 <dns_write.constprop.0+0x144>

40024db0 <dns_resolve_init>:
	if (!ctx) {
40024db0:	06050263          	beqz	a0,40024e14 <dns_resolve_init+0x64>
{
40024db4:	ff010113          	addi	sp,sp,-16
40024db8:	00912223          	sw	s1,4(sp)
40024dbc:	01212023          	sw	s2,0(sp)
40024dc0:	00058493          	mv	s1,a1
40024dc4:	00060913          	mv	s2,a2
	(void)memset(ctx, 0, sizeof(*ctx));
40024dc8:	00000593          	li	a1,0
40024dcc:	0a000613          	li	a2,160
{
40024dd0:	00812423          	sw	s0,8(sp)
40024dd4:	00112623          	sw	ra,12(sp)
40024dd8:	00050413          	mv	s0,a0
	(void)memset(ctx, 0, sizeof(*ctx));
40024ddc:	a94e40ef          	jal	ra,40009070 <memset>
	return z_impl_k_mutex_init(mutex);
40024de0:	02040513          	addi	a0,s0,32
40024de4:	281030ef          	jal	ra,40028864 <z_impl_k_mutex_init>
	ctx->state = DNS_RESOLVE_CONTEXT_INACTIVE;
40024de8:	00200793          	li	a5,2
40024dec:	08f42c23          	sw	a5,152(s0)
	return dns_resolve_init_locked(ctx, servers, servers_sa);
40024df0:	00040513          	mv	a0,s0
}
40024df4:	00812403          	lw	s0,8(sp)
40024df8:	00c12083          	lw	ra,12(sp)
	return dns_resolve_init_locked(ctx, servers, servers_sa);
40024dfc:	00090613          	mv	a2,s2
40024e00:	00048593          	mv	a1,s1
}
40024e04:	00012903          	lw	s2,0(sp)
40024e08:	00412483          	lw	s1,4(sp)
40024e0c:	01010113          	addi	sp,sp,16
	return dns_resolve_init_locked(ctx, servers, servers_sa);
40024e10:	aedff06f          	j	400248fc <dns_resolve_init_locked>
}
40024e14:	ffe00513          	li	a0,-2
40024e18:	00008067          	ret

40024e1c <dns_resolve_cancel_with_name>:
{
40024e1c:	fc010113          	addi	sp,sp,-64
40024e20:	03212823          	sw	s2,48(sp)
40024e24:	03312623          	sw	s3,44(sp)
40024e28:	02112e23          	sw	ra,60(sp)
40024e2c:	02812c23          	sw	s0,56(sp)
40024e30:	02912a23          	sw	s1,52(sp)
40024e34:	03412423          	sw	s4,40(sp)
40024e38:	00050913          	mv	s2,a0
40024e3c:	00058993          	mv	s3,a1
	if (query_name) {
40024e40:	10060263          	beqz	a2,40024f44 <dns_resolve_cancel_with_name+0x128>
	return net_buf_alloc_fixed(pool, timeout);
40024e44:	03852583          	lw	a1,56(a0)
40024e48:	00060493          	mv	s1,a2
40024e4c:	03c52603          	lw	a2,60(a0)
40024e50:	4003d537          	lui	a0,0x4003d
40024e54:	b8c50513          	addi	a0,a0,-1140 # 4003cb8c <dns_msg_pool>
40024e58:	00068a13          	mv	s4,a3
40024e5c:	a9de40ef          	jal	ra,400098f8 <net_buf_alloc_fixed>
40024e60:	00050413          	mv	s0,a0
		if (!buf) {
40024e64:	06050263          	beqz	a0,40024ec8 <dns_resolve_cancel_with_name+0xac>
		ret = dns_msg_pack_qname(&len, buf->data, buf->size,
40024e68:	01255603          	lhu	a2,18(a0)
40024e6c:	00c52583          	lw	a1,12(a0)
40024e70:	00048693          	mv	a3,s1
40024e74:	01e10513          	addi	a0,sp,30
40024e78:	9fcff0ef          	jal	ra,40024074 <dns_msg_pack_qname>
40024e7c:	00050493          	mv	s1,a0
		if (ret >= 0) {
40024e80:	02055863          	bgez	a0,40024eb0 <dns_resolve_cancel_with_name+0x94>
		net_buf_unref(buf);
40024e84:	00040513          	mv	a0,s0
40024e88:	a89e40ef          	jal	ra,40009910 <net_buf_unref>
}
40024e8c:	03c12083          	lw	ra,60(sp)
40024e90:	03812403          	lw	s0,56(sp)
40024e94:	03012903          	lw	s2,48(sp)
40024e98:	02c12983          	lw	s3,44(sp)
40024e9c:	02812a03          	lw	s4,40(sp)
40024ea0:	00048513          	mv	a0,s1
40024ea4:	03412483          	lw	s1,52(sp)
40024ea8:	04010113          	addi	sp,sp,64
40024eac:	00008067          	ret
			if ((len + 2) > buf->size) {
40024eb0:	01e15583          	lhu	a1,30(sp)
40024eb4:	01245783          	lhu	a5,18(s0)
40024eb8:	00158713          	addi	a4,a1,1
40024ebc:	00f74a63          	blt	a4,a5,40024ed0 <dns_resolve_cancel_with_name+0xb4>
				net_buf_unref(buf);
40024ec0:	00040513          	mv	a0,s0
40024ec4:	a4de40ef          	jal	ra,40009910 <net_buf_unref>
			return -ENOMEM;
40024ec8:	ff400493          	li	s1,-12
40024ecc:	fc1ff06f          	j	40024e8c <dns_resolve_cancel_with_name+0x70>
	return net_buf_simple_add(&buf->b, len);
40024ed0:	00c40493          	addi	s1,s0,12
40024ed4:	00048513          	mv	a0,s1
40024ed8:	c45e40ef          	jal	ra,40009b1c <net_buf_simple_add>
	net_buf_simple_add_be16(&buf->b, val);
40024edc:	010a1593          	slli	a1,s4,0x10
40024ee0:	0105d593          	srli	a1,a1,0x10
40024ee4:	00048513          	mv	a0,s1
40024ee8:	c4de40ef          	jal	ra,40009b34 <net_buf_simple_add_be16>
			query_hash = crc16_ansi(buf->data, len + 2);
40024eec:	01e15683          	lhu	a3,30(sp)
40024ef0:	00c42603          	lw	a2,12(s0)
40024ef4:	000105b7          	lui	a1,0x10
40024ef8:	0000a537          	lui	a0,0xa
40024efc:	00268693          	addi	a3,a3,2
40024f00:	fff58593          	addi	a1,a1,-1 # ffff <__kernel_ram_size+0x3d6b>
40024f04:	00150513          	addi	a0,a0,1 # a001 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x6001>
40024f08:	c1ddc0ef          	jal	ra,40001b24 <crc16_reflect>
40024f0c:	00a12623          	sw	a0,12(sp)
		net_buf_unref(buf);
40024f10:	00040513          	mv	a0,s0
40024f14:	9fde40ef          	jal	ra,40009910 <net_buf_unref>
		if (ret < 0) {
40024f18:	00c12603          	lw	a2,12(sp)
}
40024f1c:	03812403          	lw	s0,56(sp)
40024f20:	03c12083          	lw	ra,60(sp)
40024f24:	03412483          	lw	s1,52(sp)
40024f28:	02812a03          	lw	s4,40(sp)
	return dns_resolve_cancel_with_hash(ctx, dns_id, query_hash,
40024f2c:	00098593          	mv	a1,s3
40024f30:	00090513          	mv	a0,s2
}
40024f34:	02c12983          	lw	s3,44(sp)
40024f38:	03012903          	lw	s2,48(sp)
40024f3c:	04010113          	addi	sp,sp,64
	return dns_resolve_cancel_with_hash(ctx, dns_id, query_hash,
40024f40:	b49ff06f          	j	40024a88 <dns_resolve_cancel_with_hash.constprop.0>
	uint16_t query_hash = 0;
40024f44:	00000613          	li	a2,0
40024f48:	fd5ff06f          	j	40024f1c <dns_resolve_cancel_with_name+0x100>

40024f4c <cb_recv>:
{
40024f4c:	f6010113          	addi	sp,sp,-160
40024f50:	08812c23          	sw	s0,152(sp)
40024f54:	00078413          	mv	s0,a5
	k_mutex_lock(&ctx->lock, K_FOREVER);
40024f58:	02078793          	addi	a5,a5,32
{
40024f5c:	00b12223          	sw	a1,4(sp)
	k_mutex_lock(&ctx->lock, K_FOREVER);
40024f60:	00078513          	mv	a0,a5
40024f64:	fff00593          	li	a1,-1
40024f68:	fff00613          	li	a2,-1
{
40024f6c:	09612023          	sw	s6,128(sp)
	k_mutex_lock(&ctx->lock, K_FOREVER);
40024f70:	00f12423          	sw	a5,8(sp)
{
40024f74:	08112e23          	sw	ra,156(sp)
40024f78:	08912a23          	sw	s1,148(sp)
40024f7c:	09212823          	sw	s2,144(sp)
40024f80:	09312623          	sw	s3,140(sp)
40024f84:	09412423          	sw	s4,136(sp)
40024f88:	09512223          	sw	s5,132(sp)
40024f8c:	07712e23          	sw	s7,124(sp)
40024f90:	07812c23          	sw	s8,120(sp)
40024f94:	07912a23          	sw	s9,116(sp)
40024f98:	07a12823          	sw	s10,112(sp)
40024f9c:	07b12623          	sw	s11,108(sp)
40024fa0:	00070b13          	mv	s6,a4
	k_mutex_lock(&ctx->lock, K_FOREVER);
40024fa4:	f24ff0ef          	jal	ra,400246c8 <k_mutex_lock>
	if (ctx->state != DNS_RESOLVE_CONTEXT_ACTIVE) {
40024fa8:	09842783          	lw	a5,152(s0)
40024fac:	40079663          	bnez	a5,400253b8 <cb_recv+0x46c>
	if (status) {
40024fb0:	480b1463          	bnez	s6,40025438 <cb_recv+0x4ec>
	return net_buf_alloc_fixed(pool, timeout);
40024fb4:	03842583          	lw	a1,56(s0)
40024fb8:	03c42603          	lw	a2,60(s0)
40024fbc:	4003d537          	lui	a0,0x4003d
40024fc0:	b8c50513          	addi	a0,a0,-1140 # 4003cb8c <dns_msg_pool>
40024fc4:	935e40ef          	jal	ra,400098f8 <net_buf_alloc_fixed>
40024fc8:	00050993          	mv	s3,a0
	if (!dns_data) {
40024fcc:	48050263          	beqz	a0,40025450 <cb_recv+0x504>
40024fd0:	03842583          	lw	a1,56(s0)
40024fd4:	03c42603          	lw	a2,60(s0)
40024fd8:	4003d537          	lui	a0,0x4003d
40024fdc:	bb850513          	addi	a0,a0,-1096 # 4003cbb8 <dns_qname_pool>
40024fe0:	919e40ef          	jal	ra,400098f8 <net_buf_alloc_fixed>
40024fe4:	00050a13          	mv	s4,a0
	if (!dns_cname) {
40024fe8:	44050063          	beqz	a0,40025428 <cb_recv+0x4dc>
	data_len = MIN(net_pkt_remaining_data(pkt), DNS_RESOLVER_MAX_BUF_SIZE);
40024fec:	00412503          	lw	a0,4(sp)
40024ff0:	20000493          	li	s1,512
40024ff4:	b75ee0ef          	jal	ra,40013b68 <net_pkt_remaining_data>
40024ff8:	1ff00793          	li	a5,511
40024ffc:	00a7e863          	bltu	a5,a0,4002500c <cb_recv+0xc0>
40025000:	00412503          	lw	a0,4(sp)
40025004:	b65ee0ef          	jal	ra,40013b68 <net_pkt_remaining_data>
40025008:	00050493          	mv	s1,a0
	ret = net_pkt_read(pkt, dns_data->data, data_len);
4002500c:	00c9a583          	lw	a1,12(s3)
40025010:	00412503          	lw	a0,4(sp)
40025014:	00048613          	mv	a2,s1
40025018:	9b5ee0ef          	jal	ra,400139cc <net_pkt_read>
	if (ret < 0) {
4002501c:	40054263          	bltz	a0,40025420 <cb_recv+0x4d4>
	dns_msg.msg = dns_data->data;
40025020:	00c9ab83          	lw	s7,12(s3)
	dns_msg.msg_size = data_len;
40025024:	01049493          	slli	s1,s1,0x10
40025028:	0104d493          	srli	s1,s1,0x10
	struct dns_addrinfo info = { 0 };
4002502c:	03400613          	li	a2,52
40025030:	00000593          	li	a1,0
40025034:	02c10513          	addi	a0,sp,44
	dns_msg.msg = dns_data->data;
40025038:	01712c23          	sw	s7,24(sp)
	dns_msg.msg_size = data_len;
4002503c:	02911423          	sh	s1,40(sp)
	struct dns_addrinfo info = { 0 };
40025040:	830e40ef          	jal	ra,40009070 <memset>
	if (dns_msg->msg_size < (sizeof(*dns_id) + sizeof(uint16_t))) {
40025044:	00300793          	li	a5,3
40025048:	3a97fc63          	bgeu	a5,s1,40025400 <cb_recv+0x4b4>
	return ntohs(UNALIGNED_GET((uint16_t *)(header)));
4002504c:	001bc483          	lbu	s1,1(s7)
40025050:	000bc783          	lbu	a5,0(s7)
	if (dns_header_rcode(dns_msg->msg) == DNS_HEADER_REFUSED) {
40025054:	00500713          	li	a4,5
40025058:	00849493          	slli	s1,s1,0x8
4002505c:	00f4e4b3          	or	s1,s1,a5
40025060:	0084d793          	srli	a5,s1,0x8
40025064:	00849913          	slli	s2,s1,0x8
40025068:	00f96933          	or	s2,s2,a5
4002506c:	003bc783          	lbu	a5,3(s7)
40025070:	01091913          	slli	s2,s2,0x10
40025074:	01095913          	srli	s2,s2,0x10
40025078:	00f7f793          	andi	a5,a5,15
4002507c:	02e78063          	beq	a5,a4,4002509c <cb_recv+0x150>
	return ((*(header + 2)) & 0x80) ? 1 : 0;
40025080:	002bcb83          	lbu	s7,2(s7)
40025084:	007bdb93          	srli	s7,s7,0x7
	if (dns_header_qr(dns_msg->msg) == DNS_QUERY) {
40025088:	2c0b8663          	beqz	s7,40025354 <cb_recv+0x408>
	ret = dns_unpack_response_header(dns_msg, *dns_id);
4002508c:	00090593          	mv	a1,s2
40025090:	01810513          	addi	a0,sp,24
40025094:	a58ff0ef          	jal	ra,400242ec <dns_unpack_response_header>
	if (ret < 0) {
40025098:	00055663          	bgez	a0,400250a4 <cb_recv+0x158>
	uint16_t query_hash = 0U;
4002509c:	00000493          	li	s1,0
400250a0:	18c0006f          	j	4002522c <cb_recv+0x2e0>
	if (dns_header_qdcount(dns_msg->msg) != 1) {
400250a4:	01812783          	lw	a5,24(sp)
400250a8:	0047c703          	lbu	a4,4(a5)
400250ac:	0057c783          	lbu	a5,5(a5)
400250b0:	00879793          	slli	a5,a5,0x8
400250b4:	00e7e7b3          	or	a5,a5,a4
400250b8:	10000713          	li	a4,256
400250bc:	12e78c63          	beq	a5,a4,400251f4 <cb_recv+0x2a8>
		if (*dns_id > 0) {
400250c0:	fc049ee3          	bnez	s1,4002509c <cb_recv+0x150>
	ret = dns_unpack_response_query(dns_msg);
400250c4:	01810513          	addi	a0,sp,24
400250c8:	becff0ef          	jal	ra,400244b4 <dns_unpack_response_query>
	if (ret < 0) {
400250cc:	00055663          	bgez	a0,400250d8 <cb_recv+0x18c>
		dns_msg->answer_offset = dns_msg->query_offset;
400250d0:	02415783          	lhu	a5,36(sp)
400250d4:	02f11323          	sh	a5,38(sp)
	enum dns_rr_type answer_type = DNS_RR_TYPE_INVALID;
400250d8:	00012a23          	sw	zero,20(sp)
	server_idx = 0;
400250dc:	00000c13          	li	s8,0
	int query_idx = -1;
400250e0:	fff00a93          	li	s5,-1
	uint16_t query_hash = 0U;
400250e4:	00000493          	li	s1,0
	answer_ptr = DNS_QUERY_POS;
400250e8:	00c00c93          	li	s9,12
		switch (dns_msg->response_type) {
400250ec:	feb00d13          	li	s10,-21
400250f0:	fed00d93          	li	s11,-19
	while (server_idx < dns_header_ancount(dns_msg->msg)) {
400250f4:	01812603          	lw	a2,24(sp)
	return htons(UNALIGNED_GET((uint16_t *)(header + 6)));
400250f8:	00764703          	lbu	a4,7(a2)
400250fc:	00664683          	lbu	a3,6(a2)
40025100:	00871713          	slli	a4,a4,0x8
40025104:	00d76733          	or	a4,a4,a3
40025108:	00871693          	slli	a3,a4,0x8
4002510c:	00875713          	srli	a4,a4,0x8
40025110:	00e6e733          	or	a4,a3,a4
40025114:	01071713          	slli	a4,a4,0x10
40025118:	01075713          	srli	a4,a4,0x10
4002511c:	0eec4663          	blt	s8,a4,40025208 <cb_recv+0x2bc>
	if (*query_idx < 0) {
40025120:	fff00713          	li	a4,-1
40025124:	04ea9863          	bne	s5,a4,40025174 <cb_recv+0x228>
		query_name = dns_msg->msg + dns_msg->query_offset;
40025128:	02415783          	lhu	a5,36(sp)
4002512c:	00f60633          	add	a2,a2,a5
					 strlen(query_name) + 1 + 2);
40025130:	00060513          	mv	a0,a2
40025134:	00c12623          	sw	a2,12(sp)
40025138:	df1e30ef          	jal	ra,40008f28 <strlen>
4002513c:	00c12603          	lw	a2,12(sp)
40025140:	00350693          	addi	a3,a0,3
40025144:	000105b7          	lui	a1,0x10
40025148:	0000a537          	lui	a0,0xa
4002514c:	fff58593          	addi	a1,a1,-1 # ffff <__kernel_ram_size+0x3d6b>
40025150:	00150513          	addi	a0,a0,1 # a001 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x6001>
40025154:	9d1dc0ef          	jal	ra,40001b24 <crc16_reflect>
		*query_idx = get_slot_by_id(ctx, *dns_id, *query_hash);
40025158:	00050613          	mv	a2,a0
4002515c:	00050493          	mv	s1,a0
40025160:	00090593          	mv	a1,s2
40025164:	00040513          	mv	a0,s0
40025168:	d34ff0ef          	jal	ra,4002469c <get_slot_by_id>
4002516c:	00050a93          	mv	s5,a0
		if (*query_idx < 0) {
40025170:	2a054463          	bltz	a0,40025418 <cb_recv+0x4cc>
	if (items == 0) {
40025174:	280b1a63          	bnez	s6,40025408 <cb_recv+0x4bc>
		if (dns_msg->response_type == DNS_RESPONSE_CNAME_NO_IP) {
40025178:	01c12683          	lw	a3,28(sp)
4002517c:	fed00713          	li	a4,-19
40025180:	28e69863          	bne	a3,a4,40025410 <cb_recv+0x4c4>
				ret = dns_copy_qname(dns_cname->data,
40025184:	02015703          	lhu	a4,32(sp)
40025188:	012a5603          	lhu	a2,18(s4)
4002518c:	00ca2503          	lw	a0,12(s4)
40025190:	01810693          	addi	a3,sp,24
40025194:	010a0593          	addi	a1,s4,16
40025198:	be0ff0ef          	jal	ra,40024578 <dns_copy_qname>
				if (ret < 0) {
4002519c:	26054e63          	bltz	a0,40025418 <cb_recv+0x4cc>
	dns_resolve_cancel_with_name(ctx, *dns_id,
400251a0:	05800713          	li	a4,88
400251a4:	02ea87b3          	mul	a5,s5,a4
400251a8:	00090593          	mv	a1,s2
400251ac:	00040513          	mv	a0,s0
400251b0:	00f407b3          	add	a5,s0,a5
400251b4:	0887a603          	lw	a2,136(a5)
400251b8:	08c7a683          	lw	a3,140(a5)
400251bc:	c61ff0ef          	jal	ra,40024e1c <dns_resolve_cancel_with_name>
	net_pkt_unref(pkt);
400251c0:	00412503          	lw	a0,4(sp)
400251c4:	d59ed0ef          	jal	ra,40012f1c <net_pkt_unref>
		i = get_slot_by_id(ctx, dns_id, query_hash);
400251c8:	00090593          	mv	a1,s2
400251cc:	00048613          	mv	a2,s1
400251d0:	00040513          	mv	a0,s0
400251d4:	cc8ff0ef          	jal	ra,4002469c <get_slot_by_id>
400251d8:	00050593          	mv	a1,a0
		if (i < 0) {
400251dc:	26055e63          	bgez	a0,40025458 <cb_recv+0x50c>
		net_buf_unref(dns_data);
400251e0:	00098513          	mv	a0,s3
400251e4:	f2ce40ef          	jal	ra,40009910 <net_buf_unref>
		net_buf_unref(dns_cname);
400251e8:	000a0513          	mv	a0,s4
400251ec:	f24e40ef          	jal	ra,40009910 <net_buf_unref>
400251f0:	1c80006f          	j	400253b8 <cb_recv+0x46c>
	ret = dns_unpack_response_query(dns_msg);
400251f4:	01810513          	addi	a0,sp,24
400251f8:	abcff0ef          	jal	ra,400244b4 <dns_unpack_response_query>
	if (ret < 0) {
400251fc:	ec055ee3          	bgez	a0,400250d8 <cb_recv+0x18c>
		if (*dns_id > 0) {
40025200:	ec0488e3          	beqz	s1,400250d0 <cb_recv+0x184>
40025204:	e99ff06f          	j	4002509c <cb_recv+0x150>
		ret = dns_unpack_answer(dns_msg, answer_ptr, &ttl,
40025208:	01410693          	addi	a3,sp,20
4002520c:	01010613          	addi	a2,sp,16
40025210:	000c8593          	mv	a1,s9
40025214:	01810513          	addi	a0,sp,24
40025218:	f5dfe0ef          	jal	ra,40024174 <dns_unpack_answer>
		if (ret < 0) {
4002521c:	00054863          	bltz	a0,4002522c <cb_recv+0x2e0>
		switch (dns_msg->response_type) {
40025220:	01c12703          	lw	a4,28(sp)
40025224:	01a70863          	beq	a4,s10,40025234 <cb_recv+0x2e8>
40025228:	13b70263          	beq	a4,s11,4002534c <cb_recv+0x400>
4002522c:	ffc00b13          	li	s6,-4
40025230:	1340006f          	j	40025364 <cb_recv+0x418>
			if (*query_idx >= 0) {
40025234:	fff00713          	li	a4,-1
40025238:	04ea9a63          	bne	s5,a4,4002528c <cb_recv+0x340>
			query_name = dns_msg->msg + dns_msg->query_offset;
4002523c:	02415783          	lhu	a5,36(sp)
40025240:	01812603          	lw	a2,24(sp)
40025244:	00f60633          	add	a2,a2,a5
						 strlen(query_name) + 1 + 2);
40025248:	00060513          	mv	a0,a2
4002524c:	00c12623          	sw	a2,12(sp)
40025250:	cd9e30ef          	jal	ra,40008f28 <strlen>
40025254:	00c12603          	lw	a2,12(sp)
40025258:	00350693          	addi	a3,a0,3
4002525c:	000105b7          	lui	a1,0x10
40025260:	0000a537          	lui	a0,0xa
40025264:	fff58593          	addi	a1,a1,-1 # ffff <__kernel_ram_size+0x3d6b>
40025268:	00150513          	addi	a0,a0,1 # a001 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x6001>
4002526c:	8b9dc0ef          	jal	ra,40001b24 <crc16_reflect>
			*query_idx = get_slot_by_id(ctx, *dns_id, *query_hash);
40025270:	00050613          	mv	a2,a0
40025274:	00050493          	mv	s1,a0
40025278:	00090593          	mv	a1,s2
4002527c:	00040513          	mv	a0,s0
40025280:	c1cff0ef          	jal	ra,4002469c <get_slot_by_id>
40025284:	00050a93          	mv	s5,a0
			if (*query_idx < 0) {
40025288:	18054863          	bltz	a0,40025418 <cb_recv+0x4cc>
			if (ctx->queries[*query_idx].query_type ==
4002528c:	05800713          	li	a4,88
40025290:	02ea8733          	mul	a4,s5,a4
40025294:	00100693          	li	a3,1
40025298:	00e40733          	add	a4,s0,a4
4002529c:	08c72703          	lw	a4,140(a4)
400252a0:	08d71463          	bne	a4,a3,40025328 <cb_recv+0x3dc>
				if (answer_type != DNS_RR_TYPE_A) {
400252a4:	01412683          	lw	a3,20(sp)
400252a8:	14e69863          	bne	a3,a4,400253f8 <cb_recv+0x4ac>
400252ac:	000b8593          	mv	a1,s7
400252b0:	00100693          	li	a3,1
400252b4:	00800713          	li	a4,8
				address_size = DNS_IPV4_LEN;
400252b8:	00400613          	li	a2,4
				info.ai_addrlen = sizeof(struct sockaddr_in);
400252bc:	04e12223          	sw	a4,68(sp)
			if (dns_msg->response_length < address_size) {
400252c0:	02215703          	lhu	a4,34(sp)
				info.ai_family = AF_INET;
400252c4:	04b10423          	sb	a1,72(sp)
				info.ai_addr.sa_family = AF_INET;
400252c8:	02d11623          	sh	a3,44(sp)
			if (dns_msg->response_length < address_size) {
400252cc:	f6c740e3          	blt	a4,a2,4002522c <cb_recv+0x2e0>
			if ((dns_msg->response_position + address_size) >
400252d0:	02015703          	lhu	a4,32(sp)
			    dns_msg->msg_size) {
400252d4:	02815683          	lhu	a3,40(sp)
			if ((dns_msg->response_position + address_size) >
400252d8:	00c705b3          	add	a1,a4,a2
400252dc:	f4b6c8e3          	blt	a3,a1,4002522c <cb_recv+0x2e0>
			memcpy(addr, src, address_size);
400252e0:	01812583          	lw	a1,24(sp)
400252e4:	03010513          	addi	a0,sp,48
			items++;
400252e8:	001b0b13          	addi	s6,s6,1
			memcpy(addr, src, address_size);
400252ec:	00e585b3          	add	a1,a1,a4
400252f0:	d5de30ef          	jal	ra,4000904c <memcpy>
			invoke_query_callback(DNS_EAI_INPROGRESS, &info,
400252f4:	05800613          	li	a2,88
400252f8:	02ca8633          	mul	a2,s5,a2
400252fc:	02c10593          	addi	a1,sp,44
40025300:	f9c00513          	li	a0,-100
40025304:	04060613          	addi	a2,a2,64
40025308:	00c40633          	add	a2,s0,a2
4002530c:	b74ff0ef          	jal	ra,40024680 <invoke_query_callback>
		dns_msg->answer_offset += dns_msg->response_length;
40025310:	02015703          	lhu	a4,32(sp)
40025314:	02215683          	lhu	a3,34(sp)
		server_idx++;
40025318:	001c0c13          	addi	s8,s8,1
		dns_msg->answer_offset += dns_msg->response_length;
4002531c:	00d70733          	add	a4,a4,a3
40025320:	02e11323          	sh	a4,38(sp)
		server_idx++;
40025324:	dd1ff06f          	j	400250f4 <cb_recv+0x1a8>
			} else if (ctx->queries[*query_idx].query_type ==
40025328:	01c00693          	li	a3,28
4002532c:	02d71a63          	bne	a4,a3,40025360 <cb_recv+0x414>
				if (answer_type != DNS_RR_TYPE_AAAA) {
40025330:	01412683          	lw	a3,20(sp)
40025334:	0ce69263          	bne	a3,a4,400253f8 <cb_recv+0x4ac>
40025338:	00200593          	li	a1,2
4002533c:	00200693          	li	a3,2
40025340:	01800713          	li	a4,24
				address_size = DNS_IPV6_LEN;
40025344:	01000613          	li	a2,16
40025348:	f75ff06f          	j	400252bc <cb_recv+0x370>
			answer_ptr = dns_msg->response_position;
4002534c:	02015c83          	lhu	s9,32(sp)
			break;
40025350:	fc1ff06f          	j	40025310 <cb_recv+0x3c4>
	net_pkt_unref(pkt);
40025354:	00412503          	lw	a0,4(sp)
40025358:	bc5ed0ef          	jal	ra,40012f1c <net_pkt_unref>
		net_buf_unref(dns_data);
4002535c:	e85ff06f          	j	400251e0 <cb_recv+0x294>
				ret = DNS_EAI_FAMILY;
40025360:	ffa00b13          	li	s6,-6
	net_pkt_unref(pkt);
40025364:	00412503          	lw	a0,4(sp)
40025368:	bb5ed0ef          	jal	ra,40012f1c <net_pkt_unref>
	i = get_slot_by_id(ctx, dns_id, query_hash);
4002536c:	00048613          	mv	a2,s1
40025370:	00090593          	mv	a1,s2
40025374:	00040513          	mv	a0,s0
40025378:	b24ff0ef          	jal	ra,4002469c <get_slot_by_id>
	if (i < 0) {
4002537c:	02054663          	bltz	a0,400253a8 <cb_recv+0x45c>
	invoke_query_callback(ret, NULL, &ctx->queries[i]);
40025380:	05800793          	li	a5,88
40025384:	02f50533          	mul	a0,a0,a5
40025388:	00000593          	li	a1,0
4002538c:	04050513          	addi	a0,a0,64
40025390:	00a40433          	add	s0,s0,a0
40025394:	00040613          	mv	a2,s0
40025398:	000b0513          	mv	a0,s6
4002539c:	ae4ff0ef          	jal	ra,40024680 <invoke_query_callback>
	release_query(&ctx->queries[i]);
400253a0:	00040513          	mv	a0,s0
400253a4:	b28ff0ef          	jal	ra,400246cc <release_query>
	if (dns_data) {
400253a8:	00098663          	beqz	s3,400253b4 <cb_recv+0x468>
		net_buf_unref(dns_data);
400253ac:	00098513          	mv	a0,s3
400253b0:	d60e40ef          	jal	ra,40009910 <net_buf_unref>
	if (dns_cname) {
400253b4:	e20a1ae3          	bnez	s4,400251e8 <cb_recv+0x29c>
}
400253b8:	09812403          	lw	s0,152(sp)
	k_mutex_unlock(&ctx->lock);
400253bc:	00812503          	lw	a0,8(sp)
}
400253c0:	09c12083          	lw	ra,156(sp)
400253c4:	09412483          	lw	s1,148(sp)
400253c8:	09012903          	lw	s2,144(sp)
400253cc:	08c12983          	lw	s3,140(sp)
400253d0:	08812a03          	lw	s4,136(sp)
400253d4:	08412a83          	lw	s5,132(sp)
400253d8:	08012b03          	lw	s6,128(sp)
400253dc:	07c12b83          	lw	s7,124(sp)
400253e0:	07812c03          	lw	s8,120(sp)
400253e4:	07412c83          	lw	s9,116(sp)
400253e8:	07012d03          	lw	s10,112(sp)
400253ec:	06c12d83          	lw	s11,108(sp)
400253f0:	0a010113          	addi	sp,sp,160
	k_mutex_unlock(&ctx->lock);
400253f4:	e90ff06f          	j	40024a84 <k_mutex_unlock.isra.0>
					ret = DNS_EAI_ADDRFAMILY;
400253f8:	ff700b13          	li	s6,-9
400253fc:	f69ff06f          	j	40025364 <cb_recv+0x418>
	uint16_t dns_id = 0U;
40025400:	00000913          	li	s2,0
40025404:	c99ff06f          	j	4002509c <cb_recv+0x150>
40025408:	f9900b13          	li	s6,-103
4002540c:	f59ff06f          	j	40025364 <cb_recv+0x418>
40025410:	ffb00b13          	li	s6,-5
40025414:	f51ff06f          	j	40025364 <cb_recv+0x418>
40025418:	ff500b13          	li	s6,-11
4002541c:	f49ff06f          	j	40025364 <cb_recv+0x418>
	net_pkt_unref(pkt);
40025420:	00412503          	lw	a0,4(sp)
40025424:	af9ed0ef          	jal	ra,40012f1c <net_pkt_unref>
	uint16_t dns_id = 0U;
40025428:	00000913          	li	s2,0
	uint16_t query_hash = 0U;
4002542c:	00000493          	li	s1,0
		ret = DNS_EAI_MEMORY;
40025430:	ff600b13          	li	s6,-10
40025434:	f39ff06f          	j	4002536c <cb_recv+0x420>
	uint16_t dns_id = 0U;
40025438:	00000913          	li	s2,0
	uint16_t query_hash = 0U;
4002543c:	00000493          	li	s1,0
		ret = DNS_EAI_SYSTEM;
40025440:	ff500b13          	li	s6,-11
	struct net_buf *dns_data = NULL;
40025444:	00000993          	li	s3,0
	struct net_buf *dns_cname = NULL;
40025448:	00000a13          	li	s4,0
4002544c:	f21ff06f          	j	4002536c <cb_recv+0x420>
40025450:	00000a13          	li	s4,0
40025454:	fd5ff06f          	j	40025428 <cb_recv+0x4dc>
			if (!ctx->servers[j].net_ctx) {
40025458:	01842783          	lw	a5,24(s0)
4002545c:	d80782e3          	beqz	a5,400251e0 <cb_recv+0x294>
			ret = dns_write(ctx, j, i, dns_data, dns_cname, 0);
40025460:	000a0693          	mv	a3,s4
40025464:	00098613          	mv	a2,s3
40025468:	00040513          	mv	a0,s0
4002546c:	fd4ff0ef          	jal	ra,40024c40 <dns_write.constprop.0>
			if (ret < 0) {
40025470:	d60558e3          	bgez	a0,400251e0 <cb_recv+0x294>
				ret = DNS_EAI_SYSTEM;
40025474:	ff500b13          	li	s6,-11
40025478:	ef5ff06f          	j	4002536c <cb_recv+0x420>

4002547c <dns_resolve_cancel>:
	return dns_resolve_cancel_with_hash(ctx, dns_id, query_hash,
4002547c:	00000613          	li	a2,0
40025480:	e08ff06f          	j	40024a88 <dns_resolve_cancel_with_hash.constprop.0>

40025484 <dns_resolve_name>:
{
40025484:	f8010113          	addi	sp,sp,-128
40025488:	06112e23          	sw	ra,124(sp)
4002548c:	06812c23          	sw	s0,120(sp)
40025490:	06912a23          	sw	s1,116(sp)
40025494:	07212823          	sw	s2,112(sp)
40025498:	07312623          	sw	s3,108(sp)
4002549c:	07412423          	sw	s4,104(sp)
400254a0:	07512223          	sw	s5,100(sp)
400254a4:	07612023          	sw	s6,96(sp)
400254a8:	05712e23          	sw	s7,92(sp)
400254ac:	05812c23          	sw	s8,88(sp)
400254b0:	05912a23          	sw	s9,84(sp)
400254b4:	05a12823          	sw	s10,80(sp)
	if (!ctx || !query || !cb) {
400254b8:	06050863          	beqz	a0,40025528 <dns_resolve_name+0xa4>
400254bc:	00058993          	mv	s3,a1
		return -EINVAL;
400254c0:	fea00493          	li	s1,-22
	if (!ctx || !query || !cb) {
400254c4:	10058263          	beqz	a1,400255c8 <dns_resolve_name+0x144>
400254c8:	00070a13          	mv	s4,a4
400254cc:	0e070e63          	beqz	a4,400255c8 <dns_resolve_name+0x144>
400254d0:	00078b13          	mv	s6,a5
	tout = SYS_TIMEOUT_MS(timeout);
400254d4:	fff00793          	li	a5,-1
400254d8:	00050413          	mv	s0,a0
400254dc:	00060a93          	mv	s5,a2
400254e0:	00068913          	mv	s2,a3
400254e4:	04f80663          	beq	a6,a5,40025530 <dns_resolve_name+0xac>
400254e8:	00085463          	bgez	a6,400254f0 <dns_resolve_name+0x6c>
400254ec:	00000813          	li	a6,0
		t += off;
400254f0:	00980b93          	addi	s7,a6,9
400254f4:	41f85793          	srai	a5,a6,0x1f
400254f8:	010bb833          	sltu	a6,s7,a6
400254fc:	00f804b3          	add	s1,a6,a5
			return t / ((uint64_t)from_hz / to_hz);
40025500:	00a00613          	li	a2,10
40025504:	00000693          	li	a3,0
40025508:	000b8513          	mv	a0,s7
4002550c:	00048593          	mv	a1,s1
40025510:	da9da0ef          	jal	ra,400002b8 <__udivdi3>
		t += off;
40025514:	00900d13          	li	s10,9
			return t / ((uint64_t)from_hz / to_hz);
40025518:	00050c13          	mv	s8,a0
4002551c:	00058c93          	mv	s9,a1
	if (K_TIMEOUT_EQ(tout, K_NO_WAIT)) {
40025520:	01ab9c63          	bne	s7,s10,40025538 <dns_resolve_name+0xb4>
40025524:	00049a63          	bnez	s1,40025538 <dns_resolve_name+0xb4>
		return -EINVAL;
40025528:	fea00493          	li	s1,-22
4002552c:	09c0006f          	j	400255c8 <dns_resolve_name+0x144>
	tout = SYS_TIMEOUT_MS(timeout);
40025530:	fff00c13          	li	s8,-1
40025534:	fff00c93          	li	s9,-1
	ret = net_ipaddr_parse(query, strlen(query), &addr);
40025538:	00098513          	mv	a0,s3
4002553c:	9ede30ef          	jal	ra,40008f28 <strlen>
40025540:	00050593          	mv	a1,a0
40025544:	00410613          	addi	a2,sp,4
40025548:	00098513          	mv	a0,s3
4002554c:	c9ceb0ef          	jal	ra,400109e8 <net_ipaddr_parse>
	if (ret) {
40025550:	0e050463          	beqz	a0,40025638 <dns_resolve_name+0x1b4>
		struct dns_addrinfo info = { 0 };
40025554:	03400613          	li	a2,52
40025558:	00000593          	li	a1,0
4002555c:	01c10513          	addi	a0,sp,28
40025560:	b11e30ef          	jal	ra,40009070 <memset>
		if (type == DNS_QUERY_TYPE_A) {
40025564:	00100793          	li	a5,1
40025568:	08fa9e63          	bne	s5,a5,40025604 <dns_resolve_name+0x180>
			if (net_sin(&addr)->sin_family == AF_INET6) {
4002556c:	00415703          	lhu	a4,4(sp)
40025570:	00200793          	li	a5,2
				return -EPFNOSUPPORT;
40025574:	fa000493          	li	s1,-96
			if (net_sin(&addr)->sin_family == AF_INET6) {
40025578:	04f70863          	beq	a4,a5,400255c8 <dns_resolve_name+0x144>
			memcpy(net_sin(&info.ai_addr), net_sin(&addr),
4002557c:	00800613          	li	a2,8
40025580:	00410593          	addi	a1,sp,4
40025584:	01c10513          	addi	a0,sp,28
40025588:	ac5e30ef          	jal	ra,4000904c <memcpy>
			info.ai_addrlen = sizeof(struct sockaddr_in);
4002558c:	00100693          	li	a3,1
40025590:	00100713          	li	a4,1
40025594:	00800793          	li	a5,8
			info.ai_family = AF_INET;
40025598:	02d10c23          	sb	a3,56(sp)
			info.ai_addr.sa_family = AF_INET;
4002559c:	00e11e23          	sh	a4,28(sp)
			info.ai_addrlen = sizeof(struct sockaddr_in);
400255a0:	02f12a23          	sw	a5,52(sp)
		cb(DNS_EAI_INPROGRESS, &info, user_data);
400255a4:	000b0613          	mv	a2,s6
400255a8:	01c10593          	addi	a1,sp,28
400255ac:	f9c00513          	li	a0,-100
400255b0:	000a00e7          	jalr	s4
		cb(DNS_EAI_ALLDONE, NULL, user_data);
400255b4:	000b0613          	mv	a2,s6
400255b8:	00000593          	li	a1,0
400255bc:	f9900513          	li	a0,-103
400255c0:	000a00e7          	jalr	s4
		return 0;
400255c4:	00000493          	li	s1,0
}
400255c8:	07c12083          	lw	ra,124(sp)
400255cc:	07812403          	lw	s0,120(sp)
400255d0:	07012903          	lw	s2,112(sp)
400255d4:	06c12983          	lw	s3,108(sp)
400255d8:	06812a03          	lw	s4,104(sp)
400255dc:	06412a83          	lw	s5,100(sp)
400255e0:	06012b03          	lw	s6,96(sp)
400255e4:	05c12b83          	lw	s7,92(sp)
400255e8:	05812c03          	lw	s8,88(sp)
400255ec:	05412c83          	lw	s9,84(sp)
400255f0:	05012d03          	lw	s10,80(sp)
400255f4:	00048513          	mv	a0,s1
400255f8:	07412483          	lw	s1,116(sp)
400255fc:	08010113          	addi	sp,sp,128
40025600:	00008067          	ret
		} else if (type == DNS_QUERY_TYPE_AAAA) {
40025604:	01c00713          	li	a4,28
40025608:	02ea9863          	bne	s5,a4,40025638 <dns_resolve_name+0x1b4>
			if (net_sin(&addr)->sin_family == AF_INET) {
4002560c:	00415703          	lhu	a4,4(sp)
				return -EPFNOSUPPORT;
40025610:	fa000493          	li	s1,-96
			if (net_sin(&addr)->sin_family == AF_INET) {
40025614:	faf70ae3          	beq	a4,a5,400255c8 <dns_resolve_name+0x144>
			memcpy(net_sin6(&info.ai_addr), net_sin6(&addr),
40025618:	01800613          	li	a2,24
4002561c:	00410593          	addi	a1,sp,4
40025620:	01c10513          	addi	a0,sp,28
40025624:	a29e30ef          	jal	ra,4000904c <memcpy>
			info.ai_addrlen = sizeof(struct sockaddr_in6);
40025628:	00200693          	li	a3,2
4002562c:	00200713          	li	a4,2
40025630:	01800793          	li	a5,24
40025634:	f65ff06f          	j	40025598 <dns_resolve_name+0x114>
	k_mutex_lock(&ctx->lock, K_FOREVER);
40025638:	02040b93          	addi	s7,s0,32
4002563c:	fff00593          	li	a1,-1
40025640:	fff00613          	li	a2,-1
40025644:	000b8513          	mv	a0,s7
40025648:	880ff0ef          	jal	ra,400246c8 <k_mutex_lock>
	if (ctx->state != DNS_RESOLVE_CONTEXT_ACTIVE) {
4002564c:	09842783          	lw	a5,152(s0)
		ret = -EINVAL;
40025650:	fea00493          	li	s1,-22
	if (ctx->state != DNS_RESOLVE_CONTEXT_ACTIVE) {
40025654:	12079863          	bnez	a5,40025784 <dns_resolve_name+0x300>
	if (pending_query->cb != NULL) {
40025658:	07442783          	lw	a5,116(s0)
4002565c:	00078c63          	beqz	a5,40025674 <dns_resolve_name+0x1f0>
		    && pending_query->query == NULL
40025660:	08842783          	lw	a5,136(s0)
40025664:	14079a63          	bnez	a5,400257b8 <dns_resolve_name+0x334>
		    && k_work_delayable_busy_get(&pending_query->timer) == 0) {
40025668:	04040513          	addi	a0,s0,64
4002566c:	6ad030ef          	jal	ra,40029518 <k_work_delayable_busy_get>
40025670:	14051463          	bnez	a0,400257b8 <dns_resolve_name+0x334>
	ctx->queries[i].query_type = type;
40025674:	09542623          	sw	s5,140(s0)
	k_work_init_delayable(&ctx->queries[i].timer, query_timeout);
40025678:	400255b7          	lui	a1,0x40025
4002567c:	04040a93          	addi	s5,s0,64
	ctx->queries[i].query = query;
40025680:	09342423          	sw	s3,136(s0)
	k_work_init_delayable(&ctx->queries[i].timer, query_timeout);
40025684:	b3858593          	addi	a1,a1,-1224 # 40024b38 <query_timeout>
40025688:	000a8513          	mv	a0,s5
	ctx->queries[i].cb = cb;
4002568c:	07442a23          	sw	s4,116(s0)
	ctx->queries[i].timeout = tout;
40025690:	09842023          	sw	s8,128(s0)
40025694:	09942223          	sw	s9,132(s0)
	ctx->queries[i].user_data = user_data;
40025698:	07642c23          	sw	s6,120(s0)
	ctx->queries[i].ctx = ctx;
4002569c:	06842823          	sw	s0,112(s0)
	ctx->queries[i].query_hash = 0;
400256a0:	08041923          	sh	zero,146(s0)
	k_work_init_delayable(&ctx->queries[i].timer, query_timeout);
400256a4:	631030ef          	jal	ra,400294d4 <k_work_init_delayable>
400256a8:	03842583          	lw	a1,56(s0)
400256ac:	03c42603          	lw	a2,60(s0)
400256b0:	4003d537          	lui	a0,0x4003d
400256b4:	b8c50513          	addi	a0,a0,-1140 # 4003cb8c <dns_msg_pool>
400256b8:	a40e40ef          	jal	ra,400098f8 <net_buf_alloc_fixed>
400256bc:	00050993          	mv	s3,a0
	if (!dns_data) {
400256c0:	0c050e63          	beqz	a0,4002579c <dns_resolve_name+0x318>
400256c4:	03842583          	lw	a1,56(s0)
400256c8:	03c42603          	lw	a2,60(s0)
400256cc:	4003d537          	lui	a0,0x4003d
400256d0:	bb850513          	addi	a0,a0,-1096 # 4003cbb8 <dns_qname_pool>
400256d4:	a24e40ef          	jal	ra,400098f8 <net_buf_alloc_fixed>
400256d8:	00050a13          	mv	s4,a0
	if (!dns_qname) {
400256dc:	08050663          	beqz	a0,40025768 <dns_resolve_name+0x2e4>
	ret = dns_msg_pack_qname(&dns_qname->len, dns_qname->data,
400256e0:	00c52583          	lw	a1,12(a0)
400256e4:	08842683          	lw	a3,136(s0)
400256e8:	0ff00613          	li	a2,255
400256ec:	01050513          	addi	a0,a0,16
400256f0:	985fe0ef          	jal	ra,40024074 <dns_msg_pack_qname>
400256f4:	00050493          	mv	s1,a0
	if (ret < 0) {
400256f8:	08054c63          	bltz	a0,40025790 <dns_resolve_name+0x30c>
400256fc:	e79e30ef          	jal	ra,40009574 <z_impl_sys_rand32_get>
	ctx->queries[i].id = sys_rand32_get();
40025700:	01051513          	slli	a0,a0,0x10
40025704:	01055513          	srli	a0,a0,0x10
40025708:	08a41823          	sh	a0,144(s0)
	if (dns_id) {
4002570c:	00090463          	beqz	s2,40025714 <dns_resolve_name+0x290>
		*dns_id = ctx->queries[i].id;
40025710:	00a91023          	sh	a0,0(s2)
		if (!ctx->servers[j].net_ctx) {
40025714:	01842783          	lw	a5,24(s0)
40025718:	02078c63          	beqz	a5,40025750 <dns_resolve_name+0x2cc>
		ret = dns_write(ctx, j, i, dns_data, dns_qname, hop_limit);
4002571c:	000a0693          	mv	a3,s4
40025720:	00098613          	mv	a2,s3
40025724:	00000593          	li	a1,0
40025728:	00040513          	mv	a0,s0
4002572c:	d14ff0ef          	jal	ra,40024c40 <dns_write.constprop.0>
		if (ret < 0) {
40025730:	02055063          	bgez	a0,40025750 <dns_resolve_name+0x2cc>
			release_query(&ctx->queries[i]);
40025734:	000a8513          	mv	a0,s5
40025738:	f95fe0ef          	jal	ra,400246cc <release_query>
			ret = -ENOENT;
4002573c:	ffe00493          	li	s1,-2
		if (dns_id) {
40025740:	06091863          	bnez	s2,400257b0 <dns_resolve_name+0x32c>
		net_buf_unref(dns_data);
40025744:	00098513          	mv	a0,s3
40025748:	9c8e40ef          	jal	ra,40009910 <net_buf_unref>
	if (dns_qname) {
4002574c:	0100006f          	j	4002575c <dns_resolve_name+0x2d8>
		net_buf_unref(dns_data);
40025750:	00098513          	mv	a0,s3
40025754:	9bce40ef          	jal	ra,40009910 <net_buf_unref>
	ret = 0;
40025758:	00000493          	li	s1,0
		net_buf_unref(dns_qname);
4002575c:	000a0513          	mv	a0,s4
40025760:	9b0e40ef          	jal	ra,40009910 <net_buf_unref>
40025764:	0200006f          	j	40025784 <dns_resolve_name+0x300>
			release_query(&ctx->queries[i]);
40025768:	000a8513          	mv	a0,s5
4002576c:	f61fe0ef          	jal	ra,400246cc <release_query>
		if (dns_id) {
40025770:	00090463          	beqz	s2,40025778 <dns_resolve_name+0x2f4>
			*dns_id = 0U;
40025774:	00091023          	sh	zero,0(s2)
		net_buf_unref(dns_data);
40025778:	00098513          	mv	a0,s3
4002577c:	994e40ef          	jal	ra,40009910 <net_buf_unref>
		ret = -ENOMEM;
40025780:	ff400493          	li	s1,-12
	k_mutex_unlock(&ctx->lock);
40025784:	000b8513          	mv	a0,s7
40025788:	afcff0ef          	jal	ra,40024a84 <k_mutex_unlock.isra.0>
	return ret;
4002578c:	e3dff06f          	j	400255c8 <dns_resolve_name+0x144>
			release_query(&ctx->queries[i]);
40025790:	000a8513          	mv	a0,s5
40025794:	f39fe0ef          	jal	ra,400246cc <release_query>
40025798:	fa9ff06f          	j	40025740 <dns_resolve_name+0x2bc>
4002579c:	000a8513          	mv	a0,s5
400257a0:	f2dfe0ef          	jal	ra,400246cc <release_query>
		if (dns_id) {
400257a4:	fc090ee3          	beqz	s2,40025780 <dns_resolve_name+0x2fc>
			*dns_id = 0U;
400257a8:	00091023          	sh	zero,0(s2)
	if (dns_qname) {
400257ac:	fd5ff06f          	j	40025780 <dns_resolve_name+0x2fc>
			*dns_id = 0U;
400257b0:	00091023          	sh	zero,0(s2)
400257b4:	f91ff06f          	j	40025744 <dns_resolve_name+0x2c0>
		ret = -EAGAIN;
400257b8:	ff500493          	li	s1,-11
400257bc:	fc9ff06f          	j	40025784 <dns_resolve_name+0x300>

400257c0 <dns_resolve_reconfigure>:
}

int dns_resolve_reconfigure(struct dns_resolve_context *ctx,
			    const char *servers[],
			    const struct sockaddr *servers_sa[])
{
400257c0:	fc010113          	addi	sp,sp,-64
400257c4:	02912a23          	sw	s1,52(sp)
400257c8:	02112e23          	sw	ra,60(sp)
400257cc:	02812c23          	sw	s0,56(sp)
400257d0:	03212823          	sw	s2,48(sp)
400257d4:	03312623          	sw	s3,44(sp)
400257d8:	03412423          	sw	s4,40(sp)
	int err;

	if (!ctx) {
		return -ENOENT;
400257dc:	ffe00493          	li	s1,-2
	if (!ctx) {
400257e0:	04050663          	beqz	a0,4002582c <dns_resolve_reconfigure+0x6c>
	}

	k_mutex_lock(&ctx->lock, K_FOREVER);
400257e4:	02050a13          	addi	s4,a0,32
400257e8:	00058913          	mv	s2,a1
400257ec:	00050413          	mv	s0,a0
400257f0:	00060993          	mv	s3,a2
400257f4:	fff00593          	li	a1,-1
400257f8:	fff00613          	li	a2,-1
400257fc:	000a0513          	mv	a0,s4
40025800:	ec9fe0ef          	jal	ra,400246c8 <k_mutex_lock>
	if (servers) {
40025804:	04091663          	bnez	s2,40025850 <dns_resolve_reconfigure+0x90>
	if (servers_sa) {
40025808:	00098c63          	beqz	s3,40025820 <dns_resolve_reconfigure+0x60>
		for (int i = 0; i < SERVER_COUNT && servers_sa[i]; i++) {
4002580c:	0009a583          	lw	a1,0(s3)
40025810:	00058863          	beqz	a1,40025820 <dns_resolve_reconfigure+0x60>
			if (!dns_server_exists(ctx, servers_sa[i])) {
40025814:	00040513          	mv	a0,s0
40025818:	ee9fe0ef          	jal	ra,40024700 <dns_server_exists>
4002581c:	06050463          	beqz	a0,40025884 <dns_resolve_reconfigure+0xc4>

	if (dns_servers_exists(ctx, servers, servers_sa)) {
		/* DNS servers did not change. */
		err = 0;
40025820:	00000493          	li	s1,0
	}

	err = dns_resolve_init_locked(ctx, servers, servers_sa);

unlock:
	k_mutex_unlock(&ctx->lock);
40025824:	000a0513          	mv	a0,s4
40025828:	a5cff0ef          	jal	ra,40024a84 <k_mutex_unlock.isra.0>

	return err;
}
4002582c:	03c12083          	lw	ra,60(sp)
40025830:	03812403          	lw	s0,56(sp)
40025834:	03012903          	lw	s2,48(sp)
40025838:	02c12983          	lw	s3,44(sp)
4002583c:	02812a03          	lw	s4,40(sp)
40025840:	00048513          	mv	a0,s1
40025844:	03412483          	lw	s1,52(sp)
40025848:	04010113          	addi	sp,sp,64
4002584c:	00008067          	ret
		for (int i = 0; i < SERVER_COUNT && servers[i]; i++) {
40025850:	00092483          	lw	s1,0(s2)
40025854:	fa048ae3          	beqz	s1,40025808 <dns_resolve_reconfigure+0x48>
			if (!net_ipaddr_parse(servers[i], strlen(servers[i]), &addr)) {
40025858:	00048513          	mv	a0,s1
4002585c:	ecce30ef          	jal	ra,40008f28 <strlen>
40025860:	00050593          	mv	a1,a0
40025864:	00810613          	addi	a2,sp,8
40025868:	00048513          	mv	a0,s1
4002586c:	97ceb0ef          	jal	ra,400109e8 <net_ipaddr_parse>
40025870:	f8050ce3          	beqz	a0,40025808 <dns_resolve_reconfigure+0x48>
			if (!dns_server_exists(ctx, &addr)) {
40025874:	00810593          	addi	a1,sp,8
40025878:	00040513          	mv	a0,s0
4002587c:	e85fe0ef          	jal	ra,40024700 <dns_server_exists>
40025880:	f80514e3          	bnez	a0,40025808 <dns_resolve_reconfigure+0x48>
	if (ctx->state == DNS_RESOLVE_CONTEXT_DEACTIVATING) {
40025884:	09842783          	lw	a5,152(s0)
40025888:	00100713          	li	a4,1
		err = -EBUSY;
4002588c:	ff000493          	li	s1,-16
	if (ctx->state == DNS_RESOLVE_CONTEXT_DEACTIVATING) {
40025890:	f8e78ae3          	beq	a5,a4,40025824 <dns_resolve_reconfigure+0x64>
	if (ctx->state == DNS_RESOLVE_CONTEXT_ACTIVE) {
40025894:	00078e63          	beqz	a5,400258b0 <dns_resolve_reconfigure+0xf0>
	err = dns_resolve_init_locked(ctx, servers, servers_sa);
40025898:	00098613          	mv	a2,s3
4002589c:	00090593          	mv	a1,s2
400258a0:	00040513          	mv	a0,s0
400258a4:	858ff0ef          	jal	ra,400248fc <dns_resolve_init_locked>
400258a8:	00050493          	mv	s1,a0
400258ac:	f79ff06f          	j	40025824 <dns_resolve_reconfigure+0x64>
		if (ctx->queries[i].cb && ctx->queries[i].query) {
400258b0:	07442783          	lw	a5,116(s0)
400258b4:	02078463          	beqz	a5,400258dc <dns_resolve_reconfigure+0x11c>
400258b8:	08842783          	lw	a5,136(s0)
400258bc:	02078063          	beqz	a5,400258dc <dns_resolve_reconfigure+0x11c>
	invoke_query_callback(DNS_EAI_CANCELED, NULL, &ctx->queries[slot]);
400258c0:	04040493          	addi	s1,s0,64
400258c4:	f9b00513          	li	a0,-101
400258c8:	00048613          	mv	a2,s1
400258cc:	00000593          	li	a1,0
400258d0:	db1fe0ef          	jal	ra,40024680 <invoke_query_callback>
	release_query(&ctx->queries[slot]);
400258d4:	00048513          	mv	a0,s1
400258d8:	df5fe0ef          	jal	ra,400246cc <release_query>
		err = dns_resolve_close_locked(ctx);
400258dc:	00040513          	mv	a0,s0
400258e0:	ac4ff0ef          	jal	ra,40024ba4 <dns_resolve_close_locked>
400258e4:	00050493          	mv	s1,a0
		if (err) {
400258e8:	fa0508e3          	beqz	a0,40025898 <dns_resolve_reconfigure+0xd8>
400258ec:	f39ff06f          	j	40025824 <dns_resolve_reconfigure+0x64>

400258f0 <dns_resolve_get_default>:

struct dns_resolve_context *dns_resolve_get_default(void)
{
	return &dns_default_ctx;
400258f0:	40031537          	lui	a0,0x40031
}
400258f4:	25050513          	addi	a0,a0,592 # 40031250 <dns_default_ctx>
400258f8:	00008067          	ret

400258fc <dns_init_resolver>:
	}
#else
	/* We must always call init even if there are no servers configured so
	 * that DNS mutex gets initialized properly.
	 */
	(void)dns_resolve_init(dns_resolve_get_default(), NULL, NULL);
400258fc:	40031537          	lui	a0,0x40031
40025900:	00000613          	li	a2,0
40025904:	00000593          	li	a1,0
40025908:	25050513          	addi	a0,a0,592 # 40031250 <dns_default_ctx>
4002590c:	ca4ff06f          	j	40024db0 <dns_resolve_init>

40025910 <vexriscv_litex_irq_handler>:
				:: "r"(MSTATUS_IEN));
	}
}

static void vexriscv_litex_irq_handler(const void *device)
{
40025910:	ff010113          	addi	sp,sp,-16
40025914:	00112623          	sw	ra,12(sp)
40025918:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrr %0, %1" : "=r"(pending) : "i"(IRQ_PENDING));
4002591c:	fc0027f3          	csrr	a5,0xfc0
	__asm__ volatile ("csrr %0, %1" : "=r"(mask) : "i"(IRQ_MASK));
40025920:	bc002473          	csrr	s0,0xbc0
	struct _isr_table_entry *ite;
	uint32_t pending, mask, irqs;

	pending = vexriscv_litex_irq_pending();
	mask = vexriscv_litex_irq_getmask();
	irqs = pending & mask;
40025924:	00f47433          	and	s0,s0,a5

#ifdef CONFIG_LITEX_TIMER
	if (irqs & (1 << TIMER0_IRQ)) {
40025928:	00247793          	andi	a5,s0,2
4002592c:	00078c63          	beqz	a5,40025944 <vexriscv_litex_irq_handler+0x34>
		ite = &_sw_isr_table[TIMER0_IRQ];
		ite->isr(ite->arg);
40025930:	4002c7b7          	lui	a5,0x4002c
40025934:	8d478793          	addi	a5,a5,-1836 # 4002b8d4 <_sw_isr_table>
40025938:	00c7a703          	lw	a4,12(a5)
4002593c:	0087a503          	lw	a0,8(a5)
40025940:	000700e7          	jalr	a4
		ite->isr(ite->arg);
	}
#endif

#ifdef CONFIG_ETH_LITEETH
	if (irqs & (1 << ETH0_IRQ)) {
40025944:	00447793          	andi	a5,s0,4
40025948:	00078c63          	beqz	a5,40025960 <vexriscv_litex_irq_handler+0x50>
		ite = &_sw_isr_table[ETH0_IRQ];
		ite->isr(ite->arg);
4002594c:	4002c7b7          	lui	a5,0x4002c
40025950:	8d478793          	addi	a5,a5,-1836 # 4002b8d4 <_sw_isr_table>
40025954:	0147a703          	lw	a4,20(a5)
40025958:	0107a503          	lw	a0,16(a5)
4002595c:	000700e7          	jalr	a4
		ite = &_sw_isr_table[I2S_TX_IRQ];
		ite->isr(ite->arg);
	}
#endif

	if (irqs & (1 << GPIO_IRQ)) {
40025960:	01047413          	andi	s0,s0,16
40025964:	02040263          	beqz	s0,40025988 <vexriscv_litex_irq_handler+0x78>
		ite = &_sw_isr_table[GPIO_IRQ];
		ite->isr(ite->arg);
40025968:	4002c7b7          	lui	a5,0x4002c
	}
}
4002596c:	00812403          	lw	s0,8(sp)
		ite->isr(ite->arg);
40025970:	8d478793          	addi	a5,a5,-1836 # 4002b8d4 <_sw_isr_table>
}
40025974:	00c12083          	lw	ra,12(sp)
		ite->isr(ite->arg);
40025978:	0247a703          	lw	a4,36(a5)
4002597c:	0207a503          	lw	a0,32(a5)
}
40025980:	01010113          	addi	sp,sp,16
		ite->isr(ite->arg);
40025984:	00070067          	jr	a4
}
40025988:	00c12083          	lw	ra,12(sp)
4002598c:	00812403          	lw	s0,8(sp)
40025990:	01010113          	addi	sp,sp,16
40025994:	00008067          	ret

40025998 <vexriscv_litex_irq_init>:
	return vexriscv_litex_irq_getmask() & (1 << irq);
}

static int vexriscv_litex_irq_init(void)
{
	__asm__ volatile ("csrrs x0, mie, %0"
40025998:	000017b7          	lui	a5,0x1
4002599c:	80078793          	addi	a5,a5,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
400259a0:	3047a073          	csrs	mie,a5
		__asm__ volatile ("csrrs x0, mstatus, %0"
400259a4:	00800793          	li	a5,8
400259a8:	3007a073          	csrs	mstatus,a5
	vexriscv_litex_irq_setie(1);
	IRQ_CONNECT(RISCV_MACHINE_EXT_IRQ, 0, vexriscv_litex_irq_handler,
			NULL, 0);

	return 0;
}
400259ac:	00000513          	li	a0,0
400259b0:	00008067          	ret

400259b4 <arch_irq_enable>:
	__asm__ volatile ("csrr %0, %1" : "=r"(mask) : "i"(IRQ_MASK));
400259b4:	bc002773          	csrr	a4,0xbc0
	vexriscv_litex_irq_setmask(vexriscv_litex_irq_getmask() | (1 << irq));
400259b8:	00100793          	li	a5,1
400259bc:	00a79533          	sll	a0,a5,a0
400259c0:	00e56533          	or	a0,a0,a4
	__asm__ volatile ("csrw %0, %1" :: "i"(IRQ_MASK), "r"(mask));
400259c4:	bc051073          	csrw	0xbc0,a0
}
400259c8:	00008067          	ret

400259cc <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(void)
{
400259cc:	ff010113          	addi	sp,sp,-16
400259d0:	00112623          	sw	ra,12(sp)
400259d4:	00812423          	sw	s0,8(sp)
400259d8:	4002c537          	lui	a0,0x4002c
400259dc:	87450513          	addi	a0,a0,-1932 # 4002b874 <__device_dts_ord_20>
400259e0:	701010ef          	jal	ra,400278e0 <z_device_is_ready>
400259e4:	fed00793          	li	a5,-19
	if (!device_is_ready(uart_console_dev)) {
400259e8:	00050e63          	beqz	a0,40025a04 <uart_console_init+0x38>
	__stdout_hook_install(console_out);
400259ec:	40026437          	lui	s0,0x40026
400259f0:	a1840513          	addi	a0,s0,-1512 # 40025a18 <console_out>
400259f4:	ed0e30ef          	jal	ra,400090c4 <__stdout_hook_install>
	__printk_hook_install(console_out);
400259f8:	a1840513          	addi	a0,s0,-1512
400259fc:	d14db0ef          	jal	ra,40000f10 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
40025a00:	00000793          	li	a5,0
}
40025a04:	00c12083          	lw	ra,12(sp)
40025a08:	00812403          	lw	s0,8(sp)
40025a0c:	00078513          	mv	a0,a5
40025a10:	01010113          	addi	sp,sp,16
40025a14:	00008067          	ret

40025a18 <console_out>:
{
40025a18:	ff010113          	addi	sp,sp,-16
40025a1c:	00812423          	sw	s0,8(sp)
40025a20:	00912223          	sw	s1,4(sp)
40025a24:	01212023          	sw	s2,0(sp)
40025a28:	4002c4b7          	lui	s1,0x4002c
40025a2c:	00112623          	sw	ra,12(sp)
	if ('\n' == c) {
40025a30:	00a00793          	li	a5,10
{
40025a34:	00050413          	mv	s0,a0
40025a38:	87448913          	addi	s2,s1,-1932 # 4002b874 <__device_dts_ord_20>
	if ('\n' == c) {
40025a3c:	00f51c63          	bne	a0,a5,40025a54 <console_out+0x3c>
	api->poll_out(dev, out_char);
40025a40:	00892783          	lw	a5,8(s2)
40025a44:	00d00593          	li	a1,13
40025a48:	87448513          	addi	a0,s1,-1932
40025a4c:	0047a783          	lw	a5,4(a5)
40025a50:	000780e7          	jalr	a5
40025a54:	00892783          	lw	a5,8(s2)
40025a58:	87448513          	addi	a0,s1,-1932
40025a5c:	0ff47593          	zext.b	a1,s0
40025a60:	0047a783          	lw	a5,4(a5)
40025a64:	000780e7          	jalr	a5
}
40025a68:	00c12083          	lw	ra,12(sp)
40025a6c:	00040513          	mv	a0,s0
40025a70:	00812403          	lw	s0,8(sp)
40025a74:	00412483          	lw	s1,4(sp)
40025a78:	00012903          	lw	s2,0(sp)
40025a7c:	01010113          	addi	sp,sp,16
40025a80:	00008067          	ret

40025a84 <entropy_prbs_get_entropy>:
#define PRBS_STATUS     DT_INST_REG_ADDR(0)
#define PRBS_WIDTH      DT_INST_REG_SIZE(0)

static int entropy_prbs_get_entropy(const struct device *dev, uint8_t *buffer,
					 uint16_t length)
{
40025a84:	fd010113          	addi	sp,sp,-48
40025a88:	02812423          	sw	s0,40(sp)
40025a8c:	03212023          	sw	s2,32(sp)
40025a90:	01312e23          	sw	s3,28(sp)
40025a94:	01412c23          	sw	s4,24(sp)
40025a98:	02112623          	sw	ra,44(sp)
40025a9c:	02912223          	sw	s1,36(sp)
40025aa0:	00058913          	mv	s2,a1
40025aa4:	00060413          	mv	s0,a2
40025aa8:	e00079b7          	lui	s3,0xe0007
	while (length > 0) {
		size_t to_copy;
		uint32_t value;

		value = litex_read(PRBS_STATUS, PRBS_WIDTH);
		to_copy = MIN(length, sizeof(value));
40025aac:	00400a13          	li	s4,4
	while (length > 0) {
40025ab0:	02041463          	bnez	s0,40025ad8 <entropy_prbs_get_entropy+0x54>
		memcpy(buffer, &value, to_copy);
		buffer += to_copy;
		length -= to_copy;
	}
	return 0;
}
40025ab4:	02c12083          	lw	ra,44(sp)
40025ab8:	02812403          	lw	s0,40(sp)
40025abc:	02412483          	lw	s1,36(sp)
40025ac0:	02012903          	lw	s2,32(sp)
40025ac4:	01c12983          	lw	s3,28(sp)
40025ac8:	01812a03          	lw	s4,24(sp)
40025acc:	00000513          	li	a0,0
40025ad0:	03010113          	addi	sp,sp,48
40025ad4:	00008067          	ret
40025ad8:	8009a783          	lw	a5,-2048(s3) # e0006800 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe0006801>
		to_copy = MIN(length, sizeof(value));
40025adc:	00040493          	mv	s1,s0
		value = litex_read(PRBS_STATUS, PRBS_WIDTH);
40025ae0:	00f12623          	sw	a5,12(sp)
		to_copy = MIN(length, sizeof(value));
40025ae4:	008a7463          	bgeu	s4,s0,40025aec <entropy_prbs_get_entropy+0x68>
40025ae8:	00400493          	li	s1,4
40025aec:	01049493          	slli	s1,s1,0x10
40025af0:	0104d493          	srli	s1,s1,0x10
		length -= to_copy;
40025af4:	40940433          	sub	s0,s0,s1
		memcpy(buffer, &value, to_copy);
40025af8:	00090513          	mv	a0,s2
40025afc:	00048613          	mv	a2,s1
40025b00:	00c10593          	addi	a1,sp,12
		length -= to_copy;
40025b04:	01041413          	slli	s0,s0,0x10
		memcpy(buffer, &value, to_copy);
40025b08:	d44e30ef          	jal	ra,4000904c <memcpy>
		buffer += to_copy;
40025b0c:	00990933          	add	s2,s2,s1
		length -= to_copy;
40025b10:	01045413          	srli	s0,s0,0x10
40025b14:	f9dff06f          	j	40025ab0 <entropy_prbs_get_entropy+0x2c>

40025b18 <litex_write>:
 * Size is in bytes and meaningful are 1, 2 or 4
 * Address must be aligned to 4 bytes
 */
static inline void litex_write(uint32_t addr, uint32_t size, uint32_t value)
{
	switch (size) {
40025b18:	00200793          	li	a5,2
40025b1c:	02f58063          	beq	a1,a5,40025b3c <litex_write+0x24>
40025b20:	00400793          	li	a5,4
40025b24:	02f58463          	beq	a1,a5,40025b4c <litex_write+0x34>
40025b28:	00100793          	li	a5,1
40025b2c:	02f59263          	bne	a1,a5,40025b50 <litex_write+0x38>
	case 1:
		litex_write8(value, addr);
40025b30:	0ff67613          	zext.b	a2,a2
	*(volatile uint8_t *)addr = data;
40025b34:	00c50023          	sb	a2,0(a0)
}
40025b38:	00008067          	ret
		break;
	case 2:
		litex_write16(value, addr);
40025b3c:	01061613          	slli	a2,a2,0x10
40025b40:	01065613          	srli	a2,a2,0x10
	*(volatile uint16_t *)addr = data;
40025b44:	00c51023          	sh	a2,0(a0)
}
40025b48:	00008067          	ret
	*(volatile uint32_t *)addr = data;
40025b4c:	00c52023          	sw	a2,0(a0)
		litex_write32(value, addr);
		break;
	default:
		break;
	}
}
40025b50:	00008067          	ret

40025b54 <litex_read>:
 * Size is in bytes and meaningful are 1, 2 or 4
 * Address must be aligned to 4 bytes
 */
static inline uint32_t litex_read(uint32_t addr, uint32_t size)
{
	switch (size) {
40025b54:	00200713          	li	a4,2
{
40025b58:	00050793          	mv	a5,a0
	switch (size) {
40025b5c:	02e58263          	beq	a1,a4,40025b80 <litex_read+0x2c>
40025b60:	00400713          	li	a4,4
40025b64:	02e58663          	beq	a1,a4,40025b90 <litex_read+0x3c>
40025b68:	00100713          	li	a4,1
40025b6c:	00000513          	li	a0,0
40025b70:	02e59263          	bne	a1,a4,40025b94 <litex_read+0x40>
	return *(volatile uint8_t *)addr;
40025b74:	0007c503          	lbu	a0,0(a5)
40025b78:	0ff57513          	zext.b	a0,a0
	case 1:
		return litex_read8(addr);
40025b7c:	00008067          	ret
	return *(volatile uint16_t *)addr;
40025b80:	00055503          	lhu	a0,0(a0)
40025b84:	01051513          	slli	a0,a0,0x10
40025b88:	01055513          	srli	a0,a0,0x10
	case 2:
		return litex_read16(addr);
40025b8c:	00008067          	ret
	return *(volatile uint32_t *)addr;
40025b90:	00052503          	lw	a0,0(a0)
	case 4:
		return litex_read32(addr);
	default:
		return 0;
	}
}
40025b94:	00008067          	ret

40025b98 <set_bit>:

/* Helper functions for bit / port access */

static inline void set_bit(const struct gpio_litex_cfg *config,
			   uint32_t bit, bool val)
{
40025b98:	fe010113          	addi	sp,sp,-32
40025b9c:	00812c23          	sw	s0,24(sp)
40025ba0:	00912a23          	sw	s1,20(sp)
40025ba4:	00112e23          	sw	ra,28(sp)
40025ba8:	01212823          	sw	s2,16(sp)
	int regv, new_regv;

	regv = litex_read(config->reg_addr, config->reg_size);
40025bac:	00052903          	lw	s2,0(a0)
{
40025bb0:	00058493          	mv	s1,a1
	regv = litex_read(config->reg_addr, config->reg_size);
40025bb4:	00452583          	lw	a1,4(a0)
40025bb8:	00090513          	mv	a0,s2
{
40025bbc:	00060413          	mv	s0,a2
	regv = litex_read(config->reg_addr, config->reg_size);
40025bc0:	00b12623          	sw	a1,12(sp)
40025bc4:	f91ff0ef          	jal	ra,40025b54 <litex_read>
	new_regv = (regv & ~BIT(bit)) | (val << bit);
40025bc8:	00100793          	li	a5,1
40025bcc:	009797b3          	sll	a5,a5,s1
40025bd0:	00941633          	sll	a2,s0,s1
40025bd4:	fff7c793          	not	a5,a5
	litex_write(config->reg_addr, config->reg_size, new_regv);
}
40025bd8:	01812403          	lw	s0,24(sp)
	litex_write(config->reg_addr, config->reg_size, new_regv);
40025bdc:	00c12583          	lw	a1,12(sp)
}
40025be0:	01c12083          	lw	ra,28(sp)
40025be4:	01412483          	lw	s1,20(sp)
	new_regv = (regv & ~BIT(bit)) | (val << bit);
40025be8:	00a7f7b3          	and	a5,a5,a0
	litex_write(config->reg_addr, config->reg_size, new_regv);
40025bec:	00090513          	mv	a0,s2
}
40025bf0:	01012903          	lw	s2,16(sp)
	litex_write(config->reg_addr, config->reg_size, new_regv);
40025bf4:	00c7e633          	or	a2,a5,a2
}
40025bf8:	02010113          	addi	sp,sp,32
	litex_write(config->reg_addr, config->reg_size, new_regv);
40025bfc:	f1dff06f          	j	40025b18 <litex_write>

40025c00 <get_port>:
{
	litex_write(config->reg_addr, config->reg_size, value);
}

static inline uint32_t get_port(const struct gpio_litex_cfg *config)
{
40025c00:	ff010113          	addi	sp,sp,-16
40025c04:	00812423          	sw	s0,8(sp)
40025c08:	00112623          	sw	ra,12(sp)
40025c0c:	00050413          	mv	s0,a0
	int regv = litex_read(config->reg_addr, config->reg_size);
40025c10:	00452583          	lw	a1,4(a0)
40025c14:	00052503          	lw	a0,0(a0)
40025c18:	f3dff0ef          	jal	ra,40025b54 <litex_read>

	return (regv & BIT_MASK(config->nr_gpios));
40025c1c:	01842703          	lw	a4,24(s0)
}
40025c20:	00c12083          	lw	ra,12(sp)
40025c24:	00812403          	lw	s0,8(sp)
	return (regv & BIT_MASK(config->nr_gpios));
40025c28:	fff00793          	li	a5,-1
40025c2c:	00e797b3          	sll	a5,a5,a4
40025c30:	fff7c793          	not	a5,a5
}
40025c34:	00a7f533          	and	a0,a5,a0
40025c38:	01010113          	addi	sp,sp,16
40025c3c:	00008067          	ret

40025c40 <gpio_litex_configure>:
static int gpio_litex_configure(const struct device *dev,
				gpio_pin_t pin, gpio_flags_t flags)
{
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);

	if (flags & ~SUPPORTED_FLAGS) {
40025c40:	fff107b7          	lui	a5,0xfff10
40025c44:	ffe78793          	addi	a5,a5,-2 # fff0fffe <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfff0ffff>
40025c48:	00f677b3          	and	a5,a2,a5
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
40025c4c:	00452503          	lw	a0,4(a0)
	if (flags & ~SUPPORTED_FLAGS) {
40025c50:	08079263          	bnez	a5,40025cd4 <gpio_litex_configure+0x94>
		return -ENOTSUP;
	}

	if ((flags & GPIO_OUTPUT) && (flags & GPIO_INPUT)) {
40025c54:	000306b7          	lui	a3,0x30
40025c58:	00d67733          	and	a4,a2,a3
		return -ENOTSUP;
40025c5c:	f7a00793          	li	a5,-134
	if ((flags & GPIO_OUTPUT) && (flags & GPIO_INPUT)) {
40025c60:	06d70c63          	beq	a4,a3,40025cd8 <gpio_litex_configure+0x98>
		/* Pin cannot be configured as input and output */
		return -ENOTSUP;
	} else if (!(flags & (GPIO_INPUT | GPIO_OUTPUT))) {
40025c64:	06070a63          	beqz	a4,40025cd8 <gpio_litex_configure+0x98>
		/* Pin has to be configured as input or output */
		return -ENOTSUP;
	}

	if (flags & GPIO_OUTPUT) {
40025c68:	000207b7          	lui	a5,0x20
40025c6c:	00f677b3          	and	a5,a2,a5
		if (!gpio_config->port_is_output) {
40025c70:	01c54703          	lbu	a4,28(a0)
	if (flags & GPIO_OUTPUT) {
40025c74:	04078863          	beqz	a5,40025cc4 <gpio_litex_configure+0x84>
			LOG_ERR("%s", LITEX_LOG_CANNOT_CHANGE_DIR);
			return -EINVAL;
40025c78:	fea00793          	li	a5,-22
		if (!gpio_config->port_is_output) {
40025c7c:	04070e63          	beqz	a4,40025cd8 <gpio_litex_configure+0x98>
{
40025c80:	ff010113          	addi	sp,sp,-16
		}

		if (flags & GPIO_OUTPUT_INIT_HIGH) {
40025c84:	000807b7          	lui	a5,0x80
{
40025c88:	00112623          	sw	ra,12(sp)
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
40025c8c:	00f677b3          	and	a5,a2,a5
40025c90:	02078063          	beqz	a5,40025cb0 <gpio_litex_configure+0x70>
			set_bit(gpio_config, pin, GPIO_HIGH);
40025c94:	00100613          	li	a2,1
40025c98:	f01ff0ef          	jal	ra,40025b98 <set_bit>
			return -EINVAL;
		}
	}

	return 0;
}
40025c9c:	00c12083          	lw	ra,12(sp)
	return 0;
40025ca0:	00000793          	li	a5,0
}
40025ca4:	00078513          	mv	a0,a5
40025ca8:	01010113          	addi	sp,sp,16
40025cac:	00008067          	ret
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
40025cb0:	000407b7          	lui	a5,0x40
40025cb4:	00f67633          	and	a2,a2,a5
40025cb8:	fe0602e3          	beqz	a2,40025c9c <gpio_litex_configure+0x5c>
			set_bit(gpio_config, pin, GPIO_LOW);
40025cbc:	00000613          	li	a2,0
40025cc0:	fd9ff06f          	j	40025c98 <gpio_litex_configure+0x58>
			return -EINVAL;
40025cc4:	fea00793          	li	a5,-22
		if (gpio_config->port_is_output) {
40025cc8:	00071863          	bnez	a4,40025cd8 <gpio_litex_configure+0x98>
	return 0;
40025ccc:	00000793          	li	a5,0
40025cd0:	0080006f          	j	40025cd8 <gpio_litex_configure+0x98>
		return -ENOTSUP;
40025cd4:	f7a00793          	li	a5,-134
}
40025cd8:	00078513          	mv	a0,a5
40025cdc:	00008067          	ret

40025ce0 <gpio_litex_port_get_raw>:

static int gpio_litex_port_get_raw(const struct device *dev,
				   gpio_port_value_t *value)
{
40025ce0:	ff010113          	addi	sp,sp,-16
40025ce4:	00812423          	sw	s0,8(sp)
40025ce8:	00112623          	sw	ra,12(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);

	*value = get_port(gpio_config);
40025cec:	00452503          	lw	a0,4(a0)
{
40025cf0:	00058413          	mv	s0,a1
	*value = get_port(gpio_config);
40025cf4:	f0dff0ef          	jal	ra,40025c00 <get_port>
40025cf8:	00a42023          	sw	a0,0(s0)
	return 0;
}
40025cfc:	00c12083          	lw	ra,12(sp)
40025d00:	00812403          	lw	s0,8(sp)
40025d04:	00000513          	li	a0,0
40025d08:	01010113          	addi	sp,sp,16
40025d0c:	00008067          	ret

40025d10 <gpio_litex_port_set_masked_raw>:

static int gpio_litex_port_set_masked_raw(const struct device *dev,
					  gpio_port_pins_t mask,
					  gpio_port_value_t value)
{
40025d10:	ff010113          	addi	sp,sp,-16
40025d14:	00112623          	sw	ra,12(sp)
40025d18:	00812423          	sw	s0,8(sp)
40025d1c:	01212023          	sw	s2,0(sp)
40025d20:	00912223          	sw	s1,4(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
40025d24:	00452483          	lw	s1,4(a0)
{
40025d28:	00058913          	mv	s2,a1
40025d2c:	00060413          	mv	s0,a2
	uint32_t port_val;

	port_val = get_port(gpio_config);
40025d30:	00048513          	mv	a0,s1
40025d34:	ecdff0ef          	jal	ra,40025c00 <get_port>
	port_val = (port_val & ~mask) | (value & mask);
40025d38:	00854433          	xor	s0,a0,s0
40025d3c:	01247633          	and	a2,s0,s2
	litex_write(config->reg_addr, config->reg_size, value);
40025d40:	0044a583          	lw	a1,4(s1)
40025d44:	00c54633          	xor	a2,a0,a2
40025d48:	0004a503          	lw	a0,0(s1)
40025d4c:	dcdff0ef          	jal	ra,40025b18 <litex_write>
	set_port(gpio_config, port_val);

	return 0;
}
40025d50:	00c12083          	lw	ra,12(sp)
40025d54:	00812403          	lw	s0,8(sp)
40025d58:	00412483          	lw	s1,4(sp)
40025d5c:	00012903          	lw	s2,0(sp)
40025d60:	00000513          	li	a0,0
40025d64:	01010113          	addi	sp,sp,16
40025d68:	00008067          	ret

40025d6c <gpio_litex_manage_callback>:
}

static int gpio_litex_manage_callback(const struct device *dev,
				      struct gpio_callback *callback, bool set)
{
	struct gpio_litex_data *data = dev->data;
40025d6c:	01052783          	lw	a5,16(a0)
	return list->head;
40025d70:	0087a703          	lw	a4,8(a5) # 40008 <__rom_region_size+0xf62c>
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
40025d74:	06070663          	beqz	a4,40025de0 <gpio_litex_manage_callback+0x74>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40025d78:	04b71e63          	bne	a4,a1,40025dd4 <gpio_litex_manage_callback+0x68>
	return node->next;
40025d7c:	0005a703          	lw	a4,0(a1)
Z_GENLIST_REMOVE(slist, snode)
40025d80:	00c7a683          	lw	a3,12(a5)
	list->head = node;
40025d84:	00e7a423          	sw	a4,8(a5)
Z_GENLIST_REMOVE(slist, snode)
40025d88:	00d59463          	bne	a1,a3,40025d90 <gpio_litex_manage_callback+0x24>
	list->tail = node;
40025d8c:	00e7a623          	sw	a4,12(a5)
	parent->next = child;
40025d90:	0005a023          	sw	zero,0(a1)
		}
	} else if (!set) {
		return -EINVAL;
	}

	if (set) {
40025d94:	00060e63          	beqz	a2,40025db0 <gpio_litex_manage_callback+0x44>
	return list->head;
40025d98:	0087a703          	lw	a4,8(a5)
	parent->next = child;
40025d9c:	00e5a023          	sw	a4,0(a1)
Z_GENLIST_PREPEND(slist, snode)
40025da0:	00c7a703          	lw	a4,12(a5)
	list->head = node;
40025da4:	00b7a423          	sw	a1,8(a5)
Z_GENLIST_PREPEND(slist, snode)
40025da8:	00071463          	bnez	a4,40025db0 <gpio_litex_manage_callback+0x44>
	list->tail = node;
40025dac:	00b7a623          	sw	a1,12(a5)
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
40025db0:	00000513          	li	a0,0

	return gpio_manage_callback(&data->cb, callback, set);
}
40025db4:	00008067          	ret
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40025db8:	00e59e63          	bne	a1,a4,40025dd4 <gpio_litex_manage_callback+0x68>
	return node->next;
40025dbc:	0005a703          	lw	a4,0(a1)
	parent->next = child;
40025dc0:	00e6a023          	sw	a4,0(a3) # 30000 <__kernel_ram_size+0x23d6c>
Z_GENLIST_REMOVE(slist, snode)
40025dc4:	00c7a703          	lw	a4,12(a5)
40025dc8:	fce594e3          	bne	a1,a4,40025d90 <gpio_litex_manage_callback+0x24>
	list->tail = node;
40025dcc:	00d7a623          	sw	a3,12(a5)
}
40025dd0:	fc1ff06f          	j	40025d90 <gpio_litex_manage_callback+0x24>
	return node->next;
40025dd4:	00070693          	mv	a3,a4
40025dd8:	00072703          	lw	a4,0(a4)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40025ddc:	fc071ee3          	bnez	a4,40025db8 <gpio_litex_manage_callback+0x4c>
			if (!set) {
40025de0:	fa061ce3          	bnez	a2,40025d98 <gpio_litex_manage_callback+0x2c>
				return -EINVAL;
40025de4:	fea00513          	li	a0,-22
40025de8:	00008067          	ret

40025dec <gpio_litex_pin_interrupt_configure>:

static int gpio_litex_pin_interrupt_configure(const struct device *dev,
					      gpio_pin_t pin,
					      enum gpio_int_mode mode,
					      enum gpio_int_trig trig)
{
40025dec:	fc010113          	addi	sp,sp,-64
40025df0:	02112e23          	sw	ra,60(sp)
40025df4:	02812c23          	sw	s0,56(sp)
40025df8:	02912a23          	sw	s1,52(sp)
40025dfc:	03212823          	sw	s2,48(sp)
40025e00:	03312623          	sw	s3,44(sp)
40025e04:	03412423          	sw	s4,40(sp)
40025e08:	03512223          	sw	s5,36(sp)
40025e0c:	03612023          	sw	s6,32(sp)
40025e10:	01712e23          	sw	s7,28(sp)
40025e14:	01812c23          	sw	s8,24(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
40025e18:	00452403          	lw	s0,4(a0)

	if (gpio_config->port_is_output == true) {
		return -ENOTSUP;
40025e1c:	f7a00513          	li	a0,-134
	if (gpio_config->port_is_output == true) {
40025e20:	01c44783          	lbu	a5,28(s0)
40025e24:	0c079c63          	bnez	a5,40025efc <gpio_litex_pin_interrupt_configure+0x110>
	}

	if (mode == GPIO_INT_MODE_EDGE) {
40025e28:	014007b7          	lui	a5,0x1400
40025e2c:	00058b13          	mv	s6,a1
40025e30:	10f61863          	bne	a2,a5,40025f40 <gpio_litex_pin_interrupt_configure+0x154>
		uint8_t ev_enabled = litex_read(gpio_config->ev_enable_addr,
40025e34:	00442c03          	lw	s8,4(s0)
40025e38:	00c42b83          	lw	s7,12(s0)
40025e3c:	00068a13          	mv	s4,a3
40025e40:	000c0593          	mv	a1,s8
40025e44:	000b8513          	mv	a0,s7
40025e48:	d0dff0ef          	jal	ra,40025b54 <litex_read>
40025e4c:	00050a93          	mv	s5,a0
				gpio_config->reg_size);
		uint8_t ev_mode = litex_read(gpio_config->ev_mode_addr,
40025e50:	01042503          	lw	a0,16(s0)
40025e54:	000c0593          	mv	a1,s8
				gpio_config->reg_size);
		uint8_t ev_edge = litex_read(gpio_config->ev_edge_addr,
				gpio_config->reg_size);

		litex_write(gpio_config->ev_enable_addr, gpio_config->reg_size,
			    ev_enabled | BIT(pin));
40025e58:	00100493          	li	s1,1
		uint8_t ev_mode = litex_read(gpio_config->ev_mode_addr,
40025e5c:	cf9ff0ef          	jal	ra,40025b54 <litex_read>
40025e60:	00050913          	mv	s2,a0
		uint8_t ev_edge = litex_read(gpio_config->ev_edge_addr,
40025e64:	01442503          	lw	a0,20(s0)
40025e68:	000c0593          	mv	a1,s8
			    ev_enabled | BIT(pin));
40025e6c:	016494b3          	sll	s1,s1,s6
		uint8_t ev_edge = litex_read(gpio_config->ev_edge_addr,
40025e70:	ce5ff0ef          	jal	ra,40025b54 <litex_read>
			    ev_enabled | BIT(pin));
40025e74:	0ffaf613          	zext.b	a2,s5
		uint8_t ev_edge = litex_read(gpio_config->ev_edge_addr,
40025e78:	00050993          	mv	s3,a0
		litex_write(gpio_config->ev_enable_addr, gpio_config->reg_size,
40025e7c:	00966633          	or	a2,a2,s1
40025e80:	000c0593          	mv	a1,s8
40025e84:	000b8513          	mv	a0,s7
40025e88:	c91ff0ef          	jal	ra,40025b18 <litex_write>

		if (trig == GPIO_INT_TRIG_HIGH) {
40025e8c:	040007b7          	lui	a5,0x4000
40025e90:	02fa1a63          	bne	s4,a5,40025ec4 <gpio_litex_pin_interrupt_configure+0xd8>
			/* Change mode to 'edge' and edge to 'rising' */
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
			    ev_mode & ~BIT(pin));
40025e94:	fff4c493          	not	s1,s1
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
40025e98:	00442583          	lw	a1,4(s0)
40025e9c:	01042503          	lw	a0,16(s0)
			    ev_mode & ~BIT(pin));
40025ea0:	00997633          	and	a2,s2,s1
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
40025ea4:	0ff67613          	zext.b	a2,a2
40025ea8:	c71ff0ef          	jal	ra,40025b18 <litex_write>
			litex_write(gpio_config->ev_edge_addr, gpio_config->reg_size,
			    ev_edge & ~BIT(pin));
40025eac:	0099f4b3          	and	s1,s3,s1
			litex_write(gpio_config->ev_edge_addr, gpio_config->reg_size,
40025eb0:	0ff4f613          	zext.b	a2,s1
		} else if (trig == GPIO_INT_TRIG_LOW) {
			/* Change mode to 'edge' and edge to 'falling' */
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
			    ev_mode & ~BIT(pin));
			litex_write(gpio_config->ev_edge_addr, gpio_config->reg_size,
40025eb4:	00442583          	lw	a1,4(s0)
40025eb8:	01442503          	lw	a0,20(s0)
	}

	if (mode == GPIO_INT_DISABLE) {
		uint8_t ev_enabled = litex_read(gpio_config->ev_enable_addr,
				gpio_config->reg_size);
		litex_write(gpio_config->ev_enable_addr, gpio_config->reg_size,
40025ebc:	c5dff0ef          	jal	ra,40025b18 <litex_write>
			    ev_enabled & ~BIT(pin));
		return 0;
40025ec0:	0380006f          	j	40025ef8 <gpio_litex_pin_interrupt_configure+0x10c>
		} else if (trig == GPIO_INT_TRIG_LOW) {
40025ec4:	020007b7          	lui	a5,0x2000
40025ec8:	02fa1463          	bne	s4,a5,40025ef0 <gpio_litex_pin_interrupt_configure+0x104>
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
40025ecc:	00442583          	lw	a1,4(s0)
40025ed0:	01042503          	lw	a0,16(s0)
			    ev_mode & ~BIT(pin));
40025ed4:	fff4c613          	not	a2,s1
40025ed8:	01267633          	and	a2,a2,s2
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
40025edc:	0ff67613          	zext.b	a2,a2
40025ee0:	c39ff0ef          	jal	ra,40025b18 <litex_write>
			    ev_edge | BIT(pin));
40025ee4:	0ff9f613          	zext.b	a2,s3
			litex_write(gpio_config->ev_edge_addr, gpio_config->reg_size,
40025ee8:	00966633          	or	a2,a2,s1
40025eec:	fc9ff06f          	j	40025eb4 <gpio_litex_pin_interrupt_configure+0xc8>
		} else if (trig == GPIO_INT_TRIG_BOTH) {
40025ef0:	060007b7          	lui	a5,0x6000
40025ef4:	02fa0c63          	beq	s4,a5,40025f2c <gpio_litex_pin_interrupt_configure+0x140>
		return 0;
40025ef8:	00000513          	li	a0,0
	}

	return -ENOTSUP;
}
40025efc:	03c12083          	lw	ra,60(sp)
40025f00:	03812403          	lw	s0,56(sp)
40025f04:	03412483          	lw	s1,52(sp)
40025f08:	03012903          	lw	s2,48(sp)
40025f0c:	02c12983          	lw	s3,44(sp)
40025f10:	02812a03          	lw	s4,40(sp)
40025f14:	02412a83          	lw	s5,36(sp)
40025f18:	02012b03          	lw	s6,32(sp)
40025f1c:	01c12b83          	lw	s7,28(sp)
40025f20:	01812c03          	lw	s8,24(sp)
40025f24:	04010113          	addi	sp,sp,64
40025f28:	00008067          	ret
			    ev_mode | BIT(pin));
40025f2c:	0ff97613          	zext.b	a2,s2
			litex_write(gpio_config->ev_mode_addr, gpio_config->reg_size,
40025f30:	00442583          	lw	a1,4(s0)
40025f34:	01042503          	lw	a0,16(s0)
40025f38:	00966633          	or	a2,a2,s1
40025f3c:	f81ff06f          	j	40025ebc <gpio_litex_pin_interrupt_configure+0xd0>
	if (mode == GPIO_INT_DISABLE) {
40025f40:	002007b7          	lui	a5,0x200
		return -ENOTSUP;
40025f44:	f7a00513          	li	a0,-134
	if (mode == GPIO_INT_DISABLE) {
40025f48:	faf61ae3          	bne	a2,a5,40025efc <gpio_litex_pin_interrupt_configure+0x110>
		uint8_t ev_enabled = litex_read(gpio_config->ev_enable_addr,
40025f4c:	00c42483          	lw	s1,12(s0)
40025f50:	00442583          	lw	a1,4(s0)
40025f54:	00048513          	mv	a0,s1
40025f58:	00b12623          	sw	a1,12(sp)
40025f5c:	bf9ff0ef          	jal	ra,40025b54 <litex_read>
			    ev_enabled & ~BIT(pin));
40025f60:	00100613          	li	a2,1
40025f64:	01661633          	sll	a2,a2,s6
40025f68:	fff64613          	not	a2,a2
40025f6c:	00a67633          	and	a2,a2,a0
		litex_write(gpio_config->ev_enable_addr, gpio_config->reg_size,
40025f70:	00c12583          	lw	a1,12(sp)
40025f74:	0ff67613          	zext.b	a2,a2
40025f78:	00048513          	mv	a0,s1
40025f7c:	f41ff06f          	j	40025ebc <gpio_litex_pin_interrupt_configure+0xd0>

40025f80 <gpio_litex_port_init_0>:
		IF_ENABLED(DT_INST_IRQ_HAS_IDX(n, 0), \
			   (GPIO_LITEX_IRQ_INIT(n);)) \
		return 0; \
	}

DT_INST_FOREACH_STATUS_OKAY(GPIO_LITEX_INIT)
40025f80:	00452783          	lw	a5,4(a0)
40025f84:	0187a703          	lw	a4,24(a5) # 200018 <__rom_region_size+0x1cf63c>
40025f88:	02000793          	li	a5,32
40025f8c:	00e7c663          	blt	a5,a4,40025f98 <gpio_litex_port_init_0+0x18>
40025f90:	00000513          	li	a0,0
40025f94:	00008067          	ret
40025f98:	fea00513          	li	a0,-22
40025f9c:	00008067          	ret

40025fa0 <gpio_litex_port_init_1>:
40025fa0:	00452783          	lw	a5,4(a0)
40025fa4:	0187a703          	lw	a4,24(a5)
40025fa8:	02000793          	li	a5,32
40025fac:	02e7c263          	blt	a5,a4,40025fd0 <gpio_litex_port_init_1+0x30>
40025fb0:	ff010113          	addi	sp,sp,-16
40025fb4:	00400513          	li	a0,4
40025fb8:	00112623          	sw	ra,12(sp)
40025fbc:	9f9ff0ef          	jal	ra,400259b4 <arch_irq_enable>
40025fc0:	00c12083          	lw	ra,12(sp)
40025fc4:	00000513          	li	a0,0
40025fc8:	01010113          	addi	sp,sp,16
40025fcc:	00008067          	ret
40025fd0:	fea00513          	li	a0,-22
40025fd4:	00008067          	ret

40025fd8 <gpio_litex_irq_handler>:
{
40025fd8:	fd010113          	addi	sp,sp,-48
40025fdc:	02112623          	sw	ra,44(sp)
40025fe0:	02812423          	sw	s0,40(sp)
40025fe4:	02912223          	sw	s1,36(sp)
40025fe8:	03212023          	sw	s2,32(sp)
40025fec:	01312e23          	sw	s3,28(sp)
40025ff0:	01412c23          	sw	s4,24(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
40025ff4:	00452903          	lw	s2,4(a0)
	struct gpio_litex_data *data = dev->data;
40025ff8:	01052a03          	lw	s4,16(a0)
{
40025ffc:	00050493          	mv	s1,a0
		litex_read(gpio_config->ev_pending_addr, gpio_config->reg_size);
40026000:	00892983          	lw	s3,8(s2)
40026004:	00492583          	lw	a1,4(s2)
40026008:	00098513          	mv	a0,s3
4002600c:	00b12623          	sw	a1,12(sp)
40026010:	b45ff0ef          	jal	ra,40025b54 <litex_read>
		litex_read(gpio_config->ev_enable_addr, gpio_config->reg_size);
40026014:	00c12583          	lw	a1,12(sp)
		litex_read(gpio_config->ev_pending_addr, gpio_config->reg_size);
40026018:	00050413          	mv	s0,a0
		litex_read(gpio_config->ev_enable_addr, gpio_config->reg_size);
4002601c:	00c92503          	lw	a0,12(s2)
40026020:	b35ff0ef          	jal	ra,40025b54 <litex_read>
	litex_write(gpio_config->ev_pending_addr, gpio_config->reg_size,
40026024:	00c12583          	lw	a1,12(sp)
		litex_read(gpio_config->ev_enable_addr, gpio_config->reg_size);
40026028:	00050913          	mv	s2,a0
	litex_write(gpio_config->ev_pending_addr, gpio_config->reg_size,
4002602c:	0ff47613          	zext.b	a2,s0
40026030:	00098513          	mv	a0,s3
40026034:	ae5ff0ef          	jal	ra,40025b18 <litex_write>
	gpio_fire_callbacks(&data->cb, dev, int_status & ev_enabled);
40026038:	008a2583          	lw	a1,8(s4)
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
4002603c:	00058a63          	beqz	a1,40026050 <gpio_litex_irq_handler+0x78>
40026040:	01247433          	and	s0,s0,s2
	return node->next;
40026044:	0005a903          	lw	s2,0(a1)
40026048:	0ff47413          	zext.b	s0,s0
4002604c:	02059263          	bnez	a1,40026070 <gpio_litex_irq_handler+0x98>
}
40026050:	02c12083          	lw	ra,44(sp)
40026054:	02812403          	lw	s0,40(sp)
40026058:	02412483          	lw	s1,36(sp)
4002605c:	02012903          	lw	s2,32(sp)
40026060:	01c12983          	lw	s3,28(sp)
40026064:	01812a03          	lw	s4,24(sp)
40026068:	03010113          	addi	sp,sp,48
4002606c:	00008067          	ret
		if (cb->pin_mask & pins) {
40026070:	0085a603          	lw	a2,8(a1)
40026074:	00c47633          	and	a2,s0,a2
40026078:	00060863          	beqz	a2,40026088 <gpio_litex_irq_handler+0xb0>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
4002607c:	0045a783          	lw	a5,4(a1)
40026080:	00048513          	mv	a0,s1
40026084:	000780e7          	jalr	a5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
40026088:	00000793          	li	a5,0
4002608c:	00090463          	beqz	s2,40026094 <gpio_litex_irq_handler+0xbc>
40026090:	00092783          	lw	a5,0(s2)
40026094:	00090593          	mv	a1,s2
40026098:	00078913          	mv	s2,a5
4002609c:	fb1ff06f          	j	4002604c <gpio_litex_irq_handler+0x74>

400260a0 <gpio_litex_port_toggle_bits>:
{
400260a0:	ff010113          	addi	sp,sp,-16
400260a4:	00112623          	sw	ra,12(sp)
400260a8:	00912223          	sw	s1,4(sp)
400260ac:	00812423          	sw	s0,8(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
400260b0:	00452403          	lw	s0,4(a0)
{
400260b4:	00058493          	mv	s1,a1
	port_val = get_port(gpio_config);
400260b8:	00040513          	mv	a0,s0
400260bc:	b45ff0ef          	jal	ra,40025c00 <get_port>
	litex_write(config->reg_addr, config->reg_size, value);
400260c0:	00954633          	xor	a2,a0,s1
400260c4:	00442583          	lw	a1,4(s0)
400260c8:	00042503          	lw	a0,0(s0)
400260cc:	a4dff0ef          	jal	ra,40025b18 <litex_write>
}
400260d0:	00c12083          	lw	ra,12(sp)
400260d4:	00812403          	lw	s0,8(sp)
400260d8:	00412483          	lw	s1,4(sp)
400260dc:	00000513          	li	a0,0
400260e0:	01010113          	addi	sp,sp,16
400260e4:	00008067          	ret

400260e8 <gpio_litex_port_clear_bits_raw>:
{
400260e8:	ff010113          	addi	sp,sp,-16
400260ec:	00112623          	sw	ra,12(sp)
400260f0:	00812423          	sw	s0,8(sp)
400260f4:	00912223          	sw	s1,4(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
400260f8:	00452483          	lw	s1,4(a0)
{
400260fc:	00058413          	mv	s0,a1
	port_val &= ~pins;
40026100:	fff44413          	not	s0,s0
	port_val = get_port(gpio_config);
40026104:	00048513          	mv	a0,s1
40026108:	af9ff0ef          	jal	ra,40025c00 <get_port>
	litex_write(config->reg_addr, config->reg_size, value);
4002610c:	00a47633          	and	a2,s0,a0
40026110:	0044a583          	lw	a1,4(s1)
40026114:	0004a503          	lw	a0,0(s1)
40026118:	a01ff0ef          	jal	ra,40025b18 <litex_write>
}
4002611c:	00c12083          	lw	ra,12(sp)
40026120:	00812403          	lw	s0,8(sp)
40026124:	00412483          	lw	s1,4(sp)
40026128:	00000513          	li	a0,0
4002612c:	01010113          	addi	sp,sp,16
40026130:	00008067          	ret

40026134 <gpio_litex_port_set_bits_raw>:
{
40026134:	ff010113          	addi	sp,sp,-16
40026138:	00112623          	sw	ra,12(sp)
4002613c:	00912223          	sw	s1,4(sp)
40026140:	00812423          	sw	s0,8(sp)
	const struct gpio_litex_cfg *gpio_config = DEV_GPIO_CFG(dev);
40026144:	00452403          	lw	s0,4(a0)
{
40026148:	00058493          	mv	s1,a1
	port_val = get_port(gpio_config);
4002614c:	00040513          	mv	a0,s0
40026150:	ab1ff0ef          	jal	ra,40025c00 <get_port>
	litex_write(config->reg_addr, config->reg_size, value);
40026154:	00956633          	or	a2,a0,s1
40026158:	00442583          	lw	a1,4(s0)
4002615c:	00042503          	lw	a0,0(s0)
40026160:	9b9ff0ef          	jal	ra,40025b18 <litex_write>
}
40026164:	00c12083          	lw	ra,12(sp)
40026168:	00812403          	lw	s0,8(sp)
4002616c:	00412483          	lw	s1,4(sp)
40026170:	00000513          	li	a0,0
40026174:	01010113          	addi	sp,sp,16
40026178:	00008067          	ret

4002617c <eth_initialize>:
struct eth_liteeth_config {
	void (*config_func)(void);
};

static int eth_initialize(const struct device *dev)
{
4002617c:	ff010113          	addi	sp,sp,-16
40026180:	00112623          	sw	ra,12(sp)
	const struct eth_liteeth_config *config = dev->config;

	config->config_func();
40026184:	00452783          	lw	a5,4(a0)
40026188:	0007a783          	lw	a5,0(a5)
4002618c:	000780e7          	jalr	a5

	return 0;
}
40026190:	00c12083          	lw	ra,12(sp)
40026194:	00000513          	li	a0,0
40026198:	01010113          	addi	sp,sp,16
4002619c:	00008067          	ret

400261a0 <eth_caps>:
static enum ethernet_hw_caps eth_caps(const struct device *dev)
{
	ARG_UNUSED(dev);
	return ETHERNET_LINK_10BASE_T | ETHERNET_LINK_100BASE_T |
	       ETHERNET_LINK_1000BASE_T;
}
400261a0:	07000513          	li	a0,112
400261a4:	00008067          	ret

400261a8 <eth_iface_init>:
{
400261a8:	ff010113          	addi	sp,sp,-16
400261ac:	01212023          	sw	s2,0(sp)
400261b0:	00112623          	sw	ra,12(sp)
400261b4:	00812423          	sw	s0,8(sp)
400261b8:	00912223          	sw	s1,4(sp)
	return iface->if_dev->dev;
400261bc:	00052783          	lw	a5,0(a0)
	if (init_done) {
400261c0:	40031937          	lui	s2,0x40031
	struct eth_liteeth_dev_data *context = port->data;
400261c4:	0007a783          	lw	a5,0(a5)
400261c8:	0107a403          	lw	s0,16(a5)
	if (init_done) {
400261cc:	b0694783          	lbu	a5,-1274(s2) # 40030b06 <init_done.0>
400261d0:	06079263          	bnez	a5,40026234 <eth_iface_init+0x8c>
	context->iface = iface;
400261d4:	00a42023          	sw	a0,0(s0)
400261d8:	00050493          	mv	s1,a0
	ethernet_init(iface);
400261dc:	9e0e40ef          	jal	ra,4000a3bc <ethernet_init>
	return net_if_set_link_addr_locked(iface, addr, len, type);
400261e0:	00300693          	li	a3,3
400261e4:	00600613          	li	a2,6
400261e8:	00440593          	addi	a1,s0,4
400261ec:	00048513          	mv	a0,s1
400261f0:	90de60ef          	jal	ra,4000cafc <net_if_set_link_addr_locked>
	if (net_if_set_link_addr(iface, context->mac_addr, sizeof(context->mac_addr),
400261f4:	04054063          	bltz	a0,40026234 <eth_iface_init+0x8c>
	*(volatile uint8_t *)addr = data;
400261f8:	f00027b7          	lui	a5,0xf0002
400261fc:	00100713          	li	a4,1
40026200:	82e78823          	sb	a4,-2000(a5) # f0001830 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0001831>
	context->tx_buf[1] = (uint8_t *)LITEETH_SLOT_TX1_ADDR;
40026204:	800026b7          	lui	a3,0x80002
40026208:	80e78823          	sb	a4,-2032(a5)
4002620c:	80068693          	addi	a3,a3,-2048 # 80001800 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80001801>
	context->tx_buf[0] = (uint8_t *)LITEETH_SLOT_TX0_ADDR;
40026210:	800017b7          	lui	a5,0x80001
40026214:	00f42623          	sw	a5,12(s0)
	context->tx_buf[1] = (uint8_t *)LITEETH_SLOT_TX1_ADDR;
40026218:	00d42823          	sw	a3,16(s0)
	context->rx_buf[1] = (uint8_t *)LITEETH_SLOT_RX1_ADDR;
4002621c:	80078793          	addi	a5,a5,-2048 # 80000800 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000801>
	context->rx_buf[0] = (uint8_t *)LITEETH_SLOT_RX0_ADDR;
40026220:	800006b7          	lui	a3,0x80000
	context->txslot = 0;
40026224:	00041523          	sh	zero,10(s0)
	context->rx_buf[0] = (uint8_t *)LITEETH_SLOT_RX0_ADDR;
40026228:	00d42a23          	sw	a3,20(s0)
	context->rx_buf[1] = (uint8_t *)LITEETH_SLOT_RX1_ADDR;
4002622c:	00f42c23          	sw	a5,24(s0)
	init_done = true;
40026230:	b0e90323          	sb	a4,-1274(s2)
}
40026234:	00c12083          	lw	ra,12(sp)
40026238:	00812403          	lw	s0,8(sp)
4002623c:	00412483          	lw	s1,4(sp)
40026240:	00012903          	lw	s2,0(sp)
40026244:	01010113          	addi	sp,sp,16
40026248:	00008067          	ret

4002624c <eth_irq_config>:
NET_DEVICE_DT_INST_DEFINE(0, eth_initialize, NULL,
		&eth_data, &eth_config, CONFIG_ETH_INIT_PRIORITY, &eth_api,
		ETHERNET_L2, NET_L2_GET_CTX_TYPE(ETHERNET_L2), NET_ETH_MTU);

static void eth_irq_config(void)
{
4002624c:	ff010113          	addi	sp,sp,-16
	IRQ_CONNECT(LITEETH_IRQ, LITEETH_IRQ_PRIORITY, eth_irq_handler,
		    DEVICE_DT_INST_GET(0), 0);
	irq_enable(LITEETH_IRQ);
40026250:	00200513          	li	a0,2
{
40026254:	00112623          	sw	ra,12(sp)
	irq_enable(LITEETH_IRQ);
40026258:	f5cff0ef          	jal	ra,400259b4 <arch_irq_enable>
4002625c:	f00027b7          	lui	a5,0xf0002
40026260:	00100713          	li	a4,1
40026264:	80e78a23          	sb	a4,-2028(a5) # f0001814 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0001815>
	litex_write8(1, LITEETH_RX_EV_ENABLE_ADDR);
}
40026268:	00c12083          	lw	ra,12(sp)
4002626c:	01010113          	addi	sp,sp,16
40026270:	00008067          	ret

40026274 <eth_irq_handler>:
	return *(volatile uint8_t *)addr;
40026274:	f0002737          	lui	a4,0xf0002
40026278:	83074783          	lbu	a5,-2000(a4) # f0001830 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0001831>
	if (litex_read8(LITEETH_TX_EV_PENDING_ADDR) & LITEETH_EV_TX) {
4002627c:	0017f793          	andi	a5,a5,1
40026280:	00078663          	beqz	a5,4002628c <eth_irq_handler+0x18>
	*(volatile uint8_t *)addr = data;
40026284:	00100793          	li	a5,1
40026288:	82f70823          	sb	a5,-2000(a4)
	return *(volatile uint8_t *)addr;
4002628c:	f00027b7          	lui	a5,0xf0002
40026290:	8107c703          	lbu	a4,-2032(a5) # f0001810 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0001811>
	if (litex_read8(LITEETH_RX_EV_PENDING_ADDR) & LITEETH_EV_RX) {
40026294:	00177713          	andi	a4,a4,1
40026298:	0c070463          	beqz	a4,40026360 <eth_irq_handler+0xec>
{
4002629c:	fe010113          	addi	sp,sp,-32
400262a0:	00112e23          	sw	ra,28(sp)
400262a4:	00812c23          	sw	s0,24(sp)
400262a8:	00912a23          	sw	s1,20(sp)
400262ac:	01212823          	sw	s2,16(sp)
400262b0:	01312623          	sw	s3,12(sp)
400262b4:	01052483          	lw	s1,16(a0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
400262b8:	300479f3          	csrrci	s3,mstatus,8
	return *(volatile uint16_t *)addr;
400262bc:	8047d903          	lhu	s2,-2044(a5)
	return *(volatile uint8_t *)addr;
400262c0:	8007c783          	lbu	a5,-2048(a5)
	pkt = net_pkt_rx_alloc_with_buffer(context->iface, len, AF_UNSPEC, 0,
400262c4:	0004a503          	lw	a0,0(s1)
	return *(volatile uint16_t *)addr;
400262c8:	01091913          	slli	s2,s2,0x10
400262cc:	01095913          	srli	s2,s2,0x10
	context->rxslot = litex_read8(LITEETH_RX_SLOT_ADDR);
400262d0:	00f485a3          	sb	a5,11(s1)
	pkt = net_pkt_rx_alloc_with_buffer(context->iface, len, AF_UNSPEC, 0,
400262d4:	00000713          	li	a4,0
400262d8:	00000793          	li	a5,0
400262dc:	00000693          	li	a3,0
400262e0:	00000613          	li	a2,0
400262e4:	00090593          	mv	a1,s2
400262e8:	c58ed0ef          	jal	ra,40013740 <net_pkt_rx_alloc_with_buffer>
400262ec:	00050413          	mv	s0,a0
	if (pkt == NULL) {
400262f0:	04050063          	beqz	a0,40026330 <eth_irq_handler+0xbc>
	if (net_pkt_write(pkt, (void *)context->rx_buf[context->rxslot], len) != 0) {
400262f4:	00b4c783          	lbu	a5,11(s1)
400262f8:	00090613          	mv	a2,s2
400262fc:	00478793          	addi	a5,a5,4
40026300:	00279793          	slli	a5,a5,0x2
40026304:	00f487b3          	add	a5,s1,a5
40026308:	0047a583          	lw	a1,4(a5)
4002630c:	c0ded0ef          	jal	ra,40013f18 <net_pkt_write>
40026310:	00050863          	beqz	a0,40026320 <eth_irq_handler+0xac>
		net_pkt_unref(pkt);
40026314:	00040513          	mv	a0,s0
40026318:	c05ec0ef          	jal	ra,40012f1c <net_pkt_unref>
4002631c:	0140006f          	j	40026330 <eth_irq_handler+0xbc>
	r = net_recv_data(context->iface, pkt);
40026320:	0004a503          	lw	a0,0(s1)
40026324:	00040593          	mv	a1,s0
40026328:	f44e50ef          	jal	ra,4000ba6c <net_recv_data>
	if (r < 0) {
4002632c:	fe0544e3          	bltz	a0,40026314 <eth_irq_handler+0xa0>
			  : "r" (key & MSTATUS_IEN)
40026330:	0089f993          	andi	s3,s3,8
	__asm__ volatile ("csrs mstatus, %0"
40026334:	3009a073          	csrs	mstatus,s3
	*(volatile uint8_t *)addr = data;
40026338:	f00027b7          	lui	a5,0xf0002
4002633c:	00100713          	li	a4,1
40026340:	80e78823          	sb	a4,-2032(a5) # f0001810 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0001811>
}
40026344:	01c12083          	lw	ra,28(sp)
40026348:	01812403          	lw	s0,24(sp)
4002634c:	01412483          	lw	s1,20(sp)
40026350:	01012903          	lw	s2,16(sp)
40026354:	00c12983          	lw	s3,12(sp)
40026358:	02010113          	addi	sp,sp,32
4002635c:	00008067          	ret
40026360:	00008067          	ret

40026364 <eth_tx>:
{
40026364:	fe010113          	addi	sp,sp,-32
40026368:	00050793          	mv	a5,a0
4002636c:	00112e23          	sw	ra,28(sp)
40026370:	00812c23          	sw	s0,24(sp)
40026374:	00912a23          	sw	s1,20(sp)
40026378:	01212823          	sw	s2,16(sp)
4002637c:	01312623          	sw	s3,12(sp)
40026380:	00058513          	mv	a0,a1
	struct eth_liteeth_dev_data *context = dev->data;
40026384:	0107a483          	lw	s1,16(a5)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40026388:	30047473          	csrrci	s0,mstatus,8
	len = net_pkt_get_len(pkt);
4002638c:	0085a783          	lw	a5,8(a1)
	size_t bytes = 0;
40026390:	00000613          	li	a2,0
	while (buf) {
40026394:	06079663          	bnez	a5,40026400 <eth_tx+0x9c>
	net_pkt_read(pkt, context->tx_buf[context->txslot], len);
40026398:	00a4c783          	lbu	a5,10(s1)
	len = net_pkt_get_len(pkt);
4002639c:	01061913          	slli	s2,a2,0x10
400263a0:	01095913          	srli	s2,s2,0x10
	net_pkt_read(pkt, context->tx_buf[context->txslot], len);
400263a4:	00279793          	slli	a5,a5,0x2
400263a8:	00f487b3          	add	a5,s1,a5
400263ac:	00c7a583          	lw	a1,12(a5)
400263b0:	00090613          	mv	a2,s2
	return *(volatile uint8_t *)addr;
400263b4:	f00029b7          	lui	s3,0xf0002
400263b8:	e14ed0ef          	jal	ra,400139cc <net_pkt_read>
	litex_write8(context->txslot, LITEETH_TX_SLOT_ADDR);
400263bc:	00a4c703          	lbu	a4,10(s1)
	*(volatile uint8_t *)addr = data;
400263c0:	f00027b7          	lui	a5,0xf0002
400263c4:	82e78223          	sb	a4,-2012(a5) # f0001824 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0001825>
	*(volatile uint16_t *)addr = data;
400263c8:	83279423          	sh	s2,-2008(a5)
}
400263cc:	06500913          	li	s2,101
	return *(volatile uint8_t *)addr;
400263d0:	81c9c783          	lbu	a5,-2020(s3) # f000181c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf000181d>
	while (litex_read8(LITEETH_TX_READY_ADDR) == 0) {
400263d4:	02078e63          	beqz	a5,40026410 <eth_tx+0xac>
	*(volatile uint8_t *)addr = data;
400263d8:	00100793          	li	a5,1
400263dc:	80f98c23          	sb	a5,-2024(s3)
	context->txslot = (context->txslot + 1) % 2;
400263e0:	00a4c783          	lbu	a5,10(s1)
			  : "r" (key & MSTATUS_IEN)
400263e4:	00847413          	andi	s0,s0,8
400263e8:	00178793          	addi	a5,a5,1
400263ec:	0017f793          	andi	a5,a5,1
400263f0:	00f48523          	sb	a5,10(s1)
	__asm__ volatile ("csrs mstatus, %0"
400263f4:	30042073          	csrs	mstatus,s0
	return 0;
400263f8:	00000513          	li	a0,0
400263fc:	0280006f          	j	40026424 <eth_tx+0xc0>
		bytes += buf->len;
40026400:	0107d703          	lhu	a4,16(a5)
		buf = buf->frags;
40026404:	0047a783          	lw	a5,4(a5)
		bytes += buf->len;
40026408:	00e60633          	add	a2,a2,a4
		buf = buf->frags;
4002640c:	f89ff06f          	j	40026394 <eth_tx+0x30>
		if (attempts++ == MAX_TX_FAILURE) {
40026410:	fff90913          	addi	s2,s2,-1
40026414:	02091663          	bnez	s2,40026440 <eth_tx+0xdc>
			  : "r" (key & MSTATUS_IEN)
40026418:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrs mstatus, %0"
4002641c:	30042073          	csrs	mstatus,s0
	return -1;
40026420:	fff00513          	li	a0,-1
}
40026424:	01c12083          	lw	ra,28(sp)
40026428:	01812403          	lw	s0,24(sp)
4002642c:	01412483          	lw	s1,20(sp)
40026430:	01012903          	lw	s2,16(sp)
40026434:	00c12983          	lw	s3,12(sp)
40026438:	02010113          	addi	sp,sp,32
4002643c:	00008067          	ret
	return z_impl_k_sleep(timeout);
40026440:	00000593          	li	a1,0
40026444:	00100513          	li	a0,1
40026448:	01c040ef          	jal	ra,4002a464 <z_impl_k_sleep>
4002644c:	f85ff06f          	j	400263d0 <eth_tx+0x6c>

40026450 <uart_liteuart_poll_out>:
	return *(volatile uint8_t *)addr;
40026450:	f00057b7          	lui	a5,0xf0005
40026454:	8047c703          	lbu	a4,-2044(a5) # f0004804 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0004805>
 * @param c Character to send
 */
static void uart_liteuart_poll_out(const struct device *dev, unsigned char c)
{
	/* wait for space */
	while (litex_read8(UART_TXFULL_ADDR)) {
40026458:	fe071ee3          	bnez	a4,40026454 <uart_liteuart_poll_out+0x4>
	*(volatile uint8_t *)addr = data;
4002645c:	80b78023          	sb	a1,-2048(a5)
	}

	litex_write8(c, UART_RXTX_ADDR);
}
40026460:	00008067          	ret

40026464 <uart_liteuart_poll_in>:
	return *(volatile uint8_t *)addr;
40026464:	f00057b7          	lui	a5,0xf0005
40026468:	8087c703          	lbu	a4,-2040(a5) # f0004808 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0004809>
		 * to UART_EV_PENDING
		 */
		litex_write8(UART_EV_RX, UART_EV_PENDING_ADDR);
		return 0;
	} else {
		return -1;
4002646c:	fff00513          	li	a0,-1
	if (!litex_read8(UART_RXEMPTY_ADDR)) {
40026470:	00071c63          	bnez	a4,40026488 <uart_liteuart_poll_in+0x24>
40026474:	8007c703          	lbu	a4,-2048(a5)
		return 0;
40026478:	00000513          	li	a0,0
		*c = litex_read8(UART_RXTX_ADDR);
4002647c:	00e58023          	sb	a4,0(a1)
	*(volatile uint8_t *)addr = data;
40026480:	00200713          	li	a4,2
40026484:	80e78823          	sb	a4,-2032(a5)
	}
}
40026488:	00008067          	ret

4002648c <uart_liteuart_init>:
4002648c:	f00057b7          	lui	a5,0xf0005
40026490:	00300713          	li	a4,3
40026494:	80e78823          	sb	a4,-2032(a5) # f0004810 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0004811>
			0);
	irq_enable(UART_IRQ);
#endif

	return 0;
}
40026498:	00000513          	li	a0,0
4002649c:	00008067          	ret

400264a0 <sys_clock_set_timeout>:

/* Weak-linked noop defaults for optional driver interfaces*/

void __weak sys_clock_set_timeout(int32_t ticks, bool idle)
{
}
400264a0:	00008067          	ret

400264a4 <sys_clock_driver_init>:
{
	return 0;
}

static int sys_clock_driver_init(void)
{
400264a4:	ff010113          	addi	sp,sp,-16
	IRQ_CONNECT(TIMER_IRQ, DT_INST_IRQ(0, priority),
			litex_timer_irq_handler, NULL, 0);
	irq_enable(TIMER_IRQ);
400264a8:	00100513          	li	a0,1
{
400264ac:	00112623          	sw	ra,12(sp)
	irq_enable(TIMER_IRQ);
400264b0:	d04ff0ef          	jal	ra,400259b4 <arch_irq_enable>
400264b4:	f00047b7          	lui	a5,0xf0004
	*(volatile uint32_t *)addr = data;
400264b8:	000f4737          	lui	a4,0xf4
	*(volatile uint8_t *)addr = data;
400264bc:	00078423          	sb	zero,8(a5) # f0004008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0004009>
	*(volatile uint32_t *)addr = data;
400264c0:	24070713          	addi	a4,a4,576 # f4240 <__rom_region_size+0xc3864>
400264c4:	00e7a223          	sw	a4,4(a5)
400264c8:	00e7a023          	sw	a4,0(a5)
	*(volatile uint8_t *)addr = data;
400264cc:	00100693          	li	a3,1
400264d0:	00d78423          	sb	a3,8(a5)
	return *(volatile uint8_t *)addr;
400264d4:	0187c703          	lbu	a4,24(a5)
	litex_write8(TIMER_ENABLE, TIMER_EN_ADDR);
	litex_write8(litex_read8(TIMER_EV_PENDING_ADDR), TIMER_EV_PENDING_ADDR);
	litex_write8(TIMER_EV, TIMER_EV_ENABLE_ADDR);

	return 0;
}
400264d8:	00000513          	li	a0,0
400264dc:	0ff77713          	zext.b	a4,a4
	*(volatile uint8_t *)addr = data;
400264e0:	00e78c23          	sb	a4,24(a5)
400264e4:	00d78e23          	sb	a3,28(a5)
400264e8:	00c12083          	lw	ra,12(sp)
400264ec:	01010113          	addi	sp,sp,16
400264f0:	00008067          	ret

400264f4 <litex_timer_irq_handler>:
{
400264f4:	ff010113          	addi	sp,sp,-16
400264f8:	00112623          	sw	ra,12(sp)
400264fc:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40026500:	30047473          	csrrci	s0,mstatus,8
40026504:	f00047b7          	lui	a5,0xf0004
40026508:	00100713          	li	a4,1
4002650c:	00e78c23          	sb	a4,24(a5) # f0004018 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0004019>
	sys_clock_announce(1);
40026510:	00100513          	li	a0,1
40026514:	500040ef          	jal	ra,4002aa14 <sys_clock_announce>
			  : "r" (key & MSTATUS_IEN)
40026518:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrs mstatus, %0"
4002651c:	30042073          	csrs	mstatus,s0
}
40026520:	00c12083          	lw	ra,12(sp)
40026524:	00812403          	lw	s0,8(sp)
40026528:	01010113          	addi	sp,sp,16
4002652c:	00008067          	ret

40026530 <sys_clock_cycle_get_32>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
40026530:	300477f3          	csrrci	a5,mstatus,8
40026534:	f0004737          	lui	a4,0xf0004
40026538:	00100693          	li	a3,1
4002653c:	02d70023          	sb	a3,32(a4) # f0004020 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0004021>
	return *(volatile uint32_t *)addr;
40026540:	02472683          	lw	a3,36(a4)
	__asm__ volatile ("csrs mstatus, %0"
40026544:	0087f793          	andi	a5,a5,8
40026548:	02872503          	lw	a0,40(a4)
4002654c:	3007a073          	csrs	mstatus,a5
}
40026550:	00008067          	ret

40026554 <sys_clock_elapsed>:
}
40026554:	00000513          	li	a0,0
40026558:	00008067          	ret

4002655c <_mbedtls_init>:
#if defined(CONFIG_MBEDTLS_DEBUG_LEVEL)
	mbedtls_debug_set_threshold(CONFIG_MBEDTLS_DEBUG_LEVEL);
#endif

	return 0;
}
4002655c:	00000513          	li	a0,0
40026560:	00008067          	ret

40026564 <mbedtls_md5_init>:

#if !defined(MBEDTLS_MD5_ALT)

void mbedtls_md5_init( mbedtls_md5_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_md5_context ) );
40026564:	05800613          	li	a2,88
40026568:	00000593          	li	a1,0
4002656c:	b05e206f          	j	40009070 <memset>

40026570 <mbedtls_internal_md5_process>:
}

#if !defined(MBEDTLS_MD5_PROCESS_ALT)
int mbedtls_internal_md5_process( mbedtls_md5_context *ctx,
                                  const unsigned char data[64] )
{
40026570:	f7010113          	addi	sp,sp,-144
40026574:	08112623          	sw	ra,140(sp)
40026578:	08912223          	sw	s1,132(sp)
4002657c:	09212023          	sw	s2,128(sp)
40026580:	07312e23          	sw	s3,124(sp)
40026584:	07412c23          	sw	s4,120(sp)
40026588:	07512a23          	sw	s5,116(sp)
4002658c:	07612823          	sw	s6,112(sp)
40026590:	07712623          	sw	s7,108(sp)
40026594:	07812423          	sw	s8,104(sp)
40026598:	07912223          	sw	s9,100(sp)
4002659c:	07a12023          	sw	s10,96(sp)
400265a0:	05b12e23          	sw	s11,92(sp)
400265a4:	08812423          	sw	s0,136(sp)
    struct
    {
        uint32_t X[16], A, B, C, D;
    } local;

    local.X[ 0] = MBEDTLS_GET_UINT32_LE( data,  0 );
400265a8:	0015c703          	lbu	a4,1(a1)
400265ac:	0005c783          	lbu	a5,0(a1)
400265b0:	0035c403          	lbu	s0,3(a1)
400265b4:	00871713          	slli	a4,a4,0x8
400265b8:	00f76733          	or	a4,a4,a5
400265bc:	0025c783          	lbu	a5,2(a1)
400265c0:	01841413          	slli	s0,s0,0x18
    local.X[ 1] = MBEDTLS_GET_UINT32_LE( data,  4 );
400265c4:	0075ce03          	lbu	t3,7(a1)
    local.X[ 0] = MBEDTLS_GET_UINT32_LE( data,  0 );
400265c8:	01079793          	slli	a5,a5,0x10
400265cc:	00e7e7b3          	or	a5,a5,a4
    local.X[ 1] = MBEDTLS_GET_UINT32_LE( data,  4 );
400265d0:	0055c703          	lbu	a4,5(a1)
    local.X[ 0] = MBEDTLS_GET_UINT32_LE( data,  0 );
400265d4:	00f46433          	or	s0,s0,a5
    local.X[ 1] = MBEDTLS_GET_UINT32_LE( data,  4 );
400265d8:	0045c783          	lbu	a5,4(a1)
400265dc:	00871713          	slli	a4,a4,0x8
400265e0:	018e1e13          	slli	t3,t3,0x18
400265e4:	00f76733          	or	a4,a4,a5
400265e8:	0065c783          	lbu	a5,6(a1)
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
    local.X[ 3] = MBEDTLS_GET_UINT32_LE( data, 12 );
400265ec:	00d5c683          	lbu	a3,13(a1)
400265f0:	00f5cf03          	lbu	t5,15(a1)
    local.X[ 1] = MBEDTLS_GET_UINT32_LE( data,  4 );
400265f4:	01079793          	slli	a5,a5,0x10
400265f8:	00e7e7b3          	or	a5,a5,a4
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
400265fc:	0095c703          	lbu	a4,9(a1)
    local.X[ 1] = MBEDTLS_GET_UINT32_LE( data,  4 );
40026600:	00fe6e33          	or	t3,t3,a5
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
40026604:	0085c783          	lbu	a5,8(a1)
40026608:	00871713          	slli	a4,a4,0x8
    local.X[ 3] = MBEDTLS_GET_UINT32_LE( data, 12 );
4002660c:	00869693          	slli	a3,a3,0x8
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
40026610:	00f76733          	or	a4,a4,a5
40026614:	00a5c783          	lbu	a5,10(a1)
    local.X[ 3] = MBEDTLS_GET_UINT32_LE( data, 12 );
40026618:	018f1f13          	slli	t5,t5,0x18
    local.X[ 0] = MBEDTLS_GET_UINT32_LE( data,  0 );
4002661c:	00812023          	sw	s0,0(sp)
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
40026620:	01079793          	slli	a5,a5,0x10
40026624:	00e7e7b3          	or	a5,a5,a4
40026628:	00b5c703          	lbu	a4,11(a1)
    local.X[ 1] = MBEDTLS_GET_UINT32_LE( data,  4 );
4002662c:	01c12223          	sw	t3,4(sp)
    local.C = ctx->state[2];
    local.D = ctx->state[3];

#define F(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))

    P( local.A, local.B, local.C, local.D,  0,  7, 0xD76AA478 );
40026630:	d76aa9b7          	lui	s3,0xd76aa
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
40026634:	01871713          	slli	a4,a4,0x18
40026638:	00f76733          	or	a4,a4,a5
    local.X[ 3] = MBEDTLS_GET_UINT32_LE( data, 12 );
4002663c:	00c5c783          	lbu	a5,12(a1)
    local.X[ 2] = MBEDTLS_GET_UINT32_LE( data,  8 );
40026640:	00e12423          	sw	a4,8(sp)
    P( local.A, local.B, local.C, local.D,  0,  7, 0xD76AA478 );
40026644:	47898993          	addi	s3,s3,1144 # d76aa478 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd76aa479>
    local.X[ 3] = MBEDTLS_GET_UINT32_LE( data, 12 );
40026648:	00f6e6b3          	or	a3,a3,a5
4002664c:	00e5c783          	lbu	a5,14(a1)
    P( local.D, local.A, local.B, local.C,  1, 12, 0xE8C7B756 );
    P( local.C, local.D, local.A, local.B,  2, 17, 0x242070DB );
    P( local.B, local.C, local.D, local.A,  3, 22, 0xC1BDCEEE );
    P( local.A, local.B, local.C, local.D,  4,  7, 0xF57C0FAF );
40026650:	f57c1d37          	lui	s10,0xf57c1
40026654:	fafd0d13          	addi	s10,s10,-81 # f57c0faf <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf57c0fb0>
    local.X[ 3] = MBEDTLS_GET_UINT32_LE( data, 12 );
40026658:	01079793          	slli	a5,a5,0x10
4002665c:	00d7e7b3          	or	a5,a5,a3
40026660:	00ff6f33          	or	t5,t5,a5
40026664:	01e12623          	sw	t5,12(sp)
    local.X[ 4] = MBEDTLS_GET_UINT32_LE( data, 16 );
40026668:	0115c683          	lbu	a3,17(a1)
4002666c:	0105c783          	lbu	a5,16(a1)
40026670:	0135c603          	lbu	a2,19(a1)
40026674:	00869693          	slli	a3,a3,0x8
40026678:	00f6e6b3          	or	a3,a3,a5
4002667c:	0125c783          	lbu	a5,18(a1)
40026680:	01861613          	slli	a2,a2,0x18
    local.X[ 5] = MBEDTLS_GET_UINT32_LE( data, 20 );
40026684:	0175c283          	lbu	t0,23(a1)
    local.X[ 4] = MBEDTLS_GET_UINT32_LE( data, 16 );
40026688:	01079793          	slli	a5,a5,0x10
4002668c:	00d7e7b3          	or	a5,a5,a3
    local.X[ 5] = MBEDTLS_GET_UINT32_LE( data, 20 );
40026690:	0155c683          	lbu	a3,21(a1)
    local.X[ 4] = MBEDTLS_GET_UINT32_LE( data, 16 );
40026694:	00f66633          	or	a2,a2,a5
    local.X[ 5] = MBEDTLS_GET_UINT32_LE( data, 20 );
40026698:	0145c783          	lbu	a5,20(a1)
4002669c:	00869693          	slli	a3,a3,0x8
400266a0:	01829293          	slli	t0,t0,0x18
400266a4:	00f6e6b3          	or	a3,a3,a5
400266a8:	0165c783          	lbu	a5,22(a1)
    local.X[ 6] = MBEDTLS_GET_UINT32_LE( data, 24 );
400266ac:	01b5c883          	lbu	a7,27(a1)
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
400266b0:	01f5c083          	lbu	ra,31(a1)
    local.X[ 5] = MBEDTLS_GET_UINT32_LE( data, 20 );
400266b4:	01079793          	slli	a5,a5,0x10
400266b8:	00d7e7b3          	or	a5,a5,a3
    local.X[ 6] = MBEDTLS_GET_UINT32_LE( data, 24 );
400266bc:	0195c683          	lbu	a3,25(a1)
    local.X[ 5] = MBEDTLS_GET_UINT32_LE( data, 20 );
400266c0:	00f2e2b3          	or	t0,t0,a5
    local.X[ 6] = MBEDTLS_GET_UINT32_LE( data, 24 );
400266c4:	0185c783          	lbu	a5,24(a1)
400266c8:	00869693          	slli	a3,a3,0x8
400266cc:	01889893          	slli	a7,a7,0x18
400266d0:	00f6e6b3          	or	a3,a3,a5
400266d4:	01a5c783          	lbu	a5,26(a1)
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
400266d8:	01809093          	slli	ra,ra,0x18
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
400266dc:	0235c303          	lbu	t1,35(a1)
    local.X[ 6] = MBEDTLS_GET_UINT32_LE( data, 24 );
400266e0:	01079793          	slli	a5,a5,0x10
400266e4:	00d7e7b3          	or	a5,a5,a3
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
400266e8:	01d5c683          	lbu	a3,29(a1)
    local.X[ 6] = MBEDTLS_GET_UINT32_LE( data, 24 );
400266ec:	00f8e8b3          	or	a7,a7,a5
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
400266f0:	01c5c783          	lbu	a5,28(a1)
400266f4:	00869693          	slli	a3,a3,0x8
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
400266f8:	01831313          	slli	t1,t1,0x18
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
400266fc:	00f6e6b3          	or	a3,a3,a5
40026700:	01e5c783          	lbu	a5,30(a1)
    local.X[10] = MBEDTLS_GET_UINT32_LE( data, 40 );
40026704:	0295c803          	lbu	a6,41(a1)
    local.X[ 4] = MBEDTLS_GET_UINT32_LE( data, 16 );
40026708:	00c12823          	sw	a2,16(sp)
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
4002670c:	01079793          	slli	a5,a5,0x10
40026710:	00d7e7b3          	or	a5,a5,a3
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
40026714:	0215c683          	lbu	a3,33(a1)
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
40026718:	00f0e0b3          	or	ra,ra,a5
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
4002671c:	0205c783          	lbu	a5,32(a1)
40026720:	00869693          	slli	a3,a3,0x8
    local.X[10] = MBEDTLS_GET_UINT32_LE( data, 40 );
40026724:	00881813          	slli	a6,a6,0x8
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
40026728:	00f6e6b3          	or	a3,a3,a5
4002672c:	0225c783          	lbu	a5,34(a1)
    local.X[ 5] = MBEDTLS_GET_UINT32_LE( data, 20 );
40026730:	00512a23          	sw	t0,20(sp)
    local.X[ 6] = MBEDTLS_GET_UINT32_LE( data, 24 );
40026734:	01112c23          	sw	a7,24(sp)
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
40026738:	01079793          	slli	a5,a5,0x10
4002673c:	00d7e7b3          	or	a5,a5,a3
40026740:	00f36333          	or	t1,t1,a5
    local.X[ 9] = MBEDTLS_GET_UINT32_LE( data, 36 );
40026744:	0255c783          	lbu	a5,37(a1)
40026748:	0245c683          	lbu	a3,36(a1)
    local.X[ 7] = MBEDTLS_GET_UINT32_LE( data, 28 );
4002674c:	00112e23          	sw	ra,28(sp)
    local.X[ 9] = MBEDTLS_GET_UINT32_LE( data, 36 );
40026750:	00879793          	slli	a5,a5,0x8
40026754:	00d7e7b3          	or	a5,a5,a3
40026758:	0265c683          	lbu	a3,38(a1)
    local.X[ 8] = MBEDTLS_GET_UINT32_LE( data, 32 );
4002675c:	02612023          	sw	t1,32(sp)
    P( local.A, local.B, local.C, local.D,  4,  7, 0xF57C0FAF );
40026760:	01a60d33          	add	s10,a2,s10
    local.X[ 9] = MBEDTLS_GET_UINT32_LE( data, 36 );
40026764:	01069693          	slli	a3,a3,0x10
40026768:	00f6e6b3          	or	a3,a3,a5
4002676c:	0275c783          	lbu	a5,39(a1)
    P( local.C, local.D, local.A, local.B,  3, 14, 0xF4D50D87 );
    P( local.B, local.C, local.D, local.A,  8, 20, 0x455A14ED );
    P( local.A, local.B, local.C, local.D, 13,  5, 0xA9E3E905 );
    P( local.D, local.A, local.B, local.C,  2,  9, 0xFCEFA3F8 );
    P( local.C, local.D, local.A, local.B,  7, 14, 0x676F02D9 );
    P( local.B, local.C, local.D, local.A, 12, 20, 0x8D2A4C8A );
40026770:	8d2a5db7          	lui	s11,0x8d2a5
40026774:	c8ad8d93          	addi	s11,s11,-886 # 8d2a4c8a <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8d2a4c8b>
    local.X[ 9] = MBEDTLS_GET_UINT32_LE( data, 36 );
40026778:	01879793          	slli	a5,a5,0x18
4002677c:	00d7e7b3          	or	a5,a5,a3
    local.X[10] = MBEDTLS_GET_UINT32_LE( data, 40 );
40026780:	0285c683          	lbu	a3,40(a1)
    local.X[ 9] = MBEDTLS_GET_UINT32_LE( data, 36 );
40026784:	02f12223          	sw	a5,36(sp)
    local.X[10] = MBEDTLS_GET_UINT32_LE( data, 40 );
40026788:	00d86833          	or	a6,a6,a3
4002678c:	02a5c683          	lbu	a3,42(a1)
40026790:	02b5ce83          	lbu	t4,43(a1)
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
40026794:	0315cf83          	lbu	t6,49(a1)
    local.X[10] = MBEDTLS_GET_UINT32_LE( data, 40 );
40026798:	01069693          	slli	a3,a3,0x10
4002679c:	0106e6b3          	or	a3,a3,a6
400267a0:	018e9e93          	slli	t4,t4,0x18
400267a4:	00deeeb3          	or	t4,t4,a3
    local.X[11] = MBEDTLS_GET_UINT32_LE( data, 44 );
400267a8:	02d5c683          	lbu	a3,45(a1)
400267ac:	02c5c803          	lbu	a6,44(a1)
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
400267b0:	008f9f93          	slli	t6,t6,0x8
    local.X[11] = MBEDTLS_GET_UINT32_LE( data, 44 );
400267b4:	00869693          	slli	a3,a3,0x8
400267b8:	0106e6b3          	or	a3,a3,a6
400267bc:	02e5c803          	lbu	a6,46(a1)
    local.X[13] = MBEDTLS_GET_UINT32_LE( data, 52 );
400267c0:	0345c383          	lbu	t2,52(a1)
    local.X[14] = MBEDTLS_GET_UINT32_LE( data, 56 );
400267c4:	0385c483          	lbu	s1,56(a1)
    local.X[11] = MBEDTLS_GET_UINT32_LE( data, 44 );
400267c8:	01081813          	slli	a6,a6,0x10
400267cc:	00d86833          	or	a6,a6,a3
400267d0:	02f5c683          	lbu	a3,47(a1)
    local.X[15] = MBEDTLS_GET_UINT32_LE( data, 60 );
400267d4:	03d5c903          	lbu	s2,61(a1)
    local.C = ctx->state[2];
400267d8:	01052b03          	lw	s6,16(a0)
    local.X[11] = MBEDTLS_GET_UINT32_LE( data, 44 );
400267dc:	01869693          	slli	a3,a3,0x18
400267e0:	0106e6b3          	or	a3,a3,a6
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
400267e4:	0305c803          	lbu	a6,48(a1)
    local.X[15] = MBEDTLS_GET_UINT32_LE( data, 60 );
400267e8:	00891913          	slli	s2,s2,0x8
    local.D = ctx->state[3];
400267ec:	01452b83          	lw	s7,20(a0)
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
400267f0:	010fefb3          	or	t6,t6,a6
400267f4:	0325c803          	lbu	a6,50(a1)
    local.A = ctx->state[0];
400267f8:	00852c03          	lw	s8,8(a0)
    local.X[10] = MBEDTLS_GET_UINT32_LE( data, 40 );
400267fc:	03d12423          	sw	t4,40(sp)
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
40026800:	01081813          	slli	a6,a6,0x10
40026804:	01f86833          	or	a6,a6,t6
40026808:	0335cf83          	lbu	t6,51(a1)
    P( local.A, local.B, local.C, local.D,  0,  7, 0xD76AA478 );
4002680c:	013c09b3          	add	s3,s8,s3
40026810:	008989b3          	add	s3,s3,s0
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
40026814:	018f9f93          	slli	t6,t6,0x18
40026818:	010fefb3          	or	t6,t6,a6
    local.X[13] = MBEDTLS_GET_UINT32_LE( data, 52 );
4002681c:	0355c803          	lbu	a6,53(a1)
    P( local.B, local.C, local.D, local.A, 12, 20, 0x8D2A4C8A );
40026820:	01bf8db3          	add	s11,t6,s11
    local.X[12] = MBEDTLS_GET_UINT32_LE( data, 48 );
40026824:	03f12823          	sw	t6,48(sp)
    local.X[13] = MBEDTLS_GET_UINT32_LE( data, 52 );
40026828:	00881813          	slli	a6,a6,0x8
4002682c:	00786833          	or	a6,a6,t2
40026830:	0365c383          	lbu	t2,54(a1)
    local.X[11] = MBEDTLS_GET_UINT32_LE( data, 44 );
40026834:	02d12623          	sw	a3,44(sp)
    local.X[13] = MBEDTLS_GET_UINT32_LE( data, 52 );
40026838:	01039393          	slli	t2,t2,0x10
4002683c:	0103e3b3          	or	t2,t2,a6
40026840:	0375c803          	lbu	a6,55(a1)
40026844:	01881813          	slli	a6,a6,0x18
40026848:	00786833          	or	a6,a6,t2
    local.X[14] = MBEDTLS_GET_UINT32_LE( data, 56 );
4002684c:	0395c383          	lbu	t2,57(a1)
    local.X[13] = MBEDTLS_GET_UINT32_LE( data, 52 );
40026850:	03012a23          	sw	a6,52(sp)
    local.X[14] = MBEDTLS_GET_UINT32_LE( data, 56 );
40026854:	00839393          	slli	t2,t2,0x8
40026858:	0093e3b3          	or	t2,t2,s1
4002685c:	03a5c483          	lbu	s1,58(a1)
40026860:	01049493          	slli	s1,s1,0x10
40026864:	0074e4b3          	or	s1,s1,t2
40026868:	03b5c383          	lbu	t2,59(a1)
4002686c:	01839393          	slli	t2,t2,0x18
40026870:	0093e3b3          	or	t2,t2,s1
    local.X[15] = MBEDTLS_GET_UINT32_LE( data, 60 );
40026874:	03c5c483          	lbu	s1,60(a1)
    local.X[14] = MBEDTLS_GET_UINT32_LE( data, 56 );
40026878:	02712c23          	sw	t2,56(sp)
    local.X[15] = MBEDTLS_GET_UINT32_LE( data, 60 );
4002687c:	00996933          	or	s2,s2,s1
40026880:	03e5c483          	lbu	s1,62(a1)
40026884:	03f5c583          	lbu	a1,63(a1)
40026888:	01049493          	slli	s1,s1,0x10
4002688c:	0124e4b3          	or	s1,s1,s2
    local.B = ctx->state[1];
40026890:	00c52903          	lw	s2,12(a0)
    local.X[15] = MBEDTLS_GET_UINT32_LE( data, 60 );
40026894:	01859593          	slli	a1,a1,0x18
40026898:	0095e5b3          	or	a1,a1,s1
    P( local.A, local.B, local.C, local.D,  0,  7, 0xD76AA478 );
4002689c:	017b44b3          	xor	s1,s6,s7
400268a0:	0124f4b3          	and	s1,s1,s2
400268a4:	0174c4b3          	xor	s1,s1,s7
400268a8:	013484b3          	add	s1,s1,s3
400268ac:	00749a13          	slli	s4,s1,0x7
400268b0:	0194d493          	srli	s1,s1,0x19
400268b4:	009a6a33          	or	s4,s4,s1
    P( local.D, local.A, local.B, local.C,  1, 12, 0xE8C7B756 );
400268b8:	e8c7b9b7          	lui	s3,0xe8c7b
    P( local.A, local.B, local.C, local.D,  0,  7, 0xD76AA478 );
400268bc:	012a0a33          	add	s4,s4,s2
    P( local.D, local.A, local.B, local.C,  1, 12, 0xE8C7B756 );
400268c0:	016944b3          	xor	s1,s2,s6
400268c4:	75698993          	addi	s3,s3,1878 # e8c7b756 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe8c7b757>
400268c8:	0144f4b3          	and	s1,s1,s4
400268cc:	013b89b3          	add	s3,s7,s3
400268d0:	01c989b3          	add	s3,s3,t3
400268d4:	0164c4b3          	xor	s1,s1,s6
400268d8:	013484b3          	add	s1,s1,s3
400268dc:	00c49c93          	slli	s9,s1,0xc
400268e0:	0144d493          	srli	s1,s1,0x14
400268e4:	009cecb3          	or	s9,s9,s1
    P( local.C, local.D, local.A, local.B,  2, 17, 0x242070DB );
400268e8:	242079b7          	lui	s3,0x24207
    P( local.D, local.A, local.B, local.C,  1, 12, 0xE8C7B756 );
400268ec:	014c8cb3          	add	s9,s9,s4
    P( local.C, local.D, local.A, local.B,  2, 17, 0x242070DB );
400268f0:	014944b3          	xor	s1,s2,s4
400268f4:	0db98993          	addi	s3,s3,219 # 242070db <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1e2a8fdb>
400268f8:	0194f4b3          	and	s1,s1,s9
400268fc:	013b09b3          	add	s3,s6,s3
40026900:	00e989b3          	add	s3,s3,a4
40026904:	0124c4b3          	xor	s1,s1,s2
40026908:	013484b3          	add	s1,s1,s3
4002690c:	00f4da93          	srli	s5,s1,0xf
40026910:	01149493          	slli	s1,s1,0x11
40026914:	009aeab3          	or	s5,s5,s1
    P( local.B, local.C, local.D, local.A,  3, 22, 0xC1BDCEEE );
40026918:	c1bdd9b7          	lui	s3,0xc1bdd
    P( local.C, local.D, local.A, local.B,  2, 17, 0x242070DB );
4002691c:	019a8ab3          	add	s5,s5,s9
    P( local.B, local.C, local.D, local.A,  3, 22, 0xC1BDCEEE );
40026920:	019a44b3          	xor	s1,s4,s9
40026924:	eee98993          	addi	s3,s3,-274 # c1bdceee <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xc1bdceef>
40026928:	0154f4b3          	and	s1,s1,s5
4002692c:	013909b3          	add	s3,s2,s3
40026930:	01e989b3          	add	s3,s3,t5
40026934:	0144c4b3          	xor	s1,s1,s4
40026938:	013484b3          	add	s1,s1,s3
4002693c:	00a4d993          	srli	s3,s1,0xa
40026940:	01649493          	slli	s1,s1,0x16
40026944:	0099e9b3          	or	s3,s3,s1
40026948:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  4,  7, 0xF57C0FAF );
4002694c:	015cc4b3          	xor	s1,s9,s5
40026950:	0134f4b3          	and	s1,s1,s3
40026954:	014d0a33          	add	s4,s10,s4
40026958:	0194c4b3          	xor	s1,s1,s9
4002695c:	014484b3          	add	s1,s1,s4
40026960:	00749a13          	slli	s4,s1,0x7
40026964:	0194d493          	srli	s1,s1,0x19
40026968:	009a6a33          	or	s4,s4,s1
    P( local.D, local.A, local.B, local.C,  5, 12, 0x4787C62A );
4002696c:	4787cd37          	lui	s10,0x4787c
    P( local.A, local.B, local.C, local.D,  4,  7, 0xF57C0FAF );
40026970:	013a0a33          	add	s4,s4,s3
    P( local.D, local.A, local.B, local.C,  5, 12, 0x4787C62A );
40026974:	013ac4b3          	xor	s1,s5,s3
40026978:	62ad0d13          	addi	s10,s10,1578 # 4787c62a <__data_region_end+0x783f9b6>
4002697c:	01a28d33          	add	s10,t0,s10
40026980:	0144f4b3          	and	s1,s1,s4
40026984:	019d0cb3          	add	s9,s10,s9
40026988:	0154c4b3          	xor	s1,s1,s5
4002698c:	019484b3          	add	s1,s1,s9
40026990:	00c49c93          	slli	s9,s1,0xc
40026994:	0144d493          	srli	s1,s1,0x14
40026998:	009cecb3          	or	s9,s9,s1
    P( local.C, local.D, local.A, local.B,  6, 17, 0xA8304613 );
4002699c:	a8304d37          	lui	s10,0xa8304
    P( local.D, local.A, local.B, local.C,  5, 12, 0x4787C62A );
400269a0:	014c8cb3          	add	s9,s9,s4
    P( local.C, local.D, local.A, local.B,  6, 17, 0xA8304613 );
400269a4:	0149c4b3          	xor	s1,s3,s4
400269a8:	613d0d13          	addi	s10,s10,1555 # a8304613 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xa8304614>
400269ac:	01a88d33          	add	s10,a7,s10
400269b0:	0194f4b3          	and	s1,s1,s9
400269b4:	015d0ab3          	add	s5,s10,s5
400269b8:	0134c4b3          	xor	s1,s1,s3
400269bc:	015484b3          	add	s1,s1,s5
400269c0:	00f4da93          	srli	s5,s1,0xf
400269c4:	01149493          	slli	s1,s1,0x11
400269c8:	009aeab3          	or	s5,s5,s1
    P( local.B, local.C, local.D, local.A,  7, 22, 0xFD469501 );
400269cc:	fd469d37          	lui	s10,0xfd469
    P( local.C, local.D, local.A, local.B,  6, 17, 0xA8304613 );
400269d0:	019a8ab3          	add	s5,s5,s9
    P( local.B, local.C, local.D, local.A,  7, 22, 0xFD469501 );
400269d4:	019a44b3          	xor	s1,s4,s9
400269d8:	501d0d13          	addi	s10,s10,1281 # fd469501 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfd469502>
400269dc:	01a08d33          	add	s10,ra,s10
400269e0:	0154f4b3          	and	s1,s1,s5
400269e4:	013d09b3          	add	s3,s10,s3
400269e8:	0144c4b3          	xor	s1,s1,s4
400269ec:	013484b3          	add	s1,s1,s3
400269f0:	00a4d993          	srli	s3,s1,0xa
400269f4:	01649493          	slli	s1,s1,0x16
400269f8:	0099e9b3          	or	s3,s3,s1
    P( local.A, local.B, local.C, local.D,  8,  7, 0x698098D8 );
400269fc:	6980ad37          	lui	s10,0x6980a
    P( local.B, local.C, local.D, local.A,  7, 22, 0xFD469501 );
40026a00:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  8,  7, 0x698098D8 );
40026a04:	015cc4b3          	xor	s1,s9,s5
40026a08:	8d8d0d13          	addi	s10,s10,-1832 # 698098d8 <__data_region_end+0x297ccc64>
40026a0c:	01a30d33          	add	s10,t1,s10
40026a10:	0134f4b3          	and	s1,s1,s3
40026a14:	014d0a33          	add	s4,s10,s4
40026a18:	0194c4b3          	xor	s1,s1,s9
40026a1c:	014484b3          	add	s1,s1,s4
40026a20:	00749a13          	slli	s4,s1,0x7
40026a24:	0194d493          	srli	s1,s1,0x19
40026a28:	009a6a33          	or	s4,s4,s1
    P( local.D, local.A, local.B, local.C,  9, 12, 0x8B44F7AF );
40026a2c:	8b44fd37          	lui	s10,0x8b44f
    P( local.A, local.B, local.C, local.D,  8,  7, 0x698098D8 );
40026a30:	013a0a33          	add	s4,s4,s3
    P( local.D, local.A, local.B, local.C,  9, 12, 0x8B44F7AF );
40026a34:	013ac4b3          	xor	s1,s5,s3
40026a38:	7afd0d13          	addi	s10,s10,1967 # 8b44f7af <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8b44f7b0>
40026a3c:	01a78d33          	add	s10,a5,s10
40026a40:	0144f4b3          	and	s1,s1,s4
40026a44:	019d0cb3          	add	s9,s10,s9
40026a48:	0154c4b3          	xor	s1,s1,s5
40026a4c:	019484b3          	add	s1,s1,s9
40026a50:	00c49c93          	slli	s9,s1,0xc
40026a54:	0144d493          	srli	s1,s1,0x14
40026a58:	009cecb3          	or	s9,s9,s1
    P( local.C, local.D, local.A, local.B, 10, 17, 0xFFFF5BB1 );
40026a5c:	ffff6d37          	lui	s10,0xffff6
    P( local.D, local.A, local.B, local.C,  9, 12, 0x8B44F7AF );
40026a60:	014c8cb3          	add	s9,s9,s4
    P( local.C, local.D, local.A, local.B, 10, 17, 0xFFFF5BB1 );
40026a64:	0149c4b3          	xor	s1,s3,s4
40026a68:	bb1d0d13          	addi	s10,s10,-1103 # ffff5bb1 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff5bb2>
40026a6c:	01ae8d33          	add	s10,t4,s10
40026a70:	0194f4b3          	and	s1,s1,s9
40026a74:	015d0ab3          	add	s5,s10,s5
40026a78:	0134c4b3          	xor	s1,s1,s3
40026a7c:	015484b3          	add	s1,s1,s5
40026a80:	00f4da93          	srli	s5,s1,0xf
40026a84:	01149493          	slli	s1,s1,0x11
40026a88:	009aeab3          	or	s5,s5,s1
    P( local.B, local.C, local.D, local.A, 11, 22, 0x895CD7BE );
40026a8c:	895cdd37          	lui	s10,0x895cd
    P( local.C, local.D, local.A, local.B, 10, 17, 0xFFFF5BB1 );
40026a90:	019a8ab3          	add	s5,s5,s9
    P( local.B, local.C, local.D, local.A, 11, 22, 0x895CD7BE );
40026a94:	019a44b3          	xor	s1,s4,s9
40026a98:	7bed0d13          	addi	s10,s10,1982 # 895cd7be <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x895cd7bf>
40026a9c:	01a68d33          	add	s10,a3,s10
40026aa0:	0154f4b3          	and	s1,s1,s5
40026aa4:	013d09b3          	add	s3,s10,s3
40026aa8:	0144c4b3          	xor	s1,s1,s4
40026aac:	013484b3          	add	s1,s1,s3
40026ab0:	00a4d993          	srli	s3,s1,0xa
40026ab4:	01649493          	slli	s1,s1,0x16
40026ab8:	0099e9b3          	or	s3,s3,s1
    P( local.A, local.B, local.C, local.D, 12,  7, 0x6B901122 );
40026abc:	6b901d37          	lui	s10,0x6b901
    P( local.B, local.C, local.D, local.A, 11, 22, 0x895CD7BE );
40026ac0:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D, 12,  7, 0x6B901122 );
40026ac4:	015cc4b3          	xor	s1,s9,s5
40026ac8:	122d0d13          	addi	s10,s10,290 # 6b901122 <__data_region_end+0x2b8c44ae>
40026acc:	01af8d33          	add	s10,t6,s10
40026ad0:	0134f4b3          	and	s1,s1,s3
40026ad4:	014d0a33          	add	s4,s10,s4
40026ad8:	0194c4b3          	xor	s1,s1,s9
40026adc:	014484b3          	add	s1,s1,s4
40026ae0:	00749a13          	slli	s4,s1,0x7
40026ae4:	0194d493          	srli	s1,s1,0x19
40026ae8:	009a6a33          	or	s4,s4,s1
    P( local.D, local.A, local.B, local.C, 13, 12, 0xFD987193 );
40026aec:	fd987d37          	lui	s10,0xfd987
    P( local.A, local.B, local.C, local.D, 12,  7, 0x6B901122 );
40026af0:	013a0a33          	add	s4,s4,s3
    P( local.D, local.A, local.B, local.C, 13, 12, 0xFD987193 );
40026af4:	013ac4b3          	xor	s1,s5,s3
40026af8:	193d0d13          	addi	s10,s10,403 # fd987193 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfd987194>
40026afc:	01a80d33          	add	s10,a6,s10
40026b00:	0144f4b3          	and	s1,s1,s4
40026b04:	019d0cb3          	add	s9,s10,s9
40026b08:	0154c4b3          	xor	s1,s1,s5
40026b0c:	019484b3          	add	s1,s1,s9
40026b10:	00c49d13          	slli	s10,s1,0xc
40026b14:	0144d493          	srli	s1,s1,0x14
40026b18:	009d6d33          	or	s10,s10,s1
    P( local.C, local.D, local.A, local.B, 14, 17, 0xA679438E );
40026b1c:	a6794cb7          	lui	s9,0xa6794
    P( local.D, local.A, local.B, local.C, 13, 12, 0xFD987193 );
40026b20:	014d0d33          	add	s10,s10,s4
    P( local.C, local.D, local.A, local.B, 14, 17, 0xA679438E );
40026b24:	0149c4b3          	xor	s1,s3,s4
40026b28:	38ec8c93          	addi	s9,s9,910 # a679438e <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xa679438f>
40026b2c:	01938cb3          	add	s9,t2,s9
40026b30:	01a4f4b3          	and	s1,s1,s10
40026b34:	015c8ab3          	add	s5,s9,s5
40026b38:	0134c4b3          	xor	s1,s1,s3
40026b3c:	015484b3          	add	s1,s1,s5
40026b40:	00f4da93          	srli	s5,s1,0xf
40026b44:	01149493          	slli	s1,s1,0x11
40026b48:	009aeab3          	or	s5,s5,s1
    P( local.B, local.C, local.D, local.A, 15, 22, 0x49B40821 );
40026b4c:	49b41cb7          	lui	s9,0x49b41
    P( local.C, local.D, local.A, local.B, 14, 17, 0xA679438E );
40026b50:	01aa8ab3          	add	s5,s5,s10
    P( local.B, local.C, local.D, local.A, 15, 22, 0x49B40821 );
40026b54:	01aa44b3          	xor	s1,s4,s10
40026b58:	821c8c93          	addi	s9,s9,-2015 # 49b40821 <__data_region_end+0x9b03bad>
40026b5c:	01958cb3          	add	s9,a1,s9
40026b60:	0154f4b3          	and	s1,s1,s5
40026b64:	013c89b3          	add	s3,s9,s3
40026b68:	0144c4b3          	xor	s1,s1,s4
40026b6c:	013484b3          	add	s1,s1,s3
40026b70:	00a4d993          	srli	s3,s1,0xa
40026b74:	01649493          	slli	s1,s1,0x16
40026b78:	0099e9b3          	or	s3,s3,s1
40026b7c:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  1,  5, 0xF61E2562 );
40026b80:	f61e2cb7          	lui	s9,0xf61e2
40026b84:	013ac4b3          	xor	s1,s5,s3
40026b88:	562c8c93          	addi	s9,s9,1378 # f61e2562 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf61e2563>
40026b8c:	019e0cb3          	add	s9,t3,s9
40026b90:	01a4f4b3          	and	s1,s1,s10
40026b94:	014c8a33          	add	s4,s9,s4
40026b98:	0154c4b3          	xor	s1,s1,s5
40026b9c:	014484b3          	add	s1,s1,s4
40026ba0:	00549c93          	slli	s9,s1,0x5
40026ba4:	01b4d493          	srli	s1,s1,0x1b
40026ba8:	009cecb3          	or	s9,s9,s1
40026bac:	013c8cb3          	add	s9,s9,s3
    P( local.D, local.A, local.B, local.C,  6,  9, 0xC040B340 );
40026bb0:	c040ba37          	lui	s4,0xc040b
40026bb4:	0199c4b3          	xor	s1,s3,s9
40026bb8:	340a0a13          	addi	s4,s4,832 # c040b340 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xc040b341>
40026bbc:	0154f4b3          	and	s1,s1,s5
40026bc0:	01488a33          	add	s4,a7,s4
40026bc4:	01aa0a33          	add	s4,s4,s10
40026bc8:	0134c4b3          	xor	s1,s1,s3
40026bcc:	014484b3          	add	s1,s1,s4
40026bd0:	00949a13          	slli	s4,s1,0x9
40026bd4:	0174d493          	srli	s1,s1,0x17
40026bd8:	009a6a33          	or	s4,s4,s1
40026bdc:	019a0a33          	add	s4,s4,s9
    P( local.C, local.D, local.A, local.B, 11, 14, 0x265E5A51 );
40026be0:	265e6d37          	lui	s10,0x265e6
40026be4:	014cc4b3          	xor	s1,s9,s4
40026be8:	a51d0d13          	addi	s10,s10,-1455 # 265e5a51 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x20687951>
40026bec:	01a68d33          	add	s10,a3,s10
40026bf0:	0134f4b3          	and	s1,s1,s3
40026bf4:	015d0ab3          	add	s5,s10,s5
40026bf8:	0194c4b3          	xor	s1,s1,s9
40026bfc:	015484b3          	add	s1,s1,s5
40026c00:	00e49a93          	slli	s5,s1,0xe
40026c04:	0124d493          	srli	s1,s1,0x12
40026c08:	009aeab3          	or	s5,s5,s1
40026c0c:	014a8ab3          	add	s5,s5,s4
    P( local.B, local.C, local.D, local.A,  0, 20, 0xE9B6C7AA );
40026c10:	e9b6cd37          	lui	s10,0xe9b6c
40026c14:	015a44b3          	xor	s1,s4,s5
40026c18:	7aad0d13          	addi	s10,s10,1962 # e9b6c7aa <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe9b6c7ab>
40026c1c:	01a40d33          	add	s10,s0,s10
40026c20:	0194f4b3          	and	s1,s1,s9
40026c24:	013d09b3          	add	s3,s10,s3
40026c28:	0144c4b3          	xor	s1,s1,s4
40026c2c:	013484b3          	add	s1,s1,s3
40026c30:	00c4d993          	srli	s3,s1,0xc
40026c34:	01449493          	slli	s1,s1,0x14
40026c38:	0099e9b3          	or	s3,s3,s1
40026c3c:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  5,  5, 0xD62F105D );
40026c40:	d62f1d37          	lui	s10,0xd62f1
40026c44:	013ac4b3          	xor	s1,s5,s3
40026c48:	05dd0d13          	addi	s10,s10,93 # d62f105d <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd62f105e>
40026c4c:	01a28d33          	add	s10,t0,s10
40026c50:	0144f4b3          	and	s1,s1,s4
40026c54:	019d0cb3          	add	s9,s10,s9
40026c58:	0154c4b3          	xor	s1,s1,s5
40026c5c:	019484b3          	add	s1,s1,s9
40026c60:	00549c93          	slli	s9,s1,0x5
40026c64:	01b4d493          	srli	s1,s1,0x1b
40026c68:	009cecb3          	or	s9,s9,s1
40026c6c:	013c8cb3          	add	s9,s9,s3
    P( local.D, local.A, local.B, local.C, 10,  9, 0x02441453 );
40026c70:	02441d37          	lui	s10,0x2441
40026c74:	0199c4b3          	xor	s1,s3,s9
40026c78:	453d0d13          	addi	s10,s10,1107 # 2441453 <__rom_region_size+0x2410a77>
40026c7c:	01ae8d33          	add	s10,t4,s10
40026c80:	0154f4b3          	and	s1,s1,s5
40026c84:	014d0a33          	add	s4,s10,s4
40026c88:	0134c4b3          	xor	s1,s1,s3
40026c8c:	014484b3          	add	s1,s1,s4
40026c90:	00949a13          	slli	s4,s1,0x9
40026c94:	0174d493          	srli	s1,s1,0x17
40026c98:	009a6a33          	or	s4,s4,s1
40026c9c:	019a0a33          	add	s4,s4,s9
    P( local.C, local.D, local.A, local.B, 15, 14, 0xD8A1E681 );
40026ca0:	d8a1ed37          	lui	s10,0xd8a1e
40026ca4:	014cc4b3          	xor	s1,s9,s4
40026ca8:	681d0d13          	addi	s10,s10,1665 # d8a1e681 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd8a1e682>
40026cac:	01a58d33          	add	s10,a1,s10
40026cb0:	0134f4b3          	and	s1,s1,s3
40026cb4:	015d0ab3          	add	s5,s10,s5
40026cb8:	0194c4b3          	xor	s1,s1,s9
40026cbc:	015484b3          	add	s1,s1,s5
40026cc0:	00e49a93          	slli	s5,s1,0xe
40026cc4:	0124d493          	srli	s1,s1,0x12
40026cc8:	009aeab3          	or	s5,s5,s1
40026ccc:	014a8ab3          	add	s5,s5,s4
    P( local.B, local.C, local.D, local.A,  4, 20, 0xE7D3FBC8 );
40026cd0:	e7d40d37          	lui	s10,0xe7d40
40026cd4:	015a44b3          	xor	s1,s4,s5
40026cd8:	bc8d0d13          	addi	s10,s10,-1080 # e7d3fbc8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe7d3fbc9>
40026cdc:	01a60d33          	add	s10,a2,s10
40026ce0:	0194f4b3          	and	s1,s1,s9
40026ce4:	013d09b3          	add	s3,s10,s3
40026ce8:	0144c4b3          	xor	s1,s1,s4
40026cec:	013484b3          	add	s1,s1,s3
40026cf0:	00c4d993          	srli	s3,s1,0xc
40026cf4:	01449493          	slli	s1,s1,0x14
40026cf8:	0099e9b3          	or	s3,s3,s1
40026cfc:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  9,  5, 0x21E1CDE6 );
40026d00:	21e1dd37          	lui	s10,0x21e1d
40026d04:	013ac4b3          	xor	s1,s5,s3
40026d08:	de6d0d13          	addi	s10,s10,-538 # 21e1cde6 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1bebece6>
40026d0c:	01a78d33          	add	s10,a5,s10
40026d10:	0144f4b3          	and	s1,s1,s4
40026d14:	019d0cb3          	add	s9,s10,s9
40026d18:	0154c4b3          	xor	s1,s1,s5
40026d1c:	019484b3          	add	s1,s1,s9
40026d20:	00549c93          	slli	s9,s1,0x5
40026d24:	01b4d493          	srli	s1,s1,0x1b
40026d28:	009cecb3          	or	s9,s9,s1
40026d2c:	013c8cb3          	add	s9,s9,s3
    P( local.D, local.A, local.B, local.C, 14,  9, 0xC33707D6 );
40026d30:	c3370d37          	lui	s10,0xc3370
40026d34:	0199c4b3          	xor	s1,s3,s9
40026d38:	7d6d0d13          	addi	s10,s10,2006 # c33707d6 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xc33707d7>
40026d3c:	01a38d33          	add	s10,t2,s10
40026d40:	0154f4b3          	and	s1,s1,s5
40026d44:	014d0a33          	add	s4,s10,s4
40026d48:	0134c4b3          	xor	s1,s1,s3
40026d4c:	014484b3          	add	s1,s1,s4
40026d50:	00949a13          	slli	s4,s1,0x9
40026d54:	0174d493          	srli	s1,s1,0x17
40026d58:	009a6a33          	or	s4,s4,s1
40026d5c:	019a0a33          	add	s4,s4,s9
    P( local.C, local.D, local.A, local.B,  3, 14, 0xF4D50D87 );
40026d60:	f4d51d37          	lui	s10,0xf4d51
40026d64:	014cc4b3          	xor	s1,s9,s4
40026d68:	d87d0d13          	addi	s10,s10,-633 # f4d50d87 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf4d50d88>
40026d6c:	01af0d33          	add	s10,t5,s10
40026d70:	0134f4b3          	and	s1,s1,s3
40026d74:	015d0ab3          	add	s5,s10,s5
40026d78:	0194c4b3          	xor	s1,s1,s9
40026d7c:	015484b3          	add	s1,s1,s5
40026d80:	00e49a93          	slli	s5,s1,0xe
40026d84:	0124d493          	srli	s1,s1,0x12
40026d88:	009aeab3          	or	s5,s5,s1
40026d8c:	014a8ab3          	add	s5,s5,s4
    P( local.B, local.C, local.D, local.A,  8, 20, 0x455A14ED );
40026d90:	455a1d37          	lui	s10,0x455a1
40026d94:	015a44b3          	xor	s1,s4,s5
40026d98:	4edd0d13          	addi	s10,s10,1261 # 455a14ed <__data_region_end+0x5564879>
40026d9c:	01a30d33          	add	s10,t1,s10
40026da0:	0194f4b3          	and	s1,s1,s9
40026da4:	013d09b3          	add	s3,s10,s3
40026da8:	0144c4b3          	xor	s1,s1,s4
40026dac:	013484b3          	add	s1,s1,s3
40026db0:	00c4d993          	srli	s3,s1,0xc
40026db4:	01449493          	slli	s1,s1,0x14
40026db8:	0099e4b3          	or	s1,s3,s1
40026dbc:	015484b3          	add	s1,s1,s5
    P( local.A, local.B, local.C, local.D, 13,  5, 0xA9E3E905 );
40026dc0:	a9e3fd37          	lui	s10,0xa9e3f
40026dc4:	009ac9b3          	xor	s3,s5,s1
40026dc8:	905d0d13          	addi	s10,s10,-1787 # a9e3e905 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xa9e3e906>
40026dcc:	01a80d33          	add	s10,a6,s10
40026dd0:	0149f9b3          	and	s3,s3,s4
40026dd4:	019d0cb3          	add	s9,s10,s9
40026dd8:	0159c9b3          	xor	s3,s3,s5
40026ddc:	019989b3          	add	s3,s3,s9
40026de0:	00599d13          	slli	s10,s3,0x5
40026de4:	01b9d993          	srli	s3,s3,0x1b
40026de8:	013d6d33          	or	s10,s10,s3
40026dec:	009d0d33          	add	s10,s10,s1
    P( local.D, local.A, local.B, local.C,  2,  9, 0xFCEFA3F8 );
40026df0:	fcefacb7          	lui	s9,0xfcefa
40026df4:	01a4c9b3          	xor	s3,s1,s10
40026df8:	3f8c8c93          	addi	s9,s9,1016 # fcefa3f8 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfcefa3f9>
40026dfc:	01970cb3          	add	s9,a4,s9
40026e00:	0159f9b3          	and	s3,s3,s5
40026e04:	014c8a33          	add	s4,s9,s4
40026e08:	0099c9b3          	xor	s3,s3,s1
40026e0c:	014989b3          	add	s3,s3,s4
40026e10:	00999a13          	slli	s4,s3,0x9
40026e14:	0179d993          	srli	s3,s3,0x17
40026e18:	013a6a33          	or	s4,s4,s3
40026e1c:	01aa0a33          	add	s4,s4,s10
    P( local.C, local.D, local.A, local.B,  7, 14, 0x676F02D9 );
40026e20:	676f0cb7          	lui	s9,0x676f0
40026e24:	014d49b3          	xor	s3,s10,s4
40026e28:	2d9c8c93          	addi	s9,s9,729 # 676f02d9 <__data_region_end+0x276b3665>
40026e2c:	01908cb3          	add	s9,ra,s9
40026e30:	0099f9b3          	and	s3,s3,s1
40026e34:	015c8ab3          	add	s5,s9,s5
40026e38:	01a9c9b3          	xor	s3,s3,s10
40026e3c:	015989b3          	add	s3,s3,s5
40026e40:	00e99a93          	slli	s5,s3,0xe
40026e44:	0129d993          	srli	s3,s3,0x12
40026e48:	013aeab3          	or	s5,s5,s3
40026e4c:	014a8ab3          	add	s5,s5,s4
    P( local.B, local.C, local.D, local.A, 12, 20, 0x8D2A4C8A );
40026e50:	015a4cb3          	xor	s9,s4,s5
40026e54:	019d79b3          	and	s3,s10,s9
40026e58:	009d84b3          	add	s1,s11,s1
40026e5c:	0149c9b3          	xor	s3,s3,s4
40026e60:	009989b3          	add	s3,s3,s1
40026e64:	00c9d493          	srli	s1,s3,0xc
40026e68:	01499993          	slli	s3,s3,0x14
40026e6c:	0134e9b3          	or	s3,s1,s3

#undef F

#define F(x,y,z) ((x) ^ (y) ^ (z))

    P( local.A, local.B, local.C, local.D,  5,  4, 0xFFFA3942 );
40026e70:	fffa44b7          	lui	s1,0xfffa4
40026e74:	94248493          	addi	s1,s1,-1726 # fffa3942 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfffa3943>
    P( local.B, local.C, local.D, local.A, 12, 20, 0x8D2A4C8A );
40026e78:	015989b3          	add	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  5,  4, 0xFFFA3942 );
40026e7c:	009284b3          	add	s1,t0,s1
40026e80:	013cccb3          	xor	s9,s9,s3
40026e84:	01a484b3          	add	s1,s1,s10
40026e88:	019484b3          	add	s1,s1,s9
40026e8c:	00449c93          	slli	s9,s1,0x4
    P( local.D, local.A, local.B, local.C,  8, 11, 0x8771F681 );
40026e90:	8771fd37          	lui	s10,0x8771f
    P( local.A, local.B, local.C, local.D,  5,  4, 0xFFFA3942 );
40026e94:	01c4d493          	srli	s1,s1,0x1c
40026e98:	009ce4b3          	or	s1,s9,s1
    P( local.D, local.A, local.B, local.C,  8, 11, 0x8771F681 );
40026e9c:	681d0d13          	addi	s10,s10,1665 # 8771f681 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8771f682>
    P( local.A, local.B, local.C, local.D,  5,  4, 0xFFFA3942 );
40026ea0:	013484b3          	add	s1,s1,s3
    P( local.D, local.A, local.B, local.C,  8, 11, 0x8771F681 );
40026ea4:	013accb3          	xor	s9,s5,s3
40026ea8:	01a30d33          	add	s10,t1,s10
40026eac:	014d0a33          	add	s4,s10,s4
40026eb0:	009cccb3          	xor	s9,s9,s1
40026eb4:	014c8cb3          	add	s9,s9,s4
40026eb8:	00bc9a13          	slli	s4,s9,0xb
    P( local.C, local.D, local.A, local.B, 11, 16, 0x6D9D6122 );
40026ebc:	6d9d6d37          	lui	s10,0x6d9d6
    P( local.D, local.A, local.B, local.C,  8, 11, 0x8771F681 );
40026ec0:	015cdc93          	srli	s9,s9,0x15
40026ec4:	019a6cb3          	or	s9,s4,s9
    P( local.C, local.D, local.A, local.B, 11, 16, 0x6D9D6122 );
40026ec8:	122d0d13          	addi	s10,s10,290 # 6d9d6122 <__data_region_end+0x2d9994ae>
    P( local.D, local.A, local.B, local.C,  8, 11, 0x8771F681 );
40026ecc:	009c8cb3          	add	s9,s9,s1
    P( local.C, local.D, local.A, local.B, 11, 16, 0x6D9D6122 );
40026ed0:	0099ca33          	xor	s4,s3,s1
40026ed4:	01a68d33          	add	s10,a3,s10
40026ed8:	015d0ab3          	add	s5,s10,s5
40026edc:	019a4a33          	xor	s4,s4,s9
40026ee0:	015a0a33          	add	s4,s4,s5
40026ee4:	010a1a93          	slli	s5,s4,0x10
    P( local.B, local.C, local.D, local.A, 14, 23, 0xFDE5380C );
40026ee8:	fde54d37          	lui	s10,0xfde54
    P( local.C, local.D, local.A, local.B, 11, 16, 0x6D9D6122 );
40026eec:	010a5a13          	srli	s4,s4,0x10
40026ef0:	014aea33          	or	s4,s5,s4
    P( local.B, local.C, local.D, local.A, 14, 23, 0xFDE5380C );
40026ef4:	80cd0d13          	addi	s10,s10,-2036 # fde5380c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfde5380d>
    P( local.C, local.D, local.A, local.B, 11, 16, 0x6D9D6122 );
40026ef8:	019a0a33          	add	s4,s4,s9
    P( local.B, local.C, local.D, local.A, 14, 23, 0xFDE5380C );
40026efc:	0194cab3          	xor	s5,s1,s9
40026f00:	01a38d33          	add	s10,t2,s10
40026f04:	013d09b3          	add	s3,s10,s3
40026f08:	014acab3          	xor	s5,s5,s4
40026f0c:	013a8ab3          	add	s5,s5,s3
40026f10:	009ad993          	srli	s3,s5,0x9
    P( local.A, local.B, local.C, local.D,  1,  4, 0xA4BEEA44 );
40026f14:	a4befd37          	lui	s10,0xa4bef
    P( local.B, local.C, local.D, local.A, 14, 23, 0xFDE5380C );
40026f18:	017a9a93          	slli	s5,s5,0x17
40026f1c:	0159e9b3          	or	s3,s3,s5
    P( local.A, local.B, local.C, local.D,  1,  4, 0xA4BEEA44 );
40026f20:	a44d0d13          	addi	s10,s10,-1468 # a4beea44 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xa4beea45>
    P( local.B, local.C, local.D, local.A, 14, 23, 0xFDE5380C );
40026f24:	014989b3          	add	s3,s3,s4
    P( local.A, local.B, local.C, local.D,  1,  4, 0xA4BEEA44 );
40026f28:	014ccab3          	xor	s5,s9,s4
40026f2c:	01ae0d33          	add	s10,t3,s10
40026f30:	009d04b3          	add	s1,s10,s1
40026f34:	013acab3          	xor	s5,s5,s3
40026f38:	009a8ab3          	add	s5,s5,s1
40026f3c:	004a9493          	slli	s1,s5,0x4
    P( local.D, local.A, local.B, local.C,  4, 11, 0x4BDECFA9 );
40026f40:	4bdedd37          	lui	s10,0x4bded
    P( local.A, local.B, local.C, local.D,  1,  4, 0xA4BEEA44 );
40026f44:	01cada93          	srli	s5,s5,0x1c
40026f48:	0154e4b3          	or	s1,s1,s5
    P( local.D, local.A, local.B, local.C,  4, 11, 0x4BDECFA9 );
40026f4c:	fa9d0d13          	addi	s10,s10,-87 # 4bdecfa9 <__data_region_end+0xbdb0335>
    P( local.A, local.B, local.C, local.D,  1,  4, 0xA4BEEA44 );
40026f50:	013484b3          	add	s1,s1,s3
    P( local.D, local.A, local.B, local.C,  4, 11, 0x4BDECFA9 );
40026f54:	013a4ab3          	xor	s5,s4,s3
40026f58:	01a60d33          	add	s10,a2,s10
40026f5c:	019d0cb3          	add	s9,s10,s9
40026f60:	009acab3          	xor	s5,s5,s1
40026f64:	019a8ab3          	add	s5,s5,s9
40026f68:	00ba9c93          	slli	s9,s5,0xb
    P( local.C, local.D, local.A, local.B,  7, 16, 0xF6BB4B60 );
40026f6c:	f6bb5d37          	lui	s10,0xf6bb5
    P( local.D, local.A, local.B, local.C,  4, 11, 0x4BDECFA9 );
40026f70:	015ada93          	srli	s5,s5,0x15
40026f74:	015ceab3          	or	s5,s9,s5
    P( local.C, local.D, local.A, local.B,  7, 16, 0xF6BB4B60 );
40026f78:	b60d0d13          	addi	s10,s10,-1184 # f6bb4b60 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf6bb4b61>
    P( local.D, local.A, local.B, local.C,  4, 11, 0x4BDECFA9 );
40026f7c:	009a8ab3          	add	s5,s5,s1
    P( local.C, local.D, local.A, local.B,  7, 16, 0xF6BB4B60 );
40026f80:	0099ccb3          	xor	s9,s3,s1
40026f84:	01a08d33          	add	s10,ra,s10
40026f88:	014d0a33          	add	s4,s10,s4
40026f8c:	015cccb3          	xor	s9,s9,s5
40026f90:	014c8cb3          	add	s9,s9,s4
40026f94:	010c9a13          	slli	s4,s9,0x10
    P( local.B, local.C, local.D, local.A, 10, 23, 0xBEBFBC70 );
40026f98:	bebfcd37          	lui	s10,0xbebfc
    P( local.C, local.D, local.A, local.B,  7, 16, 0xF6BB4B60 );
40026f9c:	010cdc93          	srli	s9,s9,0x10
40026fa0:	019a6a33          	or	s4,s4,s9
    P( local.B, local.C, local.D, local.A, 10, 23, 0xBEBFBC70 );
40026fa4:	c70d0d13          	addi	s10,s10,-912 # bebfbc70 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xbebfbc71>
    P( local.C, local.D, local.A, local.B,  7, 16, 0xF6BB4B60 );
40026fa8:	015a0a33          	add	s4,s4,s5
    P( local.B, local.C, local.D, local.A, 10, 23, 0xBEBFBC70 );
40026fac:	0154ccb3          	xor	s9,s1,s5
40026fb0:	01ae8d33          	add	s10,t4,s10
40026fb4:	013d09b3          	add	s3,s10,s3
40026fb8:	014cccb3          	xor	s9,s9,s4
40026fbc:	013c8cb3          	add	s9,s9,s3
40026fc0:	009cd993          	srli	s3,s9,0x9
    P( local.A, local.B, local.C, local.D, 13,  4, 0x289B7EC6 );
40026fc4:	289b8d37          	lui	s10,0x289b8
    P( local.B, local.C, local.D, local.A, 10, 23, 0xBEBFBC70 );
40026fc8:	017c9c93          	slli	s9,s9,0x17
40026fcc:	0199e9b3          	or	s3,s3,s9
    P( local.A, local.B, local.C, local.D, 13,  4, 0x289B7EC6 );
40026fd0:	ec6d0d13          	addi	s10,s10,-314 # 289b7ec6 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x22a59dc6>
    P( local.B, local.C, local.D, local.A, 10, 23, 0xBEBFBC70 );
40026fd4:	014989b3          	add	s3,s3,s4
    P( local.A, local.B, local.C, local.D, 13,  4, 0x289B7EC6 );
40026fd8:	014accb3          	xor	s9,s5,s4
40026fdc:	01a80d33          	add	s10,a6,s10
40026fe0:	009d04b3          	add	s1,s10,s1
40026fe4:	013cccb3          	xor	s9,s9,s3
40026fe8:	009c8cb3          	add	s9,s9,s1
40026fec:	004c9493          	slli	s1,s9,0x4
    P( local.D, local.A, local.B, local.C,  0, 11, 0xEAA127FA );
40026ff0:	eaa12d37          	lui	s10,0xeaa12
    P( local.A, local.B, local.C, local.D, 13,  4, 0x289B7EC6 );
40026ff4:	01ccdc93          	srli	s9,s9,0x1c
40026ff8:	0194e4b3          	or	s1,s1,s9
    P( local.D, local.A, local.B, local.C,  0, 11, 0xEAA127FA );
40026ffc:	7fad0d13          	addi	s10,s10,2042 # eaa127fa <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xeaa127fb>
    P( local.A, local.B, local.C, local.D, 13,  4, 0x289B7EC6 );
40027000:	013484b3          	add	s1,s1,s3
    P( local.D, local.A, local.B, local.C,  0, 11, 0xEAA127FA );
40027004:	013a4cb3          	xor	s9,s4,s3
40027008:	01a40d33          	add	s10,s0,s10
4002700c:	015d0ab3          	add	s5,s10,s5
40027010:	009cccb3          	xor	s9,s9,s1
40027014:	015c8cb3          	add	s9,s9,s5
40027018:	00bc9a93          	slli	s5,s9,0xb
    P( local.C, local.D, local.A, local.B,  3, 16, 0xD4EF3085 );
4002701c:	d4ef3d37          	lui	s10,0xd4ef3
    P( local.D, local.A, local.B, local.C,  0, 11, 0xEAA127FA );
40027020:	015cdc93          	srli	s9,s9,0x15
40027024:	019aeab3          	or	s5,s5,s9
    P( local.C, local.D, local.A, local.B,  3, 16, 0xD4EF3085 );
40027028:	085d0d13          	addi	s10,s10,133 # d4ef3085 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd4ef3086>
    P( local.D, local.A, local.B, local.C,  0, 11, 0xEAA127FA );
4002702c:	009a8ab3          	add	s5,s5,s1
    P( local.C, local.D, local.A, local.B,  3, 16, 0xD4EF3085 );
40027030:	0099ccb3          	xor	s9,s3,s1
40027034:	01af0d33          	add	s10,t5,s10
40027038:	014d0a33          	add	s4,s10,s4
4002703c:	015cccb3          	xor	s9,s9,s5
40027040:	014c8cb3          	add	s9,s9,s4
40027044:	010c9a13          	slli	s4,s9,0x10
    P( local.B, local.C, local.D, local.A,  6, 23, 0x04881D05 );
40027048:	04882d37          	lui	s10,0x4882
    P( local.C, local.D, local.A, local.B,  3, 16, 0xD4EF3085 );
4002704c:	010cdc93          	srli	s9,s9,0x10
40027050:	019a6a33          	or	s4,s4,s9
    P( local.B, local.C, local.D, local.A,  6, 23, 0x04881D05 );
40027054:	d05d0d13          	addi	s10,s10,-763 # 4881d05 <__rom_region_size+0x4851329>
    P( local.C, local.D, local.A, local.B,  3, 16, 0xD4EF3085 );
40027058:	015a0a33          	add	s4,s4,s5
    P( local.B, local.C, local.D, local.A,  6, 23, 0x04881D05 );
4002705c:	0154ccb3          	xor	s9,s1,s5
40027060:	01a88d33          	add	s10,a7,s10
40027064:	013d09b3          	add	s3,s10,s3
40027068:	014cccb3          	xor	s9,s9,s4
4002706c:	013c8cb3          	add	s9,s9,s3
40027070:	009cd993          	srli	s3,s9,0x9
    P( local.A, local.B, local.C, local.D,  9,  4, 0xD9D4D039 );
40027074:	d9d4dd37          	lui	s10,0xd9d4d
    P( local.B, local.C, local.D, local.A,  6, 23, 0x04881D05 );
40027078:	017c9c93          	slli	s9,s9,0x17
4002707c:	0199e9b3          	or	s3,s3,s9
    P( local.A, local.B, local.C, local.D,  9,  4, 0xD9D4D039 );
40027080:	039d0d13          	addi	s10,s10,57 # d9d4d039 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xd9d4d03a>
    P( local.B, local.C, local.D, local.A,  6, 23, 0x04881D05 );
40027084:	014989b3          	add	s3,s3,s4
    P( local.A, local.B, local.C, local.D,  9,  4, 0xD9D4D039 );
40027088:	014accb3          	xor	s9,s5,s4
4002708c:	01a78d33          	add	s10,a5,s10
40027090:	009d04b3          	add	s1,s10,s1
40027094:	013cccb3          	xor	s9,s9,s3
40027098:	009c8cb3          	add	s9,s9,s1
4002709c:	004c9493          	slli	s1,s9,0x4
    P( local.D, local.A, local.B, local.C, 12, 11, 0xE6DB99E5 );
400270a0:	e6dbad37          	lui	s10,0xe6dba
    P( local.A, local.B, local.C, local.D,  9,  4, 0xD9D4D039 );
400270a4:	01ccdc93          	srli	s9,s9,0x1c
400270a8:	0194e4b3          	or	s1,s1,s9
    P( local.D, local.A, local.B, local.C, 12, 11, 0xE6DB99E5 );
400270ac:	9e5d0d13          	addi	s10,s10,-1563 # e6db99e5 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xe6db99e6>
    P( local.A, local.B, local.C, local.D,  9,  4, 0xD9D4D039 );
400270b0:	013484b3          	add	s1,s1,s3
    P( local.D, local.A, local.B, local.C, 12, 11, 0xE6DB99E5 );
400270b4:	013a4cb3          	xor	s9,s4,s3
400270b8:	01af8d33          	add	s10,t6,s10
400270bc:	015d0ab3          	add	s5,s10,s5
400270c0:	009cccb3          	xor	s9,s9,s1
400270c4:	015c8cb3          	add	s9,s9,s5
400270c8:	00bc9a93          	slli	s5,s9,0xb
    P( local.C, local.D, local.A, local.B, 15, 16, 0x1FA27CF8 );
400270cc:	1fa28d37          	lui	s10,0x1fa28
    P( local.D, local.A, local.B, local.C, 12, 11, 0xE6DB99E5 );
400270d0:	015cdc93          	srli	s9,s9,0x15
400270d4:	019aeab3          	or	s5,s5,s9
    P( local.C, local.D, local.A, local.B, 15, 16, 0x1FA27CF8 );
400270d8:	cf8d0d13          	addi	s10,s10,-776 # 1fa27cf8 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x19ac9bf8>
    P( local.D, local.A, local.B, local.C, 12, 11, 0xE6DB99E5 );
400270dc:	009a8ab3          	add	s5,s5,s1
    P( local.C, local.D, local.A, local.B, 15, 16, 0x1FA27CF8 );
400270e0:	0099ccb3          	xor	s9,s3,s1
400270e4:	01a58d33          	add	s10,a1,s10
400270e8:	014d0a33          	add	s4,s10,s4
400270ec:	015cccb3          	xor	s9,s9,s5
400270f0:	014c8cb3          	add	s9,s9,s4
400270f4:	010c9a13          	slli	s4,s9,0x10
    P( local.B, local.C, local.D, local.A,  2, 23, 0xC4AC5665 );
400270f8:	c4ac5d37          	lui	s10,0xc4ac5
    P( local.C, local.D, local.A, local.B, 15, 16, 0x1FA27CF8 );
400270fc:	010cdc93          	srli	s9,s9,0x10
40027100:	019a6a33          	or	s4,s4,s9
    P( local.B, local.C, local.D, local.A,  2, 23, 0xC4AC5665 );
40027104:	665d0d13          	addi	s10,s10,1637 # c4ac5665 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xc4ac5666>
    P( local.C, local.D, local.A, local.B, 15, 16, 0x1FA27CF8 );
40027108:	015a0a33          	add	s4,s4,s5
    P( local.B, local.C, local.D, local.A,  2, 23, 0xC4AC5665 );
4002710c:	0154ccb3          	xor	s9,s1,s5
40027110:	01a70d33          	add	s10,a4,s10
40027114:	013d09b3          	add	s3,s10,s3
40027118:	014cccb3          	xor	s9,s9,s4
4002711c:	013c8cb3          	add	s9,s9,s3
40027120:	009cd993          	srli	s3,s9,0x9
40027124:	017c9c93          	slli	s9,s9,0x17
40027128:	0199e9b3          	or	s3,s3,s9

#undef F

#define F(x,y,z) ((y) ^ ((x) | ~(z)))

    P( local.A, local.B, local.C, local.D,  0,  6, 0xF4292244 );
4002712c:	f4292d37          	lui	s10,0xf4292
    P( local.B, local.C, local.D, local.A,  2, 23, 0xC4AC5665 );
40027130:	014989b3          	add	s3,s3,s4
    P( local.A, local.B, local.C, local.D,  0,  6, 0xF4292244 );
40027134:	fffacc93          	not	s9,s5
40027138:	244d0d13          	addi	s10,s10,580 # f4292244 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf4292245>
4002713c:	013cecb3          	or	s9,s9,s3
40027140:	01a40433          	add	s0,s0,s10
40027144:	014cccb3          	xor	s9,s9,s4
40027148:	00940433          	add	s0,s0,s1
4002714c:	008c8433          	add	s0,s9,s0
40027150:	00641493          	slli	s1,s0,0x6
40027154:	01a45413          	srli	s0,s0,0x1a
40027158:	0084e4b3          	or	s1,s1,s0
    P( local.D, local.A, local.B, local.C,  7, 10, 0x432AFF97 );
4002715c:	432b0cb7          	lui	s9,0x432b0
    P( local.A, local.B, local.C, local.D,  0,  6, 0xF4292244 );
40027160:	013484b3          	add	s1,s1,s3
    P( local.D, local.A, local.B, local.C,  7, 10, 0x432AFF97 );
40027164:	fffa4413          	not	s0,s4
40027168:	f97c8c93          	addi	s9,s9,-105 # 432aff97 <__data_region_end+0x3273323>
4002716c:	00946433          	or	s0,s0,s1
40027170:	019080b3          	add	ra,ra,s9
40027174:	01344433          	xor	s0,s0,s3
40027178:	015080b3          	add	ra,ra,s5
4002717c:	001400b3          	add	ra,s0,ra
40027180:	00a09413          	slli	s0,ra,0xa
40027184:	0160d093          	srli	ra,ra,0x16
40027188:	00146433          	or	s0,s0,ra
    P( local.C, local.D, local.A, local.B, 14, 15, 0xAB9423A7 );
4002718c:	ab942ab7          	lui	s5,0xab942
    P( local.D, local.A, local.B, local.C,  7, 10, 0x432AFF97 );
40027190:	00940433          	add	s0,s0,s1
    P( local.C, local.D, local.A, local.B, 14, 15, 0xAB9423A7 );
40027194:	fff9c093          	not	ra,s3
40027198:	3a7a8a93          	addi	s5,s5,935 # ab9423a7 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xab9423a8>
4002719c:	0080e0b3          	or	ra,ra,s0
400271a0:	015383b3          	add	t2,t2,s5
400271a4:	0090c0b3          	xor	ra,ra,s1
400271a8:	014383b3          	add	t2,t2,s4
400271ac:	007083b3          	add	t2,ra,t2
400271b0:	00f39093          	slli	ra,t2,0xf
400271b4:	0113d393          	srli	t2,t2,0x11
400271b8:	0070e0b3          	or	ra,ra,t2
    P( local.B, local.C, local.D, local.A,  5, 21, 0xFC93A039 );
400271bc:	fc93aa37          	lui	s4,0xfc93a
    P( local.C, local.D, local.A, local.B, 14, 15, 0xAB9423A7 );
400271c0:	008080b3          	add	ra,ra,s0
    P( local.B, local.C, local.D, local.A,  5, 21, 0xFC93A039 );
400271c4:	fff4c393          	not	t2,s1
400271c8:	039a0a13          	addi	s4,s4,57 # fc93a039 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfc93a03a>
400271cc:	0013e3b3          	or	t2,t2,ra
400271d0:	014282b3          	add	t0,t0,s4
400271d4:	0083c3b3          	xor	t2,t2,s0
400271d8:	013282b3          	add	t0,t0,s3
400271dc:	005382b3          	add	t0,t2,t0
400271e0:	00b2d393          	srli	t2,t0,0xb
400271e4:	01529293          	slli	t0,t0,0x15
400271e8:	0053e3b3          	or	t2,t2,t0
    P( local.A, local.B, local.C, local.D, 12,  6, 0x655B59C3 );
400271ec:	655b69b7          	lui	s3,0x655b6
    P( local.B, local.C, local.D, local.A,  5, 21, 0xFC93A039 );
400271f0:	001383b3          	add	t2,t2,ra
    P( local.A, local.B, local.C, local.D, 12,  6, 0x655B59C3 );
400271f4:	fff44293          	not	t0,s0
400271f8:	9c398993          	addi	s3,s3,-1597 # 655b59c3 <__data_region_end+0x25578d4f>
400271fc:	0072e2b3          	or	t0,t0,t2
40027200:	013f8fb3          	add	t6,t6,s3
40027204:	0012c2b3          	xor	t0,t0,ra
40027208:	009f8fb3          	add	t6,t6,s1
4002720c:	01f28fb3          	add	t6,t0,t6
40027210:	006f9293          	slli	t0,t6,0x6
40027214:	01afdf93          	srli	t6,t6,0x1a
40027218:	01f2e2b3          	or	t0,t0,t6
    P( local.D, local.A, local.B, local.C,  3, 10, 0x8F0CCC92 );
4002721c:	8f0cd4b7          	lui	s1,0x8f0cd
    P( local.A, local.B, local.C, local.D, 12,  6, 0x655B59C3 );
40027220:	007282b3          	add	t0,t0,t2
    P( local.D, local.A, local.B, local.C,  3, 10, 0x8F0CCC92 );
40027224:	fff0cf93          	not	t6,ra
40027228:	c9248493          	addi	s1,s1,-878 # 8f0ccc92 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8f0ccc93>
4002722c:	005fefb3          	or	t6,t6,t0
40027230:	009f0f33          	add	t5,t5,s1
40027234:	007fcfb3          	xor	t6,t6,t2
40027238:	008f0f33          	add	t5,t5,s0
4002723c:	01ef8f33          	add	t5,t6,t5
40027240:	00af1f93          	slli	t6,t5,0xa
40027244:	016f5f13          	srli	t5,t5,0x16
40027248:	01efefb3          	or	t6,t6,t5
    P( local.C, local.D, local.A, local.B, 10, 15, 0xFFEFF47D );
4002724c:	ffeff437          	lui	s0,0xffeff
    P( local.D, local.A, local.B, local.C,  3, 10, 0x8F0CCC92 );
40027250:	005f8fb3          	add	t6,t6,t0
    P( local.C, local.D, local.A, local.B, 10, 15, 0xFFEFF47D );
40027254:	fff3cf13          	not	t5,t2
40027258:	47d40413          	addi	s0,s0,1149 # ffeff47d <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffeff47e>
4002725c:	01ff6f33          	or	t5,t5,t6
40027260:	008e8eb3          	add	t4,t4,s0
40027264:	005f4f33          	xor	t5,t5,t0
40027268:	001e8eb3          	add	t4,t4,ra
4002726c:	01df0eb3          	add	t4,t5,t4
40027270:	00fe9f13          	slli	t5,t4,0xf
40027274:	011ede93          	srli	t4,t4,0x11
40027278:	01df6f33          	or	t5,t5,t4
    P( local.B, local.C, local.D, local.A,  1, 21, 0x85845DD1 );
4002727c:	858460b7          	lui	ra,0x85846
    P( local.C, local.D, local.A, local.B, 10, 15, 0xFFEFF47D );
40027280:	01ff0f33          	add	t5,t5,t6
    P( local.B, local.C, local.D, local.A,  1, 21, 0x85845DD1 );
40027284:	dd108093          	addi	ra,ra,-559 # 85845dd1 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x85845dd2>
40027288:	fff2ce93          	not	t4,t0
4002728c:	001e0e33          	add	t3,t3,ra
40027290:	01eeeeb3          	or	t4,t4,t5
40027294:	01feceb3          	xor	t4,t4,t6
40027298:	007e0e33          	add	t3,t3,t2
4002729c:	01ce8e33          	add	t3,t4,t3
400272a0:	00be5e93          	srli	t4,t3,0xb
400272a4:	015e1e13          	slli	t3,t3,0x15
400272a8:	01ceeeb3          	or	t4,t4,t3
    P( local.A, local.B, local.C, local.D,  8,  6, 0x6FA87E4F );
400272ac:	6fa883b7          	lui	t2,0x6fa88
    P( local.B, local.C, local.D, local.A,  1, 21, 0x85845DD1 );
400272b0:	01ee8eb3          	add	t4,t4,t5
    P( local.A, local.B, local.C, local.D,  8,  6, 0x6FA87E4F );
400272b4:	ffffce13          	not	t3,t6
400272b8:	e4f38393          	addi	t2,t2,-433 # 6fa87e4f <__data_region_end+0x2fa4b1db>
400272bc:	01de6e33          	or	t3,t3,t4
400272c0:	00730333          	add	t1,t1,t2
400272c4:	01ee4e33          	xor	t3,t3,t5
400272c8:	00530333          	add	t1,t1,t0
400272cc:	006e0333          	add	t1,t3,t1
400272d0:	00631e13          	slli	t3,t1,0x6
400272d4:	01a35313          	srli	t1,t1,0x1a
400272d8:	006e6e33          	or	t3,t3,t1
    P( local.D, local.A, local.B, local.C, 15, 10, 0xFE2CE6E0 );
400272dc:	fe2ce2b7          	lui	t0,0xfe2ce
    P( local.A, local.B, local.C, local.D,  8,  6, 0x6FA87E4F );
400272e0:	01de0e33          	add	t3,t3,t4
    P( local.D, local.A, local.B, local.C, 15, 10, 0xFE2CE6E0 );
400272e4:	ffff4313          	not	t1,t5
400272e8:	6e028293          	addi	t0,t0,1760 # fe2ce6e0 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xfe2ce6e1>
    local.X[15] = MBEDTLS_GET_UINT32_LE( data, 60 );
400272ec:	02b12e23          	sw	a1,60(sp)
    P( local.D, local.A, local.B, local.C, 15, 10, 0xFE2CE6E0 );
400272f0:	01c36333          	or	t1,t1,t3
400272f4:	005585b3          	add	a1,a1,t0
400272f8:	01d34333          	xor	t1,t1,t4
400272fc:	01f585b3          	add	a1,a1,t6
40027300:	00b305b3          	add	a1,t1,a1
40027304:	00a59313          	slli	t1,a1,0xa
40027308:	0165d593          	srli	a1,a1,0x16
4002730c:	00b36333          	or	t1,t1,a1
    P( local.C, local.D, local.A, local.B,  6, 15, 0xA3014314 );
40027310:	a3014fb7          	lui	t6,0xa3014
    P( local.D, local.A, local.B, local.C, 15, 10, 0xFE2CE6E0 );
40027314:	01c30333          	add	t1,t1,t3
    P( local.C, local.D, local.A, local.B,  6, 15, 0xA3014314 );
40027318:	fffec593          	not	a1,t4
4002731c:	314f8f93          	addi	t6,t6,788 # a3014314 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xa3014315>
40027320:	0065e5b3          	or	a1,a1,t1
40027324:	01f888b3          	add	a7,a7,t6
40027328:	01e888b3          	add	a7,a7,t5
4002732c:	01c5c5b3          	xor	a1,a1,t3
40027330:	011585b3          	add	a1,a1,a7
40027334:	00f59893          	slli	a7,a1,0xf
40027338:	0115d593          	srli	a1,a1,0x11
4002733c:	00b8e8b3          	or	a7,a7,a1
    P( local.B, local.C, local.D, local.A, 13, 21, 0x4E0811A1 );
40027340:	4e081f37          	lui	t5,0x4e081
    P( local.C, local.D, local.A, local.B,  6, 15, 0xA3014314 );
40027344:	006888b3          	add	a7,a7,t1
    P( local.B, local.C, local.D, local.A, 13, 21, 0x4E0811A1 );
40027348:	fffe4593          	not	a1,t3
4002734c:	1a1f0f13          	addi	t5,t5,417 # 4e0811a1 <__data_region_end+0xe04452d>
40027350:	0115e5b3          	or	a1,a1,a7
40027354:	01e80833          	add	a6,a6,t5
40027358:	01d80833          	add	a6,a6,t4
4002735c:	0065c5b3          	xor	a1,a1,t1
40027360:	010585b3          	add	a1,a1,a6
40027364:	00b5d813          	srli	a6,a1,0xb
40027368:	01559593          	slli	a1,a1,0x15
4002736c:	00b86833          	or	a6,a6,a1
    P( local.A, local.B, local.C, local.D,  4,  6, 0xF7537E82 );
40027370:	f7538eb7          	lui	t4,0xf7538
    P( local.B, local.C, local.D, local.A, 13, 21, 0x4E0811A1 );
40027374:	01180833          	add	a6,a6,a7
    P( local.A, local.B, local.C, local.D,  4,  6, 0xF7537E82 );
40027378:	fff34593          	not	a1,t1
4002737c:	e82e8e93          	addi	t4,t4,-382 # f7537e82 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf7537e83>
40027380:	0105e5b3          	or	a1,a1,a6
40027384:	01d60633          	add	a2,a2,t4
40027388:	01c60633          	add	a2,a2,t3
4002738c:	0115c5b3          	xor	a1,a1,a7
40027390:	00c585b3          	add	a1,a1,a2
40027394:	00659613          	slli	a2,a1,0x6
40027398:	01a5d593          	srli	a1,a1,0x1a
4002739c:	00b66633          	or	a2,a2,a1
    P( local.D, local.A, local.B, local.C, 11, 10, 0xBD3AF235 );
400273a0:	bd3afe37          	lui	t3,0xbd3af
    P( local.A, local.B, local.C, local.D,  4,  6, 0xF7537E82 );
400273a4:	01060633          	add	a2,a2,a6
    P( local.D, local.A, local.B, local.C, 11, 10, 0xBD3AF235 );
400273a8:	fff8c593          	not	a1,a7
400273ac:	235e0e13          	addi	t3,t3,565 # bd3af235 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xbd3af236>
400273b0:	00c5e5b3          	or	a1,a1,a2
400273b4:	01c686b3          	add	a3,a3,t3
400273b8:	0105c5b3          	xor	a1,a1,a6
400273bc:	006686b3          	add	a3,a3,t1
400273c0:	00d586b3          	add	a3,a1,a3
400273c4:	00a69593          	slli	a1,a3,0xa
400273c8:	0166d693          	srli	a3,a3,0x16
400273cc:	00d5e5b3          	or	a1,a1,a3
    P( local.C, local.D, local.A, local.B,  2, 15, 0x2AD7D2BB );
400273d0:	2ad7d337          	lui	t1,0x2ad7d
    P( local.D, local.A, local.B, local.C, 11, 10, 0xBD3AF235 );
400273d4:	00c585b3          	add	a1,a1,a2
    P( local.C, local.D, local.A, local.B,  2, 15, 0x2AD7D2BB );
400273d8:	fff84693          	not	a3,a6
400273dc:	2bb30313          	addi	t1,t1,699 # 2ad7d2bb <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x24e1f1bb>
400273e0:	00b6e6b3          	or	a3,a3,a1
400273e4:	00670733          	add	a4,a4,t1
400273e8:	00c6c6b3          	xor	a3,a3,a2
400273ec:	01170733          	add	a4,a4,a7
400273f0:	00e68733          	add	a4,a3,a4
400273f4:	00f71693          	slli	a3,a4,0xf
400273f8:	01175713          	srli	a4,a4,0x11
400273fc:	00e6e6b3          	or	a3,a3,a4
    P( local.B, local.C, local.D, local.A,  9, 21, 0xEB86D391 );
40027400:	eb86d8b7          	lui	a7,0xeb86d
    P( local.C, local.D, local.A, local.B,  2, 15, 0x2AD7D2BB );
40027404:	00b686b3          	add	a3,a3,a1
    P( local.B, local.C, local.D, local.A,  9, 21, 0xEB86D391 );
40027408:	fff64713          	not	a4,a2
4002740c:	39188893          	addi	a7,a7,913 # eb86d391 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xeb86d392>
40027410:	00d76733          	or	a4,a4,a3
40027414:	011787b3          	add	a5,a5,a7
40027418:	00b74733          	xor	a4,a4,a1
4002741c:	010787b3          	add	a5,a5,a6
40027420:	00f707b3          	add	a5,a4,a5
40027424:	00b7d713          	srli	a4,a5,0xb
40027428:	01579793          	slli	a5,a5,0x15
4002742c:	00f767b3          	or	a5,a4,a5
40027430:	00d787b3          	add	a5,a5,a3

#undef F

    ctx->state[0] += local.A;
40027434:	00cc0c33          	add	s8,s8,a2
    ctx->state[1] += local.B;
40027438:	00f90933          	add	s2,s2,a5
    ctx->state[2] += local.C;
4002743c:	00db0b33          	add	s6,s6,a3
    ctx->state[3] += local.D;
40027440:	00bb8bb3          	add	s7,s7,a1
    P( local.A, local.B, local.C, local.D,  4,  6, 0xF7537E82 );
40027444:	04c12023          	sw	a2,64(sp)
    P( local.D, local.A, local.B, local.C, 11, 10, 0xBD3AF235 );
40027448:	04b12623          	sw	a1,76(sp)
    ctx->state[0] += local.A;
4002744c:	01852423          	sw	s8,8(a0)
    ctx->state[1] += local.B;
40027450:	01252623          	sw	s2,12(a0)
    ctx->state[2] += local.C;
40027454:	01652823          	sw	s6,16(a0)
    ctx->state[3] += local.D;
40027458:	01752a23          	sw	s7,20(a0)

    /* Zeroise variables to clear sensitive data from memory. */
    mbedtls_platform_zeroize( &local, sizeof( local ) );
4002745c:	05000593          	li	a1,80
40027460:	00010513          	mv	a0,sp
    P( local.C, local.D, local.A, local.B,  2, 15, 0x2AD7D2BB );
40027464:	04d12423          	sw	a3,72(sp)
    P( local.B, local.C, local.D, local.A,  9, 21, 0xEB86D391 );
40027468:	04f12223          	sw	a5,68(sp)
    mbedtls_platform_zeroize( &local, sizeof( local ) );
4002746c:	34c000ef          	jal	ra,400277b8 <mbedtls_platform_zeroize>

    return( 0 );
}
40027470:	08c12083          	lw	ra,140(sp)
40027474:	08812403          	lw	s0,136(sp)
40027478:	08412483          	lw	s1,132(sp)
4002747c:	08012903          	lw	s2,128(sp)
40027480:	07c12983          	lw	s3,124(sp)
40027484:	07812a03          	lw	s4,120(sp)
40027488:	07412a83          	lw	s5,116(sp)
4002748c:	07012b03          	lw	s6,112(sp)
40027490:	06c12b83          	lw	s7,108(sp)
40027494:	06812c03          	lw	s8,104(sp)
40027498:	06412c83          	lw	s9,100(sp)
4002749c:	06012d03          	lw	s10,96(sp)
400274a0:	05c12d83          	lw	s11,92(sp)
400274a4:	00000513          	li	a0,0
400274a8:	09010113          	addi	sp,sp,144
400274ac:	00008067          	ret

400274b0 <mbedtls_md5_update>:
{
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t fill;
    uint32_t left;

    if( ilen == 0 )
400274b0:	0e060e63          	beqz	a2,400275ac <mbedtls_md5_update+0xfc>
{
400274b4:	fd010113          	addi	sp,sp,-48
400274b8:	02812423          	sw	s0,40(sp)
400274bc:	02912223          	sw	s1,36(sp)
400274c0:	03212023          	sw	s2,32(sp)
400274c4:	01312e23          	sw	s3,28(sp)
400274c8:	02112623          	sw	ra,44(sp)
400274cc:	01412c23          	sw	s4,24(sp)
400274d0:	01512a23          	sw	s5,20(sp)
        return( 0 );

    left = ctx->total[0] & 0x3F;
400274d4:	00052783          	lw	a5,0(a0)
400274d8:	00050493          	mv	s1,a0
400274dc:	00058913          	mv	s2,a1
400274e0:	00c78733          	add	a4,a5,a2
    fill = 64 - left;

    ctx->total[0] += (uint32_t) ilen;
400274e4:	00e52023          	sw	a4,0(a0)
400274e8:	00060413          	mv	s0,a2
    left = ctx->total[0] & 0x3F;
400274ec:	03f7f993          	andi	s3,a5,63
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < (uint32_t) ilen )
400274f0:	00f77863          	bgeu	a4,a5,40027500 <mbedtls_md5_update+0x50>
        ctx->total[1]++;
400274f4:	00452783          	lw	a5,4(a0)
400274f8:	00178793          	addi	a5,a5,1
400274fc:	00f52223          	sw	a5,4(a0)

    if( left && ilen >= fill )
40027500:	04098263          	beqz	s3,40027544 <mbedtls_md5_update+0x94>
    fill = 64 - left;
40027504:	04000a13          	li	s4,64
40027508:	413a0a33          	sub	s4,s4,s3
    if( left && ilen >= fill )
4002750c:	03446c63          	bltu	s0,s4,40027544 <mbedtls_md5_update+0x94>
    {
        memcpy( (void *) (ctx->buffer + left), input, fill );
40027510:	01848a93          	addi	s5,s1,24
40027514:	00090593          	mv	a1,s2
40027518:	000a0613          	mv	a2,s4
4002751c:	013a8533          	add	a0,s5,s3
40027520:	b2de10ef          	jal	ra,4000904c <memcpy>
        if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )
40027524:	000a8593          	mv	a1,s5
40027528:	00048513          	mv	a0,s1
4002752c:	844ff0ef          	jal	ra,40026570 <mbedtls_internal_md5_process>
40027530:	04051c63          	bnez	a0,40027588 <mbedtls_md5_update+0xd8>
            return( ret );

        input += fill;
40027534:	01340633          	add	a2,s0,s3
40027538:	01490933          	add	s2,s2,s4
        ilen  -= fill;
4002753c:	fc060413          	addi	s0,a2,-64
        left = 0;
40027540:	00000993          	li	s3,0
40027544:	00040613          	mv	a2,s0
40027548:	00890933          	add	s2,s2,s0
    }

    while( ilen >= 64 )
4002754c:	03f00413          	li	s0,63
40027550:	01c0006f          	j	4002756c <mbedtls_md5_update+0xbc>
    {
        if( ( ret = mbedtls_internal_md5_process( ctx, input ) ) != 0 )
40027554:	00048513          	mv	a0,s1
40027558:	00c12623          	sw	a2,12(sp)
4002755c:	814ff0ef          	jal	ra,40026570 <mbedtls_internal_md5_process>
40027560:	02051463          	bnez	a0,40027588 <mbedtls_md5_update+0xd8>
            return( ret );

        input += 64;
        ilen  -= 64;
40027564:	00c12603          	lw	a2,12(sp)
40027568:	fc060613          	addi	a2,a2,-64
4002756c:	40c905b3          	sub	a1,s2,a2
    while( ilen >= 64 )
40027570:	fec462e3          	bltu	s0,a2,40027554 <mbedtls_md5_update+0xa4>
    }

    if( ilen > 0 )
40027574:	00060863          	beqz	a2,40027584 <mbedtls_md5_update+0xd4>
    {
        memcpy( (void *) (ctx->buffer + left), input, ilen );
40027578:	01848513          	addi	a0,s1,24
4002757c:	01350533          	add	a0,a0,s3
40027580:	acde10ef          	jal	ra,4000904c <memcpy>
        return( 0 );
40027584:	00000513          	li	a0,0
    }

    return( 0 );
}
40027588:	02c12083          	lw	ra,44(sp)
4002758c:	02812403          	lw	s0,40(sp)
40027590:	02412483          	lw	s1,36(sp)
40027594:	02012903          	lw	s2,32(sp)
40027598:	01c12983          	lw	s3,28(sp)
4002759c:	01812a03          	lw	s4,24(sp)
400275a0:	01412a83          	lw	s5,20(sp)
400275a4:	03010113          	addi	sp,sp,48
400275a8:	00008067          	ret
        return( 0 );
400275ac:	00000513          	li	a0,0
}
400275b0:	00008067          	ret

400275b4 <mbedtls_md5_finish>:
/*
 * MD5 final digest
 */
int mbedtls_md5_finish( mbedtls_md5_context *ctx,
                            unsigned char output[16] )
{
400275b4:	ff010113          	addi	sp,sp,-16
400275b8:	00812423          	sw	s0,8(sp)
400275bc:	00912223          	sw	s1,4(sp)
400275c0:	01212023          	sw	s2,0(sp)
400275c4:	00112623          	sw	ra,12(sp)
    uint32_t high, low;

    /*
     * Add padding: 0x80 then 0x00 until 8 bytes remain for the length
     */
    used = ctx->total[0] & 0x3F;
400275c8:	00052783          	lw	a5,0(a0)

    ctx->buffer[used++] = 0x80;
400275cc:	f8000693          	li	a3,-128

    if( used <= 56 )
    {
        /* Enough room for padding + length in current block */
        memset( ctx->buffer + used, 0, 56 - used );
400275d0:	01850913          	addi	s2,a0,24
    used = ctx->total[0] & 0x3F;
400275d4:	03f7f793          	andi	a5,a5,63
    ctx->buffer[used++] = 0x80;
400275d8:	00178713          	addi	a4,a5,1
400275dc:	00f507b3          	add	a5,a0,a5
400275e0:	00d78c23          	sb	a3,24(a5)
    if( used <= 56 )
400275e4:	03800613          	li	a2,56
{
400275e8:	00050413          	mv	s0,a0
400275ec:	00058493          	mv	s1,a1
        memset( ctx->buffer + used, 0, 56 - used );
400275f0:	00e90533          	add	a0,s2,a4
    if( used <= 56 )
400275f4:	0ee66463          	bltu	a2,a4,400276dc <mbedtls_md5_finish+0x128>
        memset( ctx->buffer + used, 0, 56 - used );
400275f8:	40e60633          	sub	a2,a2,a4
400275fc:	00000593          	li	a1,0
        memset( ctx->buffer + used, 0, 64 - used );

        if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )
            return( ret );

        memset( ctx->buffer, 0, 56 );
40027600:	a71e10ef          	jal	ra,40009070 <memset>
    }

    /*
     * Add message length
     */
    high = ( ctx->total[0] >> 29 )
40027604:	00042703          	lw	a4,0(s0)
         | ( ctx->total[1] <<  3 );
40027608:	00442783          	lw	a5,4(s0)
    low  = ( ctx->total[0] <<  3 );

    MBEDTLS_PUT_UINT32_LE( low,  ctx->buffer, 56 );
    MBEDTLS_PUT_UINT32_LE( high, ctx->buffer, 60 );

    if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )
4002760c:	00090593          	mv	a1,s2
    high = ( ctx->total[0] >> 29 )
40027610:	01d75693          	srli	a3,a4,0x1d
         | ( ctx->total[1] <<  3 );
40027614:	00379793          	slli	a5,a5,0x3
    high = ( ctx->total[0] >> 29 )
40027618:	00d7e7b3          	or	a5,a5,a3
    low  = ( ctx->total[0] <<  3 );
4002761c:	00371713          	slli	a4,a4,0x3
    MBEDTLS_PUT_UINT32_LE( low,  ctx->buffer, 56 );
40027620:	04e42823          	sw	a4,80(s0)
    MBEDTLS_PUT_UINT32_LE( high, ctx->buffer, 60 );
40027624:	04f42a23          	sw	a5,84(s0)
    if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )
40027628:	00040513          	mv	a0,s0
4002762c:	f45fe0ef          	jal	ra,40026570 <mbedtls_internal_md5_process>
40027630:	08051a63          	bnez	a0,400276c4 <mbedtls_md5_finish+0x110>
        return( ret );

    /*
     * Output final state
     */
    MBEDTLS_PUT_UINT32_LE( ctx->state[0], output,  0 );
40027634:	00842783          	lw	a5,8(s0)
40027638:	00f48023          	sb	a5,0(s1)
4002763c:	00842783          	lw	a5,8(s0)
40027640:	0087d793          	srli	a5,a5,0x8
40027644:	00f480a3          	sb	a5,1(s1)
40027648:	00a45783          	lhu	a5,10(s0)
4002764c:	00f48123          	sb	a5,2(s1)
40027650:	00b44783          	lbu	a5,11(s0)
40027654:	00f481a3          	sb	a5,3(s1)
    MBEDTLS_PUT_UINT32_LE( ctx->state[1], output,  4 );
40027658:	00c42783          	lw	a5,12(s0)
4002765c:	00f48223          	sb	a5,4(s1)
40027660:	00c42783          	lw	a5,12(s0)
40027664:	0087d793          	srli	a5,a5,0x8
40027668:	00f482a3          	sb	a5,5(s1)
4002766c:	00e45783          	lhu	a5,14(s0)
40027670:	00f48323          	sb	a5,6(s1)
40027674:	00f44783          	lbu	a5,15(s0)
40027678:	00f483a3          	sb	a5,7(s1)
    MBEDTLS_PUT_UINT32_LE( ctx->state[2], output,  8 );
4002767c:	01042783          	lw	a5,16(s0)
40027680:	00f48423          	sb	a5,8(s1)
40027684:	01042783          	lw	a5,16(s0)
40027688:	0087d793          	srli	a5,a5,0x8
4002768c:	00f484a3          	sb	a5,9(s1)
40027690:	01245783          	lhu	a5,18(s0)
40027694:	00f48523          	sb	a5,10(s1)
40027698:	01344783          	lbu	a5,19(s0)
4002769c:	00f485a3          	sb	a5,11(s1)
    MBEDTLS_PUT_UINT32_LE( ctx->state[3], output, 12 );
400276a0:	01442783          	lw	a5,20(s0)
400276a4:	00f48623          	sb	a5,12(s1)
400276a8:	01442783          	lw	a5,20(s0)
400276ac:	0087d793          	srli	a5,a5,0x8
400276b0:	00f486a3          	sb	a5,13(s1)
400276b4:	01645783          	lhu	a5,22(s0)
400276b8:	00f48723          	sb	a5,14(s1)
400276bc:	01744783          	lbu	a5,23(s0)
400276c0:	00f487a3          	sb	a5,15(s1)

    return( 0 );
}
400276c4:	00c12083          	lw	ra,12(sp)
400276c8:	00812403          	lw	s0,8(sp)
400276cc:	00412483          	lw	s1,4(sp)
400276d0:	00012903          	lw	s2,0(sp)
400276d4:	01010113          	addi	sp,sp,16
400276d8:	00008067          	ret
        memset( ctx->buffer + used, 0, 64 - used );
400276dc:	04000613          	li	a2,64
400276e0:	00000593          	li	a1,0
400276e4:	40e60633          	sub	a2,a2,a4
400276e8:	989e10ef          	jal	ra,40009070 <memset>
        if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )
400276ec:	00090593          	mv	a1,s2
400276f0:	00040513          	mv	a0,s0
400276f4:	e7dfe0ef          	jal	ra,40026570 <mbedtls_internal_md5_process>
400276f8:	fc0516e3          	bnez	a0,400276c4 <mbedtls_md5_finish+0x110>
        memset( ctx->buffer, 0, 56 );
400276fc:	03800613          	li	a2,56
40027700:	00000593          	li	a1,0
40027704:	00090513          	mv	a0,s2
40027708:	ef9ff06f          	j	40027600 <mbedtls_md5_finish+0x4c>

4002770c <mbedtls_md5>:
 * output = MD5( input buffer )
 */
int mbedtls_md5( const unsigned char *input,
                     size_t ilen,
                     unsigned char output[16] )
{
4002770c:	f9010113          	addi	sp,sp,-112
40027710:	06812423          	sw	s0,104(sp)
40027714:	00050413          	mv	s0,a0
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    mbedtls_md5_context ctx;

    mbedtls_md5_init( &ctx );
40027718:	00810513          	addi	a0,sp,8
{
4002771c:	06912223          	sw	s1,100(sp)
40027720:	07212023          	sw	s2,96(sp)
40027724:	06112623          	sw	ra,108(sp)
40027728:	00058913          	mv	s2,a1
4002772c:	00060493          	mv	s1,a2
    mbedtls_md5_init( &ctx );
40027730:	e35fe0ef          	jal	ra,40026564 <mbedtls_md5_init>
    ctx->state[0] = 0x67452301;
40027734:	674527b7          	lui	a5,0x67452
40027738:	30178793          	addi	a5,a5,769 # 67452301 <__data_region_end+0x2741568d>
4002773c:	00f12823          	sw	a5,16(sp)
    ctx->state[1] = 0xEFCDAB89;
40027740:	efcdb7b7          	lui	a5,0xefcdb
40027744:	b8978793          	addi	a5,a5,-1143 # efcdab89 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xefcdab8a>
40027748:	00f12a23          	sw	a5,20(sp)
    ctx->state[2] = 0x98BADCFE;
4002774c:	98bae7b7          	lui	a5,0x98bae
40027750:	cfe78793          	addi	a5,a5,-770 # 98badcfe <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x98badcff>
40027754:	00f12c23          	sw	a5,24(sp)
    ctx->state[3] = 0x10325476;
40027758:	103257b7          	lui	a5,0x10325
4002775c:	47678793          	addi	a5,a5,1142 # 10325476 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa3c7376>

    if( ( ret = mbedtls_md5_starts( &ctx ) ) != 0 )
        goto exit;

    if( ( ret = mbedtls_md5_update( &ctx, input, ilen ) ) != 0 )
40027760:	00090613          	mv	a2,s2
40027764:	00040593          	mv	a1,s0
40027768:	00810513          	addi	a0,sp,8
    ctx->total[0] = 0;
4002776c:	00012423          	sw	zero,8(sp)
    ctx->total[1] = 0;
40027770:	00012623          	sw	zero,12(sp)
    ctx->state[3] = 0x10325476;
40027774:	00f12e23          	sw	a5,28(sp)
    if( ( ret = mbedtls_md5_update( &ctx, input, ilen ) ) != 0 )
40027778:	d39ff0ef          	jal	ra,400274b0 <mbedtls_md5_update>
4002777c:	00051863          	bnez	a0,4002778c <mbedtls_md5+0x80>
        goto exit;

    if( ( ret = mbedtls_md5_finish( &ctx, output ) ) != 0 )
40027780:	00048593          	mv	a1,s1
40027784:	00810513          	addi	a0,sp,8
40027788:	e2dff0ef          	jal	ra,400275b4 <mbedtls_md5_finish>
4002778c:	00050413          	mv	s0,a0
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md5_context ) );
40027790:	05800593          	li	a1,88
40027794:	00810513          	addi	a0,sp,8
40027798:	020000ef          	jal	ra,400277b8 <mbedtls_platform_zeroize>

exit:
    mbedtls_md5_free( &ctx );

    return( ret );
}
4002779c:	06c12083          	lw	ra,108(sp)
400277a0:	00040513          	mv	a0,s0
400277a4:	06812403          	lw	s0,104(sp)
400277a8:	06412483          	lw	s1,100(sp)
400277ac:	06012903          	lw	s2,96(sp)
400277b0:	07010113          	addi	sp,sp,112
400277b4:	00008067          	ret

400277b8 <mbedtls_platform_zeroize>:
 * platform and needs.
 */
void * (* const volatile memset_func)( void *, int, size_t ) = memset;

void mbedtls_platform_zeroize( void *buf, size_t len )
{
400277b8:	00058613          	mv	a2,a1
    MBEDTLS_INTERNAL_VALIDATE( len == 0 || buf != NULL );

    if( len > 0 )
400277bc:	00058a63          	beqz	a1,400277d0 <mbedtls_platform_zeroize+0x18>
        memset_func( buf, 0, len );
400277c0:	4003d7b7          	lui	a5,0x4003d
400277c4:	a147a783          	lw	a5,-1516(a5) # 4003ca14 <memset_func>
400277c8:	00000593          	li	a1,0
400277cc:	00078067          	jr	a5
}
400277d0:	00008067          	ret

400277d4 <device_visitor>:

static int device_visitor(const device_handle_t *handles,
			   size_t handle_count,
			   device_visitor_callback_t visitor_cb,
			   void *context)
{
400277d4:	fd010113          	addi	sp,sp,-48
	size_t numdev = __device_end - __device_start;
400277d8:	4002c7b7          	lui	a5,0x4002c
400277dc:	02812423          	sw	s0,40(sp)
400277e0:	4002c437          	lui	s0,0x4002c
400277e4:	85c78713          	addi	a4,a5,-1956 # 4002b85c <__device_dts_ord_18>
400277e8:	8d440413          	addi	s0,s0,-1836 # 4002b8d4 <_sw_isr_table>
400277ec:	40e40433          	sub	s0,s0,a4
400277f0:	aaaab737          	lui	a4,0xaaaab
400277f4:	40345413          	srai	s0,s0,0x3
400277f8:	aab70713          	addi	a4,a4,-1365 # aaaaaaab <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xaaaaaaac>
400277fc:	02e40433          	mul	s0,s0,a4
40027800:	02912223          	sw	s1,36(sp)
40027804:	03212023          	sw	s2,32(sp)
40027808:	01312e23          	sw	s3,28(sp)
4002780c:	01412c23          	sw	s4,24(sp)
40027810:	01512a23          	sw	s5,20(sp)
40027814:	01612823          	sw	s6,16(sp)
40027818:	01712623          	sw	s7,12(sp)
4002781c:	02112623          	sw	ra,44(sp)
40027820:	00050a93          	mv	s5,a0
40027824:	00058a13          	mv	s4,a1
40027828:	00060b13          	mv	s6,a2
4002782c:	00068913          	mv	s2,a3
	/* Iterate over fixed devices */
	for (size_t i = 0; i < handle_count; ++i) {
40027830:	00000493          	li	s1,0
40027834:	85c78993          	addi	s3,a5,-1956
		dev = &__device_start[dev_handle - 1];
40027838:	01800b93          	li	s7,24
4002783c:	03449a63          	bne	s1,s4,40027870 <device_visitor+0x9c>
		if (rc < 0) {
			return rc;
		}
	}

	return handle_count;
40027840:	00048513          	mv	a0,s1
}
40027844:	02c12083          	lw	ra,44(sp)
40027848:	02812403          	lw	s0,40(sp)
4002784c:	02412483          	lw	s1,36(sp)
40027850:	02012903          	lw	s2,32(sp)
40027854:	01c12983          	lw	s3,28(sp)
40027858:	01812a03          	lw	s4,24(sp)
4002785c:	01412a83          	lw	s5,20(sp)
40027860:	01012b03          	lw	s6,16(sp)
40027864:	00c12b83          	lw	s7,12(sp)
40027868:	03010113          	addi	sp,sp,48
4002786c:	00008067          	ret
		device_handle_t dh = handles[i];
40027870:	00149793          	slli	a5,s1,0x1
40027874:	00fa87b3          	add	a5,s5,a5
40027878:	00079783          	lh	a5,0(a5)
	const struct device *dev = NULL;
4002787c:	00000513          	li	a0,0
	if ((dev_handle > 0) && ((size_t)dev_handle <= numdev)) {
40027880:	00f05e63          	blez	a5,4002789c <device_visitor+0xc8>
40027884:	00f46c63          	bltu	s0,a5,4002789c <device_visitor+0xc8>
		dev = &__device_start[dev_handle - 1];
40027888:	fff78793          	addi	a5,a5,-1
4002788c:	01079793          	slli	a5,a5,0x10
40027890:	4107d793          	srai	a5,a5,0x10
40027894:	037787b3          	mul	a5,a5,s7
40027898:	00f98533          	add	a0,s3,a5
		int rc = visitor_cb(rdev, context);
4002789c:	00090593          	mv	a1,s2
400278a0:	000b00e7          	jalr	s6
		if (rc < 0) {
400278a4:	fa0540e3          	bltz	a0,40027844 <device_visitor+0x70>
	for (size_t i = 0; i < handle_count; ++i) {
400278a8:	00148493          	addi	s1,s1,1
400278ac:	f91ff06f          	j	4002783c <device_visitor+0x68>

400278b0 <z_device_state_init>:
}
400278b0:	00008067          	ret

400278b4 <z_device_get_all_static>:
	*devices = __device_start;
400278b4:	4002c737          	lui	a4,0x4002c
	return __device_end - __device_start;
400278b8:	4002c7b7          	lui	a5,0x4002c
	*devices = __device_start;
400278bc:	85c70713          	addi	a4,a4,-1956 # 4002b85c <__device_dts_ord_18>
	return __device_end - __device_start;
400278c0:	8d478793          	addi	a5,a5,-1836 # 4002b8d4 <_sw_isr_table>
	*devices = __device_start;
400278c4:	00e52023          	sw	a4,0(a0)
	return __device_end - __device_start;
400278c8:	40e787b3          	sub	a5,a5,a4
}
400278cc:	aaaab537          	lui	a0,0xaaaab
	return __device_end - __device_start;
400278d0:	4037d793          	srai	a5,a5,0x3
}
400278d4:	aab50513          	addi	a0,a0,-1365 # aaaaaaab <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xaaaaaaac>
400278d8:	02a78533          	mul	a0,a5,a0
400278dc:	00008067          	ret

400278e0 <z_device_is_ready>:
	if (dev == NULL) {
400278e0:	02050263          	beqz	a0,40027904 <z_device_is_ready+0x24>
	return dev->state->initialized && (dev->state->init_res == 0U);
400278e4:	00c52703          	lw	a4,12(a0)
400278e8:	00000513          	li	a0,0
400278ec:	00174783          	lbu	a5,1(a4)
400278f0:	0017f793          	andi	a5,a5,1
400278f4:	00078a63          	beqz	a5,40027908 <z_device_is_ready+0x28>
400278f8:	00074503          	lbu	a0,0(a4)
400278fc:	00153513          	seqz	a0,a0
40027900:	00008067          	ret
		return false;
40027904:	00000513          	li	a0,0
}
40027908:	00008067          	ret

4002790c <device_required_foreach>:
int device_required_foreach(const struct device *dev,
			    device_visitor_callback_t visitor_cb,
			    void *context)
{
	size_t handle_count = 0;
	const device_handle_t *handles = device_required_handles_get(dev, &handle_count);
4002790c:	01452503          	lw	a0,20(a0)
{
40027910:	00058713          	mv	a4,a1
40027914:	00060693          	mv	a3,a2
		size_t i = 0;
40027918:	00000593          	li	a1,0
	if (rv != NULL) {
4002791c:	02050863          	beqz	a0,4002794c <device_required_foreach+0x40>
		while ((rv[i] != DEVICE_HANDLE_ENDS) &&
40027920:	00008837          	lui	a6,0x8
40027924:	00010637          	lui	a2,0x10
40027928:	fff80813          	addi	a6,a6,-1 # 7fff <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x3fff>
4002792c:	ffd60613          	addi	a2,a2,-3 # fffd <__kernel_ram_size+0x3d69>
40027930:	00159793          	slli	a5,a1,0x1
40027934:	00f507b3          	add	a5,a0,a5
40027938:	0007d783          	lhu	a5,0(a5)
4002793c:	010787b3          	add	a5,a5,a6
40027940:	01079793          	slli	a5,a5,0x10
40027944:	0107d793          	srli	a5,a5,0x10
40027948:	00f67663          	bgeu	a2,a5,40027954 <device_required_foreach+0x48>

	return device_visitor(handles, handle_count, visitor_cb, context);
4002794c:	00070613          	mv	a2,a4
40027950:	e85ff06f          	j	400277d4 <device_visitor>
			++i;
40027954:	00158593          	addi	a1,a1,1
40027958:	fd9ff06f          	j	40027930 <device_required_foreach+0x24>

4002795c <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
4002795c:	400337b7          	lui	a5,0x40033
40027960:	8707a503          	lw	a0,-1936(a5) # 40032870 <_kernel+0x8>
}
40027964:	0ac50513          	addi	a0,a0,172
40027968:	00008067          	ret

4002796c <arch_system_halt>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002796c:	300477f3          	csrrci	a5,mstatus,8
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
40027970:	0000006f          	j	40027970 <arch_system_halt+0x4>

40027974 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
40027974:	ff010113          	addi	sp,sp,-16
40027978:	00112623          	sw	ra,12(sp)
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
4002797c:	ff1ff0ef          	jal	ra,4002796c <arch_system_halt>

40027980 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
40027980:	fe010113          	addi	sp,sp,-32
40027984:	01212823          	sw	s2,16(sp)
40027988:	00112e23          	sw	ra,28(sp)
4002798c:	00812c23          	sw	s0,24(sp)
40027990:	00912a23          	sw	s1,20(sp)
40027994:	00050913          	mv	s2,a0
40027998:	00b12623          	sw	a1,12(sp)
4002799c:	300474f3          	csrrci	s1,mstatus,8
	return z_impl_z_current_get();
400279a0:	305020ef          	jal	ra,4002a4a4 <z_impl_z_current_get>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
400279a4:	00c12583          	lw	a1,12(sp)
400279a8:	00050413          	mv	s0,a0
400279ac:	00090513          	mv	a0,s2
400279b0:	fc5ff0ef          	jal	ra,40027974 <k_sys_fatal_error_handler>
			  : "r" (key & MSTATUS_IEN)
400279b4:	0084f493          	andi	s1,s1,8
	__asm__ volatile ("csrs mstatus, %0"
400279b8:	3004a073          	csrs	mstatus,s1
	z_impl_k_thread_abort(thread);
400279bc:	00040513          	mv	a0,s0
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
400279c0:	01812403          	lw	s0,24(sp)
400279c4:	01c12083          	lw	ra,28(sp)
400279c8:	01412483          	lw	s1,20(sp)
400279cc:	01012903          	lw	s2,16(sp)
400279d0:	02010113          	addi	sp,sp,32
400279d4:	4050206f          	j	4002a5d8 <z_impl_k_thread_abort>

400279d8 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
400279d8:	00251713          	slli	a4,a0,0x2
400279dc:	400317b7          	lui	a5,0x40031
400279e0:	00150513          	addi	a0,a0,1
400279e4:	8e878793          	addi	a5,a5,-1816 # 400308e8 <levels.0>
400279e8:	00251513          	slli	a0,a0,0x2
{
400279ec:	fe010113          	addi	sp,sp,-32
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
400279f0:	00e78733          	add	a4,a5,a4
400279f4:	00a787b3          	add	a5,a5,a0
{
400279f8:	00812c23          	sw	s0,24(sp)
400279fc:	01212823          	sw	s2,16(sp)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
40027a00:	00072403          	lw	s0,0(a4)
40027a04:	0007a903          	lw	s2,0(a5)
{
40027a08:	01312623          	sw	s3,12(sp)
40027a0c:	00112e23          	sw	ra,28(sp)
40027a10:	00912a23          	sw	s1,20(sp)
				 */
				if (rc != 0) {
					if (rc < 0) {
						rc = -rc;
					}
					if (rc > UINT8_MAX) {
40027a14:	0ff00993          	li	s3,255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
40027a18:	03246063          	bltu	s0,s2,40027a38 <z_sys_init_run_level+0x60>
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
40027a1c:	01c12083          	lw	ra,28(sp)
40027a20:	01812403          	lw	s0,24(sp)
40027a24:	01412483          	lw	s1,20(sp)
40027a28:	01012903          	lw	s2,16(sp)
40027a2c:	00c12983          	lw	s3,12(sp)
40027a30:	02010113          	addi	sp,sp,32
40027a34:	00008067          	ret
		const struct device *dev = entry->dev;
40027a38:	00442483          	lw	s1,4(s0)
			if (entry->init_fn.dev != NULL) {
40027a3c:	00042783          	lw	a5,0(s0)
		if (dev != NULL) {
40027a40:	04048463          	beqz	s1,40027a88 <z_sys_init_run_level+0xb0>
			if (entry->init_fn.dev != NULL) {
40027a44:	02078663          	beqz	a5,40027a70 <z_sys_init_run_level+0x98>
				rc = entry->init_fn.dev(dev);
40027a48:	00048513          	mv	a0,s1
40027a4c:	000780e7          	jalr	a5
				if (rc != 0) {
40027a50:	02050063          	beqz	a0,40027a70 <z_sys_init_run_level+0x98>
					if (rc < 0) {
40027a54:	41f55793          	srai	a5,a0,0x1f
40027a58:	00a7c533          	xor	a0,a5,a0
40027a5c:	40f50533          	sub	a0,a0,a5
					dev->state->init_res = rc;
40027a60:	00c4a703          	lw	a4,12(s1)
					if (rc > UINT8_MAX) {
40027a64:	00a9d463          	bge	s3,a0,40027a6c <z_sys_init_run_level+0x94>
40027a68:	0ff00513          	li	a0,255
					dev->state->init_res = rc;
40027a6c:	00a70023          	sb	a0,0(a4)
			dev->state->initialized = true;
40027a70:	00c4a703          	lw	a4,12(s1)
40027a74:	00174783          	lbu	a5,1(a4)
40027a78:	0017e793          	ori	a5,a5,1
40027a7c:	00f700a3          	sb	a5,1(a4)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
40027a80:	00840413          	addi	s0,s0,8
40027a84:	f95ff06f          	j	40027a18 <z_sys_init_run_level+0x40>
			(void)entry->init_fn.sys();
40027a88:	000780e7          	jalr	a5
40027a8c:	ff5ff06f          	j	40027a80 <z_sys_init_run_level+0xa8>

40027a90 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
40027a90:	ff010113          	addi	sp,sp,-16
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
40027a94:	400317b7          	lui	a5,0x40031
40027a98:	00100713          	li	a4,1

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
40027a9c:	00300513          	li	a0,3
{
40027aa0:	00112623          	sw	ra,12(sp)
	z_sys_post_kernel = true;
40027aa4:	b0e783a3          	sb	a4,-1273(a5) # 40030b07 <z_sys_post_kernel>
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
40027aa8:	f31ff0ef          	jal	ra,400279d8 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
40027aac:	4dd030ef          	jal	ra,4002b788 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
40027ab0:	00400513          	li	a0,4
40027ab4:	f25ff0ef          	jal	ra,400279d8 <z_sys_init_run_level>

	z_init_static_threads();
40027ab8:	1bd000ef          	jal	ra,40028474 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
40027abc:	814d90ef          	jal	ra,40000ad0 <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
40027ac0:	400317b7          	lui	a5,0x40031
40027ac4:	3b878793          	addi	a5,a5,952 # 400313b8 <z_main_thread>
40027ac8:	00c7c703          	lbu	a4,12(a5)
40027acc:	ffe77713          	andi	a4,a4,-2
40027ad0:	00e78623          	sb	a4,12(a5)

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
40027ad4:	00c12083          	lw	ra,12(sp)
40027ad8:	01010113          	addi	sp,sp,16
40027adc:	00008067          	ret

40027ae0 <z_early_memset>:
	(void) memset(dst, c, n);
40027ae0:	d90e106f          	j	40009070 <memset>

40027ae4 <z_bss_zero>:
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
40027ae4:	40031537          	lui	a0,0x40031
40027ae8:	400337b7          	lui	a5,0x40033
40027aec:	9e050613          	addi	a2,a0,-1568 # 400309e0 <curr_tick>
40027af0:	88c78793          	addi	a5,a5,-1908 # 4003288c <sched_spinlock>
40027af4:	40c78633          	sub	a2,a5,a2
40027af8:	00000593          	li	a1,0
40027afc:	9e050513          	addi	a0,a0,-1568
40027b00:	fe1ff06f          	j	40027ae0 <z_early_memset>

40027b04 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
40027b04:	fe010113          	addi	sp,sp,-32
40027b08:	01212823          	sw	s2,16(sp)
	struct k_thread *thread = &z_idle_threads[i];
40027b0c:	0c800913          	li	s2,200
40027b10:	03250933          	mul	s2,a0,s2
{
40027b14:	00912a23          	sw	s1,20(sp)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
40027b18:	01400493          	li	s1,20
	struct k_thread *thread = &z_idle_threads[i];
40027b1c:	400317b7          	lui	a5,0x40031
40027b20:	2f078793          	addi	a5,a5,752 # 400312f0 <z_idle_threads>
	z_setup_new_thread(thread, stack,
40027b24:	400355b7          	lui	a1,0x40035
{
40027b28:	00812c23          	sw	s0,24(sp)
	z_setup_new_thread(thread, stack,
40027b2c:	400286b7          	lui	a3,0x40028
{
40027b30:	00050413          	mv	s0,a0
	z_setup_new_thread(thread, stack,
40027b34:	d7058593          	addi	a1,a1,-656 # 40034d70 <z_idle_stacks>
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
40027b38:	029504b3          	mul	s1,a0,s1
	struct k_thread *thread = &z_idle_threads[i];
40027b3c:	00f90933          	add	s2,s2,a5
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
40027b40:	400337b7          	lui	a5,0x40033
40027b44:	86878793          	addi	a5,a5,-1944 # 40032868 <_kernel>
	k_thread_stack_t *stack = z_idle_stacks[i];
40027b48:	00951513          	slli	a0,a0,0x9
	z_setup_new_thread(thread, stack,
40027b4c:	00a585b3          	add	a1,a1,a0
40027b50:	00f00893          	li	a7,15
40027b54:	00090513          	mv	a0,s2
40027b58:	00000813          	li	a6,0
40027b5c:	5d468693          	addi	a3,a3,1492 # 400285d4 <idle>
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
40027b60:	00f484b3          	add	s1,s1,a5
	z_setup_new_thread(thread, stack,
40027b64:	400317b7          	lui	a5,0x40031
40027b68:	8d878793          	addi	a5,a5,-1832 # 400308d8 <uart_liteuart_driver_api+0x14>
40027b6c:	00f12223          	sw	a5,4(sp)
40027b70:	00100793          	li	a5,1
40027b74:	00f12023          	sw	a5,0(sp)
40027b78:	00048713          	mv	a4,s1
40027b7c:	00000793          	li	a5,0
40027b80:	20000613          	li	a2,512
{
40027b84:	00112e23          	sw	ra,28(sp)
	z_setup_new_thread(thread, stack,
40027b88:	718000ef          	jal	ra,400282a0 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
40027b8c:	00d94783          	lbu	a5,13(s2)
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
40027b90:	00848823          	sb	s0,16(s1)
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
40027b94:	00140413          	addi	s0,s0,1
40027b98:	ffb7f793          	andi	a5,a5,-5
40027b9c:	00f906a3          	sb	a5,13(s2)
40027ba0:	400347b7          	lui	a5,0x40034
40027ba4:	00b41413          	slli	s0,s0,0xb
40027ba8:	57078793          	addi	a5,a5,1392 # 40034570 <z_interrupt_stacks>
40027bac:	00f40433          	add	s0,s0,a5
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
40027bb0:	0124a623          	sw	s2,12(s1)
	_kernel.cpus[id].irq_stack =
40027bb4:	0084a223          	sw	s0,4(s1)
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
40027bb8:	01c12083          	lw	ra,28(sp)
40027bbc:	01812403          	lw	s0,24(sp)
40027bc0:	01412483          	lw	s1,20(sp)
40027bc4:	01012903          	lw	s2,16(sp)
40027bc8:	02010113          	addi	sp,sp,32
40027bcc:	00008067          	ret

40027bd0 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
40027bd0:	f0010113          	addi	sp,sp,-256
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
40027bd4:	00000513          	li	a0,0
{
40027bd8:	0e112e23          	sw	ra,252(sp)
40027bdc:	0e812c23          	sw	s0,248(sp)
40027be0:	0e912a23          	sw	s1,244(sp)
40027be4:	0f212823          	sw	s2,240(sp)
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif
#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
	k_thread_system_pool_assign(dummy_thread);
40027be8:	01810493          	addi	s1,sp,24
40027bec:	0f312623          	sw	s3,236(sp)

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
40027bf0:	40033437          	lui	s0,0x40033
	z_sys_init_run_level(INIT_LEVEL_EARLY);
40027bf4:	de5ff0ef          	jal	ra,400279d8 <z_sys_init_run_level>
	dummy_thread->base.user_options = K_ESSENTIAL;
40027bf8:	10100793          	li	a5,257
	k_thread_system_pool_assign(dummy_thread);
40027bfc:	00048513          	mv	a0,s1
	_current_cpu->current = dummy_thread;
40027c00:	86840413          	addi	s0,s0,-1944 # 40032868 <_kernel>
	dummy_thread->base.user_options = K_ESSENTIAL;
40027c04:	02f11223          	sh	a5,36(sp)
	dummy_thread->stack_info.start = 0U;
40027c08:	0c012423          	sw	zero,200(sp)
	dummy_thread->stack_info.size = 0U;
40027c0c:	0c012623          	sw	zero,204(sp)
	k_thread_system_pool_assign(dummy_thread);
40027c10:	309030ef          	jal	ra,4002b718 <k_thread_system_pool_assign>
	_current_cpu->current = dummy_thread;
40027c14:	00942423          	sw	s1,8(s0)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
40027c18:	c99ff0ef          	jal	ra,400278b0 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
40027c1c:	00100513          	li	a0,1
40027c20:	db9ff0ef          	jal	ra,400279d8 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
40027c24:	00200513          	li	a0,2
40027c28:	db1ff0ef          	jal	ra,400279d8 <z_sys_init_run_level>
	z_sched_init();
40027c2c:	65c020ef          	jal	ra,4002a288 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
40027c30:	400317b7          	lui	a5,0x40031
40027c34:	8e078793          	addi	a5,a5,-1824 # 400308e0 <uart_liteuart_driver_api+0x1c>
	_kernel.ready_q.cache = &z_main_thread;
40027c38:	400314b7          	lui	s1,0x40031
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
40027c3c:	00f12223          	sw	a5,4(sp)
40027c40:	400286b7          	lui	a3,0x40028
40027c44:	00100793          	li	a5,1
40027c48:	400355b7          	lui	a1,0x40035
	_kernel.ready_q.cache = &z_main_thread;
40027c4c:	3b848913          	addi	s2,s1,952 # 400313b8 <z_main_thread>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
40027c50:	00000893          	li	a7,0
40027c54:	00000813          	li	a6,0
40027c58:	00000713          	li	a4,0
40027c5c:	a9068693          	addi	a3,a3,-1392 # 40027a90 <bg_thread_main>
40027c60:	40000613          	li	a2,1024
40027c64:	f7058593          	addi	a1,a1,-144 # 40034f70 <z_main_stack>
40027c68:	00f12023          	sw	a5,0(sp)
40027c6c:	3b848513          	addi	a0,s1,952
40027c70:	00000793          	li	a5,0
	_kernel.ready_q.cache = &z_main_thread;
40027c74:	01242a23          	sw	s2,20(s0)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
40027c78:	628000ef          	jal	ra,400282a0 <z_setup_new_thread>
40027c7c:	00d94783          	lbu	a5,13(s2)
	z_ready_thread(&z_main_thread);
40027c80:	3b848513          	addi	a0,s1,952
40027c84:	ffb7f793          	andi	a5,a5,-5
40027c88:	00f906a3          	sb	a5,13(s2)
40027c8c:	0c0020ef          	jal	ra,40029d4c <z_ready_thread>
	z_init_cpu(0);
40027c90:	00000513          	li	a0,0
40027c94:	e71ff0ef          	jal	ra,40027b04 <z_init_cpu>
	__asm__ volatile ("csrrc %0, mstatus, %1"
40027c98:	30047973          	csrrci	s2,mstatus,8
	old_thread = _current;
40027c9c:	00842983          	lw	s3,8(s0)
	old_thread->swap_retval = -EAGAIN;
40027ca0:	ff500793          	li	a5,-11
40027ca4:	0af9ae23          	sw	a5,188(s3)
40027ca8:	300477f3          	csrrci	a5,mstatus,8
	new_thread = z_swap_next_thread();
40027cac:	560020ef          	jal	ra,4002a20c <z_swap_next_thread>
	if (new_thread != old_thread) {
40027cb0:	00a98e63          	beq	s3,a0,40027ccc <z_cstart+0xfc>
40027cb4:	00050493          	mv	s1,a0
		_current_cpu->current = new_thread;
40027cb8:	00a42423          	sw	a0,8(s0)
		z_reset_time_slice(new_thread);
40027cbc:	349010ef          	jal	ra,40029804 <z_reset_time_slice>
	struct k_thread *old = CONTAINER_OF(switched_from, struct k_thread,
					    switch_handle);
#ifdef CONFIG_RISCV_ALWAYS_SWITCH_THROUGH_ECALL
	arch_syscall_invoke2((uintptr_t)new, (uintptr_t)old, RV_ECALL_SCHEDULE);
#else
	z_riscv_switch(new, old);
40027cc0:	0c04a503          	lw	a0,192(s1)
40027cc4:	00098593          	mv	a1,s3
40027cc8:	d51e00ef          	jal	ra,40008a18 <z_riscv_switch>
			  : "r" (key & MSTATUS_IEN)
40027ccc:	00897913          	andi	s2,s2,8
	__asm__ volatile ("csrs mstatus, %0"
40027cd0:	30092073          	csrs	mstatus,s2

40027cd4 <k_heap_init>:
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
40027cd4:	00c50713          	addi	a4,a0,12
	list->head = (sys_dnode_t *)list;
40027cd8:	00e52623          	sw	a4,12(a0)
	list->tail = (sys_dnode_t *)list;
40027cdc:	00e52823          	sw	a4,16(a0)
#include <zephyr/linker/linker-defs.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
40027ce0:	d0dd906f          	j	400019ec <sys_heap_init>

40027ce4 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(void)
{
40027ce4:	ff010113          	addi	sp,sp,-16
40027ce8:	00812423          	sw	s0,8(sp)
40027cec:	00912223          	sw	s1,4(sp)
	STRUCT_SECTION_FOREACH(k_heap, h) {
40027cf0:	4003d437          	lui	s0,0x4003d
40027cf4:	4003d4b7          	lui	s1,0x4003d
{
40027cf8:	00112623          	sw	ra,12(sp)
	STRUCT_SECTION_FOREACH(k_heap, h) {
40027cfc:	a8840413          	addi	s0,s0,-1400 # 4003ca88 <_system_heap>
40027d00:	a9c48493          	addi	s1,s1,-1380 # 4003ca9c <conn_lock>
40027d04:	00946e63          	bltu	s0,s1,40027d20 <statics_init+0x3c>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
40027d08:	00c12083          	lw	ra,12(sp)
40027d0c:	00812403          	lw	s0,8(sp)
40027d10:	00412483          	lw	s1,4(sp)
40027d14:	00000513          	li	a0,0
40027d18:	01010113          	addi	sp,sp,16
40027d1c:	00008067          	ret
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
40027d20:	00842603          	lw	a2,8(s0)
40027d24:	00442583          	lw	a1,4(s0)
40027d28:	00040513          	mv	a0,s0
	STRUCT_SECTION_FOREACH(k_heap, h) {
40027d2c:	01440413          	addi	s0,s0,20
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
40027d30:	fa5ff0ef          	jal	ra,40027cd4 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
40027d34:	fd1ff06f          	j	40027d04 <statics_init+0x20>

40027d38 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
40027d38:	fd010113          	addi	sp,sp,-48
40027d3c:	01312e23          	sw	s3,28(sp)
40027d40:	01412c23          	sw	s4,24(sp)
40027d44:	00050993          	mv	s3,a0
40027d48:	00058a13          	mv	s4,a1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
40027d4c:	00068513          	mv	a0,a3
40027d50:	00070593          	mv	a1,a4
{
40027d54:	02812423          	sw	s0,40(sp)
40027d58:	02912223          	sw	s1,36(sp)
40027d5c:	03212023          	sw	s2,32(sp)
40027d60:	01512a23          	sw	s5,20(sp)
40027d64:	01612823          	sw	s6,16(sp)
40027d68:	02112623          	sw	ra,44(sp)
40027d6c:	01712623          	sw	s7,12(sp)
40027d70:	01812423          	sw	s8,8(sp)
40027d74:	00060a93          	mv	s5,a2
40027d78:	00068413          	mv	s0,a3
40027d7c:	00070b13          	mv	s6,a4
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
40027d80:	6a1020ef          	jal	ra,4002ac20 <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
40027d84:	fff00793          	li	a5,-1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
40027d88:	00050913          	mv	s2,a0
40027d8c:	00058493          	mv	s1,a1
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
40027d90:	00f41a63          	bne	s0,a5,40027da4 <k_heap_aligned_alloc+0x6c>
40027d94:	008b1863          	bne	s6,s0,40027da4 <k_heap_aligned_alloc+0x6c>
40027d98:	800004b7          	lui	s1,0x80000
40027d9c:	fff00913          	li	s2,-1
40027da0:	fff48493          	addi	s1,s1,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>

	k_spinlock_key_t key = k_spin_lock(&h->lock);
40027da4:	01498b13          	addi	s6,s3,20
	__asm__ volatile ("csrrc %0, mstatus, %1"
40027da8:	30047473          	csrrci	s0,mstatus,8
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
40027dac:	00c98b93          	addi	s7,s3,12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
40027db0:	000a8613          	mv	a2,s5
40027db4:	000a0593          	mv	a1,s4
40027db8:	00098513          	mv	a0,s3
40027dbc:	a61d90ef          	jal	ra,4000181c <sys_heap_aligned_alloc>
40027dc0:	00050c13          	mv	s8,a0
		now = sys_clock_tick_get();
40027dc4:	595020ef          	jal	ra,4002ab58 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
40027dc8:	040c0063          	beqz	s8,40027e08 <k_heap_aligned_alloc+0xd0>
			  : "r" (key & MSTATUS_IEN)
40027dcc:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrs mstatus, %0"
40027dd0:	30042073          	csrs	mstatus,s0

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
40027dd4:	02c12083          	lw	ra,44(sp)
40027dd8:	02812403          	lw	s0,40(sp)
40027ddc:	02412483          	lw	s1,36(sp)
40027de0:	02012903          	lw	s2,32(sp)
40027de4:	01c12983          	lw	s3,28(sp)
40027de8:	01812a03          	lw	s4,24(sp)
40027dec:	01412a83          	lw	s5,20(sp)
40027df0:	01012b03          	lw	s6,16(sp)
40027df4:	00c12b83          	lw	s7,12(sp)
40027df8:	000c0513          	mv	a0,s8
40027dfc:	00812c03          	lw	s8,8(sp)
40027e00:	03010113          	addi	sp,sp,48
40027e04:	00008067          	ret
		    (ret != NULL) || ((end - now) <= 0)) {
40027e08:	40a906b3          	sub	a3,s2,a0
40027e0c:	00d937b3          	sltu	a5,s2,a3
40027e10:	40b48733          	sub	a4,s1,a1
40027e14:	40f70733          	sub	a4,a4,a5
40027e18:	00e04663          	bgtz	a4,40027e24 <k_heap_aligned_alloc+0xec>
40027e1c:	fa0718e3          	bnez	a4,40027dcc <k_heap_aligned_alloc+0x94>
40027e20:	fa0686e3          	beqz	a3,40027dcc <k_heap_aligned_alloc+0x94>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
40027e24:	000b8613          	mv	a2,s7
40027e28:	00040593          	mv	a1,s0
40027e2c:	000b0513          	mv	a0,s6
40027e30:	7fd010ef          	jal	ra,40029e2c <z_pend_curr>
	__asm__ volatile ("csrrc %0, mstatus, %1"
40027e34:	30047473          	csrrci	s0,mstatus,8
	z_spin_lock_set_owner(l);
#if defined(CONFIG_SPIN_LOCK_TIME_LIMIT) && (CONFIG_SPIN_LOCK_TIME_LIMIT != 0)
	l->lock_time = sys_clock_cycle_get_32();
#endif /* CONFIG_SPIN_LOCK_TIME_LIMIT */
#endif/* CONFIG_SPIN_VALIDATE */
	return k;
40027e38:	f79ff06f          	j	40027db0 <k_heap_aligned_alloc+0x78>

40027e3c <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
40027e3c:	ff010113          	addi	sp,sp,-16
40027e40:	00912223          	sw	s1,4(sp)
40027e44:	00112623          	sw	ra,12(sp)
40027e48:	00812423          	sw	s0,8(sp)
40027e4c:	00050493          	mv	s1,a0
40027e50:	30047473          	csrrci	s0,mstatus,8
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
40027e54:	8a5d90ef          	jal	ra,400016f8 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
40027e58:	00c48513          	addi	a0,s1,12
40027e5c:	3dc020ef          	jal	ra,4002a238 <z_unpend_all>
40027e60:	02050063          	beqz	a0,40027e80 <k_heap_free+0x44>
		z_reschedule(&h->lock, key);
40027e64:	00040593          	mv	a1,s0
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
40027e68:	00812403          	lw	s0,8(sp)
40027e6c:	00c12083          	lw	ra,12(sp)
		z_reschedule(&h->lock, key);
40027e70:	01448513          	addi	a0,s1,20
}
40027e74:	00412483          	lw	s1,4(sp)
40027e78:	01010113          	addi	sp,sp,16
		z_reschedule(&h->lock, key);
40027e7c:	1dc0206f          	j	4002a058 <z_reschedule>
	__asm__ volatile ("csrs mstatus, %0"
40027e80:	00847413          	andi	s0,s0,8
40027e84:	30042073          	csrs	mstatus,s0
}
40027e88:	00c12083          	lw	ra,12(sp)
40027e8c:	00812403          	lw	s0,8(sp)
40027e90:	00412483          	lw	s1,4(sp)
40027e94:	01010113          	addi	sp,sp,16
40027e98:	00008067          	ret

40027e9c <create_free_list>:
{
	uint32_t j;
	char *p;

	/* blocks must be word aligned */
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
40027e9c:	01052703          	lw	a4,16(a0)
40027ea0:	00c52783          	lw	a5,12(a0)
40027ea4:	00f767b3          	or	a5,a4,a5
40027ea8:	0037f793          	andi	a5,a5,3
40027eac:	02079a63          	bnez	a5,40027ee0 <create_free_list+0x44>
				(sizeof(void *) - 1)) != 0U) {
		return -EINVAL;
	}

	slab->free_list = NULL;
40027eb0:	00052a23          	sw	zero,20(a0)
	p = slab->buffer;

	for (j = 0U; j < slab->num_blocks; j++) {
40027eb4:	00852683          	lw	a3,8(a0)
40027eb8:	00d7e663          	bltu	a5,a3,40027ec4 <create_free_list+0x28>
		*(char **)p = slab->free_list;
		slab->free_list = p;
		p += slab->block_size;
	}
	return 0;
40027ebc:	00000513          	li	a0,0
40027ec0:	00008067          	ret
		*(char **)p = slab->free_list;
40027ec4:	01452683          	lw	a3,20(a0)
	for (j = 0U; j < slab->num_blocks; j++) {
40027ec8:	00178793          	addi	a5,a5,1
		*(char **)p = slab->free_list;
40027ecc:	00d72023          	sw	a3,0(a4)
		p += slab->block_size;
40027ed0:	00c52683          	lw	a3,12(a0)
		slab->free_list = p;
40027ed4:	00e52a23          	sw	a4,20(a0)
		p += slab->block_size;
40027ed8:	00d70733          	add	a4,a4,a3
	for (j = 0U; j < slab->num_blocks; j++) {
40027edc:	fd9ff06f          	j	40027eb4 <create_free_list+0x18>
		return -EINVAL;
40027ee0:	fea00513          	li	a0,-22
}
40027ee4:	00008067          	ret

40027ee8 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(void)
{
40027ee8:	ff010113          	addi	sp,sp,-16
40027eec:	00812423          	sw	s0,8(sp)
40027ef0:	00912223          	sw	s1,4(sp)
	int rc = 0;

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
40027ef4:	4003d437          	lui	s0,0x4003d
40027ef8:	4003d4b7          	lui	s1,0x4003d
{
40027efc:	00112623          	sw	ra,12(sp)
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
40027f00:	a3440413          	addi	s0,s0,-1484 # 4003ca34 <rx_pkts>
	int rc = 0;
40027f04:	00000513          	li	a0,0
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
40027f08:	a8848493          	addi	s1,s1,-1400 # 4003ca88 <_system_heap>
40027f0c:	00946c63          	bltu	s0,s1,40027f24 <init_mem_slab_module+0x3c>
		z_object_init(slab);
	}

out:
	return rc;
}
40027f10:	00c12083          	lw	ra,12(sp)
40027f14:	00812403          	lw	s0,8(sp)
40027f18:	00412483          	lw	s1,4(sp)
40027f1c:	01010113          	addi	sp,sp,16
40027f20:	00008067          	ret
		rc = create_free_list(slab);
40027f24:	00040513          	mv	a0,s0
40027f28:	f75ff0ef          	jal	ra,40027e9c <create_free_list>
		if (rc < 0) {
40027f2c:	fe0542e3          	bltz	a0,40027f10 <init_mem_slab_module+0x28>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
40027f30:	01c40413          	addi	s0,s0,28
40027f34:	fd9ff06f          	j	40027f0c <init_mem_slab_module+0x24>

40027f38 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
40027f38:	ff010113          	addi	sp,sp,-16
40027f3c:	00812423          	sw	s0,8(sp)
40027f40:	00112623          	sw	ra,12(sp)
40027f44:	00058413          	mv	s0,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
40027f48:	300475f3          	csrrci	a1,mstatus,8
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
40027f4c:	01452783          	lw	a5,20(a0)
40027f50:	02078663          	beqz	a5,40027f7c <k_mem_slab_alloc+0x44>
		/* take a free block */
		*mem = slab->free_list;
40027f54:	00f42023          	sw	a5,0(s0)
		slab->free_list = *(char **)(slab->free_list);
40027f58:	0007a783          	lw	a5,0(a5)
40027f5c:	00f52a23          	sw	a5,20(a0)
		slab->num_used++;
40027f60:	01852783          	lw	a5,24(a0)
40027f64:	00178793          	addi	a5,a5,1
40027f68:	00f52c23          	sw	a5,24(a0)

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
40027f6c:	00000513          	li	a0,0
	__asm__ volatile ("csrs mstatus, %0"
40027f70:	0085f593          	andi	a1,a1,8
40027f74:	3005a073          	csrs	mstatus,a1

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
40027f78:	0400006f          	j	40027fb8 <k_mem_slab_alloc+0x80>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
40027f7c:	00d667b3          	or	a5,a2,a3
40027f80:	00068713          	mv	a4,a3
40027f84:	00079863          	bnez	a5,40027f94 <k_mem_slab_alloc+0x5c>
		*mem = NULL;
40027f88:	00042023          	sw	zero,0(s0)
		result = -ENOMEM;
40027f8c:	ff400513          	li	a0,-12
40027f90:	fe1ff06f          	j	40027f70 <k_mem_slab_alloc+0x38>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
40027f94:	00060693          	mv	a3,a2
40027f98:	00050613          	mv	a2,a0
40027f9c:	00850513          	addi	a0,a0,8
40027fa0:	68d010ef          	jal	ra,40029e2c <z_pend_curr>
		if (result == 0) {
40027fa4:	00051a63          	bnez	a0,40027fb8 <k_mem_slab_alloc+0x80>
			*mem = _current->base.swap_data;
40027fa8:	400337b7          	lui	a5,0x40033
40027fac:	8707a783          	lw	a5,-1936(a5) # 40032870 <_kernel+0x8>
40027fb0:	0147a783          	lw	a5,20(a5)
40027fb4:	00f42023          	sw	a5,0(s0)
}
40027fb8:	00c12083          	lw	ra,12(sp)
40027fbc:	00812403          	lw	s0,8(sp)
40027fc0:	01010113          	addi	sp,sp,16
40027fc4:	00008067          	ret

40027fc8 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
40027fc8:	ff010113          	addi	sp,sp,-16
40027fcc:	00812423          	sw	s0,8(sp)
40027fd0:	00912223          	sw	s1,4(sp)
40027fd4:	00112623          	sw	ra,12(sp)
40027fd8:	01212023          	sw	s2,0(sp)
40027fdc:	00050413          	mv	s0,a0
40027fe0:	00058493          	mv	s1,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
40027fe4:	30047973          	csrrci	s2,mstatus,8
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
40027fe8:	01452783          	lw	a5,20(a0)
40027fec:	02079e63          	bnez	a5,40028028 <k_mem_slab_free+0x60>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
40027ff0:	6d1010ef          	jal	ra,40029ec0 <z_unpend_first_thread>

		if (pending_thread != NULL) {
40027ff4:	02050a63          	beqz	a0,40028028 <k_mem_slab_free+0x60>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
40027ff8:	0004a703          	lw	a4,0(s1)
 * z_swap() is in use it's a simple inline provided by the kernel.
 */
static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->swap_retval = value;
40027ffc:	0a052e23          	sw	zero,188(a0)
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
40028000:	00e52a23          	sw	a4,20(a0)
			z_ready_thread(pending_thread);
40028004:	549010ef          	jal	ra,40029d4c <z_ready_thread>
			z_reschedule(&slab->lock, key);
40028008:	00840513          	addi	a0,s0,8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
4002800c:	00812403          	lw	s0,8(sp)
40028010:	00c12083          	lw	ra,12(sp)
40028014:	00412483          	lw	s1,4(sp)
			z_reschedule(&slab->lock, key);
40028018:	00090593          	mv	a1,s2
}
4002801c:	00012903          	lw	s2,0(sp)
40028020:	01010113          	addi	sp,sp,16
			z_reschedule(&slab->lock, key);
40028024:	0340206f          	j	4002a058 <z_reschedule>
	**(char ***) mem = slab->free_list;
40028028:	0004a783          	lw	a5,0(s1)
4002802c:	01442703          	lw	a4,20(s0)
	__asm__ volatile ("csrs mstatus, %0"
40028030:	00897913          	andi	s2,s2,8
40028034:	00e7a023          	sw	a4,0(a5)
	slab->free_list = *(char **) mem;
40028038:	0004a783          	lw	a5,0(s1)
4002803c:	00f42a23          	sw	a5,20(s0)
	slab->num_used--;
40028040:	01842783          	lw	a5,24(s0)
40028044:	fff78793          	addi	a5,a5,-1
40028048:	00f42c23          	sw	a5,24(s0)
4002804c:	30092073          	csrs	mstatus,s2
}
40028050:	00c12083          	lw	ra,12(sp)
40028054:	00812403          	lw	s0,8(sp)
40028058:	00412483          	lw	s1,4(sp)
4002805c:	00012903          	lw	s2,0(sp)
40028060:	01010113          	addi	sp,sp,16
40028064:	00008067          	ret

40028068 <k_thread_foreach>:

#define _FOREACH_STATIC_THREAD(thread_data)              \
	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data)

void k_thread_foreach(k_thread_user_cb_t user_cb, void *user_data)
{
40028068:	fe010113          	addi	sp,sp,-32
4002806c:	01212823          	sw	s2,16(sp)
40028070:	01312623          	sw	s3,12(sp)
40028074:	00112e23          	sw	ra,28(sp)
40028078:	00812c23          	sw	s0,24(sp)
4002807c:	00912a23          	sw	s1,20(sp)
40028080:	00050913          	mv	s2,a0
40028084:	00058993          	mv	s3,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
40028088:	300474f3          	csrrci	s1,mstatus,8
	 */
	key = k_spin_lock(&z_thread_monitor_lock);

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, foreach);

	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
4002808c:	400337b7          	lui	a5,0x40033
40028090:	8887a403          	lw	s0,-1912(a5) # 40032888 <_kernel+0x20>
40028094:	02041463          	bnez	s0,400280bc <k_thread_foreach+0x54>
	__asm__ volatile ("csrs mstatus, %0"
40028098:	0084f493          	andi	s1,s1,8
4002809c:	3004a073          	csrs	mstatus,s1

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, foreach);

	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
}
400280a0:	01c12083          	lw	ra,28(sp)
400280a4:	01812403          	lw	s0,24(sp)
400280a8:	01412483          	lw	s1,20(sp)
400280ac:	01012903          	lw	s2,16(sp)
400280b0:	00c12983          	lw	s3,12(sp)
400280b4:	02010113          	addi	sp,sp,32
400280b8:	00008067          	ret
		user_cb(thread, user_data);
400280bc:	00040513          	mv	a0,s0
400280c0:	00098593          	mv	a1,s3
400280c4:	000900e7          	jalr	s2
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
400280c8:	08842403          	lw	s0,136(s0)
400280cc:	fc9ff06f          	j	40028094 <k_thread_foreach+0x2c>

400280d0 <k_is_in_isr>:
	bool ret = arch_curr_cpu()->nested != 0U;

	arch_irq_unlock(key);
	return ret;
#else
	return _kernel.cpus[0].nested != 0U;
400280d0:	400337b7          	lui	a5,0x40033
400280d4:	8687a503          	lw	a0,-1944(a5) # 40032868 <_kernel>
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
400280d8:	00a03533          	snez	a0,a0
400280dc:	00008067          	ret

400280e0 <z_thread_monitor_exit>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
400280e0:	300476f3          	csrrci	a3,mstatus,8
 */
void z_thread_monitor_exit(struct k_thread *thread)
{
	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	if (thread == _kernel.threads) {
400280e4:	40033737          	lui	a4,0x40033
400280e8:	86870713          	addi	a4,a4,-1944 # 40032868 <_kernel>
400280ec:	02072783          	lw	a5,32(a4)
400280f0:	00a79e63          	bne	a5,a0,4002810c <z_thread_monitor_exit+0x2c>
		_kernel.threads = _kernel.threads->next_thread;
400280f4:	0887a783          	lw	a5,136(a5)
400280f8:	02f72023          	sw	a5,32(a4)
	__asm__ volatile ("csrs mstatus, %0"
400280fc:	0086f693          	andi	a3,a3,8
40028100:	3006a073          	csrs	mstatus,a3
			prev_thread->next_thread = thread->next_thread;
		}
	}

	k_spin_unlock(&z_thread_monitor_lock, key);
}
40028104:	00008067          	ret
40028108:	00070793          	mv	a5,a4
		while ((prev_thread != NULL) &&
4002810c:	fe0788e3          	beqz	a5,400280fc <z_thread_monitor_exit+0x1c>
			(thread != prev_thread->next_thread)) {
40028110:	0887a703          	lw	a4,136(a5)
		while ((prev_thread != NULL) &&
40028114:	fea71ae3          	bne	a4,a0,40028108 <z_thread_monitor_exit+0x28>
			prev_thread->next_thread = thread->next_thread;
40028118:	08852703          	lw	a4,136(a0)
4002811c:	08e7a423          	sw	a4,136(a5)
40028120:	fddff06f          	j	400280fc <z_thread_monitor_exit+0x1c>

40028124 <z_impl_k_thread_name_set>:
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
40028124:	ff010113          	addi	sp,sp,-16
40028128:	00812423          	sw	s0,8(sp)
4002812c:	00112623          	sw	ra,12(sp)
40028130:	00050413          	mv	s0,a0
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
40028134:	00051663          	bnez	a0,40028140 <z_impl_k_thread_name_set+0x1c>
		thread = _current;
40028138:	400337b7          	lui	a5,0x40033
4002813c:	8707a403          	lw	s0,-1936(a5) # 40032870 <_kernel+0x8>
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN - 1);
40028140:	08c40513          	addi	a0,s0,140
40028144:	01f00613          	li	a2,31
40028148:	d5de00ef          	jal	ra,40008ea4 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
4002814c:	0a0405a3          	sb	zero,171(s0)

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
40028150:	00c12083          	lw	ra,12(sp)
40028154:	00812403          	lw	s0,8(sp)
40028158:	00000513          	li	a0,0
4002815c:	01010113          	addi	sp,sp,16
40028160:	00008067          	ret

40028164 <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
40028164:	08c50513          	addi	a0,a0,140
40028168:	00008067          	ret

4002816c <k_thread_state_str>:
	static const char  *states_str[8] = {"dummy", "pending", "prestart",
					     "dead", "suspended", "aborting",
					     "", "queued"};
	static const size_t states_sz[8] = {5, 7, 8, 4, 9, 8, 0, 6};

	if ((buf == NULL) || (buf_size == 0)) {
4002816c:	12058263          	beqz	a1,40028290 <k_thread_state_str+0x124>
40028170:	12060063          	beqz	a2,40028290 <k_thread_state_str+0x124>
{
40028174:	fd010113          	addi	sp,sp,-48
40028178:	02812423          	sw	s0,40(sp)
4002817c:	03212023          	sw	s2,32(sp)
40028180:	02112623          	sw	ra,44(sp)
40028184:	02912223          	sw	s1,36(sp)
40028188:	01312e23          	sw	s3,28(sp)
4002818c:	01412c23          	sw	s4,24(sp)
40028190:	01512a23          	sw	s5,20(sp)
40028194:	01612823          	sw	s6,16(sp)
40028198:	01712623          	sw	s7,12(sp)
4002819c:	01812423          	sw	s8,8(sp)
400281a0:	01912223          	sw	s9,4(sp)
400281a4:	01a12023          	sw	s10,0(sp)
	uint8_t     thread_state = thread_id->base.thread_state;
400281a8:	00d54d03          	lbu	s10,13(a0)
		return "";
	}

	buf_size--;   /* Reserve 1 byte for end-of-string character */
400281ac:	00058413          	mv	s0,a1
400281b0:	fff60913          	addi	s2,a2,-1
		bit = BIT(index);
		if ((thread_state & bit) == 0) {
			continue;
		}

		off += copy_bytes(buf + off, buf_size - off,
400281b4:	00058513          	mv	a0,a1
	for (uint8_t index = 0; thread_state != 0; index++) {
400281b8:	080d0c63          	beqz	s10,40028250 <k_thread_state_str+0xe4>
				  states_str[index], states_sz[index]);
400281bc:	40031ab7          	lui	s5,0x40031
		off += copy_bytes(buf + off, buf_size - off,
400281c0:	40031b37          	lui	s6,0x40031
	for (uint8_t index = 0; thread_state != 0; index++) {
400281c4:	00000993          	li	s3,0
	size_t      off = 0;
400281c8:	00000493          	li	s1,0
		bit = BIT(index);
400281cc:	00100b93          	li	s7,1
				  states_str[index], states_sz[index]);
400281d0:	908a8a93          	addi	s5,s5,-1784 # 40030908 <states_sz.0>
		off += copy_bytes(buf + off, buf_size - off,
400281d4:	96cb0b13          	addi	s6,s6,-1684 # 4003096c <states_str.1>
	memcpy(dest, src, bytes_to_copy);
400281d8:	40031c37          	lui	s8,0x40031
		bit = BIT(index);
400281dc:	013b9a33          	sll	s4,s7,s3
		if ((thread_state & bit) == 0) {
400281e0:	014d77b3          	and	a5,s10,s4
400281e4:	04078e63          	beqz	a5,40028240 <k_thread_state_str+0xd4>
				  states_str[index], states_sz[index]);
400281e8:	00299793          	slli	a5,s3,0x2
400281ec:	00fa8733          	add	a4,s5,a5
	bytes_to_copy = MIN(dest_size, src_size);
400281f0:	00072703          	lw	a4,0(a4)
400281f4:	40990cb3          	sub	s9,s2,s1
400281f8:	01977463          	bgeu	a4,s9,40028200 <k_thread_state_str+0x94>
400281fc:	00070c93          	mv	s9,a4
		off += copy_bytes(buf + off, buf_size - off,
40028200:	00fb07b3          	add	a5,s6,a5
	memcpy(dest, src, bytes_to_copy);
40028204:	0007a583          	lw	a1,0(a5)
40028208:	000c8613          	mv	a2,s9

		thread_state &= ~bit;
4002820c:	fffa4a13          	not	s4,s4
	memcpy(dest, src, bytes_to_copy);
40028210:	e3de00ef          	jal	ra,4000904c <memcpy>
		off += copy_bytes(buf + off, buf_size - off,
40028214:	009c84b3          	add	s1,s9,s1
		thread_state &= ~bit;
40028218:	014d7d33          	and	s10,s10,s4

		if (thread_state != 0) {
4002821c:	00940533          	add	a0,s0,s1
40028220:	020d0863          	beqz	s10,40028250 <k_thread_state_str+0xe4>
			off += copy_bytes(buf + off, buf_size - off, "+", 1);
40028224:	40990a33          	sub	s4,s2,s1
	bytes_to_copy = MIN(dest_size, src_size);
40028228:	00990463          	beq	s2,s1,40028230 <k_thread_state_str+0xc4>
4002822c:	00100a13          	li	s4,1
	memcpy(dest, src, bytes_to_copy);
40028230:	000a0613          	mv	a2,s4
40028234:	904c0593          	addi	a1,s8,-1788 # 40030904 <levels.0+0x1c>
40028238:	e15e00ef          	jal	ra,4000904c <memcpy>
			off += copy_bytes(buf + off, buf_size - off, "+", 1);
4002823c:	014484b3          	add	s1,s1,s4
	for (uint8_t index = 0; thread_state != 0; index++) {
40028240:	00198993          	addi	s3,s3,1
40028244:	0ff9f993          	zext.b	s3,s3
		off += copy_bytes(buf + off, buf_size - off,
40028248:	00940533          	add	a0,s0,s1
4002824c:	f91ff06f          	j	400281dc <k_thread_state_str+0x70>
		}
	}

	buf[off] = '\0';
40028250:	00050023          	sb	zero,0(a0)

	return (const char *)buf;
}
40028254:	02c12083          	lw	ra,44(sp)
	return (const char *)buf;
40028258:	00040513          	mv	a0,s0
}
4002825c:	02812403          	lw	s0,40(sp)
40028260:	02412483          	lw	s1,36(sp)
40028264:	02012903          	lw	s2,32(sp)
40028268:	01c12983          	lw	s3,28(sp)
4002826c:	01812a03          	lw	s4,24(sp)
40028270:	01412a83          	lw	s5,20(sp)
40028274:	01012b03          	lw	s6,16(sp)
40028278:	00c12b83          	lw	s7,12(sp)
4002827c:	00812c03          	lw	s8,8(sp)
40028280:	00412c83          	lw	s9,4(sp)
40028284:	00012d03          	lw	s10,0(sp)
40028288:	03010113          	addi	sp,sp,48
4002828c:	00008067          	ret
		return "";
40028290:	4002c537          	lui	a0,0x4002c
40028294:	ed850513          	addi	a0,a0,-296 # 4002bed8 <__clz_tab+0x2ac>
}
40028298:	00008067          	ret

4002829c <z_impl_k_thread_start>:

void z_impl_k_thread_start(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
4002829c:	5ed0106f          	j	4002a088 <z_sched_start>

400282a0 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
400282a0:	fd010113          	addi	sp,sp,-48
400282a4:	02112623          	sw	ra,44(sp)
400282a8:	02812423          	sw	s0,40(sp)
400282ac:	02912223          	sw	s1,36(sp)
400282b0:	03212023          	sw	s2,32(sp)
400282b4:	01312e23          	sw	s3,28(sp)
400282b8:	01412c23          	sw	s4,24(sp)
400282bc:	01512a23          	sw	s5,20(sp)
400282c0:	01612823          	sw	s6,16(sp)
400282c4:	01712623          	sw	s7,12(sp)
400282c8:	00078a13          	mv	s4,a5
400282cc:	06c50793          	addi	a5,a0,108
	list->head = (sys_dnode_t *)list;
400282d0:	06f52623          	sw	a5,108(a0)
	list->tail = (sys_dnode_t *)list;
400282d4:	06f52823          	sw	a5,112(a0)
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
400282d8:	03012783          	lw	a5,48(sp)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
400282dc:	00f60613          	addi	a2,a2,15
{
400282e0:	00058913          	mv	s2,a1
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
400282e4:	ff067493          	andi	s1,a2,-16
	thread_base->user_options = (uint8_t)options;
400282e8:	00f50623          	sb	a5,12(a0)
	thread_base->thread_state = (uint8_t)initial_state;
400282ec:	00400793          	li	a5,4
{
400282f0:	00050413          	mv	s0,a0

	thread_base->prio = priority;
400282f4:	01150723          	sb	a7,14(a0)
	thread_base->thread_state = (uint8_t)initial_state;
400282f8:	00f506a3          	sb	a5,13(a0)
	stack_ptr = (char *)stack + stack_obj_size;
400282fc:	00958bb3          	add	s7,a1,s1
	memset(stack_buf_start, 0xaa, stack_buf_size);
40028300:	00048613          	mv	a2,s1
	thread_base->pended_on = NULL;
40028304:	00052423          	sw	zero,8(a0)

	thread_base->sched_locked = 0U;
40028308:	000507a3          	sb	zero,15(a0)
	node->next = NULL;
4002830c:	00052c23          	sw	zero,24(a0)
	node->prev = NULL;
40028310:	00052e23          	sw	zero,28(a0)
	memset(stack_buf_start, 0xaa, stack_buf_size);
40028314:	0aa00593          	li	a1,170
40028318:	00090513          	mv	a0,s2
{
4002831c:	00068b13          	mv	s6,a3
40028320:	00070a93          	mv	s5,a4
40028324:	00080993          	mv	s3,a6
	memset(stack_buf_start, 0xaa, stack_buf_size);
40028328:	d49e00ef          	jal	ra,40009070 <memset>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
4002832c:	00098813          	mv	a6,s3
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
40028330:	0b242823          	sw	s2,176(s0)
	new_thread->stack_info.size = stack_buf_size;
40028334:	0a942a23          	sw	s1,180(s0)
	new_thread->stack_info.delta = delta;
40028338:	0a042c23          	sw	zero,184(s0)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
4002833c:	000a0793          	mv	a5,s4
40028340:	000a8713          	mv	a4,s5
40028344:	000b0693          	mv	a3,s6
40028348:	000b8613          	mv	a2,s7
4002834c:	00090593          	mv	a1,s2
40028350:	00040513          	mv	a0,s0
40028354:	f3ce00ef          	jal	ra,40008a90 <arch_new_thread>
	new_thread->init_data = NULL;
40028358:	06042423          	sw	zero,104(s0)
	new_thread->entry.pEntry = entry;
4002835c:	07642c23          	sw	s6,120(s0)
	new_thread->entry.parameter1 = p1;
40028360:	07542e23          	sw	s5,124(s0)
	new_thread->entry.parameter2 = p2;
40028364:	09442023          	sw	s4,128(s0)
	new_thread->entry.parameter3 = p3;
40028368:	09342223          	sw	s3,132(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002836c:	30047773          	csrrci	a4,mstatus,8
	new_thread->next_thread = _kernel.threads;
40028370:	400337b7          	lui	a5,0x40033
40028374:	86878693          	addi	a3,a5,-1944 # 40032868 <_kernel>
40028378:	0206a603          	lw	a2,32(a3)
	__asm__ volatile ("csrs mstatus, %0"
4002837c:	00877713          	andi	a4,a4,8
	_kernel.threads = new_thread;
40028380:	0286a023          	sw	s0,32(a3)
	new_thread->next_thread = _kernel.threads;
40028384:	08c42423          	sw	a2,136(s0)
40028388:	30072073          	csrs	mstatus,a4
	if (name != NULL) {
4002838c:	86878493          	addi	s1,a5,-1944
40028390:	03412783          	lw	a5,52(sp)
40028394:	04078a63          	beqz	a5,400283e8 <z_setup_new_thread+0x148>
		strncpy(new_thread->name, name,
40028398:	01f00613          	li	a2,31
4002839c:	00078593          	mv	a1,a5
400283a0:	08c40513          	addi	a0,s0,140
400283a4:	b01e00ef          	jal	ra,40008ea4 <strncpy>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
400283a8:	0a0405a3          	sb	zero,171(s0)
	new_thread->resource_pool = _current->resource_pool;
400283ac:	0084a783          	lw	a5,8(s1)
}
400283b0:	000b8513          	mv	a0,s7
	new_thread->resource_pool = _current->resource_pool;
400283b4:	0c47a783          	lw	a5,196(a5)
400283b8:	0cf42223          	sw	a5,196(s0)
}
400283bc:	02c12083          	lw	ra,44(sp)
400283c0:	02812403          	lw	s0,40(sp)
400283c4:	02412483          	lw	s1,36(sp)
400283c8:	02012903          	lw	s2,32(sp)
400283cc:	01c12983          	lw	s3,28(sp)
400283d0:	01812a03          	lw	s4,24(sp)
400283d4:	01412a83          	lw	s5,20(sp)
400283d8:	01012b03          	lw	s6,16(sp)
400283dc:	00c12b83          	lw	s7,12(sp)
400283e0:	03010113          	addi	sp,sp,48
400283e4:	00008067          	ret
		new_thread->name[0] = '\0';
400283e8:	08040623          	sb	zero,140(s0)
400283ec:	fc1ff06f          	j	400283ac <z_setup_new_thread+0x10c>

400283f0 <z_impl_k_thread_create>:
{
400283f0:	fe010113          	addi	sp,sp,-32
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
400283f4:	02012303          	lw	t1,32(sp)
{
400283f8:	01212823          	sw	s2,16(sp)
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
400283fc:	00012223          	sw	zero,4(sp)
{
40028400:	02812903          	lw	s2,40(sp)
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
40028404:	00612023          	sw	t1,0(sp)
{
40028408:	00812c23          	sw	s0,24(sp)
4002840c:	00912a23          	sw	s1,20(sp)
40028410:	00112e23          	sw	ra,28(sp)
40028414:	02c12483          	lw	s1,44(sp)
40028418:	00050413          	mv	s0,a0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
4002841c:	e85ff0ef          	jal	ra,400282a0 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
40028420:	fff00693          	li	a3,-1
40028424:	00d91463          	bne	s2,a3,4002842c <z_impl_k_thread_create+0x3c>
40028428:	01248a63          	beq	s1,s2,4002843c <z_impl_k_thread_create+0x4c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
4002842c:	0124e7b3          	or	a5,s1,s2
40028430:	02079463          	bnez	a5,40028458 <z_impl_k_thread_create+0x68>
	z_sched_start(thread);
40028434:	00040513          	mv	a0,s0
40028438:	451010ef          	jal	ra,4002a088 <z_sched_start>
}
4002843c:	01c12083          	lw	ra,28(sp)
40028440:	00040513          	mv	a0,s0
40028444:	01812403          	lw	s0,24(sp)
40028448:	01412483          	lw	s1,20(sp)
4002844c:	01012903          	lw	s2,16(sp)
40028450:	02010113          	addi	sp,sp,32
40028454:	00008067          	ret

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
40028458:	4002a5b7          	lui	a1,0x4002a
4002845c:	00090613          	mv	a2,s2
40028460:	00048693          	mv	a3,s1
40028464:	e2058593          	addi	a1,a1,-480 # 40029e20 <z_thread_timeout>
40028468:	01840513          	addi	a0,s0,24
4002846c:	39c020ef          	jal	ra,4002a808 <z_add_timeout>
40028470:	fcdff06f          	j	4002843c <z_impl_k_thread_create+0x4c>

40028474 <z_init_static_threads>:
{
40028474:	fd010113          	addi	sp,sp,-48
	_FOREACH_STATIC_THREAD(thread_data) {
40028478:	4002c7b7          	lui	a5,0x4002c
{
4002847c:	03212023          	sw	s2,32(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
40028480:	4002c937          	lui	s2,0x4002c
{
40028484:	02812423          	sw	s0,40(sp)
40028488:	02912223          	sw	s1,36(sp)
4002848c:	02112623          	sw	ra,44(sp)
40028490:	01312e23          	sw	s3,28(sp)
40028494:	01412c23          	sw	s4,24(sp)
40028498:	01512a23          	sw	s5,20(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
4002849c:	93478413          	addi	s0,a5,-1740 # 4002b934 <__devicehdl_dts_ord_12>
400284a0:	93478493          	addi	s1,a5,-1740
400284a4:	93490913          	addi	s2,s2,-1740 # 4002b934 <__devicehdl_dts_ord_12>
400284a8:	05246063          	bltu	s0,s2,400284e8 <z_init_static_threads+0x74>
	k_sched_lock();
400284ac:	4f9010ef          	jal	ra,4002a1a4 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
400284b0:	00048413          	mv	s0,s1
		if (thread_data->init_delay != K_TICKS_FOREVER) {
400284b4:	fff00993          	li	s3,-1
		t += off;
400284b8:	00900a13          	li	s4,9
400284bc:	4002aab7          	lui	s5,0x4002a
	_FOREACH_STATIC_THREAD(thread_data) {
400284c0:	07246663          	bltu	s0,s2,4002852c <z_init_static_threads+0xb8>
}
400284c4:	02812403          	lw	s0,40(sp)
400284c8:	02c12083          	lw	ra,44(sp)
400284cc:	02412483          	lw	s1,36(sp)
400284d0:	02012903          	lw	s2,32(sp)
400284d4:	01c12983          	lw	s3,28(sp)
400284d8:	01812a03          	lw	s4,24(sp)
400284dc:	01412a83          	lw	s5,20(sp)
400284e0:	03010113          	addi	sp,sp,48
	k_sched_unlock();
400284e4:	4e50106f          	j	4002a1c8 <k_sched_unlock>
		z_setup_new_thread(
400284e8:	02842783          	lw	a5,40(s0)
400284ec:	00f12223          	sw	a5,4(sp)
400284f0:	02042783          	lw	a5,32(s0)
400284f4:	00f12023          	sw	a5,0(sp)
400284f8:	01442783          	lw	a5,20(s0)
400284fc:	01c42883          	lw	a7,28(s0)
40028500:	01842803          	lw	a6,24(s0)
40028504:	01042703          	lw	a4,16(s0)
40028508:	00c42683          	lw	a3,12(s0)
4002850c:	00842603          	lw	a2,8(s0)
40028510:	00442583          	lw	a1,4(s0)
40028514:	00042503          	lw	a0,0(s0)
40028518:	d89ff0ef          	jal	ra,400282a0 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
4002851c:	00042783          	lw	a5,0(s0)
40028520:	0687a423          	sw	s0,104(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
40028524:	02c40413          	addi	s0,s0,44
40028528:	f81ff06f          	j	400284a8 <z_init_static_threads+0x34>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
4002852c:	02442783          	lw	a5,36(s0)
40028530:	03378863          	beq	a5,s3,40028560 <z_init_static_threads+0xec>
			schedule_new_thread(thread_data->init_thread,
40028534:	00042483          	lw	s1,0(s0)
					    K_MSEC(thread_data->init_delay));
40028538:	0007d463          	bgez	a5,40028540 <z_init_static_threads+0xcc>
4002853c:	00000793          	li	a5,0
40028540:	00978513          	addi	a0,a5,9
40028544:	41f7d713          	srai	a4,a5,0x1f
40028548:	00f535b3          	sltu	a1,a0,a5
4002854c:	00e585b3          	add	a1,a1,a4
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
40028550:	01451c63          	bne	a0,s4,40028568 <z_init_static_threads+0xf4>
40028554:	00059a63          	bnez	a1,40028568 <z_init_static_threads+0xf4>
	z_sched_start(thread);
40028558:	00048513          	mv	a0,s1
4002855c:	32d010ef          	jal	ra,4002a088 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
40028560:	02c40413          	addi	s0,s0,44
40028564:	f5dff06f          	j	400284c0 <z_init_static_threads+0x4c>
			return t / ((uint64_t)from_hz / to_hz);
40028568:	00a00613          	li	a2,10
4002856c:	00000693          	li	a3,0
40028570:	d49d70ef          	jal	ra,400002b8 <__udivdi3>
40028574:	00050613          	mv	a2,a0
40028578:	00058693          	mv	a3,a1
4002857c:	01848513          	addi	a0,s1,24
40028580:	e20a8593          	addi	a1,s5,-480 # 40029e20 <z_thread_timeout>
40028584:	284020ef          	jal	ra,4002a808 <z_add_timeout>
40028588:	fd9ff06f          	j	40028560 <z_init_static_threads+0xec>

4002858c <z_stack_space_get>:
#error "Unsupported configuration for stack analysis"
#endif

int z_stack_space_get(const uint8_t *stack_start, size_t size, size_t *unused_ptr)
{
	size_t unused = 0;
4002858c:	00000793          	li	a5,0
		checked_stack += 4;
		size -= 4;
	}

	for (size_t i = 0; i < size; i++) {
		if ((checked_stack[i]) == 0xaaU) {
40028590:	0aa00713          	li	a4,170
	for (size_t i = 0; i < size; i++) {
40028594:	00b79863          	bne	a5,a1,400285a4 <z_stack_space_get+0x18>
		} else {
			break;
		}
	}

	*unused_ptr = unused;
40028598:	00f62023          	sw	a5,0(a2)

	return 0;
}
4002859c:	00000513          	li	a0,0
400285a0:	00008067          	ret
		if ((checked_stack[i]) == 0xaaU) {
400285a4:	00f506b3          	add	a3,a0,a5
400285a8:	0006c683          	lbu	a3,0(a3)
400285ac:	fee696e3          	bne	a3,a4,40028598 <z_stack_space_get+0xc>
			unused++;
400285b0:	00178793          	addi	a5,a5,1
	for (size_t i = 0; i < size; i++) {
400285b4:	fe1ff06f          	j	40028594 <z_stack_space_get+0x8>

400285b8 <z_impl_k_thread_stack_space_get>:

int z_impl_k_thread_stack_space_get(const struct k_thread *thread,
				    size_t *unused_ptr)
{
400285b8:	00058613          	mv	a2,a1
	return z_stack_space_get((const uint8_t *)thread->stack_info.start,
400285bc:	0b452583          	lw	a1,180(a0)
400285c0:	0b052503          	lw	a0,176(a0)
400285c4:	fc9ff06f          	j	4002858c <z_stack_space_get>

400285c8 <sys_kernel_version_get>:
 * @return kernel version
 */
uint32_t sys_kernel_version_get(void)
{
	return KERNELVERSION;
}
400285c8:	03036537          	lui	a0,0x3036
400285cc:	30050513          	addi	a0,a0,768 # 3036300 <__rom_region_size+0x3005924>
400285d0:	00008067          	ret

400285d4 <idle>:
	sys_clock_idle_exit();
#endif
}

void idle(void *unused1, void *unused2, void *unused3)
{
400285d4:	ff010113          	addi	sp,sp,-16
400285d8:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
400285dc:	300477f3          	csrrci	a5,mstatus,8
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
400285e0:	b80e00ef          	jal	ra,40008960 <arch_cpu_idle>
400285e4:	ff9ff06f          	j	400285dc <idle+0x8>

400285e8 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
400285e8:	fd010113          	addi	sp,sp,-48
400285ec:	02812423          	sw	s0,40(sp)
400285f0:	01312e23          	sw	s3,28(sp)
400285f4:	02112623          	sw	ra,44(sp)
400285f8:	02912223          	sw	s1,36(sp)
400285fc:	03212023          	sw	s2,32(sp)
40028600:	00050413          	mv	s0,a0
40028604:	00068713          	mv	a4,a3

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
40028608:	00850993          	addi	s3,a0,8
4002860c:	30047973          	csrrci	s2,mstatus,8

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
40028610:	02052683          	lw	a3,32(a0)
40028614:	00c52783          	lw	a5,12(a0)
40028618:	0af6f663          	bgeu	a3,a5,400286c4 <z_impl_k_msgq_put+0xdc>
4002861c:	00b12623          	sw	a1,12(sp)
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
40028620:	0a1010ef          	jal	ra,40029ec0 <z_unpend_first_thread>
40028624:	00842603          	lw	a2,8(s0)
		if (pending_thread != NULL) {
40028628:	00c12583          	lw	a1,12(sp)
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
4002862c:	00050493          	mv	s1,a0
		if (pending_thread != NULL) {
40028630:	04050263          	beqz	a0,40028674 <z_impl_k_msgq_put+0x8c>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, 0);

			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
40028634:	01452503          	lw	a0,20(a0)
40028638:	a15e00ef          	jal	ra,4000904c <memcpy>
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
4002863c:	00048513          	mv	a0,s1
	thread->swap_retval = value;
40028640:	0a04ae23          	sw	zero,188(s1)
40028644:	708010ef          	jal	ra,40029d4c <z_ready_thread>
			z_reschedule(&msgq->lock, key);
40028648:	00098513          	mv	a0,s3
4002864c:	00090593          	mv	a1,s2
40028650:	209010ef          	jal	ra,4002a058 <z_reschedule>
			return 0;
40028654:	00000513          	li	a0,0
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
40028658:	02c12083          	lw	ra,44(sp)
4002865c:	02812403          	lw	s0,40(sp)
40028660:	02412483          	lw	s1,36(sp)
40028664:	02012903          	lw	s2,32(sp)
40028668:	01c12983          	lw	s3,28(sp)
4002866c:	03010113          	addi	sp,sp,48
40028670:	00008067          	ret
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
40028674:	01c42503          	lw	a0,28(s0)
40028678:	9d5e00ef          	jal	ra,4000904c <memcpy>
			msgq->write_ptr += msgq->msg_size;
4002867c:	01c42783          	lw	a5,28(s0)
40028680:	00842703          	lw	a4,8(s0)
40028684:	00e787b3          	add	a5,a5,a4
			if (msgq->write_ptr == msgq->buffer_end) {
40028688:	01442703          	lw	a4,20(s0)
			msgq->write_ptr += msgq->msg_size;
4002868c:	00f42e23          	sw	a5,28(s0)
			if (msgq->write_ptr == msgq->buffer_end) {
40028690:	00e79663          	bne	a5,a4,4002869c <z_impl_k_msgq_put+0xb4>
				msgq->write_ptr = msgq->buffer_start;
40028694:	01042783          	lw	a5,16(s0)
40028698:	00f42e23          	sw	a5,28(s0)
			msgq->used_msgs++;
4002869c:	02042783          	lw	a5,32(s0)
	z_handle_obj_poll_events(&msgq->poll_events, state);
400286a0:	02440513          	addi	a0,s0,36
400286a4:	01000593          	li	a1,16
			msgq->used_msgs++;
400286a8:	00178793          	addi	a5,a5,1
400286ac:	02f42023          	sw	a5,32(s0)
	z_handle_obj_poll_events(&msgq->poll_events, state);
400286b0:	71d020ef          	jal	ra,4002b5cc <z_handle_obj_poll_events>
		result = 0;
400286b4:	00000513          	li	a0,0
	__asm__ volatile ("csrs mstatus, %0"
400286b8:	00897913          	andi	s2,s2,8
400286bc:	30092073          	csrs	mstatus,s2
	return result;
400286c0:	f99ff06f          	j	40028658 <z_impl_k_msgq_put+0x70>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
400286c4:	00e667b3          	or	a5,a2,a4
		result = -ENOMSG;
400286c8:	fdd00513          	li	a0,-35
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
400286cc:	fe0786e3          	beqz	a5,400286b8 <z_impl_k_msgq_put+0xd0>
		_current->base.swap_data = (void *) data;
400286d0:	400337b7          	lui	a5,0x40033
400286d4:	8707a783          	lw	a5,-1936(a5) # 40032870 <_kernel+0x8>
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
400286d8:	00060693          	mv	a3,a2
400286dc:	00040613          	mv	a2,s0
		_current->base.swap_data = (void *) data;
400286e0:	00b7aa23          	sw	a1,20(a5)
}
400286e4:	02812403          	lw	s0,40(sp)
400286e8:	02c12083          	lw	ra,44(sp)
400286ec:	02412483          	lw	s1,36(sp)
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
400286f0:	00090593          	mv	a1,s2
400286f4:	00098513          	mv	a0,s3
}
400286f8:	02012903          	lw	s2,32(sp)
400286fc:	01c12983          	lw	s3,28(sp)
40028700:	03010113          	addi	sp,sp,48
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
40028704:	7280106f          	j	40029e2c <z_pend_curr>

40028708 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
40028708:	fe010113          	addi	sp,sp,-32
4002870c:	00812c23          	sw	s0,24(sp)
40028710:	00050413          	mv	s0,a0
40028714:	01312623          	sw	s3,12(sp)
40028718:	00112e23          	sw	ra,28(sp)
4002871c:	00912a23          	sw	s1,20(sp)
40028720:	01212823          	sw	s2,16(sp)
40028724:	00058513          	mv	a0,a1

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
40028728:	00840993          	addi	s3,s0,8
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002872c:	30047973          	csrrci	s2,mstatus,8

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
40028730:	02042783          	lw	a5,32(s0)
40028734:	0c078463          	beqz	a5,400287fc <z_impl_k_msgq_get+0xf4>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
40028738:	00842603          	lw	a2,8(s0)
4002873c:	01842583          	lw	a1,24(s0)
40028740:	90de00ef          	jal	ra,4000904c <memcpy>
		msgq->read_ptr += msgq->msg_size;
40028744:	01842783          	lw	a5,24(s0)
40028748:	00842703          	lw	a4,8(s0)
4002874c:	00e787b3          	add	a5,a5,a4
		if (msgq->read_ptr == msgq->buffer_end) {
40028750:	01442703          	lw	a4,20(s0)
		msgq->read_ptr += msgq->msg_size;
40028754:	00f42c23          	sw	a5,24(s0)
		if (msgq->read_ptr == msgq->buffer_end) {
40028758:	00e79663          	bne	a5,a4,40028764 <z_impl_k_msgq_get+0x5c>
			msgq->read_ptr = msgq->buffer_start;
4002875c:	01042783          	lw	a5,16(s0)
40028760:	00f42c23          	sw	a5,24(s0)
		}
		msgq->used_msgs--;
40028764:	02042783          	lw	a5,32(s0)

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
40028768:	00040513          	mv	a0,s0
		msgq->used_msgs--;
4002876c:	fff78793          	addi	a5,a5,-1
40028770:	02f42023          	sw	a5,32(s0)
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
40028774:	74c010ef          	jal	ra,40029ec0 <z_unpend_first_thread>
40028778:	00050493          	mv	s1,a0

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
		}
		result = 0;
4002877c:	00000793          	li	a5,0
		if (pending_thread != NULL) {
40028780:	0c050263          	beqz	a0,40028844 <z_impl_k_msgq_get+0x13c>
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
40028784:	01452583          	lw	a1,20(a0)
40028788:	00842603          	lw	a2,8(s0)
4002878c:	01c42503          	lw	a0,28(s0)
40028790:	8bde00ef          	jal	ra,4000904c <memcpy>
			msgq->write_ptr += msgq->msg_size;
40028794:	01c42783          	lw	a5,28(s0)
40028798:	00842703          	lw	a4,8(s0)
4002879c:	00e787b3          	add	a5,a5,a4
			if (msgq->write_ptr == msgq->buffer_end) {
400287a0:	01442703          	lw	a4,20(s0)
			msgq->write_ptr += msgq->msg_size;
400287a4:	00f42e23          	sw	a5,28(s0)
			if (msgq->write_ptr == msgq->buffer_end) {
400287a8:	00e79663          	bne	a5,a4,400287b4 <z_impl_k_msgq_get+0xac>
				msgq->write_ptr = msgq->buffer_start;
400287ac:	01042783          	lw	a5,16(s0)
400287b0:	00f42e23          	sw	a5,28(s0)
			msgq->used_msgs++;
400287b4:	02042783          	lw	a5,32(s0)
			z_ready_thread(pending_thread);
400287b8:	00048513          	mv	a0,s1
			msgq->used_msgs++;
400287bc:	00178793          	addi	a5,a5,1
400287c0:	02f42023          	sw	a5,32(s0)
400287c4:	0a04ae23          	sw	zero,188(s1)
			z_ready_thread(pending_thread);
400287c8:	584010ef          	jal	ra,40029d4c <z_ready_thread>
			z_reschedule(&msgq->lock, key);
400287cc:	00090593          	mv	a1,s2
400287d0:	00098513          	mv	a0,s3
400287d4:	085010ef          	jal	ra,4002a058 <z_reschedule>
			return 0;
400287d8:	00000793          	li	a5,0
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
400287dc:	01c12083          	lw	ra,28(sp)
400287e0:	01812403          	lw	s0,24(sp)
400287e4:	01412483          	lw	s1,20(sp)
400287e8:	01012903          	lw	s2,16(sp)
400287ec:	00c12983          	lw	s3,12(sp)
400287f0:	00078513          	mv	a0,a5
400287f4:	02010113          	addi	sp,sp,32
400287f8:	00008067          	ret
400287fc:	00068713          	mv	a4,a3
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
40028800:	00d666b3          	or	a3,a2,a3
		result = -ENOMSG;
40028804:	fdd00793          	li	a5,-35
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
40028808:	02068e63          	beqz	a3,40028844 <z_impl_k_msgq_get+0x13c>
		_current->base.swap_data = data;
4002880c:	400337b7          	lui	a5,0x40033
40028810:	8707a783          	lw	a5,-1936(a5) # 40032870 <_kernel+0x8>
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
40028814:	00060693          	mv	a3,a2
40028818:	00040613          	mv	a2,s0
		_current->base.swap_data = data;
4002881c:	00b7aa23          	sw	a1,20(a5)
}
40028820:	01812403          	lw	s0,24(sp)
40028824:	01c12083          	lw	ra,28(sp)
40028828:	01412483          	lw	s1,20(sp)
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
4002882c:	00090593          	mv	a1,s2
40028830:	00098513          	mv	a0,s3
}
40028834:	01012903          	lw	s2,16(sp)
40028838:	00c12983          	lw	s3,12(sp)
4002883c:	02010113          	addi	sp,sp,32
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
40028840:	5ec0106f          	j	40029e2c <z_pend_curr>
	__asm__ volatile ("csrs mstatus, %0"
40028844:	00897913          	andi	s2,s2,8
40028848:	30092073          	csrs	mstatus,s2
	return result;
4002884c:	f91ff06f          	j	400287dc <z_impl_k_msgq_get+0xd4>

40028850 <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
40028850:	00e50783          	lb	a5,14(a0)
40028854:	00b78463          	beq	a5,a1,4002885c <adjust_owner_prio.isra.0+0xc>
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
40028858:	7040106f          	j	40029f5c <z_set_prio>
	}
	return false;
}
4002885c:	00000513          	li	a0,0
40028860:	00008067          	ret

40028864 <z_impl_k_mutex_init>:
	mutex->owner = NULL;
40028864:	00052423          	sw	zero,8(a0)
	mutex->lock_count = 0U;
40028868:	00052623          	sw	zero,12(a0)
	list->head = (sys_dnode_t *)list;
4002886c:	00a52023          	sw	a0,0(a0)
	list->tail = (sys_dnode_t *)list;
40028870:	00a52223          	sw	a0,4(a0)
}
40028874:	00000513          	li	a0,0
40028878:	00008067          	ret

4002887c <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
4002887c:	fd010113          	addi	sp,sp,-48
40028880:	02812423          	sw	s0,40(sp)
40028884:	02112623          	sw	ra,44(sp)
40028888:	02912223          	sw	s1,36(sp)
4002888c:	03212023          	sw	s2,32(sp)
40028890:	01312e23          	sw	s3,28(sp)
40028894:	00050413          	mv	s0,a0
40028898:	00060713          	mv	a4,a2
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002889c:	300474f3          	csrrci	s1,mstatus,8

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
400288a0:	00c52603          	lw	a2,12(a0)
400288a4:	400337b7          	lui	a5,0x40033
400288a8:	86878793          	addi	a5,a5,-1944 # 40032868 <_kernel>
400288ac:	04060263          	beqz	a2,400288f0 <z_impl_k_mutex_lock+0x74>
400288b0:	00058693          	mv	a3,a1
400288b4:	00852503          	lw	a0,8(a0)
400288b8:	0087a583          	lw	a1,8(a5)
400288bc:	06b50063          	beq	a0,a1,4002891c <z_impl_k_mutex_lock+0xa0>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
400288c0:	00e6e7b3          	or	a5,a3,a4
400288c4:	06079063          	bnez	a5,40028924 <z_impl_k_mutex_lock+0xa8>
	__asm__ volatile ("csrs mstatus, %0"
400288c8:	0084f493          	andi	s1,s1,8
400288cc:	3004a073          	csrs	mstatus,s1
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
400288d0:	ff000513          	li	a0,-16
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
400288d4:	02c12083          	lw	ra,44(sp)
400288d8:	02812403          	lw	s0,40(sp)
400288dc:	02412483          	lw	s1,36(sp)
400288e0:	02012903          	lw	s2,32(sp)
400288e4:	01c12983          	lw	s3,28(sp)
400288e8:	03010113          	addi	sp,sp,48
400288ec:	00008067          	ret
					_current->base.prio :
400288f0:	0087a703          	lw	a4,8(a5)
400288f4:	00e70703          	lb	a4,14(a4)
		mutex->owner = _current;
400288f8:	0087a783          	lw	a5,8(a5)
		mutex->lock_count++;
400288fc:	00160613          	addi	a2,a2,1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
40028900:	00e42823          	sw	a4,16(s0)
		mutex->lock_count++;
40028904:	00c42623          	sw	a2,12(s0)
		mutex->owner = _current;
40028908:	00f42423          	sw	a5,8(s0)
4002890c:	0084f493          	andi	s1,s1,8
40028910:	3004a073          	csrs	mstatus,s1
		return 0;
40028914:	00000513          	li	a0,0
40028918:	fbdff06f          	j	400288d4 <z_impl_k_mutex_lock+0x58>
					_current->base.prio :
4002891c:	01042703          	lw	a4,16(s0)
40028920:	fd9ff06f          	j	400288f8 <z_impl_k_mutex_lock+0x7c>
	new_prio = new_prio_for_inheritance(_current->base.prio,
40028924:	00e50783          	lb	a5,14(a0)
40028928:	00e58583          	lb	a1,14(a1)
	return prio >= CONFIG_PRIORITY_CEILING;
}

static inline int z_get_new_prio_with_ceiling(int prio)
{
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
4002892c:	00b7d463          	bge	a5,a1,40028934 <z_impl_k_mutex_lock+0xb8>
40028930:	00078593          	mv	a1,a5
40028934:	f8100613          	li	a2,-127
40028938:	00c5d463          	bge	a1,a2,40028940 <z_impl_k_mutex_lock+0xc4>
4002893c:	f8100593          	li	a1,-127
	bool resched = false;
40028940:	00000913          	li	s2,0
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
40028944:	00f5de63          	bge	a1,a5,40028960 <z_impl_k_mutex_lock+0xe4>
40028948:	00e12623          	sw	a4,12(sp)
4002894c:	00d12423          	sw	a3,8(sp)
		resched = adjust_owner_prio(mutex, new_prio);
40028950:	f01ff0ef          	jal	ra,40028850 <adjust_owner_prio.isra.0>
40028954:	00c12703          	lw	a4,12(sp)
40028958:	00812683          	lw	a3,8(sp)
4002895c:	00050913          	mv	s2,a0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
40028960:	400339b7          	lui	s3,0x40033
40028964:	00040613          	mv	a2,s0
40028968:	00048593          	mv	a1,s1
4002896c:	88c98513          	addi	a0,s3,-1908 # 4003288c <sched_spinlock>
40028970:	4bc010ef          	jal	ra,40029e2c <z_pend_curr>
	if (got_mutex == 0) {
40028974:	fa0500e3          	beqz	a0,40028914 <z_impl_k_mutex_lock+0x98>
	__asm__ volatile ("csrrc %0, mstatus, %1"
40028978:	300474f3          	csrrci	s1,mstatus,8
	if (likely(mutex->owner != NULL)) {
4002897c:	00842503          	lw	a0,8(s0)
40028980:	04050463          	beqz	a0,400289c8 <z_impl_k_mutex_lock+0x14c>
	return list->head == list;
40028984:	00042783          	lw	a5,0(s0)
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
40028988:	01042583          	lw	a1,16(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002898c:	02f40063          	beq	s0,a5,400289ac <z_impl_k_mutex_lock+0x130>
40028990:	00078e63          	beqz	a5,400289ac <z_impl_k_mutex_lock+0x130>
40028994:	00e78783          	lb	a5,14(a5)
40028998:	00b7d463          	bge	a5,a1,400289a0 <z_impl_k_mutex_lock+0x124>
4002899c:	00078593          	mv	a1,a5
400289a0:	f8100793          	li	a5,-127
400289a4:	00f5d463          	bge	a1,a5,400289ac <z_impl_k_mutex_lock+0x130>
400289a8:	f8100593          	li	a1,-127
		resched = adjust_owner_prio(mutex, new_prio) || resched;
400289ac:	ea5ff0ef          	jal	ra,40028850 <adjust_owner_prio.isra.0>
400289b0:	00050c63          	beqz	a0,400289c8 <z_impl_k_mutex_lock+0x14c>
		z_reschedule(&lock, key);
400289b4:	00048593          	mv	a1,s1
400289b8:	88c98513          	addi	a0,s3,-1908
400289bc:	69c010ef          	jal	ra,4002a058 <z_reschedule>
	return -EAGAIN;
400289c0:	ff500513          	li	a0,-11
400289c4:	f11ff06f          	j	400288d4 <z_impl_k_mutex_lock+0x58>
	if (resched) {
400289c8:	fe0916e3          	bnez	s2,400289b4 <z_impl_k_mutex_lock+0x138>
	__asm__ volatile ("csrs mstatus, %0"
400289cc:	0084f493          	andi	s1,s1,8
400289d0:	3004a073          	csrs	mstatus,s1
400289d4:	fedff06f          	j	400289c0 <z_impl_k_mutex_lock+0x144>

400289d8 <z_impl_k_mutex_unlock>:

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
400289d8:	00852783          	lw	a5,8(a0)
400289dc:	0a078463          	beqz	a5,40028a84 <z_impl_k_mutex_unlock+0xac>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
400289e0:	40033737          	lui	a4,0x40033
400289e4:	87072703          	lw	a4,-1936(a4) # 40032870 <_kernel+0x8>
{
400289e8:	ff010113          	addi	sp,sp,-16
400289ec:	00812423          	sw	s0,8(sp)
400289f0:	00112623          	sw	ra,12(sp)
400289f4:	00912223          	sw	s1,4(sp)
400289f8:	00050413          	mv	s0,a0
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EPERM);

		return -EPERM;
400289fc:	fff00513          	li	a0,-1
	CHECKIF(mutex->owner != _current) {
40028a00:	00e79e63          	bne	a5,a4,40028a1c <z_impl_k_mutex_unlock+0x44>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
40028a04:	00c42783          	lw	a5,12(s0)
40028a08:	00100713          	li	a4,1
40028a0c:	02f77263          	bgeu	a4,a5,40028a30 <z_impl_k_mutex_unlock+0x58>
		mutex->lock_count--;
40028a10:	fff78793          	addi	a5,a5,-1
40028a14:	00f42623          	sw	a5,12(s0)


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
40028a18:	00000513          	li	a0,0
}
40028a1c:	00c12083          	lw	ra,12(sp)
40028a20:	00812403          	lw	s0,8(sp)
40028a24:	00412483          	lw	s1,4(sp)
40028a28:	01010113          	addi	sp,sp,16
40028a2c:	00008067          	ret
	__asm__ volatile ("csrrc %0, mstatus, %1"
40028a30:	300474f3          	csrrci	s1,mstatus,8
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
40028a34:	01042583          	lw	a1,16(s0)
40028a38:	00842503          	lw	a0,8(s0)
40028a3c:	e15ff0ef          	jal	ra,40028850 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
40028a40:	00040513          	mv	a0,s0
40028a44:	47c010ef          	jal	ra,40029ec0 <z_unpend_first_thread>
	mutex->owner = new_owner;
40028a48:	00a42423          	sw	a0,8(s0)
	if (new_owner != NULL) {
40028a4c:	02050463          	beqz	a0,40028a74 <z_impl_k_mutex_unlock+0x9c>
		mutex->owner_orig_prio = new_owner->base.prio;
40028a50:	00e50703          	lb	a4,14(a0)
40028a54:	00e42823          	sw	a4,16(s0)
40028a58:	0a052e23          	sw	zero,188(a0)
		z_ready_thread(new_owner);
40028a5c:	2f0010ef          	jal	ra,40029d4c <z_ready_thread>
		z_reschedule(&lock, key);
40028a60:	40033537          	lui	a0,0x40033
40028a64:	00048593          	mv	a1,s1
40028a68:	88c50513          	addi	a0,a0,-1908 # 4003288c <sched_spinlock>
40028a6c:	5ec010ef          	jal	ra,4002a058 <z_reschedule>
40028a70:	fa9ff06f          	j	40028a18 <z_impl_k_mutex_unlock+0x40>
		mutex->lock_count = 0U;
40028a74:	00042623          	sw	zero,12(s0)
	__asm__ volatile ("csrs mstatus, %0"
40028a78:	0084f493          	andi	s1,s1,8
40028a7c:	3004a073          	csrs	mstatus,s1
40028a80:	f99ff06f          	j	40028a18 <z_impl_k_mutex_unlock+0x40>
		return -EINVAL;
40028a84:	fea00513          	li	a0,-22
}
40028a88:	00008067          	ret

40028a8c <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
40028a8c:	fe010113          	addi	sp,sp,-32
40028a90:	00812c23          	sw	s0,24(sp)
40028a94:	01212823          	sw	s2,16(sp)
40028a98:	01412423          	sw	s4,8(sp)
40028a9c:	01512223          	sw	s5,4(sp)
40028aa0:	00112e23          	sw	ra,28(sp)
40028aa4:	00912a23          	sw	s1,20(sp)
40028aa8:	01312623          	sw	s3,12(sp)
40028aac:	00050413          	mv	s0,a0
40028ab0:	00060913          	mv	s2,a2
40028ab4:	00068a93          	mv	s5,a3
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
40028ab8:	00850a13          	addi	s4,a0,8
	__asm__ volatile ("csrrc %0, mstatus, %1"
40028abc:	300479f3          	csrrci	s3,mstatus,8

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
40028ac0:	00058493          	mv	s1,a1
40028ac4:	00070463          	beqz	a4,40028acc <queue_insert+0x40>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
40028ac8:	00452483          	lw	s1,4(a0)
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
40028acc:	000a0513          	mv	a0,s4
40028ad0:	3f0010ef          	jal	ra,40029ec0 <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
40028ad4:	02050263          	beqz	a0,40028af8 <queue_insert+0x6c>
40028ad8:	0a052e23          	sw	zero,188(a0)
	thread->base.swap_data = data;
40028adc:	01252a23          	sw	s2,20(a0)
	z_ready_thread(thread);
40028ae0:	26c010ef          	jal	ra,40029d4c <z_ready_thread>

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
40028ae4:	000a0513          	mv	a0,s4
40028ae8:	00098593          	mv	a1,s3
40028aec:	56c010ef          	jal	ra,4002a058 <z_reschedule>
		return 0;
40028af0:	00000513          	li	a0,0
40028af4:	0200006f          	j	40028b14 <queue_insert+0x88>
	if (alloc) {
40028af8:	060a8c63          	beqz	s5,40028b70 <queue_insert+0xe4>
	return z_thread_aligned_alloc(0, size);
40028afc:	00800593          	li	a1,8
40028b00:	429020ef          	jal	ra,4002b728 <z_thread_aligned_alloc>
		if (anode == NULL) {
40028b04:	02051a63          	bnez	a0,40028b38 <queue_insert+0xac>
	__asm__ volatile ("csrs mstatus, %0"
40028b08:	0089f993          	andi	s3,s3,8
40028b0c:	3009a073          	csrs	mstatus,s3
			return -ENOMEM;
40028b10:	ff400513          	li	a0,-12

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
}
40028b14:	01c12083          	lw	ra,28(sp)
40028b18:	01812403          	lw	s0,24(sp)
40028b1c:	01412483          	lw	s1,20(sp)
40028b20:	01012903          	lw	s2,16(sp)
40028b24:	00c12983          	lw	s3,12(sp)
40028b28:	00812a03          	lw	s4,8(sp)
40028b2c:	00412a83          	lw	s5,4(sp)
40028b30:	02010113          	addi	sp,sp,32
40028b34:	00008067          	ret
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
40028b38:	00100793          	li	a5,1
		anode->data = data;
40028b3c:	01252223          	sw	s2,4(a0)
40028b40:	00f52023          	sw	a5,0(a0)
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
40028b44:	00052703          	lw	a4,0(a0)
	parent->next_and_flags = cur_flags | (unative_t)child;
40028b48:	00377713          	andi	a4,a4,3
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
40028b4c:	02049863          	bnez	s1,40028b7c <queue_insert+0xf0>
	parent->next_and_flags = cur_flags | (unative_t)child;
40028b50:	00042783          	lw	a5,0(s0)
40028b54:	00e7e7b3          	or	a5,a5,a4
40028b58:	00f52023          	sw	a5,0(a0)
Z_GENLIST_PREPEND(sflist, sfnode)
40028b5c:	00442783          	lw	a5,4(s0)
	list->head = node;
40028b60:	00a42023          	sw	a0,0(s0)
Z_GENLIST_PREPEND(sflist, sfnode)
40028b64:	02079c63          	bnez	a5,40028b9c <queue_insert+0x110>
	list->tail = node;
40028b68:	00a42223          	sw	a0,4(s0)
}
40028b6c:	0300006f          	j	40028b9c <queue_insert+0x110>
	node->next_and_flags = flags;
40028b70:	00092023          	sw	zero,0(s2)
}
40028b74:	00090513          	mv	a0,s2
40028b78:	fcdff06f          	j	40028b44 <queue_insert+0xb8>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
40028b7c:	0004a783          	lw	a5,0(s1)
Z_GENLIST_INSERT(sflist, sfnode)
40028b80:	00300693          	li	a3,3
40028b84:	02f6ee63          	bltu	a3,a5,40028bc0 <queue_insert+0x134>
	parent->next_and_flags = cur_flags | (unative_t)child;
40028b88:	00e52023          	sw	a4,0(a0)
	return list->tail;
40028b8c:	00442703          	lw	a4,4(s0)
Z_GENLIST_APPEND(sflist, sfnode)
40028b90:	00071e63          	bnez	a4,40028bac <queue_insert+0x120>
	list->tail = node;
40028b94:	00a42223          	sw	a0,4(s0)
	list->head = node;
40028b98:	00a42023          	sw	a0,0(s0)
	z_handle_obj_poll_events(&queue->poll_events, state);
40028b9c:	00400593          	li	a1,4
40028ba0:	01040513          	addi	a0,s0,16
40028ba4:	229020ef          	jal	ra,4002b5cc <z_handle_obj_poll_events>
40028ba8:	f3dff06f          	j	40028ae4 <queue_insert+0x58>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
40028bac:	00072783          	lw	a5,0(a4)
	parent->next_and_flags = cur_flags | (unative_t)child;
40028bb0:	0037f793          	andi	a5,a5,3
40028bb4:	00f567b3          	or	a5,a0,a5
40028bb8:	00f72023          	sw	a5,0(a4)
40028bbc:	fadff06f          	j	40028b68 <queue_insert+0xdc>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
40028bc0:	ffc7f793          	andi	a5,a5,-4
	parent->next_and_flags = cur_flags | (unative_t)child;
40028bc4:	00e7e7b3          	or	a5,a5,a4
40028bc8:	00f52023          	sw	a5,0(a0)
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
40028bcc:	0004a783          	lw	a5,0(s1)
	parent->next_and_flags = cur_flags | (unative_t)child;
40028bd0:	0037f793          	andi	a5,a5,3
40028bd4:	00f567b3          	or	a5,a0,a5
40028bd8:	00f4a023          	sw	a5,0(s1)
}
40028bdc:	fc1ff06f          	j	40028b9c <queue_insert+0x110>

40028be0 <z_queue_node_peek>:
{
40028be0:	ff010113          	addi	sp,sp,-16
40028be4:	00812423          	sw	s0,8(sp)
40028be8:	00112623          	sw	ra,12(sp)
40028bec:	00050413          	mv	s0,a0
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
40028bf0:	00050e63          	beqz	a0,40028c0c <z_queue_node_peek+0x2c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
40028bf4:	00052703          	lw	a4,0(a0)
40028bf8:	00377713          	andi	a4,a4,3
40028bfc:	00070863          	beqz	a4,40028c0c <z_queue_node_peek+0x2c>
		ret = anode->data;
40028c00:	00452403          	lw	s0,4(a0)
		if (needs_free) {
40028c04:	00058463          	beqz	a1,40028c0c <z_queue_node_peek+0x2c>
			k_free(anode);
40028c08:	2fd020ef          	jal	ra,4002b704 <k_free>
}
40028c0c:	00c12083          	lw	ra,12(sp)
40028c10:	00040513          	mv	a0,s0
40028c14:	00812403          	lw	s0,8(sp)
40028c18:	01010113          	addi	sp,sp,16
40028c1c:	00008067          	ret

40028c20 <z_impl_k_queue_init>:
40028c20:	00850793          	addi	a5,a0,8
	list->head = (sys_dnode_t *)list;
40028c24:	00f52423          	sw	a5,8(a0)
	list->tail = (sys_dnode_t *)list;
40028c28:	00f52623          	sw	a5,12(a0)
	sys_dlist_init(&queue->poll_events);
40028c2c:	01050793          	addi	a5,a0,16
	list->head = NULL;
40028c30:	00052023          	sw	zero,0(a0)
	list->tail = NULL;
40028c34:	00052223          	sw	zero,4(a0)
	list->head = (sys_dnode_t *)list;
40028c38:	00f52823          	sw	a5,16(a0)
	list->tail = (sys_dnode_t *)list;
40028c3c:	00f52a23          	sw	a5,20(a0)
}
40028c40:	00008067          	ret

40028c44 <k_queue_append>:

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, insert, queue);
}

void k_queue_append(struct k_queue *queue, void *data)
{
40028c44:	00058613          	mv	a2,a1
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, append, queue);

	(void)queue_insert(queue, NULL, data, false, true);
40028c48:	00100713          	li	a4,1
40028c4c:	00000693          	li	a3,0
40028c50:	00000593          	li	a1,0
40028c54:	e39ff06f          	j	40028a8c <queue_insert>

40028c58 <k_queue_prepend>:

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append, queue);
}

void k_queue_prepend(struct k_queue *queue, void *data)
{
40028c58:	00058613          	mv	a2,a1
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, prepend, queue);

	(void)queue_insert(queue, NULL, data, false, false);
40028c5c:	00000713          	li	a4,0
40028c60:	00000693          	li	a3,0
40028c64:	00000593          	li	a1,0
40028c68:	e25ff06f          	j	40028a8c <queue_insert>

40028c6c <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
40028c6c:	ff010113          	addi	sp,sp,-16
40028c70:	00112623          	sw	ra,12(sp)
40028c74:	00812423          	sw	s0,8(sp)
40028c78:	00912223          	sw	s1,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40028c7c:	300474f3          	csrrci	s1,mstatus,8
	return list->head;
40028c80:	00052403          	lw	s0,0(a0)
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
40028c84:	04040663          	beqz	s0,40028cd0 <z_impl_k_queue_get+0x64>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
40028c88:	00042783          	lw	a5,0(s0)
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
40028c8c:	00452703          	lw	a4,4(a0)
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
40028c90:	ffc7f793          	andi	a5,a5,-4
	list->head = node;
40028c94:	00f52023          	sw	a5,0(a0)
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
40028c98:	00e41463          	bne	s0,a4,40028ca0 <z_impl_k_queue_get+0x34>
	list->tail = node;
40028c9c:	00f52223          	sw	a5,4(a0)
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
40028ca0:	00040513          	mv	a0,s0
40028ca4:	00100593          	li	a1,1
40028ca8:	f39ff0ef          	jal	ra,40028be0 <z_queue_node_peek>
40028cac:	00050413          	mv	s0,a0
	__asm__ volatile ("csrs mstatus, %0"
40028cb0:	0084f493          	andi	s1,s1,8
40028cb4:	3004a073          	csrs	mstatus,s1

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
40028cb8:	00c12083          	lw	ra,12(sp)
40028cbc:	00040513          	mv	a0,s0
40028cc0:	00812403          	lw	s0,8(sp)
40028cc4:	00412483          	lw	s1,4(sp)
40028cc8:	01010113          	addi	sp,sp,16
40028ccc:	00008067          	ret
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
40028cd0:	00c5e7b3          	or	a5,a1,a2
40028cd4:	00058693          	mv	a3,a1
40028cd8:	00060713          	mv	a4,a2
40028cdc:	fc078ae3          	beqz	a5,40028cb0 <z_impl_k_queue_get+0x44>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
40028ce0:	00850613          	addi	a2,a0,8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
40028ce4:	00048593          	mv	a1,s1
40028ce8:	00060513          	mv	a0,a2
40028cec:	140010ef          	jal	ra,40029e2c <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
40028cf0:	fc0514e3          	bnez	a0,40028cb8 <z_impl_k_queue_get+0x4c>
40028cf4:	400337b7          	lui	a5,0x40033
40028cf8:	8707a783          	lw	a5,-1936(a5) # 40032870 <_kernel+0x8>
40028cfc:	0147a403          	lw	s0,20(a5)
40028d00:	fb9ff06f          	j	40028cb8 <z_impl_k_queue_get+0x4c>

40028d04 <k_queue_unique_append>:
	return list->head;
40028d04:	00052783          	lw	a5,0(a0)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, unique_append, queue);

	sys_sfnode_t *test;

	SYS_SFLIST_FOR_EACH_NODE(&queue->data_q, test) {
40028d08:	02079063          	bnez	a5,40028d28 <k_queue_unique_append+0x24>
{
40028d0c:	ff010113          	addi	sp,sp,-16
40028d10:	00112623          	sw	ra,12(sp)

			return false;
		}
	}

	k_queue_append(queue, data);
40028d14:	f31ff0ef          	jal	ra,40028c44 <k_queue_append>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, unique_append, queue, true);

	return true;
}
40028d18:	00c12083          	lw	ra,12(sp)
	return true;
40028d1c:	00100513          	li	a0,1
}
40028d20:	01010113          	addi	sp,sp,16
40028d24:	00008067          	ret
		if (test == (sys_sfnode_t *) data) {
40028d28:	00b78863          	beq	a5,a1,40028d38 <k_queue_unique_append+0x34>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
40028d2c:	0007a783          	lw	a5,0(a5)
40028d30:	ffc7f793          	andi	a5,a5,-4
40028d34:	fd5ff06f          	j	40028d08 <k_queue_unique_append+0x4>
			return false;
40028d38:	00000513          	li	a0,0
}
40028d3c:	00008067          	ret

40028d40 <z_impl_k_queue_peek_head>:

void *z_impl_k_queue_peek_head(struct k_queue *queue)
{
	void *ret = z_queue_node_peek(sys_sflist_peek_head(&queue->data_q), false);
40028d40:	00052503          	lw	a0,0(a0)
40028d44:	00000593          	li	a1,0
40028d48:	e99ff06f          	j	40028be0 <z_queue_node_peek>

40028d4c <z_impl_k_sem_init>:
 */
static struct k_spinlock lock;

int z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,
		      unsigned int limit)
{
40028d4c:	00050793          	mv	a5,a0
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
		SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, -EINVAL);

		return -EINVAL;
40028d50:	fea00513          	li	a0,-22
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
40028d54:	02060663          	beqz	a2,40028d80 <z_impl_k_sem_init+0x34>
40028d58:	02b66463          	bltu	a2,a1,40028d80 <z_impl_k_sem_init+0x34>

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);

	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
40028d5c:	01078713          	addi	a4,a5,16
	sem->count = initial_count;
40028d60:	00b7a423          	sw	a1,8(a5)
	sem->limit = limit;
40028d64:	00c7a623          	sw	a2,12(a5)
	list->head = (sys_dnode_t *)list;
40028d68:	00f7a023          	sw	a5,0(a5)
	list->tail = (sys_dnode_t *)list;
40028d6c:	00f7a223          	sw	a5,4(a5)
	list->head = (sys_dnode_t *)list;
40028d70:	00e7a823          	sw	a4,16(a5)
	list->tail = (sys_dnode_t *)list;
40028d74:	00e7aa23          	sw	a4,20(a5)
#endif
	z_object_init(sem);

	return 0;
40028d78:	00000513          	li	a0,0
40028d7c:	00008067          	ret
}
40028d80:	00008067          	ret

40028d84 <z_impl_k_sem_give>:
	return false;
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
40028d84:	ff010113          	addi	sp,sp,-16
40028d88:	00812423          	sw	s0,8(sp)
40028d8c:	00112623          	sw	ra,12(sp)
40028d90:	00912223          	sw	s1,4(sp)
40028d94:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40028d98:	300474f3          	csrrci	s1,mstatus,8
	struct k_thread *thread;
	bool resched = true;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
40028d9c:	124010ef          	jal	ra,40029ec0 <z_unpend_first_thread>

	if (thread != NULL) {
40028da0:	02050663          	beqz	a0,40028dcc <z_impl_k_sem_give+0x48>
	thread->swap_retval = value;
40028da4:	0a052e23          	sw	zero,188(a0)
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
40028da8:	7a5000ef          	jal	ra,40029d4c <z_ready_thread>
	} else {
		k_spin_unlock(&lock, key);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
40028dac:	00812403          	lw	s0,8(sp)
40028db0:	00c12083          	lw	ra,12(sp)
		z_reschedule(&lock, key);
40028db4:	00048593          	mv	a1,s1
}
40028db8:	00412483          	lw	s1,4(sp)
		z_reschedule(&lock, key);
40028dbc:	40033537          	lui	a0,0x40033
40028dc0:	88c50513          	addi	a0,a0,-1908 # 4003288c <sched_spinlock>
}
40028dc4:	01010113          	addi	sp,sp,16
		z_reschedule(&lock, key);
40028dc8:	2900106f          	j	4002a058 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
40028dcc:	00842703          	lw	a4,8(s0)
40028dd0:	00c42783          	lw	a5,12(s0)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
40028dd4:	00200593          	li	a1,2
40028dd8:	01040513          	addi	a0,s0,16
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
40028ddc:	40e787b3          	sub	a5,a5,a4
40028de0:	00f037b3          	snez	a5,a5
40028de4:	00e787b3          	add	a5,a5,a4
40028de8:	00f42423          	sw	a5,8(s0)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
40028dec:	7e0020ef          	jal	ra,4002b5cc <z_handle_obj_poll_events>
	return true;
40028df0:	fbdff06f          	j	40028dac <z_impl_k_sem_give+0x28>

40028df4 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
40028df4:	00058693          	mv	a3,a1
40028df8:	00060713          	mv	a4,a2
40028dfc:	300475f3          	csrrci	a1,mstatus,8

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
40028e00:	00852783          	lw	a5,8(a0)
40028e04:	00078e63          	beqz	a5,40028e20 <z_impl_k_sem_take+0x2c>
		sem->count--;
40028e08:	fff78793          	addi	a5,a5,-1
40028e0c:	00f52423          	sw	a5,8(a0)
	__asm__ volatile ("csrs mstatus, %0"
40028e10:	0085f593          	andi	a1,a1,8
40028e14:	3005a073          	csrs	mstatus,a1
		k_spin_unlock(&lock, key);
		ret = 0;
40028e18:	00000513          	li	a0,0
		goto out;
40028e1c:	00008067          	ret
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
40028e20:	00c6e7b3          	or	a5,a3,a2
40028e24:	00079a63          	bnez	a5,40028e38 <z_impl_k_sem_take+0x44>
40028e28:	0085f593          	andi	a1,a1,8
40028e2c:	3005a073          	csrs	mstatus,a1
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
40028e30:	ff000513          	li	a0,-16

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
40028e34:	00008067          	ret
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
40028e38:	00050613          	mv	a2,a0
40028e3c:	40033537          	lui	a0,0x40033
40028e40:	88c50513          	addi	a0,a0,-1908 # 4003288c <sched_spinlock>
40028e44:	7e90006f          	j	40029e2c <z_pend_curr>

40028e48 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
40028e48:	ff010113          	addi	sp,sp,-16
40028e4c:	00812423          	sw	s0,8(sp)
40028e50:	00112623          	sw	ra,12(sp)
40028e54:	00912223          	sw	s1,4(sp)
40028e58:	01212023          	sw	s2,0(sp)
40028e5c:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40028e60:	300474f3          	csrrci	s1,mstatus,8
40028e64:	ff500913          	li	s2,-11
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
40028e68:	00040513          	mv	a0,s0
40028e6c:	054010ef          	jal	ra,40029ec0 <z_unpend_first_thread>
		if (thread == NULL) {
40028e70:	00050863          	beqz	a0,40028e80 <z_impl_k_sem_reset+0x38>
40028e74:	0b252e23          	sw	s2,188(a0)
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
40028e78:	6d5000ef          	jal	ra,40029d4c <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
40028e7c:	fedff06f          	j	40028e68 <z_impl_k_sem_reset+0x20>
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
40028e80:	01040513          	addi	a0,s0,16
	}
	sem->count = 0;
40028e84:	00042423          	sw	zero,8(s0)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
40028e88:	00200593          	li	a1,2
40028e8c:	740020ef          	jal	ra,4002b5cc <z_handle_obj_poll_events>
	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
}
40028e90:	00812403          	lw	s0,8(sp)
40028e94:	00c12083          	lw	ra,12(sp)
40028e98:	00012903          	lw	s2,0(sp)
	z_reschedule(&lock, key);
40028e9c:	00048593          	mv	a1,s1
}
40028ea0:	00412483          	lw	s1,4(sp)
	z_reschedule(&lock, key);
40028ea4:	40033537          	lui	a0,0x40033
40028ea8:	88c50513          	addi	a0,a0,-1908 # 4003288c <sched_spinlock>
}
40028eac:	01010113          	addi	sp,sp,16
	z_reschedule(&lock, key);
40028eb0:	1a80106f          	j	4002a058 <z_reschedule>

40028eb4 <flag_test_and_clear>:
}

static inline bool flag_test(const uint32_t *flagp,
			     uint32_t bit)
{
	return (*flagp & BIT(bit)) != 0U;
40028eb4:	00052703          	lw	a4,0(a0)
	*flagp &= ~BIT(bit);
40028eb8:	00100793          	li	a5,1
40028ebc:	00b797b3          	sll	a5,a5,a1
40028ec0:	fff7c793          	not	a5,a5
40028ec4:	00e7f7b3          	and	a5,a5,a4
40028ec8:	00f52023          	sw	a5,0(a0)
	return (*flagp & BIT(bit)) != 0U;
40028ecc:	00b75533          	srl	a0,a4,a1
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
40028ed0:	00157513          	andi	a0,a0,1
40028ed4:	00008067          	ret

40028ed8 <unschedule_locked>:
 *
 * @return true if and only if work had been delayed so the timeout
 * was cancelled.
 */
static inline bool unschedule_locked(struct k_work_delayable *dwork)
{
40028ed8:	ff010113          	addi	sp,sp,-16
40028edc:	00812423          	sw	s0,8(sp)
	/* If scheduled, try to cancel.  If it fails, that means the
	 * callback has been dequeued and will inevitably run (or has
	 * already run), so treat that as "undelayed" and return
	 * false.
	 */
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
40028ee0:	00300593          	li	a1,3
{
40028ee4:	00050413          	mv	s0,a0
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
40028ee8:	00c50513          	addi	a0,a0,12
{
40028eec:	00112623          	sw	ra,12(sp)
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
40028ef0:	fc5ff0ef          	jal	ra,40028eb4 <flag_test_and_clear>
40028ef4:	00050863          	beqz	a0,40028f04 <unschedule_locked+0x2c>
		ret = z_abort_timeout(&dwork->timeout) == 0;
40028ef8:	01040513          	addi	a0,s0,16
40028efc:	2ad010ef          	jal	ra,4002a9a8 <z_abort_timeout>
40028f00:	00153513          	seqz	a0,a0
	}

	return ret;
}
40028f04:	00c12083          	lw	ra,12(sp)
40028f08:	00812403          	lw	s0,8(sp)
40028f0c:	01010113          	addi	sp,sp,16
40028f10:	00008067          	ret

40028f14 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
40028f14:	00050a63          	beqz	a0,40028f28 <notify_queue_locked.isra.0+0x14>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
40028f18:	00000613          	li	a2,0
40028f1c:	00000593          	li	a1,0
40028f20:	0d050513          	addi	a0,a0,208
40028f24:	6b80106f          	j	4002a5dc <z_sched_wake>
}
40028f28:	00008067          	ret

40028f2c <cancel_async_locked>:
{
40028f2c:	ff010113          	addi	sp,sp,-16
40028f30:	00812423          	sw	s0,8(sp)
40028f34:	00112623          	sw	ra,12(sp)
40028f38:	00912223          	sw	s1,4(sp)
	return (*flagp & BIT(bit)) != 0U;
40028f3c:	00c52783          	lw	a5,12(a0)
{
40028f40:	00050413          	mv	s0,a0
	return (*flagp & BIT(bit)) != 0U;
40028f44:	0017d793          	srli	a5,a5,0x1
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
40028f48:	0017f793          	andi	a5,a5,1
40028f4c:	04079263          	bnez	a5,40028f90 <cancel_async_locked+0x64>
		queue_remove_locked(work->queue, work);
40028f50:	00852483          	lw	s1,8(a0)
	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
40028f54:	00200593          	li	a1,2
40028f58:	00c50513          	addi	a0,a0,12
40028f5c:	f59ff0ef          	jal	ra,40028eb4 <flag_test_and_clear>
40028f60:	02050863          	beqz	a0,40028f90 <cancel_async_locked+0x64>
	return list->head;
40028f64:	0c84a783          	lw	a5,200(s1)
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40028f68:	00000713          	li	a4,0
40028f6c:	02078263          	beqz	a5,40028f90 <cancel_async_locked+0x64>
40028f70:	06f41263          	bne	s0,a5,40028fd4 <cancel_async_locked+0xa8>
	return node->next;
40028f74:	00042783          	lw	a5,0(s0)
Z_GENLIST_REMOVE(slist, snode)
40028f78:	04071463          	bnez	a4,40028fc0 <cancel_async_locked+0x94>
40028f7c:	0cc4a703          	lw	a4,204(s1)
	list->head = node;
40028f80:	0cf4a423          	sw	a5,200(s1)
Z_GENLIST_REMOVE(slist, snode)
40028f84:	00e41463          	bne	s0,a4,40028f8c <cancel_async_locked+0x60>
	list->tail = node;
40028f88:	0cf4a623          	sw	a5,204(s1)
	parent->next = child;
40028f8c:	00042023          	sw	zero,0(s0)
	return *flagp;
40028f90:	00c42783          	lw	a5,12(s0)
40028f94:	00000513          	li	a0,0
40028f98:	00f7f713          	andi	a4,a5,15
	if (ret != 0) {
40028f9c:	00070863          	beqz	a4,40028fac <cancel_async_locked+0x80>
	*flagp |= BIT(bit);
40028fa0:	0027e793          	ori	a5,a5,2
40028fa4:	00f42623          	sw	a5,12(s0)
	return flags_get(&work->flags) & K_WORK_MASK;
40028fa8:	00276513          	ori	a0,a4,2
}
40028fac:	00c12083          	lw	ra,12(sp)
40028fb0:	00812403          	lw	s0,8(sp)
40028fb4:	00412483          	lw	s1,4(sp)
40028fb8:	01010113          	addi	sp,sp,16
40028fbc:	00008067          	ret
40028fc0:	00f72023          	sw	a5,0(a4)
Z_GENLIST_REMOVE(slist, snode)
40028fc4:	0cc4a783          	lw	a5,204(s1)
40028fc8:	fcf412e3          	bne	s0,a5,40028f8c <cancel_async_locked+0x60>
	list->tail = node;
40028fcc:	0ce4a623          	sw	a4,204(s1)
}
40028fd0:	fbdff06f          	j	40028f8c <cancel_async_locked+0x60>
	return node->next;
40028fd4:	00078713          	mv	a4,a5
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
40028fd8:	0007a783          	lw	a5,0(a5)
40028fdc:	f91ff06f          	j	40028f6c <cancel_async_locked+0x40>

40028fe0 <work_queue_main>:
{
40028fe0:	fd010113          	addi	sp,sp,-48
40028fe4:	02812423          	sw	s0,40(sp)
40028fe8:	03212023          	sw	s2,32(sp)
40028fec:	01312e23          	sw	s3,28(sp)
40028ff0:	01412c23          	sw	s4,24(sp)
40028ff4:	01512a23          	sw	s5,20(sp)
40028ff8:	01612823          	sw	s6,16(sp)
40028ffc:	02112623          	sw	ra,44(sp)
40029000:	02912223          	sw	s1,36(sp)
40029004:	01712623          	sw	s7,12(sp)
40029008:	01812423          	sw	s8,8(sp)
4002900c:	01912223          	sw	s9,4(sp)
40029010:	01a12023          	sw	s10,0(sp)
40029014:	00050413          	mv	s0,a0
	return list->head;
40029018:	40031937          	lui	s2,0x40031
		} else if (flag_test_and_clear(&queue->flags,
4002901c:	0e050993          	addi	s3,a0,224
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
40029020:	0d850a13          	addi	s4,a0,216
			(void)z_sched_wait(&lock, key, &queue->notifyq,
40029024:	0d050a93          	addi	s5,a0,208
40029028:	40033b37          	lui	s6,0x40033
4002902c:	30047bf3          	csrrci	s7,mstatus,8
40029030:	0c842483          	lw	s1,200(s0)
Z_GENLIST_GET(slist, snode)
40029034:	02049a63          	bnez	s1,40029068 <work_queue_main+0x88>
		} else if (flag_test_and_clear(&queue->flags,
40029038:	00200593          	li	a1,2
4002903c:	00098513          	mv	a0,s3
40029040:	e75ff0ef          	jal	ra,40028eb4 <flag_test_and_clear>
40029044:	0a051663          	bnez	a0,400290f0 <work_queue_main+0x110>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
40029048:	00000793          	li	a5,0
4002904c:	fff00693          	li	a3,-1
40029050:	fff00713          	li	a4,-1
40029054:	000a8613          	mv	a2,s5
40029058:	000b8593          	mv	a1,s7
4002905c:	88cb0513          	addi	a0,s6,-1908 # 4003288c <sched_spinlock>
40029060:	5e8010ef          	jal	ra,4002a648 <z_sched_wait>
			continue;
40029064:	fc9ff06f          	j	4002902c <work_queue_main+0x4c>
	return node->next;
40029068:	0004a783          	lw	a5,0(s1)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
4002906c:	0cc42703          	lw	a4,204(s0)
	list->head = node;
40029070:	0cf42423          	sw	a5,200(s0)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
40029074:	00e49463          	bne	s1,a4,4002907c <work_queue_main+0x9c>
	list->tail = node;
40029078:	0cf42623          	sw	a5,204(s0)
	*flagp |= BIT(bit);
4002907c:	0e042783          	lw	a5,224(s0)
	__asm__ volatile ("csrs mstatus, %0"
40029080:	008bfb93          	andi	s7,s7,8
40029084:	0027e793          	ori	a5,a5,2
40029088:	0ef42023          	sw	a5,224(s0)
	*flagp &= ~BIT(bit);
4002908c:	00c4a783          	lw	a5,12(s1)
40029090:	ffb7f793          	andi	a5,a5,-5
40029094:	0017e793          	ori	a5,a5,1
40029098:	00f4a623          	sw	a5,12(s1)
			handler = work->handler;
4002909c:	0044a783          	lw	a5,4(s1)
400290a0:	300ba073          	csrs	mstatus,s7
		handler(work);
400290a4:	00048513          	mv	a0,s1
400290a8:	000780e7          	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
400290ac:	30047d73          	csrrci	s10,mstatus,8
	*flagp &= ~BIT(bit);
400290b0:	00c4a783          	lw	a5,12(s1)
	return (*flagp & BIT(bit)) != 0U;
400290b4:	0017d713          	srli	a4,a5,0x1
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
400290b8:	00177713          	andi	a4,a4,1
	*flagp &= ~BIT(bit);
400290bc:	ffe7f693          	andi	a3,a5,-2
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
400290c0:	04071263          	bnez	a4,40029104 <work_queue_main+0x124>
	*flagp &= ~BIT(bit);
400290c4:	00d4a623          	sw	a3,12(s1)
400290c8:	0e042783          	lw	a5,224(s0)
	__asm__ volatile ("csrs mstatus, %0"
400290cc:	008d7d13          	andi	s10,s10,8
400290d0:	ffd7f793          	andi	a5,a5,-3
400290d4:	0ef42023          	sw	a5,224(s0)
400290d8:	300d2073          	csrs	mstatus,s10
	return (*flagp & BIT(bit)) != 0U;
400290dc:	0087d793          	srli	a5,a5,0x8
		if (yield) {
400290e0:	0017f793          	andi	a5,a5,1
400290e4:	f40794e3          	bnez	a5,4002902c <work_queue_main+0x4c>
	z_impl_k_yield();
400290e8:	1bc010ef          	jal	ra,4002a2a4 <z_impl_k_yield>
}
400290ec:	f41ff06f          	j	4002902c <work_queue_main+0x4c>
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
400290f0:	00000613          	li	a2,0
400290f4:	00100593          	li	a1,1
400290f8:	000a0513          	mv	a0,s4
400290fc:	4e0010ef          	jal	ra,4002a5dc <z_sched_wake>
40029100:	f45ff06f          	j	40029044 <work_queue_main+0x64>
	return list->head;
40029104:	ae892503          	lw	a0,-1304(s2) # 40030ae8 <pending_cancels>
	*flagp &= ~BIT(bit);
40029108:	ffc7f793          	andi	a5,a5,-4
4002910c:	00f4a623          	sw	a5,12(s1)
40029110:	ae890c13          	addi	s8,s2,-1304
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
40029114:	fa050ae3          	beqz	a0,400290c8 <work_queue_main+0xe8>
	return node->next;
40029118:	00052c83          	lw	s9,0(a0)
4002911c:	00000b93          	li	s7,0
40029120:	fa0504e3          	beqz	a0,400290c8 <work_queue_main+0xe8>
		if (wc->work == work) {
40029124:	00452783          	lw	a5,4(a0)
			sys_slist_remove(&pending_cancels, prev, &wc->node);
40029128:	00050713          	mv	a4,a0
		if (wc->work == work) {
4002912c:	02f49663          	bne	s1,a5,40029158 <work_queue_main+0x178>
40029130:	00052783          	lw	a5,0(a0)
Z_GENLIST_REMOVE(slist, snode)
40029134:	040b9063          	bnez	s7,40029174 <work_queue_main+0x194>
40029138:	004c2703          	lw	a4,4(s8)
	list->head = node;
4002913c:	00fc2023          	sw	a5,0(s8)
Z_GENLIST_REMOVE(slist, snode)
40029140:	00e51463          	bne	a0,a4,40029148 <work_queue_main+0x168>
	list->tail = node;
40029144:	00fc2223          	sw	a5,4(s8)
	parent->next = child;
40029148:	00052023          	sw	zero,0(a0)
	z_impl_k_sem_give(sem);
4002914c:	00850513          	addi	a0,a0,8
40029150:	c35ff0ef          	jal	ra,40028d84 <z_impl_k_sem_give>
}
40029154:	000b8713          	mv	a4,s7
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
40029158:	00000793          	li	a5,0
4002915c:	000c8463          	beqz	s9,40029164 <work_queue_main+0x184>
	return node->next;
40029160:	000ca783          	lw	a5,0(s9)
40029164:	000c8513          	mv	a0,s9
40029168:	00070b93          	mv	s7,a4
4002916c:	00078c93          	mv	s9,a5
40029170:	fb1ff06f          	j	40029120 <work_queue_main+0x140>
	parent->next = child;
40029174:	00fba023          	sw	a5,0(s7)
Z_GENLIST_REMOVE(slist, snode)
40029178:	004c2783          	lw	a5,4(s8)
4002917c:	fcf516e3          	bne	a0,a5,40029148 <work_queue_main+0x168>
	list->tail = node;
40029180:	017c2223          	sw	s7,4(s8)
}
40029184:	fc5ff06f          	j	40029148 <work_queue_main+0x168>

40029188 <cancel_sync_locked>:
{
40029188:	ff010113          	addi	sp,sp,-16
4002918c:	00112623          	sw	ra,12(sp)
40029190:	00812423          	sw	s0,8(sp)
40029194:	00912223          	sw	s1,4(sp)
40029198:	01212023          	sw	s2,0(sp)
	return (*flagp & BIT(bit)) != 0U;
4002919c:	00c52483          	lw	s1,12(a0)
400291a0:	0014d493          	srli	s1,s1,0x1
400291a4:	0014f493          	andi	s1,s1,1
	if (ret) {
400291a8:	02048e63          	beqz	s1,400291e4 <cancel_sync_locked+0x5c>
400291ac:	00050913          	mv	s2,a0
400291b0:	00058413          	mv	s0,a1
	return z_impl_k_sem_init(sem, initial_count, limit);
400291b4:	00100613          	li	a2,1
400291b8:	00000593          	li	a1,0
400291bc:	00840513          	addi	a0,s0,8
400291c0:	b8dff0ef          	jal	ra,40028d4c <z_impl_k_sem_init>
	return list->tail;
400291c4:	400317b7          	lui	a5,0x40031
	canceler->work = work;
400291c8:	01242223          	sw	s2,4(s0)
	parent->next = child;
400291cc:	00042023          	sw	zero,0(s0)
	return list->tail;
400291d0:	ae878793          	addi	a5,a5,-1304 # 40030ae8 <pending_cancels>
400291d4:	0047a703          	lw	a4,4(a5)
Z_GENLIST_APPEND(slist, snode)
400291d8:	02071463          	bnez	a4,40029200 <cancel_sync_locked+0x78>
	list->tail = node;
400291dc:	0087a223          	sw	s0,4(a5)
	list->head = node;
400291e0:	0087a023          	sw	s0,0(a5)
}
400291e4:	00c12083          	lw	ra,12(sp)
400291e8:	00812403          	lw	s0,8(sp)
400291ec:	00012903          	lw	s2,0(sp)
400291f0:	00048513          	mv	a0,s1
400291f4:	00412483          	lw	s1,4(sp)
400291f8:	01010113          	addi	sp,sp,16
400291fc:	00008067          	ret
	parent->next = child;
40029200:	00872023          	sw	s0,0(a4)
	list->tail = node;
40029204:	0087a223          	sw	s0,4(a5)
}
40029208:	fddff06f          	j	400291e4 <cancel_sync_locked+0x5c>

4002920c <submit_to_queue_locked>:
{
4002920c:	fe010113          	addi	sp,sp,-32
40029210:	01212823          	sw	s2,16(sp)
40029214:	00112e23          	sw	ra,28(sp)
40029218:	00812c23          	sw	s0,24(sp)
4002921c:	00912a23          	sw	s1,20(sp)
40029220:	01312623          	sw	s3,12(sp)
	return (*flagp & BIT(bit)) != 0U;
40029224:	00c52783          	lw	a5,12(a0)
{
40029228:	00058913          	mv	s2,a1
	return (*flagp & BIT(bit)) != 0U;
4002922c:	0017d713          	srli	a4,a5,0x1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
40029230:	00177713          	andi	a4,a4,1
40029234:	0a071063          	bnez	a4,400292d4 <submit_to_queue_locked+0xc8>
	return (*flagp & BIT(bit)) != 0U;
40029238:	0027d793          	srli	a5,a5,0x2
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
4002923c:	0017f793          	andi	a5,a5,1
40029240:	10079463          	bnez	a5,40029348 <submit_to_queue_locked+0x13c>
		if (*queuep == NULL) {
40029244:	0005a783          	lw	a5,0(a1)
40029248:	00050413          	mv	s0,a0
4002924c:	00079663          	bnez	a5,40029258 <submit_to_queue_locked+0x4c>
			*queuep = work->queue;
40029250:	00852783          	lw	a5,8(a0)
40029254:	00f5a023          	sw	a5,0(a1)
	return (*flagp & BIT(bit)) != 0U;
40029258:	00c42783          	lw	a5,12(s0)
		ret = 1;
4002925c:	00100993          	li	s3,1
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
40029260:	0017f793          	andi	a5,a5,1
40029264:	00078863          	beqz	a5,40029274 <submit_to_queue_locked+0x68>
			*queuep = work->queue;
40029268:	00842783          	lw	a5,8(s0)
			ret = 2;
4002926c:	00200993          	li	s3,2
			*queuep = work->queue;
40029270:	00f92023          	sw	a5,0(s2)
		int rc = queue_submit_locked(*queuep, work);
40029274:	00092483          	lw	s1,0(s2)
	if (queue == NULL) {
40029278:	0c048c63          	beqz	s1,40029350 <submit_to_queue_locked+0x144>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
4002927c:	400337b7          	lui	a5,0x40033
40029280:	8707a783          	lw	a5,-1936(a5) # 40032870 <_kernel+0x8>
40029284:	02978263          	beq	a5,s1,400292a8 <submit_to_queue_locked+0x9c>
	return (*flagp & BIT(bit)) != 0U;
40029288:	0e04a783          	lw	a5,224(s1)
4002928c:	0027d713          	srli	a4,a5,0x2
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
40029290:	0017f693          	andi	a3,a5,1
	return (*flagp & BIT(bit)) != 0U;
40029294:	00177713          	andi	a4,a4,1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
40029298:	04069263          	bnez	a3,400292dc <submit_to_queue_locked+0xd0>
		ret = -EBUSY;
4002929c:	fed00993          	li	s3,-19
		*queuep = NULL;
400292a0:	00092023          	sw	zero,0(s2)
	return ret;
400292a4:	0780006f          	j	4002931c <submit_to_queue_locked+0x110>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
400292a8:	e29fe0ef          	jal	ra,400280d0 <k_is_in_isr>
400292ac:	0e04a783          	lw	a5,224(s1)
400292b0:	fc051ee3          	bnez	a0,4002928c <submit_to_queue_locked+0x80>
	return (*flagp & BIT(bit)) != 0U;
400292b4:	0037d713          	srli	a4,a5,0x3
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
400292b8:	0017f693          	andi	a3,a5,1
	return (*flagp & BIT(bit)) != 0U;
400292bc:	00177713          	andi	a4,a4,1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
400292c0:	fc068ee3          	beqz	a3,4002929c <submit_to_queue_locked+0x90>
	} else if (plugged && !draining) {
400292c4:	02070463          	beqz	a4,400292ec <submit_to_queue_locked+0xe0>
	return (*flagp & BIT(bit)) != 0U;
400292c8:	0027d793          	srli	a5,a5,0x2
	} else if (plugged && !draining) {
400292cc:	0017f793          	andi	a5,a5,1
400292d0:	00079e63          	bnez	a5,400292ec <submit_to_queue_locked+0xe0>
		ret = -EBUSY;
400292d4:	ff000993          	li	s3,-16
400292d8:	fc9ff06f          	j	400292a0 <submit_to_queue_locked+0x94>
	} else if (draining && !chained) {
400292dc:	fe071ce3          	bnez	a4,400292d4 <submit_to_queue_locked+0xc8>
	return (*flagp & BIT(bit)) != 0U;
400292e0:	0037d793          	srli	a5,a5,0x3
400292e4:	0017f793          	andi	a5,a5,1
	} else if (plugged && !draining) {
400292e8:	fe0796e3          	bnez	a5,400292d4 <submit_to_queue_locked+0xc8>
	parent->next = child;
400292ec:	00042023          	sw	zero,0(s0)
	return list->tail;
400292f0:	0cc4a783          	lw	a5,204(s1)
Z_GENLIST_APPEND(slist, snode)
400292f4:	04079463          	bnez	a5,4002933c <submit_to_queue_locked+0x130>
	list->tail = node;
400292f8:	0c84a623          	sw	s0,204(s1)
	list->head = node;
400292fc:	0c84a423          	sw	s0,200(s1)
		(void)notify_queue_locked(queue);
40029300:	00048513          	mv	a0,s1
40029304:	c11ff0ef          	jal	ra,40028f14 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
40029308:	00c42783          	lw	a5,12(s0)
4002930c:	0047e793          	ori	a5,a5,4
40029310:	00f42623          	sw	a5,12(s0)
			work->queue = *queuep;
40029314:	00092783          	lw	a5,0(s2)
40029318:	00f42423          	sw	a5,8(s0)
}
4002931c:	01c12083          	lw	ra,28(sp)
40029320:	01812403          	lw	s0,24(sp)
40029324:	01412483          	lw	s1,20(sp)
40029328:	01012903          	lw	s2,16(sp)
4002932c:	00098513          	mv	a0,s3
40029330:	00c12983          	lw	s3,12(sp)
40029334:	02010113          	addi	sp,sp,32
40029338:	00008067          	ret
	parent->next = child;
4002933c:	0087a023          	sw	s0,0(a5)
	list->tail = node;
40029340:	0c84a623          	sw	s0,204(s1)
}
40029344:	fbdff06f          	j	40029300 <submit_to_queue_locked+0xf4>
	int ret = 0;
40029348:	00000993          	li	s3,0
4002934c:	f55ff06f          	j	400292a0 <submit_to_queue_locked+0x94>
		return -EINVAL;
40029350:	fea00993          	li	s3,-22
40029354:	f4dff06f          	j	400292a0 <submit_to_queue_locked+0x94>

40029358 <work_timeout>:
{
40029358:	fe010113          	addi	sp,sp,-32
4002935c:	00812c23          	sw	s0,24(sp)
40029360:	00112e23          	sw	ra,28(sp)
40029364:	00912a23          	sw	s1,20(sp)
40029368:	01212823          	sw	s2,16(sp)
4002936c:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029370:	300474f3          	csrrci	s1,mstatus,8
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
40029374:	00300593          	li	a1,3
40029378:	ff050913          	addi	s2,a0,-16
4002937c:	ffc50513          	addi	a0,a0,-4
	struct k_work_q *queue = NULL;
40029380:	00012623          	sw	zero,12(sp)
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
40029384:	b31ff0ef          	jal	ra,40028eb4 <flag_test_and_clear>
40029388:	00050c63          	beqz	a0,400293a0 <work_timeout+0x48>
		queue = dw->queue;
4002938c:	01842783          	lw	a5,24(s0)
		(void)submit_to_queue_locked(wp, &queue);
40029390:	00c10593          	addi	a1,sp,12
40029394:	00090513          	mv	a0,s2
		queue = dw->queue;
40029398:	00f12623          	sw	a5,12(sp)
		(void)submit_to_queue_locked(wp, &queue);
4002939c:	e71ff0ef          	jal	ra,4002920c <submit_to_queue_locked>
	__asm__ volatile ("csrs mstatus, %0"
400293a0:	0084f493          	andi	s1,s1,8
400293a4:	3004a073          	csrs	mstatus,s1
}
400293a8:	01c12083          	lw	ra,28(sp)
400293ac:	01812403          	lw	s0,24(sp)
400293b0:	01412483          	lw	s1,20(sp)
400293b4:	01012903          	lw	s2,16(sp)
400293b8:	02010113          	addi	sp,sp,32
400293bc:	00008067          	ret

400293c0 <k_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
400293c0:	00052023          	sw	zero,0(a0)
400293c4:	00052423          	sw	zero,8(a0)
400293c8:	00052623          	sw	zero,12(a0)
400293cc:	00b52223          	sw	a1,4(a0)
}
400293d0:	00008067          	ret

400293d4 <k_work_busy_get>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
400293d4:	300477f3          	csrrci	a5,mstatus,8
	return flags_get(&work->flags) & K_WORK_MASK;
400293d8:	00c52503          	lw	a0,12(a0)
	__asm__ volatile ("csrs mstatus, %0"
400293dc:	0087f793          	andi	a5,a5,8
400293e0:	00f57513          	andi	a0,a0,15
400293e4:	3007a073          	csrs	mstatus,a5
}
400293e8:	00008067          	ret

400293ec <z_work_submit_to_queue>:
{
400293ec:	fe010113          	addi	sp,sp,-32
400293f0:	00112e23          	sw	ra,28(sp)
400293f4:	00812c23          	sw	s0,24(sp)
400293f8:	00a12623          	sw	a0,12(sp)
400293fc:	00058513          	mv	a0,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029400:	30047473          	csrrci	s0,mstatus,8
	int ret = submit_to_queue_locked(work, &queue);
40029404:	00c10593          	addi	a1,sp,12
40029408:	e05ff0ef          	jal	ra,4002920c <submit_to_queue_locked>
	__asm__ volatile ("csrs mstatus, %0"
4002940c:	00847413          	andi	s0,s0,8
40029410:	30042073          	csrs	mstatus,s0
}
40029414:	01c12083          	lw	ra,28(sp)
40029418:	01812403          	lw	s0,24(sp)
4002941c:	02010113          	addi	sp,sp,32
40029420:	00008067          	ret

40029424 <k_work_queue_start>:
{
40029424:	fe010113          	addi	sp,sp,-32
40029428:	00812c23          	sw	s0,24(sp)
4002942c:	00912a23          	sw	s1,20(sp)
40029430:	00112e23          	sw	ra,28(sp)
40029434:	0d050793          	addi	a5,a0,208
	list->head = (sys_dnode_t *)list;
40029438:	0cf52823          	sw	a5,208(a0)
	list->tail = (sys_dnode_t *)list;
4002943c:	0cf52a23          	sw	a5,212(a0)
40029440:	0d850793          	addi	a5,a0,216
	list->head = (sys_dnode_t *)list;
40029444:	0cf52c23          	sw	a5,216(a0)
	list->tail = (sys_dnode_t *)list;
40029448:	0cf52e23          	sw	a5,220(a0)
	list->head = NULL;
4002944c:	0c052423          	sw	zero,200(a0)
	list->tail = NULL;
40029450:	0c052623          	sw	zero,204(a0)
40029454:	00050413          	mv	s0,a0
40029458:	00068893          	mv	a7,a3
4002945c:	00070493          	mv	s1,a4
	uint32_t flags = K_WORK_QUEUE_STARTED;
40029460:	00100793          	li	a5,1
	if ((cfg != NULL) && cfg->no_yield) {
40029464:	00070863          	beqz	a4,40029474 <k_work_queue_start+0x50>
40029468:	00474703          	lbu	a4,4(a4)
4002946c:	00070463          	beqz	a4,40029474 <k_work_queue_start+0x50>
		flags |= K_WORK_QUEUE_NO_YIELD;
40029470:	10100793          	li	a5,257
	*flagp = flags;
40029474:	0ef42023          	sw	a5,224(s0)
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
40029478:	fff00713          	li	a4,-1
4002947c:	fff00793          	li	a5,-1
40029480:	400296b7          	lui	a3,0x40029
40029484:	00e12423          	sw	a4,8(sp)
40029488:	00f12623          	sw	a5,12(sp)
4002948c:	00012023          	sw	zero,0(sp)
40029490:	00000813          	li	a6,0
40029494:	00000793          	li	a5,0
40029498:	00040713          	mv	a4,s0
4002949c:	fe068693          	addi	a3,a3,-32 # 40028fe0 <work_queue_main>
400294a0:	00040513          	mv	a0,s0
400294a4:	f4dfe0ef          	jal	ra,400283f0 <z_impl_k_thread_create>
	if ((cfg != NULL) && (cfg->name != NULL)) {
400294a8:	00048a63          	beqz	s1,400294bc <k_work_queue_start+0x98>
400294ac:	0004a583          	lw	a1,0(s1)
400294b0:	00058663          	beqz	a1,400294bc <k_work_queue_start+0x98>
	return z_impl_k_thread_name_set(thread, str);
400294b4:	00040513          	mv	a0,s0
400294b8:	c6dfe0ef          	jal	ra,40028124 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
400294bc:	00040513          	mv	a0,s0
}
400294c0:	01812403          	lw	s0,24(sp)
400294c4:	01c12083          	lw	ra,28(sp)
400294c8:	01412483          	lw	s1,20(sp)
400294cc:	02010113          	addi	sp,sp,32
400294d0:	dcdfe06f          	j	4002829c <z_impl_k_thread_start>

400294d4 <k_work_init_delayable>:
{
400294d4:	ff010113          	addi	sp,sp,-16
400294d8:	00912223          	sw	s1,4(sp)
	*dwork = (struct k_work_delayable){
400294dc:	03000613          	li	a2,48
{
400294e0:	00058493          	mv	s1,a1
	*dwork = (struct k_work_delayable){
400294e4:	00000593          	li	a1,0
{
400294e8:	00812423          	sw	s0,8(sp)
400294ec:	00112623          	sw	ra,12(sp)
400294f0:	00050413          	mv	s0,a0
	*dwork = (struct k_work_delayable){
400294f4:	b7ddf0ef          	jal	ra,40009070 <memset>
400294f8:	10000793          	li	a5,256
400294fc:	00942223          	sw	s1,4(s0)
40029500:	00f42623          	sw	a5,12(s0)
}
40029504:	00c12083          	lw	ra,12(sp)
40029508:	00812403          	lw	s0,8(sp)
4002950c:	00412483          	lw	s1,4(sp)
40029510:	01010113          	addi	sp,sp,16
40029514:	00008067          	ret

40029518 <k_work_delayable_busy_get>:
int k_work_delayable_busy_get(const struct k_work_delayable *dwork)
40029518:	ebdff06f          	j	400293d4 <k_work_busy_get>

4002951c <k_work_schedule_for_queue>:
}

int k_work_schedule_for_queue(struct k_work_q *queue,
			       struct k_work_delayable *dwork,
			       k_timeout_t delay)
{
4002951c:	fe010113          	addi	sp,sp,-32
40029520:	00112e23          	sw	ra,28(sp)
40029524:	00812c23          	sw	s0,24(sp)
40029528:	00a12623          	sw	a0,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002952c:	30047473          	csrrci	s0,mstatus,8
	return *flagp;
40029530:	00c5a783          	lw	a5,12(a1)
	__ASSERT_NO_MSG(dwork != NULL);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, schedule_for_queue, queue, dwork, delay);

	struct k_work *work = &dwork->work;
	int ret = 0;
40029534:	00000513          	li	a0,0
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Schedule the work item if it's idle or running. */
	if ((work_busy_get_locked(work) & ~K_WORK_RUNNING) == 0U) {
40029538:	00e7f713          	andi	a4,a5,14
4002953c:	00071c63          	bnez	a4,40029554 <k_work_schedule_for_queue+0x38>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
40029540:	00c6e733          	or	a4,a3,a2
40029544:	00058513          	mv	a0,a1
40029548:	02071263          	bnez	a4,4002956c <k_work_schedule_for_queue+0x50>
		return submit_to_queue_locked(work, queuep);
4002954c:	00c10593          	addi	a1,sp,12
40029550:	cbdff0ef          	jal	ra,4002920c <submit_to_queue_locked>
	__asm__ volatile ("csrs mstatus, %0"
40029554:	00847413          	andi	s0,s0,8
40029558:	30042073          	csrs	mstatus,s0
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
4002955c:	01c12083          	lw	ra,28(sp)
40029560:	01812403          	lw	s0,24(sp)
40029564:	02010113          	addi	sp,sp,32
40029568:	00008067          	ret
	*flagp |= BIT(bit);
4002956c:	0087e793          	ori	a5,a5,8
40029570:	00f5a623          	sw	a5,12(a1)
	dwork->queue = *queuep;
40029574:	00c12783          	lw	a5,12(sp)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
40029578:	01050513          	addi	a0,a0,16
	dwork->queue = *queuep;
4002957c:	02f5a423          	sw	a5,40(a1)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
40029580:	400295b7          	lui	a1,0x40029
40029584:	35858593          	addi	a1,a1,856 # 40029358 <work_timeout>
40029588:	280010ef          	jal	ra,4002a808 <z_add_timeout>
	return ret;
4002958c:	00100513          	li	a0,1
40029590:	fc5ff06f          	j	40029554 <k_work_schedule_for_queue+0x38>

40029594 <k_work_reschedule_for_queue>:
}

int k_work_reschedule_for_queue(struct k_work_q *queue,
				 struct k_work_delayable *dwork,
				 k_timeout_t delay)
{
40029594:	fe010113          	addi	sp,sp,-32
40029598:	00812c23          	sw	s0,24(sp)
4002959c:	00112e23          	sw	ra,28(sp)
400295a0:	00912a23          	sw	s1,20(sp)
400295a4:	00a12623          	sw	a0,12(sp)
400295a8:	00058413          	mv	s0,a1
400295ac:	00c12423          	sw	a2,8(sp)
400295b0:	00d12223          	sw	a3,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
400295b4:	300474f3          	csrrci	s1,mstatus,8

	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Remove any active scheduling. */
	(void)unschedule_locked(dwork);
400295b8:	00058513          	mv	a0,a1
400295bc:	91dff0ef          	jal	ra,40028ed8 <unschedule_locked>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
400295c0:	00412683          	lw	a3,4(sp)
400295c4:	00812603          	lw	a2,8(sp)
400295c8:	00c6e7b3          	or	a5,a3,a2
400295cc:	02079663          	bnez	a5,400295f8 <k_work_reschedule_for_queue+0x64>
		return submit_to_queue_locked(work, queuep);
400295d0:	00c10593          	addi	a1,sp,12
400295d4:	00040513          	mv	a0,s0
400295d8:	c35ff0ef          	jal	ra,4002920c <submit_to_queue_locked>
	__asm__ volatile ("csrs mstatus, %0"
400295dc:	0084f493          	andi	s1,s1,8
400295e0:	3004a073          	csrs	mstatus,s1
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
400295e4:	01c12083          	lw	ra,28(sp)
400295e8:	01812403          	lw	s0,24(sp)
400295ec:	01412483          	lw	s1,20(sp)
400295f0:	02010113          	addi	sp,sp,32
400295f4:	00008067          	ret
	*flagp |= BIT(bit);
400295f8:	00c42783          	lw	a5,12(s0)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
400295fc:	400295b7          	lui	a1,0x40029
40029600:	01040513          	addi	a0,s0,16
	*flagp |= BIT(bit);
40029604:	0087e793          	ori	a5,a5,8
40029608:	00f42623          	sw	a5,12(s0)
	dwork->queue = *queuep;
4002960c:	00c12783          	lw	a5,12(sp)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
40029610:	35858593          	addi	a1,a1,856 # 40029358 <work_timeout>
	dwork->queue = *queuep;
40029614:	02f42423          	sw	a5,40(s0)
	z_add_timeout(&dwork->timeout, work_timeout, delay);
40029618:	1f0010ef          	jal	ra,4002a808 <z_add_timeout>
	return ret;
4002961c:	00100513          	li	a0,1
40029620:	fbdff06f          	j	400295dc <k_work_reschedule_for_queue+0x48>

40029624 <k_work_reschedule>:

int k_work_reschedule(struct k_work_delayable *dwork,
				     k_timeout_t delay)
{
40029624:	00060693          	mv	a3,a2
40029628:	00058613          	mv	a2,a1
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, reschedule, dwork, delay);

	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
4002962c:	00050593          	mv	a1,a0
40029630:	40031537          	lui	a0,0x40031
40029634:	49850513          	addi	a0,a0,1176 # 40031498 <k_sys_work_q>
40029638:	f5dff06f          	j	40029594 <k_work_reschedule_for_queue>

4002963c <k_work_cancel_delayable>:

	return ret;
}

int k_work_cancel_delayable(struct k_work_delayable *dwork)
{
4002963c:	ff010113          	addi	sp,sp,-16
40029640:	00912223          	sw	s1,4(sp)
40029644:	00112623          	sw	ra,12(sp)
40029648:	00812423          	sw	s0,8(sp)
4002964c:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029650:	30047473          	csrrci	s0,mstatus,8
	(void)unschedule_locked(dwork);
40029654:	885ff0ef          	jal	ra,40028ed8 <unschedule_locked>
	return cancel_async_locked(&dwork->work);
40029658:	00048513          	mv	a0,s1
4002965c:	8d1ff0ef          	jal	ra,40028f2c <cancel_async_locked>
	__asm__ volatile ("csrs mstatus, %0"
40029660:	00847793          	andi	a5,s0,8
40029664:	3007a073          	csrs	mstatus,a5
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable, dwork, ret);

	return ret;
}
40029668:	00c12083          	lw	ra,12(sp)
4002966c:	00812403          	lw	s0,8(sp)
40029670:	00412483          	lw	s1,4(sp)
40029674:	01010113          	addi	sp,sp,16
40029678:	00008067          	ret

4002967c <k_work_cancel_delayable_sync>:

bool k_work_cancel_delayable_sync(struct k_work_delayable *dwork,
				  struct k_work_sync *sync)
{
4002967c:	fe010113          	addi	sp,sp,-32
40029680:	00112e23          	sw	ra,28(sp)
40029684:	00812c23          	sw	s0,24(sp)
40029688:	00912a23          	sw	s1,20(sp)
4002968c:	01212823          	sw	s2,16(sp)
40029690:	01312623          	sw	s3,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029694:	30047973          	csrrci	s2,mstatus,8
	return *flagp;
40029698:	00c52783          	lw	a5,12(a0)
4002969c:	00897913          	andi	s2,s2,8
400296a0:	00f7f793          	andi	a5,a5,15

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_delayable_sync, dwork, sync);

	struct z_work_canceller *canceller = &sync->canceller;
	k_spinlock_key_t key = k_spin_lock(&lock);
	bool pending = (work_delayable_busy_get_locked(dwork) != 0U);
400296a4:	00f039b3          	snez	s3,a5
	bool need_wait = false;

	if (pending) {
400296a8:	02079463          	bnez	a5,400296d0 <k_work_cancel_delayable_sync+0x54>
	__asm__ volatile ("csrs mstatus, %0"
400296ac:	30092073          	csrs	mstatus,s2
		k_sem_take(&canceller->sem, K_FOREVER);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable_sync, dwork, sync, pending);
	return pending;
}
400296b0:	01c12083          	lw	ra,28(sp)
400296b4:	01812403          	lw	s0,24(sp)
400296b8:	01412483          	lw	s1,20(sp)
400296bc:	01012903          	lw	s2,16(sp)
400296c0:	00098513          	mv	a0,s3
400296c4:	00c12983          	lw	s3,12(sp)
400296c8:	02010113          	addi	sp,sp,32
400296cc:	00008067          	ret
400296d0:	00050413          	mv	s0,a0
400296d4:	00058493          	mv	s1,a1
	(void)unschedule_locked(dwork);
400296d8:	801ff0ef          	jal	ra,40028ed8 <unschedule_locked>
	return cancel_async_locked(&dwork->work);
400296dc:	00040513          	mv	a0,s0
400296e0:	84dff0ef          	jal	ra,40028f2c <cancel_async_locked>
		need_wait = cancel_sync_locked(&dwork->work, canceller);
400296e4:	00048593          	mv	a1,s1
400296e8:	00040513          	mv	a0,s0
400296ec:	a9dff0ef          	jal	ra,40029188 <cancel_sync_locked>
400296f0:	30092073          	csrs	mstatus,s2
	if (need_wait) {
400296f4:	fa050ee3          	beqz	a0,400296b0 <k_work_cancel_delayable_sync+0x34>
	return z_impl_k_sem_take(sem, timeout);
400296f8:	fff00593          	li	a1,-1
400296fc:	fff00613          	li	a2,-1
40029700:	00848513          	addi	a0,s1,8
40029704:	ef0ff0ef          	jal	ra,40028df4 <z_impl_k_sem_take>
40029708:	fa9ff06f          	j	400296b0 <k_work_cancel_delayable_sync+0x34>

4002970c <sys_dlist_remove>:
	sys_dnode_t *const prev = node->prev;
4002970c:	00452703          	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
40029710:	00052783          	lw	a5,0(a0)
	prev->next = next;
40029714:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
40029718:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
4002971c:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
40029720:	00052223          	sw	zero,4(a0)
	sys_dnode_init(node);
}
40029724:	00008067          	ret

40029728 <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
40029728:	00e55703          	lhu	a4,14(a0)
4002972c:	07f00793          	li	a5,127
40029730:	04e7e463          	bltu	a5,a4,40029778 <sliceable+0x50>
	int ret = slice_ticks;
40029734:	400317b7          	lui	a5,0x40031
40029738:	af87a783          	lw	a5,-1288(a5) # 40030af8 <slice_ticks>
		&& slice_time(thread) != 0
4002973c:	02078a63          	beqz	a5,40029770 <sliceable+0x48>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
40029740:	400317b7          	lui	a5,0x40031
40029744:	af47a703          	lw	a4,-1292(a5) # 40030af4 <slice_max_prio>
40029748:	00e50683          	lb	a3,14(a0)
		&& !z_is_idle_thread_object(thread);
4002974c:	00000793          	li	a5,0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
40029750:	02e6c063          	blt	a3,a4,40029770 <sliceable+0x48>
		&& !z_is_thread_prevented_from_running(thread)
40029754:	00d54703          	lbu	a4,13(a0)
40029758:	01f77713          	andi	a4,a4,31
4002975c:	00071a63          	bnez	a4,40029770 <sliceable+0x48>
		&& !z_is_idle_thread_object(thread);
40029760:	400317b7          	lui	a5,0x40031
40029764:	2f078793          	addi	a5,a5,752 # 400312f0 <z_idle_threads>
40029768:	40f50533          	sub	a0,a0,a5
4002976c:	00a037b3          	snez	a5,a0
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
40029770:	0017f513          	andi	a0,a5,1
40029774:	00008067          	ret
		&& !z_is_idle_thread_object(thread);
40029778:	00000793          	li	a5,0
4002977c:	ff5ff06f          	j	40029770 <sliceable+0x48>

40029780 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);
40029780:	400317b7          	lui	a5,0x40031
40029784:	48078793          	addi	a5,a5,1152 # 40031480 <slice_timeouts>
40029788:	40f507b3          	sub	a5,a0,a5
4002978c:	aaaab737          	lui	a4,0xaaaab
40029790:	aab70713          	addi	a4,a4,-1365 # aaaaaaab <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xaaaaaaac>
40029794:	4037d793          	srai	a5,a5,0x3
40029798:	02e787b3          	mul	a5,a5,a4

	slice_expired[cpu] = true;
4002979c:	40031737          	lui	a4,0x40031
400297a0:	af070713          	addi	a4,a4,-1296 # 40030af0 <slice_expired>
400297a4:	00e787b3          	add	a5,a5,a4
400297a8:	00100713          	li	a4,1
400297ac:	00e78023          	sb	a4,0(a5)
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
400297b0:	00008067          	ret

400297b4 <unpend_thread_no_timeout>:
		pend_locked(thread, wait_q, timeout);
	}
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
400297b4:	ff010113          	addi	sp,sp,-16
400297b8:	00812423          	sw	s0,8(sp)
400297bc:	00112623          	sw	ra,12(sp)
400297c0:	00050413          	mv	s0,a0

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
400297c4:	f49ff0ef          	jal	ra,4002970c <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
400297c8:	00d44783          	lbu	a5,13(s0)
	thread->base.pended_on = NULL;
400297cc:	00042423          	sw	zero,8(s0)
400297d0:	ffd7f793          	andi	a5,a5,-3
400297d4:	00f406a3          	sb	a5,13(s0)
}
400297d8:	00c12083          	lw	ra,12(sp)
400297dc:	00812403          	lw	s0,8(sp)
400297e0:	01010113          	addi	sp,sp,16
400297e4:	00008067          	ret

400297e8 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
400297e8:	00e50783          	lb	a5,14(a0)
	int32_t b2 = thread_2->base.prio;
400297ec:	00e58503          	lb	a0,14(a1)
	if (b1 != b2) {
400297f0:	00a78663          	beq	a5,a0,400297fc <z_sched_prio_cmp+0x14>
		return b2 - b1;
400297f4:	40f50533          	sub	a0,a0,a5
400297f8:	00008067          	ret
	return 0;
400297fc:	00000513          	li	a0,0
}
40029800:	00008067          	ret

40029804 <z_reset_time_slice>:
{
40029804:	ff010113          	addi	sp,sp,-16
	int cpu = _current_cpu->id;
40029808:	400337b7          	lui	a5,0x40033
{
4002980c:	00912223          	sw	s1,4(sp)
	int cpu = _current_cpu->id;
40029810:	8787c483          	lbu	s1,-1928(a5) # 40032878 <_kernel+0x10>
{
40029814:	00812423          	sw	s0,8(sp)
	z_abort_timeout(&slice_timeouts[cpu]);
40029818:	01800413          	li	s0,24
4002981c:	02848433          	mul	s0,s1,s0
40029820:	400317b7          	lui	a5,0x40031
40029824:	48078793          	addi	a5,a5,1152 # 40031480 <slice_timeouts>
{
40029828:	01212023          	sw	s2,0(sp)
4002982c:	00050913          	mv	s2,a0
40029830:	00112623          	sw	ra,12(sp)
	z_abort_timeout(&slice_timeouts[cpu]);
40029834:	00f40433          	add	s0,s0,a5
40029838:	00040513          	mv	a0,s0
4002983c:	16c010ef          	jal	ra,4002a9a8 <z_abort_timeout>
	slice_expired[cpu] = false;
40029840:	400317b7          	lui	a5,0x40031
40029844:	af078793          	addi	a5,a5,-1296 # 40030af0 <slice_expired>
40029848:	00f484b3          	add	s1,s1,a5
	if (sliceable(curr)) {
4002984c:	00090513          	mv	a0,s2
	slice_expired[cpu] = false;
40029850:	00048023          	sb	zero,0(s1)
	if (sliceable(curr)) {
40029854:	ed5ff0ef          	jal	ra,40029728 <sliceable>
40029858:	02050c63          	beqz	a0,40029890 <z_reset_time_slice+0x8c>
	int ret = slice_ticks;
4002985c:	400317b7          	lui	a5,0x40031
			      K_TICKS(slice_time(curr) - 1));
40029860:	af87a603          	lw	a2,-1288(a5) # 40030af8 <slice_ticks>
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
40029864:	00040513          	mv	a0,s0
}
40029868:	00812403          	lw	s0,8(sp)
4002986c:	00c12083          	lw	ra,12(sp)
40029870:	00412483          	lw	s1,4(sp)
40029874:	00012903          	lw	s2,0(sp)
			      K_TICKS(slice_time(curr) - 1));
40029878:	fff60613          	addi	a2,a2,-1
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
4002987c:	400295b7          	lui	a1,0x40029
40029880:	41f65693          	srai	a3,a2,0x1f
40029884:	78058593          	addi	a1,a1,1920 # 40029780 <slice_timeout>
}
40029888:	01010113          	addi	sp,sp,16
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
4002988c:	77d0006f          	j	4002a808 <z_add_timeout>
}
40029890:	00c12083          	lw	ra,12(sp)
40029894:	00812403          	lw	s0,8(sp)
40029898:	00412483          	lw	s1,4(sp)
4002989c:	00012903          	lw	s2,0(sp)
400298a0:	01010113          	addi	sp,sp,16
400298a4:	00008067          	ret

400298a8 <z_swap_irqlock>:
{
400298a8:	fe010113          	addi	sp,sp,-32
400298ac:	00812c23          	sw	s0,24(sp)
	old_thread = _current;
400298b0:	40033437          	lui	s0,0x40033
{
400298b4:	00912a23          	sw	s1,20(sp)
400298b8:	00112e23          	sw	ra,28(sp)
400298bc:	01212823          	sw	s2,16(sp)
	old_thread = _current;
400298c0:	86840793          	addi	a5,s0,-1944 # 40032868 <_kernel>
400298c4:	0087a583          	lw	a1,8(a5)
	old_thread->swap_retval = -EAGAIN;
400298c8:	ff500713          	li	a4,-11
{
400298cc:	00050493          	mv	s1,a0
	old_thread->swap_retval = -EAGAIN;
400298d0:	0ae5ae23          	sw	a4,188(a1)
	__asm__ volatile ("csrrc %0, mstatus, %1"
400298d4:	30047773          	csrrci	a4,mstatus,8
	return _kernel.ready_q.cache;
400298d8:	0147a903          	lw	s2,20(a5)
	if (new_thread != old_thread) {
400298dc:	00b12623          	sw	a1,12(sp)
400298e0:	86840413          	addi	s0,s0,-1944
400298e4:	01258e63          	beq	a1,s2,40029900 <z_swap_irqlock+0x58>
		z_reset_time_slice(new_thread);
400298e8:	00090513          	mv	a0,s2
		_current_cpu->current = new_thread;
400298ec:	01242423          	sw	s2,8(s0)
		z_reset_time_slice(new_thread);
400298f0:	f15ff0ef          	jal	ra,40029804 <z_reset_time_slice>
	z_riscv_switch(new, old);
400298f4:	00c12583          	lw	a1,12(sp)
400298f8:	0c092503          	lw	a0,192(s2)
400298fc:	91cdf0ef          	jal	ra,40008a18 <z_riscv_switch>
			  : "r" (key & MSTATUS_IEN)
40029900:	0084f493          	andi	s1,s1,8
	__asm__ volatile ("csrs mstatus, %0"
40029904:	3004a073          	csrs	mstatus,s1
	return _current->swap_retval;
40029908:	00842783          	lw	a5,8(s0)
}
4002990c:	01c12083          	lw	ra,28(sp)
40029910:	01812403          	lw	s0,24(sp)
40029914:	0bc7a503          	lw	a0,188(a5)
40029918:	01412483          	lw	s1,20(sp)
4002991c:	01012903          	lw	s2,16(sp)
40029920:	02010113          	addi	sp,sp,32
40029924:	00008067          	ret

40029928 <z_swap>:
{
40029928:	fe010113          	addi	sp,sp,-32
4002992c:	00812c23          	sw	s0,24(sp)
	old_thread = _current;
40029930:	40033437          	lui	s0,0x40033
{
40029934:	00912a23          	sw	s1,20(sp)
	old_thread = _current;
40029938:	86840793          	addi	a5,s0,-1944 # 40032868 <_kernel>
{
4002993c:	00112e23          	sw	ra,28(sp)
40029940:	01212823          	sw	s2,16(sp)
40029944:	00058493          	mv	s1,a1
	old_thread = _current;
40029948:	0087a583          	lw	a1,8(a5)
	old_thread->swap_retval = -EAGAIN;
4002994c:	ff500793          	li	a5,-11
40029950:	86840413          	addi	s0,s0,-1944
40029954:	0af5ae23          	sw	a5,188(a1)
	if (!is_spinlock || lock != &sched_spinlock) {
40029958:	400337b7          	lui	a5,0x40033
4002995c:	88c78793          	addi	a5,a5,-1908 # 4003288c <sched_spinlock>
40029960:	00a78463          	beq	a5,a0,40029968 <z_swap+0x40>
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029964:	300477f3          	csrrci	a5,mstatus,8
40029968:	01442903          	lw	s2,20(s0)
	if (new_thread != old_thread) {
4002996c:	00b12623          	sw	a1,12(sp)
40029970:	01258e63          	beq	a1,s2,4002998c <z_swap+0x64>
		z_reset_time_slice(new_thread);
40029974:	00090513          	mv	a0,s2
		_current_cpu->current = new_thread;
40029978:	01242423          	sw	s2,8(s0)
		z_reset_time_slice(new_thread);
4002997c:	e89ff0ef          	jal	ra,40029804 <z_reset_time_slice>
40029980:	00c12583          	lw	a1,12(sp)
40029984:	0c092503          	lw	a0,192(s2)
40029988:	890df0ef          	jal	ra,40008a18 <z_riscv_switch>
			  : "r" (key & MSTATUS_IEN)
4002998c:	0084f493          	andi	s1,s1,8
	__asm__ volatile ("csrs mstatus, %0"
40029990:	3004a073          	csrs	mstatus,s1
	return _current->swap_retval;
40029994:	00842783          	lw	a5,8(s0)
}
40029998:	01c12083          	lw	ra,28(sp)
4002999c:	01812403          	lw	s0,24(sp)
400299a0:	0bc7a503          	lw	a0,188(a5)
400299a4:	01412483          	lw	s1,20(sp)
400299a8:	01012903          	lw	s2,16(sp)
400299ac:	02010113          	addi	sp,sp,32
400299b0:	00008067          	ret

400299b4 <update_cache>:
{
400299b4:	ff010113          	addi	sp,sp,-16
400299b8:	00812423          	sw	s0,8(sp)
	return list->head == list;
400299bc:	40033437          	lui	s0,0x40033
400299c0:	86840793          	addi	a5,s0,-1944 # 40032868 <_kernel>
400299c4:	00112623          	sw	ra,12(sp)
400299c8:	00912223          	sw	s1,4(sp)
400299cc:	0187a483          	lw	s1,24(a5)
	return sys_dlist_is_empty(list) ? NULL : list->head;
400299d0:	400337b7          	lui	a5,0x40033
400299d4:	88078793          	addi	a5,a5,-1920 # 40032880 <_kernel+0x18>
400299d8:	86840413          	addi	s0,s0,-1944
400299dc:	00f48463          	beq	s1,a5,400299e4 <update_cache+0x30>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
400299e0:	00049463          	bnez	s1,400299e8 <update_cache+0x34>
400299e4:	00c42483          	lw	s1,12(s0)
	if (z_is_thread_prevented_from_running(_current)) {
400299e8:	00842783          	lw	a5,8(s0)
	if (preempt_ok != 0) {
400299ec:	00051e63          	bnez	a0,40029a08 <update_cache+0x54>
	if (z_is_thread_prevented_from_running(_current)) {
400299f0:	00d7c703          	lbu	a4,13(a5)
400299f4:	01f77713          	andi	a4,a4,31
400299f8:	00071863          	bnez	a4,40029a08 <update_cache+0x54>
	if (is_preempt(_current) || is_metairq(thread)) {
400299fc:	00e7d683          	lhu	a3,14(a5)
40029a00:	07f00713          	li	a4,127
40029a04:	00d76a63          	bltu	a4,a3,40029a18 <update_cache+0x64>
		if (thread != _current) {
40029a08:	00f48663          	beq	s1,a5,40029a14 <update_cache+0x60>
			z_reset_time_slice(thread);
40029a0c:	00048513          	mv	a0,s1
40029a10:	df5ff0ef          	jal	ra,40029804 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
40029a14:	00048793          	mv	a5,s1
40029a18:	00f42a23          	sw	a5,20(s0)
}
40029a1c:	00c12083          	lw	ra,12(sp)
40029a20:	00812403          	lw	s0,8(sp)
40029a24:	00412483          	lw	s1,4(sp)
40029a28:	01010113          	addi	sp,sp,16
40029a2c:	00008067          	ret

40029a30 <move_thread_to_end_of_prio_q>:
{
40029a30:	ff010113          	addi	sp,sp,-16
40029a34:	00812423          	sw	s0,8(sp)
40029a38:	00112623          	sw	ra,12(sp)
	return (thread->base.thread_state & state) != 0U;
40029a3c:	00d54783          	lbu	a5,13(a0)
40029a40:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
40029a44:	01879713          	slli	a4,a5,0x18
40029a48:	41875713          	srai	a4,a4,0x18
40029a4c:	00075863          	bgez	a4,40029a5c <move_thread_to_end_of_prio_q+0x2c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
40029a50:	07f7f793          	andi	a5,a5,127
40029a54:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
40029a58:	cb5ff0ef          	jal	ra,4002970c <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
40029a5c:	00d44783          	lbu	a5,13(s0)
	return list->head == list;
40029a60:	40033737          	lui	a4,0x40033
40029a64:	400336b7          	lui	a3,0x40033
40029a68:	f807e793          	ori	a5,a5,-128
40029a6c:	00f406a3          	sb	a5,13(s0)
40029a70:	86870793          	addi	a5,a4,-1944 # 40032868 <_kernel>
40029a74:	0187a783          	lw	a5,24(a5)
40029a78:	88068693          	addi	a3,a3,-1920 # 40032880 <_kernel+0x18>
40029a7c:	86870713          	addi	a4,a4,-1944
	return sys_dlist_is_empty(list) ? NULL : list->head;
40029a80:	00d79463          	bne	a5,a3,40029a88 <move_thread_to_end_of_prio_q+0x58>
40029a84:	00000793          	li	a5,0
	return (node == list->tail) ? NULL : node->next;
40029a88:	01c72603          	lw	a2,28(a4)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40029a8c:	00079c63          	bnez	a5,40029aa4 <move_thread_to_end_of_prio_q+0x74>
	node->next = list;
40029a90:	00d42023          	sw	a3,0(s0)
	node->prev = tail;
40029a94:	00c42223          	sw	a2,4(s0)
	tail->next = node;
40029a98:	00862023          	sw	s0,0(a2)
	list->tail = node;
40029a9c:	00872e23          	sw	s0,28(a4)
}
40029aa0:	0280006f          	j	40029ac8 <move_thread_to_end_of_prio_q+0x98>
	int32_t b1 = thread_1->base.prio;
40029aa4:	00e40583          	lb	a1,14(s0)
	int32_t b2 = thread_2->base.prio;
40029aa8:	00e78503          	lb	a0,14(a5)
	if (b1 != b2) {
40029aac:	02a58c63          	beq	a1,a0,40029ae4 <move_thread_to_end_of_prio_q+0xb4>
		if (z_sched_prio_cmp(thread, t) > 0) {
40029ab0:	02a5da63          	bge	a1,a0,40029ae4 <move_thread_to_end_of_prio_q+0xb4>
	sys_dnode_t *const prev = successor->prev;
40029ab4:	0047a683          	lw	a3,4(a5)
	node->next = successor;
40029ab8:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
40029abc:	00d42223          	sw	a3,4(s0)
	prev->next = node;
40029ac0:	0086a023          	sw	s0,0(a3)
	successor->prev = node;
40029ac4:	0087a223          	sw	s0,4(a5)
	update_cache(thread == _current);
40029ac8:	00872503          	lw	a0,8(a4)
}
40029acc:	00c12083          	lw	ra,12(sp)
	update_cache(thread == _current);
40029ad0:	40850533          	sub	a0,a0,s0
}
40029ad4:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
40029ad8:	00153513          	seqz	a0,a0
}
40029adc:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
40029ae0:	ed5ff06f          	j	400299b4 <update_cache>
	return (node == list->tail) ? NULL : node->next;
40029ae4:	faf606e3          	beq	a2,a5,40029a90 <move_thread_to_end_of_prio_q+0x60>
40029ae8:	0007a783          	lw	a5,0(a5)
40029aec:	fa1ff06f          	j	40029a8c <move_thread_to_end_of_prio_q+0x5c>

40029af0 <ready_thread>:
40029af0:	00d54703          	lbu	a4,13(a0)
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
40029af4:	01871793          	slli	a5,a4,0x18
40029af8:	4187d793          	srai	a5,a5,0x18
40029afc:	0807c863          	bltz	a5,40029b8c <ready_thread+0x9c>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
40029b00:	01f77793          	andi	a5,a4,31
40029b04:	08079463          	bnez	a5,40029b8c <ready_thread+0x9c>
	return node->next != NULL;
40029b08:	01852783          	lw	a5,24(a0)
40029b0c:	08079063          	bnez	a5,40029b8c <ready_thread+0x9c>
	thread->base.thread_state |= _THREAD_QUEUED;
40029b10:	f8076713          	ori	a4,a4,-128
40029b14:	00e506a3          	sb	a4,13(a0)
	return list->head == list;
40029b18:	40033737          	lui	a4,0x40033
40029b1c:	86870693          	addi	a3,a4,-1944 # 40032868 <_kernel>
40029b20:	0186a603          	lw	a2,24(a3)
40029b24:	400336b7          	lui	a3,0x40033
40029b28:	88068693          	addi	a3,a3,-1920 # 40032880 <_kernel+0x18>
40029b2c:	86870713          	addi	a4,a4,-1944
	return sys_dlist_is_empty(list) ? NULL : list->head;
40029b30:	00d60463          	beq	a2,a3,40029b38 <ready_thread+0x48>
40029b34:	00060793          	mv	a5,a2
	return (node == list->tail) ? NULL : node->next;
40029b38:	01c72603          	lw	a2,28(a4)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40029b3c:	00079c63          	bnez	a5,40029b54 <ready_thread+0x64>
	node->next = list;
40029b40:	00d52023          	sw	a3,0(a0)
	node->prev = tail;
40029b44:	00c52223          	sw	a2,4(a0)
	tail->next = node;
40029b48:	00a62023          	sw	a0,0(a2)
	list->tail = node;
40029b4c:	00a72e23          	sw	a0,28(a4)
}
40029b50:	0280006f          	j	40029b78 <ready_thread+0x88>
	int32_t b1 = thread_1->base.prio;
40029b54:	00e50583          	lb	a1,14(a0)
	int32_t b2 = thread_2->base.prio;
40029b58:	00e78803          	lb	a6,14(a5)
	if (b1 != b2) {
40029b5c:	03058263          	beq	a1,a6,40029b80 <ready_thread+0x90>
		if (z_sched_prio_cmp(thread, t) > 0) {
40029b60:	0305d063          	bge	a1,a6,40029b80 <ready_thread+0x90>
	sys_dnode_t *const prev = successor->prev;
40029b64:	0047a703          	lw	a4,4(a5)
	node->next = successor;
40029b68:	00f52023          	sw	a5,0(a0)
	node->prev = prev;
40029b6c:	00e52223          	sw	a4,4(a0)
	prev->next = node;
40029b70:	00a72023          	sw	a0,0(a4)
	successor->prev = node;
40029b74:	00a7a223          	sw	a0,4(a5)
		update_cache(0);
40029b78:	00000513          	li	a0,0
40029b7c:	e39ff06f          	j	400299b4 <update_cache>
	return (node == list->tail) ? NULL : node->next;
40029b80:	fcc780e3          	beq	a5,a2,40029b40 <ready_thread+0x50>
40029b84:	0007a783          	lw	a5,0(a5)
40029b88:	fb5ff06f          	j	40029b3c <ready_thread+0x4c>
}
40029b8c:	00008067          	ret

40029b90 <unready_thread>:
{
40029b90:	ff010113          	addi	sp,sp,-16
40029b94:	00812423          	sw	s0,8(sp)
40029b98:	00112623          	sw	ra,12(sp)
	return (thread->base.thread_state & state) != 0U;
40029b9c:	00d54783          	lbu	a5,13(a0)
40029ba0:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
40029ba4:	01879713          	slli	a4,a5,0x18
40029ba8:	41875713          	srai	a4,a4,0x18
40029bac:	00075863          	bgez	a4,40029bbc <unready_thread+0x2c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
40029bb0:	07f7f793          	andi	a5,a5,127
40029bb4:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
40029bb8:	b55ff0ef          	jal	ra,4002970c <sys_dlist_remove>
	update_cache(thread == _current);
40029bbc:	400337b7          	lui	a5,0x40033
40029bc0:	8707a503          	lw	a0,-1936(a5) # 40032870 <_kernel+0x8>
}
40029bc4:	00c12083          	lw	ra,12(sp)
	update_cache(thread == _current);
40029bc8:	40850533          	sub	a0,a0,s0
}
40029bcc:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
40029bd0:	00153513          	seqz	a0,a0
}
40029bd4:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
40029bd8:	dddff06f          	j	400299b4 <update_cache>

40029bdc <add_to_waitq_locked>:
{
40029bdc:	ff010113          	addi	sp,sp,-16
40029be0:	00812423          	sw	s0,8(sp)
40029be4:	00912223          	sw	s1,4(sp)
40029be8:	00050413          	mv	s0,a0
40029bec:	00112623          	sw	ra,12(sp)
40029bf0:	00058493          	mv	s1,a1
	unready_thread(thread);
40029bf4:	f9dff0ef          	jal	ra,40029b90 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
40029bf8:	00d44783          	lbu	a5,13(s0)
40029bfc:	0027e793          	ori	a5,a5,2
40029c00:	00f406a3          	sb	a5,13(s0)
	if (wait_q != NULL) {
40029c04:	04048e63          	beqz	s1,40029c60 <add_to_waitq_locked+0x84>
		thread->base.pended_on = wait_q;
40029c08:	00942423          	sw	s1,8(s0)
	return list->head == list;
40029c0c:	0004a783          	lw	a5,0(s1)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40029c10:	02f49463          	bne	s1,a5,40029c38 <add_to_waitq_locked+0x5c>
	sys_dnode_t *const tail = list->tail;
40029c14:	0044a783          	lw	a5,4(s1)
	node->next = list;
40029c18:	00942023          	sw	s1,0(s0)
	node->prev = tail;
40029c1c:	00f42223          	sw	a5,4(s0)
	tail->next = node;
40029c20:	0087a023          	sw	s0,0(a5)
	list->tail = node;
40029c24:	0084a223          	sw	s0,4(s1)
}
40029c28:	0380006f          	j	40029c60 <add_to_waitq_locked+0x84>
	return (node == list->tail) ? NULL : node->next;
40029c2c:	0044a703          	lw	a4,4(s1)
40029c30:	fee782e3          	beq	a5,a4,40029c14 <add_to_waitq_locked+0x38>
40029c34:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40029c38:	fc078ee3          	beqz	a5,40029c14 <add_to_waitq_locked+0x38>
	int32_t b1 = thread_1->base.prio;
40029c3c:	00e40703          	lb	a4,14(s0)
	int32_t b2 = thread_2->base.prio;
40029c40:	00e78683          	lb	a3,14(a5)
	if (b1 != b2) {
40029c44:	fed704e3          	beq	a4,a3,40029c2c <add_to_waitq_locked+0x50>
		if (z_sched_prio_cmp(thread, t) > 0) {
40029c48:	fed752e3          	bge	a4,a3,40029c2c <add_to_waitq_locked+0x50>
	sys_dnode_t *const prev = successor->prev;
40029c4c:	0047a703          	lw	a4,4(a5)
	node->next = successor;
40029c50:	00f42023          	sw	a5,0(s0)
	node->prev = prev;
40029c54:	00e42223          	sw	a4,4(s0)
	prev->next = node;
40029c58:	00872023          	sw	s0,0(a4)
	successor->prev = node;
40029c5c:	0087a223          	sw	s0,4(a5)
}
40029c60:	00c12083          	lw	ra,12(sp)
40029c64:	00812403          	lw	s0,8(sp)
40029c68:	00412483          	lw	s1,4(sp)
40029c6c:	01010113          	addi	sp,sp,16
40029c70:	00008067          	ret

40029c74 <pend_locked>:
{
40029c74:	fe010113          	addi	sp,sp,-32
40029c78:	00812c23          	sw	s0,24(sp)
40029c7c:	00c12623          	sw	a2,12(sp)
40029c80:	00d12423          	sw	a3,8(sp)
40029c84:	00112e23          	sw	ra,28(sp)
40029c88:	00050413          	mv	s0,a0
	add_to_waitq_locked(thread, wait_q);
40029c8c:	f51ff0ef          	jal	ra,40029bdc <add_to_waitq_locked>
	add_thread_timeout(thread, timeout);
40029c90:	00c12603          	lw	a2,12(sp)
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
40029c94:	fff00593          	li	a1,-1
40029c98:	00812683          	lw	a3,8(sp)
40029c9c:	00b61463          	bne	a2,a1,40029ca4 <pend_locked+0x30>
40029ca0:	02c68063          	beq	a3,a2,40029cc0 <pend_locked+0x4c>
40029ca4:	01840513          	addi	a0,s0,24
}
40029ca8:	01812403          	lw	s0,24(sp)
40029cac:	01c12083          	lw	ra,28(sp)
40029cb0:	4002a5b7          	lui	a1,0x4002a
40029cb4:	e2058593          	addi	a1,a1,-480 # 40029e20 <z_thread_timeout>
40029cb8:	02010113          	addi	sp,sp,32
40029cbc:	34d0006f          	j	4002a808 <z_add_timeout>
40029cc0:	01c12083          	lw	ra,28(sp)
40029cc4:	01812403          	lw	s0,24(sp)
40029cc8:	02010113          	addi	sp,sp,32
40029ccc:	00008067          	ret

40029cd0 <z_time_slice>:
{
40029cd0:	ff010113          	addi	sp,sp,-16
40029cd4:	00112623          	sw	ra,12(sp)
40029cd8:	00812423          	sw	s0,8(sp)
40029cdc:	00912223          	sw	s1,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029ce0:	300474f3          	csrrci	s1,mstatus,8
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
40029ce4:	400337b7          	lui	a5,0x40033
40029ce8:	86878793          	addi	a5,a5,-1944 # 40032868 <_kernel>
40029cec:	0107c703          	lbu	a4,16(a5)
40029cf0:	400316b7          	lui	a3,0x40031
40029cf4:	af068693          	addi	a3,a3,-1296 # 40030af0 <slice_expired>
40029cf8:	00d70733          	add	a4,a4,a3
40029cfc:	00074703          	lbu	a4,0(a4)
40029d00:	02070863          	beqz	a4,40029d30 <z_time_slice+0x60>
	struct k_thread *curr = _current;
40029d04:	0087a403          	lw	s0,8(a5)
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
40029d08:	00040513          	mv	a0,s0
40029d0c:	a1dff0ef          	jal	ra,40029728 <sliceable>
40029d10:	02050063          	beqz	a0,40029d30 <z_time_slice+0x60>
		if (!z_is_thread_prevented_from_running(curr)) {
40029d14:	00d44783          	lbu	a5,13(s0)
40029d18:	01f7f793          	andi	a5,a5,31
40029d1c:	00079663          	bnez	a5,40029d28 <z_time_slice+0x58>
			move_thread_to_end_of_prio_q(curr);
40029d20:	00040513          	mv	a0,s0
40029d24:	d0dff0ef          	jal	ra,40029a30 <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
40029d28:	00040513          	mv	a0,s0
40029d2c:	ad9ff0ef          	jal	ra,40029804 <z_reset_time_slice>
	__asm__ volatile ("csrs mstatus, %0"
40029d30:	0084f493          	andi	s1,s1,8
40029d34:	3004a073          	csrs	mstatus,s1
}
40029d38:	00c12083          	lw	ra,12(sp)
40029d3c:	00812403          	lw	s0,8(sp)
40029d40:	00412483          	lw	s1,4(sp)
40029d44:	01010113          	addi	sp,sp,16
40029d48:	00008067          	ret

40029d4c <z_ready_thread>:
{
40029d4c:	ff010113          	addi	sp,sp,-16
40029d50:	00112623          	sw	ra,12(sp)
40029d54:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029d58:	30047473          	csrrci	s0,mstatus,8
			ready_thread(thread);
40029d5c:	d95ff0ef          	jal	ra,40029af0 <ready_thread>
	__asm__ volatile ("csrs mstatus, %0"
40029d60:	00847413          	andi	s0,s0,8
40029d64:	30042073          	csrs	mstatus,s0
}
40029d68:	00c12083          	lw	ra,12(sp)
40029d6c:	00812403          	lw	s0,8(sp)
40029d70:	01010113          	addi	sp,sp,16
40029d74:	00008067          	ret

40029d78 <z_unpend_thread_no_timeout>:
{
40029d78:	ff010113          	addi	sp,sp,-16
40029d7c:	00112623          	sw	ra,12(sp)
40029d80:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029d84:	30047473          	csrrci	s0,mstatus,8
		if (thread->base.pended_on != NULL) {
40029d88:	00852783          	lw	a5,8(a0)
40029d8c:	00078463          	beqz	a5,40029d94 <z_unpend_thread_no_timeout+0x1c>
			unpend_thread_no_timeout(thread);
40029d90:	a25ff0ef          	jal	ra,400297b4 <unpend_thread_no_timeout>
	__asm__ volatile ("csrs mstatus, %0"
40029d94:	00847413          	andi	s0,s0,8
40029d98:	30042073          	csrs	mstatus,s0
}
40029d9c:	00c12083          	lw	ra,12(sp)
40029da0:	00812403          	lw	s0,8(sp)
40029da4:	01010113          	addi	sp,sp,16
40029da8:	00008067          	ret

40029dac <z_sched_wake_thread>:
{
40029dac:	ff010113          	addi	sp,sp,-16
40029db0:	00112623          	sw	ra,12(sp)
40029db4:	00812423          	sw	s0,8(sp)
40029db8:	00912223          	sw	s1,4(sp)
40029dbc:	01212023          	sw	s2,0(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029dc0:	300474f3          	csrrci	s1,mstatus,8
		if (!killed) {
40029dc4:	00d54783          	lbu	a5,13(a0)
40029dc8:	0287f793          	andi	a5,a5,40
40029dcc:	02079a63          	bnez	a5,40029e00 <z_sched_wake_thread+0x54>
			if (thread->base.pended_on != NULL) {
40029dd0:	00852783          	lw	a5,8(a0)
40029dd4:	00050413          	mv	s0,a0
40029dd8:	00058913          	mv	s2,a1
40029ddc:	00078463          	beqz	a5,40029de4 <z_sched_wake_thread+0x38>
				unpend_thread_no_timeout(thread);
40029de0:	9d5ff0ef          	jal	ra,400297b4 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_PRESTART;
40029de4:	00d44703          	lbu	a4,13(s0)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
40029de8:	0eb77793          	andi	a5,a4,235
			if (is_timeout) {
40029dec:	00091463          	bnez	s2,40029df4 <z_sched_wake_thread+0x48>
	thread->base.thread_state &= ~_THREAD_PRESTART;
40029df0:	0fb77793          	andi	a5,a4,251
40029df4:	00f406a3          	sb	a5,13(s0)
			ready_thread(thread);
40029df8:	00040513          	mv	a0,s0
40029dfc:	cf5ff0ef          	jal	ra,40029af0 <ready_thread>
	__asm__ volatile ("csrs mstatus, %0"
40029e00:	0084f493          	andi	s1,s1,8
40029e04:	3004a073          	csrs	mstatus,s1
}
40029e08:	00c12083          	lw	ra,12(sp)
40029e0c:	00812403          	lw	s0,8(sp)
40029e10:	00412483          	lw	s1,4(sp)
40029e14:	00012903          	lw	s2,0(sp)
40029e18:	01010113          	addi	sp,sp,16
40029e1c:	00008067          	ret

40029e20 <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
40029e20:	00100593          	li	a1,1
40029e24:	fe850513          	addi	a0,a0,-24
40029e28:	f85ff06f          	j	40029dac <z_sched_wake_thread>

40029e2c <z_pend_curr>:
{
40029e2c:	ff010113          	addi	sp,sp,-16
40029e30:	00812423          	sw	s0,8(sp)
40029e34:	00112623          	sw	ra,12(sp)
40029e38:	00058413          	mv	s0,a1
40029e3c:	00060593          	mv	a1,a2
40029e40:	00068613          	mv	a2,a3
40029e44:	00070693          	mv	a3,a4
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029e48:	300477f3          	csrrci	a5,mstatus,8
	pend_locked(_current, wait_q, timeout);
40029e4c:	400337b7          	lui	a5,0x40033
40029e50:	8707a503          	lw	a0,-1936(a5) # 40032870 <_kernel+0x8>
40029e54:	e21ff0ef          	jal	ra,40029c74 <pend_locked>
	return z_swap(&sched_spinlock, key);
40029e58:	00040593          	mv	a1,s0
}
40029e5c:	00812403          	lw	s0,8(sp)
40029e60:	00c12083          	lw	ra,12(sp)
	return z_swap(&sched_spinlock, key);
40029e64:	40033537          	lui	a0,0x40033
40029e68:	88c50513          	addi	a0,a0,-1908 # 4003288c <sched_spinlock>
}
40029e6c:	01010113          	addi	sp,sp,16
	return z_swap(&sched_spinlock, key);
40029e70:	ab9ff06f          	j	40029928 <z_swap>

40029e74 <z_unpend1_no_timeout>:
{
40029e74:	fe010113          	addi	sp,sp,-32
40029e78:	00112e23          	sw	ra,28(sp)
40029e7c:	00812c23          	sw	s0,24(sp)
40029e80:	00050793          	mv	a5,a0
40029e84:	30047473          	csrrci	s0,mstatus,8
	return list->head == list;
40029e88:	00052503          	lw	a0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40029e8c:	02a78663          	beq	a5,a0,40029eb8 <z_unpend1_no_timeout+0x44>
		if (thread != NULL) {
40029e90:	00050863          	beqz	a0,40029ea0 <z_unpend1_no_timeout+0x2c>
			unpend_thread_no_timeout(thread);
40029e94:	00a12623          	sw	a0,12(sp)
40029e98:	91dff0ef          	jal	ra,400297b4 <unpend_thread_no_timeout>
40029e9c:	00c12503          	lw	a0,12(sp)
	__asm__ volatile ("csrs mstatus, %0"
40029ea0:	00847413          	andi	s0,s0,8
40029ea4:	30042073          	csrs	mstatus,s0
}
40029ea8:	01c12083          	lw	ra,28(sp)
40029eac:	01812403          	lw	s0,24(sp)
40029eb0:	02010113          	addi	sp,sp,32
40029eb4:	00008067          	ret
40029eb8:	00000513          	li	a0,0
40029ebc:	fe5ff06f          	j	40029ea0 <z_unpend1_no_timeout+0x2c>

40029ec0 <z_unpend_first_thread>:
{
40029ec0:	ff010113          	addi	sp,sp,-16
40029ec4:	00112623          	sw	ra,12(sp)
40029ec8:	00812423          	sw	s0,8(sp)
40029ecc:	00912223          	sw	s1,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029ed0:	300474f3          	csrrci	s1,mstatus,8
	return list->head == list;
40029ed4:	00052403          	lw	s0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40029ed8:	02850c63          	beq	a0,s0,40029f10 <z_unpend_first_thread+0x50>
		if (thread != NULL) {
40029edc:	00040a63          	beqz	s0,40029ef0 <z_unpend_first_thread+0x30>
			unpend_thread_no_timeout(thread);
40029ee0:	00040513          	mv	a0,s0
40029ee4:	8d1ff0ef          	jal	ra,400297b4 <unpend_thread_no_timeout>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
40029ee8:	01840513          	addi	a0,s0,24
40029eec:	2bd000ef          	jal	ra,4002a9a8 <z_abort_timeout>
	__asm__ volatile ("csrs mstatus, %0"
40029ef0:	0084f493          	andi	s1,s1,8
40029ef4:	3004a073          	csrs	mstatus,s1
}
40029ef8:	00c12083          	lw	ra,12(sp)
40029efc:	00040513          	mv	a0,s0
40029f00:	00812403          	lw	s0,8(sp)
40029f04:	00412483          	lw	s1,4(sp)
40029f08:	01010113          	addi	sp,sp,16
40029f0c:	00008067          	ret
40029f10:	00000413          	li	s0,0
40029f14:	fddff06f          	j	40029ef0 <z_unpend_first_thread+0x30>

40029f18 <z_unpend_thread>:
{
40029f18:	ff010113          	addi	sp,sp,-16
40029f1c:	00812423          	sw	s0,8(sp)
40029f20:	00112623          	sw	ra,12(sp)
40029f24:	00912223          	sw	s1,4(sp)
40029f28:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029f2c:	300474f3          	csrrci	s1,mstatus,8
		if (thread->base.pended_on != NULL) {
40029f30:	00852783          	lw	a5,8(a0)
40029f34:	00078463          	beqz	a5,40029f3c <z_unpend_thread+0x24>
			unpend_thread_no_timeout(thread);
40029f38:	87dff0ef          	jal	ra,400297b4 <unpend_thread_no_timeout>
	__asm__ volatile ("csrs mstatus, %0"
40029f3c:	0084f493          	andi	s1,s1,8
40029f40:	3004a073          	csrs	mstatus,s1
40029f44:	01840513          	addi	a0,s0,24
}
40029f48:	00812403          	lw	s0,8(sp)
40029f4c:	00c12083          	lw	ra,12(sp)
40029f50:	00412483          	lw	s1,4(sp)
40029f54:	01010113          	addi	sp,sp,16
40029f58:	2510006f          	j	4002a9a8 <z_abort_timeout>

40029f5c <z_set_prio>:
{
40029f5c:	fe010113          	addi	sp,sp,-32
40029f60:	00812c23          	sw	s0,24(sp)
40029f64:	00112e23          	sw	ra,28(sp)
40029f68:	00912a23          	sw	s1,20(sp)
40029f6c:	01212823          	sw	s2,16(sp)
40029f70:	01312623          	sw	s3,12(sp)
40029f74:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40029f78:	300479f3          	csrrci	s3,mstatus,8
	uint8_t state = thread->base.thread_state;
40029f7c:	00d54783          	lbu	a5,13(a0)
				thread->base.prio = prio;
40029f80:	01859913          	slli	s2,a1,0x18
40029f84:	41895913          	srai	s2,s2,0x18
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
40029f88:	01f7f713          	andi	a4,a5,31
40029f8c:	06071263          	bnez	a4,40029ff0 <z_set_prio+0x94>
	return node->next != NULL;
40029f90:	01852483          	lw	s1,24(a0)
40029f94:	04049e63          	bnez	s1,40029ff0 <z_set_prio+0x94>
	thread->base.thread_state &= ~_THREAD_QUEUED;
40029f98:	07f7f793          	andi	a5,a5,127
40029f9c:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
40029fa0:	f6cff0ef          	jal	ra,4002970c <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
40029fa4:	00d44783          	lbu	a5,13(s0)
				thread->base.prio = prio;
40029fa8:	01240723          	sb	s2,14(s0)
	thread->base.thread_state |= _THREAD_QUEUED;
40029fac:	f807e793          	ori	a5,a5,-128
40029fb0:	00f406a3          	sb	a5,13(s0)
	return list->head == list;
40029fb4:	400337b7          	lui	a5,0x40033
40029fb8:	86878713          	addi	a4,a5,-1944 # 40032868 <_kernel>
40029fbc:	01872683          	lw	a3,24(a4)
40029fc0:	40033737          	lui	a4,0x40033
40029fc4:	88070713          	addi	a4,a4,-1920 # 40032880 <_kernel+0x18>
40029fc8:	86878793          	addi	a5,a5,-1944
	return sys_dlist_is_empty(list) ? NULL : list->head;
40029fcc:	00e68463          	beq	a3,a4,40029fd4 <z_set_prio+0x78>
40029fd0:	00068493          	mv	s1,a3
	return (node == list->tail) ? NULL : node->next;
40029fd4:	01c7a683          	lw	a3,28(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40029fd8:	04049263          	bnez	s1,4002a01c <z_set_prio+0xc0>
	node->next = list;
40029fdc:	00e42023          	sw	a4,0(s0)
	node->prev = tail;
40029fe0:	00d42223          	sw	a3,4(s0)
	tail->next = node;
40029fe4:	0086a023          	sw	s0,0(a3)
	list->tail = node;
40029fe8:	0087ae23          	sw	s0,28(a5)
}
40029fec:	0500006f          	j	4002a03c <z_set_prio+0xe0>
			thread->base.prio = prio;
40029ff0:	01240723          	sb	s2,14(s0)
40029ff4:	00000513          	li	a0,0
	__asm__ volatile ("csrs mstatus, %0"
40029ff8:	0089f993          	andi	s3,s3,8
40029ffc:	3009a073          	csrs	mstatus,s3
}
4002a000:	01c12083          	lw	ra,28(sp)
4002a004:	01812403          	lw	s0,24(sp)
4002a008:	01412483          	lw	s1,20(sp)
4002a00c:	01012903          	lw	s2,16(sp)
4002a010:	00c12983          	lw	s3,12(sp)
4002a014:	02010113          	addi	sp,sp,32
4002a018:	00008067          	ret
	int32_t b2 = thread_2->base.prio;
4002a01c:	00e48603          	lb	a2,14(s1)
	if (b1 != b2) {
4002a020:	02c90663          	beq	s2,a2,4002a04c <z_set_prio+0xf0>
		if (z_sched_prio_cmp(thread, t) > 0) {
4002a024:	02c95463          	bge	s2,a2,4002a04c <z_set_prio+0xf0>
	sys_dnode_t *const prev = successor->prev;
4002a028:	0044a783          	lw	a5,4(s1)
	node->next = successor;
4002a02c:	00942023          	sw	s1,0(s0)
	node->prev = prev;
4002a030:	00f42223          	sw	a5,4(s0)
	prev->next = node;
4002a034:	0087a023          	sw	s0,0(a5)
	successor->prev = node;
4002a038:	0084a223          	sw	s0,4(s1)
			update_cache(1);
4002a03c:	00100513          	li	a0,1
4002a040:	975ff0ef          	jal	ra,400299b4 <update_cache>
4002a044:	00100513          	li	a0,1
4002a048:	fb1ff06f          	j	40029ff8 <z_set_prio+0x9c>
	return (node == list->tail) ? NULL : node->next;
4002a04c:	f8d488e3          	beq	s1,a3,40029fdc <z_set_prio+0x80>
4002a050:	0004a483          	lw	s1,0(s1)
4002a054:	f85ff06f          	j	40029fd8 <z_set_prio+0x7c>

4002a058 <z_reschedule>:
	return (key & MSTATUS_IEN) != 0;
4002a058:	0085f713          	andi	a4,a1,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
4002a05c:	02070263          	beqz	a4,4002a080 <z_reschedule+0x28>
	return _kernel.cpus[0].nested != 0U;
4002a060:	400337b7          	lui	a5,0x40033
4002a064:	86878793          	addi	a5,a5,-1944 # 40032868 <_kernel>
4002a068:	0007a683          	lw	a3,0(a5)
4002a06c:	00069a63          	bnez	a3,4002a080 <z_reschedule+0x28>
	if (resched(key.key) && need_swap()) {
4002a070:	0147a683          	lw	a3,20(a5)
4002a074:	0087a783          	lw	a5,8(a5)
4002a078:	00f68463          	beq	a3,a5,4002a080 <z_reschedule+0x28>
		z_swap(lock, key);
4002a07c:	8adff06f          	j	40029928 <z_swap>
	__asm__ volatile ("csrs mstatus, %0"
4002a080:	30072073          	csrs	mstatus,a4
}
4002a084:	00008067          	ret

4002a088 <z_sched_start>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002a088:	300475f3          	csrrci	a1,mstatus,8
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
4002a08c:	00d54703          	lbu	a4,13(a0)
	if (z_has_thread_started(thread)) {
4002a090:	00477693          	andi	a3,a4,4
4002a094:	00069863          	bnez	a3,4002a0a4 <z_sched_start+0x1c>
	__asm__ volatile ("csrs mstatus, %0"
4002a098:	0085f593          	andi	a1,a1,8
4002a09c:	3005a073          	csrs	mstatus,a1
		return;
4002a0a0:	00008067          	ret
{
4002a0a4:	fe010113          	addi	sp,sp,-32
4002a0a8:	00112e23          	sw	ra,28(sp)
	thread->base.thread_state &= ~_THREAD_PRESTART;
4002a0ac:	ffb77713          	andi	a4,a4,-5
4002a0b0:	00e506a3          	sb	a4,13(a0)
4002a0b4:	00b12623          	sw	a1,12(sp)
	ready_thread(thread);
4002a0b8:	a39ff0ef          	jal	ra,40029af0 <ready_thread>
	z_reschedule(&sched_spinlock, key);
4002a0bc:	00c12583          	lw	a1,12(sp)
}
4002a0c0:	01c12083          	lw	ra,28(sp)
	z_reschedule(&sched_spinlock, key);
4002a0c4:	40033537          	lui	a0,0x40033
4002a0c8:	88c50513          	addi	a0,a0,-1908 # 4003288c <sched_spinlock>
}
4002a0cc:	02010113          	addi	sp,sp,32
	z_reschedule(&sched_spinlock, key);
4002a0d0:	f89ff06f          	j	4002a058 <z_reschedule>

4002a0d4 <z_reschedule_irqlock>:
	return (key & MSTATUS_IEN) != 0;
4002a0d4:	00857793          	andi	a5,a0,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
4002a0d8:	00078a63          	beqz	a5,4002a0ec <z_reschedule_irqlock+0x18>
4002a0dc:	40033737          	lui	a4,0x40033
4002a0e0:	86872703          	lw	a4,-1944(a4) # 40032868 <_kernel>
4002a0e4:	00071463          	bnez	a4,4002a0ec <z_reschedule_irqlock+0x18>
		z_swap_irqlock(key);
4002a0e8:	fc0ff06f          	j	400298a8 <z_swap_irqlock>
	__asm__ volatile ("csrs mstatus, %0"
4002a0ec:	3007a073          	csrs	mstatus,a5
}
4002a0f0:	00008067          	ret

4002a0f4 <z_reschedule_unlocked>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002a0f4:	30047573          	csrrci	a0,mstatus,8
	(void) z_reschedule_irqlock(arch_irq_lock());
4002a0f8:	fddff06f          	j	4002a0d4 <z_reschedule_irqlock>

4002a0fc <z_impl_k_thread_suspend>:
{
4002a0fc:	ff010113          	addi	sp,sp,-16
4002a100:	00812423          	sw	s0,8(sp)
4002a104:	00050413          	mv	s0,a0
4002a108:	01850513          	addi	a0,a0,24
4002a10c:	00112623          	sw	ra,12(sp)
4002a110:	00912223          	sw	s1,4(sp)
4002a114:	01212023          	sw	s2,0(sp)
4002a118:	091000ef          	jal	ra,4002a9a8 <z_abort_timeout>
4002a11c:	30047973          	csrrci	s2,mstatus,8
	return (thread->base.thread_state & state) != 0U;
4002a120:	00d44783          	lbu	a5,13(s0)
		if (z_is_thread_queued(thread)) {
4002a124:	01879713          	slli	a4,a5,0x18
4002a128:	41875713          	srai	a4,a4,0x18
4002a12c:	00075a63          	bgez	a4,4002a140 <z_impl_k_thread_suspend+0x44>
	thread->base.thread_state &= ~_THREAD_QUEUED;
4002a130:	07f7f793          	andi	a5,a5,127
4002a134:	00f406a3          	sb	a5,13(s0)
	sys_dlist_remove(&thread->base.qnode_dlist);
4002a138:	00040513          	mv	a0,s0
4002a13c:	dd0ff0ef          	jal	ra,4002970c <sys_dlist_remove>
		update_cache(thread == _current);
4002a140:	400334b7          	lui	s1,0x40033
4002a144:	86848493          	addi	s1,s1,-1944 # 40032868 <_kernel>
	thread->base.thread_state |= _THREAD_SUSPENDED;
4002a148:	00d44783          	lbu	a5,13(s0)
4002a14c:	0084a503          	lw	a0,8(s1)
	__asm__ volatile ("csrs mstatus, %0"
4002a150:	00897913          	andi	s2,s2,8
4002a154:	0107e793          	ori	a5,a5,16
4002a158:	40850533          	sub	a0,a0,s0
4002a15c:	00f406a3          	sb	a5,13(s0)
4002a160:	00153513          	seqz	a0,a0
4002a164:	851ff0ef          	jal	ra,400299b4 <update_cache>
4002a168:	30092073          	csrs	mstatus,s2
	if (thread == _current) {
4002a16c:	0084a783          	lw	a5,8(s1)
4002a170:	00879e63          	bne	a5,s0,4002a18c <z_impl_k_thread_suspend+0x90>
}
4002a174:	00812403          	lw	s0,8(sp)
4002a178:	00c12083          	lw	ra,12(sp)
4002a17c:	00412483          	lw	s1,4(sp)
4002a180:	00012903          	lw	s2,0(sp)
4002a184:	01010113          	addi	sp,sp,16
		z_reschedule_unlocked();
4002a188:	f6dff06f          	j	4002a0f4 <z_reschedule_unlocked>
}
4002a18c:	00c12083          	lw	ra,12(sp)
4002a190:	00812403          	lw	s0,8(sp)
4002a194:	00412483          	lw	s1,4(sp)
4002a198:	00012903          	lw	s2,0(sp)
4002a19c:	01010113          	addi	sp,sp,16
4002a1a0:	00008067          	ret

4002a1a4 <k_sched_lock>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002a1a4:	300477f3          	csrrci	a5,mstatus,8
	--_current->base.sched_locked;
4002a1a8:	40033737          	lui	a4,0x40033
4002a1ac:	87072683          	lw	a3,-1936(a4) # 40032870 <_kernel+0x8>
4002a1b0:	00f6c703          	lbu	a4,15(a3)
4002a1b4:	fff70713          	addi	a4,a4,-1
4002a1b8:	00e687a3          	sb	a4,15(a3)
	__asm__ volatile ("csrs mstatus, %0"
4002a1bc:	0087f793          	andi	a5,a5,8
4002a1c0:	3007a073          	csrs	mstatus,a5
}
4002a1c4:	00008067          	ret

4002a1c8 <k_sched_unlock>:
{
4002a1c8:	ff010113          	addi	sp,sp,-16
4002a1cc:	00112623          	sw	ra,12(sp)
4002a1d0:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002a1d4:	30047473          	csrrci	s0,mstatus,8
		++_current->base.sched_locked;
4002a1d8:	400337b7          	lui	a5,0x40033
4002a1dc:	8707a703          	lw	a4,-1936(a5) # 40032870 <_kernel+0x8>
		update_cache(0);
4002a1e0:	00000513          	li	a0,0
	__asm__ volatile ("csrs mstatus, %0"
4002a1e4:	00847413          	andi	s0,s0,8
		++_current->base.sched_locked;
4002a1e8:	00f74783          	lbu	a5,15(a4)
4002a1ec:	00178793          	addi	a5,a5,1
4002a1f0:	00f707a3          	sb	a5,15(a4)
		update_cache(0);
4002a1f4:	fc0ff0ef          	jal	ra,400299b4 <update_cache>
4002a1f8:	30042073          	csrs	mstatus,s0
}
4002a1fc:	00812403          	lw	s0,8(sp)
4002a200:	00c12083          	lw	ra,12(sp)
4002a204:	01010113          	addi	sp,sp,16
	z_reschedule_unlocked();
4002a208:	eedff06f          	j	4002a0f4 <z_reschedule_unlocked>

4002a20c <z_swap_next_thread>:
}
4002a20c:	400337b7          	lui	a5,0x40033
4002a210:	87c7a503          	lw	a0,-1924(a5) # 4003287c <_kernel+0x14>
4002a214:	00008067          	ret

4002a218 <z_get_next_switch_handle>:
	z_sched_usage_switch(_kernel.ready_q.cache);
4002a218:	400337b7          	lui	a5,0x40033
4002a21c:	86878793          	addi	a5,a5,-1944 # 40032868 <_kernel>
	_current->switch_handle = interrupted;
4002a220:	0087a683          	lw	a3,8(a5)
	z_sched_usage_switch(_kernel.ready_q.cache);
4002a224:	0147a703          	lw	a4,20(a5)
	_current->switch_handle = interrupted;
4002a228:	0ca6a023          	sw	a0,192(a3)
}
4002a22c:	0c072503          	lw	a0,192(a4)
	_current_cpu->current = new_thread;
4002a230:	00e7a423          	sw	a4,8(a5)
}
4002a234:	00008067          	ret

4002a238 <z_unpend_all>:
	}
	return thread;
}

int z_unpend_all(_wait_q_t *wait_q)
{
4002a238:	ff010113          	addi	sp,sp,-16
4002a23c:	00912223          	sw	s1,4(sp)
4002a240:	00112623          	sw	ra,12(sp)
4002a244:	00050493          	mv	s1,a0
4002a248:	00812423          	sw	s0,8(sp)
	int need_sched = 0;
4002a24c:	00000513          	li	a0,0
	return list->head == list;
4002a250:	0004a403          	lw	s0,0(s1)
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002a254:	00848463          	beq	s1,s0,4002a25c <z_unpend_all+0x24>
	struct k_thread *thread;

	while ((thread = z_waitq_head(wait_q)) != NULL) {
4002a258:	00041c63          	bnez	s0,4002a270 <z_unpend_all+0x38>
		z_ready_thread(thread);
		need_sched = 1;
	}

	return need_sched;
}
4002a25c:	00c12083          	lw	ra,12(sp)
4002a260:	00812403          	lw	s0,8(sp)
4002a264:	00412483          	lw	s1,4(sp)
4002a268:	01010113          	addi	sp,sp,16
4002a26c:	00008067          	ret
		z_unpend_thread(thread);
4002a270:	00040513          	mv	a0,s0
4002a274:	ca5ff0ef          	jal	ra,40029f18 <z_unpend_thread>
		z_ready_thread(thread);
4002a278:	00040513          	mv	a0,s0
4002a27c:	ad1ff0ef          	jal	ra,40029d4c <z_ready_thread>
		need_sched = 1;
4002a280:	00100513          	li	a0,1
4002a284:	fcdff06f          	j	4002a250 <z_unpend_all+0x18>

4002a288 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
4002a288:	400337b7          	lui	a5,0x40033
4002a28c:	40033737          	lui	a4,0x40033
4002a290:	86878793          	addi	a5,a5,-1944 # 40032868 <_kernel>
4002a294:	88070713          	addi	a4,a4,-1920 # 40032880 <_kernel+0x18>
4002a298:	00e7ac23          	sw	a4,24(a5)
	list->tail = (sys_dnode_t *)list;
4002a29c:	00e7ae23          	sw	a4,28(a5)
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
#endif
}
4002a2a0:	00008067          	ret

4002a2a4 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
4002a2a4:	ff010113          	addi	sp,sp,-16
4002a2a8:	00112623          	sw	ra,12(sp)
4002a2ac:	00812423          	sw	s0,8(sp)
4002a2b0:	00912223          	sw	s1,4(sp)
4002a2b4:	01212023          	sw	s2,0(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002a2b8:	30047973          	csrrci	s2,mstatus,8

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
4002a2bc:	40033437          	lui	s0,0x40033
4002a2c0:	86840493          	addi	s1,s0,-1944 # 40032868 <_kernel>
4002a2c4:	0084a503          	lw	a0,8(s1)
	thread->base.thread_state &= ~_THREAD_QUEUED;
4002a2c8:	86840413          	addi	s0,s0,-1944
4002a2cc:	00d54783          	lbu	a5,13(a0)
4002a2d0:	07f7f793          	andi	a5,a5,127
4002a2d4:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
4002a2d8:	c34ff0ef          	jal	ra,4002970c <sys_dlist_remove>
	}
	queue_thread(_current);
4002a2dc:	0084a783          	lw	a5,8(s1)
	thread->base.thread_state |= _THREAD_QUEUED;
4002a2e0:	400336b7          	lui	a3,0x40033
4002a2e4:	88068693          	addi	a3,a3,-1920 # 40032880 <_kernel+0x18>
4002a2e8:	00d7c703          	lbu	a4,13(a5)
4002a2ec:	f8076713          	ori	a4,a4,-128
4002a2f0:	00e786a3          	sb	a4,13(a5)
	return list->head == list;
4002a2f4:	0184a703          	lw	a4,24(s1)
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002a2f8:	00d71463          	bne	a4,a3,4002a300 <z_impl_k_yield+0x5c>
4002a2fc:	00000713          	li	a4,0
	return (node == list->tail) ? NULL : node->next;
4002a300:	01c42603          	lw	a2,28(s0)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
4002a304:	00071c63          	bnez	a4,4002a31c <z_impl_k_yield+0x78>
	node->next = list;
4002a308:	00d7a023          	sw	a3,0(a5)
	node->prev = tail;
4002a30c:	00c7a223          	sw	a2,4(a5)
	tail->next = node;
4002a310:	00f62023          	sw	a5,0(a2)
	list->tail = node;
4002a314:	00f42e23          	sw	a5,28(s0)
}
4002a318:	0280006f          	j	4002a340 <z_impl_k_yield+0x9c>
	int32_t b1 = thread_1->base.prio;
4002a31c:	00e78583          	lb	a1,14(a5)
	int32_t b2 = thread_2->base.prio;
4002a320:	00e70503          	lb	a0,14(a4)
	if (b1 != b2) {
4002a324:	04a58463          	beq	a1,a0,4002a36c <z_impl_k_yield+0xc8>
		if (z_sched_prio_cmp(thread, t) > 0) {
4002a328:	04a5d263          	bge	a1,a0,4002a36c <z_impl_k_yield+0xc8>
	sys_dnode_t *const prev = successor->prev;
4002a32c:	00472683          	lw	a3,4(a4)
	node->next = successor;
4002a330:	00e7a023          	sw	a4,0(a5)
	node->prev = prev;
4002a334:	00d7a223          	sw	a3,4(a5)
	prev->next = node;
4002a338:	00f6a023          	sw	a5,0(a3)
	successor->prev = node;
4002a33c:	00f72223          	sw	a5,4(a4)
	update_cache(1);
4002a340:	00100513          	li	a0,1
4002a344:	e70ff0ef          	jal	ra,400299b4 <update_cache>
	z_swap(&sched_spinlock, key);
}
4002a348:	00812403          	lw	s0,8(sp)
4002a34c:	00c12083          	lw	ra,12(sp)
4002a350:	00412483          	lw	s1,4(sp)
	z_swap(&sched_spinlock, key);
4002a354:	00090593          	mv	a1,s2
}
4002a358:	00012903          	lw	s2,0(sp)
	z_swap(&sched_spinlock, key);
4002a35c:	40033537          	lui	a0,0x40033
4002a360:	88c50513          	addi	a0,a0,-1908 # 4003288c <sched_spinlock>
}
4002a364:	01010113          	addi	sp,sp,16
	z_swap(&sched_spinlock, key);
4002a368:	dc0ff06f          	j	40029928 <z_swap>
	return (node == list->tail) ? NULL : node->next;
4002a36c:	f8c70ee3          	beq	a4,a2,4002a308 <z_impl_k_yield+0x64>
4002a370:	00072703          	lw	a4,0(a4)
4002a374:	f91ff06f          	j	4002a304 <z_impl_k_yield+0x60>

4002a378 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
4002a378:	fe010113          	addi	sp,sp,-32
4002a37c:	00112e23          	sw	ra,28(sp)
4002a380:	00812c23          	sw	s0,24(sp)
4002a384:	00912a23          	sw	s1,20(sp)
4002a388:	01212823          	sw	s2,16(sp)
4002a38c:	01312623          	sw	s3,12(sp)
4002a390:	01412423          	sw	s4,8(sp)
	__ASSERT(!arch_is_in_isr(), "");

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
4002a394:	00b567b3          	or	a5,a0,a1
4002a398:	00079863          	bnez	a5,4002a3a8 <z_tick_sleep+0x30>
	z_impl_k_yield();
4002a39c:	f09ff0ef          	jal	ra,4002a2a4 <z_impl_k_yield>
		k_yield();
		return 0;
4002a3a0:	00000513          	li	a0,0
4002a3a4:	0940006f          	j	4002a438 <z_tick_sleep+0xc0>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
4002a3a8:	fff00793          	li	a5,-1
4002a3ac:	00050493          	mv	s1,a0
4002a3b0:	00058913          	mv	s2,a1
4002a3b4:	0af5c263          	blt	a1,a5,4002a458 <z_tick_sleep+0xe0>
4002a3b8:	00f59663          	bne	a1,a5,4002a3c4 <z_tick_sleep+0x4c>
4002a3bc:	ffe00793          	li	a5,-2
4002a3c0:	08f56c63          	bltu	a0,a5,4002a458 <z_tick_sleep+0xe0>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
4002a3c4:	7e4000ef          	jal	ra,4002aba8 <sys_clock_tick_get_32>
4002a3c8:	00a48433          	add	s0,s1,a0
4002a3cc:	30047a73          	csrrci	s4,mstatus,8
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	unready_thread(_current);
4002a3d0:	400339b7          	lui	s3,0x40033
4002a3d4:	86898993          	addi	s3,s3,-1944 # 40032868 <_kernel>
4002a3d8:	0089a503          	lw	a0,8(s3)
4002a3dc:	fb4ff0ef          	jal	ra,40029b90 <unready_thread>
	z_add_thread_timeout(_current, timeout);
4002a3e0:	0089a503          	lw	a0,8(s3)
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
4002a3e4:	4002a5b7          	lui	a1,0x4002a
4002a3e8:	00048613          	mv	a2,s1
4002a3ec:	00090693          	mv	a3,s2
4002a3f0:	e2058593          	addi	a1,a1,-480 # 40029e20 <z_thread_timeout>
4002a3f4:	01850513          	addi	a0,a0,24
4002a3f8:	410000ef          	jal	ra,4002a808 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
4002a3fc:	0089a703          	lw	a4,8(s3)

	(void)z_swap(&sched_spinlock, key);
4002a400:	40033537          	lui	a0,0x40033
4002a404:	000a0593          	mv	a1,s4
	thread->base.thread_state |= _THREAD_SUSPENDED;
4002a408:	00d74783          	lbu	a5,13(a4)
4002a40c:	88c50513          	addi	a0,a0,-1908 # 4003288c <sched_spinlock>
4002a410:	0107e793          	ori	a5,a5,16
4002a414:	00f706a3          	sb	a5,13(a4)
4002a418:	d10ff0ef          	jal	ra,40029928 <z_swap>

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
4002a41c:	78c000ef          	jal	ra,4002aba8 <sys_clock_tick_get_32>
4002a420:	40a407b3          	sub	a5,s0,a0
4002a424:	00f43433          	sltu	s0,s0,a5
4002a428:	40800433          	neg	s0,s0
	if (ticks > 0) {
4002a42c:	f6041ae3          	bnez	s0,4002a3a0 <z_tick_sleep+0x28>
		return ticks;
4002a430:	00078513          	mv	a0,a5
	if (ticks > 0) {
4002a434:	f60786e3          	beqz	a5,4002a3a0 <z_tick_sleep+0x28>
	}
#endif

	return 0;
}
4002a438:	01c12083          	lw	ra,28(sp)
4002a43c:	01812403          	lw	s0,24(sp)
4002a440:	01412483          	lw	s1,20(sp)
4002a444:	01012903          	lw	s2,16(sp)
4002a448:	00c12983          	lw	s3,12(sp)
4002a44c:	00812a03          	lw	s4,8(sp)
4002a450:	02010113          	addi	sp,sp,32
4002a454:	00008067          	ret
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
4002a458:	ffe00413          	li	s0,-2
4002a45c:	40940433          	sub	s0,s0,s1
4002a460:	f6dff06f          	j	4002a3cc <z_tick_sleep+0x54>

4002a464 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
4002a464:	ff010113          	addi	sp,sp,-16
4002a468:	00112623          	sw	ra,12(sp)
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
4002a46c:	fff00693          	li	a3,-1
4002a470:	02d51263          	bne	a0,a3,4002a494 <z_impl_k_sleep+0x30>
4002a474:	02a59063          	bne	a1,a0,4002a494 <z_impl_k_sleep+0x30>
		k_thread_suspend(_current);
4002a478:	400337b7          	lui	a5,0x40033
4002a47c:	8707a503          	lw	a0,-1936(a5) # 40032870 <_kernel+0x8>
	z_impl_k_thread_suspend(thread);
4002a480:	c7dff0ef          	jal	ra,4002a0fc <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
4002a484:	fff00513          	li	a0,-1
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
4002a488:	00c12083          	lw	ra,12(sp)
4002a48c:	01010113          	addi	sp,sp,16
4002a490:	00008067          	ret
	ticks = z_tick_sleep(ticks);
4002a494:	ee5ff0ef          	jal	ra,4002a378 <z_tick_sleep>
			return t * ((uint64_t)to_hz / from_hz);
4002a498:	00a00793          	li	a5,10
4002a49c:	02f50533          	mul	a0,a0,a5
	return ret;
4002a4a0:	fe9ff06f          	j	4002a488 <z_impl_k_sleep+0x24>

4002a4a4 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
4002a4a4:	400337b7          	lui	a5,0x40033
4002a4a8:	8707a503          	lw	a0,-1936(a5) # 40032870 <_kernel+0x8>
4002a4ac:	00008067          	ret

4002a4b0 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
4002a4b0:	fe010113          	addi	sp,sp,-32
4002a4b4:	00112e23          	sw	ra,28(sp)
4002a4b8:	00812c23          	sw	s0,24(sp)
4002a4bc:	00912a23          	sw	s1,20(sp)
4002a4c0:	01212823          	sw	s2,16(sp)
4002a4c4:	01312623          	sw	s3,12(sp)
4002a4c8:	01412423          	sw	s4,8(sp)
4002a4cc:	300479f3          	csrrci	s3,mstatus,8
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
4002a4d0:	00c54783          	lbu	a5,12(a0)
4002a4d4:	0089f913          	andi	s2,s3,8
4002a4d8:	0017f793          	andi	a5,a5,1
4002a4dc:	02078a63          	beqz	a5,4002a510 <z_thread_abort+0x60>
	__asm__ volatile ("csrs mstatus, %0"
4002a4e0:	30092073          	csrs	mstatus,s2
	return a0;
}

static inline uintptr_t arch_syscall_invoke1(uintptr_t arg1, uintptr_t call_id)
{
	register unsigned long a0 __asm__ ("a0") = arg1;
4002a4e4:	00400513          	li	a0,4
	register unsigned long t0 __asm__ ("t0") = call_id;
4002a4e8:	00000293          	li	t0,0

	__asm__ volatile ("ecall"
4002a4ec:	00000073          	ecall
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
4002a4f0:	01c12083          	lw	ra,28(sp)
4002a4f4:	01812403          	lw	s0,24(sp)
4002a4f8:	01412483          	lw	s1,20(sp)
4002a4fc:	01012903          	lw	s2,16(sp)
4002a500:	00c12983          	lw	s3,12(sp)
4002a504:	00812a03          	lw	s4,8(sp)
4002a508:	02010113          	addi	sp,sp,32
4002a50c:	00008067          	ret
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
4002a510:	00d54783          	lbu	a5,13(a0)
4002a514:	00050413          	mv	s0,a0
4002a518:	0087f713          	andi	a4,a5,8
4002a51c:	00070663          	beqz	a4,4002a528 <z_thread_abort+0x78>
4002a520:	30092073          	csrs	mstatus,s2
4002a524:	fcdff06f          	j	4002a4f0 <z_thread_abort+0x40>
		thread->base.thread_state &= ~_THREAD_ABORTING;
4002a528:	fdf7f713          	andi	a4,a5,-33
4002a52c:	00876713          	ori	a4,a4,8
		if (z_is_thread_queued(thread)) {
4002a530:	01871693          	slli	a3,a4,0x18
4002a534:	4186d693          	srai	a3,a3,0x18
4002a538:	0606c663          	bltz	a3,4002a5a4 <z_thread_abort+0xf4>
		thread->base.thread_state &= ~_THREAD_ABORTING;
4002a53c:	00e506a3          	sb	a4,13(a0)
		if (thread->base.pended_on != NULL) {
4002a540:	00842783          	lw	a5,8(s0)
4002a544:	00078663          	beqz	a5,4002a550 <z_thread_abort+0xa0>
			unpend_thread_no_timeout(thread);
4002a548:	00040513          	mv	a0,s0
4002a54c:	a68ff0ef          	jal	ra,400297b4 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
4002a550:	01840513          	addi	a0,s0,24
4002a554:	454000ef          	jal	ra,4002a9a8 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
4002a558:	06c40a13          	addi	s4,s0,108
	return list->head == list;
4002a55c:	06c42483          	lw	s1,108(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002a560:	01448463          	beq	s1,s4,4002a568 <z_thread_abort+0xb8>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
4002a564:	04049a63          	bnez	s1,4002a5b8 <z_thread_abort+0x108>
		update_cache(1);
4002a568:	00100513          	li	a0,1
4002a56c:	c48ff0ef          	jal	ra,400299b4 <update_cache>
		z_thread_monitor_exit(thread);
4002a570:	00040513          	mv	a0,s0
4002a574:	b6dfd0ef          	jal	ra,400280e0 <z_thread_monitor_exit>
	if (thread == _current && !arch_is_in_isr()) {
4002a578:	400337b7          	lui	a5,0x40033
4002a57c:	86878793          	addi	a5,a5,-1944 # 40032868 <_kernel>
4002a580:	0087a703          	lw	a4,8(a5)
4002a584:	f8871ee3          	bne	a4,s0,4002a520 <z_thread_abort+0x70>
4002a588:	0007a783          	lw	a5,0(a5)
4002a58c:	f8079ae3          	bnez	a5,4002a520 <z_thread_abort+0x70>
		z_swap(&sched_spinlock, key);
4002a590:	40033537          	lui	a0,0x40033
4002a594:	00098593          	mv	a1,s3
4002a598:	88c50513          	addi	a0,a0,-1908 # 4003288c <sched_spinlock>
4002a59c:	b8cff0ef          	jal	ra,40029928 <z_swap>
4002a5a0:	f81ff06f          	j	4002a520 <z_thread_abort+0x70>
	thread->base.thread_state &= ~_THREAD_QUEUED;
4002a5a4:	05f7f793          	andi	a5,a5,95
4002a5a8:	0087e793          	ori	a5,a5,8
4002a5ac:	00f506a3          	sb	a5,13(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
4002a5b0:	95cff0ef          	jal	ra,4002970c <sys_dlist_remove>
}
4002a5b4:	f8dff06f          	j	4002a540 <z_thread_abort+0x90>
		unpend_thread_no_timeout(thread);
4002a5b8:	00048513          	mv	a0,s1
4002a5bc:	9f8ff0ef          	jal	ra,400297b4 <unpend_thread_no_timeout>
4002a5c0:	01848513          	addi	a0,s1,24
4002a5c4:	3e4000ef          	jal	ra,4002a9a8 <z_abort_timeout>
		ready_thread(thread);
4002a5c8:	00048513          	mv	a0,s1
4002a5cc:	0a04ae23          	sw	zero,188(s1)
4002a5d0:	d20ff0ef          	jal	ra,40029af0 <ready_thread>
4002a5d4:	f89ff06f          	j	4002a55c <z_thread_abort+0xac>

4002a5d8 <z_impl_k_thread_abort>:
#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
4002a5d8:	ed9ff06f          	j	4002a4b0 <z_thread_abort>

4002a5dc <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
4002a5dc:	ff010113          	addi	sp,sp,-16
4002a5e0:	00112623          	sw	ra,12(sp)
4002a5e4:	00812423          	sw	s0,8(sp)
4002a5e8:	00912223          	sw	s1,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002a5ec:	300474f3          	csrrci	s1,mstatus,8
	return list->head == list;
4002a5f0:	00052403          	lw	s0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002a5f4:	04850663          	beq	a0,s0,4002a640 <z_sched_wake+0x64>
	struct k_thread *thread;
	bool ret = false;
4002a5f8:	00000513          	li	a0,0

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);

		if (thread != NULL) {
4002a5fc:	02040463          	beqz	s0,4002a624 <z_sched_wake+0x48>
4002a600:	0ab42e23          	sw	a1,188(s0)
	thread->base.swap_data = data;
4002a604:	00c42a23          	sw	a2,20(s0)
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
4002a608:	00040513          	mv	a0,s0
4002a60c:	9a8ff0ef          	jal	ra,400297b4 <unpend_thread_no_timeout>
4002a610:	01840513          	addi	a0,s0,24
4002a614:	394000ef          	jal	ra,4002a9a8 <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
4002a618:	00040513          	mv	a0,s0
4002a61c:	cd4ff0ef          	jal	ra,40029af0 <ready_thread>
			ret = true;
4002a620:	00100513          	li	a0,1
	__asm__ volatile ("csrs mstatus, %0"
4002a624:	0084f493          	andi	s1,s1,8
4002a628:	3004a073          	csrs	mstatus,s1
		}
	}

	return ret;
}
4002a62c:	00c12083          	lw	ra,12(sp)
4002a630:	00812403          	lw	s0,8(sp)
4002a634:	00412483          	lw	s1,4(sp)
4002a638:	01010113          	addi	sp,sp,16
4002a63c:	00008067          	ret
	bool ret = false;
4002a640:	00000513          	li	a0,0
4002a644:	fe1ff06f          	j	4002a624 <z_sched_wake+0x48>

4002a648 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
4002a648:	ff010113          	addi	sp,sp,-16
4002a64c:	00812423          	sw	s0,8(sp)
4002a650:	00078413          	mv	s0,a5
4002a654:	00112623          	sw	ra,12(sp)
	int ret = z_pend_curr(lock, key, wait_q, timeout);
4002a658:	fd4ff0ef          	jal	ra,40029e2c <z_pend_curr>

	if (data != NULL) {
4002a65c:	00040a63          	beqz	s0,4002a670 <z_sched_wait+0x28>
		*data = _current->base.swap_data;
4002a660:	400337b7          	lui	a5,0x40033
4002a664:	8707a783          	lw	a5,-1936(a5) # 40032870 <_kernel+0x8>
4002a668:	0147a783          	lw	a5,20(a5)
4002a66c:	00f42023          	sw	a5,0(s0)
	}
	return ret;
}
4002a670:	00c12083          	lw	ra,12(sp)
4002a674:	00812403          	lw	s0,8(sp)
4002a678:	01010113          	addi	sp,sp,16
4002a67c:	00008067          	ret

4002a680 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
4002a680:	400317b7          	lui	a5,0x40031
4002a684:	afc7a783          	lw	a5,-1284(a5) # 40030afc <announce_remaining>
4002a688:	00079463          	bnez	a5,4002a690 <elapsed+0x10>
4002a68c:	ec9fb06f          	j	40026554 <sys_clock_elapsed>
}
4002a690:	00000513          	li	a0,0
4002a694:	00008067          	ret

4002a698 <next_timeout>:

static int32_t next_timeout(void)
{
4002a698:	ff010113          	addi	sp,sp,-16
	return list->head == list;
4002a69c:	4003d7b7          	lui	a5,0x4003d
4002a6a0:	00112623          	sw	ra,12(sp)
4002a6a4:	00812423          	sw	s0,8(sp)
4002a6a8:	a1878793          	addi	a5,a5,-1512 # 4003ca18 <timeout_list>
4002a6ac:	0007a403          	lw	s0,0(a5)
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002a6b0:	02f41063          	bne	s0,a5,4002a6d0 <next_timeout+0x38>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
4002a6b4:	fcdff0ef          	jal	ra,4002a680 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
4002a6b8:	80000537          	lui	a0,0x80000
4002a6bc:	fff50513          	addi	a0,a0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

	return ret;
}
4002a6c0:	00c12083          	lw	ra,12(sp)
4002a6c4:	00812403          	lw	s0,8(sp)
4002a6c8:	01010113          	addi	sp,sp,16
4002a6cc:	00008067          	ret
	int32_t ticks_elapsed = elapsed();
4002a6d0:	fb1ff0ef          	jal	ra,4002a680 <elapsed>
	if ((to == NULL) ||
4002a6d4:	fe0402e3          	beqz	s0,4002a6b8 <next_timeout+0x20>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
4002a6d8:	01042703          	lw	a4,16(s0)
4002a6dc:	01442783          	lw	a5,20(s0)
4002a6e0:	41f55693          	srai	a3,a0,0x1f
4002a6e4:	40a70533          	sub	a0,a4,a0
4002a6e8:	00a73733          	sltu	a4,a4,a0
4002a6ec:	40d787b3          	sub	a5,a5,a3
4002a6f0:	40e787b3          	sub	a5,a5,a4
	if ((to == NULL) ||
4002a6f4:	fcf042e3          	bgtz	a5,4002a6b8 <next_timeout+0x20>
4002a6f8:	00079463          	bnez	a5,4002a700 <next_timeout+0x68>
4002a6fc:	fa054ee3          	bltz	a0,4002a6b8 <next_timeout+0x20>
		ret = MAX(0, to->dticks - ticks_elapsed);
4002a700:	fc07d0e3          	bgez	a5,4002a6c0 <next_timeout+0x28>
4002a704:	00000513          	li	a0,0
	return ret;
4002a708:	fb9ff06f          	j	4002a6c0 <next_timeout+0x28>

4002a70c <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
4002a70c:	04050063          	beqz	a0,4002a74c <remove_timeout+0x40>
	return (node == list->tail) ? NULL : node->next;
4002a710:	4003d7b7          	lui	a5,0x4003d
4002a714:	a1c7a783          	lw	a5,-1508(a5) # 4003ca1c <timeout_list+0x4>
4002a718:	02f50a63          	beq	a0,a5,4002a74c <remove_timeout+0x40>
4002a71c:	00052703          	lw	a4,0(a0)
	if (next(t) != NULL) {
4002a720:	02070663          	beqz	a4,4002a74c <remove_timeout+0x40>
		next(t)->dticks += t->dticks;
4002a724:	01072783          	lw	a5,16(a4)
4002a728:	01052683          	lw	a3,16(a0)
4002a72c:	01452583          	lw	a1,20(a0)
4002a730:	01472603          	lw	a2,20(a4)
4002a734:	00d786b3          	add	a3,a5,a3
4002a738:	00f6b7b3          	sltu	a5,a3,a5
4002a73c:	00b60633          	add	a2,a2,a1
4002a740:	00c787b3          	add	a5,a5,a2
4002a744:	00d72823          	sw	a3,16(a4)
4002a748:	00f72a23          	sw	a5,20(a4)
	sys_dnode_t *const prev = node->prev;
4002a74c:	00452703          	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
4002a750:	00052783          	lw	a5,0(a0)
	prev->next = next;
4002a754:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
4002a758:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
4002a75c:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
4002a760:	00052223          	sw	zero,4(a0)
}
4002a764:	00008067          	ret

4002a768 <timeout_rem>:
/* must be locked */
static k_ticks_t timeout_rem(const struct _timeout *timeout)
{
	k_ticks_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
4002a768:	00052783          	lw	a5,0(a0)
4002a76c:	08078863          	beqz	a5,4002a7fc <timeout_rem+0x94>
	return list->head == list;
4002a770:	4003d737          	lui	a4,0x4003d
4002a774:	a1872783          	lw	a5,-1512(a4) # 4003ca18 <timeout_list>
{
4002a778:	ff010113          	addi	sp,sp,-16
4002a77c:	00112623          	sw	ra,12(sp)
4002a780:	00812423          	sw	s0,8(sp)
4002a784:	00912223          	sw	s1,4(sp)
4002a788:	a1870713          	addi	a4,a4,-1512
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002a78c:	00e79463          	bne	a5,a4,4002a794 <timeout_rem+0x2c>
4002a790:	00000793          	li	a5,0
	return (node == list->tail) ? NULL : node->next;
4002a794:	00472683          	lw	a3,4(a4)
4002a798:	00000493          	li	s1,0
4002a79c:	00000413          	li	s0,0
		return 0;
	}

	for (struct _timeout *t = first(); t != NULL; t = next(t)) {
4002a7a0:	02079863          	bnez	a5,4002a7d0 <timeout_rem+0x68>
		if (timeout == t) {
			break;
		}
	}

	return ticks - elapsed();
4002a7a4:	eddff0ef          	jal	ra,4002a680 <elapsed>
4002a7a8:	41f55793          	srai	a5,a0,0x1f
}
4002a7ac:	00c12083          	lw	ra,12(sp)
	return ticks - elapsed();
4002a7b0:	40f405b3          	sub	a1,s0,a5
}
4002a7b4:	00812403          	lw	s0,8(sp)
	return ticks - elapsed();
4002a7b8:	40a48533          	sub	a0,s1,a0
4002a7bc:	00a4b4b3          	sltu	s1,s1,a0
4002a7c0:	409585b3          	sub	a1,a1,s1
}
4002a7c4:	00412483          	lw	s1,4(sp)
4002a7c8:	01010113          	addi	sp,sp,16
4002a7cc:	00008067          	ret
		ticks += t->dticks;
4002a7d0:	0107a703          	lw	a4,16(a5)
4002a7d4:	0147a583          	lw	a1,20(a5)
4002a7d8:	00e48733          	add	a4,s1,a4
4002a7dc:	00973633          	sltu	a2,a4,s1
4002a7e0:	00b40433          	add	s0,s0,a1
4002a7e4:	00070493          	mv	s1,a4
4002a7e8:	00860433          	add	s0,a2,s0
		if (timeout == t) {
4002a7ec:	faa78ce3          	beq	a5,a0,4002a7a4 <timeout_rem+0x3c>
4002a7f0:	faf68ae3          	beq	a3,a5,4002a7a4 <timeout_rem+0x3c>
4002a7f4:	0007a783          	lw	a5,0(a5)
4002a7f8:	fa9ff06f          	j	4002a7a0 <timeout_rem+0x38>
		return 0;
4002a7fc:	00000513          	li	a0,0
4002a800:	00000593          	li	a1,0
}
4002a804:	00008067          	ret

4002a808 <z_add_timeout>:
{
4002a808:	fe010113          	addi	sp,sp,-32
4002a80c:	00812c23          	sw	s0,24(sp)
4002a810:	01212823          	sw	s2,16(sp)
4002a814:	01312623          	sw	s3,12(sp)
4002a818:	00068713          	mv	a4,a3
4002a81c:	00068993          	mv	s3,a3
4002a820:	00112e23          	sw	ra,28(sp)
4002a824:	00912a23          	sw	s1,20(sp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
4002a828:	fff00693          	li	a3,-1
{
4002a82c:	00050413          	mv	s0,a0
4002a830:	00060913          	mv	s2,a2
4002a834:	00060793          	mv	a5,a2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
4002a838:	00d61463          	bne	a2,a3,4002a840 <z_add_timeout+0x38>
4002a83c:	12c98663          	beq	s3,a2,4002a968 <z_add_timeout+0x160>
	to->fn = fn;
4002a840:	00b42423          	sw	a1,8(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002a844:	300474f3          	csrrci	s1,mstatus,8
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
4002a848:	08075863          	bgez	a4,4002a8d8 <z_add_timeout+0xd0>
4002a84c:	fff00693          	li	a3,-1
4002a850:	00d71663          	bne	a4,a3,4002a85c <z_add_timeout+0x54>
4002a854:	ffe00713          	li	a4,-2
4002a858:	08f76063          	bltu	a4,a5,4002a8d8 <z_add_timeout+0xd0>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
4002a85c:	400317b7          	lui	a5,0x40031
4002a860:	9e07a703          	lw	a4,-1568(a5) # 400309e0 <curr_tick>
4002a864:	9e47a783          	lw	a5,-1564(a5)
4002a868:	ffe00693          	li	a3,-2
4002a86c:	40e68733          	sub	a4,a3,a4
4002a870:	00e6b6b3          	sltu	a3,a3,a4
4002a874:	fff7c793          	not	a5,a5
4002a878:	40d787b3          	sub	a5,a5,a3
4002a87c:	41270533          	sub	a0,a4,s2
4002a880:	00a73733          	sltu	a4,a4,a0
4002a884:	413787b3          	sub	a5,a5,s3
4002a888:	40e787b3          	sub	a5,a5,a4
			to->dticks = MAX(1, ticks);
4002a88c:	00f04a63          	bgtz	a5,4002a8a0 <z_add_timeout+0x98>
4002a890:	00079463          	bnez	a5,4002a898 <z_add_timeout+0x90>
4002a894:	00051663          	bnez	a0,4002a8a0 <z_add_timeout+0x98>
4002a898:	00100513          	li	a0,1
4002a89c:	00000793          	li	a5,0
	return list->head == list;
4002a8a0:	4003d737          	lui	a4,0x4003d
4002a8a4:	00f42a23          	sw	a5,20(s0)
4002a8a8:	a1872783          	lw	a5,-1512(a4) # 4003ca18 <timeout_list>
4002a8ac:	00a42823          	sw	a0,16(s0)
4002a8b0:	a1870713          	addi	a4,a4,-1512
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002a8b4:	00e79463          	bne	a5,a4,4002a8bc <z_add_timeout+0xb4>
4002a8b8:	00000793          	li	a5,0
	return (node == list->tail) ? NULL : node->next;
4002a8bc:	00472803          	lw	a6,4(a4)
		for (t = first(); t != NULL; t = next(t)) {
4002a8c0:	04079063          	bnez	a5,4002a900 <z_add_timeout+0xf8>
	node->next = list;
4002a8c4:	00e42023          	sw	a4,0(s0)
	node->prev = tail;
4002a8c8:	01042223          	sw	a6,4(s0)
	tail->next = node;
4002a8cc:	00882023          	sw	s0,0(a6)
	list->tail = node;
4002a8d0:	00872223          	sw	s0,4(a4)
}
4002a8d4:	0740006f          	j	4002a948 <z_add_timeout+0x140>
			to->dticks = timeout.ticks + 1 + elapsed();
4002a8d8:	da9ff0ef          	jal	ra,4002a680 <elapsed>
4002a8dc:	00190793          	addi	a5,s2,1
4002a8e0:	0127b933          	sltu	s2,a5,s2
4002a8e4:	41f55713          	srai	a4,a0,0x1f
4002a8e8:	01390933          	add	s2,s2,s3
4002a8ec:	00a78533          	add	a0,a5,a0
4002a8f0:	00f537b3          	sltu	a5,a0,a5
4002a8f4:	00e90933          	add	s2,s2,a4
4002a8f8:	012787b3          	add	a5,a5,s2
4002a8fc:	fa5ff06f          	j	4002a8a0 <z_add_timeout+0x98>
			if (t->dticks > to->dticks) {
4002a900:	0147a503          	lw	a0,20(a5)
4002a904:	01442583          	lw	a1,20(s0)
4002a908:	0107a683          	lw	a3,16(a5)
4002a90c:	01042603          	lw	a2,16(s0)
4002a910:	00a5c663          	blt	a1,a0,4002a91c <z_add_timeout+0x114>
4002a914:	06b51863          	bne	a0,a1,4002a984 <z_add_timeout+0x17c>
4002a918:	06d67663          	bgeu	a2,a3,4002a984 <z_add_timeout+0x17c>
				t->dticks -= to->dticks;
4002a91c:	40c68633          	sub	a2,a3,a2
4002a920:	00c6b6b3          	sltu	a3,a3,a2
4002a924:	40b50533          	sub	a0,a0,a1
4002a928:	40d50533          	sub	a0,a0,a3
	sys_dnode_t *const prev = successor->prev;
4002a92c:	0047a683          	lw	a3,4(a5)
4002a930:	00c7a823          	sw	a2,16(a5)
4002a934:	00a7aa23          	sw	a0,20(a5)
	node->prev = prev;
4002a938:	00d42223          	sw	a3,4(s0)
	node->next = successor;
4002a93c:	00f42023          	sw	a5,0(s0)
	prev->next = node;
4002a940:	0086a023          	sw	s0,0(a3)
	successor->prev = node;
4002a944:	0087a223          	sw	s0,4(a5)
	return list->head == list;
4002a948:	00072783          	lw	a5,0(a4)
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002a94c:	00e78a63          	beq	a5,a4,4002a960 <z_add_timeout+0x158>
		if (to == first()) {
4002a950:	00f41863          	bne	s0,a5,4002a960 <z_add_timeout+0x158>
			sys_clock_set_timeout(next_timeout(), false);
4002a954:	d45ff0ef          	jal	ra,4002a698 <next_timeout>
4002a958:	00000593          	li	a1,0
4002a95c:	b45fb0ef          	jal	ra,400264a0 <sys_clock_set_timeout>
	__asm__ volatile ("csrs mstatus, %0"
4002a960:	0084f493          	andi	s1,s1,8
4002a964:	3004a073          	csrs	mstatus,s1
}
4002a968:	01c12083          	lw	ra,28(sp)
4002a96c:	01812403          	lw	s0,24(sp)
4002a970:	01412483          	lw	s1,20(sp)
4002a974:	01012903          	lw	s2,16(sp)
4002a978:	00c12983          	lw	s3,12(sp)
4002a97c:	02010113          	addi	sp,sp,32
4002a980:	00008067          	ret
			to->dticks -= t->dticks;
4002a984:	40d606b3          	sub	a3,a2,a3
4002a988:	00d63633          	sltu	a2,a2,a3
4002a98c:	40a585b3          	sub	a1,a1,a0
4002a990:	40c585b3          	sub	a1,a1,a2
4002a994:	00d42823          	sw	a3,16(s0)
4002a998:	00b42a23          	sw	a1,20(s0)
	return (node == list->tail) ? NULL : node->next;
4002a99c:	f30784e3          	beq	a5,a6,4002a8c4 <z_add_timeout+0xbc>
4002a9a0:	0007a783          	lw	a5,0(a5)
4002a9a4:	f1dff06f          	j	4002a8c0 <z_add_timeout+0xb8>

4002a9a8 <z_abort_timeout>:
{
4002a9a8:	ff010113          	addi	sp,sp,-16
4002a9ac:	00112623          	sw	ra,12(sp)
4002a9b0:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002a9b4:	30047473          	csrrci	s0,mstatus,8
		if (sys_dnode_is_linked(&to->node)) {
4002a9b8:	00052783          	lw	a5,0(a0)
4002a9bc:	02078263          	beqz	a5,4002a9e0 <z_abort_timeout+0x38>
			remove_timeout(to);
4002a9c0:	d4dff0ef          	jal	ra,4002a70c <remove_timeout>
			ret = 0;
4002a9c4:	00000513          	li	a0,0
	__asm__ volatile ("csrs mstatus, %0"
4002a9c8:	00847413          	andi	s0,s0,8
4002a9cc:	30042073          	csrs	mstatus,s0
}
4002a9d0:	00c12083          	lw	ra,12(sp)
4002a9d4:	00812403          	lw	s0,8(sp)
4002a9d8:	01010113          	addi	sp,sp,16
4002a9dc:	00008067          	ret
	int ret = -EINVAL;
4002a9e0:	fea00513          	li	a0,-22
4002a9e4:	fe5ff06f          	j	4002a9c8 <z_abort_timeout+0x20>

4002a9e8 <z_timeout_remaining>:

k_ticks_t z_timeout_remaining(const struct _timeout *timeout)
{
4002a9e8:	ff010113          	addi	sp,sp,-16
4002a9ec:	00112623          	sw	ra,12(sp)
4002a9f0:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002a9f4:	30047473          	csrrci	s0,mstatus,8
	k_ticks_t ticks = 0;

	LOCKED(&timeout_lock) {
		ticks = timeout_rem(timeout);
4002a9f8:	d71ff0ef          	jal	ra,4002a768 <timeout_rem>
	__asm__ volatile ("csrs mstatus, %0"
4002a9fc:	00847793          	andi	a5,s0,8
4002aa00:	3007a073          	csrs	mstatus,a5
	}

	return ticks;
}
4002aa04:	00c12083          	lw	ra,12(sp)
4002aa08:	00812403          	lw	s0,8(sp)
4002aa0c:	01010113          	addi	sp,sp,16
4002aa10:	00008067          	ret

4002aa14 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
4002aa14:	fd010113          	addi	sp,sp,-48
4002aa18:	02112623          	sw	ra,44(sp)
4002aa1c:	02812423          	sw	s0,40(sp)
4002aa20:	02912223          	sw	s1,36(sp)
4002aa24:	03212023          	sw	s2,32(sp)
4002aa28:	01312e23          	sw	s3,28(sp)
4002aa2c:	01412c23          	sw	s4,24(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002aa30:	300474f3          	csrrci	s1,mstatus,8
	return list->head == list;
4002aa34:	4003d9b7          	lui	s3,0x4003d
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
4002aa38:	40031a37          	lui	s4,0x40031
4002aa3c:	aeaa2e23          	sw	a0,-1284(s4) # 40030afc <announce_remaining>
4002aa40:	a189a503          	lw	a0,-1512(s3) # 4003ca18 <timeout_list>
4002aa44:	a1898993          	addi	s3,s3,-1512
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002aa48:	01351463          	bne	a0,s3,4002aa50 <sys_clock_announce+0x3c>
4002aa4c:	00000513          	li	a0,0
	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
4002aa50:	40031937          	lui	s2,0x40031
4002aa54:	9e092703          	lw	a4,-1568(s2) # 400309e0 <curr_tick>
4002aa58:	9e492583          	lw	a1,-1564(s2)
	     (t != NULL) && (t->dticks <= announce_remaining);
4002aa5c:	afca2783          	lw	a5,-1284(s4)
			  : "r" (key & MSTATUS_IEN)
4002aa60:	0084f493          	andi	s1,s1,8
4002aa64:	0a050263          	beqz	a0,4002ab08 <sys_clock_announce+0xf4>
4002aa68:	01452683          	lw	a3,20(a0)
4002aa6c:	41f7d613          	srai	a2,a5,0x1f
4002aa70:	01052403          	lw	s0,16(a0)
4002aa74:	00d64663          	blt	a2,a3,4002aa80 <sys_clock_announce+0x6c>
4002aa78:	02c69263          	bne	a3,a2,4002aa9c <sys_clock_announce+0x88>
4002aa7c:	0287f063          	bgeu	a5,s0,4002aa9c <sys_clock_announce+0x88>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
4002aa80:	40f40833          	sub	a6,s0,a5
4002aa84:	01043433          	sltu	s0,s0,a6
4002aa88:	40c686b3          	sub	a3,a3,a2
4002aa8c:	408686b3          	sub	a3,a3,s0
4002aa90:	01052823          	sw	a6,16(a0)
4002aa94:	00d52a23          	sw	a3,20(a0)
4002aa98:	0700006f          	j	4002ab08 <sys_clock_announce+0xf4>
		curr_tick += dt;
4002aa9c:	00e40733          	add	a4,s0,a4
4002aaa0:	41f45693          	srai	a3,s0,0x1f
4002aaa4:	008737b3          	sltu	a5,a4,s0
4002aaa8:	00b686b3          	add	a3,a3,a1
4002aaac:	00d787b3          	add	a5,a5,a3
4002aab0:	9ef92223          	sw	a5,-1564(s2)
		t->dticks = 0;
4002aab4:	00000813          	li	a6,0
4002aab8:	00000793          	li	a5,0
4002aabc:	00f52823          	sw	a5,16(a0)
4002aac0:	01052a23          	sw	a6,20(a0)
		curr_tick += dt;
4002aac4:	9ee92023          	sw	a4,-1568(s2)
		remove_timeout(t);
4002aac8:	00a12623          	sw	a0,12(sp)
4002aacc:	c41ff0ef          	jal	ra,4002a70c <remove_timeout>
	__asm__ volatile ("csrs mstatus, %0"
4002aad0:	3004a073          	csrs	mstatus,s1
		t->fn(t);
4002aad4:	00c12503          	lw	a0,12(sp)
4002aad8:	00852783          	lw	a5,8(a0)
4002aadc:	000780e7          	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002aae0:	300476f3          	csrrci	a3,mstatus,8
		announce_remaining -= dt;
4002aae4:	afca2783          	lw	a5,-1284(s4)
	return list->head == list;
4002aae8:	0009a503          	lw	a0,0(s3)
	k.key = arch_irq_lock();
4002aaec:	00068493          	mv	s1,a3
4002aaf0:	408787b3          	sub	a5,a5,s0
4002aaf4:	aefa2e23          	sw	a5,-1284(s4)
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002aaf8:	f5351ee3          	bne	a0,s3,4002aa54 <sys_clock_announce+0x40>
		curr_tick += dt;
4002aafc:	9e092703          	lw	a4,-1568(s2)
4002ab00:	9e492583          	lw	a1,-1564(s2)
4002ab04:	0086f493          	andi	s1,a3,8
	}

	curr_tick += announce_remaining;
4002ab08:	00e78733          	add	a4,a5,a4
4002ab0c:	41f7d693          	srai	a3,a5,0x1f
4002ab10:	00b686b3          	add	a3,a3,a1
4002ab14:	00f737b3          	sltu	a5,a4,a5
4002ab18:	00d787b3          	add	a5,a5,a3
4002ab1c:	9ee92023          	sw	a4,-1568(s2)
4002ab20:	9ef92223          	sw	a5,-1564(s2)
	announce_remaining = 0;
4002ab24:	ae0a2e23          	sw	zero,-1284(s4)

	sys_clock_set_timeout(next_timeout(), false);
4002ab28:	b71ff0ef          	jal	ra,4002a698 <next_timeout>
4002ab2c:	00000593          	li	a1,0
4002ab30:	971fb0ef          	jal	ra,400264a0 <sys_clock_set_timeout>
	__asm__ volatile ("csrs mstatus, %0"
4002ab34:	3004a073          	csrs	mstatus,s1
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
4002ab38:	02812403          	lw	s0,40(sp)
4002ab3c:	02c12083          	lw	ra,44(sp)
4002ab40:	02412483          	lw	s1,36(sp)
4002ab44:	02012903          	lw	s2,32(sp)
4002ab48:	01c12983          	lw	s3,28(sp)
4002ab4c:	01812a03          	lw	s4,24(sp)
4002ab50:	03010113          	addi	sp,sp,48
	z_time_slice();
4002ab54:	97cff06f          	j	40029cd0 <z_time_slice>

4002ab58 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
4002ab58:	ff010113          	addi	sp,sp,-16
4002ab5c:	00112623          	sw	ra,12(sp)
4002ab60:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002ab64:	30047473          	csrrci	s0,mstatus,8
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
4002ab68:	b19ff0ef          	jal	ra,4002a680 <elapsed>
4002ab6c:	40031737          	lui	a4,0x40031
4002ab70:	00050593          	mv	a1,a0
4002ab74:	41f55793          	srai	a5,a0,0x1f
4002ab78:	9e072503          	lw	a0,-1568(a4) # 400309e0 <curr_tick>
4002ab7c:	9e472703          	lw	a4,-1564(a4)
	__asm__ volatile ("csrs mstatus, %0"
4002ab80:	00847413          	andi	s0,s0,8
4002ab84:	00a58533          	add	a0,a1,a0
4002ab88:	00b535b3          	sltu	a1,a0,a1
4002ab8c:	00e787b3          	add	a5,a5,a4
4002ab90:	00f585b3          	add	a1,a1,a5
4002ab94:	30042073          	csrs	mstatus,s0
	}
	return t;
}
4002ab98:	00c12083          	lw	ra,12(sp)
4002ab9c:	00812403          	lw	s0,8(sp)
4002aba0:	01010113          	addi	sp,sp,16
4002aba4:	00008067          	ret

4002aba8 <sys_clock_tick_get_32>:
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
#else
	return (uint32_t)curr_tick;
#endif
}
4002aba8:	400317b7          	lui	a5,0x40031
4002abac:	9e07a503          	lw	a0,-1568(a5) # 400309e0 <curr_tick>
4002abb0:	00008067          	ret

4002abb4 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
4002abb4:	fa5ff06f          	j	4002ab58 <sys_clock_tick_get>

4002abb8 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
4002abb8:	06050263          	beqz	a0,4002ac1c <z_impl_k_busy_wait+0x64>
{
4002abbc:	ff010113          	addi	sp,sp,-16
4002abc0:	00112623          	sw	ra,12(sp)
4002abc4:	00812423          	sw	s0,8(sp)
4002abc8:	00912223          	sw	s1,4(sp)
4002abcc:	00050413          	mv	s0,a0
	return sys_clock_cycle_get_32();
4002abd0:	961fb0ef          	jal	ra,40026530 <sys_clock_cycle_get_32>
#if !defined(CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT)
	uint32_t start_cycles = k_cycle_get_32();

	/* use 64-bit math to prevent overflow when multiplying */
	uint32_t cycles_to_wait = (uint32_t)(
		(uint64_t)usec_to_wait *
4002abd4:	05f5e7b7          	lui	a5,0x5f5e
4002abd8:	10078793          	addi	a5,a5,256 # 5f5e100 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC>
4002abdc:	02f435b3          	mulhu	a1,s0,a5
4002abe0:	00050493          	mv	s1,a0
		(uint64_t)sys_clock_hw_cycles_per_sec() /
4002abe4:	000f4637          	lui	a2,0xf4
4002abe8:	24060613          	addi	a2,a2,576 # f4240 <__rom_region_size+0xc3864>
4002abec:	00000693          	li	a3,0
4002abf0:	02f40533          	mul	a0,s0,a5
4002abf4:	ec4d50ef          	jal	ra,400002b8 <__udivdi3>
4002abf8:	00050413          	mv	s0,a0
4002abfc:	935fb0ef          	jal	ra,40026530 <sys_clock_cycle_get_32>

	for (;;) {
		uint32_t current_cycles = k_cycle_get_32();

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
4002ac00:	409507b3          	sub	a5,a0,s1
4002ac04:	fe87ece3          	bltu	a5,s0,4002abfc <z_impl_k_busy_wait+0x44>
	}
#else
	arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
4002ac08:	00c12083          	lw	ra,12(sp)
4002ac0c:	00812403          	lw	s0,8(sp)
4002ac10:	00412483          	lw	s1,4(sp)
4002ac14:	01010113          	addi	sp,sp,16
4002ac18:	00008067          	ret
4002ac1c:	00008067          	ret

4002ac20 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
4002ac20:	ff010113          	addi	sp,sp,-16
4002ac24:	00812423          	sw	s0,8(sp)
4002ac28:	00912223          	sw	s1,4(sp)
4002ac2c:	00112623          	sw	ra,12(sp)
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
4002ac30:	fff00693          	li	a3,-1
{
4002ac34:	00050493          	mv	s1,a0
4002ac38:	00058413          	mv	s0,a1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
4002ac3c:	00d51463          	bne	a0,a3,4002ac44 <sys_clock_timeout_end_calc+0x24>
4002ac40:	06a58263          	beq	a1,a0,4002aca4 <sys_clock_timeout_end_calc+0x84>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
4002ac44:	009467b3          	or	a5,s0,s1
4002ac48:	00079c63          	bnez	a5,4002ac60 <sys_clock_timeout_end_calc+0x40>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
4002ac4c:	00812403          	lw	s0,8(sp)
4002ac50:	00c12083          	lw	ra,12(sp)
4002ac54:	00412483          	lw	s1,4(sp)
4002ac58:	01010113          	addi	sp,sp,16
		return sys_clock_tick_get();
4002ac5c:	efdff06f          	j	4002ab58 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
4002ac60:	ffe00793          	li	a5,-2
4002ac64:	40978533          	sub	a0,a5,s1
4002ac68:	00a7b7b3          	sltu	a5,a5,a0
4002ac6c:	fff44593          	not	a1,s0
4002ac70:	40f585b3          	sub	a1,a1,a5
4002ac74:	0005de63          	bgez	a1,4002ac90 <sys_clock_timeout_end_calc+0x70>
		return sys_clock_tick_get() + MAX(1, dt);
4002ac78:	ee1ff0ef          	jal	ra,4002ab58 <sys_clock_tick_get>
4002ac7c:	00050793          	mv	a5,a0
4002ac80:	00950533          	add	a0,a0,s1
4002ac84:	00f537b3          	sltu	a5,a0,a5
4002ac88:	008585b3          	add	a1,a1,s0
4002ac8c:	00b785b3          	add	a1,a5,a1
}
4002ac90:	00c12083          	lw	ra,12(sp)
4002ac94:	00812403          	lw	s0,8(sp)
4002ac98:	00412483          	lw	s1,4(sp)
4002ac9c:	01010113          	addi	sp,sp,16
4002aca0:	00008067          	ret
		return UINT64_MAX;
4002aca4:	fff00513          	li	a0,-1
4002aca8:	fff00593          	li	a1,-1
4002acac:	fe5ff06f          	j	4002ac90 <sys_clock_timeout_end_calc+0x70>

4002acb0 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
4002acb0:	fd010113          	addi	sp,sp,-48
4002acb4:	02112623          	sw	ra,44(sp)
4002acb8:	02812423          	sw	s0,40(sp)
4002acbc:	02912223          	sw	s1,36(sp)
4002acc0:	03212023          	sw	s2,32(sp)
4002acc4:	01312e23          	sw	s3,28(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002acc8:	300474f3          	csrrci	s1,mstatus,8
	 * interrupt. Then, the timeout structure for this timer will turn out
	 * to be linked to the timeout list. And in such case, since the timer
	 * was restarted, its expiration handler should not be executed then,
	 * so the function exits immediately.
	 */
	if (sys_dnode_is_linked(&t->node)) {
4002accc:	00052783          	lw	a5,0(a0)
4002acd0:	02078463          	beqz	a5,4002acf8 <z_timer_expiration_handler+0x48>
	__asm__ volatile ("csrs mstatus, %0"
4002acd4:	0084f493          	andi	s1,s1,8
4002acd8:	3004a073          	csrs	mstatus,s1
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
4002acdc:	02c12083          	lw	ra,44(sp)
4002ace0:	02812403          	lw	s0,40(sp)
4002ace4:	02412483          	lw	s1,36(sp)
4002ace8:	02012903          	lw	s2,32(sp)
4002acec:	01c12983          	lw	s3,28(sp)
4002acf0:	03010113          	addi	sp,sp,48
4002acf4:	00008067          	ret
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
4002acf8:	02852783          	lw	a5,40(a0)
4002acfc:	02c52983          	lw	s3,44(a0)
4002ad00:	00050413          	mv	s0,a0
4002ad04:	00178693          	addi	a3,a5,1
4002ad08:	00f6b733          	sltu	a4,a3,a5
4002ad0c:	01370733          	add	a4,a4,s3
4002ad10:	00100613          	li	a2,1
4002ad14:	00071463          	bnez	a4,4002ad1c <z_timer_expiration_handler+0x6c>
4002ad18:	08d67a63          	bgeu	a2,a3,4002adac <z_timer_expiration_handler+0xfc>
		next.ticks = MAX(next.ticks - 1, 0);
4002ad1c:	01304a63          	bgtz	s3,4002ad30 <z_timer_expiration_handler+0x80>
4002ad20:	00099463          	bnez	s3,4002ad28 <z_timer_expiration_handler+0x78>
4002ad24:	00079663          	bnez	a5,4002ad30 <z_timer_expiration_handler+0x80>
4002ad28:	00100793          	li	a5,1
4002ad2c:	00000993          	li	s3,0
4002ad30:	fff78913          	addi	s2,a5,-1
4002ad34:	0017b793          	seqz	a5,a5
4002ad38:	40f989b3          	sub	s3,s3,a5
	return z_impl_k_uptime_ticks();
4002ad3c:	e79ff0ef          	jal	ra,4002abb4 <z_impl_k_uptime_ticks>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
4002ad40:	00150793          	addi	a5,a0,1
4002ad44:	00a7b533          	sltu	a0,a5,a0
4002ad48:	00b50533          	add	a0,a0,a1
4002ad4c:	01278733          	add	a4,a5,s2
4002ad50:	00f737b3          	sltu	a5,a4,a5
4002ad54:	01350533          	add	a0,a0,s3
4002ad58:	00a787b3          	add	a5,a5,a0
4002ad5c:	00f04663          	bgtz	a5,4002ad68 <z_timer_expiration_handler+0xb8>
4002ad60:	0a079e63          	bnez	a5,4002ae1c <z_timer_expiration_handler+0x16c>
4002ad64:	0a070c63          	beqz	a4,4002ae1c <z_timer_expiration_handler+0x16c>
4002ad68:	e4dff0ef          	jal	ra,4002abb4 <z_impl_k_uptime_ticks>
4002ad6c:	00150793          	addi	a5,a0,1
4002ad70:	00a7b533          	sltu	a0,a5,a0
4002ad74:	01278633          	add	a2,a5,s2
4002ad78:	00b50533          	add	a0,a0,a1
4002ad7c:	00f636b3          	sltu	a3,a2,a5
4002ad80:	01350533          	add	a0,a0,s3
4002ad84:	ffe00793          	li	a5,-2
4002ad88:	00a686b3          	add	a3,a3,a0
4002ad8c:	40c78633          	sub	a2,a5,a2
4002ad90:	00c7b7b3          	sltu	a5,a5,a2
4002ad94:	fff6c693          	not	a3,a3
4002ad98:	40f686b3          	sub	a3,a3,a5
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
4002ad9c:	4002b5b7          	lui	a1,0x4002b
4002ada0:	cb058593          	addi	a1,a1,-848 # 4002acb0 <z_timer_expiration_handler>
4002ada4:	00040513          	mv	a0,s0
4002ada8:	a61ff0ef          	jal	ra,4002a808 <z_add_timeout>
	timer->status += 1U;
4002adac:	03042783          	lw	a5,48(s0)
4002adb0:	00178793          	addi	a5,a5,1
4002adb4:	02f42823          	sw	a5,48(s0)
	if (timer->expiry_fn != NULL) {
4002adb8:	02042783          	lw	a5,32(s0)
4002adbc:	00078e63          	beqz	a5,4002add8 <z_timer_expiration_handler+0x128>
4002adc0:	0084f493          	andi	s1,s1,8
4002adc4:	3004a073          	csrs	mstatus,s1
		timer->expiry_fn(timer);
4002adc8:	02042783          	lw	a5,32(s0)
4002adcc:	00040513          	mv	a0,s0
4002add0:	000780e7          	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002add4:	300474f3          	csrrci	s1,mstatus,8
	return list->head == list;
4002add8:	01842503          	lw	a0,24(s0)
4002addc:	01840413          	addi	s0,s0,24
			  : "r" (key & MSTATUS_IEN)
4002ade0:	0084f493          	andi	s1,s1,8
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002ade4:	ee850ae3          	beq	a0,s0,4002acd8 <z_timer_expiration_handler+0x28>
	if (thread == NULL) {
4002ade8:	ee0508e3          	beqz	a0,4002acd8 <z_timer_expiration_handler+0x28>
	z_unpend_thread_no_timeout(thread);
4002adec:	00a12623          	sw	a0,12(sp)
4002adf0:	f89fe0ef          	jal	ra,40029d78 <z_unpend_thread_no_timeout>
	thread->swap_retval = value;
4002adf4:	00c12503          	lw	a0,12(sp)
4002adf8:	0a052e23          	sw	zero,188(a0)
	__asm__ volatile ("csrs mstatus, %0"
4002adfc:	3004a073          	csrs	mstatus,s1
}
4002ae00:	02812403          	lw	s0,40(sp)
4002ae04:	02c12083          	lw	ra,44(sp)
4002ae08:	02412483          	lw	s1,36(sp)
4002ae0c:	02012903          	lw	s2,32(sp)
4002ae10:	01c12983          	lw	s3,28(sp)
4002ae14:	03010113          	addi	sp,sp,48
	z_ready_thread(thread);
4002ae18:	f35fe06f          	j	40029d4c <z_ready_thread>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
4002ae1c:	ffe00613          	li	a2,-2
4002ae20:	fff00693          	li	a3,-1
4002ae24:	f79ff06f          	j	4002ad9c <z_timer_expiration_handler+0xec>

4002ae28 <k_timer_init>:
	sys_dlist_init(&w->waitq);
4002ae28:	01850793          	addi	a5,a0,24

void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
	timer->expiry_fn = expiry_fn;
4002ae2c:	02b52023          	sw	a1,32(a0)
	timer->stop_fn = stop_fn;
4002ae30:	02c52223          	sw	a2,36(a0)
	timer->status = 0U;
4002ae34:	02052823          	sw	zero,48(a0)
	list->head = (sys_dnode_t *)list;
4002ae38:	00f52c23          	sw	a5,24(a0)
	list->tail = (sys_dnode_t *)list;
4002ae3c:	00f52e23          	sw	a5,28(a0)
	node->next = NULL;
4002ae40:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
4002ae44:	00052223          	sw	zero,4(a0)

	z_init_timeout(&timer->timeout);

	SYS_PORT_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
4002ae48:	02052a23          	sw	zero,52(a0)

	z_object_init(timer);
}
4002ae4c:	00008067          	ret

4002ae50 <z_impl_k_timer_start>:


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
4002ae50:	fd010113          	addi	sp,sp,-48
4002ae54:	00060793          	mv	a5,a2
4002ae58:	02812423          	sw	s0,40(sp)
4002ae5c:	02912223          	sw	s1,36(sp)
4002ae60:	03212023          	sw	s2,32(sp)
4002ae64:	01312e23          	sw	s3,28(sp)
4002ae68:	00070913          	mv	s2,a4
4002ae6c:	02112623          	sw	ra,44(sp)
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer, duration, period);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
4002ae70:	fff00713          	li	a4,-1
{
4002ae74:	00050413          	mv	s0,a0
4002ae78:	00068993          	mv	s3,a3
4002ae7c:	00058613          	mv	a2,a1
4002ae80:	00078493          	mv	s1,a5
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
4002ae84:	00e59463          	bne	a1,a4,4002ae8c <z_impl_k_timer_start+0x3c>
4002ae88:	08b78063          	beq	a5,a1,4002af08 <z_impl_k_timer_start+0xb8>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (Z_TICK_ABS(duration.ticks) < 0) {
4002ae8c:	0007da63          	bgez	a5,4002aea0 <z_impl_k_timer_start+0x50>
4002ae90:	fff00713          	li	a4,-1
4002ae94:	02e79663          	bne	a5,a4,4002aec0 <z_impl_k_timer_start+0x70>
4002ae98:	ffe00713          	li	a4,-2
4002ae9c:	02b77263          	bgeu	a4,a1,4002aec0 <z_impl_k_timer_start+0x70>
		duration.ticks = MAX(duration.ticks - 1, 0);
4002aea0:	00f04a63          	bgtz	a5,4002aeb4 <z_impl_k_timer_start+0x64>
4002aea4:	00079463          	bnez	a5,4002aeac <z_impl_k_timer_start+0x5c>
4002aea8:	00059663          	bnez	a1,4002aeb4 <z_impl_k_timer_start+0x64>
4002aeac:	00100593          	li	a1,1
4002aeb0:	00000793          	li	a5,0
4002aeb4:	0015b493          	seqz	s1,a1
4002aeb8:	fff58613          	addi	a2,a1,-1
4002aebc:	409784b3          	sub	s1,a5,s1
	}

	(void)z_abort_timeout(&timer->timeout);
4002aec0:	00040513          	mv	a0,s0
4002aec4:	00c12623          	sw	a2,12(sp)
4002aec8:	ae1ff0ef          	jal	ra,4002a9a8 <z_abort_timeout>
	timer->period = period;
4002aecc:	03342423          	sw	s3,40(s0)
4002aed0:	03242623          	sw	s2,44(s0)
	timer->status = 0U;
4002aed4:	02042823          	sw	zero,48(s0)

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
4002aed8:	00040513          	mv	a0,s0
		     duration);
}
4002aedc:	02812403          	lw	s0,40(sp)
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
4002aee0:	00c12603          	lw	a2,12(sp)
}
4002aee4:	02c12083          	lw	ra,44(sp)
4002aee8:	02012903          	lw	s2,32(sp)
4002aeec:	01c12983          	lw	s3,28(sp)
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
4002aef0:	00048693          	mv	a3,s1
}
4002aef4:	02412483          	lw	s1,36(sp)
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
4002aef8:	4002b5b7          	lui	a1,0x4002b
4002aefc:	cb058593          	addi	a1,a1,-848 # 4002acb0 <z_timer_expiration_handler>
}
4002af00:	03010113          	addi	sp,sp,48
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
4002af04:	905ff06f          	j	4002a808 <z_add_timeout>
}
4002af08:	02c12083          	lw	ra,44(sp)
4002af0c:	02812403          	lw	s0,40(sp)
4002af10:	02412483          	lw	s1,36(sp)
4002af14:	02012903          	lw	s2,32(sp)
4002af18:	01c12983          	lw	s3,28(sp)
4002af1c:	03010113          	addi	sp,sp,48
4002af20:	00008067          	ret

4002af24 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
4002af24:	ff010113          	addi	sp,sp,-16
4002af28:	00812423          	sw	s0,8(sp)
4002af2c:	00112623          	sw	ra,12(sp)
4002af30:	00050413          	mv	s0,a0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	bool inactive = (z_abort_timeout(&timer->timeout) != 0);
4002af34:	a75ff0ef          	jal	ra,4002a9a8 <z_abort_timeout>

	if (inactive) {
4002af38:	02051c63          	bnez	a0,4002af70 <z_impl_k_timer_stop+0x4c>
		return;
	}

	if (timer->stop_fn != NULL) {
4002af3c:	02442783          	lw	a5,36(s0)
4002af40:	00078663          	beqz	a5,4002af4c <z_impl_k_timer_stop+0x28>
		timer->stop_fn(timer);
4002af44:	00040513          	mv	a0,s0
4002af48:	000780e7          	jalr	a5
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
4002af4c:	01840513          	addi	a0,s0,24
4002af50:	f25fe0ef          	jal	ra,40029e74 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
4002af54:	00050e63          	beqz	a0,4002af70 <z_impl_k_timer_stop+0x4c>
			z_ready_thread(pending_thread);
4002af58:	df5fe0ef          	jal	ra,40029d4c <z_ready_thread>
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002af5c:	30047573          	csrrci	a0,mstatus,8
			z_reschedule_unlocked();
		}
	}
}
4002af60:	00812403          	lw	s0,8(sp)
4002af64:	00c12083          	lw	ra,12(sp)
4002af68:	01010113          	addi	sp,sp,16
	(void) z_reschedule_irqlock(arch_irq_lock());
4002af6c:	968ff06f          	j	4002a0d4 <z_reschedule_irqlock>
4002af70:	00c12083          	lw	ra,12(sp)
4002af74:	00812403          	lw	s0,8(sp)
4002af78:	01010113          	addi	sp,sp,16
4002af7c:	00008067          	ret

4002af80 <z_impl_atomic_cas>:
4002af80:	300477f3          	csrrci	a5,mstatus,8
	k_spinlock_key_t key;
	int ret = false;

	key = k_spin_lock(&lock);

	if (*target == old_value) {
4002af84:	00052703          	lw	a4,0(a0)
4002af88:	00b71c63          	bne	a4,a1,4002afa0 <z_impl_atomic_cas+0x20>
		*target = new_value;
4002af8c:	00c52023          	sw	a2,0(a0)
		ret = true;
4002af90:	00100513          	li	a0,1
	__asm__ volatile ("csrs mstatus, %0"
4002af94:	0087f793          	andi	a5,a5,8
4002af98:	3007a073          	csrs	mstatus,a5
	}

	k_spin_unlock(&lock, key);

	return ret;
}
4002af9c:	00008067          	ret
	int ret = false;
4002afa0:	00000513          	li	a0,0
4002afa4:	ff1ff06f          	j	4002af94 <z_impl_atomic_cas+0x14>

4002afa8 <z_impl_atomic_add>:
 * @param value the value to add
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_add(atomic_t *target, atomic_val_t value)
{
4002afa8:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002afac:	30047773          	csrrci	a4,mstatus,8
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
4002afb0:	00052503          	lw	a0,0(a0)
	*target += value;
4002afb4:	00b505b3          	add	a1,a0,a1
4002afb8:	00b7a023          	sw	a1,0(a5)
	__asm__ volatile ("csrs mstatus, %0"
4002afbc:	00877793          	andi	a5,a4,8
4002afc0:	3007a073          	csrs	mstatus,a5

	k_spin_unlock(&lock, key);

	return ret;
}
4002afc4:	00008067          	ret

4002afc8 <z_impl_atomic_sub>:
 * @param value the value to subtract
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_sub(atomic_t *target, atomic_val_t value)
{
4002afc8:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002afcc:	30047773          	csrrci	a4,mstatus,8
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
4002afd0:	00052503          	lw	a0,0(a0)
	*target -= value;
4002afd4:	40b505b3          	sub	a1,a0,a1
4002afd8:	00b7a023          	sw	a1,0(a5)
	__asm__ volatile ("csrs mstatus, %0"
4002afdc:	00877793          	andi	a5,a4,8
4002afe0:	3007a073          	csrs	mstatus,a5

	k_spin_unlock(&lock, key);

	return ret;
}
4002afe4:	00008067          	ret

4002afe8 <atomic_get>:
 * @return The value read from <target>
 */
atomic_val_t atomic_get(const atomic_t *target)
{
	return *target;
}
4002afe8:	00052503          	lw	a0,0(a0)
4002afec:	00008067          	ret

4002aff0 <z_impl_atomic_set>:
 * @param value the value to write
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_set(atomic_t *target, atomic_val_t value)
{
4002aff0:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002aff4:	30047773          	csrrci	a4,mstatus,8
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
4002aff8:	00052503          	lw	a0,0(a0)
	*target = value;
4002affc:	00b7a023          	sw	a1,0(a5)
	__asm__ volatile ("csrs mstatus, %0"
4002b000:	00877793          	andi	a5,a4,8
4002b004:	3007a073          	csrs	mstatus,a5

	k_spin_unlock(&lock, key);

	return ret;
}
4002b008:	00008067          	ret

4002b00c <z_impl_atomic_or>:
 * @param value the value to OR
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_or(atomic_t *target, atomic_val_t value)
{
4002b00c:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002b010:	30047773          	csrrci	a4,mstatus,8
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
4002b014:	00052503          	lw	a0,0(a0)
	*target |= value;
4002b018:	00b565b3          	or	a1,a0,a1
4002b01c:	00b7a023          	sw	a1,0(a5)
	__asm__ volatile ("csrs mstatus, %0"
4002b020:	00877793          	andi	a5,a4,8
4002b024:	3007a073          	csrs	mstatus,a5

	k_spin_unlock(&lock, key);

	return ret;
}
4002b028:	00008067          	ret

4002b02c <z_impl_atomic_and>:
 * @param value the value to AND
 *
 * @return The previous value from <target>
 */
atomic_val_t z_impl_atomic_and(atomic_t *target, atomic_val_t value)
{
4002b02c:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002b030:	30047773          	csrrci	a4,mstatus,8
	k_spinlock_key_t key;
	atomic_val_t ret;

	key = k_spin_lock(&lock);

	ret = *target;
4002b034:	00052503          	lw	a0,0(a0)
	*target &= value;
4002b038:	00b575b3          	and	a1,a0,a1
4002b03c:	00b7a023          	sw	a1,0(a5)
	__asm__ volatile ("csrs mstatus, %0"
4002b040:	00877793          	andi	a5,a4,8
4002b044:	3007a073          	csrs	mstatus,a5

	k_spin_unlock(&lock, key);

	return ret;
}
4002b048:	00008067          	ret

4002b04c <add_event>:
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
}

static inline void add_event(sys_dlist_t *events, struct k_poll_event *event,
			     struct z_poller *poller)
{
4002b04c:	fe010113          	addi	sp,sp,-32
4002b050:	00812c23          	sw	s0,24(sp)
4002b054:	00912a23          	sw	s1,20(sp)
4002b058:	00112e23          	sw	ra,28(sp)
4002b05c:	01212823          	sw	s2,16(sp)
4002b060:	01312623          	sw	s3,12(sp)
	return sys_dlist_is_empty(list) ? NULL : list->tail;
4002b064:	00052703          	lw	a4,0(a0)
4002b068:	00452783          	lw	a5,4(a0)
4002b06c:	00050413          	mv	s0,a0
4002b070:	00058493          	mv	s1,a1
4002b074:	00e51e63          	bne	a0,a4,4002b090 <add_event+0x44>
	sys_dnode_t *const tail = list->tail;
4002b078:	00442783          	lw	a5,4(s0)
	node->next = list;
4002b07c:	0084a023          	sw	s0,0(s1)
	node->prev = tail;
4002b080:	00f4a223          	sw	a5,4(s1)
	tail->next = node;
4002b084:	0097a023          	sw	s1,0(a5)
	list->tail = node;
4002b088:	00942223          	sw	s1,4(s0)
4002b08c:	05c0006f          	j	4002b0e8 <add_event+0x9c>
	struct k_poll_event *pending;

	pending = (struct k_poll_event *)sys_dlist_peek_tail(events);
	if ((pending == NULL) ||
4002b090:	fe0784e3          	beqz	a5,4002b078 <add_event+0x2c>
		(z_sched_prio_cmp(poller_thread(pending->poller),
4002b094:	0087a503          	lw	a0,8(a5)
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
4002b098:	00050463          	beqz	a0,4002b0a0 <add_event+0x54>
4002b09c:	f8c50513          	addi	a0,a0,-116
4002b0a0:	f8c60993          	addi	s3,a2,-116
		(z_sched_prio_cmp(poller_thread(pending->poller),
4002b0a4:	00098593          	mv	a1,s3
4002b0a8:	f40fe0ef          	jal	ra,400297e8 <z_sched_prio_cmp>
	if ((pending == NULL) ||
4002b0ac:	fca046e3          	bgtz	a0,4002b078 <add_event+0x2c>
	return list->head == list;
4002b0b0:	00042903          	lw	s2,0(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
4002b0b4:	fd2402e3          	beq	s0,s2,4002b078 <add_event+0x2c>
							   poller_thread(poller)) > 0)) {
		sys_dlist_append(events, &event->_node);
		return;
	}

	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
4002b0b8:	fc0900e3          	beqz	s2,4002b078 <add_event+0x2c>
		if (z_sched_prio_cmp(poller_thread(poller),
4002b0bc:	00892583          	lw	a1,8(s2)
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
4002b0c0:	00058463          	beqz	a1,4002b0c8 <add_event+0x7c>
4002b0c4:	f8c58593          	addi	a1,a1,-116
		if (z_sched_prio_cmp(poller_thread(poller),
4002b0c8:	00098513          	mv	a0,s3
4002b0cc:	f1cfe0ef          	jal	ra,400297e8 <z_sched_prio_cmp>
4002b0d0:	02a05a63          	blez	a0,4002b104 <add_event+0xb8>
	sys_dnode_t *const prev = successor->prev;
4002b0d4:	00492783          	lw	a5,4(s2)
	node->next = successor;
4002b0d8:	0124a023          	sw	s2,0(s1)
	node->prev = prev;
4002b0dc:	00f4a223          	sw	a5,4(s1)
	prev->next = node;
4002b0e0:	0097a023          	sw	s1,0(a5)
	successor->prev = node;
4002b0e4:	00992223          	sw	s1,4(s2)
			return;
		}
	}

	sys_dlist_append(events, &event->_node);
}
4002b0e8:	01c12083          	lw	ra,28(sp)
4002b0ec:	01812403          	lw	s0,24(sp)
4002b0f0:	01412483          	lw	s1,20(sp)
4002b0f4:	01012903          	lw	s2,16(sp)
4002b0f8:	00c12983          	lw	s3,12(sp)
4002b0fc:	02010113          	addi	sp,sp,32
4002b100:	00008067          	ret
	return (node == list->tail) ? NULL : node->next;
4002b104:	00442783          	lw	a5,4(s0)
4002b108:	f6f908e3          	beq	s2,a5,4002b078 <add_event+0x2c>
4002b10c:	00092903          	lw	s2,0(s2)
4002b110:	fa9ff06f          	j	4002b0b8 <add_event+0x6c>

4002b114 <register_events>:

static inline int register_events(struct k_poll_event *events,
				  int num_events,
				  struct z_poller *poller,
				  bool just_check)
{
4002b114:	fc010113          	addi	sp,sp,-64
4002b118:	03612023          	sw	s6,32(sp)
	event->state |= state;
4002b11c:	ffe04b37          	lui	s6,0xffe04
{
4002b120:	02812c23          	sw	s0,56(sp)
4002b124:	02912a23          	sw	s1,52(sp)
4002b128:	03212823          	sw	s2,48(sp)
4002b12c:	03312623          	sw	s3,44(sp)
4002b130:	03412423          	sw	s4,40(sp)
4002b134:	03512223          	sw	s5,36(sp)
4002b138:	01812c23          	sw	s8,24(sp)
4002b13c:	01912a23          	sw	s9,20(sp)
4002b140:	01a12823          	sw	s10,16(sp)
4002b144:	01b12623          	sw	s11,12(sp)
4002b148:	02112e23          	sw	ra,60(sp)
4002b14c:	01712e23          	sw	s7,28(sp)
4002b150:	00058993          	mv	s3,a1
4002b154:	00060493          	mv	s1,a2
4002b158:	00068a93          	mv	s5,a3
4002b15c:	00050413          	mv	s0,a0
	int events_registered = 0;

	for (int ii = 0; ii < num_events; ii++) {
4002b160:	00000a13          	li	s4,0
	int events_registered = 0;
4002b164:	00000913          	li	s2,0
	switch (event->type) {
4002b168:	00400c13          	li	s8,4
	event->state |= state;
4002b16c:	fffb0b13          	addi	s6,s6,-1 # ffe03fff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffe04000>
	switch (event->type) {
4002b170:	00800c93          	li	s9,8
4002b174:	00100d13          	li	s10,1
4002b178:	00200d93          	li	s11,2
	for (int ii = 0; ii < num_events; ii++) {
4002b17c:	053a4263          	blt	s4,s3,4002b1c0 <register_events+0xac>
		}
		k_spin_unlock(&lock, key);
	}

	return events_registered;
}
4002b180:	03c12083          	lw	ra,60(sp)
4002b184:	03812403          	lw	s0,56(sp)
4002b188:	03412483          	lw	s1,52(sp)
4002b18c:	02c12983          	lw	s3,44(sp)
4002b190:	02812a03          	lw	s4,40(sp)
4002b194:	02412a83          	lw	s5,36(sp)
4002b198:	02012b03          	lw	s6,32(sp)
4002b19c:	01c12b83          	lw	s7,28(sp)
4002b1a0:	01812c03          	lw	s8,24(sp)
4002b1a4:	01412c83          	lw	s9,20(sp)
4002b1a8:	01012d03          	lw	s10,16(sp)
4002b1ac:	00c12d83          	lw	s11,12(sp)
4002b1b0:	00090513          	mv	a0,s2
4002b1b4:	03012903          	lw	s2,48(sp)
4002b1b8:	04010113          	addi	sp,sp,64
4002b1bc:	00008067          	ret
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002b1c0:	30047bf3          	csrrci	s7,mstatus,8
	switch (event->type) {
4002b1c4:	00c42783          	lw	a5,12(s0)
4002b1c8:	0087d793          	srli	a5,a5,0x8
4002b1cc:	03f7f793          	andi	a5,a5,63
4002b1d0:	07878e63          	beq	a5,s8,4002b24c <register_events+0x138>
4002b1d4:	04fc6663          	bltu	s8,a5,4002b220 <register_events+0x10c>
4002b1d8:	0da78063          	beq	a5,s10,4002b298 <register_events+0x184>
4002b1dc:	05b78e63          	beq	a5,s11,4002b238 <register_events+0x124>
		} else if (!just_check && poller->is_polling) {
4002b1e0:	0a0a9263          	bnez	s5,4002b284 <register_events+0x170>
4002b1e4:	0004c783          	lbu	a5,0(s1)
4002b1e8:	08078e63          	beqz	a5,4002b284 <register_events+0x170>
	switch (event->type) {
4002b1ec:	00c42783          	lw	a5,12(s0)
4002b1f0:	00400713          	li	a4,4
4002b1f4:	0087d793          	srli	a5,a5,0x8
4002b1f8:	03f7f793          	andi	a5,a5,63
4002b1fc:	0ce78663          	beq	a5,a4,4002b2c8 <register_events+0x1b4>
4002b200:	0af76663          	bltu	a4,a5,4002b2ac <register_events+0x198>
4002b204:	00100713          	li	a4,1
4002b208:	0ce78c63          	beq	a5,a4,4002b2e0 <register_events+0x1cc>
4002b20c:	00200713          	li	a4,2
4002b210:	0ae78c63          	beq	a5,a4,4002b2c8 <register_events+0x1b4>
	event->poller = poller;
4002b214:	00942423          	sw	s1,8(s0)
			events_registered += 1;
4002b218:	00190913          	addi	s2,s2,1
4002b21c:	0680006f          	j	4002b284 <register_events+0x170>
	switch (event->type) {
4002b220:	fd9790e3          	bne	a5,s9,4002b1e0 <register_events+0xcc>
		if (event->msgq->used_msgs > 0) {
4002b224:	01042783          	lw	a5,16(s0)
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
4002b228:	01000693          	li	a3,16
		if (event->msgq->used_msgs > 0) {
4002b22c:	0207a783          	lw	a5,32(a5)
4002b230:	fa0788e3          	beqz	a5,4002b1e0 <register_events+0xcc>
4002b234:	0280006f          	j	4002b25c <register_events+0x148>
		if (k_sem_count_get(event->sem) > 0U) {
4002b238:	01042783          	lw	a5,16(s0)
4002b23c:	0087a783          	lw	a5,8(a5)
4002b240:	fa0780e3          	beqz	a5,4002b1e0 <register_events+0xcc>
			*state = K_POLL_STATE_SEM_AVAILABLE;
4002b244:	00200693          	li	a3,2
4002b248:	0140006f          	j	4002b25c <register_events+0x148>
		if (!k_queue_is_empty(event->queue)) {
4002b24c:	01042783          	lw	a5,16(s0)
4002b250:	0007a783          	lw	a5,0(a5)
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
4002b254:	00400693          	li	a3,4
		if (!k_queue_is_empty(event->queue)) {
4002b258:	f80784e3          	beqz	a5,4002b1e0 <register_events+0xcc>
	event->state |= state;
4002b25c:	00c42703          	lw	a4,12(s0)
	event->poller = NULL;
4002b260:	00042423          	sw	zero,8(s0)
	event->state |= state;
4002b264:	00e75793          	srli	a5,a4,0xe
4002b268:	07f7f793          	andi	a5,a5,127
4002b26c:	00d7e7b3          	or	a5,a5,a3
4002b270:	00e79793          	slli	a5,a5,0xe
4002b274:	01677733          	and	a4,a4,s6
4002b278:	00f76733          	or	a4,a4,a5
4002b27c:	00e42623          	sw	a4,12(s0)
			poller->is_polling = false;
4002b280:	00048023          	sb	zero,0(s1)
	__asm__ volatile ("csrs mstatus, %0"
4002b284:	008bfb93          	andi	s7,s7,8
4002b288:	300ba073          	csrs	mstatus,s7
	for (int ii = 0; ii < num_events; ii++) {
4002b28c:	001a0a13          	addi	s4,s4,1
4002b290:	01440413          	addi	s0,s0,20
4002b294:	ee9ff06f          	j	4002b17c <register_events+0x68>
		if (event->signal->signaled != 0U) {
4002b298:	01042783          	lw	a5,16(s0)
4002b29c:	0087a783          	lw	a5,8(a5)
4002b2a0:	f40780e3          	beqz	a5,4002b1e0 <register_events+0xcc>
			*state = K_POLL_STATE_SIGNALED;
4002b2a4:	00100693          	li	a3,1
4002b2a8:	fb5ff06f          	j	4002b25c <register_events+0x148>
	switch (event->type) {
4002b2ac:	00800713          	li	a4,8
4002b2b0:	f6e792e3          	bne	a5,a4,4002b214 <register_events+0x100>
		add_event(&event->msgq->poll_events, event, poller);
4002b2b4:	01042503          	lw	a0,16(s0)
4002b2b8:	00048613          	mv	a2,s1
4002b2bc:	00040593          	mv	a1,s0
4002b2c0:	02450513          	addi	a0,a0,36
4002b2c4:	0140006f          	j	4002b2d8 <register_events+0x1c4>
		add_event(&event->queue->poll_events, event, poller);
4002b2c8:	01042503          	lw	a0,16(s0)
4002b2cc:	00048613          	mv	a2,s1
4002b2d0:	00040593          	mv	a1,s0
4002b2d4:	01050513          	addi	a0,a0,16
		add_event(&event->msgq->poll_events, event, poller);
4002b2d8:	d75ff0ef          	jal	ra,4002b04c <add_event>
		break;
4002b2dc:	f39ff06f          	j	4002b214 <register_events+0x100>
		add_event(&event->signal->poll_events, event, poller);
4002b2e0:	01042503          	lw	a0,16(s0)
4002b2e4:	00048613          	mv	a2,s1
4002b2e8:	00040593          	mv	a1,s0
4002b2ec:	fedff06f          	j	4002b2d8 <register_events+0x1c4>

4002b2f0 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
4002b2f0:	fd010113          	addi	sp,sp,-48
4002b2f4:	02912223          	sw	s1,36(sp)
4002b2f8:	03212023          	sw	s2,32(sp)
4002b2fc:	02112623          	sw	ra,44(sp)
4002b300:	02812423          	sw	s0,40(sp)
4002b304:	01312e23          	sw	s3,28(sp)
	struct z_poller *poller = event->poller;
4002b308:	00852403          	lw	s0,8(a0)
{
4002b30c:	00050913          	mv	s2,a0
4002b310:	00058493          	mv	s1,a1
	int retcode = 0;

	if (poller != NULL) {
4002b314:	02040063          	beqz	s0,4002b334 <signal_poll_event+0x44>
		if (poller->mode == MODE_POLL) {
4002b318:	00144783          	lbu	a5,1(s0)
4002b31c:	00100713          	li	a4,1
4002b320:	0ae79063          	bne	a5,a4,4002b3c0 <signal_poll_event+0xd0>
	if (!z_is_thread_pending(thread)) {
4002b324:	f9944783          	lbu	a5,-103(s0)
4002b328:	0027f793          	andi	a5,a5,2
4002b32c:	02079e63          	bnez	a5,4002b368 <signal_poll_event+0x78>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
4002b330:	00040023          	sb	zero,0(s0)
	event->state |= state;
4002b334:	00c92783          	lw	a5,12(s2)
	event->poller = NULL;
4002b338:	00092423          	sw	zero,8(s2)
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
4002b33c:	00000513          	li	a0,0
	event->state |= state;
4002b340:	00e7d713          	srli	a4,a5,0xe
4002b344:	00e4e4b3          	or	s1,s1,a4
4002b348:	ffe04737          	lui	a4,0xffe04
4002b34c:	07f4f493          	andi	s1,s1,127
4002b350:	fff70713          	addi	a4,a4,-1 # ffe03fff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffe04000>
4002b354:	00e49493          	slli	s1,s1,0xe
4002b358:	00e7f7b3          	and	a5,a5,a4
4002b35c:	0097e7b3          	or	a5,a5,s1
4002b360:	00f92623          	sw	a5,12(s2)
	return retcode;
4002b364:	0a00006f          	j	4002b404 <signal_poll_event+0x114>
	if (z_is_thread_timeout_expired(thread)) {
4002b368:	fb442703          	lw	a4,-76(s0)
4002b36c:	ffe00793          	li	a5,-2
4002b370:	00f71863          	bne	a4,a5,4002b380 <signal_poll_event+0x90>
4002b374:	fb842703          	lw	a4,-72(s0)
4002b378:	fff00793          	li	a5,-1
4002b37c:	08f70063          	beq	a4,a5,4002b3fc <signal_poll_event+0x10c>
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
4002b380:	f8c40513          	addi	a0,s0,-116
	z_unpend_thread(thread);
4002b384:	00a12623          	sw	a0,12(sp)
4002b388:	b91fe0ef          	jal	ra,40029f18 <z_unpend_thread>
	arch_thread_return_value_set(thread,
4002b38c:	00800713          	li	a4,8
4002b390:	00c12503          	lw	a0,12(sp)
4002b394:	ffc00793          	li	a5,-4
4002b398:	00e48463          	beq	s1,a4,4002b3a0 <signal_poll_event+0xb0>
4002b39c:	00000793          	li	a5,0
4002b3a0:	04f42423          	sw	a5,72(s0)
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
4002b3a4:	f9944783          	lbu	a5,-103(s0)
4002b3a8:	01f7f793          	andi	a5,a5,31
4002b3ac:	f80792e3          	bnez	a5,4002b330 <signal_poll_event+0x40>
4002b3b0:	fa442783          	lw	a5,-92(s0)
4002b3b4:	f6079ee3          	bnez	a5,4002b330 <signal_poll_event+0x40>
	z_ready_thread(thread);
4002b3b8:	995fe0ef          	jal	ra,40029d4c <z_ready_thread>
		poller->is_polling = false;
4002b3bc:	f75ff06f          	j	4002b330 <signal_poll_event+0x40>
		} else if (poller->mode == MODE_TRIGGERED) {
4002b3c0:	00200713          	li	a4,2
4002b3c4:	f6e796e3          	bne	a5,a4,4002b330 <signal_poll_event+0x40>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
4002b3c8:	00044783          	lbu	a5,0(s0)
4002b3cc:	f60784e3          	beqz	a5,4002b334 <signal_poll_event+0x44>
4002b3d0:	ffc42983          	lw	s3,-4(s0)
4002b3d4:	f4098ee3          	beqz	s3,4002b330 <signal_poll_event+0x40>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
4002b3d8:	fec40593          	addi	a1,s0,-20
4002b3dc:	01440513          	addi	a0,s0,20
4002b3e0:	00b12623          	sw	a1,12(sp)
4002b3e4:	dc4ff0ef          	jal	ra,4002a9a8 <z_abort_timeout>
		twork->poll_result = 0;
		z_work_submit_to_queue(work_q, &twork->work);
4002b3e8:	00c12583          	lw	a1,12(sp)
		twork->poll_result = 0;
4002b3ec:	02042623          	sw	zero,44(s0)
		z_work_submit_to_queue(work_q, &twork->work);
4002b3f0:	00098513          	mv	a0,s3
4002b3f4:	ff9fd0ef          	jal	ra,400293ec <z_work_submit_to_queue>
4002b3f8:	f39ff06f          	j	4002b330 <signal_poll_event+0x40>
		poller->is_polling = false;
4002b3fc:	00040023          	sb	zero,0(s0)
		return -EAGAIN;
4002b400:	ff500513          	li	a0,-11
}
4002b404:	02c12083          	lw	ra,44(sp)
4002b408:	02812403          	lw	s0,40(sp)
4002b40c:	02412483          	lw	s1,36(sp)
4002b410:	02012903          	lw	s2,32(sp)
4002b414:	01c12983          	lw	s3,28(sp)
4002b418:	03010113          	addi	sp,sp,48
4002b41c:	00008067          	ret

4002b420 <clear_event_registrations>:
	while (num_events--) {
4002b420:	01400793          	li	a5,20
4002b424:	02f587b3          	mul	a5,a1,a5
	switch (event->type) {
4002b428:	00800693          	li	a3,8
4002b42c:	11600813          	li	a6,278
4002b430:	fec78793          	addi	a5,a5,-20
4002b434:	00f50533          	add	a0,a0,a5
	while (num_events--) {
4002b438:	00059463          	bnez	a1,4002b440 <clear_event_registrations+0x20>
}
4002b43c:	00008067          	ret
	switch (event->type) {
4002b440:	00c52783          	lw	a5,12(a0)
	event->poller = NULL;
4002b444:	00052423          	sw	zero,8(a0)
	switch (event->type) {
4002b448:	0087d793          	srli	a5,a5,0x8
4002b44c:	03f7f793          	andi	a5,a5,63
4002b450:	02f6e663          	bltu	a3,a5,4002b47c <clear_event_registrations+0x5c>
4002b454:	00f857b3          	srl	a5,a6,a5
4002b458:	0017f793          	andi	a5,a5,1
4002b45c:	02078063          	beqz	a5,4002b47c <clear_event_registrations+0x5c>
	return node->next != NULL;
4002b460:	00052783          	lw	a5,0(a0)
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
4002b464:	00078c63          	beqz	a5,4002b47c <clear_event_registrations+0x5c>
	sys_dnode_t *const prev = node->prev;
4002b468:	00452703          	lw	a4,4(a0)
	prev->next = next;
4002b46c:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
4002b470:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
4002b474:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
4002b478:	00052223          	sw	zero,4(a0)
			  : "r" (key & MSTATUS_IEN)
4002b47c:	00867613          	andi	a2,a2,8
	__asm__ volatile ("csrs mstatus, %0"
4002b480:	30062073          	csrs	mstatus,a2
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002b484:	30047673          	csrrci	a2,mstatus,8
	return k;
4002b488:	fff58593          	addi	a1,a1,-1
4002b48c:	fec50513          	addi	a0,a0,-20
4002b490:	fa9ff06f          	j	4002b438 <clear_event_registrations+0x18>

4002b494 <k_poll_event_init>:
	event->type = type;
4002b494:	002007b7          	lui	a5,0x200
4002b498:	01561613          	slli	a2,a2,0x15
4002b49c:	00f67633          	and	a2,a2,a5
4002b4a0:	000047b7          	lui	a5,0x4
4002b4a4:	f0078793          	addi	a5,a5,-256 # 3f00 <CONFIG_SRAM_SIZE+0x1f00>
4002b4a8:	00859593          	slli	a1,a1,0x8
4002b4ac:	00f5f5b3          	and	a1,a1,a5
4002b4b0:	00c54783          	lbu	a5,12(a0)
4002b4b4:	00b66633          	or	a2,a2,a1
	event->poller = NULL;
4002b4b8:	00052423          	sw	zero,8(a0)
	event->type = type;
4002b4bc:	00f66633          	or	a2,a2,a5
4002b4c0:	00c52623          	sw	a2,12(a0)
	event->obj = obj;
4002b4c4:	00d52823          	sw	a3,16(a0)
}
4002b4c8:	00008067          	ret

4002b4cc <z_impl_k_poll>:
{
4002b4cc:	fd010113          	addi	sp,sp,-48
	struct z_poller *poller = &_current->poller;
4002b4d0:	400337b7          	lui	a5,0x40033
{
4002b4d4:	02912223          	sw	s1,36(sp)
	struct z_poller *poller = &_current->poller;
4002b4d8:	8707a483          	lw	s1,-1936(a5) # 40032870 <_kernel+0x8>
{
4002b4dc:	03212023          	sw	s2,32(sp)
4002b4e0:	01312e23          	sw	s3,28(sp)
4002b4e4:	01412c23          	sw	s4,24(sp)
4002b4e8:	01512a23          	sw	s5,20(sp)
4002b4ec:	02112623          	sw	ra,44(sp)
4002b4f0:	02812423          	sw	s0,40(sp)
	poller->is_polling = true;
4002b4f4:	00100793          	li	a5,1
	events_registered = register_events(events, num_events, poller,
4002b4f8:	00d66ab3          	or	s5,a2,a3
4002b4fc:	00d12623          	sw	a3,12(sp)
{
4002b500:	00060a13          	mv	s4,a2
	poller->is_polling = true;
4002b504:	06f48a23          	sb	a5,116(s1)
	poller->mode = MODE_POLL;
4002b508:	06f48aa3          	sb	a5,117(s1)
	events_registered = register_events(events, num_events, poller,
4002b50c:	001ab693          	seqz	a3,s5
4002b510:	07448613          	addi	a2,s1,116
{
4002b514:	00050913          	mv	s2,a0
	events_registered = register_events(events, num_events, poller,
4002b518:	bfdff0ef          	jal	ra,4002b114 <register_events>
4002b51c:	00050993          	mv	s3,a0
4002b520:	30047473          	csrrci	s0,mstatus,8
	if (!poller->is_polling) {
4002b524:	0744c783          	lbu	a5,116(s1)
4002b528:	00c12703          	lw	a4,12(sp)
4002b52c:	04079463          	bnez	a5,4002b574 <z_impl_k_poll+0xa8>
		clear_event_registrations(events, events_registered, key);
4002b530:	00040613          	mv	a2,s0
4002b534:	00050593          	mv	a1,a0
4002b538:	00090513          	mv	a0,s2
4002b53c:	ee5ff0ef          	jal	ra,4002b420 <clear_event_registrations>
	__asm__ volatile ("csrs mstatus, %0"
4002b540:	00847413          	andi	s0,s0,8
4002b544:	30042073          	csrs	mstatus,s0
		return 0;
4002b548:	00000413          	li	s0,0
}
4002b54c:	02c12083          	lw	ra,44(sp)
4002b550:	00040513          	mv	a0,s0
4002b554:	02812403          	lw	s0,40(sp)
4002b558:	02412483          	lw	s1,36(sp)
4002b55c:	02012903          	lw	s2,32(sp)
4002b560:	01c12983          	lw	s3,28(sp)
4002b564:	01812a03          	lw	s4,24(sp)
4002b568:	01412a83          	lw	s5,20(sp)
4002b56c:	03010113          	addi	sp,sp,48
4002b570:	00008067          	ret
	poller->is_polling = false;
4002b574:	06048a23          	sb	zero,116(s1)
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
4002b578:	000a9a63          	bnez	s5,4002b58c <z_impl_k_poll+0xc0>
4002b57c:	00847413          	andi	s0,s0,8
4002b580:	30042073          	csrs	mstatus,s0
		return -EAGAIN;
4002b584:	ff500413          	li	s0,-11
4002b588:	fc5ff06f          	j	4002b54c <z_impl_k_poll+0x80>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
4002b58c:	4003d637          	lui	a2,0x4003d
4002b590:	40033537          	lui	a0,0x40033
4002b594:	00040593          	mv	a1,s0
4002b598:	000a0693          	mv	a3,s4
4002b59c:	a2060613          	addi	a2,a2,-1504 # 4003ca20 <wait_q.0>
4002b5a0:	88c50513          	addi	a0,a0,-1908 # 4003288c <sched_spinlock>
4002b5a4:	889fe0ef          	jal	ra,40029e2c <z_pend_curr>
4002b5a8:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002b5ac:	300474f3          	csrrci	s1,mstatus,8
	clear_event_registrations(events, events_registered, key);
4002b5b0:	00048613          	mv	a2,s1
4002b5b4:	00098593          	mv	a1,s3
4002b5b8:	00090513          	mv	a0,s2
4002b5bc:	e65ff0ef          	jal	ra,4002b420 <clear_event_registrations>
	__asm__ volatile ("csrs mstatus, %0"
4002b5c0:	0084f493          	andi	s1,s1,8
4002b5c4:	3004a073          	csrs	mstatus,s1
	return swap_rc;
4002b5c8:	f85ff06f          	j	4002b54c <z_impl_k_poll+0x80>

4002b5cc <z_handle_obj_poll_events>:
{
4002b5cc:	00050793          	mv	a5,a0
	return list->head == list;
4002b5d0:	00052503          	lw	a0,0(a0)

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
4002b5d4:	02a78063          	beq	a5,a0,4002b5f4 <z_handle_obj_poll_events+0x28>
	sys_dnode_t *const prev = node->prev;
4002b5d8:	00452703          	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
4002b5dc:	00052783          	lw	a5,0(a0)
	prev->next = next;
4002b5e0:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
4002b5e4:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
4002b5e8:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
4002b5ec:	00052223          	sw	zero,4(a0)
		(void) signal_poll_event(poll_event, state);
4002b5f0:	d01ff06f          	j	4002b2f0 <signal_poll_event>
}
4002b5f4:	00008067          	ret

4002b5f8 <z_impl_k_poll_signal_init>:
	list->head = (sys_dnode_t *)list;
4002b5f8:	00a52023          	sw	a0,0(a0)
	list->tail = (sys_dnode_t *)list;
4002b5fc:	00a52223          	sw	a0,4(a0)
	sig->signaled = 0U;
4002b600:	00052423          	sw	zero,8(a0)
}
4002b604:	00008067          	ret

4002b608 <z_impl_k_poll_signal_reset>:
	sig->signaled = 0U;
4002b608:	00052423          	sw	zero,8(a0)
}
4002b60c:	00008067          	ret

4002b610 <z_impl_k_poll_signal_check>:
	*signaled = sig->signaled;
4002b610:	00852783          	lw	a5,8(a0)
4002b614:	00f5a023          	sw	a5,0(a1)
	*result = sig->result;
4002b618:	00c52783          	lw	a5,12(a0)
4002b61c:	00f62023          	sw	a5,0(a2)
}
4002b620:	00008067          	ret

4002b624 <z_impl_k_poll_signal_raise>:
{
4002b624:	ff010113          	addi	sp,sp,-16
4002b628:	00112623          	sw	ra,12(sp)
4002b62c:	00812423          	sw	s0,8(sp)
4002b630:	00912223          	sw	s1,4(sp)
4002b634:	00050793          	mv	a5,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
4002b638:	300474f3          	csrrci	s1,mstatus,8
	sig->signaled = 1U;
4002b63c:	00100713          	li	a4,1
	sig->result = result;
4002b640:	00b52623          	sw	a1,12(a0)
	sig->signaled = 1U;
4002b644:	00e52423          	sw	a4,8(a0)
	return list->head == list;
4002b648:	00052503          	lw	a0,0(a0)
	if (!sys_dlist_is_empty(list)) {
4002b64c:	02a79463          	bne	a5,a0,4002b674 <z_impl_k_poll_signal_raise+0x50>
	__asm__ volatile ("csrs mstatus, %0"
4002b650:	0084f493          	andi	s1,s1,8
4002b654:	3004a073          	csrs	mstatus,s1
		return 0;
4002b658:	00000413          	li	s0,0
}
4002b65c:	00c12083          	lw	ra,12(sp)
4002b660:	00040513          	mv	a0,s0
4002b664:	00812403          	lw	s0,8(sp)
4002b668:	00412483          	lw	s1,4(sp)
4002b66c:	01010113          	addi	sp,sp,16
4002b670:	00008067          	ret
	sys_dnode_t *const prev = node->prev;
4002b674:	00452703          	lw	a4,4(a0)
	sys_dnode_t *const next = node->next;
4002b678:	00052783          	lw	a5,0(a0)
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
4002b67c:	00100593          	li	a1,1
	prev->next = next;
4002b680:	00f72023          	sw	a5,0(a4)
	next->prev = prev;
4002b684:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
4002b688:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
4002b68c:	00052223          	sw	zero,4(a0)
4002b690:	c61ff0ef          	jal	ra,4002b2f0 <signal_poll_event>
4002b694:	00050413          	mv	s0,a0
	z_reschedule(&lock, key);
4002b698:	40033537          	lui	a0,0x40033
4002b69c:	00048593          	mv	a1,s1
4002b6a0:	88c50513          	addi	a0,a0,-1908 # 4003288c <sched_spinlock>
4002b6a4:	9b5fe0ef          	jal	ra,4002a058 <z_reschedule>
	return rc;
4002b6a8:	fb5ff06f          	j	4002b65c <z_impl_k_poll_signal_raise+0x38>

4002b6ac <z_heap_aligned_alloc>:
#include <string.h>
#include <zephyr/sys/math_extras.h>
#include <zephyr/sys/util.h>

static void *z_heap_aligned_alloc(struct k_heap *heap, size_t align, size_t size)
{
4002b6ac:	00060793          	mv	a5,a2
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
4002b6b0:	00460613          	addi	a2,a2,4
4002b6b4:	02f67063          	bgeu	a2,a5,4002b6d4 <z_heap_aligned_alloc+0x28>
	 * Merge a rewind bit with align value (see sys_heap_aligned_alloc()).
	 * This allows for storing the heap pointer right below the aligned
	 * boundary without wasting any memory.
	 */
	if (size_add_overflow(size, sizeof(heap_ref), &size)) {
		return NULL;
4002b6b8:	00000513          	li	a0,0
	mem = ++heap_ref;
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
		 "misaligned memory at %p (align = %zu)", mem, align);

	return mem;
}
4002b6bc:	00008067          	ret
		return NULL;
4002b6c0:	00000513          	li	a0,0
}
4002b6c4:	00c12083          	lw	ra,12(sp)
4002b6c8:	00812403          	lw	s0,8(sp)
4002b6cc:	01010113          	addi	sp,sp,16
4002b6d0:	00008067          	ret
{
4002b6d4:	ff010113          	addi	sp,sp,-16
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
4002b6d8:	00000693          	li	a3,0
4002b6dc:	00000713          	li	a4,0
4002b6e0:	0045e593          	ori	a1,a1,4
{
4002b6e4:	00812423          	sw	s0,8(sp)
4002b6e8:	00112623          	sw	ra,12(sp)
4002b6ec:	00050413          	mv	s0,a0
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
4002b6f0:	e48fc0ef          	jal	ra,40027d38 <k_heap_aligned_alloc>
	if (mem == NULL) {
4002b6f4:	fc0506e3          	beqz	a0,4002b6c0 <z_heap_aligned_alloc+0x14>
	*heap_ref = heap;
4002b6f8:	00852023          	sw	s0,0(a0)
	mem = ++heap_ref;
4002b6fc:	00450513          	addi	a0,a0,4
	return mem;
4002b700:	fc5ff06f          	j	4002b6c4 <z_heap_aligned_alloc+0x18>

4002b704 <k_free>:

void k_free(void *ptr)
{
	struct k_heap **heap_ref;

	if (ptr != NULL) {
4002b704:	00050863          	beqz	a0,4002b714 <k_free+0x10>
		heap_ref = ptr;
		ptr = --heap_ref;

		SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref, heap_ref);

		k_heap_free(*heap_ref, ptr);
4002b708:	ffc50593          	addi	a1,a0,-4
4002b70c:	ffc52503          	lw	a0,-4(a0)
4002b710:	f2cfc06f          	j	40027e3c <k_heap_free>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref, heap_ref);
	}
}
4002b714:	00008067          	ret

4002b718 <k_thread_system_pool_assign>:
	return ret;
}

void k_thread_system_pool_assign(struct k_thread *thread)
{
	thread->resource_pool = _SYSTEM_HEAP;
4002b718:	4003d7b7          	lui	a5,0x4003d
4002b71c:	a8878793          	addi	a5,a5,-1400 # 4003ca88 <_system_heap>
4002b720:	0cf52223          	sw	a5,196(a0)
}
4002b724:	00008067          	ret

4002b728 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
4002b728:	fe010113          	addi	sp,sp,-32
4002b72c:	00812c23          	sw	s0,24(sp)
4002b730:	00112e23          	sw	ra,28(sp)
4002b734:	00050413          	mv	s0,a0
4002b738:	00b12623          	sw	a1,12(sp)
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
4002b73c:	995fc0ef          	jal	ra,400280d0 <k_is_in_isr>
4002b740:	00c12603          	lw	a2,12(sp)
4002b744:	02051263          	bnez	a0,4002b768 <z_thread_aligned_alloc+0x40>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
4002b748:	400337b7          	lui	a5,0x40033
4002b74c:	8707a783          	lw	a5,-1936(a5) # 40032870 <_kernel+0x8>
4002b750:	0c47a783          	lw	a5,196(a5)
	}

	if (heap != NULL) {
4002b754:	00079e63          	bnez	a5,4002b770 <z_thread_aligned_alloc+0x48>
	} else {
		ret = NULL;
	}

	return ret;
}
4002b758:	01c12083          	lw	ra,28(sp)
4002b75c:	01812403          	lw	s0,24(sp)
4002b760:	02010113          	addi	sp,sp,32
4002b764:	00008067          	ret
		heap = _SYSTEM_HEAP;
4002b768:	4003d7b7          	lui	a5,0x4003d
4002b76c:	a8878793          	addi	a5,a5,-1400 # 4003ca88 <_system_heap>
		ret = z_heap_aligned_alloc(heap, align, size);
4002b770:	00040593          	mv	a1,s0
}
4002b774:	01812403          	lw	s0,24(sp)
4002b778:	01c12083          	lw	ra,28(sp)
		ret = z_heap_aligned_alloc(heap, align, size);
4002b77c:	00078513          	mv	a0,a5
}
4002b780:	02010113          	addi	sp,sp,32
		ret = z_heap_aligned_alloc(heap, align, size);
4002b784:	f29ff06f          	j	4002b6ac <z_heap_aligned_alloc>

4002b788 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
4002b788:	40031537          	lui	a0,0x40031
4002b78c:	98c50513          	addi	a0,a0,-1652 # 4003098c <states_str.1+0x20>
4002b790:	fa8d506f          	j	40000f38 <printk>

4002b794 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(void)
{
4002b794:	fe010113          	addi	sp,sp,-32
	struct k_work_queue_config cfg = {
4002b798:	400317b7          	lui	a5,0x40031
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
4002b79c:	400355b7          	lui	a1,0x40035
4002b7a0:	40031537          	lui	a0,0x40031
	struct k_work_queue_config cfg = {
4002b7a4:	9d078793          	addi	a5,a5,-1584 # 400309d0 <states_str.1+0x64>
	k_work_queue_start(&k_sys_work_q,
4002b7a8:	00810713          	addi	a4,sp,8
4002b7ac:	49850513          	addi	a0,a0,1176 # 40031498 <k_sys_work_q>
4002b7b0:	fff00693          	li	a3,-1
4002b7b4:	40000613          	li	a2,1024
4002b7b8:	37058593          	addi	a1,a1,880 # 40035370 <sys_work_q_stack>
{
4002b7bc:	00112e23          	sw	ra,28(sp)
	struct k_work_queue_config cfg = {
4002b7c0:	00f12423          	sw	a5,8(sp)
4002b7c4:	00010623          	sb	zero,12(sp)
	k_work_queue_start(&k_sys_work_q,
4002b7c8:	c5dfd0ef          	jal	ra,40029424 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
4002b7cc:	01c12083          	lw	ra,28(sp)
4002b7d0:	00000513          	li	a0,0
4002b7d4:	02010113          	addi	sp,sp,32
4002b7d8:	00008067          	ret
